               L"TAG_META"
#define TABLEID_TAG_META                                 (0x1acfa100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_TAG_META                             (0L)
#define ExtendedVersion_TAG_META                         (0L)

//-----------------Column Index Enums--------------   
enum eTAG_META {
    iTAG_META_Table,  
    iTAG_META_ColumnIndex,  
    iTAG_META_InternalName,  
    iTAG_META_PublicName,  
    iTAG_META_Value,  
    iTAG_META_ID,  
    cTAG_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tTAG_METARow {
         WCHAR *     pTable;
         ULONG *     pColumnIndex;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pValue;
         ULONG *     pID;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_ManagedWiring                           L"ManagedWiring"
#define TABLEID_ManagedWiring                            (0x64aecf00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_ManagedWiring                        (0L)
#define ExtendedVersion_ManagedWiring                    (0L)

//-----------------Column Index Enums--------------   
enum eManagedWiring {
    iManagedWiring_ConfigType,  
    iManagedWiring_Protocol,  
    iManagedWiring_Order,  
    iManagedWiring_InterceptorClass,  
    iManagedWiring_InterceptorType,  
    iManagedWiring_InterceptorFlags,  
    cManagedWiring_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tManagedWiringRow {
         WCHAR *     pConfigType;
         WCHAR *     pProtocol;
         ULONG *     pOrder;
         WCHAR *     pInterceptorClass;
         ULONG *     pInterceptorType;
         ULONG *     pInterceptorFlags;
};

enum eManagedWiring_InterceptorType {
    eManagedWiring_Reader         	=	       1,	//(0x00000001)
    eManagedWiring_Writer         	=	       2,	//(0x00000002)
    eManagedWiring_Transformer    	=	       3,	//(0x00000003)
    eManagedWiring_Merger         	=	       4,	//(0x00000004)
    eManagedWiring_Validator      	=	       5	//(0x00000005)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_SchemaFiles                             L"SchemaFiles"
#define TABLEID_SchemaFiles                              (0xc96f6700L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_SchemaFiles                          (0L)
#define ExtendedVersion_SchemaFiles                      (0L)

//-----------------Column Index Enums--------------   
enum eSchemaFiles {
    iSchemaFiles_Name,  
    iSchemaFiles_Path,  
    cSchemaFiles_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tSchemaFilesRow {
         WCHAR *     pName;
         WCHAR *     pPath;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_MEMORY_SHAPEABLE                        L"MEMORY_SHAPEABLE"
#define TABLEID_MEMORY_SHAPEABLE                         (0x6a2aa900L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_MEMORY_SHAPEABLE                     (0L)
#define ExtendedVersion_MEMORY_SHAPEABLE                 (0L)





//-------------------------------TableName-----------------------------   
#define wszTABLE_TRANSFORMER_META                        L"TRANSFORMER_META"
#define TABLEID_TRANSFORMER_META                         (0x1a1bba00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_TRANSFORMER_META                     (0L)
#define ExtendedVersion_TRANSFORMER_META                 (0L)

//-----------------Column Index Enums--------------   
enum eTRANSFORMER_META {
    iTRANSFORMER_META_TF_Protocol,  
    iTRANSFORMER_META_TF_Type,  
    iTRANSFORMER_META_DllName,  
    cTRANSFORMER_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tTRANSFORMER_METARow {
         WCHAR *     pTF_Protocol;
         ULONG *     pTF_Type;
         WCHAR *     pDllName;
};

enum eTRANSFORMER_META_TF_Type {
    eTRANSFORMER_META_FileTransformer	=	    4000,	//(0x00000fa0)
    eTRANSFORMER_META_WebHierarchyTransformer	=	    4001,	//(0x00000fa1)
    eTRANSFORMER_META_AppDomainTransformer	=	    4002,	//(0x00000fa2)
    eTRANSFORMER_META_LocalMachineTransformer	=	    4003,	//(0x00000fa3)
    eTRANSFORMER_META_ConfigTransformer	=	    4004,	//(0x00000fa4)
    eTRANSFORMER_META_ShellTransformer	=	    4005	//(0x00000fa5)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_ASAI_META                               L"ASAI_META"
#define TABLEID_ASAI_META                                (0x7a37a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_ASAI_META                            (0L)
#define ExtendedVersion_ASAI_META                        (0L)

//-----------------Column Index Enums--------------   
enum eASAI_META {
    iASAI_META_CollectionName,  
    iASAI_META_Namespace,  
    iASAI_META_AsaiPath,  
    iASAI_META_AsaiClass,  
    cASAI_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tASAI_METARow {
         WCHAR *     pCollectionName;
         WCHAR *     pNamespace;
         WCHAR *     pAsaiPath;
         WCHAR *     pAsaiClass;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_ASSOC_META                              L"ASSOC_META"
#define TABLEID_ASSOC_META                               (0xec7fa100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_ASSOC_META                           (0L)
#define ExtendedVersion_ASSOC_META                       (0L)

//-----------------Column Index Enums--------------   
enum eASSOC_META {
    iASSOC_META_Type,  
    iASSOC_META_TableName,  
    cASSOC_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tASSOC_METARow {
         WCHAR *     pType;
         WCHAR *     pTableName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_MetabaseBaseClass                       L"MetabaseBaseClass"
#define TABLEID_MetabaseBaseClass                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_MetabaseBaseClass                    (0L)
#define ExtendedVersion_MetabaseBaseClass                (0L)

//-----------------Column Index Enums--------------   
enum eMetabaseBaseClass {
    iMetabaseBaseClass_Location,  
    cMetabaseBaseClass_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tMetabaseBaseClassRow {
         WCHAR *     pLocation;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsConfigObject                         L"IIsConfigObject"
#define TABLEID_IIsConfigObject                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsConfigObject                      (0L)
#define ExtendedVersion_IIsConfigObject                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsConfigObject {
    iIIsConfigObject_KeyType,  
    iIIsConfigObject_AdminACL,  
    iIIsConfigObject_AdminACLBin,  
    iIIsConfigObject_AdminEmail,  
    iIIsConfigObject_AdminName,  
    iIIsConfigObject_AdminServer,  
    iIIsConfigObject_AllowAnonymous,  
    iIIsConfigObject_AllowClientPosts,  
    iIIsConfigObject_AllowControlMsgs,  
    iIIsConfigObject_AllowFeedPosts,  
    iIIsConfigObject_AllowKeepAlive,  
    iIIsConfigObject_AllowPathInfoForScriptMappings,  
    iIIsConfigObject_AlwaysUseSsl,  
    iIIsConfigObject_AnonymousOnly,  
    iIIsConfigObject_AnonymousPasswordSync,  
    iIIsConfigObject_AnonymousUserName,  
    iIIsConfigObject_AnonymousUserPass,  
    iIIsConfigObject_AppAllowClientDebug,  
    iIIsConfigObject_AppAllowDebugging,  
    iIIsConfigObject_AppFriendlyName,  
    iIIsConfigObject_AppIsolated,  
    iIIsConfigObject_AppOopRecoverLimit,  
    iIIsConfigObject_AppPackageID,  
    iIIsConfigObject_AppPackageName,  
    iIIsConfigObject_AppPoolFriendlyName,  
    iIIsConfigObject_AppPoolId,  
    iIIsConfigObject_AppPoolIdentityType,  
    iIIsConfigObject_AppPoolCommand,  
    iIIsConfigObject_AppPoolState,  
    iIIsConfigObject_AppPoolAutoStart,  
    iIIsConfigObject_AppRoot,  
    iIIsConfigObject_AppWamClsid,  
    iIIsConfigObject_ArticleTableFile,  
    iIIsConfigObject_AspAllowOutOfProcComponents,  
    iIIsConfigObject_AspAllowSessionState,  
    iIIsConfigObject_AspBufferingOn,  
    iIIsConfigObject_AspCodepage,  
    iIIsConfigObject_AspDiskTemplateCacheDirectory,  
    iIIsConfigObject_AspEnableApplicationRestart,  
    iIIsConfigObject_AspEnableAspHtmlFallback,  
    iIIsConfigObject_AspEnableChunkedEncoding,  
    iIIsConfigObject_AspEnableParentPaths,  
    iIIsConfigObject_AspEnableTypelibCache,  
    iIIsConfigObject_AspErrorsToNTLog,  
    iIIsConfigObject_AspExceptionCatchEnable,  
    iIIsConfigObject_AspKeepSessionIDSecure,  
    iIIsConfigObject_AspLCID,  
    iIIsConfigObject_AspLogErrorRequests,  
    iIIsConfigObject_AspMaxDiskTemplateCacheFiles,  
    iIIsConfigObject_AspPartitionID,  
    iIIsConfigObject_AspSxsName,  
    iIIsConfigObject_AspProcessorThreadMax,  
    iIIsConfigObject_AspQueueConnectionTestTime,  
    iIIsConfigObject_AspQueueTimeout,  
    iIIsConfigObject_AspRequestQueueMax,  
    iIIsConfigObject_AspScriptEngineCacheMax,  
    iIIsConfigObject_AspScriptErrorMessage,  
    iIIsConfigObject_AspScriptErrorSentToBrowser,  
    iIIsConfigObject_AspScriptFileCacheSize,  
    iIIsConfigObject_AspScriptLanguage,  
    iIIsConfigObject_AspScriptTimeout,  
    iIIsConfigObject_AspSessionMax,  
    iIIsConfigObject_AspSessionTimeout,  
    iIIsConfigObject_AspThreadGateEnabled,  
    iIIsConfigObject_AspThreadGateLoadHigh,  
    iIIsConfigObject_AspThreadGateLoadLow,  
    iIIsConfigObject_AspThreadGateSleepDelay,  
    iIIsConfigObject_AspThreadGateSleepMax,  
    iIIsConfigObject_AspThreadGateTimeSlice,  
    iIIsConfigObject_AspTrackThreadingModel,  
    iIIsConfigObject_AuthTurnList,  
    iIIsConfigObject_StandardAppModeEnabled,  
    iIIsConfigObject_BadMailDirectory,  
    iIIsConfigObject_CacheControlCustom,  
    iIIsConfigObject_CacheControlMaxAge,  
    iIIsConfigObject_CacheControlNoCache,  
    iIIsConfigObject_CacheISAPI,  
    iIIsConfigObject_CalLimitHttpError,  
    iIIsConfigObject_CalReserveTimeout,  
    iIIsConfigObject_CalSSLReserveTimeout,  
    iIIsConfigObject_CalVcPerConnect,  
    iIIsConfigObject_CertCheckMode,  
    iIIsConfigObject_CGITimeout,  
    iIIsConfigObject_ChangeNumber,  
    iIIsConfigObject_ClientPostHardLimit,  
    iIIsConfigObject_ClientPostSoftLimit,  
    iIIsConfigObject_ClusterEnabled,  
    iIIsConfigObject_CollectionComment,  
    iIIsConfigObject_ConnectionTimeout,  
    iIIsConfigObject_ContentIndexed,  
    iIIsConfigObject_CPUAction,  
    iIIsConfigObject_CPUAppEnabled,  
    iIIsConfigObject_CPUCGIEnabled,  
    iIIsConfigObject_CPULimit,  
    iIIsConfigObject_CPUCGILimit,  
    iIIsConfigObject_CPULimitLogEvent,  
    iIIsConfigObject_CPULimitPause,  
    iIIsConfigObject_CPULimitPriority,  
    iIIsConfigObject_CPULimitProcStop,  
    iIIsConfigObject_CPULimitsEnabled,  
    iIIsConfigObject_CPULoggingInterval,  
    iIIsConfigObject_CPUResetInterval,  
    iIIsConfigObject_CreateCGIWithNewConsole,  
    iIIsConfigObject_CreateProcessAsUser,  
    iIIsConfigObject_CSideEtrnDomains,  
    iIIsConfigObject_CustomErrorDescriptions,  
    iIIsConfigObject_DefaultDoc,  
    iIIsConfigObject_DefaultDocFooter,  
    iIIsConfigObject_DefaultDomain,  
    iIIsConfigObject_DefaultLogonDomain,  
    iIIsConfigObject_DefaultModeratorDomain,  
    iIIsConfigObject_DirectoryLevelsToScan,  
    iIIsConfigObject_DisablePublishing,  
    iIIsConfigObject_DisableNewNews,  
    iIIsConfigObject_DisableSocketPooling,  
    iIIsConfigObject_DisallowOverlappingRotation,  
    iIIsConfigObject_DisallowRotationOnConfigChange,  
    iIIsConfigObject_DomainRouting,  
    iIIsConfigObject_DoMasquerade,  
    iIIsConfigObject_DontLog,  
    iIIsConfigObject_DownlevelAdminInstance,  
    iIIsConfigObject_DropDirectory,  
    iIIsConfigObject_HistoryMajorVersionNumber,  
    iIIsConfigObject_XMLSchemaTimeStamp,  
    iIIsConfigObject_BINSchemaTimeStamp,  
    iIIsConfigObject_EnableHistory,  
    iIIsConfigObject_EnableDocFooter,  
    iIIsConfigObject_EnableEditWhileRunning,  
    iIIsConfigObject_EnableReverseDns,  
    iIIsConfigObject_EnableReverseDnsLookup,  
    iIIsConfigObject_EtrnDays,  
    iIIsConfigObject_ExitMessage,  
    iIIsConfigObject_FeedPostHardLimit,  
    iIIsConfigObject_FeedPostSoftLimit,  
    iIIsConfigObject_FeedReportPeriod,  
    iIIsConfigObject_FilterDescription,  
    iIIsConfigObject_FilterEnabled,  
    iIIsConfigObject_FilterLoadOrder,  
    iIIsConfigObject_FilterPath,  
    iIIsConfigObject_FilterState,  
    iIIsConfigObject_FrontPageWeb,  
    iIIsConfigObject_FtpDirBrowseShowLongDate,  
    iIIsConfigObject_FullyQualifiedDomainName,  
    iIIsConfigObject_BannerMessage,  
    iIIsConfigObject_UserIsolationMode,  
    iIIsConfigObject_FtpLogInUtf8,  
    iIIsConfigObject_GreetingMessage,  
    iIIsConfigObject_GroupHelpFile,  
    iIIsConfigObject_GroupListFile,  
    iIIsConfigObject_GroupVarListFile,  
    iIIsConfigObject_HeaderWaitTimeout,  
    iIIsConfigObject_HcCacheControlHeader,  
    iIIsConfigObject_HcCompressionBufferSize,  
    iIIsConfigObject_HcCompressionDirectory,  
    iIIsConfigObject_HcCompressionDll,  
    iIIsConfigObject_HcCreateFlags,  
    iIIsConfigObject_HcDoDiskSpaceLimiting,  
    iIIsConfigObject_HcDoDynamicCompression,  
    iIIsConfigObject_HcDoOnDemandCompression,  
    iIIsConfigObject_HcDoStaticCompression,  
    iIIsConfigObject_HcDynamicCompressionLevel,  
    iIIsConfigObject_HcExpiresHeader,  
    iIIsConfigObject_HcFileExtensions,  
    iIIsConfigObject_HcFilesDeletedPerDiskFree,  
    iIIsConfigObject_HcIoBufferSize,  
    iIIsConfigObject_HcMaxDiskSpaceUsage,  
    iIIsConfigObject_HcMaxQueueLength,  
    iIIsConfigObject_HcMimeType,  
    iIIsConfigObject_HcMinFileSizeForComp,  
    iIIsConfigObject_HcNoCompressionForHttp10,  
    iIIsConfigObject_HcNoCompressionForProxies,  
    iIIsConfigObject_HcNoCompressionForRange,  
    iIIsConfigObject_HcOnDemandCompLevel,  
    iIIsConfigObject_HcPriority,  
    iIIsConfigObject_HcScriptFileExtensions,  
    iIIsConfigObject_HcSendCacheHeaders,  
    iIIsConfigObject_HistoryTableFile,  
    iIIsConfigObject_HonorClientMsgIds,  
    iIIsConfigObject_HopCount,  
    iIIsConfigObject_HttpCustomHeaders,  
    iIIsConfigObject_HttpErrors,  
    iIIsConfigObject_HttpExpires,  
    iIIsConfigObject_HttpPics,  
    iIIsConfigObject_HttpRedirect,  
    iIIsConfigObject_IdleTimeout,  
    iIIsConfigObject_IgnoreTranslate,  
    iIIsConfigObject_ImapClearTextProvider,  
    iIIsConfigObject_ImapDefaultDomain,  
    iIIsConfigObject_ImapDsAccount,  
    iIIsConfigObject_ImapDsBindType,  
    iIIsConfigObject_ImapDsDataDirectory,  
    iIIsConfigObject_ImapDsDefaultMailRoot,  
    iIIsConfigObject_ImapDsHost,  
    iIIsConfigObject_ImapDsNamingContext,  
    iIIsConfigObject_ImapDsPassword,  
    iIIsConfigObject_ImapDsSchemaType,  
    iIIsConfigObject_ImapExpireDelay,  
    iIIsConfigObject_ImapExpireMail,  
    iIIsConfigObject_ImapExpireStart,  
    iIIsConfigObject_ImapMailExpirationTime,  
    iIIsConfigObject_ImapRoutingDll,  
    iIIsConfigObject_ImapRoutingSources,  
    iIIsConfigObject_ImapRoutingTableType,  
    iIIsConfigObject_ImapServiceVersion,  
    iIIsConfigObject_InProcessIsapiApps,  
    iIIsConfigObject_IPSecurity,  
    iIIsConfigObject_LimitRemoteConnections,  
    iIIsConfigObject_ListFile,  
    iIIsConfigObject_LocalRetryAttempts,  
    iIIsConfigObject_LocalRetryInterval,  
    iIIsConfigObject_LogAnonymous,  
    iIIsConfigObject_LogCustomPropertyDataType,  
    iIIsConfigObject_LogCustomPropertyHeader,  
    iIIsConfigObject_LogCustomPropertyID,  
    iIIsConfigObject_LogCustomPropertyMask,  
    iIIsConfigObject_LogCustomPropertyName,  
    iIIsConfigObject_LogCustomPropertyServicesString,  
    iIIsConfigObject_LogFileDirectory,  
    iIIsConfigObject_LogFileLocaltimeRollover,  
    iIIsConfigObject_LogFilePeriod,  
    iIIsConfigObject_LogFileTruncateSize,  
    iIIsConfigObject_LogInUTF8,  
    iIIsConfigObject_LogModuleId,  
    iIIsConfigObject_LogModuleList,  
    iIIsConfigObject_LogModuleUiId,  
    iIIsConfigObject_LogNonAnonymous,  
    iIIsConfigObject_LogOdbcDataSource,  
    iIIsConfigObject_LogOdbcPassword,  
    iIIsConfigObject_LogOdbcTableName,  
    iIIsConfigObject_LogOdbcUserName,  
    iIIsConfigObject_LogonMethod,  
    iIIsConfigObject_LogPluginClsid,  
    iIIsConfigObject_LogType,  
    iIIsConfigObject_MasqueradeDomain,  
    iIIsConfigObject_MetabaseComments,  
    iIIsConfigObject_MaxErrorFiles,  
    iIIsConfigObject_MaxHistoryFiles,  
    iIIsConfigObject_MaxBandwidth,  
    iIIsConfigObject_MaxBandwidthBlocked,  
    iIIsConfigObject_MaxBatchedMessages,  
    iIIsConfigObject_MaxClientsMessage,  
    iIIsConfigObject_MaxConnections,  
    iIIsConfigObject_MaxEndpointConnections,  
    iIIsConfigObject_MaxGlobalBandwidth,  
    iIIsConfigObject_MaxGlobalConnections,  
    iIIsConfigObject_MaxMessageSize,  
    iIIsConfigObject_MaxOutConnections,  
    iIIsConfigObject_MaxOutConnectionsPerDomain,  
    iIIsConfigObject_MaxProcesses,  
    iIIsConfigObject_MaxRecipients,  
    iIIsConfigObject_MaxSearchResults,  
    iIIsConfigObject_MaxSessionSize,  
    iIIsConfigObject_MaxSmtpLogonErrors,  
    iIIsConfigObject_MD_0,  
    iIIsConfigObject_MD_1001,  
    iIIsConfigObject_PostmasterName,  
    iIIsConfigObject_PostmasterEmail,  
    iIIsConfigObject_LocalDomains,  
    iIIsConfigObject_ShutdownLatency,  
    iIIsConfigObject_MD_APP_LAST_OUTPROC_PID,  
    iIIsConfigObject_MD_AUTH_CHANGE_URL,  
    iIIsConfigObject_MD_AUTH_EXPIRED_UNSECUREURL,  
    iIIsConfigObject_MD_AUTH_EXPIRED_URL,  
    iIIsConfigObject_MD_AUTH_NOTIFY_PWD_EXP_URL,  
    iIIsConfigObject_MD_AUTH_NOTIFY_PWS_EXP_UNSECUREURL,  
    iIIsConfigObject_MD_ETAG_CHANGENUMBER,  
    iIIsConfigObject_MD_IISADMIN_EXTENSIONS,  
    iIIsConfigObject_MD_ISM_ACCESS_CHECK,  
    iIIsConfigObject_MD_METADATA_ID_REGISTRATION,  
    iIIsConfigObject_MD_SERVER_CAPABILITIES,  
    iIIsConfigObject_ServerCommand,  
    iIIsConfigObject_MD_SERVER_PLATFORM,  
    iIIsConfigObject_MajorIIsVersionNumber,  
    iIIsConfigObject_MinorIIsVersionNumber,  
    iIIsConfigObject_MimeMap,  
    iIIsConfigObject_MinFileKbSec,  
    iIIsConfigObject_ModeratorFile,  
    iIIsConfigObject_MSDOSDirOutput,  
    iIIsConfigObject_NetLogonWorkstation,  
    iIIsConfigObject_NntpCommandLogMask,  
    iIIsConfigObject_NewsDropDirectory,  
    iIIsConfigObject_NewsFailedPickupDirectory,  
    iIIsConfigObject_NewsPickupDirectory,  
    iIIsConfigObject_NntpServiceVersion,  
    iIIsConfigObject_NntpUucpName,  
    iIIsConfigObject_NotDeletable,  
    iIIsConfigObject_NTAuthenticationProviders,  
    iIIsConfigObject_OrphanAction,  
    iIIsConfigObject_OrphanActionExe,  
    iIIsConfigObject_OrphanActionParams,  
    iIIsConfigObject_OrphanWorkerProcess,  
    iIIsConfigObject_PasswordCacheTTL,  
    iIIsConfigObject_PasswordExpirePrenotifyDays,  
    iIIsConfigObject_Path,  
    iIIsConfigObject_PeriodicRestartRequests,  
    iIIsConfigObject_PeriodicRestartSchedule,  
    iIIsConfigObject_PeriodicRestartTime,  
    iIIsConfigObject_PeriodicRestartConnections,  
    iIIsConfigObject_PeriodicRestartMemory,  
    iIIsConfigObject_PickupDirectory,  
    iIIsConfigObject_PingingEnabled,  
    iIIsConfigObject_PingInterval,  
    iIIsConfigObject_PingResponseTime,  
    iIIsConfigObject_PoolIdcTimeout,  
    iIIsConfigObject_Pop3ClearTextProvider,  
    iIIsConfigObject_Pop3DefaultDomain,  
    iIIsConfigObject_Pop3DsAccount,  
    iIIsConfigObject_Pop3DsBindType,  
    iIIsConfigObject_Pop3DsDataDirectory,  
    iIIsConfigObject_Pop3DsDefaultMailRoot,  
    iIIsConfigObject_Pop3DsHost,  
    iIIsConfigObject_Pop3DsNamingContext,  
    iIIsConfigObject_Pop3DsPassword,  
    iIIsConfigObject_Pop3DsSchemaType,  
    iIIsConfigObject_Pop3ExpireDelay,  
    iIIsConfigObject_Pop3ExpireMail,  
    iIIsConfigObject_Pop3ExpireStart,  
    iIIsConfigObject_Pop3MailExpirationTime,  
    iIIsConfigObject_Pop3RoutingDll,  
    iIIsConfigObject_Pop3RoutingSources,  
    iIIsConfigObject_Pop3RoutingTableType,  
    iIIsConfigObject_Pop3ServiceVersion,  
    iIIsConfigObject_PrettyNamesFile,  
    iIIsConfigObject_NntpClearTextProvider,  
    iIIsConfigObject_ProcessNTCRIfLoggedOn,  
    iIIsConfigObject_PutReadSize,  
    iIIsConfigObject_QueueDirectory,  
    iIIsConfigObject_RapidFailProtection,  
    iIIsConfigObject_RapidFailProtectionInterval,  
    iIIsConfigObject_RapidFailProtectionMaxCrashes,  
    iIIsConfigObject_Realm,  
    iIIsConfigObject_RedirectHeaders,  
    iIIsConfigObject_RelayForAuth,  
    iIIsConfigObject_RelayIpList,  
    iIIsConfigObject_RemoteRetryAttempts,  
    iIIsConfigObject_RemoteRetryInterval,  
    iIIsConfigObject_RemoteSmtpPort,  
    iIIsConfigObject_RemoteSmtpSecurePort,  
    iIIsConfigObject_RemoteTimeout,  
    iIIsConfigObject_RevocationFreshnessTime,  
    iIIsConfigObject_RevocationURLRetrievalTimeout,  
    iIIsConfigObject_RouteAction,  
    iIIsConfigObject_RouteActionString,  
    iIIsConfigObject_RoutePassword,  
    iIIsConfigObject_RouteUserName,  
    iIIsConfigObject_RoutingDll,  
    iIIsConfigObject_RoutingSources,  
    iIIsConfigObject_RunAsLocalSystem,  
    iIIsConfigObject_SaslLogonDomain,  
    iIIsConfigObject_ScriptMaps,  
    iIIsConfigObject_SecureBindings,  
    iIIsConfigObject_SendBadTo,  
    iIIsConfigObject_SendNdrTo,  
    iIIsConfigObject_ServerAutoStart,  
    iIIsConfigObject_ServerBindings,  
    iIIsConfigObject_ServerComment,  
    iIIsConfigObject_ServerListenBacklog,  
    iIIsConfigObject_ServerListenTimeout,  
    iIIsConfigObject_ServerSize,  
    iIIsConfigObject_ServerState,  
    iIIsConfigObject_SessionKey,  
    iIIsConfigObject_ShouldDeliver,  
    iIIsConfigObject_ShutdownTimeLimit,  
    iIIsConfigObject_SmartHost,  
    iIIsConfigObject_SmartHostType,  
    iIIsConfigObject_SMPAffinitized,  
    iIIsConfigObject_SMPProcessorAffinityMask,  
    iIIsConfigObject_SmtpAdvQueueDll,  
    iIIsConfigObject_SmtpAuthTimeout,  
    iIIsConfigObject_SmtpBdatTimeout,  
    iIIsConfigObject_SmtpClearTextProvider,  
    iIIsConfigObject_SmtpCommandLogMask,  
    iIIsConfigObject_SmtpConnectTimeout,  
    iIIsConfigObject_SmtpDataTimeout,  
    iIIsConfigObject_SmtpDsAccount,  
    iIIsConfigObject_SmtpDsBindType,  
    iIIsConfigObject_SmtpDsDataDirectory,  
    iIIsConfigObject_SmtpDsDefaultMailRoot,  
    iIIsConfigObject_SmtpDsDomain,  
    iIIsConfigObject_SmtpDsFlags,  
    iIIsConfigObject_SmtpDsHost,  
    iIIsConfigObject_SmtpDsNamingContext,  
    iIIsConfigObject_SmtpDSNLanguageID,  
    iIIsConfigObject_SmtpDSNOptions,  
    iIIsConfigObject_SmtpDsPassword,  
    iIIsConfigObject_SmtpDsPort,  
    iIIsConfigObject_SmtpDsSchemaType,  
    iIIsConfigObject_SmtpDsUseCat,  
    iIIsConfigObject_SmtpFlushMailFile,  
    iIIsConfigObject_SmtpHeloTimeout,  
    iIIsConfigObject_SmtpInboundCommandSupportOptions,  
    iIIsConfigObject_SmtpLocalDelayExpireMinutes,  
    iIIsConfigObject_SmtpLocalNDRExpireMinutes,  
    iIIsConfigObject_SmtpMailFromTimeout,  
    iIIsConfigObject_SmtpOutboundCommandSupportOptions,  
    iIIsConfigObject_SmtpRcptToTimeout,  
    iIIsConfigObject_SmtpRemoteDelayExpireMinutes,  
    iIIsConfigObject_SmtpRemoteNDRExpireMinutes,  
    iIIsConfigObject_SmtpRemoteProgressiveRetry,  
    iIIsConfigObject_SmtpRemoteRetryThreshold,  
    iIIsConfigObject_SmtpRoutingTableType,  
    iIIsConfigObject_SmtpRsetTimeout,  
    iIIsConfigObject_SmtpSaslTimeout,  
    iIIsConfigObject_SmtpServer,  
    iIIsConfigObject_SmtpServiceVersion,  
    iIIsConfigObject_SmtpTurnTimeout,  
    iIIsConfigObject_SSIExecDisable,  
    iIIsConfigObject_SSLCertHash,  
    iIIsConfigObject_SSLStoreName,  
    iIIsConfigObject_SslUseDsMapper,  
    iIIsConfigObject_StartupTimeLimit,  
    iIIsConfigObject_AppPoolQueueLength,  
    iIIsConfigObject_UNCAuthenticationPassThrough,  
    iIIsConfigObject_UNCPassword,  
    iIIsConfigObject_UNCUserName,  
    iIIsConfigObject_UploadReadAheadSize,  
    iIIsConfigObject_UseDigestSSP,  
    iIIsConfigObject_UseHostName,  
    iIIsConfigObject_VrDriverClsid,  
    iIIsConfigObject_VrDriverProgid,  
    iIIsConfigObject_FsPropertyPath,  
    iIIsConfigObject_VrUseAccount,  
    iIIsConfigObject_VrDoExpire,  
    iIIsConfigObject_ExMdbGuid,  
    iIIsConfigObject_VrOwnModerator,  
    iIIsConfigObject_ArticleTimeLimit,  
    iIIsConfigObject_HistoryExpiration,  
    iIIsConfigObject_NewsCrawlerTime,  
    iIIsConfigObject_NntpOrganization,  
    iIIsConfigObject_SmtpUseTcpDns,  
    iIIsConfigObject_SmtpDotStuffPickupDirFiles,  
    iIIsConfigObject_SmtpDomainValidationFlags,  
    iIIsConfigObject_SmtpSSLRequireTrustedCA,  
    iIIsConfigObject_SmtpSSLCertHostnameValidation,  
    iIIsConfigObject_MaxMailObjects,  
    iIIsConfigObject_ShouldPickupMail,  
    iIIsConfigObject_MaxDirChangeIOSize,  
    iIIsConfigObject_NameResolutionType,  
    iIIsConfigObject_MaxSmtpErrors,  
    iIIsConfigObject_ShouldPipelineIn,  
    iIIsConfigObject_ShouldPipelineOut,  
    iIIsConfigObject_ConnectResponse,  
    iIIsConfigObject_UpdatedFQDN,  
    iIIsConfigObject_UpdatedDefaultDomain,  
    iIIsConfigObject_EtrnSubdomains,  
    iIIsConfigObject_SmtpMaxRemoteQThreads,  
    iIIsConfigObject_SmtpDisableRelay,  
    iIIsConfigObject_SmtpHeloNoDomain,  
    iIIsConfigObject_SmtpMailNoHelo,  
    iIIsConfigObject_SmtpAqueueWait,  
    iIIsConfigObject_AddNoHeaders,  
    iIIsConfigObject_SmtpEventlogLevel,  
    iIIsConfigObject_FeedServerName,  
    iIIsConfigObject_FeedType,  
    iIIsConfigObject_FeedNewsgroups,  
    iIIsConfigObject_FeedSecurityType,  
    iIIsConfigObject_FeedAuthenticationType,  
    iIIsConfigObject_FeedAccountName,  
    iIIsConfigObject_FeedPassword,  
    iIIsConfigObject_FeedStartTimeHigh,  
    iIIsConfigObject_FeedStartTimeLow,  
    iIIsConfigObject_FeedInterval,  
    iIIsConfigObject_FeedAllowControlMsgs,  
    iIIsConfigObject_FeedCreateAutomatically,  
    iIIsConfigObject_FeedDisabled,  
    iIIsConfigObject_FeedDistribution,  
    iIIsConfigObject_FeedConcurrentSessions,  
    iIIsConfigObject_FeedMaxConnectionAttempts,  
    iIIsConfigObject_FeedUucpName,  
    iIIsConfigObject_FeedTempDirectory,  
    iIIsConfigObject_FeedNextPullHigh,  
    iIIsConfigObject_FeedNextPullLow,  
    iIIsConfigObject_FeedPeerTempDirectory,  
    iIIsConfigObject_FeedPeerGapSize,  
    iIIsConfigObject_FeedOutgoingPort,  
    iIIsConfigObject_FeedFeedpairId,  
    iIIsConfigObject_FeedHandshake,  
    iIIsConfigObject_FeedAdminError,  
    iIIsConfigObject_FeedErrParmMask,  
    iIIsConfigObject_ExpireSpace,  
    iIIsConfigObject_ExpireTime,  
    iIIsConfigObject_ExpireNewsgroups,  
    iIIsConfigObject_ExpirePolicyName,  
    iIIsConfigObject_DoStaticCompression,  
    iIIsConfigObject_DoDynamicCompression,  
    iIIsConfigObject_WAMUserName,  
    iIIsConfigObject_WAMUserPass,  
    iIIsConfigObject_Win32Error,  
    iIIsConfigObject_XoverTableFile,  
    iIIsConfigObject_StopListening,  
    iIIsConfigObject_DavEnabled,  
    iIIsConfigObject_AccessFlags,  
    iIIsConfigObject_AccessSSLFlags,  
    iIIsConfigObject_AuthFlags,  
    iIIsConfigObject_AuthPersistence,  
    iIIsConfigObject_CPULoggingMask,  
    iIIsConfigObject_CPULoggingOptions,  
    iIIsConfigObject_DirBrowseFlags,  
    iIIsConfigObject_FilterFlags,  
    iIIsConfigObject_LogExtFileFlags,  
    iIIsConfigObject_PasswordChangeFlags,  
    iIIsConfigObject_ServerConfigFlags,  
    iIIsConfigObject_AspAppServiceFlags,  
    cIIsConfigObject_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsConfigObjectRow {
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         WCHAR *     pAdminEmail;
         WCHAR *     pAdminName;
         WCHAR *     pAdminServer;
         ULONG *     pAllowAnonymous;
         ULONG *     pAllowClientPosts;
         ULONG *     pAllowControlMsgs;
         ULONG *     pAllowFeedPosts;
         ULONG *     pAllowKeepAlive;
         ULONG *     pAllowPathInfoForScriptMappings;
         ULONG *     pAlwaysUseSsl;
         ULONG *     pAnonymousOnly;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAppAllowClientDebug;
         ULONG *     pAppAllowDebugging;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppIsolated;
         ULONG *     pAppOopRecoverLimit;
         WCHAR *     pAppPackageID;
         WCHAR *     pAppPackageName;
         WCHAR *     pAppPoolFriendlyName;
         WCHAR *     pAppPoolId;
         ULONG *     pAppPoolIdentityType;
         ULONG *     pAppPoolCommand;
         ULONG *     pAppPoolState;
         ULONG *     pAppPoolAutoStart;
         WCHAR *     pAppRoot;
         WCHAR *     pAppWamClsid;
         WCHAR *     pArticleTableFile;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspAllowSessionState;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspCodepage;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pAspLCID;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspScriptEngineCacheMax;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspScriptErrorSentToBrowser;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionMax;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspThreadGateEnabled;
         ULONG *     pAspThreadGateLoadHigh;
         ULONG *     pAspThreadGateLoadLow;
         ULONG *     pAspThreadGateSleepDelay;
         ULONG *     pAspThreadGateSleepMax;
         ULONG *     pAspThreadGateTimeSlice;
         ULONG *     pAspTrackThreadingModel;
         WCHAR *     pAuthTurnList;
         ULONG *     pStandardAppModeEnabled;
         WCHAR *     pBadMailDirectory;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         ULONG *     pCacheISAPI;
         ULONG *     pCalLimitHttpError;
         ULONG *     pCalReserveTimeout;
         ULONG *     pCalSSLReserveTimeout;
         ULONG *     pCalVcPerConnect;
         ULONG *     pCertCheckMode;
         ULONG *     pCGITimeout;
         ULONG *     pChangeNumber;
         ULONG *     pClientPostHardLimit;
         ULONG *     pClientPostSoftLimit;
         ULONG *     pClusterEnabled;
         WCHAR *     pCollectionComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pContentIndexed;
         ULONG *     pCPUAction;
         ULONG *     pCPUAppEnabled;
         ULONG *     pCPUCGIEnabled;
         ULONG *     pCPULimit;
         ULONG *     pCPUCGILimit;
         ULONG *     pCPULimitLogEvent;
         ULONG *     pCPULimitPause;
         ULONG *     pCPULimitPriority;
         ULONG *     pCPULimitProcStop;
         ULONG *     pCPULimitsEnabled;
         ULONG *     pCPULoggingInterval;
         ULONG *     pCPUResetInterval;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pCreateProcessAsUser;
         WCHAR *     pCSideEtrnDomains;
         WCHAR *     pCustomErrorDescriptions;
         WCHAR *     pDefaultDoc;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pDefaultDomain;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pDefaultModeratorDomain;
         ULONG *     pDirectoryLevelsToScan;
         ULONG *     pDisablePublishing;
         ULONG *     pDisableNewNews;
         ULONG *     pDisableSocketPooling;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         WCHAR *     pDomainRouting;
         ULONG *     pDoMasquerade;
         ULONG *     pDontLog;
         ULONG *     pDownlevelAdminInstance;
         WCHAR *     pDropDirectory;
         ULONG *     pHistoryMajorVersionNumber;
 unsigned char *     pXMLSchemaTimeStamp;
 unsigned char *     pBINSchemaTimeStamp;
         ULONG *     pEnableHistory;
         ULONG *     pEnableDocFooter;
         ULONG *     pEnableEditWhileRunning;
         ULONG *     pEnableReverseDns;
         ULONG *     pEnableReverseDnsLookup;
         ULONG *     pEtrnDays;
         WCHAR *     pExitMessage;
         ULONG *     pFeedPostHardLimit;
         ULONG *     pFeedPostSoftLimit;
         ULONG *     pFeedReportPeriod;
         WCHAR *     pFilterDescription;
         ULONG *     pFilterEnabled;
         WCHAR *     pFilterLoadOrder;
         WCHAR *     pFilterPath;
         ULONG *     pFilterState;
         ULONG *     pFrontPageWeb;
         ULONG *     pFtpDirBrowseShowLongDate;
         WCHAR *     pFullyQualifiedDomainName;
         WCHAR *     pBannerMessage;
         ULONG *     pUserIsolationMode;
         ULONG *     pFtpLogInUtf8;
         WCHAR *     pGreetingMessage;
         WCHAR *     pGroupHelpFile;
         WCHAR *     pGroupListFile;
         WCHAR *     pGroupVarListFile;
         ULONG *     pHeaderWaitTimeout;
         WCHAR *     pHcCacheControlHeader;
         ULONG *     pHcCompressionBufferSize;
         WCHAR *     pHcCompressionDirectory;
         WCHAR *     pHcCompressionDll;
         ULONG *     pHcCreateFlags;
         ULONG *     pHcDoDiskSpaceLimiting;
         ULONG *     pHcDoDynamicCompression;
         ULONG *     pHcDoOnDemandCompression;
         ULONG *     pHcDoStaticCompression;
         ULONG *     pHcDynamicCompressionLevel;
         WCHAR *     pHcExpiresHeader;
         WCHAR *     pHcFileExtensions;
         ULONG *     pHcFilesDeletedPerDiskFree;
         ULONG *     pHcIoBufferSize;
         ULONG *     pHcMaxDiskSpaceUsage;
         ULONG *     pHcMaxQueueLength;
         WCHAR *     pHcMimeType;
         ULONG *     pHcMinFileSizeForComp;
         ULONG *     pHcNoCompressionForHttp10;
         ULONG *     pHcNoCompressionForProxies;
         ULONG *     pHcNoCompressionForRange;
         ULONG *     pHcOnDemandCompLevel;
         ULONG *     pHcPriority;
         WCHAR *     pHcScriptFileExtensions;
         ULONG *     pHcSendCacheHeaders;
         WCHAR *     pHistoryTableFile;
         ULONG *     pHonorClientMsgIds;
         ULONG *     pHopCount;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpRedirect;
         ULONG *     pIdleTimeout;
         ULONG *     pIgnoreTranslate;
         WCHAR *     pImapClearTextProvider;
         WCHAR *     pImapDefaultDomain;
         WCHAR *     pImapDsAccount;
         WCHAR *     pImapDsBindType;
         WCHAR *     pImapDsDataDirectory;
         WCHAR *     pImapDsDefaultMailRoot;
         WCHAR *     pImapDsHost;
         WCHAR *     pImapDsNamingContext;
         WCHAR *     pImapDsPassword;
         WCHAR *     pImapDsSchemaType;
         ULONG *     pImapExpireDelay;
         ULONG *     pImapExpireMail;
         ULONG *     pImapExpireStart;
         ULONG *     pImapMailExpirationTime;
         WCHAR *     pImapRoutingDll;
         WCHAR *     pImapRoutingSources;
         WCHAR *     pImapRoutingTableType;
         ULONG *     pImapServiceVersion;
         WCHAR *     pInProcessIsapiApps;
 unsigned char *     pIPSecurity;
         ULONG *     pLimitRemoteConnections;
         WCHAR *     pListFile;
         ULONG *     pLocalRetryAttempts;
         ULONG *     pLocalRetryInterval;
         ULONG *     pLogAnonymous;
         ULONG *     pLogCustomPropertyDataType;
         WCHAR *     pLogCustomPropertyHeader;
         ULONG *     pLogCustomPropertyID;
         ULONG *     pLogCustomPropertyMask;
         WCHAR *     pLogCustomPropertyName;
         WCHAR *     pLogCustomPropertyServicesString;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogInUTF8;
         WCHAR *     pLogModuleId;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogModuleUiId;
         ULONG *     pLogNonAnonymous;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcPassword;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         ULONG *     pLogonMethod;
         WCHAR *     pLogPluginClsid;
         ULONG *     pLogType;
         WCHAR *     pMasqueradeDomain;
         ULONG *     pMetabaseComments;
         ULONG *     pMaxErrorFiles;
         ULONG *     pMaxHistoryFiles;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxBandwidthBlocked;
         ULONG *     pMaxBatchedMessages;
         WCHAR *     pMaxClientsMessage;
         ULONG *     pMaxConnections;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pMaxGlobalBandwidth;
         ULONG *     pMaxGlobalConnections;
         ULONG *     pMaxMessageSize;
         ULONG *     pMaxOutConnections;
         ULONG *     pMaxOutConnectionsPerDomain;
         ULONG *     pMaxProcesses;
         ULONG *     pMaxRecipients;
         ULONG *     pMaxSearchResults;
         ULONG *     pMaxSessionSize;
         ULONG *     pMaxSmtpLogonErrors;
         WCHAR *     pMD_0;
         ULONG *     pMD_1001;
         WCHAR *     pPostmasterName;
         WCHAR *     pPostmasterEmail;
         WCHAR *     pLocalDomains;
         ULONG *     pShutdownLatency;
         WCHAR *     pMD_APP_LAST_OUTPROC_PID;
         WCHAR *     pMD_AUTH_CHANGE_URL;
         WCHAR *     pMD_AUTH_EXPIRED_UNSECUREURL;
         WCHAR *     pMD_AUTH_EXPIRED_URL;
         WCHAR *     pMD_AUTH_NOTIFY_PWD_EXP_URL;
         WCHAR *     pMD_AUTH_NOTIFY_PWS_EXP_UNSECUREURL;
         ULONG *     pMD_ETAG_CHANGENUMBER;
         WCHAR *     pMD_IISADMIN_EXTENSIONS;
         ULONG *     pMD_ISM_ACCESS_CHECK;
         WCHAR *     pMD_METADATA_ID_REGISTRATION;
         ULONG *     pMD_SERVER_CAPABILITIES;
         ULONG *     pServerCommand;
         ULONG *     pMD_SERVER_PLATFORM;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         WCHAR *     pMimeMap;
         ULONG *     pMinFileKbSec;
         WCHAR *     pModeratorFile;
         ULONG *     pMSDOSDirOutput;
         ULONG *     pNetLogonWorkstation;
         ULONG *     pNntpCommandLogMask;
         WCHAR *     pNewsDropDirectory;
         WCHAR *     pNewsFailedPickupDirectory;
         WCHAR *     pNewsPickupDirectory;
         ULONG *     pNntpServiceVersion;
         WCHAR *     pNntpUucpName;
         ULONG *     pNotDeletable;
         WCHAR *     pNTAuthenticationProviders;
         WCHAR *     pOrphanAction;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
         ULONG *     pOrphanWorkerProcess;
         ULONG *     pPasswordCacheTTL;
         ULONG *     pPasswordExpirePrenotifyDays;
         WCHAR *     pPath;
         ULONG *     pPeriodicRestartRequests;
         WCHAR *     pPeriodicRestartSchedule;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartConnections;
         ULONG *     pPeriodicRestartMemory;
         WCHAR *     pPickupDirectory;
         ULONG *     pPingingEnabled;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pPop3ClearTextProvider;
         WCHAR *     pPop3DefaultDomain;
         WCHAR *     pPop3DsAccount;
         WCHAR *     pPop3DsBindType;
         WCHAR *     pPop3DsDataDirectory;
         WCHAR *     pPop3DsDefaultMailRoot;
         WCHAR *     pPop3DsHost;
         WCHAR *     pPop3DsNamingContext;
         WCHAR *     pPop3DsPassword;
         WCHAR *     pPop3DsSchemaType;
         ULONG *     pPop3ExpireDelay;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3ExpireStart;
         ULONG *     pPop3MailExpirationTime;
         WCHAR *     pPop3RoutingDll;
         WCHAR *     pPop3RoutingSources;
         WCHAR *     pPop3RoutingTableType;
         ULONG *     pPop3ServiceVersion;
         WCHAR *     pPrettyNamesFile;
         WCHAR *     pNntpClearTextProvider;
         ULONG *     pProcessNTCRIfLoggedOn;
         ULONG *     pPutReadSize;
         WCHAR *     pQueueDirectory;
         ULONG *     pRapidFailProtection;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         WCHAR *     pRealm;
         WCHAR *     pRedirectHeaders;
         ULONG *     pRelayForAuth;
 unsigned char *     pRelayIpList;
         ULONG *     pRemoteRetryAttempts;
         ULONG *     pRemoteRetryInterval;
         ULONG *     pRemoteSmtpPort;
         ULONG *     pRemoteSmtpSecurePort;
         ULONG *     pRemoteTimeout;
         ULONG *     pRevocationFreshnessTime;
         ULONG *     pRevocationURLRetrievalTimeout;
         ULONG *     pRouteAction;
         WCHAR *     pRouteActionString;
         WCHAR *     pRoutePassword;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutingDll;
         WCHAR *     pRoutingSources;
         ULONG *     pRunAsLocalSystem;
         WCHAR *     pSaslLogonDomain;
         WCHAR *     pScriptMaps;
         WCHAR *     pSecureBindings;
         WCHAR *     pSendBadTo;
         WCHAR *     pSendNdrTo;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pServerComment;
         ULONG *     pServerListenBacklog;
         ULONG *     pServerListenTimeout;
         ULONG *     pServerSize;
         ULONG *     pServerState;
 unsigned char *     pSessionKey;
         ULONG *     pShouldDeliver;
         ULONG *     pShutdownTimeLimit;
         WCHAR *     pSmartHost;
         ULONG *     pSmartHostType;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         WCHAR *     pSmtpAdvQueueDll;
         ULONG *     pSmtpAuthTimeout;
         ULONG *     pSmtpBdatTimeout;
         WCHAR *     pSmtpClearTextProvider;
         ULONG *     pSmtpCommandLogMask;
         ULONG *     pSmtpConnectTimeout;
         ULONG *     pSmtpDataTimeout;
         WCHAR *     pSmtpDsAccount;
         WCHAR *     pSmtpDsBindType;
         WCHAR *     pSmtpDsDataDirectory;
         WCHAR *     pSmtpDsDefaultMailRoot;
         WCHAR *     pSmtpDsDomain;
         ULONG *     pSmtpDsFlags;
         WCHAR *     pSmtpDsHost;
         WCHAR *     pSmtpDsNamingContext;
         ULONG *     pSmtpDSNLanguageID;
         ULONG *     pSmtpDSNOptions;
         WCHAR *     pSmtpDsPassword;
         ULONG *     pSmtpDsPort;
         WCHAR *     pSmtpDsSchemaType;
         ULONG *     pSmtpDsUseCat;
         ULONG *     pSmtpFlushMailFile;
         ULONG *     pSmtpHeloTimeout;
         ULONG *     pSmtpInboundCommandSupportOptions;
         ULONG *     pSmtpLocalDelayExpireMinutes;
         ULONG *     pSmtpLocalNDRExpireMinutes;
         ULONG *     pSmtpMailFromTimeout;
         ULONG *     pSmtpOutboundCommandSupportOptions;
         ULONG *     pSmtpRcptToTimeout;
         ULONG *     pSmtpRemoteDelayExpireMinutes;
         ULONG *     pSmtpRemoteNDRExpireMinutes;
         WCHAR *     pSmtpRemoteProgressiveRetry;
         ULONG *     pSmtpRemoteRetryThreshold;
         WCHAR *     pSmtpRoutingTableType;
         ULONG *     pSmtpRsetTimeout;
         ULONG *     pSmtpSaslTimeout;
         WCHAR *     pSmtpServer;
         ULONG *     pSmtpServiceVersion;
         ULONG *     pSmtpTurnTimeout;
         ULONG *     pSSIExecDisable;
 unsigned char *     pSSLCertHash;
         WCHAR *     pSSLStoreName;
         ULONG *     pSslUseDsMapper;
         ULONG *     pStartupTimeLimit;
         ULONG *     pAppPoolQueueLength;
         ULONG *     pUNCAuthenticationPassThrough;
         WCHAR *     pUNCPassword;
         WCHAR *     pUNCUserName;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pUseDigestSSP;
         ULONG *     pUseHostName;
         WCHAR *     pVrDriverClsid;
         WCHAR *     pVrDriverProgid;
         WCHAR *     pFsPropertyPath;
         ULONG *     pVrUseAccount;
         ULONG *     pVrDoExpire;
         WCHAR *     pExMdbGuid;
         ULONG *     pVrOwnModerator;
         ULONG *     pArticleTimeLimit;
         ULONG *     pHistoryExpiration;
         ULONG *     pNewsCrawlerTime;
         WCHAR *     pNntpOrganization;
         ULONG *     pSmtpUseTcpDns;
         ULONG *     pSmtpDotStuffPickupDirFiles;
         ULONG *     pSmtpDomainValidationFlags;
         ULONG *     pSmtpSSLRequireTrustedCA;
         ULONG *     pSmtpSSLCertHostnameValidation;
         ULONG *     pMaxMailObjects;
         ULONG *     pShouldPickupMail;
         ULONG *     pMaxDirChangeIOSize;
         ULONG *     pNameResolutionType;
         ULONG *     pMaxSmtpErrors;
         ULONG *     pShouldPipelineIn;
         ULONG *     pShouldPipelineOut;
         WCHAR *     pConnectResponse;
         ULONG *     pUpdatedFQDN;
         ULONG *     pUpdatedDefaultDomain;
         ULONG *     pEtrnSubdomains;
         ULONG *     pSmtpMaxRemoteQThreads;
         ULONG *     pSmtpDisableRelay;
         ULONG *     pSmtpHeloNoDomain;
         ULONG *     pSmtpMailNoHelo;
         ULONG *     pSmtpAqueueWait;
         ULONG *     pAddNoHeaders;
         ULONG *     pSmtpEventlogLevel;
         WCHAR *     pFeedServerName;
         ULONG *     pFeedType;
         WCHAR *     pFeedNewsgroups;
         ULONG *     pFeedSecurityType;
         ULONG *     pFeedAuthenticationType;
         WCHAR *     pFeedAccountName;
         WCHAR *     pFeedPassword;
         ULONG *     pFeedStartTimeHigh;
         ULONG *     pFeedStartTimeLow;
         ULONG *     pFeedInterval;
         ULONG *     pFeedAllowControlMsgs;
         ULONG *     pFeedCreateAutomatically;
         ULONG *     pFeedDisabled;
         WCHAR *     pFeedDistribution;
         ULONG *     pFeedConcurrentSessions;
         ULONG *     pFeedMaxConnectionAttempts;
         WCHAR *     pFeedUucpName;
         WCHAR *     pFeedTempDirectory;
         ULONG *     pFeedNextPullHigh;
         ULONG *     pFeedNextPullLow;
         WCHAR *     pFeedPeerTempDirectory;
         ULONG *     pFeedPeerGapSize;
         ULONG *     pFeedOutgoingPort;
         ULONG *     pFeedFeedpairId;
         ULONG *     pFeedHandshake;
         ULONG *     pFeedAdminError;
         ULONG *     pFeedErrParmMask;
         ULONG *     pExpireSpace;
         ULONG *     pExpireTime;
         WCHAR *     pExpireNewsgroups;
         WCHAR *     pExpirePolicyName;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pWin32Error;
         WCHAR *     pXoverTableFile;
         ULONG *     pStopListening;
         ULONG *     pDavEnabled;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pCPULoggingMask;
         ULONG *     pCPULoggingOptions;
         ULONG *     pDirBrowseFlags;
         ULONG *     pFilterFlags;
         ULONG *     pLogExtFileFlags;
         ULONG *     pPasswordChangeFlags;
         ULONG *     pServerConfigFlags;
         ULONG *     pAspAppServiceFlags;
};

enum eIIsConfigObject_AccessFlags {
    fIIsConfigObject_AccessExecute	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_AccessSource 	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_AccessRead   	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AccessWrite  	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AccessScript 	=	0x00000200,	//(512 decimal)
    fIIsConfigObject_AccessNoRemoteExecute	=	0x00000400,	//(1024 decimal)
    fIIsConfigObject_AccessNoRemoteRead	=	0x00001000,	//(4096 decimal)
    fIIsConfigObject_AccessNoRemoteWrite	=	0x00000400,	//(1024 decimal)
    fIIsConfigObject_AccessNoRemoteScript	=	0x00004000,	//(16384 decimal)
    fIIsConfigObject_AccessFlags_Mask	= 0x00005617
};

enum eIIsConfigObject_AccessSSLFlags {
    fIIsConfigObject_AccessSSL    	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_AccessSSL128 	=	0x00000100,	//(256 decimal)
    fIIsConfigObject_AccessSSLNegotiateCert	=	0x00000020,	//(32 decimal)
    fIIsConfigObject_AccessSSLRequireCert	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_AccessSSLMapCert	=	0x00000080,	//(128 decimal)
    fIIsConfigObject_AccessSSLFlags_Mask	= 0x000001e8
};

enum eIIsConfigObject_AuthFlags {
    fIIsConfigObject_AuthBasic    	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AuthAnonymous	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AuthNTLM     	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_AuthMD5      	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_AuthFlags_Mask	= 0x00000017
};

enum eIIsConfigObject_AuthPersistence {
    fIIsConfigObject_AuthPersistSingleRequest	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_AuthPersistence_Mask	= 0x00000040
};

enum eIIsConfigObject_CPULoggingMask {
    fIIsConfigObject_CPULoggingEnabled	=	0x80000000,	//(-2147483648 decimal)
    fIIsConfigObject_CPUEnableEvent	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_CPUEnableProcType	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_CPUEnableUserTime	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_CPUEnableKernelTime	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_CPUEnablePageFaults	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_CPUEnableTotalProcs	=	0x00000020,	//(32 decimal)
    fIIsConfigObject_CPUEnableActiveProcs	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_CPUEnableTerminatedProcs	=	0x00000080,	//(128 decimal)
    fIIsConfigObject_CPULoggingMask_Mask	= 0x800000ff
};

enum eIIsConfigObject_CPULoggingOptions {
    fIIsConfigObject_CPUEnableAllProcLogging	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_CPUEnableCGILogging	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_CPUEnableAppLogging	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_CPULoggingOptions_Mask	= 0x00000007
};

enum eIIsConfigObject_DirBrowseFlags {
    fIIsConfigObject_EnableDirBrowsing	=	0x80000000,	//(-2147483648 decimal)
    fIIsConfigObject_DirBrowseShowDate	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_DirBrowseShowTime	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_DirBrowseShowSize	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_DirBrowseShowExtension	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_DirBrowseShowLongDate	=	0x00000020,	//(32 decimal)
    fIIsConfigObject_EnableDefaultDoc	=	0x40000000,	//(1073741824 decimal)
    fIIsConfigObject_DirBrowseFlags_Mask	= 0xc000003e
};

enum eIIsConfigObject_FilterFlags {
    fIIsConfigObject_NotifySecurePort	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_NotifyNonSecurePort	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_NotifyReadRawData	=	0x00008000,	//(32768 decimal)
    fIIsConfigObject_NotifyPreProcHeaders	=	0x00004000,	//(16384 decimal)
    fIIsConfigObject_NotifyAuthentication	=	0x00002000,	//(8192 decimal)
    fIIsConfigObject_NotifyUrlMap 	=	0x00001000,	//(4096 decimal)
    fIIsConfigObject_NotifyAccessDenied	=	0x00000800,	//(2048 decimal)
    fIIsConfigObject_NotifySendResponse	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_NotifySendRawData	=	0x00000400,	//(1024 decimal)
    fIIsConfigObject_NotifyLog    	=	0x00000200,	//(512 decimal)
    fIIsConfigObject_NotifyEndOfRequest	=	0x00000080,	//(128 decimal)
    fIIsConfigObject_NotifyEndOfNetSession	=	0x00000100,	//(256 decimal)
    fIIsConfigObject_NotifyOrderHigh	=	0x00080000,	//(524288 decimal)
    fIIsConfigObject_NotifyOrderMedium	=	0x00040000,	//(262144 decimal)
    fIIsConfigObject_NotifyOrderLow	=	0x00020000,	//(131072 decimal)
    fIIsConfigObject_NotifyAuthComplete	=	0x04000000,	//(67108864 decimal)
    fIIsConfigObject_NotifyExtensionTrigger	=	0x02000000,	//(33554432 decimal)
    fIIsConfigObject_FilterFlags_Mask	= 0x060effc3
};

enum eIIsConfigObject_LogExtFileFlags {
    fIIsConfigObject_LogExtFileDate	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_LogExtFileHost	=	0x00100000,	//(1048576 decimal)
    fIIsConfigObject_LogExtFileTime	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_LogExtFileClientIp	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_LogExtFileUserName	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_LogExtFileSiteName	=	0x00000010,	//(16 decimal)
    fIIsConfigObject_LogExtFileComputerName	=	0x00000020,	//(32 decimal)
    fIIsConfigObject_LogExtFileServerIp	=	0x00000040,	//(64 decimal)
    fIIsConfigObject_LogExtFileMethod	=	0x00000080,	//(128 decimal)
    fIIsConfigObject_LogExtFileUriStem	=	0x00000100,	//(256 decimal)
    fIIsConfigObject_LogExtFileUriQuery	=	0x00000200,	//(512 decimal)
    fIIsConfigObject_LogExtFileHttpStatus	=	0x00000400,	//(1024 decimal)
    fIIsConfigObject_LogExtFileWin32Status	=	0x00000800,	//(2048 decimal)
    fIIsConfigObject_LogExtFileBytesSent	=	0x00001000,	//(4096 decimal)
    fIIsConfigObject_LogExtFileBytesRecv	=	0x00002000,	//(8192 decimal)
    fIIsConfigObject_LogExtFileTimeTaken	=	0x00004000,	//(16384 decimal)
    fIIsConfigObject_LogExtFileServerPort	=	0x00008000,	//(32768 decimal)
    fIIsConfigObject_LogExtFileUserAgent	=	0x00010000,	//(65536 decimal)
    fIIsConfigObject_LogExtFileCookie	=	0x00020000,	//(131072 decimal)
    fIIsConfigObject_LogExtFileReferer	=	0x00040000,	//(262144 decimal)
    fIIsConfigObject_LogExtFileProtocolVersion	=	0x00080000,	//(524288 decimal)
    fIIsConfigObject_LogExtFileFlags_Mask	= 0x001fffff
};

enum eIIsConfigObject_PasswordChangeFlags {
    fIIsConfigObject_AuthChangeUnsecure	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AuthChangeDisable	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AuthAdvNotifyDisable	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_PasswordChangeFlags_Mask	= 0x00000007
};

enum eIIsConfigObject_ServerConfigFlags {
    fIIsConfigObject_ServerConfigSSL40	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_ServerConfigSSL128	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_ServerConfigSSLAllowEncrypt	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_ServerConfigAutoPWSync	=	0x00000008,	//(8 decimal)
    fIIsConfigObject_ServerConfigFlags_Mask	= 0x0000000f
};

enum eIIsConfigObject_AspAppServiceFlags {
    fIIsConfigObject_AspEnableTracker	=	0x00000001,	//(1 decimal)
    fIIsConfigObject_AspEnableSxs 	=	0x00000002,	//(2 decimal)
    fIIsConfigObject_AspUsePartition	=	0x00000004,	//(4 decimal)
    fIIsConfigObject_AspAppServiceFlags_Mask	= 0x00000007
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsInheritedProperties                  L"IIsInheritedProperties"
#define TABLEID_IIsInheritedProperties                   (0xf9eae800L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsInheritedProperties               (0L)
#define ExtendedVersion_IIsInheritedProperties           (0L)

//-----------------Column Index Enums--------------   
enum eIIsInheritedProperties {
    iIIsInheritedProperties_KeyType,  
    iIIsInheritedProperties_AdminACL,  
    iIIsInheritedProperties_AdminACLBin,  
    iIIsInheritedProperties_AdminEmail,  
    iIIsInheritedProperties_AdminName,  
    iIIsInheritedProperties_AdminServer,  
    iIIsInheritedProperties_AllowAnonymous,  
    iIIsInheritedProperties_AllowClientPosts,  
    iIIsInheritedProperties_AllowControlMsgs,  
    iIIsInheritedProperties_AllowFeedPosts,  
    iIIsInheritedProperties_AllowKeepAlive,  
    iIIsInheritedProperties_AllowPathInfoForScriptMappings,  
    iIIsInheritedProperties_AlwaysUseSsl,  
    iIIsInheritedProperties_AnonymousOnly,  
    iIIsInheritedProperties_AnonymousPasswordSync,  
    iIIsInheritedProperties_AnonymousUserName,  
    iIIsInheritedProperties_AnonymousUserPass,  
    iIIsInheritedProperties_AppAllowClientDebug,  
    iIIsInheritedProperties_AppAllowDebugging,  
    iIIsInheritedProperties_AppFriendlyName,  
    iIIsInheritedProperties_AppIsolated,  
    iIIsInheritedProperties_AppOopRecoverLimit,  
    iIIsInheritedProperties_AppPackageID,  
    iIIsInheritedProperties_AppPackageName,  
    iIIsInheritedProperties_AppPoolFriendlyName,  
    iIIsInheritedProperties_AppPoolId,  
    iIIsInheritedProperties_AppPoolIdentityType,  
    iIIsInheritedProperties_AppPoolCommand,  
    iIIsInheritedProperties_AppPoolState,  
    iIIsInheritedProperties_AppPoolAutoStart,  
    iIIsInheritedProperties_AppRoot,  
    iIIsInheritedProperties_AppWamClsid,  
    iIIsInheritedProperties_ArticleTableFile,  
    iIIsInheritedProperties_AspAllowOutOfProcComponents,  
    iIIsInheritedProperties_AspAllowSessionState,  
    iIIsInheritedProperties_AspBufferingOn,  
    iIIsInheritedProperties_AspCodepage,  
    iIIsInheritedProperties_AspDiskTemplateCacheDirectory,  
    iIIsInheritedProperties_AspEnableApplicationRestart,  
    iIIsInheritedProperties_AspEnableAspHtmlFallback,  
    iIIsInheritedProperties_AspEnableChunkedEncoding,  
    iIIsInheritedProperties_AspEnableParentPaths,  
    iIIsInheritedProperties_AspEnableTypelibCache,  
    iIIsInheritedProperties_AspErrorsToNTLog,  
    iIIsInheritedProperties_AspExceptionCatchEnable,  
    iIIsInheritedProperties_AspKeepSessionIDSecure,  
    iIIsInheritedProperties_AspLCID,  
    iIIsInheritedProperties_AspLogErrorRequests,  
    iIIsInheritedProperties_AspMaxDiskTemplateCacheFiles,  
    iIIsInheritedProperties_AspPartitionID,  
    iIIsInheritedProperties_AspSxsName,  
    iIIsInheritedProperties_AspProcessorThreadMax,  
    iIIsInheritedProperties_AspQueueConnectionTestTime,  
    iIIsInheritedProperties_AspQueueTimeout,  
    iIIsInheritedProperties_AspRequestQueueMax,  
    iIIsInheritedProperties_AspScriptEngineCacheMax,  
    iIIsInheritedProperties_AspScriptErrorMessage,  
    iIIsInheritedProperties_AspScriptErrorSentToBrowser,  
    iIIsInheritedProperties_AspScriptFileCacheSize,  
    iIIsInheritedProperties_AspScriptLanguage,  
    iIIsInheritedProperties_AspScriptTimeout,  
    iIIsInheritedProperties_AspSessionMax,  
    iIIsInheritedProperties_AspSessionTimeout,  
    iIIsInheritedProperties_AspThreadGateEnabled,  
    iIIsInheritedProperties_AspThreadGateLoadHigh,  
    iIIsInheritedProperties_AspThreadGateLoadLow,  
    iIIsInheritedProperties_AspThreadGateSleepDelay,  
    iIIsInheritedProperties_AspThreadGateSleepMax,  
    iIIsInheritedProperties_AspThreadGateTimeSlice,  
    iIIsInheritedProperties_AspTrackThreadingModel,  
    iIIsInheritedProperties_AuthTurnList,  
    iIIsInheritedProperties_StandardAppModeEnabled,  
    iIIsInheritedProperties_BadMailDirectory,  
    iIIsInheritedProperties_CacheControlCustom,  
    iIIsInheritedProperties_CacheControlMaxAge,  
    iIIsInheritedProperties_CacheControlNoCache,  
    iIIsInheritedProperties_CacheISAPI,  
    iIIsInheritedProperties_CalLimitHttpError,  
    iIIsInheritedProperties_CalReserveTimeout,  
    iIIsInheritedProperties_CalSSLReserveTimeout,  
    iIIsInheritedProperties_CalVcPerConnect,  
    iIIsInheritedProperties_CertCheckMode,  
    iIIsInheritedProperties_CGITimeout,  
    iIIsInheritedProperties_ChangeNumber,  
    iIIsInheritedProperties_ClientPostHardLimit,  
    iIIsInheritedProperties_ClientPostSoftLimit,  
    iIIsInheritedProperties_ClusterEnabled,  
    iIIsInheritedProperties_CollectionComment,  
    iIIsInheritedProperties_ConnectionTimeout,  
    iIIsInheritedProperties_ContentIndexed,  
    iIIsInheritedProperties_CPUAction,  
    iIIsInheritedProperties_CPUAppEnabled,  
    iIIsInheritedProperties_CPUCGIEnabled,  
    iIIsInheritedProperties_CPULimit,  
    iIIsInheritedProperties_CPUCGILimit,  
    iIIsInheritedProperties_CPULimitLogEvent,  
    iIIsInheritedProperties_CPULimitPause,  
    iIIsInheritedProperties_CPULimitPriority,  
    iIIsInheritedProperties_CPULimitProcStop,  
    iIIsInheritedProperties_CPULimitsEnabled,  
    iIIsInheritedProperties_CPULoggingInterval,  
    iIIsInheritedProperties_CPUResetInterval,  
    iIIsInheritedProperties_CreateCGIWithNewConsole,  
    iIIsInheritedProperties_CreateProcessAsUser,  
    iIIsInheritedProperties_CSideEtrnDomains,  
    iIIsInheritedProperties_CustomErrorDescriptions,  
    iIIsInheritedProperties_DefaultDoc,  
    iIIsInheritedProperties_DefaultDocFooter,  
    iIIsInheritedProperties_DefaultDomain,  
    iIIsInheritedProperties_DefaultLogonDomain,  
    iIIsInheritedProperties_DefaultModeratorDomain,  
    iIIsInheritedProperties_DirectoryLevelsToScan,  
    iIIsInheritedProperties_DisablePublishing,  
    iIIsInheritedProperties_DisableNewNews,  
    iIIsInheritedProperties_DisableSocketPooling,  
    iIIsInheritedProperties_DisallowOverlappingRotation,  
    iIIsInheritedProperties_DisallowRotationOnConfigChange,  
    iIIsInheritedProperties_DomainRouting,  
    iIIsInheritedProperties_DoMasquerade,  
    iIIsInheritedProperties_DontLog,  
    iIIsInheritedProperties_DownlevelAdminInstance,  
    iIIsInheritedProperties_DropDirectory,  
    iIIsInheritedProperties_HistoryMajorVersionNumber,  
    iIIsInheritedProperties_XMLSchemaTimeStamp,  
    iIIsInheritedProperties_BINSchemaTimeStamp,  
    iIIsInheritedProperties_EnableHistory,  
    iIIsInheritedProperties_EnableDocFooter,  
    iIIsInheritedProperties_EnableEditWhileRunning,  
    iIIsInheritedProperties_EnableReverseDns,  
    iIIsInheritedProperties_EnableReverseDnsLookup,  
    iIIsInheritedProperties_EtrnDays,  
    iIIsInheritedProperties_ExitMessage,  
    iIIsInheritedProperties_FeedPostHardLimit,  
    iIIsInheritedProperties_FeedPostSoftLimit,  
    iIIsInheritedProperties_FeedReportPeriod,  
    iIIsInheritedProperties_FilterDescription,  
    iIIsInheritedProperties_FilterEnabled,  
    iIIsInheritedProperties_FilterLoadOrder,  
    iIIsInheritedProperties_FilterPath,  
    iIIsInheritedProperties_FilterState,  
    iIIsInheritedProperties_FrontPageWeb,  
    iIIsInheritedProperties_FtpDirBrowseShowLongDate,  
    iIIsInheritedProperties_FullyQualifiedDomainName,  
    iIIsInheritedProperties_BannerMessage,  
    iIIsInheritedProperties_UserIsolationMode,  
    iIIsInheritedProperties_FtpLogInUtf8,  
    iIIsInheritedProperties_GreetingMessage,  
    iIIsInheritedProperties_GroupHelpFile,  
    iIIsInheritedProperties_GroupListFile,  
    iIIsInheritedProperties_GroupVarListFile,  
    iIIsInheritedProperties_HeaderWaitTimeout,  
    iIIsInheritedProperties_HcCacheControlHeader,  
    iIIsInheritedProperties_HcCompressionBufferSize,  
    iIIsInheritedProperties_HcCompressionDirectory,  
    iIIsInheritedProperties_HcCompressionDll,  
    iIIsInheritedProperties_HcCreateFlags,  
    iIIsInheritedProperties_HcDoDiskSpaceLimiting,  
    iIIsInheritedProperties_HcDoDynamicCompression,  
    iIIsInheritedProperties_HcDoOnDemandCompression,  
    iIIsInheritedProperties_HcDoStaticCompression,  
    iIIsInheritedProperties_HcDynamicCompressionLevel,  
    iIIsInheritedProperties_HcExpiresHeader,  
    iIIsInheritedProperties_HcFileExtensions,  
    iIIsInheritedProperties_HcFilesDeletedPerDiskFree,  
    iIIsInheritedProperties_HcIoBufferSize,  
    iIIsInheritedProperties_HcMaxDiskSpaceUsage,  
    iIIsInheritedProperties_HcMaxQueueLength,  
    iIIsInheritedProperties_HcMimeType,  
    iIIsInheritedProperties_HcMinFileSizeForComp,  
    iIIsInheritedProperties_HcNoCompressionForHttp10,  
    iIIsInheritedProperties_HcNoCompressionForProxies,  
    iIIsInheritedProperties_HcNoCompressionForRange,  
    iIIsInheritedProperties_HcOnDemandCompLevel,  
    iIIsInheritedProperties_HcPriority,  
    iIIsInheritedProperties_HcScriptFileExtensions,  
    iIIsInheritedProperties_HcSendCacheHeaders,  
    iIIsInheritedProperties_HistoryTableFile,  
    iIIsInheritedProperties_HonorClientMsgIds,  
    iIIsInheritedProperties_HopCount,  
    iIIsInheritedProperties_HttpCustomHeaders,  
    iIIsInheritedProperties_HttpErrors,  
    iIIsInheritedProperties_HttpExpires,  
    iIIsInheritedProperties_HttpPics,  
    iIIsInheritedProperties_HttpRedirect,  
    iIIsInheritedProperties_IdleTimeout,  
    iIIsInheritedProperties_IgnoreTranslate,  
    iIIsInheritedProperties_ImapClearTextProvider,  
    iIIsInheritedProperties_ImapDefaultDomain,  
    iIIsInheritedProperties_ImapDsAccount,  
    iIIsInheritedProperties_ImapDsBindType,  
    iIIsInheritedProperties_ImapDsDataDirectory,  
    iIIsInheritedProperties_ImapDsDefaultMailRoot,  
    iIIsInheritedProperties_ImapDsHost,  
    iIIsInheritedProperties_ImapDsNamingContext,  
    iIIsInheritedProperties_ImapDsPassword,  
    iIIsInheritedProperties_ImapDsSchemaType,  
    iIIsInheritedProperties_ImapExpireDelay,  
    iIIsInheritedProperties_ImapExpireMail,  
    iIIsInheritedProperties_ImapExpireStart,  
    iIIsInheritedProperties_ImapMailExpirationTime,  
    iIIsInheritedProperties_ImapRoutingDll,  
    iIIsInheritedProperties_ImapRoutingSources,  
    iIIsInheritedProperties_ImapRoutingTableType,  
    iIIsInheritedProperties_ImapServiceVersion,  
    iIIsInheritedProperties_InProcessIsapiApps,  
    iIIsInheritedProperties_IPSecurity,  
    iIIsInheritedProperties_LimitRemoteConnections,  
    iIIsInheritedProperties_ListFile,  
    iIIsInheritedProperties_LocalRetryAttempts,  
    iIIsInheritedProperties_LocalRetryInterval,  
    iIIsInheritedProperties_LogAnonymous,  
    iIIsInheritedProperties_LogCustomPropertyDataType,  
    iIIsInheritedProperties_LogCustomPropertyHeader,  
    iIIsInheritedProperties_LogCustomPropertyID,  
    iIIsInheritedProperties_LogCustomPropertyMask,  
    iIIsInheritedProperties_LogCustomPropertyName,  
    iIIsInheritedProperties_LogCustomPropertyServicesString,  
    iIIsInheritedProperties_LogFileDirectory,  
    iIIsInheritedProperties_LogFileLocaltimeRollover,  
    iIIsInheritedProperties_LogFilePeriod,  
    iIIsInheritedProperties_LogFileTruncateSize,  
    iIIsInheritedProperties_LogInUTF8,  
    iIIsInheritedProperties_LogModuleId,  
    iIIsInheritedProperties_LogModuleList,  
    iIIsInheritedProperties_LogModuleUiId,  
    iIIsInheritedProperties_LogNonAnonymous,  
    iIIsInheritedProperties_LogOdbcDataSource,  
    iIIsInheritedProperties_LogOdbcPassword,  
    iIIsInheritedProperties_LogOdbcTableName,  
    iIIsInheritedProperties_LogOdbcUserName,  
    iIIsInheritedProperties_LogonMethod,  
    iIIsInheritedProperties_LogPluginClsid,  
    iIIsInheritedProperties_LogType,  
    iIIsInheritedProperties_MasqueradeDomain,  
    iIIsInheritedProperties_MetabaseComments,  
    iIIsInheritedProperties_MaxErrorFiles,  
    iIIsInheritedProperties_MaxHistoryFiles,  
    iIIsInheritedProperties_MaxBandwidth,  
    iIIsInheritedProperties_MaxBandwidthBlocked,  
    iIIsInheritedProperties_MaxBatchedMessages,  
    iIIsInheritedProperties_MaxClientsMessage,  
    iIIsInheritedProperties_MaxConnections,  
    iIIsInheritedProperties_MaxEndpointConnections,  
    iIIsInheritedProperties_MaxGlobalBandwidth,  
    iIIsInheritedProperties_MaxGlobalConnections,  
    iIIsInheritedProperties_MaxMessageSize,  
    iIIsInheritedProperties_MaxOutConnections,  
    iIIsInheritedProperties_MaxOutConnectionsPerDomain,  
    iIIsInheritedProperties_MaxProcesses,  
    iIIsInheritedProperties_MaxRecipients,  
    iIIsInheritedProperties_MaxSearchResults,  
    iIIsInheritedProperties_MaxSessionSize,  
    iIIsInheritedProperties_MaxSmtpLogonErrors,  
    iIIsInheritedProperties_MD_0,  
    iIIsInheritedProperties_MD_1001,  
    iIIsInheritedProperties_PostmasterName,  
    iIIsInheritedProperties_PostmasterEmail,  
    iIIsInheritedProperties_LocalDomains,  
    iIIsInheritedProperties_ShutdownLatency,  
    iIIsInheritedProperties_MD_APP_LAST_OUTPROC_PID,  
    iIIsInheritedProperties_MD_AUTH_CHANGE_URL,  
    iIIsInheritedProperties_MD_AUTH_EXPIRED_UNSECUREURL,  
    iIIsInheritedProperties_MD_AUTH_EXPIRED_URL,  
    iIIsInheritedProperties_MD_AUTH_NOTIFY_PWD_EXP_URL,  
    iIIsInheritedProperties_MD_AUTH_NOTIFY_PWS_EXP_UNSECUREURL,  
    iIIsInheritedProperties_MD_ETAG_CHANGENUMBER,  
    iIIsInheritedProperties_MD_IISADMIN_EXTENSIONS,  
    iIIsInheritedProperties_MD_ISM_ACCESS_CHECK,  
    iIIsInheritedProperties_MD_METADATA_ID_REGISTRATION,  
    iIIsInheritedProperties_MD_SERVER_CAPABILITIES,  
    iIIsInheritedProperties_ServerCommand,  
    iIIsInheritedProperties_MD_SERVER_PLATFORM,  
    iIIsInheritedProperties_MajorIIsVersionNumber,  
    iIIsInheritedProperties_MinorIIsVersionNumber,  
    iIIsInheritedProperties_MimeMap,  
    iIIsInheritedProperties_MinFileKbSec,  
    iIIsInheritedProperties_ModeratorFile,  
    iIIsInheritedProperties_MSDOSDirOutput,  
    iIIsInheritedProperties_NetLogonWorkstation,  
    iIIsInheritedProperties_NntpCommandLogMask,  
    iIIsInheritedProperties_NewsDropDirectory,  
    iIIsInheritedProperties_NewsFailedPickupDirectory,  
    iIIsInheritedProperties_NewsPickupDirectory,  
    iIIsInheritedProperties_NntpServiceVersion,  
    iIIsInheritedProperties_NntpUucpName,  
    iIIsInheritedProperties_NotDeletable,  
    iIIsInheritedProperties_NTAuthenticationProviders,  
    iIIsInheritedProperties_OrphanAction,  
    iIIsInheritedProperties_OrphanActionExe,  
    iIIsInheritedProperties_OrphanActionParams,  
    iIIsInheritedProperties_OrphanWorkerProcess,  
    iIIsInheritedProperties_PasswordCacheTTL,  
    iIIsInheritedProperties_PasswordExpirePrenotifyDays,  
    iIIsInheritedProperties_Path,  
    iIIsInheritedProperties_PeriodicRestartRequests,  
    iIIsInheritedProperties_PeriodicRestartSchedule,  
    iIIsInheritedProperties_PeriodicRestartTime,  
    iIIsInheritedProperties_PeriodicRestartConnections,  
    iIIsInheritedProperties_PeriodicRestartMemory,  
    iIIsInheritedProperties_PickupDirectory,  
    iIIsInheritedProperties_PingingEnabled,  
    iIIsInheritedProperties_PingInterval,  
    iIIsInheritedProperties_PingResponseTime,  
    iIIsInheritedProperties_PoolIdcTimeout,  
    iIIsInheritedProperties_Pop3ClearTextProvider,  
    iIIsInheritedProperties_Pop3DefaultDomain,  
    iIIsInheritedProperties_Pop3DsAccount,  
    iIIsInheritedProperties_Pop3DsBindType,  
    iIIsInheritedProperties_Pop3DsDataDirectory,  
    iIIsInheritedProperties_Pop3DsDefaultMailRoot,  
    iIIsInheritedProperties_Pop3DsHost,  
    iIIsInheritedProperties_Pop3DsNamingContext,  
    iIIsInheritedProperties_Pop3DsPassword,  
    iIIsInheritedProperties_Pop3DsSchemaType,  
    iIIsInheritedProperties_Pop3ExpireDelay,  
    iIIsInheritedProperties_Pop3ExpireMail,  
    iIIsInheritedProperties_Pop3ExpireStart,  
    iIIsInheritedProperties_Pop3MailExpirationTime,  
    iIIsInheritedProperties_Pop3RoutingDll,  
    iIIsInheritedProperties_Pop3RoutingSources,  
    iIIsInheritedProperties_Pop3RoutingTableType,  
    iIIsInheritedProperties_Pop3ServiceVersion,  
    iIIsInheritedProperties_PrettyNamesFile,  
    iIIsInheritedProperties_NntpClearTextProvider,  
    iIIsInheritedProperties_ProcessNTCRIfLoggedOn,  
    iIIsInheritedProperties_PutReadSize,  
    iIIsInheritedProperties_QueueDirectory,  
    iIIsInheritedProperties_RapidFailProtection,  
    iIIsInheritedProperties_RapidFailProtectionInterval,  
    iIIsInheritedProperties_RapidFailProtectionMaxCrashes,  
    iIIsInheritedProperties_Realm,  
    iIIsInheritedProperties_RedirectHeaders,  
    iIIsInheritedProperties_RelayForAuth,  
    iIIsInheritedProperties_RelayIpList,  
    iIIsInheritedProperties_RemoteRetryAttempts,  
    iIIsInheritedProperties_RemoteRetryInterval,  
    iIIsInheritedProperties_RemoteSmtpPort,  
    iIIsInheritedProperties_RemoteSmtpSecurePort,  
    iIIsInheritedProperties_RemoteTimeout,  
    iIIsInheritedProperties_RevocationFreshnessTime,  
    iIIsInheritedProperties_RevocationURLRetrievalTimeout,  
    iIIsInheritedProperties_RouteAction,  
    iIIsInheritedProperties_RouteActionString,  
    iIIsInheritedProperties_RoutePassword,  
    iIIsInheritedProperties_RouteUserName,  
    iIIsInheritedProperties_RoutingDll,  
    iIIsInheritedProperties_RoutingSources,  
    iIIsInheritedProperties_RunAsLocalSystem,  
    iIIsInheritedProperties_SaslLogonDomain,  
    iIIsInheritedProperties_ScriptMaps,  
    iIIsInheritedProperties_SecureBindings,  
    iIIsInheritedProperties_SendBadTo,  
    iIIsInheritedProperties_SendNdrTo,  
    iIIsInheritedProperties_ServerAutoStart,  
    iIIsInheritedProperties_ServerBindings,  
    iIIsInheritedProperties_ServerComment,  
    iIIsInheritedProperties_ServerListenBacklog,  
    iIIsInheritedProperties_ServerListenTimeout,  
    iIIsInheritedProperties_ServerSize,  
    iIIsInheritedProperties_ServerState,  
    iIIsInheritedProperties_SessionKey,  
    iIIsInheritedProperties_ShouldDeliver,  
    iIIsInheritedProperties_ShutdownTimeLimit,  
    iIIsInheritedProperties_SmartHost,  
    iIIsInheritedProperties_SmartHostType,  
    iIIsInheritedProperties_SMPAffinitized,  
    iIIsInheritedProperties_SMPProcessorAffinityMask,  
    iIIsInheritedProperties_SmtpAdvQueueDll,  
    iIIsInheritedProperties_SmtpAuthTimeout,  
    iIIsInheritedProperties_SmtpBdatTimeout,  
    iIIsInheritedProperties_SmtpClearTextProvider,  
    iIIsInheritedProperties_SmtpCommandLogMask,  
    iIIsInheritedProperties_SmtpConnectTimeout,  
    iIIsInheritedProperties_SmtpDataTimeout,  
    iIIsInheritedProperties_SmtpDsAccount,  
    iIIsInheritedProperties_SmtpDsBindType,  
    iIIsInheritedProperties_SmtpDsDataDirectory,  
    iIIsInheritedProperties_SmtpDsDefaultMailRoot,  
    iIIsInheritedProperties_SmtpDsDomain,  
    iIIsInheritedProperties_SmtpDsFlags,  
    iIIsInheritedProperties_SmtpDsHost,  
    iIIsInheritedProperties_SmtpDsNamingContext,  
    iIIsInheritedProperties_SmtpDSNLanguageID,  
    iIIsInheritedProperties_SmtpDSNOptions,  
    iIIsInheritedProperties_SmtpDsPassword,  
    iIIsInheritedProperties_SmtpDsPort,  
    iIIsInheritedProperties_SmtpDsSchemaType,  
    iIIsInheritedProperties_SmtpDsUseCat,  
    iIIsInheritedProperties_SmtpFlushMailFile,  
    iIIsInheritedProperties_SmtpHeloTimeout,  
    iIIsInheritedProperties_SmtpInboundCommandSupportOptions,  
    iIIsInheritedProperties_SmtpLocalDelayExpireMinutes,  
    iIIsInheritedProperties_SmtpLocalNDRExpireMinutes,  
    iIIsInheritedProperties_SmtpMailFromTimeout,  
    iIIsInheritedProperties_SmtpOutboundCommandSupportOptions,  
    iIIsInheritedProperties_SmtpRcptToTimeout,  
    iIIsInheritedProperties_SmtpRemoteDelayExpireMinutes,  
    iIIsInheritedProperties_SmtpRemoteNDRExpireMinutes,  
    iIIsInheritedProperties_SmtpRemoteProgressiveRetry,  
    iIIsInheritedProperties_SmtpRemoteRetryThreshold,  
    iIIsInheritedProperties_SmtpRoutingTableType,  
    iIIsInheritedProperties_SmtpRsetTimeout,  
    iIIsInheritedProperties_SmtpSaslTimeout,  
    iIIsInheritedProperties_SmtpServer,  
    iIIsInheritedProperties_SmtpServiceVersion,  
    iIIsInheritedProperties_SmtpTurnTimeout,  
    iIIsInheritedProperties_SSIExecDisable,  
    iIIsInheritedProperties_SSLCertHash,  
    iIIsInheritedProperties_SSLStoreName,  
    iIIsInheritedProperties_SslUseDsMapper,  
    iIIsInheritedProperties_StartupTimeLimit,  
    iIIsInheritedProperties_AppPoolQueueLength,  
    iIIsInheritedProperties_UNCAuthenticationPassThrough,  
    iIIsInheritedProperties_UNCPassword,  
    iIIsInheritedProperties_UNCUserName,  
    iIIsInheritedProperties_UploadReadAheadSize,  
    iIIsInheritedProperties_UseDigestSSP,  
    iIIsInheritedProperties_UseHostName,  
    iIIsInheritedProperties_VrDriverClsid,  
    iIIsInheritedProperties_VrDriverProgid,  
    iIIsInheritedProperties_FsPropertyPath,  
    iIIsInheritedProperties_VrUseAccount,  
    iIIsInheritedProperties_VrDoExpire,  
    iIIsInheritedProperties_ExMdbGuid,  
    iIIsInheritedProperties_VrOwnModerator,  
    iIIsInheritedProperties_ArticleTimeLimit,  
    iIIsInheritedProperties_HistoryExpiration,  
    iIIsInheritedProperties_NewsCrawlerTime,  
    iIIsInheritedProperties_NntpOrganization,  
    iIIsInheritedProperties_SmtpUseTcpDns,  
    iIIsInheritedProperties_SmtpDotStuffPickupDirFiles,  
    iIIsInheritedProperties_SmtpDomainValidationFlags,  
    iIIsInheritedProperties_SmtpSSLRequireTrustedCA,  
    iIIsInheritedProperties_SmtpSSLCertHostnameValidation,  
    iIIsInheritedProperties_MaxMailObjects,  
    iIIsInheritedProperties_ShouldPickupMail,  
    iIIsInheritedProperties_MaxDirChangeIOSize,  
    iIIsInheritedProperties_NameResolutionType,  
    iIIsInheritedProperties_MaxSmtpErrors,  
    iIIsInheritedProperties_ShouldPipelineIn,  
    iIIsInheritedProperties_ShouldPipelineOut,  
    iIIsInheritedProperties_ConnectResponse,  
    iIIsInheritedProperties_UpdatedFQDN,  
    iIIsInheritedProperties_UpdatedDefaultDomain,  
    iIIsInheritedProperties_EtrnSubdomains,  
    iIIsInheritedProperties_SmtpMaxRemoteQThreads,  
    iIIsInheritedProperties_SmtpDisableRelay,  
    iIIsInheritedProperties_SmtpHeloNoDomain,  
    iIIsInheritedProperties_SmtpMailNoHelo,  
    iIIsInheritedProperties_SmtpAqueueWait,  
    iIIsInheritedProperties_AddNoHeaders,  
    iIIsInheritedProperties_SmtpEventlogLevel,  
    iIIsInheritedProperties_FeedServerName,  
    iIIsInheritedProperties_FeedType,  
    iIIsInheritedProperties_FeedNewsgroups,  
    iIIsInheritedProperties_FeedSecurityType,  
    iIIsInheritedProperties_FeedAuthenticationType,  
    iIIsInheritedProperties_FeedAccountName,  
    iIIsInheritedProperties_FeedPassword,  
    iIIsInheritedProperties_FeedStartTimeHigh,  
    iIIsInheritedProperties_FeedStartTimeLow,  
    iIIsInheritedProperties_FeedInterval,  
    iIIsInheritedProperties_FeedAllowControlMsgs,  
    iIIsInheritedProperties_FeedCreateAutomatically,  
    iIIsInheritedProperties_FeedDisabled,  
    iIIsInheritedProperties_FeedDistribution,  
    iIIsInheritedProperties_FeedConcurrentSessions,  
    iIIsInheritedProperties_FeedMaxConnectionAttempts,  
    iIIsInheritedProperties_FeedUucpName,  
    iIIsInheritedProperties_FeedTempDirectory,  
    iIIsInheritedProperties_FeedNextPullHigh,  
    iIIsInheritedProperties_FeedNextPullLow,  
    iIIsInheritedProperties_FeedPeerTempDirectory,  
    iIIsInheritedProperties_FeedPeerGapSize,  
    iIIsInheritedProperties_FeedOutgoingPort,  
    iIIsInheritedProperties_FeedFeedpairId,  
    iIIsInheritedProperties_FeedHandshake,  
    iIIsInheritedProperties_FeedAdminError,  
    iIIsInheritedProperties_FeedErrParmMask,  
    iIIsInheritedProperties_ExpireSpace,  
    iIIsInheritedProperties_ExpireTime,  
    iIIsInheritedProperties_ExpireNewsgroups,  
    iIIsInheritedProperties_ExpirePolicyName,  
    iIIsInheritedProperties_DoStaticCompression,  
    iIIsInheritedProperties_DoDynamicCompression,  
    iIIsInheritedProperties_WAMUserName,  
    iIIsInheritedProperties_WAMUserPass,  
    iIIsInheritedProperties_Win32Error,  
    iIIsInheritedProperties_XoverTableFile,  
    iIIsInheritedProperties_StopListening,  
    iIIsInheritedProperties_DavEnabled,  
    iIIsInheritedProperties_AccessFlags,  
    iIIsInheritedProperties_AccessSSLFlags,  
    iIIsInheritedProperties_AuthFlags,  
    iIIsInheritedProperties_AuthPersistence,  
    iIIsInheritedProperties_CPULoggingMask,  
    iIIsInheritedProperties_CPULoggingOptions,  
    iIIsInheritedProperties_DirBrowseFlags,  
    iIIsInheritedProperties_FilterFlags,  
    iIIsInheritedProperties_LogExtFileFlags,  
    iIIsInheritedProperties_PasswordChangeFlags,  
    iIIsInheritedProperties_ServerConfigFlags,  
    iIIsInheritedProperties_AspAppServiceFlags,  
    cIIsInheritedProperties_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsInheritedPropertiesRow {
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
         WCHAR *     pAdminEmail;
         WCHAR *     pAdminName;
         WCHAR *     pAdminServer;
         ULONG *     pAllowAnonymous;
         ULONG *     pAllowClientPosts;
         ULONG *     pAllowControlMsgs;
         ULONG *     pAllowFeedPosts;
         ULONG *     pAllowKeepAlive;
         ULONG *     pAllowPathInfoForScriptMappings;
         ULONG *     pAlwaysUseSsl;
         ULONG *     pAnonymousOnly;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAppAllowClientDebug;
         ULONG *     pAppAllowDebugging;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppIsolated;
         ULONG *     pAppOopRecoverLimit;
         WCHAR *     pAppPackageID;
         WCHAR *     pAppPackageName;
         WCHAR *     pAppPoolFriendlyName;
         WCHAR *     pAppPoolId;
         ULONG *     pAppPoolIdentityType;
         ULONG *     pAppPoolCommand;
         ULONG *     pAppPoolState;
         ULONG *     pAppPoolAutoStart;
         WCHAR *     pAppRoot;
         WCHAR *     pAppWamClsid;
         WCHAR *     pArticleTableFile;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspAllowSessionState;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspCodepage;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pAspLCID;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspScriptEngineCacheMax;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspScriptErrorSentToBrowser;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionMax;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspThreadGateEnabled;
         ULONG *     pAspThreadGateLoadHigh;
         ULONG *     pAspThreadGateLoadLow;
         ULONG *     pAspThreadGateSleepDelay;
         ULONG *     pAspThreadGateSleepMax;
         ULONG *     pAspThreadGateTimeSlice;
         ULONG *     pAspTrackThreadingModel;
         WCHAR *     pAuthTurnList;
         ULONG *     pStandardAppModeEnabled;
         WCHAR *     pBadMailDirectory;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         ULONG *     pCacheISAPI;
         ULONG *     pCalLimitHttpError;
         ULONG *     pCalReserveTimeout;
         ULONG *     pCalSSLReserveTimeout;
         ULONG *     pCalVcPerConnect;
         ULONG *     pCertCheckMode;
         ULONG *     pCGITimeout;
         ULONG *     pChangeNumber;
         ULONG *     pClientPostHardLimit;
         ULONG *     pClientPostSoftLimit;
         ULONG *     pClusterEnabled;
         WCHAR *     pCollectionComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pContentIndexed;
         ULONG *     pCPUAction;
         ULONG *     pCPUAppEnabled;
         ULONG *     pCPUCGIEnabled;
         ULONG *     pCPULimit;
         ULONG *     pCPUCGILimit;
         ULONG *     pCPULimitLogEvent;
         ULONG *     pCPULimitPause;
         ULONG *     pCPULimitPriority;
         ULONG *     pCPULimitProcStop;
         ULONG *     pCPULimitsEnabled;
         ULONG *     pCPULoggingInterval;
         ULONG *     pCPUResetInterval;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pCreateProcessAsUser;
         WCHAR *     pCSideEtrnDomains;
         WCHAR *     pCustomErrorDescriptions;
         WCHAR *     pDefaultDoc;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pDefaultDomain;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pDefaultModeratorDomain;
         ULONG *     pDirectoryLevelsToScan;
         ULONG *     pDisablePublishing;
         ULONG *     pDisableNewNews;
         ULONG *     pDisableSocketPooling;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         WCHAR *     pDomainRouting;
         ULONG *     pDoMasquerade;
         ULONG *     pDontLog;
         ULONG *     pDownlevelAdminInstance;
         WCHAR *     pDropDirectory;
         ULONG *     pHistoryMajorVersionNumber;
 unsigned char *     pXMLSchemaTimeStamp;
 unsigned char *     pBINSchemaTimeStamp;
         ULONG *     pEnableHistory;
         ULONG *     pEnableDocFooter;
         ULONG *     pEnableEditWhileRunning;
         ULONG *     pEnableReverseDns;
         ULONG *     pEnableReverseDnsLookup;
         ULONG *     pEtrnDays;
         WCHAR *     pExitMessage;
         ULONG *     pFeedPostHardLimit;
         ULONG *     pFeedPostSoftLimit;
         ULONG *     pFeedReportPeriod;
         WCHAR *     pFilterDescription;
         ULONG *     pFilterEnabled;
         WCHAR *     pFilterLoadOrder;
         WCHAR *     pFilterPath;
         ULONG *     pFilterState;
         ULONG *     pFrontPageWeb;
         ULONG *     pFtpDirBrowseShowLongDate;
         WCHAR *     pFullyQualifiedDomainName;
         WCHAR *     pBannerMessage;
         ULONG *     pUserIsolationMode;
         ULONG *     pFtpLogInUtf8;
         WCHAR *     pGreetingMessage;
         WCHAR *     pGroupHelpFile;
         WCHAR *     pGroupListFile;
         WCHAR *     pGroupVarListFile;
         ULONG *     pHeaderWaitTimeout;
         WCHAR *     pHcCacheControlHeader;
         ULONG *     pHcCompressionBufferSize;
         WCHAR *     pHcCompressionDirectory;
         WCHAR *     pHcCompressionDll;
         ULONG *     pHcCreateFlags;
         ULONG *     pHcDoDiskSpaceLimiting;
         ULONG *     pHcDoDynamicCompression;
         ULONG *     pHcDoOnDemandCompression;
         ULONG *     pHcDoStaticCompression;
         ULONG *     pHcDynamicCompressionLevel;
         WCHAR *     pHcExpiresHeader;
         WCHAR *     pHcFileExtensions;
         ULONG *     pHcFilesDeletedPerDiskFree;
         ULONG *     pHcIoBufferSize;
         ULONG *     pHcMaxDiskSpaceUsage;
         ULONG *     pHcMaxQueueLength;
         WCHAR *     pHcMimeType;
         ULONG *     pHcMinFileSizeForComp;
         ULONG *     pHcNoCompressionForHttp10;
         ULONG *     pHcNoCompressionForProxies;
         ULONG *     pHcNoCompressionForRange;
         ULONG *     pHcOnDemandCompLevel;
         ULONG *     pHcPriority;
         WCHAR *     pHcScriptFileExtensions;
         ULONG *     pHcSendCacheHeaders;
         WCHAR *     pHistoryTableFile;
         ULONG *     pHonorClientMsgIds;
         ULONG *     pHopCount;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpRedirect;
         ULONG *     pIdleTimeout;
         ULONG *     pIgnoreTranslate;
         WCHAR *     pImapClearTextProvider;
         WCHAR *     pImapDefaultDomain;
         WCHAR *     pImapDsAccount;
         WCHAR *     pImapDsBindType;
         WCHAR *     pImapDsDataDirectory;
         WCHAR *     pImapDsDefaultMailRoot;
         WCHAR *     pImapDsHost;
         WCHAR *     pImapDsNamingContext;
         WCHAR *     pImapDsPassword;
         WCHAR *     pImapDsSchemaType;
         ULONG *     pImapExpireDelay;
         ULONG *     pImapExpireMail;
         ULONG *     pImapExpireStart;
         ULONG *     pImapMailExpirationTime;
         WCHAR *     pImapRoutingDll;
         WCHAR *     pImapRoutingSources;
         WCHAR *     pImapRoutingTableType;
         ULONG *     pImapServiceVersion;
         WCHAR *     pInProcessIsapiApps;
 unsigned char *     pIPSecurity;
         ULONG *     pLimitRemoteConnections;
         WCHAR *     pListFile;
         ULONG *     pLocalRetryAttempts;
         ULONG *     pLocalRetryInterval;
         ULONG *     pLogAnonymous;
         ULONG *     pLogCustomPropertyDataType;
         WCHAR *     pLogCustomPropertyHeader;
         ULONG *     pLogCustomPropertyID;
         ULONG *     pLogCustomPropertyMask;
         WCHAR *     pLogCustomPropertyName;
         WCHAR *     pLogCustomPropertyServicesString;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogInUTF8;
         WCHAR *     pLogModuleId;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogModuleUiId;
         ULONG *     pLogNonAnonymous;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcPassword;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         ULONG *     pLogonMethod;
         WCHAR *     pLogPluginClsid;
         ULONG *     pLogType;
         WCHAR *     pMasqueradeDomain;
         ULONG *     pMetabaseComments;
         ULONG *     pMaxErrorFiles;
         ULONG *     pMaxHistoryFiles;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxBandwidthBlocked;
         ULONG *     pMaxBatchedMessages;
         WCHAR *     pMaxClientsMessage;
         ULONG *     pMaxConnections;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pMaxGlobalBandwidth;
         ULONG *     pMaxGlobalConnections;
         ULONG *     pMaxMessageSize;
         ULONG *     pMaxOutConnections;
         ULONG *     pMaxOutConnectionsPerDomain;
         ULONG *     pMaxProcesses;
         ULONG *     pMaxRecipients;
         ULONG *     pMaxSearchResults;
         ULONG *     pMaxSessionSize;
         ULONG *     pMaxSmtpLogonErrors;
         WCHAR *     pMD_0;
         ULONG *     pMD_1001;
         WCHAR *     pPostmasterName;
         WCHAR *     pPostmasterEmail;
         WCHAR *     pLocalDomains;
         ULONG *     pShutdownLatency;
         WCHAR *     pMD_APP_LAST_OUTPROC_PID;
         WCHAR *     pMD_AUTH_CHANGE_URL;
         WCHAR *     pMD_AUTH_EXPIRED_UNSECUREURL;
         WCHAR *     pMD_AUTH_EXPIRED_URL;
         WCHAR *     pMD_AUTH_NOTIFY_PWD_EXP_URL;
         WCHAR *     pMD_AUTH_NOTIFY_PWS_EXP_UNSECUREURL;
         ULONG *     pMD_ETAG_CHANGENUMBER;
         WCHAR *     pMD_IISADMIN_EXTENSIONS;
         ULONG *     pMD_ISM_ACCESS_CHECK;
         WCHAR *     pMD_METADATA_ID_REGISTRATION;
         ULONG *     pMD_SERVER_CAPABILITIES;
         ULONG *     pServerCommand;
         ULONG *     pMD_SERVER_PLATFORM;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         WCHAR *     pMimeMap;
         ULONG *     pMinFileKbSec;
         WCHAR *     pModeratorFile;
         ULONG *     pMSDOSDirOutput;
         ULONG *     pNetLogonWorkstation;
         ULONG *     pNntpCommandLogMask;
         WCHAR *     pNewsDropDirectory;
         WCHAR *     pNewsFailedPickupDirectory;
         WCHAR *     pNewsPickupDirectory;
         ULONG *     pNntpServiceVersion;
         WCHAR *     pNntpUucpName;
         ULONG *     pNotDeletable;
         WCHAR *     pNTAuthenticationProviders;
         WCHAR *     pOrphanAction;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
         ULONG *     pOrphanWorkerProcess;
         ULONG *     pPasswordCacheTTL;
         ULONG *     pPasswordExpirePrenotifyDays;
         WCHAR *     pPath;
         ULONG *     pPeriodicRestartRequests;
         WCHAR *     pPeriodicRestartSchedule;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartConnections;
         ULONG *     pPeriodicRestartMemory;
         WCHAR *     pPickupDirectory;
         ULONG *     pPingingEnabled;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pPoolIdcTimeout;
         WCHAR *     pPop3ClearTextProvider;
         WCHAR *     pPop3DefaultDomain;
         WCHAR *     pPop3DsAccount;
         WCHAR *     pPop3DsBindType;
         WCHAR *     pPop3DsDataDirectory;
         WCHAR *     pPop3DsDefaultMailRoot;
         WCHAR *     pPop3DsHost;
         WCHAR *     pPop3DsNamingContext;
         WCHAR *     pPop3DsPassword;
         WCHAR *     pPop3DsSchemaType;
         ULONG *     pPop3ExpireDelay;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3ExpireStart;
         ULONG *     pPop3MailExpirationTime;
         WCHAR *     pPop3RoutingDll;
         WCHAR *     pPop3RoutingSources;
         WCHAR *     pPop3RoutingTableType;
         ULONG *     pPop3ServiceVersion;
         WCHAR *     pPrettyNamesFile;
         WCHAR *     pNntpClearTextProvider;
         ULONG *     pProcessNTCRIfLoggedOn;
         ULONG *     pPutReadSize;
         WCHAR *     pQueueDirectory;
         ULONG *     pRapidFailProtection;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         WCHAR *     pRealm;
         WCHAR *     pRedirectHeaders;
         ULONG *     pRelayForAuth;
 unsigned char *     pRelayIpList;
         ULONG *     pRemoteRetryAttempts;
         ULONG *     pRemoteRetryInterval;
         ULONG *     pRemoteSmtpPort;
         ULONG *     pRemoteSmtpSecurePort;
         ULONG *     pRemoteTimeout;
         ULONG *     pRevocationFreshnessTime;
         ULONG *     pRevocationURLRetrievalTimeout;
         ULONG *     pRouteAction;
         WCHAR *     pRouteActionString;
         WCHAR *     pRoutePassword;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutingDll;
         WCHAR *     pRoutingSources;
         ULONG *     pRunAsLocalSystem;
         WCHAR *     pSaslLogonDomain;
         WCHAR *     pScriptMaps;
         WCHAR *     pSecureBindings;
         WCHAR *     pSendBadTo;
         WCHAR *     pSendNdrTo;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pServerComment;
         ULONG *     pServerListenBacklog;
         ULONG *     pServerListenTimeout;
         ULONG *     pServerSize;
         ULONG *     pServerState;
 unsigned char *     pSessionKey;
         ULONG *     pShouldDeliver;
         ULONG *     pShutdownTimeLimit;
         WCHAR *     pSmartHost;
         ULONG *     pSmartHostType;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         WCHAR *     pSmtpAdvQueueDll;
         ULONG *     pSmtpAuthTimeout;
         ULONG *     pSmtpBdatTimeout;
         WCHAR *     pSmtpClearTextProvider;
         ULONG *     pSmtpCommandLogMask;
         ULONG *     pSmtpConnectTimeout;
         ULONG *     pSmtpDataTimeout;
         WCHAR *     pSmtpDsAccount;
         WCHAR *     pSmtpDsBindType;
         WCHAR *     pSmtpDsDataDirectory;
         WCHAR *     pSmtpDsDefaultMailRoot;
         WCHAR *     pSmtpDsDomain;
         ULONG *     pSmtpDsFlags;
         WCHAR *     pSmtpDsHost;
         WCHAR *     pSmtpDsNamingContext;
         ULONG *     pSmtpDSNLanguageID;
         ULONG *     pSmtpDSNOptions;
         WCHAR *     pSmtpDsPassword;
         ULONG *     pSmtpDsPort;
         WCHAR *     pSmtpDsSchemaType;
         ULONG *     pSmtpDsUseCat;
         ULONG *     pSmtpFlushMailFile;
         ULONG *     pSmtpHeloTimeout;
         ULONG *     pSmtpInboundCommandSupportOptions;
         ULONG *     pSmtpLocalDelayExpireMinutes;
         ULONG *     pSmtpLocalNDRExpireMinutes;
         ULONG *     pSmtpMailFromTimeout;
         ULONG *     pSmtpOutboundCommandSupportOptions;
         ULONG *     pSmtpRcptToTimeout;
         ULONG *     pSmtpRemoteDelayExpireMinutes;
         ULONG *     pSmtpRemoteNDRExpireMinutes;
         WCHAR *     pSmtpRemoteProgressiveRetry;
         ULONG *     pSmtpRemoteRetryThreshold;
         WCHAR *     pSmtpRoutingTableType;
         ULONG *     pSmtpRsetTimeout;
         ULONG *     pSmtpSaslTimeout;
         WCHAR *     pSmtpServer;
         ULONG *     pSmtpServiceVersion;
         ULONG *     pSmtpTurnTimeout;
         ULONG *     pSSIExecDisable;
 unsigned char *     pSSLCertHash;
         WCHAR *     pSSLStoreName;
         ULONG *     pSslUseDsMapper;
         ULONG *     pStartupTimeLimit;
         ULONG *     pAppPoolQueueLength;
         ULONG *     pUNCAuthenticationPassThrough;
         WCHAR *     pUNCPassword;
         WCHAR *     pUNCUserName;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pUseDigestSSP;
         ULONG *     pUseHostName;
         WCHAR *     pVrDriverClsid;
         WCHAR *     pVrDriverProgid;
         WCHAR *     pFsPropertyPath;
         ULONG *     pVrUseAccount;
         ULONG *     pVrDoExpire;
         WCHAR *     pExMdbGuid;
         ULONG *     pVrOwnModerator;
         ULONG *     pArticleTimeLimit;
         ULONG *     pHistoryExpiration;
         ULONG *     pNewsCrawlerTime;
         WCHAR *     pNntpOrganization;
         ULONG *     pSmtpUseTcpDns;
         ULONG *     pSmtpDotStuffPickupDirFiles;
         ULONG *     pSmtpDomainValidationFlags;
         ULONG *     pSmtpSSLRequireTrustedCA;
         ULONG *     pSmtpSSLCertHostnameValidation;
         ULONG *     pMaxMailObjects;
         ULONG *     pShouldPickupMail;
         ULONG *     pMaxDirChangeIOSize;
         ULONG *     pNameResolutionType;
         ULONG *     pMaxSmtpErrors;
         ULONG *     pShouldPipelineIn;
         ULONG *     pShouldPipelineOut;
         WCHAR *     pConnectResponse;
         ULONG *     pUpdatedFQDN;
         ULONG *     pUpdatedDefaultDomain;
         ULONG *     pEtrnSubdomains;
         ULONG *     pSmtpMaxRemoteQThreads;
         ULONG *     pSmtpDisableRelay;
         ULONG *     pSmtpHeloNoDomain;
         ULONG *     pSmtpMailNoHelo;
         ULONG *     pSmtpAqueueWait;
         ULONG *     pAddNoHeaders;
         ULONG *     pSmtpEventlogLevel;
         WCHAR *     pFeedServerName;
         ULONG *     pFeedType;
         WCHAR *     pFeedNewsgroups;
         ULONG *     pFeedSecurityType;
         ULONG *     pFeedAuthenticationType;
         WCHAR *     pFeedAccountName;
         WCHAR *     pFeedPassword;
         ULONG *     pFeedStartTimeHigh;
         ULONG *     pFeedStartTimeLow;
         ULONG *     pFeedInterval;
         ULONG *     pFeedAllowControlMsgs;
         ULONG *     pFeedCreateAutomatically;
         ULONG *     pFeedDisabled;
         WCHAR *     pFeedDistribution;
         ULONG *     pFeedConcurrentSessions;
         ULONG *     pFeedMaxConnectionAttempts;
         WCHAR *     pFeedUucpName;
         WCHAR *     pFeedTempDirectory;
         ULONG *     pFeedNextPullHigh;
         ULONG *     pFeedNextPullLow;
         WCHAR *     pFeedPeerTempDirectory;
         ULONG *     pFeedPeerGapSize;
         ULONG *     pFeedOutgoingPort;
         ULONG *     pFeedFeedpairId;
         ULONG *     pFeedHandshake;
         ULONG *     pFeedAdminError;
         ULONG *     pFeedErrParmMask;
         ULONG *     pExpireSpace;
         ULONG *     pExpireTime;
         WCHAR *     pExpireNewsgroups;
         WCHAR *     pExpirePolicyName;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pWin32Error;
         WCHAR *     pXoverTableFile;
         ULONG *     pStopListening;
         ULONG *     pDavEnabled;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pCPULoggingMask;
         ULONG *     pCPULoggingOptions;
         ULONG *     pDirBrowseFlags;
         ULONG *     pFilterFlags;
         ULONG *     pLogExtFileFlags;
         ULONG *     pPasswordChangeFlags;
         ULONG *     pServerConfigFlags;
         ULONG *     pAspAppServiceFlags;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsObject                               L"IIsObject"
#define TABLEID_IIsObject                                (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsObject                            (0L)
#define ExtendedVersion_IIsObject                        (0L)

//-----------------Column Index Enums--------------   
enum eIIsObject {
    iIIsObject_Location,  
    iIIsObject_KeyType,  
    cIIsObject_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsObjectRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsComputer                             L"IIsComputer"
#define TABLEID_IIsComputer                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsComputer                          (0L)
#define ExtendedVersion_IIsComputer                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsComputer {
    iIIsComputer_Location,  
    iIIsComputer_KeyType,  
    iIIsComputer_MaxBandwidth,  
    iIIsComputer_MaxBandwidthBlocked,  
    iIIsComputer_MimeMap,  
    iIIsComputer_MD_1001,  
    iIIsComputer_EnableHistory,  
    iIIsComputer_MaxHistoryFiles,  
    iIIsComputer_EnableEditWhileRunning,  
    cIIsComputer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsComputerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxBandwidthBlocked;
         WCHAR *     pMimeMap;
         ULONG *     pMD_1001;
         ULONG *     pEnableHistory;
         ULONG *     pMaxHistoryFiles;
         ULONG *     pEnableEditWhileRunning;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebService                           L"IIsWebService"
#define TABLEID_IIsWebService                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebService                        (0L)
#define ExtendedVersion_IIsWebService                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebService {
    iIIsWebService_Location,  
    iIIsWebService_KeyType,  
    iIIsWebService_MaxBandwidth,  
    iIIsWebService_MaxConnections,  
    iIIsWebService_MimeMap,  
    iIIsWebService_AnonymousUserName,  
    iIIsWebService_AnonymousUserPass,  
    iIIsWebService_IgnoreTranslate,  
    iIIsWebService_UseDigestSSP,  
    iIIsWebService_ServerListenBacklog,  
    iIIsWebService_ServerComment,  
    iIIsWebService_ServerBindings,  
    iIIsWebService_ConnectionTimeout,  
    iIIsWebService_ServerListenTimeout,  
    iIIsWebService_MaxEndpointConnections,  
    iIIsWebService_ServerAutoStart,  
    iIIsWebService_AllowKeepAlive,  
    iIIsWebService_ServerSize,  
    iIIsWebService_DisableSocketPooling,  
    iIIsWebService_AnonymousPasswordSync,  
    iIIsWebService_DefaultLogonDomain,  
    iIIsWebService_AdminACL,  
    iIIsWebService_AdminACLBin,  
    iIIsWebService_IPSecurity,  
    iIIsWebService_DontLog,  
    iIIsWebService_Realm,  
    iIIsWebService_DefaultDoc,  
    iIIsWebService_HttpExpires,  
    iIIsWebService_HttpPics,  
    iIIsWebService_HttpCustomHeaders,  
    iIIsWebService_HttpErrors,  
    iIIsWebService_EnableDocFooter,  
    iIIsWebService_DefaultDocFooter,  
    iIIsWebService_LogonMethod,  
    iIIsWebService_CacheISAPI,  
    iIIsWebService_CGITimeout,  
    iIIsWebService_DirectoryLevelsToScan,  
    iIIsWebService_ContentIndexed,  
    iIIsWebService_NTAuthenticationProviders,  
    iIIsWebService_CertCheckMode,  
    iIIsWebService_DownlevelAdminInstance,  
    iIIsWebService_AspBufferingOn,  
    iIIsWebService_AspLogErrorRequests,  
    iIIsWebService_AspScriptErrorSentToBrowser,  
    iIIsWebService_AspScriptErrorMessage,  
    iIIsWebService_AspAllowOutOfProcComponents,  
    iIIsWebService_AspScriptFileCacheSize,  
    iIIsWebService_AspDiskTemplateCacheDirectory,  
    iIIsWebService_AspMaxDiskTemplateCacheFiles,  
    iIIsWebService_AspScriptEngineCacheMax,  
    iIIsWebService_AspScriptTimeout,  
    iIIsWebService_AspSessionTimeout,  
    iIIsWebService_AspEnableParentPaths,  
    iIIsWebService_AspAllowSessionState,  
    iIIsWebService_AspScriptLanguage,  
    iIIsWebService_AspExceptionCatchEnable,  
    iIIsWebService_AspCodepage,  
    iIIsWebService_AspLCID,  
    iIIsWebService_AspQueueTimeout,  
    iIIsWebService_AspEnableAspHtmlFallback,  
    iIIsWebService_AspEnableChunkedEncoding,  
    iIIsWebService_AspEnableTypelibCache,  
    iIIsWebService_AspErrorsToNTLog,  
    iIIsWebService_AspProcessorThreadMax,  
    iIIsWebService_AspTrackThreadingModel,  
    iIIsWebService_AspRequestQueueMax,  
    iIIsWebService_AspEnableApplicationRestart,  
    iIIsWebService_AspQueueConnectionTestTime,  
    iIIsWebService_AspSessionMax,  
    iIIsWebService_AspThreadGateEnabled,  
    iIIsWebService_AspThreadGateTimeSlice,  
    iIIsWebService_AspThreadGateSleepDelay,  
    iIIsWebService_AspThreadGateSleepMax,  
    iIIsWebService_AspThreadGateLoadLow,  
    iIIsWebService_AspThreadGateLoadHigh,  
    iIIsWebService_AppRoot,  
    iIIsWebService_AppFriendlyName,  
    iIIsWebService_AppIsolated,  
    iIIsWebService_AppPackageID,  
    iIIsWebService_AppPackageName,  
    iIIsWebService_AppAllowDebugging,  
    iIIsWebService_AppAllowClientDebug,  
    iIIsWebService_NetLogonWorkstation,  
    iIIsWebService_UseHostName,  
    iIIsWebService_CacheControlMaxAge,  
    iIIsWebService_CacheControlNoCache,  
    iIIsWebService_CacheControlCustom,  
    iIIsWebService_CreateProcessAsUser,  
    iIIsWebService_PoolIdcTimeout,  
    iIIsWebService_PutReadSize,  
    iIIsWebService_RedirectHeaders,  
    iIIsWebService_UploadReadAheadSize,  
    iIIsWebService_PasswordExpirePrenotifyDays,  
    iIIsWebService_PasswordCacheTTL,  
    iIIsWebService_PasswordChangeFlags,  
    iIIsWebService_UNCAuthenticationPassThrough,  
    iIIsWebService_AppWamClsid,  
    iIIsWebService_DirBrowseFlags,  
    iIIsWebService_AuthFlags,  
    iIIsWebService_AuthPersistence,  
    iIIsWebService_AccessFlags,  
    iIIsWebService_AccessSSLFlags,  
    iIIsWebService_ScriptMaps,  
    iIIsWebService_SSIExecDisable,  
    iIIsWebService_EnableReverseDns,  
    iIIsWebService_CreateCGIWithNewConsole,  
    iIIsWebService_ProcessNTCRIfLoggedOn,  
    iIIsWebService_AllowPathInfoForScriptMappings,  
    iIIsWebService_InProcessIsapiApps,  
    iIIsWebService_LogType,  
    iIIsWebService_LogFilePeriod,  
    iIIsWebService_LogFileLocaltimeRollover,  
    iIIsWebService_LogPluginClsid,  
    iIIsWebService_LogModuleList,  
    iIIsWebService_LogFileDirectory,  
    iIIsWebService_LogFileTruncateSize,  
    iIIsWebService_LogExtFileFlags,  
    iIIsWebService_LogOdbcDataSource,  
    iIIsWebService_LogOdbcTableName,  
    iIIsWebService_LogOdbcUserName,  
    iIIsWebService_LogOdbcPassword,  
    iIIsWebService_CPUCGILimit,  
    iIIsWebService_CPULimitLogEvent,  
    iIIsWebService_CPULimitPriority,  
    iIIsWebService_CPULimitProcStop,  
    iIIsWebService_CPULimitPause,  
    iIIsWebService_CPULimitsEnabled,  
    iIIsWebService_CPUResetInterval,  
    iIIsWebService_CPULoggingInterval,  
    iIIsWebService_CPULoggingOptions,  
    iIIsWebService_CPULoggingMask,  
    iIIsWebService_CPUAppEnabled,  
    iIIsWebService_CPUCGIEnabled,  
    iIIsWebService_SslUseDsMapper,  
    iIIsWebService_WAMUserName,  
    iIIsWebService_WAMUserPass,  
    iIIsWebService_ShutdownTimeLimit,  
    iIIsWebService_SSLCertHash,  
    iIIsWebService_SSLStoreName,  
    iIIsWebService_CalVcPerConnect,  
    iIIsWebService_CalLimitHttpError,  
    iIIsWebService_CalReserveTimeout,  
    iIIsWebService_CalSSLReserveTimeout,  
    iIIsWebService_MD_AUTH_CHANGE_URL,  
    iIIsWebService_MD_AUTH_EXPIRED_URL,  
    iIIsWebService_MD_AUTH_NOTIFY_PWD_EXP_URL,  
    iIIsWebService_MD_AUTH_EXPIRED_UNSECUREURL,  
    iIIsWebService_MD_AUTH_NOTIFY_PWS_EXP_UNSECUREURL,  
    iIIsWebService_MD_APP_LAST_OUTPROC_PID,  
    iIIsWebService_MD_ETAG_CHANGENUMBER,  
    iIIsWebService_AdminServer,  
    iIIsWebService_AppPoolId,  
    iIIsWebService_DoStaticCompression,  
    iIIsWebService_DoDynamicCompression,  
    iIIsWebService_StandardAppModeEnabled,  
    iIIsWebService_MaxGlobalBandwidth,  
    iIIsWebService_MaxGlobalConnections,  
    iIIsWebService_MinFileKbSec,  
    iIIsWebService_HeaderWaitTimeout,  
    iIIsWebService_LogInUTF8,  
    iIIsWebService_DisablePublishing,  
    iIIsWebService_DavEnabled,  
    iIIsWebService_RapidFailProtectionInterval,  
    iIIsWebService_RapidFailProtectionMaxCrashes,  
    iIIsWebService_AspPartitionID,  
    iIIsWebService_AspSxsName,  
    iIIsWebService_AspAppServiceFlags,  
    iIIsWebService_AspKeepSessionIDSecure,  
    iIIsWebService_RevocationFreshnessTime,  
    iIIsWebService_RevocationURLRetrievalTimeout,  
    cIIsWebService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pMimeMap;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pIgnoreTranslate;
         ULONG *     pUseDigestSSP;
         ULONG *     pServerListenBacklog;
         WCHAR *     pServerComment;
         WCHAR *     pServerBindings;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         ULONG *     pAllowKeepAlive;
         ULONG *     pServerSize;
         ULONG *     pDisableSocketPooling;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pDefaultLogonDomain;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pRealm;
         WCHAR *     pDefaultDoc;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         ULONG *     pLogonMethod;
         ULONG *     pCacheISAPI;
         ULONG *     pCGITimeout;
         ULONG *     pDirectoryLevelsToScan;
         ULONG *     pContentIndexed;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pCertCheckMode;
         ULONG *     pDownlevelAdminInstance;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspScriptErrorSentToBrowser;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         ULONG *     pAspScriptEngineCacheMax;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspAllowSessionState;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspCodepage;
         ULONG *     pAspLCID;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspSessionMax;
         ULONG *     pAspThreadGateEnabled;
         ULONG *     pAspThreadGateTimeSlice;
         ULONG *     pAspThreadGateSleepDelay;
         ULONG *     pAspThreadGateSleepMax;
         ULONG *     pAspThreadGateLoadLow;
         ULONG *     pAspThreadGateLoadHigh;
         WCHAR *     pAppRoot;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppIsolated;
         WCHAR *     pAppPackageID;
         WCHAR *     pAppPackageName;
         ULONG *     pAppAllowDebugging;
         ULONG *     pAppAllowClientDebug;
         ULONG *     pNetLogonWorkstation;
         ULONG *     pUseHostName;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         ULONG *     pPutReadSize;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pPasswordExpirePrenotifyDays;
         ULONG *     pPasswordCacheTTL;
         ULONG *     pPasswordChangeFlags;
         ULONG *     pUNCAuthenticationPassThrough;
         WCHAR *     pAppWamClsid;
         ULONG *     pDirBrowseFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pProcessNTCRIfLoggedOn;
         ULONG *     pAllowPathInfoForScriptMappings;
         WCHAR *     pInProcessIsapiApps;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileLocaltimeRollover;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pCPUCGILimit;
         ULONG *     pCPULimitLogEvent;
         ULONG *     pCPULimitPriority;
         ULONG *     pCPULimitProcStop;
         ULONG *     pCPULimitPause;
         ULONG *     pCPULimitsEnabled;
         ULONG *     pCPUResetInterval;
         ULONG *     pCPULoggingInterval;
         ULONG *     pCPULoggingOptions;
         ULONG *     pCPULoggingMask;
         ULONG *     pCPUAppEnabled;
         ULONG *     pCPUCGIEnabled;
         ULONG *     pSslUseDsMapper;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pShutdownTimeLimit;
 unsigned char *     pSSLCertHash;
         WCHAR *     pSSLStoreName;
         ULONG *     pCalVcPerConnect;
         ULONG *     pCalLimitHttpError;
         ULONG *     pCalReserveTimeout;
         ULONG *     pCalSSLReserveTimeout;
         WCHAR *     pMD_AUTH_CHANGE_URL;
         WCHAR *     pMD_AUTH_EXPIRED_URL;
         WCHAR *     pMD_AUTH_NOTIFY_PWD_EXP_URL;
         WCHAR *     pMD_AUTH_EXPIRED_UNSECUREURL;
         WCHAR *     pMD_AUTH_NOTIFY_PWS_EXP_UNSECUREURL;
         WCHAR *     pMD_APP_LAST_OUTPROC_PID;
         ULONG *     pMD_ETAG_CHANGENUMBER;
         WCHAR *     pAdminServer;
         WCHAR *     pAppPoolId;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         ULONG *     pStandardAppModeEnabled;
         ULONG *     pMaxGlobalBandwidth;
         ULONG *     pMaxGlobalConnections;
         ULONG *     pMinFileKbSec;
         ULONG *     pHeaderWaitTimeout;
         ULONG *     pLogInUTF8;
         ULONG *     pDisablePublishing;
         ULONG *     pDavEnabled;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pRevocationFreshnessTime;
         ULONG *     pRevocationURLRetrievalTimeout;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFtpService                           L"IIsFtpService"
#define TABLEID_IIsFtpService                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFtpService                        (0L)
#define ExtendedVersion_IIsFtpService                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsFtpService {
    iIIsFtpService_Location,  
    iIIsFtpService_KeyType,  
    iIIsFtpService_MaxConnections,  
    iIIsFtpService_AnonymousUserName,  
    iIIsFtpService_AnonymousUserPass,  
    iIIsFtpService_ServerListenBacklog,  
    iIIsFtpService_LogAnonymous,  
    iIIsFtpService_LogNonAnonymous,  
    iIIsFtpService_ServerComment,  
    iIIsFtpService_ServerBindings,  
    iIIsFtpService_ConnectionTimeout,  
    iIIsFtpService_ServerListenTimeout,  
    iIIsFtpService_MaxEndpointConnections,  
    iIIsFtpService_ServerAutoStart,  
    iIIsFtpService_ExitMessage,  
    iIIsFtpService_GreetingMessage,  
    iIIsFtpService_MaxClientsMessage,  
    iIIsFtpService_AnonymousOnly,  
    iIIsFtpService_MSDOSDirOutput,  
    iIIsFtpService_ServerSize,  
    iIIsFtpService_DisableSocketPooling,  
    iIIsFtpService_AnonymousPasswordSync,  
    iIIsFtpService_AllowAnonymous,  
    iIIsFtpService_DefaultLogonDomain,  
    iIIsFtpService_AdminACL,  
    iIIsFtpService_AdminACLBin,  
    iIIsFtpService_IPSecurity,  
    iIIsFtpService_DontLog,  
    iIIsFtpService_DirectoryLevelsToScan,  
    iIIsFtpService_Realm,  
    iIIsFtpService_LogType,  
    iIIsFtpService_LogFilePeriod,  
    iIIsFtpService_LogFileLocaltimeRollover,  
    iIIsFtpService_LogPluginClsid,  
    iIIsFtpService_LogModuleList,  
    iIIsFtpService_LogFileDirectory,  
    iIIsFtpService_LogFileTruncateSize,  
    iIIsFtpService_LogExtFileFlags,  
    iIIsFtpService_LogOdbcDataSource,  
    iIIsFtpService_LogOdbcTableName,  
    iIIsFtpService_LogOdbcUserName,  
    iIIsFtpService_LogOdbcPassword,  
    iIIsFtpService_FtpDirBrowseShowLongDate,  
    iIIsFtpService_AccessFlags,  
    iIIsFtpService_DownlevelAdminInstance,  
    iIIsFtpService_BannerMessage,  
    iIIsFtpService_MaxBandwidth,  
    cIIsFtpService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFtpServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxConnections;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pServerListenBacklog;
         ULONG *     pLogAnonymous;
         ULONG *     pLogNonAnonymous;
         WCHAR *     pServerComment;
         WCHAR *     pServerBindings;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pExitMessage;
         WCHAR *     pGreetingMessage;
         WCHAR *     pMaxClientsMessage;
         ULONG *     pAnonymousOnly;
         ULONG *     pMSDOSDirOutput;
         ULONG *     pServerSize;
         ULONG *     pDisableSocketPooling;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pAllowAnonymous;
         WCHAR *     pDefaultLogonDomain;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pDirectoryLevelsToScan;
         WCHAR *     pRealm;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileLocaltimeRollover;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pFtpDirBrowseShowLongDate;
         ULONG *     pAccessFlags;
         ULONG *     pDownlevelAdminInstance;
         WCHAR *     pBannerMessage;
         ULONG *     pMaxBandwidth;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebServer                            L"IIsWebServer"
#define TABLEID_IIsWebServer                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebServer                         (0L)
#define ExtendedVersion_IIsWebServer                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebServer {
    iIIsWebServer_Location,  
    iIIsWebServer_ContentIndexed,  
    iIIsWebServer_KeyType,  
    iIIsWebServer_ServerState,  
    iIIsWebServer_ServerComment,  
    iIIsWebServer_MaxBandwidth,  
    iIIsWebServer_ServerAutoStart,  
    iIIsWebServer_ServerSize,  
    iIIsWebServer_DisableSocketPooling,  
    iIIsWebServer_ServerListenBacklog,  
    iIIsWebServer_ServerListenTimeout,  
    iIIsWebServer_ServerBindings,  
    iIIsWebServer_SecureBindings,  
    iIIsWebServer_MaxConnections,  
    iIIsWebServer_ConnectionTimeout,  
    iIIsWebServer_AllowKeepAlive,  
    iIIsWebServer_CGITimeout,  
    iIIsWebServer_MaxEndpointConnections,  
    iIIsWebServer_IgnoreTranslate,  
    iIIsWebServer_UseDigestSSP,  
    iIIsWebServer_CacheISAPI,  
    iIIsWebServer_MimeMap,  
    iIIsWebServer_AnonymousUserName,  
    iIIsWebServer_AnonymousUserPass,  
    iIIsWebServer_FrontPageWeb,  
    iIIsWebServer_AnonymousPasswordSync,  
    iIIsWebServer_DefaultLogonDomain,  
    iIIsWebServer_AdminACL,  
    iIIsWebServer_AdminACLBin,  
    iIIsWebServer_IPSecurity,  
    iIIsWebServer_DontLog,  
    iIIsWebServer_Realm,  
    iIIsWebServer_DefaultDoc,  
    iIIsWebServer_HttpExpires,  
    iIIsWebServer_HttpPics,  
    iIIsWebServer_HttpCustomHeaders,  
    iIIsWebServer_HttpErrors,  
    iIIsWebServer_EnableDocFooter,  
    iIIsWebServer_DefaultDocFooter,  
    iIIsWebServer_LogonMethod,  
    iIIsWebServer_NTAuthenticationProviders,  
    iIIsWebServer_CertCheckMode,  
    iIIsWebServer_AspBufferingOn,  
    iIIsWebServer_AspLogErrorRequests,  
    iIIsWebServer_AspScriptErrorSentToBrowser,  
    iIIsWebServer_AspScriptErrorMessage,  
    iIIsWebServer_AspAllowOutOfProcComponents,  
    iIIsWebServer_AspScriptFileCacheSize,  
    iIIsWebServer_AspDiskTemplateCacheDirectory,  
    iIIsWebServer_AspMaxDiskTemplateCacheFiles,  
    iIIsWebServer_AspScriptEngineCacheMax,  
    iIIsWebServer_AspScriptTimeout,  
    iIIsWebServer_AspEnableParentPaths,  
    iIIsWebServer_AspAllowSessionState,  
    iIIsWebServer_AspScriptLanguage,  
    iIIsWebServer_AspExceptionCatchEnable,  
    iIIsWebServer_AspCodepage,  
    iIIsWebServer_AspLCID,  
    iIIsWebServer_AspSessionTimeout,  
    iIIsWebServer_AspQueueTimeout,  
    iIIsWebServer_AspEnableAspHtmlFallback,  
    iIIsWebServer_AspEnableChunkedEncoding,  
    iIIsWebServer_AspEnableTypelibCache,  
    iIIsWebServer_AspErrorsToNTLog,  
    iIIsWebServer_AspProcessorThreadMax,  
    iIIsWebServer_AspTrackThreadingModel,  
    iIIsWebServer_AspRequestQueueMax,  
    iIIsWebServer_AspEnableApplicationRestart,  
    iIIsWebServer_AspQueueConnectionTestTime,  
    iIIsWebServer_AspSessionMax,  
    iIIsWebServer_AspThreadGateEnabled,  
    iIIsWebServer_AspThreadGateTimeSlice,  
    iIIsWebServer_AspThreadGateSleepDelay,  
    iIIsWebServer_AspThreadGateSleepMax,  
    iIIsWebServer_AspThreadGateLoadLow,  
    iIIsWebServer_AspThreadGateLoadHigh,  
    iIIsWebServer_AppRoot,  
    iIIsWebServer_AppFriendlyName,  
    iIIsWebServer_AppIsolated,  
    iIIsWebServer_AppPackageID,  
    iIIsWebServer_AppPackageName,  
    iIIsWebServer_AppOopRecoverLimit,  
    iIIsWebServer_AppAllowDebugging,  
    iIIsWebServer_AppAllowClientDebug,  
    iIIsWebServer_NetLogonWorkstation,  
    iIIsWebServer_UseHostName,  
    iIIsWebServer_ClusterEnabled,  
    iIIsWebServer_CacheControlMaxAge,  
    iIIsWebServer_CacheControlNoCache,  
    iIIsWebServer_CacheControlCustom,  
    iIIsWebServer_CreateProcessAsUser,  
    iIIsWebServer_PoolIdcTimeout,  
    iIIsWebServer_PutReadSize,  
    iIIsWebServer_RedirectHeaders,  
    iIIsWebServer_UploadReadAheadSize,  
    iIIsWebServer_PasswordExpirePrenotifyDays,  
    iIIsWebServer_PasswordCacheTTL,  
    iIIsWebServer_PasswordChangeFlags,  
    iIIsWebServer_MaxBandwidthBlocked,  
    iIIsWebServer_UNCAuthenticationPassThrough,  
    iIIsWebServer_AppWamClsid,  
    iIIsWebServer_DirBrowseFlags,  
    iIIsWebServer_AuthFlags,  
    iIIsWebServer_AuthPersistence,  
    iIIsWebServer_AccessFlags,  
    iIIsWebServer_AccessSSLFlags,  
    iIIsWebServer_ScriptMaps,  
    iIIsWebServer_SSIExecDisable,  
    iIIsWebServer_EnableReverseDns,  
    iIIsWebServer_CreateCGIWithNewConsole,  
    iIIsWebServer_LogType,  
    iIIsWebServer_LogPluginClsid,  
    iIIsWebServer_LogFileDirectory,  
    iIIsWebServer_LogFilePeriod,  
    iIIsWebServer_LogFileLocaltimeRollover,  
    iIIsWebServer_LogFileTruncateSize,  
    iIIsWebServer_LogExtFileFlags,  
    iIIsWebServer_LogOdbcDataSource,  
    iIIsWebServer_LogOdbcTableName,  
    iIIsWebServer_LogOdbcUserName,  
    iIIsWebServer_LogOdbcPassword,  
    iIIsWebServer_CPULimitsEnabled,  
    iIIsWebServer_CPUResetInterval,  
    iIIsWebServer_CPULoggingInterval,  
    iIIsWebServer_CPULoggingOptions,  
    iIIsWebServer_CPULoggingMask,  
    iIIsWebServer_CPUCGILimit,  
    iIIsWebServer_CPULimitLogEvent,  
    iIIsWebServer_CPULimitPriority,  
    iIIsWebServer_CPULimitProcStop,  
    iIIsWebServer_CPULimitPause,  
    iIIsWebServer_CPUAppEnabled,  
    iIIsWebServer_CPUCGIEnabled,  
    iIIsWebServer_NotDeletable,  
    iIIsWebServer_ShutdownTimeLimit,  
    iIIsWebServer_SSLCertHash,  
    iIIsWebServer_SSLStoreName,  
    iIIsWebServer_ProcessNTCRIfLoggedOn,  
    iIIsWebServer_AllowPathInfoForScriptMappings,  
    iIIsWebServer_ServerCommand,  
    iIIsWebServer_MD_ISM_ACCESS_CHECK,  
    iIIsWebServer_Win32Error,  
    iIIsWebServer_AppPoolId,  
    iIIsWebServer_DoStaticCompression,  
    iIIsWebServer_DoDynamicCompression,  
    iIIsWebServer_DisablePublishing,  
    iIIsWebServer_DavEnabled,  
    iIIsWebServer_AspPartitionID,  
    iIIsWebServer_AspSxsName,  
    iIIsWebServer_AspAppServiceFlags,  
    iIIsWebServer_AspKeepSessionIDSecure,  
    iIIsWebServer_RevocationFreshnessTime,  
    iIIsWebServer_RevocationURLRetrievalTimeout,  
    cIIsWebServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebServerRow {
         WCHAR *     pLocation;
         ULONG *     pContentIndexed;
         WCHAR *     pKeyType;
         ULONG *     pServerState;
         WCHAR *     pServerComment;
         ULONG *     pMaxBandwidth;
         ULONG *     pServerAutoStart;
         ULONG *     pServerSize;
         ULONG *     pDisableSocketPooling;
         ULONG *     pServerListenBacklog;
         ULONG *     pServerListenTimeout;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
         ULONG *     pMaxConnections;
         ULONG *     pConnectionTimeout;
         ULONG *     pAllowKeepAlive;
         ULONG *     pCGITimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pIgnoreTranslate;
         ULONG *     pUseDigestSSP;
         ULONG *     pCacheISAPI;
         WCHAR *     pMimeMap;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pFrontPageWeb;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pDefaultLogonDomain;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pRealm;
         WCHAR *     pDefaultDoc;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         ULONG *     pLogonMethod;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pCertCheckMode;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspScriptErrorSentToBrowser;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         ULONG *     pAspScriptEngineCacheMax;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspAllowSessionState;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspCodepage;
         ULONG *     pAspLCID;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspQueueTimeout;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspSessionMax;
         ULONG *     pAspThreadGateEnabled;
         ULONG *     pAspThreadGateTimeSlice;
         ULONG *     pAspThreadGateSleepDelay;
         ULONG *     pAspThreadGateSleepMax;
         ULONG *     pAspThreadGateLoadLow;
         ULONG *     pAspThreadGateLoadHigh;
         WCHAR *     pAppRoot;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppIsolated;
         WCHAR *     pAppPackageID;
         WCHAR *     pAppPackageName;
         ULONG *     pAppOopRecoverLimit;
         ULONG *     pAppAllowDebugging;
         ULONG *     pAppAllowClientDebug;
         ULONG *     pNetLogonWorkstation;
         ULONG *     pUseHostName;
         ULONG *     pClusterEnabled;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         ULONG *     pPutReadSize;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pPasswordExpirePrenotifyDays;
         ULONG *     pPasswordCacheTTL;
         ULONG *     pPasswordChangeFlags;
         ULONG *     pMaxBandwidthBlocked;
         ULONG *     pUNCAuthenticationPassThrough;
         WCHAR *     pAppWamClsid;
         ULONG *     pDirBrowseFlags;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pCPULimitsEnabled;
         ULONG *     pCPUResetInterval;
         ULONG *     pCPULoggingInterval;
         ULONG *     pCPULoggingOptions;
         ULONG *     pCPULoggingMask;
         ULONG *     pCPUCGILimit;
         ULONG *     pCPULimitLogEvent;
         ULONG *     pCPULimitPriority;
         ULONG *     pCPULimitProcStop;
         ULONG *     pCPULimitPause;
         ULONG *     pCPUAppEnabled;
         ULONG *     pCPUCGIEnabled;
         ULONG *     pNotDeletable;
         ULONG *     pShutdownTimeLimit;
 unsigned char *     pSSLCertHash;
         WCHAR *     pSSLStoreName;
         ULONG *     pProcessNTCRIfLoggedOn;
         ULONG *     pAllowPathInfoForScriptMappings;
         ULONG *     pServerCommand;
         ULONG *     pMD_ISM_ACCESS_CHECK;
         ULONG *     pWin32Error;
         WCHAR *     pAppPoolId;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         ULONG *     pDisablePublishing;
         ULONG *     pDavEnabled;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pAspKeepSessionIDSecure;
         ULONG *     pRevocationFreshnessTime;
         ULONG *     pRevocationURLRetrievalTimeout;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFtpServer                            L"IIsFtpServer"
#define TABLEID_IIsFtpServer                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFtpServer                         (0L)
#define ExtendedVersion_IIsFtpServer                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsFtpServer {
    iIIsFtpServer_Location,  
    iIIsFtpServer_KeyType,  
    iIIsFtpServer_MaxConnections,  
    iIIsFtpServer_ServerState,  
    iIIsFtpServer_AnonymousUserName,  
    iIIsFtpServer_AnonymousUserPass,  
    iIIsFtpServer_ServerListenBacklog,  
    iIIsFtpServer_DisableSocketPooling,  
    iIIsFtpServer_LogAnonymous,  
    iIIsFtpServer_LogNonAnonymous,  
    iIIsFtpServer_ServerComment,  
    iIIsFtpServer_ServerBindings,  
    iIIsFtpServer_ConnectionTimeout,  
    iIIsFtpServer_ServerListenTimeout,  
    iIIsFtpServer_MaxEndpointConnections,  
    iIIsFtpServer_ServerAutoStart,  
    iIIsFtpServer_ExitMessage,  
    iIIsFtpServer_GreetingMessage,  
    iIIsFtpServer_MaxClientsMessage,  
    iIIsFtpServer_AnonymousOnly,  
    iIIsFtpServer_MSDOSDirOutput,  
    iIIsFtpServer_ServerSize,  
    iIIsFtpServer_AnonymousPasswordSync,  
    iIIsFtpServer_AllowAnonymous,  
    iIIsFtpServer_DefaultLogonDomain,  
    iIIsFtpServer_AdminACL,  
    iIIsFtpServer_AdminACLBin,  
    iIIsFtpServer_IPSecurity,  
    iIIsFtpServer_DontLog,  
    iIIsFtpServer_Realm,  
    iIIsFtpServer_ClusterEnabled,  
    iIIsFtpServer_LogType,  
    iIIsFtpServer_LogPluginClsid,  
    iIIsFtpServer_LogFileDirectory,  
    iIIsFtpServer_LogFilePeriod,  
    iIIsFtpServer_LogFileLocaltimeRollover,  
    iIIsFtpServer_LogFileTruncateSize,  
    iIIsFtpServer_LogExtFileFlags,  
    iIIsFtpServer_LogOdbcDataSource,  
    iIIsFtpServer_LogOdbcTableName,  
    iIIsFtpServer_LogOdbcUserName,  
    iIIsFtpServer_LogOdbcPassword,  
    iIIsFtpServer_AccessFlags,  
    iIIsFtpServer_Win32Error,  
    iIIsFtpServer_FtpDirBrowseShowLongDate,  
    iIIsFtpServer_BannerMessage,  
    iIIsFtpServer_UserIsolationMode,  
    iIIsFtpServer_FtpLogInUtf8,  
    cIIsFtpServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFtpServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxConnections;
         ULONG *     pServerState;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pServerListenBacklog;
         ULONG *     pDisableSocketPooling;
         ULONG *     pLogAnonymous;
         ULONG *     pLogNonAnonymous;
         WCHAR *     pServerComment;
         WCHAR *     pServerBindings;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pExitMessage;
         WCHAR *     pGreetingMessage;
         WCHAR *     pMaxClientsMessage;
         ULONG *     pAnonymousOnly;
         ULONG *     pMSDOSDirOutput;
         ULONG *     pServerSize;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pAllowAnonymous;
         WCHAR *     pDefaultLogonDomain;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pRealm;
         ULONG *     pClusterEnabled;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pAccessFlags;
         ULONG *     pWin32Error;
         ULONG *     pFtpDirBrowseShowLongDate;
         WCHAR *     pBannerMessage;
         ULONG *     pUserIsolationMode;
         ULONG *     pFtpLogInUtf8;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebFile                              L"IIsWebFile"
#define TABLEID_IIsWebFile                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebFile                           (0L)
#define ExtendedVersion_IIsWebFile                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebFile {
    iIIsWebFile_Location,  
    iIIsWebFile_KeyType,  
    iIIsWebFile_AnonymousUserName,  
    iIIsWebFile_AnonymousUserPass,  
    iIIsWebFile_AnonymousPasswordSync,  
    iIIsWebFile_UNCAuthenticationPassThrough,  
    iIIsWebFile_IgnoreTranslate,  
    iIIsWebFile_UseDigestSSP,  
    iIIsWebFile_CGITimeout,  
    iIIsWebFile_DefaultLogonDomain,  
    iIIsWebFile_LogonMethod,  
    iIIsWebFile_Realm,  
    iIIsWebFile_MimeMap,  
    iIIsWebFile_IPSecurity,  
    iIIsWebFile_DontLog,  
    iIIsWebFile_HttpExpires,  
    iIIsWebFile_HttpPics,  
    iIIsWebFile_HttpCustomHeaders,  
    iIIsWebFile_HttpErrors,  
    iIIsWebFile_EnableDocFooter,  
    iIIsWebFile_DefaultDocFooter,  
    iIIsWebFile_HttpRedirect,  
    iIIsWebFile_CacheControlMaxAge,  
    iIIsWebFile_CacheControlNoCache,  
    iIIsWebFile_CacheControlCustom,  
    iIIsWebFile_CreateProcessAsUser,  
    iIIsWebFile_PoolIdcTimeout,  
    iIIsWebFile_PutReadSize,  
    iIIsWebFile_RedirectHeaders,  
    iIIsWebFile_UploadReadAheadSize,  
    iIIsWebFile_AuthFlags,  
    iIIsWebFile_AuthPersistence,  
    iIIsWebFile_AccessFlags,  
    iIIsWebFile_AccessSSLFlags,  
    iIIsWebFile_ScriptMaps,  
    iIIsWebFile_CPUAppEnabled,  
    iIIsWebFile_CPUCGIEnabled,  
    iIIsWebFile_SSIExecDisable,  
    iIIsWebFile_EnableReverseDns,  
    iIIsWebFile_CreateCGIWithNewConsole,  
    iIIsWebFile_DoStaticCompression,  
    iIIsWebFile_DoDynamicCompression,  
    iIIsWebFile_DavEnabled,  
    cIIsWebFile_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebFileRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pUNCAuthenticationPassThrough;
         ULONG *     pIgnoreTranslate;
         ULONG *     pUseDigestSSP;
         ULONG *     pCGITimeout;
         WCHAR *     pDefaultLogonDomain;
         ULONG *     pLogonMethod;
         WCHAR *     pRealm;
         WCHAR *     pMimeMap;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pHttpRedirect;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         ULONG *     pPutReadSize;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pAuthFlags;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         WCHAR *     pScriptMaps;
         ULONG *     pCPUAppEnabled;
         ULONG *     pCPUCGIEnabled;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         ULONG *     pDavEnabled;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebDirectory                         L"IIsWebDirectory"
#define TABLEID_IIsWebDirectory                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebDirectory                      (0L)
#define ExtendedVersion_IIsWebDirectory                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebDirectory {
    iIIsWebDirectory_Location,  
    iIIsWebDirectory_KeyType,  
    iIIsWebDirectory_AnonymousUserName,  
    iIIsWebDirectory_AnonymousUserPass,  
    iIIsWebDirectory_AnonymousPasswordSync,  
    iIIsWebDirectory_IgnoreTranslate,  
    iIIsWebDirectory_UseDigestSSP,  
    iIIsWebDirectory_AppRoot,  
    iIIsWebDirectory_AppFriendlyName,  
    iIIsWebDirectory_AppOopRecoverLimit,  
    iIIsWebDirectory_AppIsolated,  
    iIIsWebDirectory_AppPackageName,  
    iIIsWebDirectory_AppPackageID,  
    iIIsWebDirectory_CacheISAPI,  
    iIIsWebDirectory_AppAllowDebugging,  
    iIIsWebDirectory_AppAllowClientDebug,  
    iIIsWebDirectory_DefaultLogonDomain,  
    iIIsWebDirectory_LogonMethod,  
    iIIsWebDirectory_CGITimeout,  
    iIIsWebDirectory_Realm,  
    iIIsWebDirectory_IPSecurity,  
    iIIsWebDirectory_DontLog,  
    iIIsWebDirectory_HttpExpires,  
    iIIsWebDirectory_HttpPics,  
    iIIsWebDirectory_HttpCustomHeaders,  
    iIIsWebDirectory_HttpErrors,  
    iIIsWebDirectory_EnableDocFooter,  
    iIIsWebDirectory_DefaultDocFooter,  
    iIIsWebDirectory_HttpRedirect,  
    iIIsWebDirectory_DefaultDoc,  
    iIIsWebDirectory_ContentIndexed,  
    iIIsWebDirectory_CacheControlMaxAge,  
    iIIsWebDirectory_CacheControlNoCache,  
    iIIsWebDirectory_CacheControlCustom,  
    iIIsWebDirectory_CreateProcessAsUser,  
    iIIsWebDirectory_PoolIdcTimeout,  
    iIIsWebDirectory_PutReadSize,  
    iIIsWebDirectory_RedirectHeaders,  
    iIIsWebDirectory_UploadReadAheadSize,  
    iIIsWebDirectory_FrontPageWeb,  
    iIIsWebDirectory_UNCAuthenticationPassThrough,  
    iIIsWebDirectory_AppWamClsid,  
    iIIsWebDirectory_AuthPersistence,  
    iIIsWebDirectory_AccessFlags,  
    iIIsWebDirectory_AccessSSLFlags,  
    iIIsWebDirectory_ScriptMaps,  
    iIIsWebDirectory_SSIExecDisable,  
    iIIsWebDirectory_EnableReverseDns,  
    iIIsWebDirectory_CreateCGIWithNewConsole,  
    iIIsWebDirectory_AspBufferingOn,  
    iIIsWebDirectory_AspLogErrorRequests,  
    iIIsWebDirectory_AspScriptErrorSentToBrowser,  
    iIIsWebDirectory_AspScriptErrorMessage,  
    iIIsWebDirectory_AspAllowOutOfProcComponents,  
    iIIsWebDirectory_AspScriptFileCacheSize,  
    iIIsWebDirectory_AspDiskTemplateCacheDirectory,  
    iIIsWebDirectory_AspMaxDiskTemplateCacheFiles,  
    iIIsWebDirectory_AspScriptEngineCacheMax,  
    iIIsWebDirectory_AspScriptTimeout,  
    iIIsWebDirectory_AspSessionTimeout,  
    iIIsWebDirectory_AspEnableParentPaths,  
    iIIsWebDirectory_AspAllowSessionState,  
    iIIsWebDirectory_AspScriptLanguage,  
    iIIsWebDirectory_AspExceptionCatchEnable,  
    iIIsWebDirectory_AspCodepage,  
    iIIsWebDirectory_AspLCID,  
    iIIsWebDirectory_MimeMap,  
    iIIsWebDirectory_AspQueueTimeout,  
    iIIsWebDirectory_CPUAppEnabled,  
    iIIsWebDirectory_CPUCGIEnabled,  
    iIIsWebDirectory_AspEnableAspHtmlFallback,  
    iIIsWebDirectory_AspEnableChunkedEncoding,  
    iIIsWebDirectory_AspEnableTypelibCache,  
    iIIsWebDirectory_AspErrorsToNTLog,  
    iIIsWebDirectory_AspProcessorThreadMax,  
    iIIsWebDirectory_AspTrackThreadingModel,  
    iIIsWebDirectory_AspRequestQueueMax,  
    iIIsWebDirectory_AspEnableApplicationRestart,  
    iIIsWebDirectory_AspQueueConnectionTestTime,  
    iIIsWebDirectory_AspSessionMax,  
    iIIsWebDirectory_AspThreadGateEnabled,  
    iIIsWebDirectory_AspThreadGateTimeSlice,  
    iIIsWebDirectory_AspThreadGateSleepDelay,  
    iIIsWebDirectory_AspThreadGateSleepMax,  
    iIIsWebDirectory_AspThreadGateLoadLow,  
    iIIsWebDirectory_AspThreadGateLoadHigh,  
    iIIsWebDirectory_ShutdownTimeLimit,  
    iIIsWebDirectory_DirBrowseFlags,  
    iIIsWebDirectory_AuthFlags,  
    iIIsWebDirectory_AppPoolId,  
    iIIsWebDirectory_DoStaticCompression,  
    iIIsWebDirectory_DoDynamicCompression,  
    iIIsWebDirectory_DisablePublishing,  
    iIIsWebDirectory_DavEnabled,  
    iIIsWebDirectory_AspPartitionID,  
    iIIsWebDirectory_AspSxsName,  
    iIIsWebDirectory_AspAppServiceFlags,  
    iIIsWebDirectory_AspKeepSessionIDSecure,  
    cIIsWebDirectory_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebDirectoryRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pIgnoreTranslate;
         ULONG *     pUseDigestSSP;
         WCHAR *     pAppRoot;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppOopRecoverLimit;
         ULONG *     pAppIsolated;
         WCHAR *     pAppPackageName;
         WCHAR *     pAppPackageID;
         ULONG *     pCacheISAPI;
         ULONG *     pAppAllowDebugging;
         ULONG *     pAppAllowClientDebug;
         WCHAR *     pDefaultLogonDomain;
         ULONG *     pLogonMethod;
         ULONG *     pCGITimeout;
         WCHAR *     pRealm;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pHttpRedirect;
         WCHAR *     pDefaultDoc;
         ULONG *     pContentIndexed;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         ULONG *     pPutReadSize;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pFrontPageWeb;
         ULONG *     pUNCAuthenticationPassThrough;
         WCHAR *     pAppWamClsid;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspScriptErrorSentToBrowser;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         ULONG *     pAspScriptEngineCacheMax;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspAllowSessionState;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspCodepage;
         ULONG *     pAspLCID;
         WCHAR *     pMimeMap;
         ULONG *     pAspQueueTimeout;
         ULONG *     pCPUAppEnabled;
         ULONG *     pCPUCGIEnabled;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspSessionMax;
         ULONG *     pAspThreadGateEnabled;
         ULONG *     pAspThreadGateTimeSlice;
         ULONG *     pAspThreadGateSleepDelay;
         ULONG *     pAspThreadGateSleepMax;
         ULONG *     pAspThreadGateLoadLow;
         ULONG *     pAspThreadGateLoadHigh;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pDirBrowseFlags;
         ULONG *     pAuthFlags;
         WCHAR *     pAppPoolId;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         ULONG *     pDisablePublishing;
         ULONG *     pDavEnabled;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pAspKeepSessionIDSecure;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebVirtualDir                        L"IIsWebVirtualDir"
#define TABLEID_IIsWebVirtualDir                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebVirtualDir                     (0L)
#define ExtendedVersion_IIsWebVirtualDir                 (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebVirtualDir {
    iIIsWebVirtualDir_Location,  
    iIIsWebVirtualDir_KeyType,  
    iIIsWebVirtualDir_AnonymousUserName,  
    iIIsWebVirtualDir_AnonymousUserPass,  
    iIIsWebVirtualDir_AnonymousPasswordSync,  
    iIIsWebVirtualDir_IgnoreTranslate,  
    iIIsWebVirtualDir_UseDigestSSP,  
    iIIsWebVirtualDir_AppRoot,  
    iIIsWebVirtualDir_AppFriendlyName,  
    iIIsWebVirtualDir_AppOopRecoverLimit,  
    iIIsWebVirtualDir_AppIsolated,  
    iIIsWebVirtualDir_AppPackageName,  
    iIIsWebVirtualDir_AppPackageID,  
    iIIsWebVirtualDir_CacheISAPI,  
    iIIsWebVirtualDir_AppAllowDebugging,  
    iIIsWebVirtualDir_AppAllowClientDebug,  
    iIIsWebVirtualDir_DefaultLogonDomain,  
    iIIsWebVirtualDir_LogonMethod,  
    iIIsWebVirtualDir_CGITimeout,  
    iIIsWebVirtualDir_Realm,  
    iIIsWebVirtualDir_IPSecurity,  
    iIIsWebVirtualDir_DontLog,  
    iIIsWebVirtualDir_HttpExpires,  
    iIIsWebVirtualDir_HttpPics,  
    iIIsWebVirtualDir_HttpCustomHeaders,  
    iIIsWebVirtualDir_HttpErrors,  
    iIIsWebVirtualDir_EnableDocFooter,  
    iIIsWebVirtualDir_DefaultDocFooter,  
    iIIsWebVirtualDir_HttpRedirect,  
    iIIsWebVirtualDir_DefaultDoc,  
    iIIsWebVirtualDir_ContentIndexed,  
    iIIsWebVirtualDir_CacheControlMaxAge,  
    iIIsWebVirtualDir_CacheControlNoCache,  
    iIIsWebVirtualDir_CacheControlCustom,  
    iIIsWebVirtualDir_CreateProcessAsUser,  
    iIIsWebVirtualDir_PoolIdcTimeout,  
    iIIsWebVirtualDir_PutReadSize,  
    iIIsWebVirtualDir_RedirectHeaders,  
    iIIsWebVirtualDir_UploadReadAheadSize,  
    iIIsWebVirtualDir_FrontPageWeb,  
    iIIsWebVirtualDir_Path,  
    iIIsWebVirtualDir_UNCUserName,  
    iIIsWebVirtualDir_UNCPassword,  
    iIIsWebVirtualDir_UNCAuthenticationPassThrough,  
    iIIsWebVirtualDir_AppWamClsid,  
    iIIsWebVirtualDir_AuthPersistence,  
    iIIsWebVirtualDir_AccessFlags,  
    iIIsWebVirtualDir_AccessSSLFlags,  
    iIIsWebVirtualDir_ScriptMaps,  
    iIIsWebVirtualDir_SSIExecDisable,  
    iIIsWebVirtualDir_EnableReverseDns,  
    iIIsWebVirtualDir_CreateCGIWithNewConsole,  
    iIIsWebVirtualDir_AspBufferingOn,  
    iIIsWebVirtualDir_AspLogErrorRequests,  
    iIIsWebVirtualDir_AspScriptErrorSentToBrowser,  
    iIIsWebVirtualDir_AspScriptErrorMessage,  
    iIIsWebVirtualDir_AspAllowOutOfProcComponents,  
    iIIsWebVirtualDir_AspScriptFileCacheSize,  
    iIIsWebVirtualDir_AspDiskTemplateCacheDirectory,  
    iIIsWebVirtualDir_AspMaxDiskTemplateCacheFiles,  
    iIIsWebVirtualDir_AspScriptEngineCacheMax,  
    iIIsWebVirtualDir_AspScriptTimeout,  
    iIIsWebVirtualDir_AspSessionTimeout,  
    iIIsWebVirtualDir_AspEnableParentPaths,  
    iIIsWebVirtualDir_AspAllowSessionState,  
    iIIsWebVirtualDir_AspScriptLanguage,  
    iIIsWebVirtualDir_AspExceptionCatchEnable,  
    iIIsWebVirtualDir_AspCodepage,  
    iIIsWebVirtualDir_AspLCID,  
    iIIsWebVirtualDir_MimeMap,  
    iIIsWebVirtualDir_AspQueueTimeout,  
    iIIsWebVirtualDir_CPUAppEnabled,  
    iIIsWebVirtualDir_CPUCGIEnabled,  
    iIIsWebVirtualDir_AspEnableAspHtmlFallback,  
    iIIsWebVirtualDir_AspEnableChunkedEncoding,  
    iIIsWebVirtualDir_AspEnableTypelibCache,  
    iIIsWebVirtualDir_AspErrorsToNTLog,  
    iIIsWebVirtualDir_AspProcessorThreadMax,  
    iIIsWebVirtualDir_AspTrackThreadingModel,  
    iIIsWebVirtualDir_AspRequestQueueMax,  
    iIIsWebVirtualDir_AspEnableApplicationRestart,  
    iIIsWebVirtualDir_AspQueueConnectionTestTime,  
    iIIsWebVirtualDir_AspSessionMax,  
    iIIsWebVirtualDir_AspThreadGateEnabled,  
    iIIsWebVirtualDir_AspThreadGateTimeSlice,  
    iIIsWebVirtualDir_AspThreadGateSleepDelay,  
    iIIsWebVirtualDir_AspThreadGateSleepMax,  
    iIIsWebVirtualDir_AspThreadGateLoadLow,  
    iIIsWebVirtualDir_AspThreadGateLoadHigh,  
    iIIsWebVirtualDir_ShutdownTimeLimit,  
    iIIsWebVirtualDir_DirBrowseFlags,  
    iIIsWebVirtualDir_AuthFlags,  
    iIIsWebVirtualDir_Win32Error,  
    iIIsWebVirtualDir_AppPoolId,  
    iIIsWebVirtualDir_DoStaticCompression,  
    iIIsWebVirtualDir_DoDynamicCompression,  
    iIIsWebVirtualDir_DisablePublishing,  
    iIIsWebVirtualDir_DavEnabled,  
    iIIsWebVirtualDir_AspPartitionID,  
    iIIsWebVirtualDir_AspSxsName,  
    iIIsWebVirtualDir_AspAppServiceFlags,  
    iIIsWebVirtualDir_AspKeepSessionIDSecure,  
    cIIsWebVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAnonymousPasswordSync;
         ULONG *     pIgnoreTranslate;
         ULONG *     pUseDigestSSP;
         WCHAR *     pAppRoot;
         WCHAR *     pAppFriendlyName;
         ULONG *     pAppOopRecoverLimit;
         ULONG *     pAppIsolated;
         WCHAR *     pAppPackageName;
         WCHAR *     pAppPackageID;
         ULONG *     pCacheISAPI;
         ULONG *     pAppAllowDebugging;
         ULONG *     pAppAllowClientDebug;
         WCHAR *     pDefaultLogonDomain;
         ULONG *     pLogonMethod;
         ULONG *     pCGITimeout;
         WCHAR *     pRealm;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         WCHAR *     pHttpExpires;
         WCHAR *     pHttpPics;
         WCHAR *     pHttpCustomHeaders;
         WCHAR *     pHttpErrors;
         ULONG *     pEnableDocFooter;
         WCHAR *     pDefaultDocFooter;
         WCHAR *     pHttpRedirect;
         WCHAR *     pDefaultDoc;
         ULONG *     pContentIndexed;
         ULONG *     pCacheControlMaxAge;
         ULONG *     pCacheControlNoCache;
         WCHAR *     pCacheControlCustom;
         ULONG *     pCreateProcessAsUser;
         ULONG *     pPoolIdcTimeout;
         ULONG *     pPutReadSize;
         WCHAR *     pRedirectHeaders;
         ULONG *     pUploadReadAheadSize;
         ULONG *     pFrontPageWeb;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pUNCAuthenticationPassThrough;
         WCHAR *     pAppWamClsid;
         ULONG *     pAuthPersistence;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         WCHAR *     pScriptMaps;
         ULONG *     pSSIExecDisable;
         ULONG *     pEnableReverseDns;
         ULONG *     pCreateCGIWithNewConsole;
         ULONG *     pAspBufferingOn;
         ULONG *     pAspLogErrorRequests;
         ULONG *     pAspScriptErrorSentToBrowser;
         WCHAR *     pAspScriptErrorMessage;
         ULONG *     pAspAllowOutOfProcComponents;
         ULONG *     pAspScriptFileCacheSize;
         WCHAR *     pAspDiskTemplateCacheDirectory;
         ULONG *     pAspMaxDiskTemplateCacheFiles;
         ULONG *     pAspScriptEngineCacheMax;
         ULONG *     pAspScriptTimeout;
         ULONG *     pAspSessionTimeout;
         ULONG *     pAspEnableParentPaths;
         ULONG *     pAspAllowSessionState;
         WCHAR *     pAspScriptLanguage;
         ULONG *     pAspExceptionCatchEnable;
         ULONG *     pAspCodepage;
         ULONG *     pAspLCID;
         WCHAR *     pMimeMap;
         ULONG *     pAspQueueTimeout;
         ULONG *     pCPUAppEnabled;
         ULONG *     pCPUCGIEnabled;
         ULONG *     pAspEnableAspHtmlFallback;
         ULONG *     pAspEnableChunkedEncoding;
         ULONG *     pAspEnableTypelibCache;
         ULONG *     pAspErrorsToNTLog;
         ULONG *     pAspProcessorThreadMax;
         ULONG *     pAspTrackThreadingModel;
         ULONG *     pAspRequestQueueMax;
         ULONG *     pAspEnableApplicationRestart;
         ULONG *     pAspQueueConnectionTestTime;
         ULONG *     pAspSessionMax;
         ULONG *     pAspThreadGateEnabled;
         ULONG *     pAspThreadGateTimeSlice;
         ULONG *     pAspThreadGateSleepDelay;
         ULONG *     pAspThreadGateSleepMax;
         ULONG *     pAspThreadGateLoadLow;
         ULONG *     pAspThreadGateLoadHigh;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pDirBrowseFlags;
         ULONG *     pAuthFlags;
         ULONG *     pWin32Error;
         WCHAR *     pAppPoolId;
         ULONG *     pDoStaticCompression;
         ULONG *     pDoDynamicCompression;
         ULONG *     pDisablePublishing;
         ULONG *     pDavEnabled;
         WCHAR *     pAspPartitionID;
         WCHAR *     pAspSxsName;
         ULONG *     pAspAppServiceFlags;
         ULONG *     pAspKeepSessionIDSecure;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFtpVirtualDir                        L"IIsFtpVirtualDir"
#define TABLEID_IIsFtpVirtualDir                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFtpVirtualDir                     (0L)
#define ExtendedVersion_IIsFtpVirtualDir                 (0L)

//-----------------Column Index Enums--------------   
enum eIIsFtpVirtualDir {
    iIIsFtpVirtualDir_Location,  
    iIIsFtpVirtualDir_KeyType,  
    iIIsFtpVirtualDir_Path,  
    iIIsFtpVirtualDir_UNCUserName,  
    iIIsFtpVirtualDir_UNCPassword,  
    iIIsFtpVirtualDir_AccessFlags,  
    iIIsFtpVirtualDir_DontLog,  
    iIIsFtpVirtualDir_IPSecurity,  
    iIIsFtpVirtualDir_FtpDirBrowseShowLongDate,  
    iIIsFtpVirtualDir_Win32Error,  
    cIIsFtpVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFtpVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pAccessFlags;
         ULONG *     pDontLog;
 unsigned char *     pIPSecurity;
         ULONG *     pFtpDirBrowseShowLongDate;
         ULONG *     pWin32Error;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFilter                               L"IIsFilter"
#define TABLEID_IIsFilter                                (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFilter                            (0L)
#define ExtendedVersion_IIsFilter                        (0L)

//-----------------Column Index Enums--------------   
enum eIIsFilter {
    iIIsFilter_Location,  
    iIIsFilter_KeyType,  
    iIIsFilter_FilterPath,  
    iIIsFilter_FilterDescription,  
    iIIsFilter_FilterFlags,  
    iIIsFilter_FilterState,  
    iIIsFilter_FilterEnabled,  
    iIIsFilter_Win32Error,  
    cIIsFilter_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFilterRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pFilterPath;
         WCHAR *     pFilterDescription;
         ULONG *     pFilterFlags;
         ULONG *     pFilterState;
         ULONG *     pFilterEnabled;
         ULONG *     pWin32Error;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFilters                              L"IIsFilters"
#define TABLEID_IIsFilters                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFilters                           (0L)
#define ExtendedVersion_IIsFilters                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsFilters {
    iIIsFilters_Location,  
    iIIsFilters_KeyType,  
    iIIsFilters_FilterLoadOrder,  
    cIIsFilters_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFiltersRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pFilterLoadOrder;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsCompressionScheme                    L"IIsCompressionScheme"
#define TABLEID_IIsCompressionScheme                     (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsCompressionScheme                 (0L)
#define ExtendedVersion_IIsCompressionScheme             (0L)

//-----------------Column Index Enums--------------   
enum eIIsCompressionScheme {
    iIIsCompressionScheme_Location,  
    iIIsCompressionScheme_KeyType,  
    iIIsCompressionScheme_HcDoDynamicCompression,  
    iIIsCompressionScheme_HcDoStaticCompression,  
    iIIsCompressionScheme_HcDoOnDemandCompression,  
    iIIsCompressionScheme_HcCompressionDll,  
    iIIsCompressionScheme_HcFileExtensions,  
    iIIsCompressionScheme_HcScriptFileExtensions,  
    iIIsCompressionScheme_HcMimeType,  
    iIIsCompressionScheme_HcPriority,  
    iIIsCompressionScheme_HcDynamicCompressionLevel,  
    iIIsCompressionScheme_HcOnDemandCompLevel,  
    iIIsCompressionScheme_HcCreateFlags,  
    cIIsCompressionScheme_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsCompressionSchemeRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pHcDoDynamicCompression;
         ULONG *     pHcDoStaticCompression;
         ULONG *     pHcDoOnDemandCompression;
         WCHAR *     pHcCompressionDll;
         WCHAR *     pHcFileExtensions;
         WCHAR *     pHcScriptFileExtensions;
         WCHAR *     pHcMimeType;
         ULONG *     pHcPriority;
         ULONG *     pHcDynamicCompressionLevel;
         ULONG *     pHcOnDemandCompLevel;
         ULONG *     pHcCreateFlags;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsCompressionSchemes                   L"IIsCompressionSchemes"
#define TABLEID_IIsCompressionSchemes                    (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsCompressionSchemes                (0L)
#define ExtendedVersion_IIsCompressionSchemes            (0L)

//-----------------Column Index Enums--------------   
enum eIIsCompressionSchemes {
    iIIsCompressionSchemes_Location,  
    iIIsCompressionSchemes_KeyType,  
    iIIsCompressionSchemes_HcCompressionDirectory,  
    iIIsCompressionSchemes_HcCacheControlHeader,  
    iIIsCompressionSchemes_HcExpiresHeader,  
    iIIsCompressionSchemes_HcDoDynamicCompression,  
    iIIsCompressionSchemes_HcDoStaticCompression,  
    iIIsCompressionSchemes_HcDoOnDemandCompression,  
    iIIsCompressionSchemes_HcDoDiskSpaceLimiting,  
    iIIsCompressionSchemes_HcNoCompressionForHttp10,  
    iIIsCompressionSchemes_HcNoCompressionForProxies,  
    iIIsCompressionSchemes_HcNoCompressionForRange,  
    iIIsCompressionSchemes_HcSendCacheHeaders,  
    iIIsCompressionSchemes_HcMaxDiskSpaceUsage,  
    iIIsCompressionSchemes_HcIoBufferSize,  
    iIIsCompressionSchemes_HcCompressionBufferSize,  
    iIIsCompressionSchemes_HcMaxQueueLength,  
    iIIsCompressionSchemes_HcFilesDeletedPerDiskFree,  
    iIIsCompressionSchemes_HcMinFileSizeForComp,  
    cIIsCompressionSchemes_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsCompressionSchemesRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pHcCompressionDirectory;
         WCHAR *     pHcCacheControlHeader;
         WCHAR *     pHcExpiresHeader;
         ULONG *     pHcDoDynamicCompression;
         ULONG *     pHcDoStaticCompression;
         ULONG *     pHcDoOnDemandCompression;
         ULONG *     pHcDoDiskSpaceLimiting;
         ULONG *     pHcNoCompressionForHttp10;
         ULONG *     pHcNoCompressionForProxies;
         ULONG *     pHcNoCompressionForRange;
         ULONG *     pHcSendCacheHeaders;
         ULONG *     pHcMaxDiskSpaceUsage;
         ULONG *     pHcIoBufferSize;
         ULONG *     pHcCompressionBufferSize;
         ULONG *     pHcMaxQueueLength;
         ULONG *     pHcFilesDeletedPerDiskFree;
         ULONG *     pHcMinFileSizeForComp;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsCertMapper                           L"IIsCertMapper"
#define TABLEID_IIsCertMapper                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsCertMapper                        (0L)
#define ExtendedVersion_IIsCertMapper                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsCertMapper {
    iIIsCertMapper_Location,  
    iIIsCertMapper_KeyType,  
    cIIsCertMapper_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsCertMapperRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsMimeMap                              L"IIsMimeMap"
#define TABLEID_IIsMimeMap                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsMimeMap                           (0L)
#define ExtendedVersion_IIsMimeMap                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsMimeMap {
    iIIsMimeMap_Location,  
    iIIsMimeMap_KeyType,  
    iIIsMimeMap_MimeMap,  
    cIIsMimeMap_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsMimeMapRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pMimeMap;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsLogModules                           L"IIsLogModules"
#define TABLEID_IIsLogModules                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsLogModules                        (0L)
#define ExtendedVersion_IIsLogModules                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsLogModules {
    iIIsLogModules_Location,  
    iIIsLogModules_KeyType,  
    iIIsLogModules_AdminACL,  
    cIIsLogModules_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsLogModulesRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsLogModule                            L"IIsLogModule"
#define TABLEID_IIsLogModule                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsLogModule                         (0L)
#define ExtendedVersion_IIsLogModule                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsLogModule {
    iIIsLogModule_Location,  
    iIIsLogModule_KeyType,  
    iIIsLogModule_LogModuleId,  
    iIIsLogModule_LogModuleUiId,  
    cIIsLogModule_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsLogModuleRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleId;
         WCHAR *     pLogModuleUiId;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsCustomLogModule                      L"IIsCustomLogModule"
#define TABLEID_IIsCustomLogModule                       (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsCustomLogModule                   (0L)
#define ExtendedVersion_IIsCustomLogModule               (0L)

//-----------------Column Index Enums--------------   
enum eIIsCustomLogModule {
    iIIsCustomLogModule_Location,  
    iIIsCustomLogModule_KeyType,  
    iIIsCustomLogModule_LogCustomPropertyName,  
    iIIsCustomLogModule_LogCustomPropertyHeader,  
    iIIsCustomLogModule_LogCustomPropertyID,  
    iIIsCustomLogModule_LogCustomPropertyMask,  
    iIIsCustomLogModule_LogCustomPropertyDataType,  
    iIIsCustomLogModule_LogCustomPropertyServicesString,  
    cIIsCustomLogModule_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsCustomLogModuleRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogCustomPropertyName;
         WCHAR *     pLogCustomPropertyHeader;
         ULONG *     pLogCustomPropertyID;
         ULONG *     pLogCustomPropertyMask;
         ULONG *     pLogCustomPropertyDataType;
         WCHAR *     pLogCustomPropertyServicesString;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsWebInfo                              L"IIsWebInfo"
#define TABLEID_IIsWebInfo                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsWebInfo                           (0L)
#define ExtendedVersion_IIsWebInfo                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsWebInfo {
    iIIsWebInfo_Location,  
    iIIsWebInfo_KeyType,  
    iIIsWebInfo_ServerConfigFlags,  
    iIIsWebInfo_CustomErrorDescriptions,  
    iIIsWebInfo_AdminServer,  
    iIIsWebInfo_LogModuleList,  
    iIIsWebInfo_MajorIIsVersionNumber,  
    iIIsWebInfo_MinorIIsVersionNumber,  
    iIIsWebInfo_MD_SERVER_CAPABILITIES,  
    iIIsWebInfo_AdminACL,  
    iIIsWebInfo_MD_SERVER_PLATFORM,  
    cIIsWebInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsWebInfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pServerConfigFlags;
         WCHAR *     pCustomErrorDescriptions;
         WCHAR *     pAdminServer;
         WCHAR *     pLogModuleList;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         ULONG *     pMD_SERVER_CAPABILITIES;
 unsigned char *     pAdminACL;
         ULONG *     pMD_SERVER_PLATFORM;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsFtpInfo                              L"IIsFtpInfo"
#define TABLEID_IIsFtpInfo                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsFtpInfo                           (0L)
#define ExtendedVersion_IIsFtpInfo                       (0L)

//-----------------Column Index Enums--------------   
enum eIIsFtpInfo {
    iIIsFtpInfo_Location,  
    iIIsFtpInfo_AdminACL,  
    iIIsFtpInfo_KeyType,  
    iIIsFtpInfo_LogModuleList,  
    iIIsFtpInfo_MD_SERVER_PLATFORM,  
    iIIsFtpInfo_MajorIIsVersionNumber,  
    iIIsFtpInfo_MinorIIsVersionNumber,  
    iIIsFtpInfo_MD_SERVER_CAPABILITIES,  
    cIIsFtpInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsFtpInfoRow {
         WCHAR *     pLocation;
 unsigned char *     pAdminACL;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
         ULONG *     pMD_SERVER_PLATFORM;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         ULONG *     pMD_SERVER_CAPABILITIES;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpService                          L"IIsNntpService"
#define TABLEID_IIsNntpService                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpService                       (0L)
#define ExtendedVersion_IIsNntpService                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpService {
    iIIsNntpService_Location,  
    iIIsNntpService_KeyType,  
    iIIsNntpService_MaxBandwidth,  
    iIIsNntpService_MaxConnections,  
    iIIsNntpService_AnonymousUserName,  
    iIIsNntpService_AnonymousUserPass,  
    iIIsNntpService_AllowAnonymous,  
    iIIsNntpService_DirectoryLevelsToScan,  
    iIIsNntpService_ServerComment,  
    iIIsNntpService_ConnectionTimeout,  
    iIIsNntpService_ServerListenTimeout,  
    iIIsNntpService_MaxEndpointConnections,  
    iIIsNntpService_ServerAutoStart,  
    iIIsNntpService_AnonymousPasswordSync,  
    iIIsNntpService_AdminACL,  
    iIIsNntpService_AdminACLBin,  
    iIIsNntpService_IPSecurity,  
    iIIsNntpService_DontLog,  
    iIIsNntpService_ContentIndexed,  
    iIIsNntpService_AuthFlags,  
    iIIsNntpService_ServerListenBacklog,  
    iIIsNntpService_HonorClientMsgIds,  
    iIIsNntpService_SmtpServer,  
    iIIsNntpService_AdminEmail,  
    iIIsNntpService_AdminName,  
    iIIsNntpService_AllowClientPosts,  
    iIIsNntpService_AllowFeedPosts,  
    iIIsNntpService_AllowControlMsgs,  
    iIIsNntpService_DefaultModeratorDomain,  
    iIIsNntpService_NntpCommandLogMask,  
    iIIsNntpService_DisableNewNews,  
    iIIsNntpService_ClientPostHardLimit,  
    iIIsNntpService_ClientPostSoftLimit,  
    iIIsNntpService_FeedPostHardLimit,  
    iIIsNntpService_FeedPostSoftLimit,  
    iIIsNntpService_LogType,  
    iIIsNntpService_LogFilePeriod,  
    iIIsNntpService_LogPluginClsid,  
    iIIsNntpService_LogModuleList,  
    iIIsNntpService_LogFileDirectory,  
    iIIsNntpService_LogFileTruncateSize,  
    iIIsNntpService_LogExtFileFlags,  
    iIIsNntpService_LogOdbcDataSource,  
    iIIsNntpService_LogOdbcTableName,  
    iIIsNntpService_LogOdbcUserName,  
    iIIsNntpService_LogOdbcPassword,  
    iIIsNntpService_FeedReportPeriod,  
    iIIsNntpService_MaxSearchResults,  
    iIIsNntpService_NntpServiceVersion,  
    iIIsNntpService_AccessSSLFlags,  
    iIIsNntpService_AccessFlags,  
    iIIsNntpService_ShutdownLatency,  
    iIIsNntpService_ArticleTimeLimit,  
    iIIsNntpService_HistoryExpiration,  
    iIIsNntpService_NewsCrawlerTime,  
    iIIsNntpService_GroupVarListFile,  
    iIIsNntpService_NTAuthenticationProviders,  
    cIIsNntpService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pAllowAnonymous;
         ULONG *     pDirectoryLevelsToScan;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         ULONG *     pAnonymousPasswordSync;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pContentIndexed;
         ULONG *     pAuthFlags;
         ULONG *     pServerListenBacklog;
         ULONG *     pHonorClientMsgIds;
         WCHAR *     pSmtpServer;
         WCHAR *     pAdminEmail;
         WCHAR *     pAdminName;
         ULONG *     pAllowClientPosts;
         ULONG *     pAllowFeedPosts;
         ULONG *     pAllowControlMsgs;
         WCHAR *     pDefaultModeratorDomain;
         ULONG *     pNntpCommandLogMask;
         ULONG *     pDisableNewNews;
         ULONG *     pClientPostHardLimit;
         ULONG *     pClientPostSoftLimit;
         ULONG *     pFeedPostHardLimit;
         ULONG *     pFeedPostSoftLimit;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pFeedReportPeriod;
         ULONG *     pMaxSearchResults;
         ULONG *     pNntpServiceVersion;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAccessFlags;
         ULONG *     pShutdownLatency;
         ULONG *     pArticleTimeLimit;
         ULONG *     pHistoryExpiration;
         ULONG *     pNewsCrawlerTime;
         WCHAR *     pGroupVarListFile;
         WCHAR *     pNTAuthenticationProviders;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpServer                           L"IIsNntpServer"
#define TABLEID_IIsNntpServer                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpServer                        (0L)
#define ExtendedVersion_IIsNntpServer                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpServer {
    iIIsNntpServer_Location,  
    iIIsNntpServer_KeyType,  
    iIIsNntpServer_MaxBandwidth,  
    iIIsNntpServer_MaxConnections,  
    iIIsNntpServer_AnonymousUserName,  
    iIIsNntpServer_AnonymousUserPass,  
    iIIsNntpServer_ServerComment,  
    iIIsNntpServer_ConnectionTimeout,  
    iIIsNntpServer_ServerListenTimeout,  
    iIIsNntpServer_MaxEndpointConnections,  
    iIIsNntpServer_ServerAutoStart,  
    iIIsNntpServer_ServerBindings,  
    iIIsNntpServer_SecureBindings,  
    iIIsNntpServer_ClusterEnabled,  
    iIIsNntpServer_AnonymousPasswordSync,  
    iIIsNntpServer_AdminACL,  
    iIIsNntpServer_AdminACLBin,  
    iIIsNntpServer_IPSecurity,  
    iIIsNntpServer_DontLog,  
    iIIsNntpServer_ContentIndexed,  
    iIIsNntpServer_AuthFlags,  
    iIIsNntpServer_ServerListenBacklog,  
    iIIsNntpServer_Win32Error,  
    iIIsNntpServer_ServerState,  
    iIIsNntpServer_HonorClientMsgIds,  
    iIIsNntpServer_SmtpServer,  
    iIIsNntpServer_AdminEmail,  
    iIIsNntpServer_AdminName,  
    iIIsNntpServer_AllowClientPosts,  
    iIIsNntpServer_AllowFeedPosts,  
    iIIsNntpServer_AllowControlMsgs,  
    iIIsNntpServer_DefaultModeratorDomain,  
    iIIsNntpServer_NntpCommandLogMask,  
    iIIsNntpServer_DisableNewNews,  
    iIIsNntpServer_ClientPostHardLimit,  
    iIIsNntpServer_ClientPostSoftLimit,  
    iIIsNntpServer_FeedPostHardLimit,  
    iIIsNntpServer_FeedPostSoftLimit,  
    iIIsNntpServer_NewsPickupDirectory,  
    iIIsNntpServer_NewsFailedPickupDirectory,  
    iIIsNntpServer_NewsDropDirectory,  
    iIIsNntpServer_LogType,  
    iIIsNntpServer_LogPluginClsid,  
    iIIsNntpServer_LogFileDirectory,  
    iIIsNntpServer_LogFilePeriod,  
    iIIsNntpServer_LogFileTruncateSize,  
    iIIsNntpServer_LogExtFileFlags,  
    iIIsNntpServer_LogOdbcDataSource,  
    iIIsNntpServer_LogOdbcTableName,  
    iIIsNntpServer_LogOdbcUserName,  
    iIIsNntpServer_LogOdbcPassword,  
    iIIsNntpServer_FeedReportPeriod,  
    iIIsNntpServer_MaxSearchResults,  
    iIIsNntpServer_NntpUucpName,  
    iIIsNntpServer_NntpServiceVersion,  
    iIIsNntpServer_AccessSSLFlags,  
    iIIsNntpServer_AccessFlags,  
    iIIsNntpServer_GroupHelpFile,  
    iIIsNntpServer_GroupListFile,  
    iIIsNntpServer_ArticleTableFile,  
    iIIsNntpServer_HistoryTableFile,  
    iIIsNntpServer_ListFile,  
    iIIsNntpServer_ModeratorFile,  
    iIIsNntpServer_XoverTableFile,  
    iIIsNntpServer_PrettyNamesFile,  
    iIIsNntpServer_GroupVarListFile,  
    iIIsNntpServer_SSLCertHash,  
    iIIsNntpServer_ArticleTimeLimit,  
    iIIsNntpServer_HistoryExpiration,  
    iIIsNntpServer_NewsCrawlerTime,  
    iIIsNntpServer_ShutdownLatency,  
    iIIsNntpServer_NntpOrganization,  
    iIIsNntpServer_NntpClearTextProvider,  
    iIIsNntpServer_NTAuthenticationProviders,  
    cIIsNntpServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pAnonymousUserPass;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
         ULONG *     pClusterEnabled;
         ULONG *     pAnonymousPasswordSync;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pContentIndexed;
         ULONG *     pAuthFlags;
         ULONG *     pServerListenBacklog;
         ULONG *     pWin32Error;
         ULONG *     pServerState;
         ULONG *     pHonorClientMsgIds;
         WCHAR *     pSmtpServer;
         WCHAR *     pAdminEmail;
         WCHAR *     pAdminName;
         ULONG *     pAllowClientPosts;
         ULONG *     pAllowFeedPosts;
         ULONG *     pAllowControlMsgs;
         WCHAR *     pDefaultModeratorDomain;
         ULONG *     pNntpCommandLogMask;
         ULONG *     pDisableNewNews;
         ULONG *     pClientPostHardLimit;
         ULONG *     pClientPostSoftLimit;
         ULONG *     pFeedPostHardLimit;
         ULONG *     pFeedPostSoftLimit;
         WCHAR *     pNewsPickupDirectory;
         WCHAR *     pNewsFailedPickupDirectory;
         WCHAR *     pNewsDropDirectory;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pFeedReportPeriod;
         ULONG *     pMaxSearchResults;
         WCHAR *     pNntpUucpName;
         ULONG *     pNntpServiceVersion;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAccessFlags;
         WCHAR *     pGroupHelpFile;
         WCHAR *     pGroupListFile;
         WCHAR *     pArticleTableFile;
         WCHAR *     pHistoryTableFile;
         WCHAR *     pListFile;
         WCHAR *     pModeratorFile;
         WCHAR *     pXoverTableFile;
         WCHAR *     pPrettyNamesFile;
         WCHAR *     pGroupVarListFile;
 unsigned char *     pSSLCertHash;
         ULONG *     pArticleTimeLimit;
         ULONG *     pHistoryExpiration;
         ULONG *     pNewsCrawlerTime;
         ULONG *     pShutdownLatency;
         WCHAR *     pNntpOrganization;
         WCHAR *     pNntpClearTextProvider;
         WCHAR *     pNTAuthenticationProviders;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpVirtualDir                       L"IIsNntpVirtualDir"
#define TABLEID_IIsNntpVirtualDir                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpVirtualDir                    (0L)
#define ExtendedVersion_IIsNntpVirtualDir                (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpVirtualDir {
    iIIsNntpVirtualDir_Location,  
    iIIsNntpVirtualDir_KeyType,  
    iIIsNntpVirtualDir_Path,  
    iIIsNntpVirtualDir_UNCUserName,  
    iIIsNntpVirtualDir_UNCPassword,  
    iIIsNntpVirtualDir_Win32Error,  
    iIIsNntpVirtualDir_ContentIndexed,  
    iIIsNntpVirtualDir_AccessSSLFlags,  
    iIIsNntpVirtualDir_AccessFlags,  
    iIIsNntpVirtualDir_VrDoExpire,  
    iIIsNntpVirtualDir_VrUseAccount,  
    iIIsNntpVirtualDir_VrOwnModerator,  
    iIIsNntpVirtualDir_VrDriverProgid,  
    iIIsNntpVirtualDir_FsPropertyPath,  
    iIIsNntpVirtualDir_ExMdbGuid,  
    iIIsNntpVirtualDir_DontLog,  
    iIIsNntpVirtualDir_VrDriverClsid,  
    cIIsNntpVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pWin32Error;
         ULONG *     pContentIndexed;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAccessFlags;
         ULONG *     pVrDoExpire;
         ULONG *     pVrUseAccount;
         ULONG *     pVrOwnModerator;
         WCHAR *     pVrDriverProgid;
         WCHAR *     pFsPropertyPath;
         WCHAR *     pExMdbGuid;
         ULONG *     pDontLog;
         WCHAR *     pVrDriverClsid;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpInfo                             L"IIsNntpInfo"
#define TABLEID_IIsNntpInfo                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpInfo                          (0L)
#define ExtendedVersion_IIsNntpInfo                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpInfo {
    iIIsNntpInfo_Location,  
    iIIsNntpInfo_KeyType,  
    iIIsNntpInfo_LogModuleList,  
    iIIsNntpInfo_MD_SERVER_PLATFORM,  
    iIIsNntpInfo_MajorIIsVersionNumber,  
    iIIsNntpInfo_MinorIIsVersionNumber,  
    iIIsNntpInfo_MD_SERVER_CAPABILITIES,  
    cIIsNntpInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpInfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
         ULONG *     pMD_SERVER_PLATFORM;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         ULONG *     pMD_SERVER_CAPABILITIES;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpService                          L"IIsSmtpService"
#define TABLEID_IIsSmtpService                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpService                       (0L)
#define ExtendedVersion_IIsSmtpService                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpService {
    iIIsSmtpService_Location,  
    iIIsSmtpService_KeyType,  
    iIIsSmtpService_MaxBandwidth,  
    iIIsSmtpService_MaxConnections,  
    iIIsSmtpService_ServerComment,  
    iIIsSmtpService_ConnectionTimeout,  
    iIIsSmtpService_ServerListenTimeout,  
    iIIsSmtpService_MaxEndpointConnections,  
    iIIsSmtpService_ServerAutoStart,  
    iIIsSmtpService_AdminACL,  
    iIIsSmtpService_AdminACLBin,  
    iIIsSmtpService_IPSecurity,  
    iIIsSmtpService_DontLog,  
    iIIsSmtpService_AccessFlags,  
    iIIsSmtpService_AccessSSLFlags,  
    iIIsSmtpService_AuthFlags,  
    iIIsSmtpService_LogType,  
    iIIsSmtpService_LogFilePeriod,  
    iIIsSmtpService_LogPluginClsid,  
    iIIsSmtpService_LogModuleList,  
    iIIsSmtpService_LogFileDirectory,  
    iIIsSmtpService_LogFileTruncateSize,  
    iIIsSmtpService_LogExtFileFlags,  
    iIIsSmtpService_LogOdbcDataSource,  
    iIIsSmtpService_LogOdbcTableName,  
    iIIsSmtpService_LogOdbcUserName,  
    iIIsSmtpService_LogOdbcPassword,  
    iIIsSmtpService_SmtpServiceVersion,  
    iIIsSmtpService_EnableReverseDnsLookup,  
    iIIsSmtpService_ShouldDeliver,  
    iIIsSmtpService_AlwaysUseSsl,  
    iIIsSmtpService_LimitRemoteConnections,  
    iIIsSmtpService_SmartHostType,  
    iIIsSmtpService_DoMasquerade,  
    iIIsSmtpService_RemoteSmtpPort,  
    iIIsSmtpService_RemoteSmtpSecurePort,  
    iIIsSmtpService_HopCount,  
    iIIsSmtpService_MaxOutConnections,  
    iIIsSmtpService_MaxOutConnectionsPerDomain,  
    iIIsSmtpService_RemoteTimeout,  
    iIIsSmtpService_MaxMessageSize,  
    iIIsSmtpService_MaxSessionSize,  
    iIIsSmtpService_MaxRecipients,  
    iIIsSmtpService_LocalRetryInterval,  
    iIIsSmtpService_RemoteRetryInterval,  
    iIIsSmtpService_LocalRetryAttempts,  
    iIIsSmtpService_RemoteRetryAttempts,  
    iIIsSmtpService_EtrnDays,  
    iIIsSmtpService_MaxBatchedMessages,  
    iIIsSmtpService_SmartHost,  
    iIIsSmtpService_FullyQualifiedDomainName,  
    iIIsSmtpService_DefaultDomain,  
    iIIsSmtpService_DropDirectory,  
    iIIsSmtpService_BadMailDirectory,  
    iIIsSmtpService_PickupDirectory,  
    iIIsSmtpService_QueueDirectory,  
    iIIsSmtpService_MasqueradeDomain,  
    iIIsSmtpService_SendNdrTo,  
    iIIsSmtpService_SendBadTo,  
    iIIsSmtpService_RoutingDll,  
    iIIsSmtpService_RoutingSources,  
    iIIsSmtpService_DomainRouting,  
    iIIsSmtpService_RouteAction,  
    iIIsSmtpService_RouteUserName,  
    iIIsSmtpService_RoutePassword,  
    iIIsSmtpService_SaslLogonDomain,  
    iIIsSmtpService_SmtpClearTextProvider,  
    iIIsSmtpService_NTAuthenticationProviders,  
    iIIsSmtpService_SmtpRemoteProgressiveRetry,  
    iIIsSmtpService_SmtpLocalDelayExpireMinutes,  
    iIIsSmtpService_SmtpLocalNDRExpireMinutes,  
    iIIsSmtpService_SmtpRemoteDelayExpireMinutes,  
    iIIsSmtpService_SmtpRemoteNDRExpireMinutes,  
    iIIsSmtpService_SmtpRemoteRetryThreshold,  
    iIIsSmtpService_SmtpDSNOptions,  
    iIIsSmtpService_SmtpDSNLanguageID,  
    iIIsSmtpService_SmtpAdvQueueDll,  
    iIIsSmtpService_SmtpInboundCommandSupportOptions,  
    iIIsSmtpService_SmtpOutboundCommandSupportOptions,  
    iIIsSmtpService_SmtpCommandLogMask,  
    iIIsSmtpService_SmtpFlushMailFile,  
    iIIsSmtpService_RelayIpList,  
    iIIsSmtpService_RelayForAuth,  
    iIIsSmtpService_SmtpConnectTimeout,  
    iIIsSmtpService_SmtpMailFromTimeout,  
    iIIsSmtpService_SmtpRcptToTimeout,  
    iIIsSmtpService_SmtpDataTimeout,  
    iIIsSmtpService_SmtpBdatTimeout,  
    iIIsSmtpService_SmtpAuthTimeout,  
    iIIsSmtpService_SmtpSaslTimeout,  
    iIIsSmtpService_SmtpTurnTimeout,  
    iIIsSmtpService_SmtpRsetTimeout,  
    iIIsSmtpService_SmtpHeloTimeout,  
    iIIsSmtpService_LocalDomains,  
    iIIsSmtpService_AnonymousUserPass,  
    iIIsSmtpService_DisableSocketPooling,  
    iIIsSmtpService_SmtpUseTcpDns,  
    iIIsSmtpService_SmtpDotStuffPickupDirFiles,  
    iIIsSmtpService_SmtpDomainValidationFlags,  
    iIIsSmtpService_SmtpSSLRequireTrustedCA,  
    iIIsSmtpService_SmtpSSLCertHostnameValidation,  
    iIIsSmtpService_MaxMailObjects,  
    iIIsSmtpService_ShouldPickupMail,  
    iIIsSmtpService_MaxDirChangeIOSize,  
    iIIsSmtpService_NameResolutionType,  
    iIIsSmtpService_MaxSmtpErrors,  
    iIIsSmtpService_ShouldPipelineIn,  
    iIIsSmtpService_ShouldPipelineOut,  
    iIIsSmtpService_ConnectResponse,  
    iIIsSmtpService_UpdatedFQDN,  
    iIIsSmtpService_UpdatedDefaultDomain,  
    iIIsSmtpService_EtrnSubdomains,  
    iIIsSmtpService_SmtpMaxRemoteQThreads,  
    iIIsSmtpService_SmtpDisableRelay,  
    iIIsSmtpService_SmtpHeloNoDomain,  
    iIIsSmtpService_SmtpMailNoHelo,  
    iIIsSmtpService_SmtpAqueueWait,  
    iIIsSmtpService_AddNoHeaders,  
    iIIsSmtpService_SmtpEventlogLevel,  
    iIIsSmtpService_AllowAnonymous,  
    iIIsSmtpService_AnonymousOnly,  
    iIIsSmtpService_AnonymousPasswordSync,  
    iIIsSmtpService_AnonymousUserName,  
    iIIsSmtpService_Realm,  
    iIIsSmtpService_DefaultLogonDomain,  
    cIIsSmtpService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pAuthFlags;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pSmtpServiceVersion;
         ULONG *     pEnableReverseDnsLookup;
         ULONG *     pShouldDeliver;
         ULONG *     pAlwaysUseSsl;
         ULONG *     pLimitRemoteConnections;
         ULONG *     pSmartHostType;
         ULONG *     pDoMasquerade;
         ULONG *     pRemoteSmtpPort;
         ULONG *     pRemoteSmtpSecurePort;
         ULONG *     pHopCount;
         ULONG *     pMaxOutConnections;
         ULONG *     pMaxOutConnectionsPerDomain;
         ULONG *     pRemoteTimeout;
         ULONG *     pMaxMessageSize;
         ULONG *     pMaxSessionSize;
         ULONG *     pMaxRecipients;
         ULONG *     pLocalRetryInterval;
         ULONG *     pRemoteRetryInterval;
         ULONG *     pLocalRetryAttempts;
         ULONG *     pRemoteRetryAttempts;
         ULONG *     pEtrnDays;
         ULONG *     pMaxBatchedMessages;
         WCHAR *     pSmartHost;
         WCHAR *     pFullyQualifiedDomainName;
         WCHAR *     pDefaultDomain;
         WCHAR *     pDropDirectory;
         WCHAR *     pBadMailDirectory;
         WCHAR *     pPickupDirectory;
         WCHAR *     pQueueDirectory;
         WCHAR *     pMasqueradeDomain;
         WCHAR *     pSendNdrTo;
         WCHAR *     pSendBadTo;
         WCHAR *     pRoutingDll;
         WCHAR *     pRoutingSources;
         WCHAR *     pDomainRouting;
         ULONG *     pRouteAction;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutePassword;
         WCHAR *     pSaslLogonDomain;
         WCHAR *     pSmtpClearTextProvider;
         WCHAR *     pNTAuthenticationProviders;
         WCHAR *     pSmtpRemoteProgressiveRetry;
         ULONG *     pSmtpLocalDelayExpireMinutes;
         ULONG *     pSmtpLocalNDRExpireMinutes;
         ULONG *     pSmtpRemoteDelayExpireMinutes;
         ULONG *     pSmtpRemoteNDRExpireMinutes;
         ULONG *     pSmtpRemoteRetryThreshold;
         ULONG *     pSmtpDSNOptions;
         ULONG *     pSmtpDSNLanguageID;
         WCHAR *     pSmtpAdvQueueDll;
         ULONG *     pSmtpInboundCommandSupportOptions;
         ULONG *     pSmtpOutboundCommandSupportOptions;
         ULONG *     pSmtpCommandLogMask;
         ULONG *     pSmtpFlushMailFile;
 unsigned char *     pRelayIpList;
         ULONG *     pRelayForAuth;
         ULONG *     pSmtpConnectTimeout;
         ULONG *     pSmtpMailFromTimeout;
         ULONG *     pSmtpRcptToTimeout;
         ULONG *     pSmtpDataTimeout;
         ULONG *     pSmtpBdatTimeout;
         ULONG *     pSmtpAuthTimeout;
         ULONG *     pSmtpSaslTimeout;
         ULONG *     pSmtpTurnTimeout;
         ULONG *     pSmtpRsetTimeout;
         ULONG *     pSmtpHeloTimeout;
         WCHAR *     pLocalDomains;
         WCHAR *     pAnonymousUserPass;
         ULONG *     pDisableSocketPooling;
         ULONG *     pSmtpUseTcpDns;
         ULONG *     pSmtpDotStuffPickupDirFiles;
         ULONG *     pSmtpDomainValidationFlags;
         ULONG *     pSmtpSSLRequireTrustedCA;
         ULONG *     pSmtpSSLCertHostnameValidation;
         ULONG *     pMaxMailObjects;
         ULONG *     pShouldPickupMail;
         ULONG *     pMaxDirChangeIOSize;
         ULONG *     pNameResolutionType;
         ULONG *     pMaxSmtpErrors;
         ULONG *     pShouldPipelineIn;
         ULONG *     pShouldPipelineOut;
         WCHAR *     pConnectResponse;
         ULONG *     pUpdatedFQDN;
         ULONG *     pUpdatedDefaultDomain;
         ULONG *     pEtrnSubdomains;
         ULONG *     pSmtpMaxRemoteQThreads;
         ULONG *     pSmtpDisableRelay;
         ULONG *     pSmtpHeloNoDomain;
         ULONG *     pSmtpMailNoHelo;
         ULONG *     pSmtpAqueueWait;
         ULONG *     pAddNoHeaders;
         ULONG *     pSmtpEventlogLevel;
         ULONG *     pAllowAnonymous;
         ULONG *     pAnonymousOnly;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pRealm;
         WCHAR *     pDefaultLogonDomain;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpServer                           L"IIsSmtpServer"
#define TABLEID_IIsSmtpServer                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpServer                        (0L)
#define ExtendedVersion_IIsSmtpServer                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpServer {
    iIIsSmtpServer_Location,  
    iIIsSmtpServer_KeyType,  
    iIIsSmtpServer_MaxBandwidth,  
    iIIsSmtpServer_MaxConnections,  
    iIIsSmtpServer_ServerComment,  
    iIIsSmtpServer_ConnectionTimeout,  
    iIIsSmtpServer_ServerListenTimeout,  
    iIIsSmtpServer_MaxEndpointConnections,  
    iIIsSmtpServer_ServerAutoStart,  
    iIIsSmtpServer_ServerBindings,  
    iIIsSmtpServer_SecureBindings,  
    iIIsSmtpServer_ClusterEnabled,  
    iIIsSmtpServer_AdminACL,  
    iIIsSmtpServer_AdminACLBin,  
    iIIsSmtpServer_IPSecurity,  
    iIIsSmtpServer_DontLog,  
    iIIsSmtpServer_AuthFlags,  
    iIIsSmtpServer_AccessFlags,  
    iIIsSmtpServer_AccessSSLFlags,  
    iIIsSmtpServer_ServerListenBacklog,  
    iIIsSmtpServer_Win32Error,  
    iIIsSmtpServer_ServerState,  
    iIIsSmtpServer_LogType,  
    iIIsSmtpServer_LogPluginClsid,  
    iIIsSmtpServer_LogFileDirectory,  
    iIIsSmtpServer_LogFilePeriod,  
    iIIsSmtpServer_LogFileTruncateSize,  
    iIIsSmtpServer_LogExtFileFlags,  
    iIIsSmtpServer_LogOdbcDataSource,  
    iIIsSmtpServer_LogOdbcTableName,  
    iIIsSmtpServer_LogOdbcUserName,  
    iIIsSmtpServer_LogOdbcPassword,  
    iIIsSmtpServer_SmtpServiceVersion,  
    iIIsSmtpServer_EnableReverseDnsLookup,  
    iIIsSmtpServer_ShouldDeliver,  
    iIIsSmtpServer_AlwaysUseSsl,  
    iIIsSmtpServer_LimitRemoteConnections,  
    iIIsSmtpServer_SmartHostType,  
    iIIsSmtpServer_DoMasquerade,  
    iIIsSmtpServer_RemoteSmtpPort,  
    iIIsSmtpServer_RemoteSmtpSecurePort,  
    iIIsSmtpServer_HopCount,  
    iIIsSmtpServer_MaxOutConnections,  
    iIIsSmtpServer_MaxOutConnectionsPerDomain,  
    iIIsSmtpServer_RemoteTimeout,  
    iIIsSmtpServer_MaxMessageSize,  
    iIIsSmtpServer_MaxSessionSize,  
    iIIsSmtpServer_MaxRecipients,  
    iIIsSmtpServer_LocalRetryInterval,  
    iIIsSmtpServer_RemoteRetryInterval,  
    iIIsSmtpServer_LocalRetryAttempts,  
    iIIsSmtpServer_RemoteRetryAttempts,  
    iIIsSmtpServer_EtrnDays,  
    iIIsSmtpServer_MaxBatchedMessages,  
    iIIsSmtpServer_SmartHost,  
    iIIsSmtpServer_FullyQualifiedDomainName,  
    iIIsSmtpServer_DefaultDomain,  
    iIIsSmtpServer_DropDirectory,  
    iIIsSmtpServer_BadMailDirectory,  
    iIIsSmtpServer_PickupDirectory,  
    iIIsSmtpServer_QueueDirectory,  
    iIIsSmtpServer_MasqueradeDomain,  
    iIIsSmtpServer_SendNdrTo,  
    iIIsSmtpServer_SendBadTo,  
    iIIsSmtpServer_RoutingDll,  
    iIIsSmtpServer_RoutingSources,  
    iIIsSmtpServer_DomainRouting,  
    iIIsSmtpServer_RouteAction,  
    iIIsSmtpServer_RouteUserName,  
    iIIsSmtpServer_RoutePassword,  
    iIIsSmtpServer_SaslLogonDomain,  
    iIIsSmtpServer_SmtpClearTextProvider,  
    iIIsSmtpServer_NTAuthenticationProviders,  
    iIIsSmtpServer_SmtpRemoteProgressiveRetry,  
    iIIsSmtpServer_SmtpLocalDelayExpireMinutes,  
    iIIsSmtpServer_SmtpLocalNDRExpireMinutes,  
    iIIsSmtpServer_SmtpRemoteDelayExpireMinutes,  
    iIIsSmtpServer_SmtpRemoteNDRExpireMinutes,  
    iIIsSmtpServer_SmtpRemoteRetryThreshold,  
    iIIsSmtpServer_SmtpDSNOptions,  
    iIIsSmtpServer_SmtpDSNLanguageID,  
    iIIsSmtpServer_SmtpInboundCommandSupportOptions,  
    iIIsSmtpServer_SmtpOutboundCommandSupportOptions,  
    iIIsSmtpServer_RelayIpList,  
    iIIsSmtpServer_RelayForAuth,  
    iIIsSmtpServer_SmtpConnectTimeout,  
    iIIsSmtpServer_SmtpMailFromTimeout,  
    iIIsSmtpServer_SmtpRcptToTimeout,  
    iIIsSmtpServer_SmtpDataTimeout,  
    iIIsSmtpServer_SmtpBdatTimeout,  
    iIIsSmtpServer_SmtpAuthTimeout,  
    iIIsSmtpServer_SmtpSaslTimeout,  
    iIIsSmtpServer_SmtpTurnTimeout,  
    iIIsSmtpServer_SmtpRsetTimeout,  
    iIIsSmtpServer_SmtpHeloTimeout,  
    iIIsSmtpServer_PostmasterName,  
    iIIsSmtpServer_PostmasterEmail,  
    iIIsSmtpServer_LocalDomains,  
    iIIsSmtpServer_SSLCertHash,  
    iIIsSmtpServer_DisableSocketPooling,  
    iIIsSmtpServer_SmtpUseTcpDns,  
    iIIsSmtpServer_SmtpDotStuffPickupDirFiles,  
    iIIsSmtpServer_SmtpDomainValidationFlags,  
    iIIsSmtpServer_SmtpSSLRequireTrustedCA,  
    iIIsSmtpServer_SmtpSSLCertHostnameValidation,  
    iIIsSmtpServer_MaxMailObjects,  
    iIIsSmtpServer_ShouldPickupMail,  
    iIIsSmtpServer_MaxDirChangeIOSize,  
    iIIsSmtpServer_NameResolutionType,  
    iIIsSmtpServer_MaxSmtpErrors,  
    iIIsSmtpServer_ShouldPipelineIn,  
    iIIsSmtpServer_ShouldPipelineOut,  
    iIIsSmtpServer_ConnectResponse,  
    iIIsSmtpServer_UpdatedFQDN,  
    iIIsSmtpServer_UpdatedDefaultDomain,  
    iIIsSmtpServer_EtrnSubdomains,  
    iIIsSmtpServer_SmtpMaxRemoteQThreads,  
    iIIsSmtpServer_SmtpDisableRelay,  
    iIIsSmtpServer_SmtpHeloNoDomain,  
    iIIsSmtpServer_SmtpMailNoHelo,  
    iIIsSmtpServer_SmtpAqueueWait,  
    iIIsSmtpServer_AddNoHeaders,  
    iIIsSmtpServer_SmtpEventlogLevel,  
    iIIsSmtpServer_AllowAnonymous,  
    iIIsSmtpServer_AnonymousOnly,  
    iIIsSmtpServer_AnonymousPasswordSync,  
    iIIsSmtpServer_AnonymousUserName,  
    iIIsSmtpServer_Realm,  
    iIIsSmtpServer_DefaultLogonDomain,  
    cIIsSmtpServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
         ULONG *     pClusterEnabled;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pServerListenBacklog;
         ULONG *     pWin32Error;
         ULONG *     pServerState;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pSmtpServiceVersion;
         ULONG *     pEnableReverseDnsLookup;
         ULONG *     pShouldDeliver;
         ULONG *     pAlwaysUseSsl;
         ULONG *     pLimitRemoteConnections;
         ULONG *     pSmartHostType;
         ULONG *     pDoMasquerade;
         ULONG *     pRemoteSmtpPort;
         ULONG *     pRemoteSmtpSecurePort;
         ULONG *     pHopCount;
         ULONG *     pMaxOutConnections;
         ULONG *     pMaxOutConnectionsPerDomain;
         ULONG *     pRemoteTimeout;
         ULONG *     pMaxMessageSize;
         ULONG *     pMaxSessionSize;
         ULONG *     pMaxRecipients;
         ULONG *     pLocalRetryInterval;
         ULONG *     pRemoteRetryInterval;
         ULONG *     pLocalRetryAttempts;
         ULONG *     pRemoteRetryAttempts;
         ULONG *     pEtrnDays;
         ULONG *     pMaxBatchedMessages;
         WCHAR *     pSmartHost;
         WCHAR *     pFullyQualifiedDomainName;
         WCHAR *     pDefaultDomain;
         WCHAR *     pDropDirectory;
         WCHAR *     pBadMailDirectory;
         WCHAR *     pPickupDirectory;
         WCHAR *     pQueueDirectory;
         WCHAR *     pMasqueradeDomain;
         WCHAR *     pSendNdrTo;
         WCHAR *     pSendBadTo;
         WCHAR *     pRoutingDll;
         WCHAR *     pRoutingSources;
         WCHAR *     pDomainRouting;
         ULONG *     pRouteAction;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutePassword;
         WCHAR *     pSaslLogonDomain;
         WCHAR *     pSmtpClearTextProvider;
         WCHAR *     pNTAuthenticationProviders;
         WCHAR *     pSmtpRemoteProgressiveRetry;
         ULONG *     pSmtpLocalDelayExpireMinutes;
         ULONG *     pSmtpLocalNDRExpireMinutes;
         ULONG *     pSmtpRemoteDelayExpireMinutes;
         ULONG *     pSmtpRemoteNDRExpireMinutes;
         ULONG *     pSmtpRemoteRetryThreshold;
         ULONG *     pSmtpDSNOptions;
         ULONG *     pSmtpDSNLanguageID;
         ULONG *     pSmtpInboundCommandSupportOptions;
         ULONG *     pSmtpOutboundCommandSupportOptions;
 unsigned char *     pRelayIpList;
         ULONG *     pRelayForAuth;
         ULONG *     pSmtpConnectTimeout;
         ULONG *     pSmtpMailFromTimeout;
         ULONG *     pSmtpRcptToTimeout;
         ULONG *     pSmtpDataTimeout;
         ULONG *     pSmtpBdatTimeout;
         ULONG *     pSmtpAuthTimeout;
         ULONG *     pSmtpSaslTimeout;
         ULONG *     pSmtpTurnTimeout;
         ULONG *     pSmtpRsetTimeout;
         ULONG *     pSmtpHeloTimeout;
         WCHAR *     pPostmasterName;
         WCHAR *     pPostmasterEmail;
         WCHAR *     pLocalDomains;
 unsigned char *     pSSLCertHash;
         ULONG *     pDisableSocketPooling;
         ULONG *     pSmtpUseTcpDns;
         ULONG *     pSmtpDotStuffPickupDirFiles;
         ULONG *     pSmtpDomainValidationFlags;
         ULONG *     pSmtpSSLRequireTrustedCA;
         ULONG *     pSmtpSSLCertHostnameValidation;
         ULONG *     pMaxMailObjects;
         ULONG *     pShouldPickupMail;
         ULONG *     pMaxDirChangeIOSize;
         ULONG *     pNameResolutionType;
         ULONG *     pMaxSmtpErrors;
         ULONG *     pShouldPipelineIn;
         ULONG *     pShouldPipelineOut;
         WCHAR *     pConnectResponse;
         ULONG *     pUpdatedFQDN;
         ULONG *     pUpdatedDefaultDomain;
         ULONG *     pEtrnSubdomains;
         ULONG *     pSmtpMaxRemoteQThreads;
         ULONG *     pSmtpDisableRelay;
         ULONG *     pSmtpHeloNoDomain;
         ULONG *     pSmtpMailNoHelo;
         ULONG *     pSmtpAqueueWait;
         ULONG *     pAddNoHeaders;
         ULONG *     pSmtpEventlogLevel;
         ULONG *     pAllowAnonymous;
         ULONG *     pAnonymousOnly;
         ULONG *     pAnonymousPasswordSync;
         WCHAR *     pAnonymousUserName;
         WCHAR *     pRealm;
         WCHAR *     pDefaultLogonDomain;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpVirtualDir                       L"IIsSmtpVirtualDir"
#define TABLEID_IIsSmtpVirtualDir                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpVirtualDir                    (0L)
#define ExtendedVersion_IIsSmtpVirtualDir                (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpVirtualDir {
    iIIsSmtpVirtualDir_Location,  
    iIIsSmtpVirtualDir_KeyType,  
    iIIsSmtpVirtualDir_Path,  
    iIIsSmtpVirtualDir_UNCUserName,  
    iIIsSmtpVirtualDir_UNCPassword,  
    iIIsSmtpVirtualDir_Win32Error,  
    iIIsSmtpVirtualDir_DontLog,  
    iIIsSmtpVirtualDir_AccessFlags,  
    iIIsSmtpVirtualDir_AccessSSLFlags,  
    cIIsSmtpVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pWin32Error;
         ULONG *     pDontLog;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpDomain                           L"IIsSmtpDomain"
#define TABLEID_IIsSmtpDomain                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpDomain                        (0L)
#define ExtendedVersion_IIsSmtpDomain                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpDomain {
    iIIsSmtpDomain_Location,  
    iIIsSmtpDomain_KeyType,  
    iIIsSmtpDomain_RouteAction,  
    iIIsSmtpDomain_RouteActionString,  
    iIIsSmtpDomain_RouteUserName,  
    iIIsSmtpDomain_RoutePassword,  
    iIIsSmtpDomain_RelayIpList,  
    iIIsSmtpDomain_RelayForAuth,  
    iIIsSmtpDomain_AuthTurnList,  
    iIIsSmtpDomain_CSideEtrnDomains,  
    cIIsSmtpDomain_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpDomainRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pRouteAction;
         WCHAR *     pRouteActionString;
         WCHAR *     pRouteUserName;
         WCHAR *     pRoutePassword;
 unsigned char *     pRelayIpList;
         ULONG *     pRelayForAuth;
         WCHAR *     pAuthTurnList;
         WCHAR *     pCSideEtrnDomains;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpRoutingSource                    L"IIsSmtpRoutingSource"
#define TABLEID_IIsSmtpRoutingSource                     (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpRoutingSource                 (0L)
#define ExtendedVersion_IIsSmtpRoutingSource             (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpRoutingSource {
    iIIsSmtpRoutingSource_Location,  
    iIIsSmtpRoutingSource_KeyType,  
    iIIsSmtpRoutingSource_SmtpRoutingTableType,  
    iIIsSmtpRoutingSource_SmtpDsDataDirectory,  
    iIIsSmtpRoutingSource_SmtpDsDefaultMailRoot,  
    iIIsSmtpRoutingSource_SmtpDsBindType,  
    iIIsSmtpRoutingSource_SmtpDsSchemaType,  
    iIIsSmtpRoutingSource_SmtpDsHost,  
    iIIsSmtpRoutingSource_SmtpDsNamingContext,  
    iIIsSmtpRoutingSource_SmtpDsAccount,  
    iIIsSmtpRoutingSource_SmtpDsPassword,  
    iIIsSmtpRoutingSource_SmtpDsUseCat,  
    iIIsSmtpRoutingSource_SmtpDsPort,  
    iIIsSmtpRoutingSource_SmtpDsDomain,  
    iIIsSmtpRoutingSource_SmtpDsFlags,  
    cIIsSmtpRoutingSource_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpRoutingSourceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pSmtpRoutingTableType;
         WCHAR *     pSmtpDsDataDirectory;
         WCHAR *     pSmtpDsDefaultMailRoot;
         WCHAR *     pSmtpDsBindType;
         WCHAR *     pSmtpDsSchemaType;
         WCHAR *     pSmtpDsHost;
         WCHAR *     pSmtpDsNamingContext;
         WCHAR *     pSmtpDsAccount;
         WCHAR *     pSmtpDsPassword;
         ULONG *     pSmtpDsUseCat;
         ULONG *     pSmtpDsPort;
         WCHAR *     pSmtpDsDomain;
         ULONG *     pSmtpDsFlags;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpInfo                             L"IIsSmtpInfo"
#define TABLEID_IIsSmtpInfo                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpInfo                          (0L)
#define ExtendedVersion_IIsSmtpInfo                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpInfo {
    iIIsSmtpInfo_Location,  
    iIIsSmtpInfo_KeyType,  
    iIIsSmtpInfo_LogModuleList,  
    iIIsSmtpInfo_MajorIIsVersionNumber,  
    iIIsSmtpInfo_MinorIIsVersionNumber,  
    iIIsSmtpInfo_MD_SERVER_CAPABILITIES,  
    iIIsSmtpInfo_MD_SERVER_PLATFORM,  
    cIIsSmtpInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpInfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
         ULONG *     pMajorIIsVersionNumber;
         ULONG *     pMinorIIsVersionNumber;
         ULONG *     pMD_SERVER_CAPABILITIES;
         ULONG *     pMD_SERVER_PLATFORM;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3Service                          L"IIsPop3Service"
#define TABLEID_IIsPop3Service                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3Service                       (0L)
#define ExtendedVersion_IIsPop3Service                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3Service {
    iIIsPop3Service_Location,  
    iIIsPop3Service_KeyType,  
    iIIsPop3Service_MaxBandwidth,  
    iIIsPop3Service_MaxConnections,  
    iIIsPop3Service_ServerComment,  
    iIIsPop3Service_ConnectionTimeout,  
    iIIsPop3Service_ServerListenTimeout,  
    iIIsPop3Service_MaxEndpointConnections,  
    iIIsPop3Service_ServerAutoStart,  
    iIIsPop3Service_AdminACL,  
    iIIsPop3Service_AdminACLBin,  
    iIIsPop3Service_IPSecurity,  
    iIIsPop3Service_DontLog,  
    iIIsPop3Service_AuthFlags,  
    iIIsPop3Service_ServerListenBacklog,  
    iIIsPop3Service_DefaultLogonDomain,  
    iIIsPop3Service_NTAuthenticationProviders,  
    iIIsPop3Service_AccessFlags,  
    iIIsPop3Service_AccessSSLFlags,  
    iIIsPop3Service_LogType,  
    iIIsPop3Service_LogFilePeriod,  
    iIIsPop3Service_LogPluginClsid,  
    iIIsPop3Service_LogModuleList,  
    iIIsPop3Service_LogFileDirectory,  
    iIIsPop3Service_LogFileTruncateSize,  
    iIIsPop3Service_LogExtFileFlags,  
    iIIsPop3Service_LogOdbcDataSource,  
    iIIsPop3Service_LogOdbcTableName,  
    iIIsPop3Service_LogOdbcUserName,  
    iIIsPop3Service_LogOdbcPassword,  
    iIIsPop3Service_Pop3ServiceVersion,  
    iIIsPop3Service_Pop3ExpireMail,  
    iIIsPop3Service_Pop3ExpireDelay,  
    iIIsPop3Service_Pop3ExpireStart,  
    iIIsPop3Service_Pop3MailExpirationTime,  
    iIIsPop3Service_Pop3ClearTextProvider,  
    iIIsPop3Service_Pop3DefaultDomain,  
    iIIsPop3Service_Pop3RoutingDll,  
    iIIsPop3Service_Pop3RoutingSources,  
    cIIsPop3Service_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3ServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         ULONG *     pServerListenBacklog;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pPop3ServiceVersion;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3ExpireDelay;
         ULONG *     pPop3ExpireStart;
         ULONG *     pPop3MailExpirationTime;
         WCHAR *     pPop3ClearTextProvider;
         WCHAR *     pPop3DefaultDomain;
         WCHAR *     pPop3RoutingDll;
         WCHAR *     pPop3RoutingSources;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3Server                           L"IIsPop3Server"
#define TABLEID_IIsPop3Server                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3Server                        (0L)
#define ExtendedVersion_IIsPop3Server                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3Server {
    iIIsPop3Server_Location,  
    iIIsPop3Server_KeyType,  
    iIIsPop3Server_MaxBandwidth,  
    iIIsPop3Server_MaxConnections,  
    iIIsPop3Server_ServerComment,  
    iIIsPop3Server_ConnectionTimeout,  
    iIIsPop3Server_ServerListenTimeout,  
    iIIsPop3Server_MaxEndpointConnections,  
    iIIsPop3Server_ServerAutoStart,  
    iIIsPop3Server_ServerBindings,  
    iIIsPop3Server_SecureBindings,  
    iIIsPop3Server_AdminACL,  
    iIIsPop3Server_AdminACLBin,  
    iIIsPop3Server_IPSecurity,  
    iIIsPop3Server_DontLog,  
    iIIsPop3Server_AuthFlags,  
    iIIsPop3Server_DefaultLogonDomain,  
    iIIsPop3Server_NTAuthenticationProviders,  
    iIIsPop3Server_AccessFlags,  
    iIIsPop3Server_AccessSSLFlags,  
    iIIsPop3Server_ServerListenBacklog,  
    iIIsPop3Server_Win32Error,  
    iIIsPop3Server_ServerState,  
    iIIsPop3Server_LogType,  
    iIIsPop3Server_LogPluginClsid,  
    iIIsPop3Server_LogFileDirectory,  
    iIIsPop3Server_LogFilePeriod,  
    iIIsPop3Server_LogFileTruncateSize,  
    iIIsPop3Server_LogExtFileFlags,  
    iIIsPop3Server_LogOdbcDataSource,  
    iIIsPop3Server_LogOdbcTableName,  
    iIIsPop3Server_LogOdbcUserName,  
    iIIsPop3Server_LogOdbcPassword,  
    iIIsPop3Server_Pop3ServiceVersion,  
    iIIsPop3Server_Pop3ExpireMail,  
    iIIsPop3Server_Pop3ExpireDelay,  
    iIIsPop3Server_Pop3ExpireStart,  
    iIIsPop3Server_Pop3MailExpirationTime,  
    iIIsPop3Server_Pop3ClearTextProvider,  
    iIIsPop3Server_Pop3DefaultDomain,  
    iIIsPop3Server_Pop3RoutingDll,  
    iIIsPop3Server_Pop3RoutingSources,  
    iIIsPop3Server_SSLCertHash,  
    cIIsPop3Server_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3ServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pServerListenBacklog;
         ULONG *     pWin32Error;
         ULONG *     pServerState;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pPop3ServiceVersion;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3ExpireDelay;
         ULONG *     pPop3ExpireStart;
         ULONG *     pPop3MailExpirationTime;
         WCHAR *     pPop3ClearTextProvider;
         WCHAR *     pPop3DefaultDomain;
         WCHAR *     pPop3RoutingDll;
         WCHAR *     pPop3RoutingSources;
 unsigned char *     pSSLCertHash;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3VirtualDir                       L"IIsPop3VirtualDir"
#define TABLEID_IIsPop3VirtualDir                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3VirtualDir                    (0L)
#define ExtendedVersion_IIsPop3VirtualDir                (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3VirtualDir {
    iIIsPop3VirtualDir_Location,  
    iIIsPop3VirtualDir_KeyType,  
    iIIsPop3VirtualDir_Path,  
    iIIsPop3VirtualDir_UNCUserName,  
    iIIsPop3VirtualDir_UNCPassword,  
    iIIsPop3VirtualDir_Win32Error,  
    iIIsPop3VirtualDir_DontLog,  
    iIIsPop3VirtualDir_AccessFlags,  
    iIIsPop3VirtualDir_AccessSSLFlags,  
    iIIsPop3VirtualDir_Pop3ExpireMail,  
    iIIsPop3VirtualDir_Pop3MailExpirationTime,  
    cIIsPop3VirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3VirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pWin32Error;
         ULONG *     pDontLog;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pPop3ExpireMail;
         ULONG *     pPop3MailExpirationTime;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3RoutingSource                    L"IIsPop3RoutingSource"
#define TABLEID_IIsPop3RoutingSource                     (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3RoutingSource                 (0L)
#define ExtendedVersion_IIsPop3RoutingSource             (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3RoutingSource {
    iIIsPop3RoutingSource_Location,  
    iIIsPop3RoutingSource_KeyType,  
    iIIsPop3RoutingSource_Pop3RoutingTableType,  
    iIIsPop3RoutingSource_Pop3DsDataDirectory,  
    iIIsPop3RoutingSource_Pop3DsDefaultMailRoot,  
    iIIsPop3RoutingSource_Pop3DsBindType,  
    iIIsPop3RoutingSource_Pop3DsSchemaType,  
    iIIsPop3RoutingSource_Pop3DsHost,  
    iIIsPop3RoutingSource_Pop3DsNamingContext,  
    iIIsPop3RoutingSource_Pop3DsAccount,  
    iIIsPop3RoutingSource_Pop3DsPassword,  
    cIIsPop3RoutingSource_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3RoutingSourceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPop3RoutingTableType;
         WCHAR *     pPop3DsDataDirectory;
         WCHAR *     pPop3DsDefaultMailRoot;
         WCHAR *     pPop3DsBindType;
         WCHAR *     pPop3DsSchemaType;
         WCHAR *     pPop3DsHost;
         WCHAR *     pPop3DsNamingContext;
         WCHAR *     pPop3DsAccount;
         WCHAR *     pPop3DsPassword;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3Info                             L"IIsPop3Info"
#define TABLEID_IIsPop3Info                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3Info                          (0L)
#define ExtendedVersion_IIsPop3Info                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3Info {
    iIIsPop3Info_Location,  
    iIIsPop3Info_KeyType,  
    iIIsPop3Info_LogModuleList,  
    cIIsPop3Info_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3InfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapService                          L"IIsImapService"
#define TABLEID_IIsImapService                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapService                       (0L)
#define ExtendedVersion_IIsImapService                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapService {
    iIIsImapService_Location,  
    iIIsImapService_KeyType,  
    iIIsImapService_MaxBandwidth,  
    iIIsImapService_MaxConnections,  
    iIIsImapService_ServerComment,  
    iIIsImapService_ConnectionTimeout,  
    iIIsImapService_ServerListenTimeout,  
    iIIsImapService_MaxEndpointConnections,  
    iIIsImapService_ServerAutoStart,  
    iIIsImapService_AdminACL,  
    iIIsImapService_AdminACLBin,  
    iIIsImapService_IPSecurity,  
    iIIsImapService_DontLog,  
    iIIsImapService_AuthFlags,  
    iIIsImapService_ServerListenBacklog,  
    iIIsImapService_DefaultLogonDomain,  
    iIIsImapService_NTAuthenticationProviders,  
    iIIsImapService_AccessFlags,  
    iIIsImapService_AccessSSLFlags,  
    iIIsImapService_LogType,  
    iIIsImapService_LogFilePeriod,  
    iIIsImapService_LogPluginClsid,  
    iIIsImapService_LogModuleList,  
    iIIsImapService_LogFileDirectory,  
    iIIsImapService_LogFileTruncateSize,  
    iIIsImapService_LogExtFileFlags,  
    iIIsImapService_LogOdbcDataSource,  
    iIIsImapService_LogOdbcTableName,  
    iIIsImapService_LogOdbcUserName,  
    iIIsImapService_LogOdbcPassword,  
    iIIsImapService_ImapServiceVersion,  
    iIIsImapService_ImapExpireMail,  
    iIIsImapService_ImapExpireDelay,  
    iIIsImapService_ImapExpireStart,  
    iIIsImapService_ImapMailExpirationTime,  
    iIIsImapService_ImapClearTextProvider,  
    iIIsImapService_ImapDefaultDomain,  
    iIIsImapService_ImapRoutingDll,  
    iIIsImapService_ImapRoutingSources,  
    cIIsImapService_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapServiceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         ULONG *     pServerListenBacklog;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pLogType;
         ULONG *     pLogFilePeriod;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogModuleList;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pImapServiceVersion;
         ULONG *     pImapExpireMail;
         ULONG *     pImapExpireDelay;
         ULONG *     pImapExpireStart;
         ULONG *     pImapMailExpirationTime;
         WCHAR *     pImapClearTextProvider;
         WCHAR *     pImapDefaultDomain;
         WCHAR *     pImapRoutingDll;
         WCHAR *     pImapRoutingSources;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapServer                           L"IIsImapServer"
#define TABLEID_IIsImapServer                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapServer                        (0L)
#define ExtendedVersion_IIsImapServer                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapServer {
    iIIsImapServer_Location,  
    iIIsImapServer_KeyType,  
    iIIsImapServer_MaxBandwidth,  
    iIIsImapServer_MaxConnections,  
    iIIsImapServer_ServerComment,  
    iIIsImapServer_ConnectionTimeout,  
    iIIsImapServer_ServerListenTimeout,  
    iIIsImapServer_MaxEndpointConnections,  
    iIIsImapServer_ServerAutoStart,  
    iIIsImapServer_ServerBindings,  
    iIIsImapServer_SecureBindings,  
    iIIsImapServer_AdminACL,  
    iIIsImapServer_AdminACLBin,  
    iIIsImapServer_IPSecurity,  
    iIIsImapServer_DontLog,  
    iIIsImapServer_AuthFlags,  
    iIIsImapServer_DefaultLogonDomain,  
    iIIsImapServer_NTAuthenticationProviders,  
    iIIsImapServer_AccessFlags,  
    iIIsImapServer_AccessSSLFlags,  
    iIIsImapServer_LogType,  
    iIIsImapServer_LogPluginClsid,  
    iIIsImapServer_LogFileDirectory,  
    iIIsImapServer_LogFilePeriod,  
    iIIsImapServer_LogFileTruncateSize,  
    iIIsImapServer_LogExtFileFlags,  
    iIIsImapServer_LogOdbcDataSource,  
    iIIsImapServer_LogOdbcTableName,  
    iIIsImapServer_LogOdbcUserName,  
    iIIsImapServer_LogOdbcPassword,  
    iIIsImapServer_ServerListenBacklog,  
    iIIsImapServer_Win32Error,  
    iIIsImapServer_ServerState,  
    iIIsImapServer_ImapServiceVersion,  
    iIIsImapServer_ImapExpireMail,  
    iIIsImapServer_ImapExpireDelay,  
    iIIsImapServer_ImapExpireStart,  
    iIIsImapServer_ImapMailExpirationTime,  
    iIIsImapServer_ImapClearTextProvider,  
    iIIsImapServer_ImapDefaultDomain,  
    iIIsImapServer_ImapRoutingDll,  
    iIIsImapServer_ImapRoutingSources,  
    iIIsImapServer_SSLCertHash,  
    cIIsImapServer_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapServerRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         WCHAR *     pServerComment;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pMaxEndpointConnections;
         ULONG *     pServerAutoStart;
         WCHAR *     pServerBindings;
         WCHAR *     pSecureBindings;
 unsigned char *     pAdminACL;
 unsigned char *     pAdminACLBin;
 unsigned char *     pIPSecurity;
         ULONG *     pDontLog;
         ULONG *     pAuthFlags;
         WCHAR *     pDefaultLogonDomain;
         WCHAR *     pNTAuthenticationProviders;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pLogType;
         WCHAR *     pLogPluginClsid;
         WCHAR *     pLogFileDirectory;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogExtFileFlags;
         WCHAR *     pLogOdbcDataSource;
         WCHAR *     pLogOdbcTableName;
         WCHAR *     pLogOdbcUserName;
         WCHAR *     pLogOdbcPassword;
         ULONG *     pServerListenBacklog;
         ULONG *     pWin32Error;
         ULONG *     pServerState;
         ULONG *     pImapServiceVersion;
         ULONG *     pImapExpireMail;
         ULONG *     pImapExpireDelay;
         ULONG *     pImapExpireStart;
         ULONG *     pImapMailExpirationTime;
         WCHAR *     pImapClearTextProvider;
         WCHAR *     pImapDefaultDomain;
         WCHAR *     pImapRoutingDll;
         WCHAR *     pImapRoutingSources;
 unsigned char *     pSSLCertHash;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapVirtualDir                       L"IIsImapVirtualDir"
#define TABLEID_IIsImapVirtualDir                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapVirtualDir                    (0L)
#define ExtendedVersion_IIsImapVirtualDir                (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapVirtualDir {
    iIIsImapVirtualDir_Location,  
    iIIsImapVirtualDir_KeyType,  
    iIIsImapVirtualDir_Path,  
    iIIsImapVirtualDir_UNCUserName,  
    iIIsImapVirtualDir_UNCPassword,  
    iIIsImapVirtualDir_Win32Error,  
    iIIsImapVirtualDir_DontLog,  
    iIIsImapVirtualDir_AccessFlags,  
    iIIsImapVirtualDir_AccessSSLFlags,  
    iIIsImapVirtualDir_ImapExpireMail,  
    iIIsImapVirtualDir_ImapMailExpirationTime,  
    cIIsImapVirtualDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapVirtualDirRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pPath;
         WCHAR *     pUNCUserName;
         WCHAR *     pUNCPassword;
         ULONG *     pWin32Error;
         ULONG *     pDontLog;
         ULONG *     pAccessFlags;
         ULONG *     pAccessSSLFlags;
         ULONG *     pImapExpireMail;
         ULONG *     pImapMailExpirationTime;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapRoutingSource                    L"IIsImapRoutingSource"
#define TABLEID_IIsImapRoutingSource                     (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapRoutingSource                 (0L)
#define ExtendedVersion_IIsImapRoutingSource             (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapRoutingSource {
    iIIsImapRoutingSource_Location,  
    iIIsImapRoutingSource_KeyType,  
    iIIsImapRoutingSource_ImapRoutingTableType,  
    iIIsImapRoutingSource_ImapDsDataDirectory,  
    iIIsImapRoutingSource_ImapDsDefaultMailRoot,  
    iIIsImapRoutingSource_ImapDsBindType,  
    iIIsImapRoutingSource_ImapDsSchemaType,  
    iIIsImapRoutingSource_ImapDsHost,  
    iIIsImapRoutingSource_ImapDsNamingContext,  
    iIIsImapRoutingSource_ImapDsAccount,  
    iIIsImapRoutingSource_ImapDsPassword,  
    cIIsImapRoutingSource_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapRoutingSourceRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pImapRoutingTableType;
         WCHAR *     pImapDsDataDirectory;
         WCHAR *     pImapDsDefaultMailRoot;
         WCHAR *     pImapDsBindType;
         WCHAR *     pImapDsSchemaType;
         WCHAR *     pImapDsHost;
         WCHAR *     pImapDsNamingContext;
         WCHAR *     pImapDsAccount;
         WCHAR *     pImapDsPassword;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapInfo                             L"IIsImapInfo"
#define TABLEID_IIsImapInfo                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapInfo                          (0L)
#define ExtendedVersion_IIsImapInfo                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapInfo {
    iIIsImapInfo_Location,  
    iIIsImapInfo_KeyType,  
    iIIsImapInfo_LogModuleList,  
    cIIsImapInfo_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapInfoRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pLogModuleList;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpRebuild                          L"IIsNntpRebuild"
#define TABLEID_IIsNntpRebuild                           (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpRebuild                       (0L)
#define ExtendedVersion_IIsNntpRebuild                   (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpRebuild {
    iIIsNntpRebuild_Location,  
    iIIsNntpRebuild_KeyType,  
    cIIsNntpRebuild_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpRebuildRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpSessions                         L"IIsNntpSessions"
#define TABLEID_IIsNntpSessions                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpSessions                      (0L)
#define ExtendedVersion_IIsNntpSessions                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpSessions {
    iIIsNntpSessions_Location,  
    iIIsNntpSessions_KeyType,  
    cIIsNntpSessions_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpSessionsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpFeeds                            L"IIsNntpFeeds"
#define TABLEID_IIsNntpFeeds                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpFeeds                         (0L)
#define ExtendedVersion_IIsNntpFeeds                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpFeeds {
    iIIsNntpFeeds_Location,  
    iIIsNntpFeeds_KeyType,  
    iIIsNntpFeeds_FeedPeerTempDirectory,  
    cIIsNntpFeeds_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpFeedsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pFeedPeerTempDirectory;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpFeed                             L"IIsNntpFeed"
#define TABLEID_IIsNntpFeed                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpFeed                          (0L)
#define ExtendedVersion_IIsNntpFeed                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpFeed {
    iIIsNntpFeed_Location,  
    iIIsNntpFeed_KeyType,  
    iIIsNntpFeed_FeedServerName,  
    iIIsNntpFeed_FeedType,  
    iIIsNntpFeed_FeedNewsgroups,  
    iIIsNntpFeed_FeedSecurityType,  
    iIIsNntpFeed_FeedAuthenticationType,  
    iIIsNntpFeed_FeedAccountName,  
    iIIsNntpFeed_FeedPassword,  
    iIIsNntpFeed_FeedStartTimeHigh,  
    iIIsNntpFeed_FeedStartTimeLow,  
    iIIsNntpFeed_FeedInterval,  
    iIIsNntpFeed_FeedAllowControlMsgs,  
    iIIsNntpFeed_FeedCreateAutomatically,  
    iIIsNntpFeed_FeedDisabled,  
    iIIsNntpFeed_FeedDistribution,  
    iIIsNntpFeed_FeedConcurrentSessions,  
    iIIsNntpFeed_FeedMaxConnectionAttempts,  
    iIIsNntpFeed_FeedUucpName,  
    iIIsNntpFeed_FeedTempDirectory,  
    iIIsNntpFeed_FeedNextPullHigh,  
    iIIsNntpFeed_FeedNextPullLow,  
    iIIsNntpFeed_FeedPeerTempDirectory,  
    iIIsNntpFeed_FeedPeerGapSize,  
    iIIsNntpFeed_FeedOutgoingPort,  
    iIIsNntpFeed_FeedFeedpairId,  
    iIIsNntpFeed_FeedHandshake,  
    iIIsNntpFeed_FeedAdminError,  
    iIIsNntpFeed_FeedErrParmMask,  
    cIIsNntpFeed_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpFeedRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pFeedServerName;
         ULONG *     pFeedType;
         WCHAR *     pFeedNewsgroups;
         ULONG *     pFeedSecurityType;
         ULONG *     pFeedAuthenticationType;
         WCHAR *     pFeedAccountName;
         WCHAR *     pFeedPassword;
         ULONG *     pFeedStartTimeHigh;
         ULONG *     pFeedStartTimeLow;
         ULONG *     pFeedInterval;
         ULONG *     pFeedAllowControlMsgs;
         ULONG *     pFeedCreateAutomatically;
         ULONG *     pFeedDisabled;
         WCHAR *     pFeedDistribution;
         ULONG *     pFeedConcurrentSessions;
         ULONG *     pFeedMaxConnectionAttempts;
         WCHAR *     pFeedUucpName;
         WCHAR *     pFeedTempDirectory;
         ULONG *     pFeedNextPullHigh;
         ULONG *     pFeedNextPullLow;
         WCHAR *     pFeedPeerTempDirectory;
         ULONG *     pFeedPeerGapSize;
         ULONG *     pFeedOutgoingPort;
         ULONG *     pFeedFeedpairId;
         ULONG *     pFeedHandshake;
         ULONG *     pFeedAdminError;
         ULONG *     pFeedErrParmMask;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpExpiration                       L"IIsNntpExpiration"
#define TABLEID_IIsNntpExpiration                        (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpExpiration                    (0L)
#define ExtendedVersion_IIsNntpExpiration                (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpExpiration {
    iIIsNntpExpiration_Location,  
    iIIsNntpExpiration_KeyType,  
    cIIsNntpExpiration_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpExpirationRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpExpire                           L"IIsNntpExpire"
#define TABLEID_IIsNntpExpire                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpExpire                        (0L)
#define ExtendedVersion_IIsNntpExpire                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpExpire {
    iIIsNntpExpire_Location,  
    iIIsNntpExpire_KeyType,  
    iIIsNntpExpire_ExpireSpace,  
    iIIsNntpExpire_ExpireTime,  
    iIIsNntpExpire_ExpireNewsgroups,  
    iIIsNntpExpire_ExpirePolicyName,  
    cIIsNntpExpire_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpExpireRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pExpireSpace;
         ULONG *     pExpireTime;
         WCHAR *     pExpireNewsgroups;
         WCHAR *     pExpirePolicyName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsNntpGroups                           L"IIsNntpGroups"
#define TABLEID_IIsNntpGroups                            (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsNntpGroups                        (0L)
#define ExtendedVersion_IIsNntpGroups                    (0L)

//-----------------Column Index Enums--------------   
enum eIIsNntpGroups {
    iIIsNntpGroups_Location,  
    iIIsNntpGroups_KeyType,  
    cIIsNntpGroups_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsNntpGroupsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpSessions                         L"IIsSmtpSessions"
#define TABLEID_IIsSmtpSessions                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpSessions                      (0L)
#define ExtendedVersion_IIsSmtpSessions                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpSessions {
    iIIsSmtpSessions_Location,  
    iIIsSmtpSessions_KeyType,  
    cIIsSmtpSessions_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpSessionsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsPop3Sessions                         L"IIsPop3Sessions"
#define TABLEID_IIsPop3Sessions                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsPop3Sessions                      (0L)
#define ExtendedVersion_IIsPop3Sessions                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsPop3Sessions {
    iIIsPop3Sessions_Location,  
    iIIsPop3Sessions_KeyType,  
    cIIsPop3Sessions_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsPop3SessionsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsImapSessions                         L"IIsImapSessions"
#define TABLEID_IIsImapSessions                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsImapSessions                      (0L)
#define ExtendedVersion_IIsImapSessions                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsImapSessions {
    iIIsImapSessions_Location,  
    iIIsImapSessions_KeyType,  
    cIIsImapSessions_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsImapSessionsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_FTP_TEMPLATE                        L"IIS_FTP_TEMPLATE"
#define TABLEID_IIS_FTP_TEMPLATE                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_FTP_TEMPLATE                     (0L)
#define ExtendedVersion_IIS_FTP_TEMPLATE                 (0L)

//-----------------Column Index Enums--------------   
enum eIIS_FTP_TEMPLATE {
    iIIS_FTP_TEMPLATE_Location,  
    iIIS_FTP_TEMPLATE_KeyType,  
    iIIS_FTP_TEMPLATE_IPSecurity,  
    iIIS_FTP_TEMPLATE_AnonymousOnly,  
    iIIS_FTP_TEMPLATE_AllowAnonymous,  
    iIIS_FTP_TEMPLATE_ServerComment,  
    cIIS_FTP_TEMPLATE_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_FTP_TEMPLATERow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pIPSecurity;
         ULONG *     pAnonymousOnly;
         ULONG *     pAllowAnonymous;
         WCHAR *     pServerComment;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_FTP_TEMPLATESETTINGS                L"IIS_FTP_TEMPLATESETTINGS"
#define TABLEID_IIS_FTP_TEMPLATESETTINGS                 (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_FTP_TEMPLATESETTINGS             (0L)
#define ExtendedVersion_IIS_FTP_TEMPLATESETTINGS         (0L)

//-----------------Column Index Enums--------------   
enum eIIS_FTP_TEMPLATESETTINGS {
    iIIS_FTP_TEMPLATESETTINGS_Location,  
    iIIS_FTP_TEMPLATESETTINGS_KeyType,  
    iIIS_FTP_TEMPLATESETTINGS_AccessFlags,  
    cIIS_FTP_TEMPLATESETTINGS_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_FTP_TEMPLATESETTINGSRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pAccessFlags;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_WEB_TEMPLATE                        L"IIS_WEB_TEMPLATE"
#define TABLEID_IIS_WEB_TEMPLATE                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_WEB_TEMPLATE                     (0L)
#define ExtendedVersion_IIS_WEB_TEMPLATE                 (0L)

//-----------------Column Index Enums--------------   
enum eIIS_WEB_TEMPLATE {
    iIIS_WEB_TEMPLATE_Location,  
    iIIS_WEB_TEMPLATE_KeyType,  
    iIIS_WEB_TEMPLATE_ServerComment,  
    cIIS_WEB_TEMPLATE_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_WEB_TEMPLATERow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pServerComment;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_WEB_TEMPLATESETTINGS                L"IIS_WEB_TEMPLATESETTINGS"
#define TABLEID_IIS_WEB_TEMPLATESETTINGS                 (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_WEB_TEMPLATESETTINGS             (0L)
#define ExtendedVersion_IIS_WEB_TEMPLATESETTINGS         (0L)

//-----------------Column Index Enums--------------   
enum eIIS_WEB_TEMPLATESETTINGS {
    iIIS_WEB_TEMPLATESETTINGS_Location,  
    iIIS_WEB_TEMPLATESETTINGS_KeyType,  
    iIIS_WEB_TEMPLATESETTINGS_IPSecurity,  
    iIIS_WEB_TEMPLATESETTINGS_AccessFlags,  
    iIIS_WEB_TEMPLATESETTINGS_AuthFlags,  
    cIIS_WEB_TEMPLATESETTINGS_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_WEB_TEMPLATESETTINGSRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pIPSecurity;
         ULONG *     pAccessFlags;
         ULONG *     pAuthFlags;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_ADMIN                               L"IIS_ADMIN"
#define TABLEID_IIS_ADMIN                                (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_ADMIN                            (0L)
#define ExtendedVersion_IIS_ADMIN                        (0L)

//-----------------Column Index Enums--------------   
enum eIIS_ADMIN {
    iIIS_ADMIN_Location,  
    iIIS_ADMIN_KeyType,  
    iIIS_ADMIN_MD_IISADMIN_EXTENSIONS,  
    iIIS_ADMIN_MD_METADATA_ID_REGISTRATION,  
    cIIS_ADMIN_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_ADMINRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pMD_IISADMIN_EXTENSIONS;
         WCHAR *     pMD_METADATA_ID_REGISTRATION;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_EVENTMANAGER                        L"IIS_EVENTMANAGER"
#define TABLEID_IIS_EVENTMANAGER                         (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_EVENTMANAGER                     (0L)
#define ExtendedVersion_IIS_EVENTMANAGER                 (0L)

//-----------------Column Index Enums--------------   
enum eIIS_EVENTMANAGER {
    iIIS_EVENTMANAGER_Location,  
    iIIS_EVENTMANAGER_KeyType,  
    iIIS_EVENTMANAGER_MD_0,  
    cIIS_EVENTMANAGER_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_EVENTMANAGERRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pMD_0;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_ROOT                                L"IIS_ROOT"
#define TABLEID_IIS_ROOT                                 (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_ROOT                             (0L)
#define ExtendedVersion_IIS_ROOT                         (0L)

//-----------------Column Index Enums--------------   
enum eIIS_ROOT {
    iIIS_ROOT_Location,  
    iIIS_ROOT_KeyType,  
    iIIS_ROOT_AdminACL,  
    cIIS_ROOT_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_ROOTRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pAdminACL;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIS_Global                              L"IIS_Global"
#define TABLEID_IIS_Global                               (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIS_Global                           (0L)
#define ExtendedVersion_IIS_Global                       (0L)

//-----------------Column Index Enums--------------   
enum eIIS_Global {
    iIIS_Global_Location,  
    iIIS_Global_KeyType,  
    iIIS_Global_SessionKey,  
    iIIS_Global_ChangeNumber,  
    iIIS_Global_HistoryMajorVersionNumber,  
    iIIS_Global_XMLSchemaTimeStamp,  
    iIIS_Global_BINSchemaTimeStamp,  
    cIIS_Global_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIS_GlobalRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
 unsigned char *     pSessionKey;
         ULONG *     pChangeNumber;
         ULONG *     pHistoryMajorVersionNumber;
 unsigned char *     pXMLSchemaTimeStamp;
 unsigned char *     pBINSchemaTimeStamp;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpAlias                            L"IIsSmtpAlias"
#define TABLEID_IIsSmtpAlias                             (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpAlias                         (0L)
#define ExtendedVersion_IIsSmtpAlias                     (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpAlias {
    iIIsSmtpAlias_Location,  
    iIIsSmtpAlias_KeyType,  
    cIIsSmtpAlias_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpAliasRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpDL                               L"IIsSmtpDL"
#define TABLEID_IIsSmtpDL                                (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpDL                            (0L)
#define ExtendedVersion_IIsSmtpDL                        (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpDL {
    iIIsSmtpDL_Location,  
    iIIsSmtpDL_KeyType,  
    cIIsSmtpDL_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpDLRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsSmtpUser                             L"IIsSmtpUser"
#define TABLEID_IIsSmtpUser                              (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsSmtpUser                          (0L)
#define ExtendedVersion_IIsSmtpUser                      (0L)

//-----------------Column Index Enums--------------   
enum eIIsSmtpUser {
    iIIsSmtpUser_Location,  
    iIIsSmtpUser_KeyType,  
    cIIsSmtpUser_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsSmtpUserRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsStreamFilter                         L"IIsStreamFilter"
#define TABLEID_IIsStreamFilter                          (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsStreamFilter                      (0L)
#define ExtendedVersion_IIsStreamFilter                  (0L)

//-----------------Column Index Enums--------------   
enum eIIsStreamFilter {
    iIIsStreamFilter_Location,  
    iIIsStreamFilter_KeyType,  
    iIIsStreamFilter_PingingEnabled,  
    iIIsStreamFilter_IdleTimeout,  
    iIIsStreamFilter_RapidFailProtection,  
    iIIsStreamFilter_SMPAffinitized,  
    iIIsStreamFilter_SMPProcessorAffinityMask,  
    iIIsStreamFilter_StartupTimeLimit,  
    iIIsStreamFilter_ShutdownTimeLimit,  
    iIIsStreamFilter_PingInterval,  
    iIIsStreamFilter_PingResponseTime,  
    iIIsStreamFilter_DisallowOverlappingRotation,  
    iIIsStreamFilter_DisallowRotationOnConfigChange,  
    iIIsStreamFilter_OrphanWorkerProcess,  
    iIIsStreamFilter_OrphanAction,  
    iIIsStreamFilter_OrphanActionExe,  
    iIIsStreamFilter_OrphanActionParams,  
    cIIsStreamFilter_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsStreamFilterRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pPingingEnabled;
         ULONG *     pIdleTimeout;
         ULONG *     pRapidFailProtection;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         ULONG *     pStartupTimeLimit;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         ULONG *     pOrphanWorkerProcess;
         WCHAR *     pOrphanAction;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsApplicationPool                      L"IIsApplicationPool"
#define TABLEID_IIsApplicationPool                       (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsApplicationPool                   (0L)
#define ExtendedVersion_IIsApplicationPool               (0L)

//-----------------Column Index Enums--------------   
enum eIIsApplicationPool {
    iIIsApplicationPool_Location,  
    iIIsApplicationPool_KeyType,  
    iIIsApplicationPool_AppPoolFriendlyName,  
    iIIsApplicationPool_PeriodicRestartTime,  
    iIIsApplicationPool_PeriodicRestartRequests,  
    iIIsApplicationPool_MaxProcesses,  
    iIIsApplicationPool_PingingEnabled,  
    iIIsApplicationPool_IdleTimeout,  
    iIIsApplicationPool_RapidFailProtection,  
    iIIsApplicationPool_SMPAffinitized,  
    iIIsApplicationPool_SMPProcessorAffinityMask,  
    iIIsApplicationPool_StartupTimeLimit,  
    iIIsApplicationPool_ShutdownTimeLimit,  
    iIIsApplicationPool_PingInterval,  
    iIIsApplicationPool_PingResponseTime,  
    iIIsApplicationPool_DisallowOverlappingRotation,  
    iIIsApplicationPool_DisallowRotationOnConfigChange,  
    iIIsApplicationPool_OrphanWorkerProcess,  
    iIIsApplicationPool_OrphanAction,  
    iIIsApplicationPool_AppPoolQueueLength,  
    iIIsApplicationPool_CPUAction,  
    iIIsApplicationPool_CPULimit,  
    iIIsApplicationPool_CPUResetInterval,  
    iIIsApplicationPool_AppPoolIdentityType,  
    iIIsApplicationPool_WAMUserName,  
    iIIsApplicationPool_WAMUserPass,  
    iIIsApplicationPool_LogonMethod,  
    iIIsApplicationPool_PeriodicRestartMemory,  
    iIIsApplicationPool_DisablePublishing,  
    iIIsApplicationPool_AppPoolCommand,  
    iIIsApplicationPool_AppPoolState,  
    iIIsApplicationPool_AppPoolAutoStart,  
    iIIsApplicationPool_PeriodicRestartSchedule,  
    iIIsApplicationPool_PeriodicRestartConnections,  
    iIIsApplicationPool_RapidFailProtectionInterval,  
    iIIsApplicationPool_RapidFailProtectionMaxCrashes,  
    iIIsApplicationPool_Win32Error,  
    iIIsApplicationPool_OrphanActionExe,  
    iIIsApplicationPool_OrphanActionParams,  
    cIIsApplicationPool_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsApplicationPoolRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         WCHAR *     pAppPoolFriendlyName;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartRequests;
         ULONG *     pMaxProcesses;
         ULONG *     pPingingEnabled;
         ULONG *     pIdleTimeout;
         ULONG *     pRapidFailProtection;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         ULONG *     pStartupTimeLimit;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         ULONG *     pOrphanWorkerProcess;
         WCHAR *     pOrphanAction;
         ULONG *     pAppPoolQueueLength;
         ULONG *     pCPUAction;
         ULONG *     pCPULimit;
         ULONG *     pCPUResetInterval;
         ULONG *     pAppPoolIdentityType;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pLogonMethod;
         ULONG *     pPeriodicRestartMemory;
         ULONG *     pDisablePublishing;
         ULONG *     pAppPoolCommand;
         ULONG *     pAppPoolState;
         ULONG *     pAppPoolAutoStart;
         WCHAR *     pPeriodicRestartSchedule;
         ULONG *     pPeriodicRestartConnections;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         ULONG *     pWin32Error;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_IIsApplicationPools                     L"IIsApplicationPools"
#define TABLEID_IIsApplicationPools                      (0x00000000L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_IIsApplicationPools                  (0L)
#define ExtendedVersion_IIsApplicationPools              (0L)

//-----------------Column Index Enums--------------   
enum eIIsApplicationPools {
    iIIsApplicationPools_Location,  
    iIIsApplicationPools_KeyType,  
    iIIsApplicationPools_PeriodicRestartTime,  
    iIIsApplicationPools_PeriodicRestartRequests,  
    iIIsApplicationPools_MaxProcesses,  
    iIIsApplicationPools_PingingEnabled,  
    iIIsApplicationPools_IdleTimeout,  
    iIIsApplicationPools_RapidFailProtection,  
    iIIsApplicationPools_SMPAffinitized,  
    iIIsApplicationPools_SMPProcessorAffinityMask,  
    iIIsApplicationPools_StartupTimeLimit,  
    iIIsApplicationPools_ShutdownTimeLimit,  
    iIIsApplicationPools_PingInterval,  
    iIIsApplicationPools_PingResponseTime,  
    iIIsApplicationPools_DisallowOverlappingRotation,  
    iIIsApplicationPools_DisallowRotationOnConfigChange,  
    iIIsApplicationPools_OrphanWorkerProcess,  
    iIIsApplicationPools_OrphanAction,  
    iIIsApplicationPools_AppPoolQueueLength,  
    iIIsApplicationPools_CPUAction,  
    iIIsApplicationPools_CPULimit,  
    iIIsApplicationPools_CPUResetInterval,  
    iIIsApplicationPools_AppPoolIdentityType,  
    iIIsApplicationPools_WAMUserName,  
    iIIsApplicationPools_WAMUserPass,  
    iIIsApplicationPools_LogonMethod,  
    iIIsApplicationPools_PeriodicRestartMemory,  
    iIIsApplicationPools_DisablePublishing,  
    iIIsApplicationPools_AppPoolAutoStart,  
    iIIsApplicationPools_PeriodicRestartSchedule,  
    iIIsApplicationPools_PeriodicRestartConnections,  
    iIIsApplicationPools_RapidFailProtectionInterval,  
    iIIsApplicationPools_RapidFailProtectionMaxCrashes,  
    iIIsApplicationPools_Win32Error,  
    iIIsApplicationPools_OrphanActionExe,  
    iIIsApplicationPools_OrphanActionParams,  
    cIIsApplicationPools_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tIIsApplicationPoolsRow {
         WCHAR *     pLocation;
         WCHAR *     pKeyType;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartRequests;
         ULONG *     pMaxProcesses;
         ULONG *     pPingingEnabled;
         ULONG *     pIdleTimeout;
         ULONG *     pRapidFailProtection;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         ULONG *     pStartupTimeLimit;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pDisallowOverlappingRotation;
         ULONG *     pDisallowRotationOnConfigChange;
         ULONG *     pOrphanWorkerProcess;
         WCHAR *     pOrphanAction;
         ULONG *     pAppPoolQueueLength;
         ULONG *     pCPUAction;
         ULONG *     pCPULimit;
         ULONG *     pCPUResetInterval;
         ULONG *     pAppPoolIdentityType;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pLogonMethod;
         ULONG *     pPeriodicRestartMemory;
         ULONG *     pDisablePublishing;
         ULONG *     pAppPoolAutoStart;
         WCHAR *     pPeriodicRestartSchedule;
         ULONG *     pPeriodicRestartConnections;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         ULONG *     pWin32Error;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_MBProperty                              L"MBProperty"
#define TABLEID_MBProperty                               (0xcc73c900L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_MBProperty                           (0L)
#define ExtendedVersion_MBProperty                       (0L)

//-----------------Column Index Enums--------------   
enum eMBProperty {
    iMBProperty_Name,  
    iMBProperty_Type,  
    iMBProperty_Attributes,  
    iMBProperty_Value,  
    iMBProperty_Location,  
    iMBProperty_ID,  
    iMBProperty_UserType,  
    iMBProperty_LocationID,  
    iMBProperty_Group,  
    cMBProperty_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tMBPropertyRow {
         WCHAR *     pName;
         ULONG *     pType;
         ULONG *     pAttributes;
 unsigned char *     pValue;
         WCHAR *     pLocation;
         ULONG *     pID;
         ULONG *     pUserType;
         ULONG *     pLocationID;
         ULONG *     pGroup;
};

enum eMBProperty_Type {
    eMBProperty_DWORD             	=	       1,	//(0x00000001)
    eMBProperty_STRING            	=	       2,	//(0x00000002)
    eMBProperty_BINARY            	=	       3,	//(0x00000003)
    eMBProperty_EXPANDSZ          	=	       4,	//(0x00000004)
    eMBProperty_MULTISZ           	=	       5	//(0x00000005)
};

enum eMBProperty_Attributes {
    fMBProperty_NO_ATTRIBUTES     	=	0x00000000,	//(0 decimal)
    fMBProperty_INHERIT           	=	0x00000001,	//(1 decimal)
    fMBProperty_PARTIAL_PATH      	=	0x00000002,	//(2 decimal)
    fMBProperty_SECURE            	=	0x00000004,	//(4 decimal)
    fMBProperty_REFERENCE         	=	0x00000008,	//(8 decimal)
    fMBProperty_VOLATILE          	=	0x00000010,	//(16 decimal)
    fMBProperty_ISINHERITED       	=	0x00000020,	//(32 decimal)
    fMBProperty_INSERT_PATH       	=	0x00000040,	//(64 decimal)
    fMBProperty_LOCAL_MACHINE_ONLY	=	0x00000080,	//(128 decimal)
    fMBProperty_Attributes_Mask	= 0x000000ff
};

enum eMBProperty_UserType {
    eMBProperty_UNKNOWN_UserType  	=	       0,	//(0x00000000)
    eMBProperty_IIS_MD_UT_SERVER  	=	       1,	//(0x00000001)
    eMBProperty_IIS_MD_UT_FILE    	=	       2,	//(0x00000002)
    eMBProperty_IIS_MD_UT_WAM     	=	     100,	//(0x00000064)
    eMBProperty_ASP_MD_UT_APP     	=	     101	//(0x00000065)
};

enum eMBProperty_Group {
    eMBProperty_IIsConfigObject   	=	       0,	//(0x00000000)
    eMBProperty_IIsObject         	=	       1,	//(0x00000001)
    eMBProperty_IIsComputer       	=	       2,	//(0x00000002)
    eMBProperty_IIsWebService     	=	       3,	//(0x00000003)
    eMBProperty_IIsFtpService     	=	       4,	//(0x00000004)
    eMBProperty_IIsWebServer      	=	       5,	//(0x00000005)
    eMBProperty_IIsFtpServer      	=	       6,	//(0x00000006)
    eMBProperty_IIsWebFile        	=	       7,	//(0x00000007)
    eMBProperty_IIsWebDirectory   	=	       8,	//(0x00000008)
    eMBProperty_IIsWebVirtualDir  	=	       9,	//(0x00000009)
    eMBProperty_IIsFtpVirtualDir  	=	      10,	//(0x0000000a)
    eMBProperty_IIsFilter         	=	      11,	//(0x0000000b)
    eMBProperty_IIsFilters        	=	      12,	//(0x0000000c)
    eMBProperty_IIsCompressionScheme	=	      13,	//(0x0000000d)
    eMBProperty_IIsCompressionSchemes	=	      14,	//(0x0000000e)
    eMBProperty_IIsCertMapper     	=	      15,	//(0x0000000f)
    eMBProperty_IIsMimeMap        	=	      16,	//(0x00000010)
    eMBProperty_IIsLogModule      	=	      17,	//(0x00000011)
    eMBProperty_IIsLogModules     	=	      18,	//(0x00000012)
    eMBProperty_IIsCustomLogModule	=	      19,	//(0x00000013)
    eMBProperty_IIsWebInfo        	=	      20,	//(0x00000014)
    eMBProperty_IIsFtpInfo        	=	      21,	//(0x00000015)
    eMBProperty_IIsNntpService    	=	      22,	//(0x00000016)
    eMBProperty_IIsNntpServer     	=	      23,	//(0x00000017)
    eMBProperty_IIsNntpVirtualDir 	=	      24,	//(0x00000018)
    eMBProperty_IIsNntpInfo       	=	      25,	//(0x00000019)
    eMBProperty_IIsSmtpService    	=	      26,	//(0x0000001a)
    eMBProperty_IIsSmtpServer     	=	      27,	//(0x0000001b)
    eMBProperty_IIsSmtpVirtualDir 	=	      28,	//(0x0000001c)
    eMBProperty_IIsSmtpDomain     	=	      29,	//(0x0000001d)
    eMBProperty_IIsSmtpRoutingSource	=	      30,	//(0x0000001e)
    eMBProperty_IIsSmtpInfo       	=	      31,	//(0x0000001f)
    eMBProperty_IIsPop3Service    	=	      32,	//(0x00000020)
    eMBProperty_IIsPop3Server     	=	      33,	//(0x00000021)
    eMBProperty_IIsPop3VirtualDir 	=	      34,	//(0x00000022)
    eMBProperty_IIsPop3RoutingSource	=	      35,	//(0x00000023)
    eMBProperty_IIsPop3Info       	=	      36,	//(0x00000024)
    eMBProperty_IIsImapService    	=	      37,	//(0x00000025)
    eMBProperty_IIsImapServer     	=	      38,	//(0x00000026)
    eMBProperty_IIsImapVirtualDir 	=	      39,	//(0x00000027)
    eMBProperty_IIsImapRoutingSource	=	      40,	//(0x00000028)
    eMBProperty_IIsImapInfo       	=	      41,	//(0x00000029)
    eMBProperty_IIsNntpRebuild    	=	      42,	//(0x0000002a)
    eMBProperty_IIsNntpSessions   	=	      43,	//(0x0000002b)
    eMBProperty_IIsNntpFeeds      	=	      44,	//(0x0000002c)
    eMBProperty_IIsNntpFeed       	=	      45,	//(0x0000002d)
    eMBProperty_IIsNntpExpire     	=	      46,	//(0x0000002e)
    eMBProperty_IIsNntpExpiration 	=	      47,	//(0x0000002f)
    eMBProperty_IIsNntpGroups     	=	      48,	//(0x00000030)
    eMBProperty_IIsSmtpSessions   	=	      49,	//(0x00000031)
    eMBProperty_IIsPop3Sessions   	=	      50,	//(0x00000032)
    eMBProperty_IIsImapSessions   	=	      51,	//(0x00000033)
    eMBProperty_IIS_Global        	=	      52,	//(0x00000034)
    eMBProperty_IIS_ROOT          	=	      53,	//(0x00000035)
    eMBProperty_IIS_FTP_TEMPLATE  	=	      54,	//(0x00000036)
    eMBProperty_IIS_FTP_TEMPLATESETTINGS	=	      55,	//(0x00000037)
    eMBProperty_IIS_WEB_TEMPLATE  	=	      56,	//(0x00000038)
    eMBProperty_IIS_WEB_TEMPLATESETTINGS	=	      57,	//(0x00000039)
    eMBProperty_IIS_ADMIN         	=	      58,	//(0x0000003a)
    eMBProperty_IIS_EVENTMANAGER  	=	      59,	//(0x0000003b)
    eMBProperty_IIsSmtpAlias      	=	      60,	//(0x0000003c)
    eMBProperty_IIsSmtpDL         	=	      61,	//(0x0000003d)
    eMBProperty_IIsSmtpUser       	=	      62,	//(0x0000003e)
    eMBProperty_IIsStreamFilter   	=	      63,	//(0x0000003f)
    eMBProperty_IIsApplicationPool	=	      64,	//(0x00000040)
    eMBProperty_IIsApplicationPools	=	      65,	//(0x00000041)
    eMBProperty_IIsInheritedProperties	=	      66,	//(0x00000042)
    eMBProperty_Custom            	=	      67	//(0x00000043)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_MBPropertyDiff                          L"MBPropertyDiff"
#define TABLEID_MBPropertyDiff                           (0x95d76f00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_MBPropertyDiff                       (0L)
#define ExtendedVersion_MBPropertyDiff                   (0L)

//-----------------Column Index Enums--------------   
enum eMBPropertyDiff {
    iMBPropertyDiff_Name,  
    iMBPropertyDiff_Type,  
    iMBPropertyDiff_Attributes,  
    iMBPropertyDiff_Value,  
    iMBPropertyDiff_Location,  
    iMBPropertyDiff_ID,  
    iMBPropertyDiff_UserType,  
    iMBPropertyDiff_LocationID,  
    iMBPropertyDiff_Directive,  
    iMBPropertyDiff_Group,  
    cMBPropertyDiff_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tMBPropertyDiffRow {
         WCHAR *     pName;
         ULONG *     pType;
         ULONG *     pAttributes;
 unsigned char *     pValue;
         WCHAR *     pLocation;
         ULONG *     pID;
         ULONG *     pUserType;
         ULONG *     pLocationID;
         ULONG *     pDirective;
         ULONG *     pGroup;
};

enum eMBPropertyDiff_Directive {
    eMBPropertyDiff_Insert        	=	       1,	//(0x00000001)
    eMBPropertyDiff_Update        	=	       2,	//(0x00000002)
    eMBPropertyDiff_Delete        	=	       3,	//(0x00000003)
    eMBPropertyDiff_DeleteNode    	=	       4	//(0x00000004)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_APPPOOLS                                L"APPPOOLS"
#define TABLEID_APPPOOLS                                 (0x1eecf300L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_APPPOOLS                             (0L)
#define ExtendedVersion_APPPOOLS                         (0L)

//-----------------Column Index Enums--------------   
enum eAPPPOOLS {
    iAPPPOOLS_AppPoolID,  
    iAPPPOOLS_PeriodicRestartTime,  
    iAPPPOOLS_PeriodicRestartRequests,  
    iAPPPOOLS_MaxProcesses,  
    iAPPPOOLS_PingingEnabled,  
    iAPPPOOLS_IdleTimeout,  
    iAPPPOOLS_RapidFailProtection,  
    iAPPPOOLS_SMPAffinitized,  
    iAPPPOOLS_SMPProcessorAffinityMask,  
    iAPPPOOLS_OrphanWorkerProcess,  
    iAPPPOOLS_RunAsLocalSystem,  
    iAPPPOOLS_StartupTimeLimit,  
    iAPPPOOLS_ShutdownTimeLimit,  
    iAPPPOOLS_PingInterval,  
    iAPPPOOLS_PingResponseTime,  
    iAPPPOOLS_DisallowOverlappingRotation,  
    iAPPPOOLS_OrphanAction,  
    iAPPPOOLS_AppPoolQueueLength,  
    iAPPPOOLS_DisallowRotationOnConfigChange,  
    iAPPPOOLS_AppPoolFriendlyName,  
    iAPPPOOLS_PeriodicRestartSchedule,  
    iAPPPOOLS_WAMUserName,  
    iAPPPOOLS_WAMUserPass,  
    iAPPPOOLS_AppPoolIdentityType,  
    iAPPPOOLS_LogonMethod,  
    iAPPPOOLS_CPUAction,  
    iAPPPOOLS_CPULimit,  
    iAPPPOOLS_CPUResetInterval,  
    iAPPPOOLS_PeriodicRestartMemory,  
    iAPPPOOLS_AppPoolCommand,  
    iAPPPOOLS_AppPoolState,  
    iAPPPOOLS_AppPoolAutoStart,  
    iAPPPOOLS_RapidFailProtectionInterval,  
    iAPPPOOLS_RapidFailProtectionMaxCrashes,  
    iAPPPOOLS_Win32Error,  
    iAPPPOOLS_OrphanActionExe,  
    iAPPPOOLS_OrphanActionParams,  
    cAPPPOOLS_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tAPPPOOLSRow {
         WCHAR *     pAppPoolID;
         ULONG *     pPeriodicRestartTime;
         ULONG *     pPeriodicRestartRequests;
         ULONG *     pMaxProcesses;
         ULONG *     pPingingEnabled;
         ULONG *     pIdleTimeout;
         ULONG *     pRapidFailProtection;
         ULONG *     pSMPAffinitized;
         ULONG *     pSMPProcessorAffinityMask;
         ULONG *     pOrphanWorkerProcess;
         ULONG *     pRunAsLocalSystem;
         ULONG *     pStartupTimeLimit;
         ULONG *     pShutdownTimeLimit;
         ULONG *     pPingInterval;
         ULONG *     pPingResponseTime;
         ULONG *     pDisallowOverlappingRotation;
         WCHAR *     pOrphanAction;
         ULONG *     pAppPoolQueueLength;
         ULONG *     pDisallowRotationOnConfigChange;
         WCHAR *     pAppPoolFriendlyName;
         WCHAR *     pPeriodicRestartSchedule;
         WCHAR *     pWAMUserName;
         WCHAR *     pWAMUserPass;
         ULONG *     pAppPoolIdentityType;
         ULONG *     pLogonMethod;
         ULONG *     pCPUAction;
         ULONG *     pCPULimit;
         ULONG *     pCPUResetInterval;
         ULONG *     pPeriodicRestartMemory;
         ULONG *     pAppPoolCommand;
         ULONG *     pAppPoolState;
         ULONG *     pAppPoolAutoStart;
         ULONG *     pRapidFailProtectionInterval;
         ULONG *     pRapidFailProtectionMaxCrashes;
         ULONG *     pWin32Error;
         WCHAR *     pOrphanActionExe;
         WCHAR *     pOrphanActionParams;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_SITES                                   L"SITES"
#define TABLEID_SITES                                    (0x006fe700L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_SITES                                (0L)
#define ExtendedVersion_SITES                            (0L)

//-----------------Column Index Enums--------------   
enum eSITES {
    iSITES_SiteID,  
    iSITES_Bindings,  
    iSITES_ServerCommand,  
    iSITES_ServerComment,  
    iSITES_MaxBandwidth,  
    iSITES_MaxConnections,  
    iSITES_ServerAutoStart,  
    iSITES_ConnectionTimeout,  
    iSITES_ServerListenTimeout,  
    iSITES_LogType,  
    iSITES_LogFileDirectory,  
    iSITES_LogPluginClsid,  
    iSITES_LogFilePeriod,  
    iSITES_LogFileTruncateSize,  
    iSITES_LogFileLocaltimeRollover,  
    iSITES_LogExtFileFlags,  
    iSITES_ServerState,  
    iSITES_Win32Error,  
    iSITES_FilterFlags,  
    cSITES_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tSITESRow {
         ULONG *     pSiteID;
 unsigned char *     pBindings;
         ULONG *     pServerCommand;
         WCHAR *     pServerComment;
         ULONG *     pMaxBandwidth;
         ULONG *     pMaxConnections;
         ULONG *     pServerAutoStart;
         ULONG *     pConnectionTimeout;
         ULONG *     pServerListenTimeout;
         ULONG *     pLogType;
         WCHAR *     pLogFileDirectory;
         WCHAR *     pLogPluginClsid;
         ULONG *     pLogFilePeriod;
         ULONG *     pLogFileTruncateSize;
         ULONG *     pLogFileLocaltimeRollover;
         ULONG *     pLogExtFileFlags;
         ULONG *     pServerState;
         ULONG *     pWin32Error;
         ULONG *     pFilterFlags;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_APPS                                    L"APPS"
#define TABLEID_APPS                                     (0x001ef300L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_APPS                                 (0L)
#define ExtendedVersion_APPS                             (0L)

//-----------------Column Index Enums--------------   
enum eAPPS {
    iAPPS_AppRelativeURL,  
    iAPPS_SiteID,  
    iAPPS_AppPoolId,  
    iAPPS_AppFriendlyName,  
    cAPPS_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tAPPSRow {
         WCHAR *     pAppRelativeURL;
         ULONG *     pSiteID;
         WCHAR *     pAppPoolId;
         WCHAR *     pAppFriendlyName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_GlobalW3SVC                             L"GlobalW3SVC"
#define TABLEID_GlobalW3SVC                              (0xb3dd4b00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_GlobalW3SVC                          (0L)
#define ExtendedVersion_GlobalW3SVC                      (0L)

//-----------------Column Index Enums--------------   
enum eGlobalW3SVC {
    iGlobalW3SVC_MaxGlobalBandwidth,  
    iGlobalW3SVC_MaxGlobalConnections,  
    iGlobalW3SVC_StandardAppModeEnabled,  
    iGlobalW3SVC_FilterFlags,  
    iGlobalW3SVC_ConnectionTimeout,  
    iGlobalW3SVC_HeaderWaitTimeout,  
    iGlobalW3SVC_MinFileKbSec,  
    iGlobalW3SVC_LogInUTF8,  
    cGlobalW3SVC_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tGlobalW3SVCRow {
         ULONG *     pMaxGlobalBandwidth;
         ULONG *     pMaxGlobalConnections;
         ULONG *     pStandardAppModeEnabled;
         ULONG *     pFilterFlags;
         ULONG *     pConnectionTimeout;
         ULONG *     pHeaderWaitTimeout;
         ULONG *     pMinFileKbSec;
         ULONG *     pLogInUTF8;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_CHANGENUMBER                            L"CHANGENUMBER"
#define TABLEID_CHANGENUMBER                             (0xbbc18600L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_CHANGENUMBER                         (0L)
#define ExtendedVersion_CHANGENUMBER                     (0L)

//-----------------Column Index Enums--------------   
enum eCHANGENUMBER {
    iCHANGENUMBER_ChangeNumber,  
    iCHANGENUMBER_TimeStamp,  
    cCHANGENUMBER_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tCHANGENUMBERRow {
         ULONG *     pChangeNumber;
 unsigned char *     pTimeStamp;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_SESSIONKEY                              L"SESSIONKEY"
#define TABLEID_SESSIONKEY                               (0xb3a7dd00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_SESSIONKEY                           (0L)
#define ExtendedVersion_SESSIONKEY                       (0L)

//-----------------Column Index Enums--------------   
enum eSESSIONKEY {
    iSESSIONKEY_SessionKey,  
    cSESSIONKEY_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tSESSIONKEYRow {
 unsigned char *     pSessionKey;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_Dirs                                    L"Dirs"
#define TABLEID_Dirs                                     (0x001e2b00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_Dirs                                 (0L)
#define ExtendedVersion_Dirs                             (0L)

//-----------------Column Index Enums--------------   
enum eDirs {
    iDirs_URL,  
    iDirs_Dir,  
    cDirs_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tDirsRow {
         WCHAR *     pURL;
         WCHAR *     pDir;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_VDir                                    L"VDir"
#define TABLEID_VDir                                     (0x001a1600L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_VDir                                 (0L)
#define ExtendedVersion_VDir                             (0L)

//-----------------Column Index Enums--------------   
enum eVDir {
    iVDir_ParentURL,  
    iVDir_ChildRelURL,  
    iVDir_VDir,  
    cVDir_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tVDirRow {
         WCHAR *     pParentURL;
         WCHAR *     pChildRelURL;
         WCHAR *     pVDir;
};


#endif //__TABLEINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\wam\wamccf.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
       wamccf.cxx

   Abstract:
       This module implements the WAM Custom Class Factory
       which creates WAM objects regardless of passed class id

   Author:
       Dmitry Robsman   ( dmitryr )     07-Apr-1997

   Environment:
       User Mode - Win32

   Project:
       Wam DLL

--*/

/************************************************************
 *     Include Headers
 ************************************************************/
//#include <isapip.hxx>
//#include "setable.hxx"
#include <precomp.hxx>
#include "wamobj.hxx"
#include "wamccf.hxx"

/************************************************************
 *     W A M  C C F   
 ************************************************************/

WAM_CCF::WAM_CCF()
/*++

Routine Description:
    WAM_CCF Constructor

Arguments:

Return Value:

--*/
    : 
    m_cRef(0),
    m_pcfAtl(NULL)
    {

    // Query ATL's class factory for WAM

    _Module.GetClassObject
        (
        CLSID_Wam,
        IID_IClassFactory,
        (void **)(&m_pcfAtl)
        );
    }

/*----------------------------------------------------------*/
    
WAM_CCF::~WAM_CCF()
/*++

Routine Description:
    WAM_CCF Destructor

Arguments:

Return Value:

--*/
    {
    if (m_pcfAtl)
        m_pcfAtl->Release();
    }

/*----------------------------------------------------------*/

STDMETHODIMP 
WAM_CCF::QueryInterface
(
REFIID riid,
LPVOID *ppv
)
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::QueryInterface

Arguments:
    REFIID riid     interface id
    LPVOID *ppv     [out]

Return Value:
    HRESULT

--*/
    {
    if (!ppv)
        return E_POINTER;

    if (!m_pcfAtl)  // must have original CF to create WAMs
        return E_NOINTERFACE;
        
    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
        *ppv = this;

    if (*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
    }

/*----------------------------------------------------------*/
    
STDMETHODIMP_(ULONG) 
WAM_CCF::AddRef()
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::AddRef

Arguments:

Return Value:
    ref count

--*/
    {
    return (ULONG)InterlockedIncrement((LPLONG)(&m_cRef));
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP_(ULONG) 
WAM_CCF::Release()
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::Release

Arguments:

Return Value:
    ref count

--*/
    {
    ULONG cRef = (ULONG)InterlockedDecrement((LPLONG)(&m_cRef));
    if (cRef > 0)
        return cRef;

    delete this;
    return 0;
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP
WAM_CCF::CreateInstance
(
LPUNKNOWN pUnkOuter,
REFIID    riid, 
LPVOID    *ppvObj
)
/*++

Routine Description:
    WAM_CCF implementation of IClassFactory::CreateInstance
    Delegate to default ATL CF

Arguments:
    LPUNKNOWN pUnkOuter     outer object
    REFIID    riid          interface id to query
    LPVOID   *ppvObj        [out]

Return Value:
    HRESULT

--*/
    {
    if (!m_pcfAtl)
        return E_UNEXPECTED;

    return m_pcfAtl->CreateInstance(pUnkOuter, riid, ppvObj);
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP
WAM_CCF::LockServer
(
BOOL fLock
)
/*++

Routine Description:
    WAM_CCF implementation of IClassFactory::LockServer
    Delegate to default ATL CF

Arguments:
    BOOL fLock      flag (lock/unlock)

Return Value:
    HRESULT

--*/
    {
    if (!m_pcfAtl)
        return E_UNEXPECTED;
        
    m_pcfAtl->LockServer(fLock);
	return NOERROR;
    }


/************************************************************
 *     W A M  C C F  M O D U L E
 ************************************************************/

WAM_CCF_MODULE::WAM_CCF_MODULE()
/*++

Routine Description:
    WAM_CCF_MODULE Constructor

Arguments:

Return Value:

--*/
    : 
    m_pCF(NULL)
    {
    }

/*----------------------------------------------------------*/

WAM_CCF_MODULE::~WAM_CCF_MODULE()
/*++

Routine Description:
    WAM_CCF_MODULE Destructor

Arguments:

Return Value:

--*/
    {
    }
    
/*----------------------------------------------------------*/

HRESULT 
WAM_CCF_MODULE::Init()
/*++

Routine Description:
    Initialize WAM_CCF_MODULE. Create Custom Class Factory.

Arguments:

Return Value:
    HRESULT

--*/
    {
    m_pCF = new WAM_CCF;
    if (!m_pCF)
        return E_OUTOFMEMORY;
        
    m_pCF->AddRef(); // keep AddRef()'d
    return NOERROR;
    }

/*----------------------------------------------------------*/
        
HRESULT 
WAM_CCF_MODULE::Term()
/*++

Routine Description:
    UnInitialize WAM_CCF_MODULE. Remove Custom Class Factory.

Arguments:

Return Value:
    HRESULT

--*/
    {
    if (m_pCF)
        {
        m_pCF->Release();
        m_pCF = NULL;
        }

    return NOERROR;
    }

/*----------------------------------------------------------*/

HRESULT 
WAM_CCF_MODULE::GetClassObject
(
REFCLSID rclsid,
REFIID riid,
LPVOID *ppv
)
/*++

Routine Description:
    Gives out to the called an addref'd Custom Class Library

Arguments:
    REFCLSID rclsid     Class Id (ignored)
    REFIID   riid       QI CCF for this
    LPVOID  *ppv        [out] returned CCF pointer

Return Value:
    HRESULT

--*/
    {
    if (!m_pCF)
        return CLASS_E_CLASSNOTAVAILABLE;

    // CONSIDER: verify rclsid somehow
    
    return m_pCF->QueryInterface(riid, ppv);
    }

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\import\inc\svcmsg.h ===
/*
 COM+ 1.0
 Copyright (c) 1996 Microsoft Corporation

 This file contains the message definitions for MS Transaction Server
-------------------------------------------------------------------------
 HEADER SECTION

 The header section defines names and language identifiers for use
 by the message definitions later in this file. The MessageIdTypedef,
 SeverityNames, FacilityNames, and LanguageNames keywords are
 optional and not required.



 The MessageIdTypedef keyword gives a typedef name that is used in a
 type cast for each message code in the generated include file. Each
 message code appears in the include file with the format: #define
 name ((type) 0xnnnnnnnn) The default value for type is empty, and no
 type cast is generated. It is the programmer's responsibility to
 specify a typedef statement in the application source code to define
 the type. The type used in the typedef must be large enough to
 accommodate the entire 32-bit message code.



 The SeverityNames keyword defines the set of names that are allowed
 as the value of the Severity keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 severity name is a number that, when shifted left by 30, gives the
 bit pattern to logical-OR with the Facility value and MessageId
 value to form the full 32-bit message code. The default value of
 this keyword is:

 SeverityNames=(
   Success=0x0
   Informational=0x1
   Warning=0x2
   Error=0x3
   )

 Severity values occupy the high two bits of a 32-bit message code.
 Any severity value that does not fit in two bits is an error. The
 severity codes can be given symbolic names by following each value
 with :name

 The FacilityNames keyword defines the set of names that are allowed
 as the value of the Facility keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 facility name is a number that, when shifted left by 16 bits, gives
 the bit pattern to logical-OR with the Severity value and MessageId
 value to form the full 32-bit message code. The default value of
 this keyword is:

 FacilityNames=(
   System=0x0FF
   Application=0xFFF
  )

 Facility codes occupy the low order 12 bits of the high order
 16-bits of a 32-bit message code. Any facility code that does not
 fit in 12 bits is an error. This allows for 4,096 facility codes.
 The first 256 codes are reserved for use by the system software. The
 facility codes can be given symbolic names by following each value
 with :name

 The 1033 comes from the result of the MAKELANGID() macro
 (SUBLANG_ENGLISH_US << 10) | (LANG_ENGLISH)

 The LanguageNames keyword defines the set of names that are allowed
 as the value of the Language keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 language name is a number and a file name that are used to name the
 generated resource file that contains the messages for that
 language. The number corresponds to the language identifier to use
 in the resource table. The number is separated from the file name
 with a colon. The initial value of LanguageNames is:

 LanguageNames=(English=1:MSG00001)

 Any new names in the source file that don't override the built-in
 names are added to the list of valid languages. This allows an
 application to support private languages with descriptive names.


-------------------------------------------------------------------------
 MESSAGE DEFINITION SECTION

 Following the header section is the body of the Message Compiler
 source file. The body consists of zero or more message definitions.
 Each message definition begins with one or more of the following
 statements:

 MessageId = [number|+number]
 Severity = severity_name
 Facility = facility_name
 SymbolicName = name

 The MessageId statement marks the beginning of the message
 definition. A MessageID statement is required for each message,
 although the value is optional. If no value is specified, the value
 used is the previous value for the facility plus one. If the value
 is specified as +number, then the value used is the previous value
 for the facility plus the number after the plus sign. Otherwise, if
 a numeric value is given, that value is used. Any MessageId value
 that does not fit in 16 bits is an error.

 The Severity and Facility statements are optional. These statements
 specify additional bits to OR into the final 32-bit message code. If
 not specified, they default to the value last specified for a message
 definition. The initial values prior to processing the first message
 definition are:

 Severity=Success
 Facility=Application

 The value associated with Severity and Facility must match one of
 the names given in the FacilityNames and SeverityNames statements in
 the header section. The SymbolicName statement allows you to
 associate a C/C++ symbolic constant with the final 32-bit message
 code.

*/
/* IMPORTANT - PLEASE READ BEFORE EDITING FILE
  This file is divided into four sections. They are:
	1. Success Codes
	2. Information Codes
	3. Warning Codes
	4. Error Codes

  Please enter your codes in the appropriate section.
  All codes must be in sorted order.  Please use codes
  in the middle that are free before using codes at the end.
  The success codes (Categories) must be consecutive i.e. with no gaps.
  The category names cannot be longer than 22 chars.
*/
/******************************* Success Codes ***************************************/
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_STUBS                   0x3
#define FACILITY_RUNTIME                 0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ID_CAT_UNKNOWN
//
// MessageText:
//
//  SVC%0
//
#define ID_CAT_UNKNOWN                   ((DWORD)0x00000001L)

//
// MessageId: ID_CAT_CAT
//
// MessageText:
//
//  Catalog%0
//
#define ID_CAT_CAT                       ((DWORD)0x00000002L)

//
// MessageId: ID_CAT_CONFIG_SCHEMA_COMPILE
//
// MessageText:
//
//  Config Schema Compile%0
//
#define ID_CAT_CONFIG_SCHEMA_COMPILE     ((DWORD)0x00000003L)

 /*
 ID_CAT_COM_LAST defines a constant specifying how many categories
 there are in the COM+ event logging client
 ID_CAT_COM_LAST must remain the last category.  To add new categories
 simply add the category above.  Give it the message id of the
 last category (ID_CAT_COM_LAST) and increment the id of ID_CAT_COM_LAST
 Note: ID_CAT_COM_LAST must always be one greater than the last 
 category to be output
 */
//
// MessageId: ID_CAT_COM_LAST
//
// MessageText:
//
//  <>%0
//
#define ID_CAT_COM_LAST                  ((DWORD)0x00000004L)

//
// MessageId: ID_E_SDTXML_NOTSUPPORTED
//
// MessageText:
//
//  The specified XML is not supported. %1%2%3%4%5%0
//
#define ID_E_SDTXML_NOTSUPPORTED         ((DWORD)0xC0000511L)

//
// MessageId: ID_E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER
//
// MessageText:
//
//  The XML Parser returned an unspecified error. %1%2%3%4%5%0
//
#define ID_E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER ((DWORD)0xC0000512L)

//
// MessageId: ID_E_SDTXML_XML_FAILED_TO_PARSE
//
// MessageText:
//
//  The XML failed to parse. %1%2%3%4%5%0
//
#define ID_E_SDTXML_XML_FAILED_TO_PARSE  ((DWORD)0xC0000514L)

//
// MessageId: ID_E_SDTXML_WRONG_XMLSCHEMA
//
// MessageText:
//
//  The specified XML Schema is wrong. %1%2%3%4%5%0
//
#define ID_E_SDTXML_WRONG_XMLSCHEMA      ((DWORD)0xC0000515L)

//
// MessageId: ID_E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST
//
// MessageText:
//
//  The parent XML element does not exist. This means that you are trying to insert an XML element while the parent XML element is not there yet. %1%2%3%4%5%0
//
#define ID_E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST ((DWORD)0xC0000516L)

//
// MessageId: ID_E_SDTXML_DONE
//
// MessageText:
//
//  Internal XML Parsing error. %1%2%3%4%5%0
//
#define ID_E_SDTXML_DONE                 ((DWORD)0xC0000517L)

//
// MessageId: ID_E_SDTXML_UNEXPECTED
//
// MessageText:
//
//  Internal XML Parsing error. %1%2%3%4%5%0
//
#define ID_E_SDTXML_UNEXPECTED           ((DWORD)0xC0000520L)

//
// MessageId: ID_E_SDTXML_FILE_NOT_SPECIFIED
//
// MessageText:
//
//  The XML file was not specified. %1%2%3%4%5%0
//
#define ID_E_SDTXML_FILE_NOT_SPECIFIED   ((DWORD)0xC0000522L)

//
// MessageId: ID_E_SDTXML_LOGICAL_ERROR_IN_XML
//
// MessageText:
//
//  A Logical error was found in the XML file. %1%2%3%4%5%0
//
#define ID_E_SDTXML_LOGICAL_ERROR_IN_XML ((DWORD)0xC0000523L)

//
// MessageId: ID_E_SDTXML_UPDATES_NOT_ALLOWED_ON_THIS_KIND_OF_TABLE
//
// MessageText:
//
//  Updates are not allowed on this table. %1%2%3%4%5%0
//
#define ID_E_SDTXML_UPDATES_NOT_ALLOWED_ON_THIS_KIND_OF_TABLE ((DWORD)0xC0000524L)

//
// MessageId: ID_E_SDTXML_NOT_IN_CACHE
//
// MessageText:
//
//  The specified information was not in the cache. %1%2%3%4%5%0
//
#define ID_E_SDTXML_NOT_IN_CACHE         ((DWORD)0xC0000525L)

//
// MessageId: ID_E_SDTXML_INVALID_ENUM_OR_FLAG
//
// MessageText:
//
//  The specified Enum of Flag is invalid. %1%2%3%4%5%0
//
#define ID_E_SDTXML_INVALID_ENUM_OR_FLAG ((DWORD)0xC0000526L)

//
// MessageId: ID_E_SDTXML_FILE_NOT_WRITABLE
//
// MessageText:
//
//  The specified file is not writable. %1%2%3%4%5%0
//
#define ID_E_SDTXML_FILE_NOT_WRITABLE    ((DWORD)0xC0000527L)

//
// MessageId: ID_E_ST_INVALIDTABLE
//
// MessageText:
//
//  Call to GetTable failed. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDTABLE             ((DWORD)0xC000080AL)

//
// MessageId: ID_E_ST_INVALIDQUERY
//
// MessageText:
//
//  The specified query is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDQUERY             ((DWORD)0xC000080BL)

//
// MessageId: ID_E_ST_QUERYNOTSUPPORTED
//
// MessageText:
//
//  The query type is not supported. %1%2%3%4%5%0
//
#define ID_E_ST_QUERYNOTSUPPORTED        ((DWORD)0xC000080CL)

//
// MessageId: ID_E_ST_LOSNOTSUPPORTED
//
// MessageText:
//
//  The specified Level Of Service is not supported. %1%2%3%4%5%0
//
#define ID_E_ST_LOSNOTSUPPORTED          ((DWORD)0xC000080DL)

//
// MessageId: ID_E_ST_INVALIDMETA
//
// MessageText:
//
//  The meta information for this table is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDMETA              ((DWORD)0xC000080EL)

//
// MessageId: ID_E_ST_INVALIDWIRING
//
// MessageText:
//
//  The wiring is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDWIRING            ((DWORD)0xC000080FL)

//
// MessageId: ID_E_ST_OMITDISPENSER
//
// MessageText:
//
//  This interceptor should be ignored when searching for a valid interceptor. %1%2%3%4%5%0
//
#define ID_E_ST_OMITDISPENSER            ((DWORD)0xC0000810L)

//
// MessageId: ID_E_ST_OMITLOGIC
//
// MessageText:
//
//  This logic interceptor should be ignored while searching for a logic interceptor. %1%2%3%4%5%0
//
#define ID_E_ST_OMITLOGIC                ((DWORD)0xC0000811L)

//
// MessageId: ID_E_ST_INVALIDSNID
//
// MessageText:
//
//  The specified SNID is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDSNID              ((DWORD)0xC0000812L)

//
// MessageId: ID_E_ST_INVALIDCALL
//
// MessageText:
//
//  The Call is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDCALL              ((DWORD)0xC0000815L)

//
// MessageId: ID_E_ST_NOMOREROWS
//
// MessageText:
//
//  The index of the row specified is too big. %1%2%3%4%5%0
//
#define ID_E_ST_NOMOREROWS               ((DWORD)0xC0000816L)

//
// MessageId: ID_E_ST_NOMORECOLUMNS
//
// MessageText:
//
//  The index of the column specified is too big. %1%2%3%4%5%0
//
#define ID_E_ST_NOMORECOLUMNS            ((DWORD)0xC0000817L)

//
// MessageId: ID_E_ST_NOMOREERRORS
//
// MessageText:
//
//  The index of the error row specified is too big. %1%2%3%4%5%0
//
#define ID_E_ST_NOMOREERRORS             ((DWORD)0xC0000818L)

//
// MessageId: ID_E_ST_ERRORTABLE
//
// MessageText:
//
//  Detailed error has occurred. Get error table to get more information. %1%2%3%4%5%0
//
#define ID_E_ST_ERRORTABLE               ((DWORD)0xC000081EL)

//
// MessageId: ID_E_ST_DETAILEDERRS
//
// MessageText:
//
//  Detailed errors have occurred. %1%2%3%4%5%0
//
#define ID_E_ST_DETAILEDERRS             ((DWORD)0xC000081FL)

//
// MessageId: ID_E_ST_VALUENEEDED
//
// MessageText:
//
//  A non-nullable (or primary key) column does not have a value. %1%2%3%4%5%0
//
#define ID_E_ST_VALUENEEDED              ((DWORD)0xC0000820L)

//
// MessageId: ID_E_ST_VALUEINVALID
//
// MessageText:
//
//  The value specified is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_VALUEINVALID             ((DWORD)0xC0000821L)

//
// MessageId: ID_E_ST_SIZENEEDED
//
// MessageText:
//
//  You need to specify a size for this column. %1%2%3%4%5%0
//
#define ID_E_ST_SIZENEEDED               ((DWORD)0xC0000825L)

//
// MessageId: ID_E_ST_SIZEEXCEEDED
//
// MessageText:
//
//  The specified size is larger than the maximum size for this column. %1%2%3%4%5%0
//
#define ID_E_ST_SIZEEXCEEDED             ((DWORD)0xC0000826L)

//
// MessageId: ID_E_ST_PKNOTCHANGABLE
//
// MessageText:
//
//  It is not allowed to change the primary key. %1%2%3%4%5%0
//
#define ID_E_ST_PKNOTCHANGABLE           ((DWORD)0xC000082AL)

//
// MessageId: ID_E_ST_FKDOESNOTEXIST
//
// MessageText:
//
//  The primary key value that this foreign key points to does not exist. %1%2%3%4%5%0
//
#define ID_E_ST_FKDOESNOTEXIST           ((DWORD)0xC000082BL)

//
// MessageId: ID_E_ST_ROWDOESNOTEXIST
//
// MessageText:
//
//  The row does not exist. %1%2%3%4%5%0
//
#define ID_E_ST_ROWDOESNOTEXIST          ((DWORD)0xC0000830L)

//
// MessageId: ID_E_ST_ROWALREADYEXISTS
//
// MessageText:
//
//  The row already exists. %1%2%3%4%5%0
//
#define ID_E_ST_ROWALREADYEXISTS         ((DWORD)0xC0000831L)

//
// MessageId: ID_E_ST_ROWALREADYUPDATED
//
// MessageText:
//
//  The row is already updated. %1%2%3%4%5%0
//
#define ID_E_ST_ROWALREADYUPDATED        ((DWORD)0xC0000832L)

//
// MessageId: ID_E_ST_INVALIDEXTENDEDMETA
//
// MessageText:
//
//  The extened meta information is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDEXTENDEDMETA      ((DWORD)0xC0000833L)

//
// MessageId: ID_E_ST_INVALIDSELECTOR
//
// MessageText:
//
//  The specified selector is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDSELECTOR          ((DWORD)0xC0000850L)

//
// MessageId: ID_E_ST_MULTIPLESELECTOR
//
// MessageText:
//
//  The query string contains multiple selectors. %1%2%3%4%5%0
//
#define ID_E_ST_MULTIPLESELECTOR         ((DWORD)0xC0000851L)

//
// MessageId: ID_E_ST_NOCONFIGSTORES
//
// MessageText:
//
//  No configuration stores where found while trying to do merging. %1%2%3%4%5%0
//
#define ID_E_ST_NOCONFIGSTORES           ((DWORD)0xC0000852L)

//
// MessageId: ID_E_ST_UNKNOWNPROTOCOL
//
// MessageText:
//
//  The specified protocol is invalid/unknown. %1%2%3%4%5%0
//
#define ID_E_ST_UNKNOWNPROTOCOL          ((DWORD)0xC0000853L)

//
// MessageId: ID_E_ST_UNKNOWNWEBSERVER
//
// MessageText:
//
//  The specified webserver is unknown. %1%2%3%4%5%0
//
#define ID_E_ST_UNKNOWNWEBSERVER         ((DWORD)0xC0000854L)

//
// MessageId: ID_E_ST_UNKNOWNDIRECTIVE
//
// MessageText:
//
//  The specified directive is unknown/invalid. %1%2%3%4%5%0
//
#define ID_E_ST_UNKNOWNDIRECTIVE         ((DWORD)0xC0000855L)

//
// MessageId: ID_E_ST_DISALLOWOVERRIDE
//
// MessageText:
//
//  The configuration setting were locked down by a previous configuration file. %1%2%3%4%5%0
//
#define ID_E_ST_DISALLOWOVERRIDE         ((DWORD)0xC0000856L)

//
// MessageId: ID_E_ST_NEEDDIRECTIVE
//
// MessageText:
//
//  The specified table does not have first column as DIRECTIVE. %1%2%3%4%5%0
//
#define ID_E_ST_NEEDDIRECTIVE            ((DWORD)0xC0000857L)

//
// MessageId: ID_E_ST_INVALIDSTATE
//
// MessageText:
//
//  The state is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDSTATE             ((DWORD)0xC0000860L)

//
// MessageId: ID_E_ST_COMPILEFAILED
//
// MessageText:
//
//  The compile failed. %1%2%3%4%5%0
//
#define ID_E_ST_COMPILEFAILED            ((DWORD)0xC0000861L)

//
// MessageId: ID_E_ST_INVALIDBINFILE
//
// MessageText:
//
//  The specified .bin file is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDBINFILE           ((DWORD)0xC0000862L)

//
// MessageId: ID_E_ST_INVALIDCOOKIE
//
// MessageText:
//
//  The specified cookie is invalid. %1%2%3%4%5%0
//
#define ID_E_ST_INVALIDCOOKIE            ((DWORD)0xC0000870L)

//
// MessageId: ID_COMCAT_REGDB_FOUNDCORRUPT
//
// MessageText:
//
//  The current registration database is corrupt. COM+ catalog has reverted to a previous version of the database. %1%2%3%4%5%0
//
#define ID_COMCAT_REGDB_FOUNDCORRUPT     ((DWORD)0xC0001068L)

//
// MessageId: ID_COMCAT_REGDB_INITSECURITYDESC
//
// MessageText:
//
//  Error creating security descriptor. %1%2%3%4%5%0
//
#define ID_COMCAT_REGDB_INITSECURITYDESC ((DWORD)0xC0001083L)

//
// MessageId: ID_COMCAT_REGDBSVR_INITFAILED
//
// MessageText:
//
//  Failed to initialize registration database server. %1%2%3%4%5%0
//
#define ID_COMCAT_REGDBSVR_INITFAILED    ((DWORD)0xC0001084L)

//
// MessageId: ID_COMCAT_REGDBAPI_INITFAILED
//
// MessageText:
//
//  Failed to initialize registration database API. %1%2%3%4%5%0
//
#define ID_COMCAT_REGDBAPI_INITFAILED    ((DWORD)0xC0001085L)

//
// MessageId: ID_COMCAT_SLTCOMS_THREADINGMODELINCONSISTENT
//
// MessageText:
//
//  The threading model of the component specified in the registry is inconsistent with the registration database. The faulty component is: %1%2%3%4%5%0
//
#define ID_COMCAT_SLTCOMS_THREADINGMODELINCONSISTENT ((DWORD)0xC00210AAL)

//
// MessageId: IDS_COMCAT_XML_PARSE_FAILED
//
// MessageText:
//
//  The XML File failed to parse.%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_PARSE_FAILED      ((DWORD)0xC00210ADL)

//
// MessageId: IDS_COMCAT_COOKDOWN_FAILED
//
// MessageText:
//
//  Internal compilation failed.%1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_FAILED       ((DWORD)0xC00210AEL)

//
// MessageId: IDS_COMCAT_COOKDOWN_INTERNAL_ERROR
//
// MessageText:
//
//  An Internal error has occurred during compilation.%1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_INTERNAL_ERROR ((DWORD)0xC00210AFL)

//
// MessageId: IDS_COMCAT_XML_LOGIC_FAILURE
//
// MessageText:
//
//  The XML File contains a logical error.%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_LOGIC_FAILURE     ((DWORD)0xC00210B1L)

//
// MessageId: IDS_COMCAT_FILE_NOT_FOUND
//
// MessageText:
//
//  File not found.%1%2%3%4%5%0
//
#define IDS_COMCAT_FILE_NOT_FOUND        ((DWORD)0xC00210B2L)

//
// MessageId: IDS_COMCAT_XML_PARSE_ERROR
//
// MessageText:
//
//  Error Parsing XML file.%1Reason: %2 Incorrect XML: %3%4%5%0
//
#define IDS_COMCAT_XML_PARSE_ERROR       ((DWORD)0xC00210B3L)

//
// MessageId: IDS_COMCAT_XML_ELEMENT_NAME_TOO_LONG
//
// MessageText:
//
//  Ignoring Element name with length greater than 1023 characters (%1).%2%3%4%5%0
//
#define IDS_COMCAT_XML_ELEMENT_NAME_TOO_LONG ((DWORD)0x800210B4L)

//
// MessageId: IDS_COMCAT_XML_METABASE_CLASS_NOT_FOUND
//
// MessageText:
//
//  Element found (%1) that does NOT match one of the defined Metabase Classes.%2%3%4%5%0
//
#define IDS_COMCAT_XML_METABASE_CLASS_NOT_FOUND ((DWORD)0x800210B5L)

//
// MessageId: IDS_COMCAT_XML_CUSTOM_ELEMENT_NOT_UNDER_PARENT
//
// MessageText:
//
//  'Custom' element found which is NOT under a proper 'parent node'.  Incorrect XML:%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_CUSTOM_ELEMENT_NOT_UNDER_PARENT ((DWORD)0x800210B6L)

//
// MessageId: IDS_COMCAT_XML_NO_METABASE_LOCATION_FOUND
//
// MessageText:
//
//  No Location attribute found.  This must be an undefined element (%1).  Ignoring it. Incorrect XML:%2%3%4%5%0
//
#define IDS_COMCAT_XML_NO_METABASE_LOCATION_FOUND ((DWORD)0x800210B7L)

//
// MessageId: IDS_COMCAT_XML_METABASE_NO_PROPERTYMETA_FOUND
//
// MessageText:
//
//  No PropertyMeta found for Attribute (%1).  Ignoring it.  Incorrect XML:%2%3%4%5%0
//
#define IDS_COMCAT_XML_METABASE_NO_PROPERTYMETA_FOUND ((DWORD)0x800210B8L)

//
// MessageId: IDS_COMCAT_MBSCHEMA_BIN_INVALID
//
// MessageText:
//
//  The schema file (%1) is not compatible with this configuration system.  Reverting to the shipped schema.%2%3%4%5%0
//
#define IDS_COMCAT_MBSCHEMA_BIN_INVALID  ((DWORD)0x800210B9L)

//
// MessageId: IDS_COMCAT_XML_ILLEGAL_FLAG_VALUE
//
// MessageText:
//
//  Invalid Flag (%1), Ignoring unknown flag value.  Incorrect XML:%2%3%4%5%0
//
#define IDS_COMCAT_XML_ILLEGAL_FLAG_VALUE ((DWORD)0x800210BAL)

//
// MessageId: IDS_COMCAT_XML_FLAG_BITS_DONT_MATCH_FLAG_MASK
//
// MessageText:
//
//  Invalid Flag(s).  Property (%1) has Value (%2), which does not match legal mask (%3).  Continuing anyway.  Incorrect XML:%4%5%0
//
#define IDS_COMCAT_XML_FLAG_BITS_DONT_MATCH_FLAG_MASK ((DWORD)0x800210BBL)

//
// MessageId: IDS_COMCAT_XML_CUSTOM_KEYTYPE_NOT_ON_IISCONFIGOBJECT
//
// MessageText:
//
//  Custom KeyTypes are allowed on %1 only.  Incorrect XML:%2%3%4%5%0
//
#define IDS_COMCAT_XML_CUSTOM_KEYTYPE_NOT_ON_IISCONFIGOBJECT ((DWORD)0x800210BCL)

//
// MessageId: IDS_COMCAT_METABASE_PROPERTY_NOT_FOUND
//
// MessageText:
//
//  Unable to find Metabase Property %1.  This property is required.%2%3%4%5%0
//
#define IDS_COMCAT_METABASE_PROPERTY_NOT_FOUND ((DWORD)0x800210BDL)

//
// MessageId: IDS_COMCAT_XML_BINARY_STRING_CONTAINS_ODD_NUMBER_OF_CHARACTERS
//
// MessageText:
//
//  An Odd number of characters was specified for a 'bin.hex' attribute value (%1).  %2%3%4%5%0
//
#define IDS_COMCAT_XML_BINARY_STRING_CONTAINS_ODD_NUMBER_OF_CHARACTERS ((DWORD)0x800210BEL)

//
// MessageId: IDS_COMCAT_XML_BINARY_STRING_CONTAINS_A_NON_HEX_CHARACTER
//
// MessageText:
//
//  A 'bin.hex' attribute value (%1) contains a non-hex character%2%3%4%5%0
//
#define IDS_COMCAT_XML_BINARY_STRING_CONTAINS_A_NON_HEX_CHARACTER ((DWORD)0x800210BFL)

//
// MessageId: IDS_COMCAT_XML_DOM_PARSE_SUCCEEDED_WHEN_NODE_FACTORY_PARSE_FAILED
//
// MessageText:
//
//  The XML file (%1) failed to parse.%2%3%4%5%0
//
#define IDS_COMCAT_XML_DOM_PARSE_SUCCEEDED_WHEN_NODE_FACTORY_PARSE_FAILED ((DWORD)0xC00210C0L)

//
// MessageId: IDS_COMCAT_METABASE_CUSTOM_ELEMENT_EXPECTED
//
// MessageText:
//
//  Custom element expected.  Ignoring unknown element.  Incorrect XML:%1%2%3%4%5%0
//
#define IDS_COMCAT_METABASE_CUSTOM_ELEMENT_EXPECTED ((DWORD)0x800210C1L)

//
// MessageId: IDS_COMCAT_METABASE_CUSTOM_ELEMENT_FOUND_BUT_NO_KEY_TYPE_LOCATION
//
// MessageText:
//
//  Custom element found; but no KeyType Location.  Incorrect XML:%1%2%3%4%5%0
//
#define IDS_COMCAT_METABASE_CUSTOM_ELEMENT_FOUND_BUT_NO_KEY_TYPE_LOCATION ((DWORD)0x800210C2L)

//
// MessageId: IDS_COMCAT_METABASE_CUSTOM_PROPERTY_NAME_ID_CONFLICT
//
// MessageText:
//
//  Custom Property has Name(%1) which conflicts with ID(%2).  Incorrect XML:%3%4%5%0
//
#define IDS_COMCAT_METABASE_CUSTOM_PROPERTY_NAME_ID_CONFLICT ((DWORD)0x800210C3L)

//
// MessageId: IDS_COMCAT_METABASE_CUSTOM_ELEMENT_CONTAINS_NO_ID
//
// MessageText:
//
//  A Custom element was found but contained no 'ID' attribute.  Ignoring this element.  Incorrect XML:%1%2%3%4%5%0
//
#define IDS_COMCAT_METABASE_CUSTOM_ELEMENT_CONTAINS_NO_ID ((DWORD)0x800210C4L)

//
// MessageId: IDS_COMCAT_METABASE_CUSTOM_ELEMENT_CONTAINS_NO_TYPE
//
// MessageText:
//
//  A Custom Property (%1) was found but contained no 'Type' attribute.  Defaulting to 'String'.  Incorrect XML:%2%3%4%5%0
//
#define IDS_COMCAT_METABASE_CUSTOM_ELEMENT_CONTAINS_NO_TYPE ((DWORD)0x800210C5L)

//
// MessageId: IDS_COMCAT_XML_ILLEGAL_BOOL_VALUE
//
// MessageText:
//
//  Invalid Boolean Value (%1), Ignoring property with unknown Boolean value.%2%3%4%5%0
//
#define IDS_COMCAT_XML_ILLEGAL_BOOL_VALUE ((DWORD)0x800210C6L)

//
// MessageId: IDS_COMCAT_XML_ILLEGAL_ENUM_VALUE
//
// MessageText:
//
//  Invalid Enum Value (%1), Ignoring property with unknown Enum value.%2%3%4%5%0
//
#define IDS_COMCAT_XML_ILLEGAL_ENUM_VALUE ((DWORD)0x800210C7L)

//
// MessageId: IDS_COMCAT_CLASS_NOT_FOUND_IN_META
//
// MessageText:
//
//  Class (%1) not found in metabase OR found in inappropriate location or position.%2%3%4%5%0
//
#define IDS_COMCAT_CLASS_NOT_FOUND_IN_META ((DWORD)0xC00210C8L)

//
// MessageId: IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA
//
// MessageText:
//
//  Error retrieving shipped schema table (%1).%2%3%4%5%0
//
#define IDS_COMCAT_ERROR_GETTTING_SHIPPED_SCHEMA ((DWORD)0xC00210C9L)

//
// MessageId: IDS_COMCAT_OUTOFMEMORY
//
// MessageText:
//
//  Out of memory.%1%2%3%4%5%0
//
#define IDS_COMCAT_OUTOFMEMORY           ((DWORD)0xC00210CAL)

//
// MessageId: IDS_COMCAT_ERROR_IN_DIRECTIVE_INHERITANCE
//
// MessageText:
//
//  Schema Compilation Error in Inheritance: Referenced Column (%1) is a Directive column, this is not supported.%2%3%4%5%0
//
#define IDS_COMCAT_ERROR_IN_DIRECTIVE_INHERITANCE ((DWORD)0xC00210CBL)

//
// MessageId: IDS_COMCAT_INHERITED_FLAG_OR_ENUM_HAS_NO_TAGS_DEFINED
//
// MessageText:
//
//  Schema Compilation Error in Inheritance: Referenced Column (%1:%2) is a Flag or Enum.  But there are no Flag/Enum values defined.%3%4%5%0
//
#define IDS_COMCAT_INHERITED_FLAG_OR_ENUM_HAS_NO_TAGS_DEFINED ((DWORD)0xC00210CCL)

//
// MessageId: IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_TOO_LARGE
//
// MessageText:
//
//  Schema Compilation Error: DefaultValue is too big.  Maximum size is (%1) bytes.  Column(%2).%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_TOO_LARGE ((DWORD)0xC00210CDL)

//
// MessageId: IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_FIXEDLENGTH_MULTISTRING_NOT_ALLOWED
//
// MessageText:
//
//  Schema Compilation Error: DefaultValue on a FixedLength MultiString is not allowed.  Column(%1).%2%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_DEFAULT_VALUE_FIXEDLENGTH_MULTISTRING_NOT_ALLOWED ((DWORD)0xC00210CEL)

//
// MessageId: IDS_SCHEMA_COMPILATION_ATTRIBUTE_NOT_FOUND
//
// MessageText:
//
//  Schema Compilation Error: Attribute (%1) not found.  Incorrect XML (%2).%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_ATTRIBUTE_NOT_FOUND ((DWORD)0xC00210CFL)

//
// MessageId: IDS_SCHEMA_COMPILATION_ATTRIBUTE_CONTAINS_TOO_MANY_CHARACTERS
//
// MessageText:
//
//  Schema Compilation Error: Attribute (%1) has value (%2), which contains too many characters.%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_ATTRIBUTE_CONTAINS_TOO_MANY_CHARACTERS ((DWORD)0xC00210D0L)

//
// MessageId: IDS_SCHEMA_COMPILATION_INHERITSPROPERTIESFROM_ERROR
//
// MessageText:
//
//  Schema Compilation Error: Attribute (InheritsPropertiesFrom) has value (%1) which should be in the form (TableName::ColumnName).%2%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_INHERITSPROPERTIESFROM_ERROR ((DWORD)0xC00210D1L)

//
// MessageId: IDS_SCHEMA_COMPILATION_INHERITSPROPERTIESFROM_BOGUS_TABLE
//
// MessageText:
//
//  Schema Compilation Error: Property attempted to inherit from table (%1).  Properties may only inherit from table (%2).%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_INHERITSPROPERTIESFROM_BOGUS_TABLE ((DWORD)0xC00210D2L)

//
// MessageId: IDS_SCHEMA_COMPILATION_NO_METABASE_DATABASE
//
// MessageText:
//
//  Schema Compilation Error: Required database (%1) not found.  Either an internal error occurred OR this DLL was incorrectly set as the IIS product when meta for IIS does not exist.%2%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_NO_METABASE_DATABASE ((DWORD)0xC00210D3L)

//
// MessageId: IDS_SCHEMA_COMPILATION_UNKNOWN_DATA_TYPE
//
// MessageText:
//
//  Schema Compilation Error: Data type (%1) unknown.%2%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_UNKNOWN_DATA_TYPE ((DWORD)0xC00210D4L)

//
// MessageId: IDS_METABASE_DUPLICATE_LOCATION
//
// MessageText:
//
//  Duplicate location found (%1).  Ignoring the properties found in the latter location.%2%3%4%5%0
//
#define IDS_METABASE_DUPLICATE_LOCATION  ((DWORD)0x800210D5L)

//
// MessageId: IDS_CATALOG_INTERNAL_ERROR
//
// MessageText:
//
//  Internal Error: %1%2%3%4%5%0
//
#define IDS_CATALOG_INTERNAL_ERROR       ((DWORD)0x800210D6L)

//
// MessageId: IDS_SCHEMA_COMPILATION_ILLEGAL_ENUM_VALUE
//
// MessageText:
//
//  Schema Compilation Error: Enum specified (%1) is not a valid Enum for Table (%2)%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_ILLEGAL_ENUM_VALUE ((DWORD)0xC00210D7L)

//
// MessageId: IDS_SCHEMA_COMPILATION_ILLEGAL_FLAG_VALUE
//
// MessageText:
//
//  Schema Compilation Error: Flag specified (%1) is not a valid Flag for Table (%2).  This flag will be ignored.%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_ILLEGAL_FLAG_VALUE ((DWORD)0x800210D8L)

//
// MessageId: IDS_COMCAT_WIN32
//
// MessageText:
//
//  Win32 API call failed: Call (%1).%2%3%4%5%0
//
#define IDS_COMCAT_WIN32                 ((DWORD)0x800210D9L)

//
// MessageId: IDS_COMCAT_XML_FILENAMENOTPROVIDED
//
// MessageText:
//
//  No file name supplied.%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_FILENAMENOTPROVIDED ((DWORD)0xC00210DAL)

//
// MessageId: IDS_COMCAT_XML_FILENAMETOOLONG
//
// MessageText:
//
//  File name supplied (...%1) is too long.%2%3%4%5%0
//
#define IDS_COMCAT_XML_FILENAMETOOLONG   ((DWORD)0xC00210DBL)

//
// MessageId: IDS_COMCAT_XML_BOGUSBYTECHARACTER
//
// MessageText:
//
//  Invalid character found in value (%1).  Strings typed as BYTES must have only 0-9, a-f, A-F.%2%3%4%5%0
//
#define IDS_COMCAT_XML_BOGUSBYTECHARACTER ((DWORD)0xC00210DCL)

//
// MessageId: IDS_COMCAT_XML_BOGUSBOOLEANSTRING
//
// MessageText:
//
//  Invalid boolean string value (%1).  The only legal BOOL values are: true, false, 0, 1, yes, no, on, off.%2%3%4%5%0
//
#define IDS_COMCAT_XML_BOGUSBOOLEANSTRING ((DWORD)0xC00210DDL)

//
// MessageId: IDS_COMCAT_XML_BOGUSENUMVALUE
//
// MessageText:
//
//  Invalid enum value (%1).  One enum value may be supplied.  The following are examples of legal enum values for this property: %2 %3 %4%5%0
//
#define IDS_COMCAT_XML_BOGUSENUMVALUE    ((DWORD)0xC00210DEL)

//
// MessageId: IDS_COMCAT_XML_BOGUSFLAGVALUE
//
// MessageText:
//
//  Invalid flag value (%1).  Multiple flags may be separated by a comma, the | character and/or a space.  The following are examples of legal flag values for this property: %2 %3 %4%5%0
//
#define IDS_COMCAT_XML_BOGUSFLAGVALUE    ((DWORD)0xC00210DFL)

//
// MessageId: IDS_COMCAT_XML_FILENOTWRITEABLE
//
// MessageText:
//
//  The file (%1) is not write accessible.%2%3%4%5%0
//
#define IDS_COMCAT_XML_FILENOTWRITEABLE  ((DWORD)0xC00210E0L)

//
// MessageId: IDS_COMCAT_XML_PARENTTABLEDOESNOTEXIST
//
// MessageText:
//
//  Parent table does not exist.%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_PARENTTABLEDOESNOTEXIST ((DWORD)0xC00210E1L)

//
// MessageId: IDS_COMCAT_XML_PRIMARYKEYISNULL
//
// MessageText:
//
//  PrimaryKey column (%1) is NULL.  Parent table does not exist.%2%3%4%5%0
//
#define IDS_COMCAT_XML_PRIMARYKEYISNULL  ((DWORD)0xC00210E2L)

//
// MessageId: IDS_COMCAT_XML_NOTNULLABLECOLUMNISNULL
//
// MessageText:
//
//  A Column (%1) is NULL.  This column is marked as NOTNULLABLE, so a value must be provided.%2%3%4%5%0
//
#define IDS_COMCAT_XML_NOTNULLABLECOLUMNISNULL ((DWORD)0xC00210E3L)

//
// MessageId: IDS_COMCAT_XML_ROWALREADYEXISTS
//
// MessageText:
//
//  Attempted to Insert a new row; but a row with the same Primary Key already exists.  Updated the row instead.%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_ROWALREADYEXISTS  ((DWORD)0xC00210E4L)

//
// MessageId: IDS_COMCAT_XML_ROWDOESNOTEXIST
//
// MessageText:
//
//  Attempted to Update a row; but no row matching the Primary Key currently exists.  Insert a new row instead.%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_ROWDOESNOTEXIST   ((DWORD)0xC00210E5L)

//
// MessageId: IDS_COMCAT_XML_BOGUSENUMVALUEINWRITECACHE
//
// MessageText:
//
//  Invalid enum value (%2) supplied for Column (%1)%3%4%5%0
//
#define IDS_COMCAT_XML_BOGUSENUMVALUEINWRITECACHE ((DWORD)0xC00210E6L)

//
// MessageId: IDS_COMCAT_XML_POPULATE_ROWALREADYEXISTS
//
// MessageText:
//
//  Two rows within the XML have the same primary key.%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_POPULATE_ROWALREADYEXISTS ((DWORD)0xC00210E7L)

//
// MessageId: IDS_METABASE_DUPLICATE_PROPERTY
//
// MessageText:
//
//  Two properties with the same name (%1), under Location (%2) were specified in the XML.  Ignoring the latter property.%3%4%5%0
//
#define IDS_METABASE_DUPLICATE_PROPERTY  ((DWORD)0xC00210E8L)

//
// MessageId: IDS_METABASE_TOO_MANY_WARNINGS
//
// MessageText:
//
//  The file (%1) contains too many warnings.  No more warnings will be reported.%2%3%4%5%0
//
#define IDS_METABASE_TOO_MANY_WARNINGS   ((DWORD)0xC00210E9L)

//
// MessageId: IDS_COMCAT_XML_ILLEGAL_NUMERIC_VALUE
//
// MessageText:
//
//  Invalid Numeric Value.  Ignoring property.  Incorrect XML:%1%2%3%4%5%0
//
#define IDS_COMCAT_XML_ILLEGAL_NUMERIC_VALUE ((DWORD)0xC00210EAL)

//
// MessageId: IDS_METABASE_DUPLICATE_PROPERTY_ID
//
// MessageText:
//
//  Two properties with the same ID (%1), under Location (%2) were specified in the XML.  Ignoring the latter property.%3%4%5%0
//
#define IDS_METABASE_DUPLICATE_PROPERTY_ID ((DWORD)0xC00210EBL)

//
// MessageId: IDS_SCHEMA_COMPILATION_USERDEFINED_PROPERTY_HAS_COLLIDING_ID
//
// MessageText:
//
//  Property (%1) defined in schema has the Property ID (%2) which collides with property (%3) already defined.  Ignoring the latter property.  Incorrect XML:%4%5%0
//
#define IDS_SCHEMA_COMPILATION_USERDEFINED_PROPERTY_HAS_COLLIDING_ID ((DWORD)0x800210ECL)

//
// MessageId: IDS_SCHEMA_COMPILATION_USERDEFINED_PROPERTY_HAS_COLLIDING_ID_
//
// MessageText:
//
//  Property (%1) defined in schema has the Property ID (%2) which was already defined.  Ignoring the latter property.  Incorrect XML:%3%4%5%0
//
#define IDS_SCHEMA_COMPILATION_USERDEFINED_PROPERTY_HAS_COLLIDING_ID_ ((DWORD)0x800210EDL)

//
// MessageId: MD_ERROR_READING_SCHEMA_BIN
//
// MessageText:
//
//  Schema information could not be read because could not fetch or read the binary file where the information resides.%1%2%3%4%5%0
//
#define MD_ERROR_READING_SCHEMA_BIN      ((DWORD)0xC002C811L)

//
// MessageId: MD_ERROR_NO_MATCHING_HISTORY_FILE
//
// MessageText:
//
//  Could not find a history file with the same major version number as the one being edited.  Therefore, these edits can not be processed.%1%2%3%4%5%0
//
#define MD_ERROR_NO_MATCHING_HISTORY_FILE ((DWORD)0xC002C812L)

//
// MessageId: MD_ERROR_PROCESSING_TEXT_EDITS
//
// MessageText:
//
//  An error occurred while processing text edits to the metabase file. The file with the error has been copied into the history directory with the name Errors appended to it.%1%2%3%4%5%0
//
#define MD_ERROR_PROCESSING_TEXT_EDITS   ((DWORD)0xC002C813L)

//
// MessageId: MD_ERROR_COMPUTING_TEXT_EDITS
//
// MessageText:
//
//  An error occurred while determining what text edits were made to the metabase file. %1%2%3%4%5%0
//
#define MD_ERROR_COMPUTING_TEXT_EDITS    ((DWORD)0xC002C814L)

//
// MessageId: MD_ERROR_READING_TEXT_EDITS
//
// MessageText:
//
//  An error occurred while reading the text edits that were made to the metabase file. %1%2%3%4%5%0
//
#define MD_ERROR_READING_TEXT_EDITS      ((DWORD)0xC002C815L)

//
// MessageId: MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE
//
// MessageText:
//
//  An error occurred while applying text edits to the metabase.%1%2%3%4%5%0
//
#define MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE ((DWORD)0xC002C816L)

//
// MessageId: MD_ERROR_APPLYING_TEXT_EDITS_TO_HISTORY
//
// MessageText:
//
//  An error occurred while applying text edits to the history file.%1%2%3%4%5%0
//
#define MD_ERROR_APPLYING_TEXT_EDITS_TO_HISTORY ((DWORD)0xC002C817L)

//
// MessageId: MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS
//
// MessageText:
//
//  An error occurred during the processing of text edits. Due to this error, no further text edits will be processed. It is necessary to restart the IISAdmin process to recover.%1%2%3%4%5%0
//
#define MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS ((DWORD)0xC002C818L)

//
// MessageId: MD_ERROR_READ_XML_FILE
//
// MessageText:
//
//  Unable to read the edited metabase file (tried 10 times). Check for (a) Missing metabase file or (b) Locked metabase file or (c) XML syntax errors.%1%2%3%4%5%0
//
#define MD_ERROR_READ_XML_FILE           ((DWORD)0xC002C819L)

//
// MessageId: MD_ERROR_SAVING_APPLIED_TEXT_EDITS
//
// MessageText:
//
//  An error occurred while saving the text edits that were applied to the metabase.%1%2%3%4%5%0
//
#define MD_ERROR_SAVING_APPLIED_TEXT_EDITS ((DWORD)0xC002C81AL)

//
// MessageId: MD_ERROR_COPY_ERROR_FILE
//
// MessageText:
//
//  An error occurred while processing text edits to the metabase file.  Normally the file with the error would be copied to the History folder, however an error prevented this.%1%2%3%4%5%0
//
#define MD_ERROR_COPY_ERROR_FILE         ((DWORD)0xC002C81BL)

//
// MessageId: MD_ERROR_UNABLE_TOSAVE_METABASE
//
// MessageText:
//
//  An error occurred while saving the metabase file.%1%2%3%4%5%0
//
#define MD_ERROR_UNABLE_TOSAVE_METABASE  ((DWORD)0xC002C81CL)

//
// MessageId: IDS_COMCAT_NOTIFICATION_CLIENT_THREW_EXCEPTION
//
// MessageText:
//
//  A notification client threw an exception. %1%2%3%4%5%0
//
#define IDS_COMCAT_NOTIFICATION_CLIENT_THREW_EXCEPTION ((DWORD)0xC002C81DL)

//
// MessageId: IDS_COMCAT_EVENT_FIRING_THREAD_DIED_UNEXPECTEDLY
//
// MessageText:
//
//  The event firing thread died unexpectedly. %1%2%3%4%5%0
//
#define IDS_COMCAT_EVENT_FIRING_THREAD_DIED_UNEXPECTEDLY ((DWORD)0xC002C81EL)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_RANGE
//
// MessageText:
//
//  Invalid range encountered for a property. Will ignore the configured value and assume default values. TableName and PropertyName: %1 ValueFound: %2 ExpectedRange: %3 to %4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_RANGE ((DWORD)0xC002C81FL)

//
// MessageId: IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATIONS
//
// MessageText:
//
//  Enumerating applications from the metabase failed. Application path: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATIONS ((DWORD)0xC002C820L)

//
// MessageId: IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_PROPERTIES
//
// MessageText:
//
//  Enumerating application properties from the metabase failed. Ignoring this application. Application path & Site ID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_PROPERTIES ((DWORD)0xC002C821L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_INVALID_APPLICATION_APPPOOL
//
// MessageText:
//
//  Invalid application. The application's AppPoolID is invalid. Ignoring this application. Application's SiteID: %2  Application's relative path: %1 Application's AppPoolID: %3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_INVALID_APPLICATION_APPPOOL ((DWORD)0xC002C822L)

//
// MessageId: IDS_COMCAT_COOKDOWN_APPLICATION_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error has occurred while cooking down an application. Ignoring this application. Application path & Site ID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_APPLICATION_INTERNAL_ERROR ((DWORD)0xC002C823L)

//
// MessageId: IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_POOLS
//
// MessageText:
//
//  Enumerating application pools from the metabase failed.%1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_POOLS ((DWORD)0xC002C824L)

//
// MessageId: IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_POOL_PROPERTIES
//
// MessageText:
//
//  Enumerating application pool properties from the metabase failed. Ignoring this application pool. AppPoolID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_POOL_PROPERTIES ((DWORD)0xC002C825L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_NO_VALID_APPLICATION_APPPOOLS
//
// MessageText:
//
//  No valid application pools found in the metabase.%1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_NO_VALID_APPLICATION_APPPOOLS ((DWORD)0xC002C826L)

//
// MessageId: IDS_COMCAT_COOKDOWN_APPPOOL_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error has occurred while cooking down an application pool. Ignoring the application pool. AppPoolID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_APPPOOL_INTERNAL_ERROR ((DWORD)0xC002C827L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_CONFLICTING_PERIODICRESTARTTIME_IDLETIMEOUT
//
// MessageText:
//
//  Invalid application pool configuration. Idle timeout should be less than periodic restart time. Will ignore configured values and assume default values. AppPoolID: %1, IdleTimeout: %2, PeriodicRestartTime: %3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_CONFLICTING_PERIODICRESTARTTIME_IDLETIMEOUT ((DWORD)0xC002C828L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_APPLICATION_POOL_NAME
//
// MessageText:
//
//  Invalid application pool encountered. Application pool name has invalid number of characters. Ignoring this application pool. Expected minimum length: %1, Expected maximum length: %2 AppPoolID: %3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_APPLICATION_POOL_NAME ((DWORD)0xC002C829L)

//
// MessageId: IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_GLOBALW3SVC_PROPERTIES
//
// MessageText:
//
//  Enumerating properties at w3svc from the metabase failed.%1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_GLOBALW3SVC_PROPERTIES ((DWORD)0xC002C82AL)

//
// MessageId: IDS_COMCAT_COOKDOWN_GLOBALW3SVC_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error has occurred while cooking down an properties from w3svc. %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_GLOBALW3SVC_INTERNAL_ERROR ((DWORD)0xC002C82BL)

//
// MessageId: IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_SITES
//
// MessageText:
//
//  Enumerating sites from the metabase failed.%1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_SITES ((DWORD)0xC002C82CL)

//
// MessageId: IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_SITE_PROPERTIES
//
// MessageText:
//
//  Enumerating site properties from the metabase failed. Ignoring this site. SiteID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_SITE_PROPERTIES ((DWORD)0xC002C82DL)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_NO_VALID_SITES
//
// MessageText:
//
//  No valid sites found in the metabase.%1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_NO_VALID_SITES ((DWORD)0xC002C82EL)

//
// MessageId: IDS_COMCAT_COOKDOWN_SITE_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error has occurred while cooking down a site. Ignoring this site. SiteID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_SITE_INTERNAL_ERROR ((DWORD)0xC002C82FL)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_BINDINGS
//
// MessageText:
//
//  Invalid site encountered. Could not construct bindings for the site or no bindings found for the site. Ignoring this site. SiteID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_BINDINGS ((DWORD)0xC002C830L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_SITEFILTERFLAGS
//
// MessageText:
//
//  Could not compute filter flags for the site. Ignoring this site. SiteID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_SITEFILTERFLAGS ((DWORD)0xC002C831L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_DELETING_SITE_APPLICATIONS
//
// MessageText:
//
//  An error occured while deleting the site's applications. SiteID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_DELETING_SITE_APPLICATIONS ((DWORD)0xC002C832L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_DELETING_SITE
//
// MessageText:
//
//  An error occured while deleting the site. SiteID: %1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_DELETING_SITE ((DWORD)0xC002C833L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_ENUM
//
// MessageText:
//
//  Invalid enum value encountered for a property. TableName:%1 PropertyName: %2 EnumValueFound: %3 %4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_ENUM ((DWORD)0xC002C834L)

//
// MessageId: IDS_COMCAT_COOKDOWN_CONFIG_ERROR_FLAG
//
// MessageText:
//
//  Invalid flag value encountered for a property. TableName:%1 PropertyName: %2 FlagValueFound: %3 LegalFlagMask:%4%5%0
//
#define IDS_COMCAT_COOKDOWN_CONFIG_ERROR_FLAG ((DWORD)0xC002C835L)

//
// MessageId: IDS_COMCAT_COOKDOWN_INTERNAL_ERROR_WAIT_PREVIOUS_COOKDOWN
//
// MessageText:
//
//  An Internal error has occurred during compilation.Unable start cookdown. Waiting for previous cookdown/incremental cookdown to complete failed.%1%2%3%4%5%0
//
#define IDS_COMCAT_COOKDOWN_INTERNAL_ERROR_WAIT_PREVIOUS_COOKDOWN ((DWORD)0xC002C836L)

//
// MessageId: IDS_COMCAT_CLB_INTERNAL_ERROR
//
// MessageText:
//
//  An Internal error has occurred while writing the clb file. %1%2%3%4%5%0
//
#define IDS_COMCAT_CLB_INTERNAL_ERROR    ((DWORD)0xC002C837L)

//
// MessageId: MD_ERROR_DAFAULTING_MAX_HISTORY_FILES
//
// MessageText:
//
//  The configured value for the property MaxHistoryFiles is being ignored and it is being defaulted. This may be because it conflicted with the EnableEditWhileRunning and/or EnableHistory property. Please fix the configured value.%1%2%3%4%5%0
//
#define MD_ERROR_DAFAULTING_MAX_HISTORY_FILES ((DWORD)0xC002C838L)

//
// MessageId: MD_ERROR_COPYING_EDITED_FILE
//
// MessageText:
//
//  Could not copy the edited metabase file and hence cannot process user edits.%1%2%3%4%5%0
//
#define MD_ERROR_COPYING_EDITED_FILE     ((DWORD)0xC002C839L)

//
// MessageId: MD_WARNING_RESETTING_READ_ONLY_ATTRIB
//
// MessageText:
//
//  Resetting the read only attribute on the metabase file.%1%2%3%4%5%0
//
#define MD_WARNING_RESETTING_READ_ONLY_ATTRIB ((DWORD)0x8002C83AL)

//
// MessageId: MD_WARNING_HIGHEST_POSSIBLE_MINOR_FOUND
//
// MessageText:
//
//  A file with the highest minor number possible was already found. Hence cannot generate a higer minor file that contains the successfully applied user edits. We will apply the user edits to the file with the highest minor. It is recommended that you cleanup the minor files.%1%2%3%4%5%0
//
#define MD_WARNING_HIGHEST_POSSIBLE_MINOR_FOUND ((DWORD)0x8002C83BL)

//
// MessageId: MD_WARNING_IGNORING_DISCONTINUOUS_NODE
//
// MessageText:
//
//  A discontinous node was found. Ignoring it.%1%2%3%4%5%0
//
#define MD_WARNING_IGNORING_DISCONTINUOUS_NODE ((DWORD)0x8002C83CL)

//
// MessageId: MD_ERROR_METABASE_PATH_NOT_FOUND
//
// MessageText:
//
//  An edited metabase path was not found.%1%2%3%4%5%0
//
#define MD_ERROR_METABASE_PATH_NOT_FOUND ((DWORD)0xC002C83DL)

 /***** NEW ERROR MESSAGES GO ABOVE HERE *****/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\inc\makefile.inc ===
copyfiles:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\inc\iis.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iis.h

Abstract:

    Includes common user-mode header files.

Author:

    Murali Krishnan (MuraliK)       09-Nov-1998

Revision History:

--*/

#ifndef _IIS_H_
#define _IIS_H_



//
// Include all required system files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


//
// Include standard IIS definitions
//

#include <iisdef.h>



#endif // _IIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\inc\httprtl.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    httprtl.h

Abstract:

    This module contains public declarations for HTTPRTL.LIB, a body
    of code shared between kernel- and user-mode.

Author:

    Keith Moore (keithmo)       18-Jan-1999

Revision History:

    Chun Ye (chunye)            27-Sep-2000

        Renamed UL_* to HTTP_*.

--*/


#ifndef _HTTPRTL_H_
#define _HTTPRTL_H_


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


VOID
HttpRtlDummy(   // Gives the linker something to do until we can
    VOID        // actually populate this library with real code.
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _HTTPRTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\inc\iisdef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iisdef.h

Abstract:

    The IIS shared definitions header. 

Author:

    Seth Pollack (sethp)        01-Dec-1998

Revision History:

--*/


#ifndef _IISDEF_H_
#define _IISDEF_H_


//
// Define some standard 64-bit stuff here 
//

//
// The DIFF macro should be used around an expression involving pointer
// subtraction. The expression passed to DIFF is cast to a size_t type,
// allowing the result to be easily assigned to any 32-bit variable or
// passed to a function expecting a 32-bit argument.
//

#define DIFF(x)     ((size_t)(x))



//
// Signature helpers
//


//
// Create a signature that reads the same way in the debugger as how you
// define it in code. Done by byte-swapping the DWORD passed into it.
//
// Typical usage:
//
// #define FOOBAR_SIGNATURE         CREATE_SIGNATURE( 'FBAR' )
// #define FOOBAR_SIGNATURE_FREED   CREATE_SIGNATURE( 'fbaX' )
//

#define CREATE_SIGNATURE( Value )                                   \
            (                                                       \
                ( ( ( ( DWORD ) Value ) & 0xFF000000 ) >> 24 ) |    \
                ( ( ( ( DWORD ) Value ) & 0x00FF0000 ) >> 8 )  |    \
                ( ( ( ( DWORD ) Value ) & 0x0000FF00 ) << 8 )  |    \
                ( ( ( ( DWORD ) Value ) & 0x000000FF ) << 24 )      \
            )                                                       \



#ifndef __HTTP_SYS__

//
// Error handling helpers
//

#ifdef __cplusplus

//
// Recover the Win32 error from an HRESULT. 
//
// The HRESULT must be a failure, i.e. FAILED(hr) must be true.
// If these conditions are not met, then it returns the error code 
// ERROR_INVALID_PARAMETER.
//

inline DWORD WIN32_FROM_HRESULT(
    IN HRESULT hr
    )
{
    if ( ( FAILED( hr ) ) && 
         ( HRESULT_FACILITY( hr ) == FACILITY_WIN32 ) )
    {
        return ( HRESULT_CODE( hr ) );
    }
    else
    {
        // invalid parameter!
        
        // BUGBUG would be nice to assert here

        return ERROR_INVALID_PARAMETER;
    }
}

# else 

# define WIN32_FROM_HRESULT(hr)   \
      (( (FAILED(hr)) &&          \
         (HRESULT_FACILITY(hr) == FACILITY_WIN32) \
        )                         \
       ?                          \
       HRESULT_CODE(hr)           \
       : ERROR_INVALID_PARAMETER  \
       )
#endif  // _cplusplus

#endif // !__HTTP_SYS__

//
// Generate an HRESULT from a LK_RETCODE. 
//
// BUGBUG temporary; really we need a fix in the lkhash code.
//

#define HRESULT_FROM_LK_RETCODE( LkRetcode )                        \
            ( ( LkRetcode == LK_SUCCESS ) ? S_OK : E_FAIL )


//
// DNLEN is set to short value (15) that is good enough only for NetBIOS names
// Until there is more suitable constant let's use our own 
//
#define IIS_DNLEN					(256)





#endif  // _IISDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\template\module.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    x.h

Abstract:

    This module contains x

Author:

    Full Name (email)           dd-mmm-yyyy

Revision History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\template\function.h ===
/***************************************************************************++

Routine Description:

    x

Arguments:

    x

Return Value:

    x

--***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\inc\wpcounters.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wpcounters.h

Abstract:

    Module: Definition of counters

Author:

    Emily B. Kruglick (emilyk)    Aug-17-2000

Revision History:

--*/

#ifndef _WPCOUNTERS_H_
#define _WPCOUNTERS_H_


//
// This structure is used by WAS and the WP to communicate
// the global counters.
//
// If you change this structure you must change the associated enum (below) and
// the array found in ctrstshr.cxx.
//
struct IISWPGlobalCounters
{
    ULONGLONG CurrentFileCacheMemoryUsage;
    ULONGLONG MaxFileCacheMemoryUsage;
    DWORD CurrentFilesCached;
    DWORD TotalFilesCached;
    DWORD FileCacheHits;
    DWORD FileCacheMisses;
    DWORD FileCacheFlushes;
    DWORD ActiveFlushedFiles;
    DWORD TotalFlushedFiles;
    DWORD CurrentUrisCached;
    DWORD TotalUrisCached;
    DWORD UriCacheHits;
    DWORD UriCacheMisses;
    DWORD UriCacheFlushes;
    DWORD TotalFlushedUris;
    DWORD CurrentBlobsCached;
    DWORD TotalBlobsCached;
    DWORD BlobCacheHits;
    DWORD BlobCacheMisses;
    DWORD BlobCacheFlushes;
    DWORD TotalFlushedBlobs;
};

//
// Used by the WP to lookup counter definitions in the array below.
//
// If you change this enum you must change the associated struct (above) and
// the array found in ctrstshr.cxx.
//
typedef enum _IIS_WP_GLOBAL_COUNTERS_ENUM
{
    WPGlobalCtrsCurrentFileCacheMemoryUsage = 0,
    WPGlobalCtrsMaxFileCacheMemoryUsage,
    WPGlobalCtrsCurrentFilesCached,
    WPGlobalCtrsTotalFilesCached,
    WPGlobalCtrsFileCacheHits,
    WPGlobalCtrsFileCacheMisses,
    WPGlobalCtrsFileCacheFlushes,
    WPGlobalCtrsActiveFlushedFiles,
    WPGlobalCtrsTotalFlushedFiles,
    WPGlobalCtrsCurrentUrisCached,
    WPGlobalCtrsTotalUrisCached,
    WPGlobalCtrsUriCacheHits,
    WPGlobalCtrsUriCacheMisses,
    WPGlobalCtrsUriCacheFlushes,
    WPGlobalCtrsTotalFlushedUris,
    WPGlobalCtrsCurrentBlobsCached,
    WPGlobalCtrsTotalBlobsCached,
    WPGlobalCtrsBlobCacheHits,
    WPGlobalCtrsBlobCacheMisses,
    WPGlobalCtrsBlobCacheFlushes,
    WPGlobalCtrsTotalFlushedBlobs,

    WPGlobalCtrsMaximum
} IIS_WP_GLOBAL_COUNTERS_ENUM;

//
// Used to transfer site counter information from WP to WAS
//
// If you change this structure you must change the associated enum (below) and
// the array found in ctrstshr.cxx.
//
struct IISWPSiteCounters
{
    DWORD SiteID;
    DWORD FilesSent;
    DWORD FilesReceived;
    DWORD FilesTransferred;
    DWORD CurrentAnonUsers;
    DWORD CurrentNonAnonUsers;
    DWORD AnonUsers;
    DWORD NonAnonUsers;
    DWORD MaxAnonUsers;
    DWORD MaxNonAnonUsers;
    DWORD LogonAttempts;
    DWORD GetReqs;
    DWORD OptionsReqs;
    DWORD PostReqs;
    DWORD HeadReqs;
    DWORD PutReqs;
    DWORD DeleteReqs;
    DWORD TraceReqs;
    DWORD MoveReqs;
    DWORD CopyReqs;
    DWORD MkcolReqs;
    DWORD PropfindReqs;
    DWORD ProppatchReqs;
    DWORD SearchReqs;
    DWORD LockReqs;
    DWORD UnlockReqs;
    DWORD OtherReqs;
    DWORD CurrentCgiReqs;
    DWORD CgiReqs;
    DWORD MaxCgiReqs;
    DWORD CurrentIsapiExtReqs;
    DWORD IsapiExtReqs;
    DWORD MaxIsapiExtReqs;
    DWORD NotFoundErrors;
    DWORD LockedErrors;

};

//
// Used by WP to lookup counter definitions in the array below.
//
// If you change this enum you must change the associated struct (above) and
// the array found in ctrstshr.cxx.
//
typedef enum _IIS_WP_SITE_COUNTERS_ENUM
{
    WPSiteCtrsFilesSent = 0,
    WPSiteCtrsFilesReceived,
    WPSiteCtrsFilesTransferred,
    WPSiteCtrsCurrentAnonUsers,
    WPSiteCtrsCurrentNonAnonUsers,
    WPSiteCtrsAnonUsers,
    WPSiteCtrsNonAnonUsers,
    WPSiteCtrsMaxAnonUsers,
    WPSiteCtrsMaxNonAnonUsers,
    WPSiteCtrsLogonAttempts,
    WPSiteCtrsGetReqs,
    WPSiteCtrsOptionsReqs,
    WPSiteCtrsPostReqs,
    WPSiteCtrsHeadReqs,
    WPSiteCtrsPutReqs,
    WPSiteCtrsDeleteReqs,
    WPSiteCtrsTraceReqs,
    WPSiteCtrsMoveReqs,
    WPSiteCtrsCopyReqs,
    WPSiteCtrsMkcolReqs,
    WPSiteCtrsPropfindReqs,
    WPSiteCtrsProppatchReqs,
    WPSiteCtrsSearchReqs,
    WPSiteCtrsLockReqs,
    WPSiteCtrsUnlockReqs,
    WPSiteCtrsOtherReqs,
    WPSiteCtrsCurrentCgiReqs,
    WPSiteCtrsCgiReqs,
    WPSiteCtrsMaxCgiReqs,
    WPSiteCtrsCurrentIsapiExtReqs,
    WPSiteCtrsIsapiExtReqs,
    WPSiteCtrsMaxIsapiExtReqs,
    WPSiteCtrsNotFoundErrors,
    WPSiteCtrsLockedErrors,

    WPSiteCtrsMaximum
} IIS_WP_SITE_COUNTERS_ENUM;


//
// Arrays are found in ctrshstr.cxx.
// Used by WAS and WP.
//
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

extern HTTP_PROP_DESC aIISWPSiteDescription[];
extern HTTP_PROP_DESC aIISWPGlobalDescription[];
extern HTTP_PROP_DESC aIISULSiteDescription[];
extern HTTP_PROP_DESC aIISULGlobalDescription[];

#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus

#endif // _WPCOUNTERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\template\template.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    x.c

Abstract:

    This module implements x

Author:

    Full Name (email)           dd-mmm-yyyy

Revision History:

--*/


#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\inc\httpapi.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httpapi.h

Abstract:

    This module defines the public HTTP stack (Universal Listener and
    Universal Client) interface.

    Contains everything a user of HTTPAPI.DLL would need.

Author:

    Keith Moore (keithmo)       29-Jul-1998

Revision History:

    Chun Ye (chunye)            27-Sep-2000

    Renamed UL_* to HTTP_*.

--*/


#ifndef _HTTPAPI_H_
#define _HTTPAPI_H_


#include <httpdef.h>


//
// Define our API linkage.
//

#if !defined(HTTPAPI_LINKAGE)
#define HTTPAPI_LINKAGE DECLSPEC_IMPORT
#endif  // !HTTPAPI_LINKAGE


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Initialize/terminate APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpInitialize(
    IN ULONG Reserved   // must be zero
    );

HTTPAPI_LINKAGE
VOID
WINAPI
HttpTerminate(
    VOID
    );


//
// Control channel APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpOpenControlChannel(
    OUT PHANDLE pControlChannelHandle,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    OUT PVOID pControlChannelInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length
    );


//
// Configuration Group APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateConfigGroup(
    IN HANDLE ControlChannelHandle,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroupId
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpDeleteConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpAddUrlToConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl,
    IN HTTP_URL_CONTEXT UrlContext
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpRemoveUrlFromConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpRemoveAllUrlsFromConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    OUT PVOID pConfigGroupInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    );


//
// Application Pool manipulation APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpOpenAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryAppPoolInformation(
    IN HANDLE AppPoolHandle,
    IN HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    OUT PVOID pAppPoolInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetAppPoolInformation(
    IN HANDLE AppPoolHandle,
    IN HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    IN PVOID pAppPoolInformation,
    IN ULONG Length
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpAddTransientUrl(
    IN HANDLE AppPoolHandle,
    IN PCWSTR pFullyQualifiedUrl
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpRemoveTransientUrl(
    IN HANDLE AppPoolHandle,
    IN PCWSTR pFullyQualifiedUrl
    );

//
// HTTP I/O APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpReceiveHttpRequest(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    OUT PHTTP_REQUEST pRequestBuffer,
    IN ULONG RequestBufferLength,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpReceiveEntityBody(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    OUT PVOID pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSendHttpResponse(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN PHTTP_RESPONSE pHttpResponse,
    IN PHTTP_CACHE_POLICY pCachePolicy OPTIONAL,
    OUT PULONG pBytesSent OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSendEntityBody(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN ULONG EntityChunkCount OPTIONAL,
    IN PHTTP_DATA_CHUNK pEntityChunks OPTIONAL,
    OUT PULONG pBytesSent OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpWaitForDisconnect(
    IN HANDLE AppPoolHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );


//
// Response cache manipulation APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFlushResponseCache(
    IN HANDLE AppPoolHandle,
    IN PCWSTR pFullyQualifiedUrl,
    IN ULONG Flags,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );


//
// Demand start notifications.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpWaitForDemandStart(
    IN HANDLE AppPoolHandle,
    IN OUT PVOID pBuffer OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    IN PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

//
// API calls for SSL/Filter helper process
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateFilter(
    OUT PHANDLE pFilterHandle,
    IN PCWSTR pFilterName,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpOpenFilter(
    OUT PHANDLE pFilterHandle,
    IN PCWSTR pFilterName,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterAccept(
    IN HANDLE FilterHandle,
    OUT PHTTP_RAW_CONNECTION_INFO pRawConnectionInfo,
    IN ULONG RawConnectionInfoSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterClose(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterRawRead(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    OUT PVOID pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );
     

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterRawWrite(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN PVOID pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );


HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterAppRead(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    OUT PHTTP_FILTER_BUFFER pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterAppWrite(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN PHTTP_FILTER_BUFFER pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );


//
// Application pool calls for SSL
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpReceiveClientCertificate(
    IN HANDLE AppPoolHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN ULONG Flags,
    OUT PHTTP_SSL_CLIENT_CERT_INFO pSslClientCertInfo,
    IN ULONG SslClientCertInfoSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped
    );


//
// Counter Group APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpGetCounters(
    IN HANDLE ControlChannelHandle,
    IN HTTP_COUNTER_GROUP CounterGroup,
    IN OUT PULONG pCounterBlockSize,
    IN OUT PVOID pCounterBlocks,
    OUT PULONG pNumInstances OPTIONAL
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif // _ULAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\inc\httpdef.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httpdef.h

Abstract:

    This module contains basic HTTP protocol stack type definitions
    shared between the user- and kernel-mode components.

Author:

    Keith Moore (keithmo)       29-Jul-1998

Revision History:

    Paul McDaniel (paulmcd)     15-Mar-1999

        Added new response flags.

    Chun Ye (chunye)            27-Sep-2000

        Renamed UL_* to HTTP_*.

--*/


#ifndef _HTTPDEF_H_
#define _HTTPDEF_H_


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Forward references.
//

typedef struct _HTTP_RESPONSE *PHTTP_RESPONSE;
typedef struct _HTTP_DATA_CHUNK *PHTTP_DATA_CHUNK;
typedef struct _HTTP_SSL_INFO *PHTTP_SSL_INFO;


//
// Generic option flags. These apply to control channels and application
// pools.
//
// HTTP_OPTION_OVERLAPPED - Opens the object for asynchronous I/O.
//
// HTTP_OPTION_CONTROLLER - Opens the object that doesn't read data.
//

#define HTTP_OPTION_OVERLAPPED                      0x00000001
#define HTTP_OPTION_CONTROLLER                      0x00000002
#define HTTP_OPTION_VALID                           0x00000003

//
// Flags for HttpReceiveHttpRequest().
//
// HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY - Specifies that the caller would like
// any available entity body to be copied along with the protocol headers
//

#define HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY         0x00000001
#define HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY        0x00000002
#define HTTP_RECEIVE_REQUEST_FLAG_VALID             0x00000003


//
// Flags for HttpSendHttpResponse() and HttpSendEntityBody().
//
// HTTP_SEND_RESPONSE_FLAG_DISCONNECT - Specifies that the network connection
// should be disconnected immediately after sending the response, overriding
// the HTTP protocol's persistent connection features.
//
// HTTP_SEND_RESPONSE_FLAG_MORE_DATA - Specifies that additional entity body
// data will be sent by the caller.
//
// HTTP_SEND_REPONSE_RAW_HEADER - Specifies that a caller of
// HttpSendEntityBody is intentionally omitting a call to
// HttpSendHttpResponse in order to bypass normal header processing. The
// actual HTTP header will be generated by the application and sent
// as entity body. This flag should be passed on the first call to
// HttpSendEntityBody, and not after.
//

#define HTTP_SEND_RESPONSE_FLAG_DISCONNECT          0x00000001
#define HTTP_SEND_RESPONSE_FLAG_MORE_DATA           0x00000002
#define HTTP_SEND_RESPONSE_FLAG_RAW_HEADER          0x00000004
#define HTTP_SEND_RESPONSE_FLAG_VALID               0x00000007


//
// Flags for HttpFlushResponseCache().
//
// HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE - Flushes the specified URL and all
// heirarchally related sub-URLs from the response cache.
//

#define HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE          0x00000001
#define HTTP_FLUSH_RESPONSE_FLAG_VALID              0x00000001


//
// Flags for HttpReceiveClientCertificate
//
// HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP - Maps the client certificate to a token.
//

#define HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP           0x00000001
#define HTTP_RECEIVE_CLIENT_CERT_FLAG_VALID         0x00000001


//
// Opaque identifiers for various kernel objects.
//

typedef ULONGLONG HTTP_OPAQUE_ID, *PHTTP_OPAQUE_ID;

typedef HTTP_OPAQUE_ID HTTP_REQUEST_ID, *PHTTP_REQUEST_ID;
typedef HTTP_OPAQUE_ID HTTP_CONNECTION_ID, *PHTTP_CONNECTION_ID;
typedef HTTP_OPAQUE_ID HTTP_CONFIG_GROUP_ID, *PHTTP_CONFIG_GROUP_ID;
typedef HTTP_OPAQUE_ID HTTP_RAW_CONNECTION_ID, *PHTTP_RAW_CONNECTION_ID;

#define HTTP_NULL_ID            0
#define HTTP_IS_NULL_ID(pid)    (*(pid) == 0)
#define HTTP_SET_NULL_ID(pid)   (*(pid) = 0)


//
// An opaque context for URLs in an configuration group.
//

typedef ULONGLONG HTTP_URL_CONTEXT;

//
// Network QOS stuff.
//

typedef ULONG HTTP_BANDWIDTH_LIMIT, *PHTTP_BANDWIDTH_LIMIT;
typedef ULONG HTTP_CONNECTION_LIMIT, *PHTTP_CONNECTION_LIMIT;


//
// Distinguished value for bandwidth and connection limits indicating
// "no limit".
//

#define HTTP_LIMIT_INFINITE   (ULONG)-1L


//
// Enabled states. Used for configuration groups and the control channel.
//

typedef enum _HTTP_ENABLED_STATE
{
    HttpEnabledStateActive,
    HttpEnabledStateInactive,

    HttpEnabledStateMaximum

} HTTP_ENABLED_STATE, *PHTTP_ENABLED_STATE;

//
// UTF8 Logging
//

typedef BOOLEAN HTTP_CONTROL_CHANNEL_UTF8_LOGGING, *PHTTP_CONTROL_CHANNEL_UTF8_LOGGING;

//
// Control channel query/set information classes used for the
// HttpQueryControlChannelInformation() and HttpSetControlChannelInformation()
// APIs.
//

typedef enum _HTTP_CONTROL_CHANNEL_INFORMATION_CLASS
{
    //
    // Query/set the master state.
    //
    // pControlChannelInformation points to a HTTP_ENABLED_STATE enum.
    //

    HttpControlChannelStateInformation,

    //
    // Query/set the default network bandwidth limit.
    //
    // pControlChannelInformation points to a HTTP_BANDWIDTH_LIMIT value.
    //

    HttpControlChannelBandwidthInformation,

    //
    // Query/set the default network connections limit.
    //
    // pControlChannelInformation points to a HTTP_CONNECTION_LIMIT value.
    //

    HttpControlChannelConnectionInformation,

    //
    // Set the HTTP response to be sent with either HTTP has been deactivated
    // or in critically bad situations in which it is impossible to even
    // determine which process should receive the request.
    //
    // pControlChannelInformation points to a HTTP_AUTO_RESPONSE structure.
    //
    // Note this cannot be queried.
    //

    HttpControlChannelAutoResponseInformation,

    //
    // Set the handle used to communicate with the Filter/SSL process.
    //
    // Note this cannot be queried.
    //

    HttpControlChannelFilterInformation,

    //
    // Set the global Connection Timeout information
    //
    // pControlChannelInformation points to a HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT structure.
    //

    HttpControlChannelTimeoutInformation,

    //
    // Set the UTF8 Logging property for all sites
    //
    // pControlChannelInformation points to a HTTP_CONTROL_CHANNEL_UTF8_LOGGING structure.
    //
    
    HttpControlChannelUTF8Logging,

    HttpControlChannelMaximumInformation

} HTTP_CONTROL_CHANNEL_INFORMATION_CLASS, *PHTTP_CONTROL_CHANNEL_INFORMATION_CLASS;

//
// Default control channel property values.
//

#define HTTP_CONTROL_CHANNEL_STATE_DEFAULT              HttpEnabledStateInactive
#define HTTP_CONTROL_CHANNEL_MAX_BANDWIDTH_DEFAULT      HTTP_LIMIT_INFINITE
#define HTTP_CONTROL_CHANNEL_MAX_CONNECTIONS_DEFAULT    HTTP_LIMIT_INFINITE
#define HTTP_CONTROL_CHANNEL_AUTO_RESPONSE_DEFAULT      NULL

// 
// Connection Timeout Limits structure for HttpControlChannelTimeoutInformation
//
typedef struct _HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT 
{
    ULONG   ConnectionTimeout;  // Seconds
    ULONG   HeaderWaitTimeout;  // Seconds
    ULONG   MinFileKbSec;       // Bytes/Seconds
} HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT, *PHTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT;


//
// Application pool query/set information classes used for the
// HttpQueryAppPoolInformation() and HttpSetAppPoolInforamtion()
// APIs.
//

typedef enum _HTTP_APP_POOL_INFORMATION_CLASS
{
    //
    // Query/set the maximum number of processes for the specified
    // application group. This value is typically 1 in the normal case
    // and greater than 1 for Web Gardens.
    //
    // pAppPoolInformation points to a ULONG containing the maximum
    // number of processes.
    //
    // NOTE: not used.

    HttpAppPoolDemandStartInformation,

    //
    // Clears the demand start flag. This is part of the demand start
    // handshake protocol used between the user- and kernel-mode
    // components.
    //
    // pAppPoolInformation is unused.
    //
    // NOTE: not used.

    HttpAppPoolDemandStartFlagInformation,

    //
    // Query/set the maximum number of queued new requests on
    // the application pool.
    //
    // pAppPoolInformation points to a LONG containing the maximum
    // number of queued requests.
    //

    HttpAppPoolQueueLengthInformation,

    //
    // Query/set the active state of the application pool.
    //
    // pAppPoolInformation points to a HTTP_ENABLED_STATE enum.
    //

    HttpAppPoolStateInformation,

    HttpAppPoolMaximumInformation

} HTTP_APP_POOL_INFORMATION_CLASS, *PHTTP_APP_POOL_INFORMATION_CLASS;


//
// Configuration group query/set information classes use for the
// HttpQueryConfigGroupInformation() and HttpSetConfigGroupInformation()
// APIs.
//

typedef enum _HTTP_CONFIG_GROUP_INFORMATION_CLASS
{
    //
    // Query/set the current state of the configuration group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_STATE structure
    // that receives the current state.
    //

    HttpConfigGroupStateInformation,

    //
    // Query/set the maximum network bandwidth allowed for the configuration
    // group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_MAX_BANDWIDTH
    // structure specifying the maximum bytes per second allowed for the
    // contiainer.
    //

    HttpConfigGroupBandwidthInformation,

    //
    // Query/set the maximum network connections allowed for the
    // configuration group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_MAX_CONNECTIONS
    // structure containing the maximum number of network connections
    // allowed for the container.
    //

    HttpConfigGroupConnectionInformation,

    //
    // Set the response to be sent when the configuration group is
    // in a nonresponsive state.
    //
    // pConfigGroupInformation points to a HTTP_AUTO_RESPONSE
    // structure.
    //
    // Note this cannot be queried.
    //

    HttpConfigGroupAutoResponseInformation,

    //
    // Set the application pool associated with the configuration
    // group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_APP_POOL
    // structure containing the HANDLE of the application pool to
    // associate.
    //

    HttpConfigGroupAppPoolInformation,

    //
    // Set the cache size associated with the configuration
    // group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_APP_POOL
    // structure containing the HANDLE of the application pool to
    // associate.
    //

    HttpConfigGroupCacheSizeInformation,

    //
    // Set the security descriptor associated with the configuration
    // group. This security descriptor is used to control the
    // creation of transient URL registrations beneath the
    // configuration group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_SECURITY
    // structure.
    //
    // Note this cannot be queried.
    //

    HttpConfigGroupSecurityInformation,

    //
    // Set the logging related config settings.
    // This allows WAS to supply logging config as a config group
    // setting group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_LOGGING
    // structure.
    //
    // Note this cannot be queried.
    //

    HttpConfigGroupLogInformation,

    //
    // Set this information only on the root config object for the
    // site.  
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_SITE
    // structure.
    //

    HttpConfigGroupSiteInformation,

    //
    // Set this information only on the root config object for the
    // site.
    //
    // pConfigGroupInformation points to a DWORD that contains 
    // the ConnectionTimeout value (in seconds)
    //

    HttpConfigGroupConnectionTimeoutInformation,

#if DBG

    //
    // Private for dev testing only.
    //

    HttpConfigGroupGetUrlInfo,
    HttpConfigGroupFreeUrlInfo,
    HttpConfigGroupUrlStaleTest,

    //
    // End private dev testing only.
    //

#endif

    HttpConfigGroupMaximumInformation

} HTTP_CONFIG_GROUP_INFORMATION_CLASS, *PHTTP_CONFIG_GROUP_INFORMATION_CLASS;


//
// Generic configuration group property flags. Each structure defining a
// property value must contain an element of this type.
//

typedef struct _HTTP_PROPERTY_FLAGS
{
    ULONG_PTR Present:1;

} HTTP_PROPERTY_FLAGS, *PHTTP_PROPERTY_FLAGS;


//
// Individual property values.
//

typedef struct _HTTP_CONFIG_GROUP_STATE
{
    HTTP_PROPERTY_FLAGS Flags;
    HTTP_ENABLED_STATE State;

} HTTP_CONFIG_GROUP_STATE, *PHTTP_CONFIG_GROUP_STATE;


typedef struct _HTTP_CONFIG_GROUP_MAX_BANDWIDTH
{
    HTTP_PROPERTY_FLAGS Flags;
    HTTP_BANDWIDTH_LIMIT MaxBandwidth;

} HTTP_CONFIG_GROUP_MAX_BANDWIDTH, *PHTTP_CONFIG_GROUP_MAX_BANDWIDTH;


typedef struct _HTTP_CONFIG_GROUP_MAX_CONNECTIONS
{
    HTTP_PROPERTY_FLAGS Flags;
    HTTP_CONNECTION_LIMIT MaxConnections;

} HTTP_CONFIG_GROUP_MAX_CONNECTIONS, *PHTTP_CONFIG_GROUP_MAX_CONNECTIONS;


typedef struct _HTTP_AUTO_RESPONSE
{
    HTTP_PROPERTY_FLAGS Flags;
    PHTTP_RESPONSE pResponse;
    ULONG EntityChunkCount;
    PHTTP_DATA_CHUNK pEntityChunks;

} HTTP_AUTO_RESPONSE, *PHTTP_AUTO_RESPONSE;


typedef struct _HTTP_CONTROL_CHANNEL_FILTER
{
    HTTP_PROPERTY_FLAGS Flags;
    HANDLE FilterHandle;
    BOOLEAN FilterOnlySsl;

} HTTP_CONTROL_CHANNEL_FILTER, *PHTTP_CONTROL_CHANNEL_FILTER;


typedef struct _HTTP_CONFIG_GROUP_APP_POOL
{
    HTTP_PROPERTY_FLAGS Flags;
    HANDLE AppPoolHandle;

} HTTP_CONFIG_GROUP_APP_POOL, *PHTTP_CONFIG_GROUP_APP_POOL;


typedef struct _HTTP_CONFIG_GROUP_CACHE_SIZE
{
    HTTP_PROPERTY_FLAGS Flags;
    ULONG CacheSize;

} HTTP_CONFIG_GROUP_CACHE_SIZE, *PHTTP_CONFIG_GROUP_CACHE_SIZE;


typedef struct _HTTP_CONFIG_GROUP_SECURITY
{
    HTTP_PROPERTY_FLAGS Flags;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;

} HTTP_CONFIG_GROUP_SECURITY, *PHTTP_CONFIG_GROUP_SECURITY;


typedef enum _HTTP_LOGGING_TYPE
{
    HttpLoggingTypeW3C,
    HttpLoggingTypeIIS,
    HttpLoggingTypeNCSA,

    HttpLoggingTypeMaximum

} HTTP_LOGGING_TYPE, *PHTTP_LOGGING_TYPE;


typedef enum _HTTP_LOGGING_PERIOD
{
    HttpLoggingPeriodMaxSize = 0,
    HttpLoggingPeriodDaily   = 1,
    HttpLoggingPeriodWeekly  = 2,
    HttpLoggingPeriodMonthly = 3,
    HttpLoggingPeriodHourly  = 4,

    HttpLoggingPeriodMaximum

} HTTP_LOGGING_PERIOD, *PHTTP_LOGGING_PERIOD;


typedef struct _HTTP_CONFIG_GROUP_LOGGING
{
    //
    // To indicate if this property exist or not
    // in the config group
    //

    HTTP_PROPERTY_FLAGS Flags;

    //
    // This is field?s counterpart in the metabase is
    // LogType
    //

    BOOLEAN LoggingEnabled;

    //
    // Indicates the Logging Format
    //

    HTTP_LOGGING_TYPE LogFormat;

    //
    // Indicates the exact directory where the log file
    // will be written to for a site.
    //

    UNICODE_STRING LogFileDir;

    //
    // HTTP does not keep the site name information.
    // WAS should pass down this. E.g. "W3SVC1"
    //

    UNICODE_STRING SiteName;

    //
    // Log Period in terms of
    // 0 = MAX SIZE, 1 = DAILY, 2 = WEEKLY,
    // 3 = MONTHLY,  4 = HOURLY
    //

    ULONG LogPeriod;

    //
    // Indicates the max size,in bytes,after which the
    // log file should be rotated. A value of -1
    // (HTTP_LIMIT_INFINITE) indicates unlimited size.
    //

    ULONG LogFileTruncateSize;

    //
    // A bit mask indicating which fields to log when
    // LogFormat is set to W3C Extended
    //

    ULONG LogExtFileFlags;

    //
    // If this has been set then we recycle log files
    // based on the local time for this site. Default
    // should be FALSE.
    //
    
    BOOLEAN LocaltimeRollover;

} HTTP_CONFIG_GROUP_LOGGING, *PHTTP_CONFIG_GROUP_LOGGING;


// 
// HTTP_CONFIG_GROUP_SITE
// 

typedef struct _HTTP_CONFIG_GROUP_SITE
{
	ULONG   SiteId;
	
} HTTP_CONFIG_GROUP_SITE, *PHTTP_CONFIG_GROUP_SITE;

//
// This structure holds all the necessary Logging Info,
// And pushed down by User (Worker Process) with
// Sendresponse or SendEntityBody Ioctls.
//

typedef struct _HTTP_LOG_FIELDS_DATA
{
    USHORT UserNameLength;
    USHORT UriStemLength;
    USHORT ClientIpLength;
    USHORT ServerNameLength;
    USHORT ServiceNameLength;
    USHORT ServerIpLength;
    USHORT MethodLength;
    USHORT UriQueryLength;
    USHORT HostLength;
    USHORT UserAgentLength;
    USHORT CookieLength;
    USHORT ReferrerLength;

    PWSTR UserName;
    PWSTR UriStem;
    PSTR ClientIp;
    PSTR ServerName;
    PSTR ServiceName;
    PSTR ServerIp;
    PSTR Method;
    PSTR UriQuery;
    PSTR Host;
    PSTR UserAgent;
    PSTR Cookie;
    PSTR Referrer;

    ULONG ServerPort;

    ULONG ProtocolStatus;
    ULONG Win32Status;

} HTTP_LOG_FIELDS_DATA, *PHTTP_LOG_FIELDS_DATA;


#if DBG

//
// Private for dev testing only.
//

typedef struct _HTTP_CONFIG_GROUP_DBG_URL_INFO
{
    UNICODE_STRING Url;                     // IN
    HTTP_ENABLED_STATE CurrentState;        // OUT
    HTTP_BANDWIDTH_LIMIT MaxBandwidth;      // OUT
    HTTP_CONNECTION_LIMIT MaxConnections;   // OUT
    HTTP_URL_CONTEXT UrlContext;            // OUT
    PVOID pReserved;                        // OUT
    BOOLEAN Stale;                          // OUT

} HTTP_CONFIG_GROUP_DBG_URL_INFO, *PHTTP_CONFIG_GROUP_DBG_URL_INFO;

//
// End private dev testing only.
//

#endif


//
// This structure defines a file byte range.
//
// If the StartingOffset field is HTTP_BYTE_RANGE_TO_EOF (see below) then
// the last Length bytes of the file are sent.
//
// If the Length field is HTTP_BYTE_RANGE_TO_EOF then the remainder of the
// file (everything after StartingOffset) is sent.
//

typedef struct _HTTP_BYTE_RANGE
{
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER Length;

} HTTP_BYTE_RANGE, *PHTTP_BYTE_RANGE;

#define HTTP_BYTE_RANGE_TO_EOF ((ULONGLONG)-1)


//
// The type for version numbers.
//

typedef struct _HTTP_VERSION
{
    USHORT MajorVersion;
    USHORT MinorVersion;

} HTTP_VERSION, *PHTTP_VERSION;


//
// Some useful macros for version manipulation.
//

#define HTTP_VERSION_UNKNOWN    { 0, 0 }
#define HTTP_VERSION_0_9        { 0, 9 }
#define HTTP_VERSION_1_0        { 1, 0 }
#define HTTP_VERSION_1_1        { 1, 1 }

#define HTTP_SET_VERSION(version, major, minor)             \
{                                                           \
    (version).MajorVersion = (major);                       \
    (version).MinorVersion = (minor);                       \
}

#define HTTP_EQUAL_VERSION(version, major, minor)           \
    ((version).MajorVersion == (major) &&                   \
     (version).MinorVersion == (minor))

#define HTTP_GREATER_VERSION(version, major, minor)         \
    ((version).MajorVersion > (major) ||                    \
     ((version).MajorVersion == (major) &&                  \
      (version).MinorVersion > (minor)))

#define HTTP_LESS_VERSION(version, major, minor)            \
    ((version).MajorVersion < (major) ||                    \
     ((version).MajorVersion == (major) &&                  \
      (version).MinorVersion < (minor)))

#define HTTP_NOT_EQUAL_VERSION(version, major, minor)       \
    (!HTTP_EQUAL_VERSION(version, major, minor))

#define HTTP_GREATER_EQUAL_VERSION(version, major, minor)   \
    (!HTTP_LESS_VERSION(version, major, minor))

#define HTTP_LESS_EQUAL_VERSION(version, major, minor)      \
    (!HTTP_GREATER_VERSION(version, major, minor))


//
// The enum type for HTTP verbs.
//

typedef enum _HTTP_VERB
{
    HttpVerbUnparsed,
    HttpVerbUnknown,
    HttpVerbInvalid,
    HttpVerbOPTIONS,
    HttpVerbGET,
    HttpVerbHEAD,
    HttpVerbPOST,
    HttpVerbPUT,
    HttpVerbDELETE,
    HttpVerbTRACE,
    HttpVerbCONNECT,
    HttpVerbTRACK,              // used by wolf-pack for a non-logged trace
    HttpVerbMOVE,
    HttpVerbCOPY,
    HttpVerbPROPFIND,
    HttpVerbPROPPATCH,
    HttpVerbMKCOL,
    HttpVerbLOCK,
    HttpVerbUNLOCK,
    HttpVerbSEARCH,

    HttpVerbMaximum

} HTTP_VERB, *PHTTP_VERB;


//
// Symbols for all HTTP/1.1 headers and other tokens.  Notice request +
// response values overlap.  Make sure you know which type of header array
// you are indexing.
//
// These values are used as offsets into arrays and as token values in
// HTTP_KNOWN_HEADER.
//

typedef enum _HTTP_HEADER_ID
{

    HttpHeaderCacheControl          = 0,    // general-header [section 4.5]
    HttpHeaderConnection            ,       // general-header [section 4.5]
    HttpHeaderDate                  ,       // general-header [section 4.5]
    HttpHeaderKeepAlive             ,       // general-header [not in rfc]
    HttpHeaderPragma                ,       // general-header [section 4.5]
    HttpHeaderTrailer               ,       // general-header [section 4.5]
    HttpHeaderTransferEncoding      ,       // general-header [section 4.5]
    HttpHeaderUpgrade               ,       // general-header [section 4.5]
    HttpHeaderVia                   ,       // general-header [section 4.5]
    HttpHeaderWarning               = 9,    // general-header [section 4.5]

    HttpHeaderAllow                 = 10,   // entity-header  [section 7.1]
    HttpHeaderContentLength         ,       // entity-header  [section 7.1]
    HttpHeaderContentType           ,       // entity-header  [section 7.1]
    HttpHeaderContentEncoding       ,       // entity-header  [section 7.1]
    HttpHeaderContentLanguage       ,       // entity-header  [section 7.1]
    HttpHeaderContentLocation       ,       // entity-header  [section 7.1]
    HttpHeaderContentMd5            ,       // entity-header  [section 7.1]
    HttpHeaderContentRange          ,       // entity-header  [section 7.1]
    HttpHeaderExpires               ,       // entity-header  [section 7.1]
    HttpHeaderLastModified          = 19,   // entity-header  [section 7.1]

    HttpHeaderAccept                = 20,   // request-header [section 5.3]
    HttpHeaderAcceptCharset         ,       // request-header [section 5.3]
    HttpHeaderAcceptEncoding        ,       // request-header [section 5.3]
    HttpHeaderAcceptLanguage        ,       // request-header [section 5.3]
    HttpHeaderAuthorization         ,       // request-header [section 5.3]
    HttpHeaderCookie                ,       // request-header [not in rfc]  // 25 
    HttpHeaderExpect                ,       // request-header [section 5.3]
    HttpHeaderFrom                  ,       // request-header [section 5.3]
    HttpHeaderHost                  ,       // request-header [section 5.3]
    HttpHeaderIfMatch               ,       // request-header [section 5.3]
    HttpHeaderIfModifiedSince       ,       // request-header [section 5.3] // 30
    HttpHeaderIfNoneMatch           ,       // request-header [section 5.3]
    HttpHeaderIfRange               ,       // request-header [section 5.3]
    HttpHeaderIfUnmodifiedSince     ,       // request-header [section 5.3]
    HttpHeaderMaxForwards           ,       // request-header [section 5.3]
    HttpHeaderProxyAuthorization    ,       // request-header [section 5.3] // 35
    HttpHeaderReferer               ,       // request-header [section 5.3]
    HttpHeaderRange                 ,       // request-header [section 5.3]
    HttpHeaderTe                    ,       // request-header [section 5.3]
    HttpHeaderTranslate             ,       // request-header [webDAV, not in rfc 2518]
    HttpHeaderUserAgent             = 40,   // request-header [section 5.3] // 40

    HttpHeaderRequestMaximum        = 41,

    HttpHeaderAcceptRanges          = 20,   // response-header [section 6.2]
    HttpHeaderAge                   ,       // response-header [section 6.2]
    HttpHeaderEtag                  ,       // response-header [section 6.2]
    HttpHeaderLocation              ,       // response-header [section 6.2]
    HttpHeaderProxyAuthenticate     ,       // response-header [section 6.2]
    HttpHeaderRetryAfter            ,       // response-header [section 6.2]
    HttpHeaderServer                ,       // response-header [section 6.2]
    HttpHeaderSetCookie             ,       // response-header [not in rfc]
    HttpHeaderVary                  ,       // response-header [section 6.2]
    HttpHeaderWwwAuthenticate       = 29,   // response-header [section 6.2]

    HttpHeaderResponseMaximum       = 30,

    HttpHeaderMaximum               = 41
    
} HTTP_HEADER_ID, *PHTTP_HEADER_ID;


//
// Structure defining format of known header.
//

typedef struct _HTTP_KNOWN_HEADER
{
    //
    // raw value
    //

    USHORT RawValueLength;              // in bytes not including the NULL
    PSTR pRawValue;

} HTTP_KNOWN_HEADER, *PHTTP_KNOWN_HEADER;


//
// Structure defining format of unknown header.
//

typedef struct _HTTP_UNKNOWN_HEADER
{
    USHORT NameLength;                  // in bytes not including the NULL
    USHORT RawValueLength;              // in bytes not including the NULL

    //
    // The header name (minus the ':' character)
    //

    PSTR pName;

    //
    // The header value
    //

    PSTR pRawValue;

} HTTP_UNKNOWN_HEADER, *PHTTP_UNKNOWN_HEADER;


//
// This enum defines a data source for a particular chunk of data.
//

typedef enum _HTTP_DATA_CHUNK_TYPE
{
    HttpDataChunkFromMemory,
    HttpDataChunkFromFileName,
    HttpDataChunkFromFileHandle,

    HttpDataChunkMaximum

} HTTP_DATA_CHUNK_TYPE, *PHTTP_DATA_CHUNK_TYPE;


//
// This structure describes an individual data chunk.
//

typedef struct _HTTP_DATA_CHUNK
{
    //
    // The type of this data chunk.
    //

    HTTP_DATA_CHUNK_TYPE DataChunkType;

    //
    // The data chunk structures, one per supported data chunk type.
    //

    union
    {
        //
        // From memory data chunk.
        //

        struct
        {
            PVOID pBuffer;
            ULONG BufferLength;

        } FromMemory;

        //
        // From filename data chunk.
        //

        struct
        {
            HTTP_BYTE_RANGE ByteRange;

            USHORT FileNameLength;      // in bytes not including the NULL
            PCWSTR pFileName;

        } FromFileName;

        //
        // From file handle data chunk.
        //

        struct
        {
            HTTP_BYTE_RANGE ByteRange;
            HANDLE FileHandle;

        } FromFileHandle;

    };

} HTTP_DATA_CHUNK, *PHTTP_DATA_CHUNK;


//
// The enum type for HTTP request reasons.
//

typedef enum _HTTP_REQUEST_REASON
{
    HttpReasonResponseCacheMiss,
    HttpReasonFileHandleCacheMiss,
    HttpReasonCachePolicy,
    HttpReasonCacheSecurity,
    HttpReasonClientDisconnect,

    HttpReasonMaximum

} HTTP_REQUEST_REASON, *PHTTP_REQUEST_REASON;


//
// Structure defining format of request headers.
//

typedef struct _HTTP_REQUEST_HEADERS
{
    //
    // The array of unknown HTTP headers and the number of
    // entries in the array.
    //

    ULONG UnknownHeaderCount;

    PHTTP_UNKNOWN_HEADER pUnknownHeaders;

    //
    // Known headers.
    //

    HTTP_KNOWN_HEADER pKnownHeaders[HttpHeaderRequestMaximum];

} HTTP_REQUEST_HEADERS, *PHTTP_REQUEST_HEADERS;


//
// Structure defining format of request headers.
//

typedef struct _HTTP_RESPONSE_HEADERS
{
    //
    // The array of unknown HTTP headers and the number of
    // entries in the array.
    //

    ULONG UnknownHeaderCount;

    PHTTP_UNKNOWN_HEADER pUnknownHeaders;

    //
    // Known headers.
    //

    HTTP_KNOWN_HEADER pKnownHeaders[HttpHeaderResponseMaximum];

} HTTP_RESPONSE_HEADERS, *PHTTP_RESPONSE_HEADERS;


//
// Network address definitions.
//

#define HTTP_NETWORK_ADDRESS_TYPE_IPV4      0

typedef struct _HTTP_NETWORK_ADDRESS_IPV4
{
    ULONG IpAddress;
    USHORT Port;
    USHORT Spare;   // for alignment

} HTTP_NETWORK_ADDRESS_IPV4, *PHTTP_NETWORK_ADDRESS_IPV4;


//
// Structure defining format of transport address.
//

typedef struct _HTTP_TRANSPORT_ADDRESS
{
    USHORT RemoteAddressLength; // sizeof(HTTP_NETWORK_ADDRESS_xxx)
    USHORT RemoteAddressType;   // HTTP_NETWORK_ADDRESS_TYPE_xxx

    USHORT LocalAddressLength;  // sizeof(HTTP_NETWORK_ADDRESS_xxx)
    USHORT LocalAddressType;    // HTTP_NETWORK_ADDRESS_TYPE_xxx

    PVOID pRemoteAddress;       // points to a HTTP_NETWORK_ADDRESS_xxx
    PVOID pLocalAddress;        // points to a HTTP_NETWORK_ADDRESS_xxx

} HTTP_TRANSPORT_ADDRESS, *PHTTP_TRANSPORT_ADDRESS;


//
// Structure defining format of cooked URL.
//

typedef struct _HTTP_COOKED_URL
{
    //
    // Pointers overlap and point into pFullUrl.  NULL if not present.
    //

    USHORT FullUrlLength;       // in bytes not including the NULL
    USHORT HostLength;          // in bytes not including the NULL
    USHORT AbsPathLength;       // in bytes not including the NULL
    USHORT QueryStringLength;   // in bytes not including the NULL

    PWSTR pFullUrl;             // points to "http://...."
    PWSTR pHost;                // points to the first char in the hostname
    PWSTR pAbsPath;             // Points to the 3rd '/' char
    PWSTR pQueryString;         // Points to the 1st '?' char

} HTTP_COOKED_URL, *PHTTP_COOKED_URL;


//
// The structure of an HTTP request.
//

typedef struct _HTTP_REQUEST
{
    //
    // An opaque request identifier. These values are used by the driver
    // to correlate outgoing responses with incoming requests.
    //

    HTTP_CONNECTION_ID ConnectionId;
    HTTP_REQUEST_ID RequestId;

    //
    // The context associated with the URL prefix.
    //

    HTTP_URL_CONTEXT UrlContext;

    //
    // The HTTP version number.
    //

    HTTP_VERSION Version;

    //
    // The request verb.
    //

    HTTP_VERB Verb;

    //
    // An indication of the reason the request was issued to/from user-mode.
    //

    HTTP_REQUEST_REASON Reason;

    //
    // The pointer and length of the verb string if the Verb field is
    // HttpVerbUnknown.
    //

    //
    // The pointer and length of the raw URL.
    //

    USHORT UnknownVerbLength;           // in bytes not including the NULL
    USHORT RawUrlLength;                // in bytes not including the NULL

    PSTR pUnknownVerb;
    PSTR pRawUrl;

    //
    // The pointers and length of the canonicalized URL and parts.
    //

    HTTP_COOKED_URL CookedUrl;

    //
    // Transport addresses for the connection.
    //

    HTTP_TRANSPORT_ADDRESS Address;

    //
    // The request headers.
    //

    HTTP_REQUEST_HEADERS Headers;

    //
    // The total number of bytes received from network for this request.
    //

    ULONGLONG BytesReceived;

    //
    // 1 if there is more entity body to be read or written for this request.
    // 0 if there is no entity body or all of the entity body was copied into
    // pEntityChunks.
    //

    ULONG MoreEntityBodyExists:1;

    //
    // The pointer and length of any copied entity body.  Entity body is only
    // copied if HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY is passed to receive.
    //

    ULONG EntityChunkCount;
    PHTTP_DATA_CHUNK pEntityChunks;

    //
    // SSL connection information.
    //

    HTTP_RAW_CONNECTION_ID RawConnectionId;
    PHTTP_SSL_INFO pSslInfo;

} HTTP_REQUEST, *PHTTP_REQUEST;


//
// This structure describes an HTTP response.
//

typedef struct _HTTP_RESPONSE
{
    //
    // Response flags (see HTTP_RESPONSE_FLAG_* definitions below).
    //

    USHORT Flags;

    //
    // The raw HTTP version number.  Used by client side API only.
    //

    HTTP_VERSION Version;

    //
    // The HTTP status code (e.g. 200).
    //

    USHORT StatusCode;

    //
    // The HTTP reason (e.g. "OK") .  This is a unicode string for convenience,
    // but MUST not contain non-ascii characters.
    //

    ULONG ReasonLength;                 // in bytes not including the NULL
    PSTR pReason;

    //
    // The response headers.
    //

    HTTP_RESPONSE_HEADERS Headers;

    //
    // 1 if there is more entity body to be read or written for this response.
    // 0 if there is no entity body or all of the entity body was copied into
    // pEntityChunks.
    //

    ULONG MoreEntityBodyExists:1;

    //
    // The pointer and length of any entity body.
    //

    ULONG EntityChunkCount;
    PHTTP_DATA_CHUNK pEntityChunks;

} HTTP_RESPONSE, *PHTTP_RESPONSE;


//
// Flags for HTTP_RESPONSE_FLAGS.
//
// HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH - The content length is
// calculated by summing the length of all entity body data chunks.
//
// HTTP_RESPONSE_FLAG_CALC_ETAG - An entity tag is calculated for
// the reponse based on the memory and file data chunks representing the
// entity data.
//
// HTTP_RESPONSE_FLAG_CALC_LAST_MODIFIED - The last modified time is
// calculated by examining the file data chunks within the entity body.
//

#define HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH      0x00000001
#define HTTP_RESPONSE_FLAG_CALC_ETAG                0x00000002
#define HTTP_RESPONSE_FLAG_CALC_LAST_MODIFIED       0x00000004
#define HTTP_RESPONSE_FLAG_VALID                    0x00000007


//
// Cache control.
//

//
// This enum defines the available cache policies.
//

typedef enum _HTTP_CACHE_POLICY_TYPE
{
    HttpCachePolicyNocache,
    HttpCachePolicyUserInvalidates,
    HttpCachePolicyTimeToLive,

    HttpCachePolicyMaximum

} HTTP_CACHE_POLICY_TYPE, *PHTTP_CACHE_POLICY_TYPE;


//
//  o Only cache GET's + HEAD's.
//  o Don't cache if VARY is present.
//

typedef struct _HTTP_CACHE_POLICY
{
    HTTP_CACHE_POLICY_TYPE Policy;
    ULONG SecondsToLive;

} HTTP_CACHE_POLICY, *PHTTP_CACHE_POLICY;


//
// Filters and SSL.
//

//
// Data associated with raw transport connections.
//

typedef struct _HTTP_RAW_CONNECTION_INFO
{
    //
    // Connection ID.
    //

    HTTP_RAW_CONNECTION_ID ConnectionId;

    //
    // Transport address info.
    //

    HTTP_TRANSPORT_ADDRESS Address;

    //
    // Used by client APIs only
    //

    ULONG ServerNameLength;     // Length of server name (in bytes)
    PWSTR pServerName;          // Name of remote server

    //
    // Initial data.
    //

    ULONG InitialDataSize;      // size of initial data
    PVOID pInitialData;         // pointer to initial data

} HTTP_RAW_CONNECTION_INFO, *PHTTP_RAW_CONNECTION_INFO;


//
// Client certificate information.
//

typedef struct _HTTP_SSL_CLIENT_CERT_INFO
{
    ULONG CertFlags;
    ULONG CertEncodedSize;
    PUCHAR pCertEncoded;
    HANDLE Token;
    ULONG CertDeniedByMapper:1;

} HTTP_SSL_CLIENT_CERT_INFO, *PHTTP_SSL_CLIENT_CERT_INFO;


//
// Data computed during SSL handshake.
//

typedef struct _HTTP_SSL_INFO
{
    USHORT ServerCertKeySize;
    USHORT ConnectionKeySize;
    ULONG ServerCertIssuerSize;
    ULONG ServerCertSubjectSize;

    PSTR pServerCertIssuer;
    PSTR pServerCertSubject;

    PHTTP_SSL_CLIENT_CERT_INFO pClientCertInfo;

} HTTP_SSL_INFO, *PHTTP_SSL_INFO;


//
// For transfers between filters and upper levels.
//

typedef enum _HTTP_FILTER_BUFFER_TYPE
{
    HttpFilterBufferHttpStream,             // both directions
    HttpFilterBufferSslInitInfo,            // filter -> app
    HttpFilterBufferSslClientCert,          // filter -> app
    HttpFilterBufferSslClientCertAndMap,    // filter -> app
    HttpFilterBufferSslRenegotiate,         // app -> filter
    HttpFilterBufferSslRenegotiateAndMap,   // app -> filter
    HttpFilterBufferCloseConnection,        // app -> filter

    HttpFilterBufferMaximum

} HTTP_FILTER_BUFFER_TYPE;


//
// The buffer transferred between filters and upper levels.
//

typedef struct _HTTP_FILTER_BUFFER
{
    HTTP_FILTER_BUFFER_TYPE BufferType;

    ULONG BufferSize;
    PUCHAR pBuffer;

    ULONGLONG Reserved;

} HTTP_FILTER_BUFFER, *PHTTP_FILTER_BUFFER;


//
// Counter Group.
//

//
// Counter property description.
//

typedef struct _HTTP_PROP_DESC
{
    ULONG Size;
    ULONG Offset;
    BOOLEAN WPZeros;

} HTTP_PROP_DESC, *PHTTP_PROP_DESC;


//
// This enum defines the available couter groups.
//

typedef enum _HTTP_COUNTER_GROUP
{
    HttpCounterGroupSite,
    HttpCounterGroupGlobal,

    HttpCounterGroupMaximum

} HTTP_COUNTER_GROUP;


//
// This enum defines the type of global couters.
//

typedef enum _HTTP_GLOBAL_COUNTER_ID
{
    HttpGlobalCounterCurrentUrisCached,
    HttpGlobalCounterTotalUrisCached,
    HttpGlobalCounterUriCacheHits,
    HttpGlobalCounterUriCacheMisses,
    HttpGlobalCounterUriCacheFlushes,
    HttpGlobalCounterTotalFlushedUris,

    HttpGlobalCounterMaximum

} HTTP_GLOBAL_COUNTER_ID;


//
// Global couters.
//

typedef struct _HTTP_GLOBAL_COUNTERS
{
    ULONG CurrentUrisCached;
    ULONG TotalUrisCached;
    ULONG UriCacheHits;
    ULONG UriCacheMisses;
    ULONG UriCacheFlushes;
    ULONG TotalFlushedUris;

} HTTP_GLOBAL_COUNTERS, *PHTTP_GLOBAL_COUNTERS;


//
// This enum defines the type of site couters.
//

typedef enum _HTTP_SITE_COUNTER_ID
{
    HttpSiteCounterBytesSent,
    HttpSiteCounterBytesReceived,
    HttpSiteCounterBytesTransfered,
    HttpSiteCounterCurrentConns,
    HttpSiteCounterMaxConnections,
    HttpSiteCounterConnAttempts,
    HttpSiteCounterGetReqs,
    HttpSiteCounterHeadReqs,
    HttpSiteCounterAllReqs,
    HttpSiteCounterMeasuredIoBandwidthUsage,
    HttpSiteCounterCurrentBlockedBandwidthBytes,
    HttpSiteCounterTotalBlockedBandwidthBytes,

    HttpSiteCounterMaximum

} HTTP_SITE_COUNTER_ID;


//
// Site couters.
//

typedef struct _HTTP_SITE_COUNTERS
{
    ULONG SiteId;
    ULONGLONG BytesSent;
    ULONGLONG BytesReceived;
    ULONGLONG BytesTransfered;
    ULONG CurrentConns;
    ULONG MaxConnections;
    ULONG ConnAttempts;
    ULONG GetReqs;
    ULONG HeadReqs;
    ULONG AllReqs;
    ULONG MeasuredIoBandwidthUsage;
    ULONG CurrentBlockedBandwidthBytes;
    ULONG TotalBlockedBandwidthBytes;

} HTTP_SITE_COUNTERS, *PHTTP_SITE_COUNTERS;


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _HTTPDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\inc\http.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    http.h

Abstract:

    Contains structures and declarations shared between
    HTTP.SYS and HTTPAPI.DLL. Users of the httpapi should include
    httpapi.h and not this file.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

    Chun Ye (chunye)            27-Sep-2000

    Renamed UL_* to HTTP_*.

--*/


#ifndef _HTTP_H_
#define _HTTP_H_


#include <httpdef.h>


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Names of the object directory, devices, driver, and service.
//

#define HTTP_DIRECTORY_NAME         L"\\Device\\Http"
#define HTTP_CONTROL_DEVICE_NAME    L"\\Device\\Http\\Control"
#define HTTP_APP_POOL_DEVICE_NAME   L"\\Device\\Http\\AppPool"
#define HTTP_FILTER_DEVICE_NAME     L"\\Device\\Http\\Filter"
#define HTTP_DRIVER_NAME            L"HTTP.SYS"
#define HTTP_SERVICE_NAME           L"HTTP"

//
// Names of the filters.
//
#define HTTP_SSL_SERVER_FILTER_CHANNEL_NAME L"SSLFilterChannel"
#define HTTP_SSL_SERVER_FILTER_CHANNEL_NAME_LENGTH        \
        (sizeof(HTTP_SSL_SERVER_FILTER_CHANNEL_NAME)-sizeof(WCHAR))

#define HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME L"SSLClientFilterChannel"
#define HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME_LENGTH  \
        (sizeof(HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME)-sizeof(WCHAR))




//
// The current interface version number. This version number must be
// updated after any significant changes to the interface (especially
// structure changes).
//

#define HTTP_INTERFACE_VERSION_MAJOR  0x0001
#define HTTP_INTERFACE_VERSION_MINOR  0x0000


//
// The name of the EA (Extended Attribute) passed to NtCreateFile(). This
// allows us to pass version information at the time the driver is opened,
// allowing UL.SYS to immediately fail open requests with invalid version
// numbers.
//
// N.B. The EA name (including the terminator) must be a multiple of eight
// to ensure natural alignment of the HTTP_OPEN_PACKET structure used as
// the EA value.
//

//                                       7654321076543210
#define HTTP_OPEN_PACKET_NAME           "UlOpenPacket000"
#define HTTP_OPEN_PACKET_NAME_LENGTH    (sizeof(HTTP_OPEN_PACKET_NAME) - 1)
C_ASSERT( ((HTTP_OPEN_PACKET_NAME_LENGTH + 1) & 7) == 0 );


//
// The following structure is used as the value for the EA named above.
//

typedef struct HTTP_OPEN_PACKET
{
    USHORT MajorVersion;
    USHORT MinorVersion;

} HTTP_OPEN_PACKET, *PHTTP_OPEN_PACKET;


//
// Structures for IOCTL_HTTP_QUERY_CONTROL_CHANNEL and
// IOCTL_HTTP_SET_CONTROL_CHANNEL.
//

typedef struct _HTTP_CONTROL_CHANNEL_INFO
{
    HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass;

} HTTP_CONTROL_CHANNEL_INFO, *PHTTP_CONTROL_CHANNEL_INFO;


//
// Structures for IOCTL_HTTP_CREATE_CONFIG_GROUP,
// IOCTL_HTTP_DELETE_CONFIG_GROUP, IOCTL_HTTP_QUERY_CONFIG_GROUP,
// and IOCTL_HTTP_SET_CONFIG_GROUP.
//

typedef struct _HTTP_CONFIG_GROUP_INFO
{
    HTTP_CONFIG_GROUP_ID ConfigGroupId;
    HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass;

} HTTP_CONFIG_GROUP_INFO, *PHTTP_CONFIG_GROUP_INFO;


//
// Structures for IOCTL_HTTP_ADD_URL_TO_CONFIG_GROUP and
// IOCTL_HTTP_REMOVE_URL_FROM_CONFIG_GROUP.
//

typedef struct _HTTP_CONFIG_GROUP_URL_INFO
{
    HTTP_CONFIG_GROUP_ID ConfigGroupId;
    HTTP_URL_CONTEXT UrlContext;
    UNICODE_STRING FullyQualifiedUrl;

} HTTP_CONFIG_GROUP_URL_INFO, *PHTTP_CONFIG_GROUP_URL_INFO;


//
// Structures for IOCTL_HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP.
//

typedef struct _HTTP_REMOVE_ALL_URLS_INFO
{
    HTTP_CONFIG_GROUP_ID ConfigGroupId;

} HTTP_REMOVE_ALL_URLS_INFO, *PHTTP_REMOVE_ALL_URLS_INFO;


//
// Structures for IOCTL_HTTP_CREATE_APP_POOL.
//

typedef struct _HTTP_CREATE_APP_POOL_INFO
{
    UNICODE_STRING AppPoolName;

} HTTP_CREATE_APP_POOL_INFO, *PHTTP_CREATE_APP_POOL_INFO;


//
// Structures for IOCTL_HTTP_QUERY_APP_POOL_INFORMATION and
// IOCTL_HTTP_SET_APP_POOL_INFORMATION.
//

typedef struct _HTTP_APP_POOL_INFO
{
    HTTP_APP_POOL_INFORMATION_CLASS InformationClass;

} HTTP_APP_POOL_INFO, *PHTTP_APP_POOL_INFO;


//
// Structures for IOCTL_HTTP_ADD_TRANSIENT_URL and
// IOCTL_HTTP_REMOVE_TRANSIENT_URL.
//

typedef struct _HTTP_TRANSIENT_URL_INFO
{
    UNICODE_STRING FullyQualifiedUrl;

} HTTP_TRANSIENT_URL_INFO, *PHTTP_TRANSIENT_URL_INFO;


//
// Structures for IOCTL_HTTP_RECEIVE_HTTP_REQUEST and
// IOCTL_HTTP_RECEIVE_ENTITY_BODY.
//

typedef struct _HTTP_RECEIVE_REQUEST_INFO
{
    HTTP_REQUEST_ID RequestId;
    ULONG Flags;

} HTTP_RECEIVE_REQUEST_INFO, *PHTTP_RECEIVE_REQUEST_INFO;


//
// Structures for IOCTL_HTTP_SEND_HTTP_RESPONSE.
//

typedef struct _HTTP_SEND_HTTP_RESPONSE_INFO
{
    PHTTP_RESPONSE pHttpResponse;
    ULONG EntityChunkCount;
    PHTTP_DATA_CHUNK pEntityChunks;
    HTTP_CACHE_POLICY CachePolicy;
    HTTP_REQUEST_ID RequestId;
    ULONG Flags;
    PHTTP_LOG_FIELDS_DATA pLogData;

} HTTP_SEND_HTTP_RESPONSE_INFO, *PHTTP_SEND_HTTP_RESPONSE_INFO;


//
// Structures for IOCTL_HTTP_FLUSH_RESPONSE_CACHE.
//

typedef struct _HTTP_FLUSH_RESPONSE_CACHE_INFO
{
    UNICODE_STRING FullyQualifiedUrl;
    ULONG Flags;

} HTTP_FLUSH_RESPONSE_CACHE_INFO, *PHTTP_FLUSH_RESPONSE_CACHE_INFO;


//
// Structures for IOCTL_HTTP_WAIT_FOR_DISCONNECT.
//

typedef struct _HTTP_WAIT_FOR_DISCONNECT_INFO
{
    HTTP_CONNECTION_ID ConnectionId;

} HTTP_WAIT_FOR_DISCONNECT_INFO, *PHTTP_WAIT_FOR_DISCONNECT_INFO;


//
// Structures for IOCTL_HTTP_FILTER_RECEIVE_CLIENT_CERT
//

typedef struct _HTTP_FILTER_RECEIVE_CLIENT_CERT_INFO
{
    HTTP_CONNECTION_ID ConnectionId;
    ULONG Flags;

} HTTP_FILTER_RECEIVE_CLIENT_CERT_INFO, *PHTTP_FILTER_RECEIVE_CLIENT_CERT_INFO;


//
// HTTP IOCTL code definitions.
//
// N.B. To ensure the efficient of the code generated by HTTP's
//      IOCTL dispatcher, these IOCTL codes should be contiguous
//      (no gaps).
//
// N.B. If new IOCTLs are added here, update the lookup table in
//      devctrl.c.
//

#define _HTTP_CTL_CODE(request, method, access)             \
    CTL_CODE( FILE_DEVICE_NETWORK, request, method, access )

#define _HTTP_REQUEST(ioctl)                                \
   ((((ULONG)(ioctl)) >> 2) & 0x03FF)


#define HTTP_QUERY_CONTROL_CHANNEL                          0
#define HTTP_SET_CONTROL_CHANNEL                            1
#define HTTP_CREATE_CONFIG_GROUP                            2
#define HTTP_DELETE_CONFIG_GROUP                            3
#define HTTP_QUERY_CONFIG_GROUP                             4
#define HTTP_SET_CONFIG_GROUP                               5
#define HTTP_ADD_URL_TO_CONFIG_GROUP                        6
#define HTTP_REMOVE_URL_FROM_CONFIG_GROUP                   7
#define HTTP_QUERY_APP_POOL_INFORMATION                     8
#define HTTP_SET_APP_POOL_INFORMATION                       9
#define HTTP_RECEIVE_HTTP_REQUEST                           10
#define HTTP_RECEIVE_ENTITY_BODY                            11
#define HTTP_SEND_HTTP_RESPONSE                             12
#define HTTP_SEND_ENTITY_BODY                               13
#define HTTP_FLUSH_RESPONSE_CACHE                           14
#define HTTP_WAIT_FOR_DEMAND_START                          15
#define HTTP_WAIT_FOR_DISCONNECT                            16
#define HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP              17
#define HTTP_ADD_TRANSIENT_URL                              18
#define HTTP_REMOVE_TRANSIENT_URL                           19
#define HTTP_FILTER_ACCEPT                                  20
#define HTTP_FILTER_CLOSE                                   21
#define HTTP_FILTER_RAW_READ                                22
#define HTTP_FILTER_RAW_WRITE                               23
#define HTTP_FILTER_APP_READ                                24
#define HTTP_FILTER_APP_WRITE                               25
#define HTTP_FILTER_RECEIVE_CLIENT_CERT                     26
#define HTTP_GET_COUNTERS                                   27

#define HTTP_NUM_IOCTLS                                     28


#define IOCTL_HTTP_QUERY_CONTROL_CHANNEL                    \
    _HTTP_CTL_CODE( HTTP_QUERY_CONTROL_CHANNEL,             \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SET_CONTROL_CHANNEL                      \
    _HTTP_CTL_CODE( HTTP_SET_CONTROL_CHANNEL,               \
                    METHOD_IN_DIRECT,                       \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_CREATE_CONFIG_GROUP                      \
    _HTTP_CTL_CODE( HTTP_CREATE_CONFIG_GROUP,               \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_DELETE_CONFIG_GROUP                      \
    _HTTP_CTL_CODE( HTTP_DELETE_CONFIG_GROUP,               \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_QUERY_CONFIG_GROUP                       \
    _HTTP_CTL_CODE( HTTP_QUERY_CONFIG_GROUP,                \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SET_CONFIG_GROUP                         \
    _HTTP_CTL_CODE( HTTP_SET_CONFIG_GROUP,                  \
                    METHOD_IN_DIRECT,                       \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_ADD_URL_TO_CONFIG_GROUP                  \
    _HTTP_CTL_CODE( HTTP_ADD_URL_TO_CONFIG_GROUP,           \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_REMOVE_URL_FROM_CONFIG_GROUP             \
    _HTTP_CTL_CODE( HTTP_REMOVE_URL_FROM_CONFIG_GROUP,      \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_QUERY_APP_POOL_INFORMATION               \
    _HTTP_CTL_CODE( HTTP_QUERY_APP_POOL_INFORMATION,        \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SET_APP_POOL_INFORMATION                 \
    _HTTP_CTL_CODE( HTTP_SET_APP_POOL_INFORMATION,          \
                    METHOD_IN_DIRECT,                       \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_RECEIVE_HTTP_REQUEST                     \
    _HTTP_CTL_CODE( HTTP_RECEIVE_HTTP_REQUEST,              \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_RECEIVE_ENTITY_BODY                      \
    _HTTP_CTL_CODE( HTTP_RECEIVE_ENTITY_BODY,               \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SEND_HTTP_RESPONSE                       \
    _HTTP_CTL_CODE( HTTP_SEND_HTTP_RESPONSE,                \
                    METHOD_NEITHER,                         \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SEND_ENTITY_BODY                         \
    _HTTP_CTL_CODE( HTTP_SEND_ENTITY_BODY,                  \
                    METHOD_NEITHER,                         \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FLUSH_RESPONSE_CACHE                     \
    _HTTP_CTL_CODE( HTTP_FLUSH_RESPONSE_CACHE,              \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_WAIT_FOR_DEMAND_START                    \
    _HTTP_CTL_CODE( HTTP_WAIT_FOR_DEMAND_START,             \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_WAIT_FOR_DISCONNECT                      \
    _HTTP_CTL_CODE( HTTP_WAIT_FOR_DISCONNECT,               \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP        \
    _HTTP_CTL_CODE( HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP, \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_ADD_TRANSIENT_URL                        \
    _HTTP_CTL_CODE( HTTP_ADD_TRANSIENT_URL,                 \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_REMOVE_TRANSIENT_URL                     \
    _HTTP_CTL_CODE( HTTP_REMOVE_TRANSIENT_URL,              \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_FILTER_ACCEPT                            \
    _HTTP_CTL_CODE( HTTP_FILTER_ACCEPT,                     \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_CLOSE                             \
    _HTTP_CTL_CODE( HTTP_FILTER_CLOSE,                      \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_RAW_READ                          \
    _HTTP_CTL_CODE( HTTP_FILTER_RAW_READ,                   \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_RAW_WRITE                         \
    _HTTP_CTL_CODE( HTTP_FILTER_RAW_WRITE,                  \
                    METHOD_IN_DIRECT,                       \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_APP_READ                          \
    _HTTP_CTL_CODE( HTTP_FILTER_APP_READ,                   \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_APP_WRITE                         \
    _HTTP_CTL_CODE( HTTP_FILTER_APP_WRITE,                  \
                    METHOD_IN_DIRECT,                       \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_RECEIVE_CLIENT_CERT               \
    _HTTP_CTL_CODE( HTTP_FILTER_RECEIVE_CLIENT_CERT,        \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_GET_COUNTERS                             \
    _HTTP_CTL_CODE( HTTP_GET_COUNTERS,                      \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif // _HTTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\config.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    config.c

Abstract:

    User-mode interface to UL.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//

#ifndef DIFF
#define DIFF(x)    ((size_t)(x))
#endif

//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Creates a new configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    pConfigGroupId - Receives an opaque identifier for the new
        configuration group.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpCreateConfigGroup(
    IN HANDLE ControlChannelHandle,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroupId
    )
{
    NTSTATUS status;
    HTTP_CONFIG_GROUP_INFO configGroupInfo;

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_CREATE_CONFIG_GROUP,     // IoControlCode
                    NULL,                               // pInputBuffer
                    0,                                  // InputBufferLength
                    &configGroupInfo,                   // pOutputBuffer
                    sizeof(configGroupInfo),            // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    if (NT_SUCCESS(status))
    {
        //
        // Retrieve the container ID.
        //

        *pConfigGroupId = configGroupInfo.ConfigGroupId;
    }

    return HttpApiNtStatusToWin32Status( status );

} // HttpCreateConfigGroup


/***************************************************************************++

Routine Description:

    Deletes an existing configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpDeleteConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    )
{
    NTSTATUS status;
    HTTP_CONFIG_GROUP_INFO configGroupInfo;

    //
    // Initialize the input structure.
    //

    configGroupInfo.ConfigGroupId = ConfigGroupId;

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_DELETE_CONFIG_GROUP,     // IoControlCode
                    &configGroupInfo,                   // pInputBuffer
                    sizeof(configGroupInfo),            // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpDeleteConfigGroup


/***************************************************************************++

Routine Description:

    Adds a fully qualified URL to an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

    pFullyQualifiedUrl - Supplies the fully qualified URL to add to the
        container.

    UrlContext - Supplies an uninterpreted context to be associated with
        the URL.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpAddUrlToConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl,
    IN HTTP_URL_CONTEXT UrlContext
    )
{
    NTSTATUS status;
    HTTP_CONFIG_GROUP_URL_INFO urlInfo;

    //
    // Initialize the input structure.
    //

    urlInfo.ConfigGroupId = ConfigGroupId;
    urlInfo.UrlContext = UrlContext;
    RtlInitUnicodeString( &urlInfo.FullyQualifiedUrl, pFullyQualifiedUrl );

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_ADD_URL_TO_CONFIG_GROUP, // IoControlCode
                    &urlInfo,                           // pInputBuffer
                    sizeof(urlInfo),                    // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpAddUrlToConfigGroup


/***************************************************************************++

Routine Description:

    Removes a fully qualified URL from an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

    pFullyQualifiedUrl - Supplies the fully qualified URL to remove from
        the container.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpRemoveUrlFromConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl
    )
{
    NTSTATUS status;
    HTTP_CONFIG_GROUP_URL_INFO urlInfo;

    //
    // Initialize the input structure.
    //

    urlInfo.ConfigGroupId = ConfigGroupId;
    RtlInitUnicodeString( &urlInfo.FullyQualifiedUrl, pFullyQualifiedUrl );

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_REMOVE_URL_FROM_CONFIG_GROUP,    // IoControlCode
                    &urlInfo,                           // pInputBuffer
                    sizeof(urlInfo),                    // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpRemoveUrlFromConfigGroup


/***************************************************************************++

Routine Description:

    Removes all URLs from an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpRemoveAllUrlsFromConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    )
{
    NTSTATUS status;
    HTTP_REMOVE_ALL_URLS_INFO urlInfo;

    //
    // Initialize the input structure.
    //

    urlInfo.ConfigGroupId = ConfigGroupId;

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP,   // IoControlCode
                    &urlInfo,                           // pInputBuffer
                    sizeof(urlInfo),                    // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpRemoveAllUrlsFromConfigGroup


/***************************************************************************++

Routine Description:

    Queries information from an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

    InformationClass - Supplies the type of information to query.

    pConfigGroupInformation - Supplies a buffer for the query.

    Length - Supplies the length of pConfigGroupInformation.

    pReturnLength - Receives the length of data written to the buffer.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpQueryConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    OUT PVOID pConfigGroupInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    )
{
    NTSTATUS status;
    HTTP_CONFIG_GROUP_INFO configGroupInfo;

    //
    // Initialize the input structure.
    //

    configGroupInfo.ConfigGroupId = ConfigGroupId;
    configGroupInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_QUERY_CONFIG_GROUP,      // IoControlCode
                    &configGroupInfo,                   // pInputBuffer
                    sizeof(configGroupInfo),            // InputBufferLength
                    pConfigGroupInformation,            // pOutputBuffer
                    Length,                             // OutputBufferLength
                    pReturnLength                       // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpQueryConfigGroupInformation

/***************************************************************************++

Routine Description:

    Before passing down the config group information. Make sure that the 
    directory name in the HttpConfigGroupLogInformation is not pointing back
    to local machine if it's a UNC path

Arguments:

    pConfigGroupInformation - Supplies the config group info with dir name
    Length  - Length of the above

Return

    STATUS_SUCCESS : If the UNC path doesn't include the local machine name
                     Or if the path is not UNC path.
    
    STATUS_INVALID_PARAMETER : If the buffer itself is corrupted or something
                               fatal is preventing us from getting computer
                               name when path is UNC.

    STATUS_NOT_SUPPORTED: If UNC path points back to the local machine.
    
--***************************************************************************/

NTSTATUS
HttpApiConfigGroupInformationSanityCheck(
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    )
{
    PHTTP_CONFIG_GROUP_LOGGING pLoggingInfo;
    WCHAR pwszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG ulComputerNameLength;
    PWCHAR pwsz,pwszT;
    ULONG ulSrcUncLength;
    ULONG ulDirNameLength;

    //
    // Only for HttpConfigGroupLogInformation
    //

    if(InformationClass != HttpConfigGroupLogInformation ||
       pConfigGroupInformation == NULL
       )
    {
        return STATUS_SUCCESS;
    }

    if (Length < sizeof(HTTP_CONFIG_GROUP_LOGGING))
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // Try to check the log dir name if it's a UNC Path
    //
    __try
    {            
        pLoggingInfo = (PHTTP_CONFIG_GROUP_LOGGING)pConfigGroupInformation;
        ulDirNameLength = pLoggingInfo->LogFileDir.Length / sizeof(WCHAR);
            
        if (ulDirNameLength > 2)
        {        
            if (pLoggingInfo->LogFileDir.Buffer[0] == L'\\' &&
                pLoggingInfo->LogFileDir.Buffer[1] == L'\\')
            {
                // UNC Path
                
                ULONG ccLength = MAX_COMPUTERNAME_LENGTH + 1;
                
                if (!GetComputerNameW(pwszComputerName, &ccLength))
                {
                    // This should never fail unless there's really fatal 
                    // system problem. But if it fails then refuse the 
                    // UNC path regardless.
                    
                    return STATUS_INVALID_PARAMETER;                
                }
                
                if (ccLength == 0)
                {
                    return STATUS_INVALID_PARAMETER;
                }

                ulComputerNameLength = ccLength;                    

                // Extract the computername from the full path
                
                pwsz = pwszT = &pLoggingInfo->LogFileDir.Buffer[2];
                ulDirNameLength -= 2;
                    
                // Forward the temp pointer to the end of the supposed
                // computername
                
                while(ulDirNameLength && *pwszT != UNICODE_NULL && *pwszT != L'\\') 
                {
                    pwszT++;
                    ulDirNameLength--;
                }

                ulSrcUncLength = (ULONG) DIFF(pwszT - pwsz);

                // Compare not case sensitive
                
                if(ulComputerNameLength == ulSrcUncLength &&
                   _wcsnicmp(pwszComputerName, pwsz, ulSrcUncLength) == 0
                   )
                {
                    return STATUS_NOT_SUPPORTED;
                }

            }            
        
        }

    }    
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    return STATUS_SUCCESS;
    
}

/***************************************************************************++

Routine Description:

    Sets information in an configuration group.

Arguments:

    ControlChannelHandle - Supplies a control channel handle.

    ConfigGroupId - Supplies an identifier as returned by
        HttpCreateConfigGroup().

    InformationClass - Supplies the type of information to set.

    pConfigGroupInformation - Supplies the data to set.

    Length - Supplies the length of pConfigGroupInformation.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSetConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    )
{
    NTSTATUS status;
    HTTP_CONFIG_GROUP_INFO configGroupInfo;

    //
    // Initialize the input structure.
    //

    configGroupInfo.ConfigGroupId = ConfigGroupId;
    configGroupInfo.InformationClass = InformationClass;

    status = HttpApiConfigGroupInformationSanityCheck(
                    InformationClass,
                    pConfigGroupInformation,
                    Length
                    );
    if (!NT_SUCCESS(status))
    {
        return HttpApiNtStatusToWin32Status(status);
    }
        
    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_SET_CONFIG_GROUP,        // IoControlCode
                    &configGroupInfo,                   // pInputBuffer
                    sizeof(configGroupInfo),            // InputBufferLength
                    pConfigGroupInformation,            // pOutputBuffer
                    Length,                             // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpSetConfigGroupInformation


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\control.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    control.c

Abstract:

    User-mode interface to UL.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Opens a control channel to UL.SYS.

Arguments:

    pControlChannel - Receives a handle to the control channel if successful.

    Options - Supplies zero or more HTTP_OPTION_* flags.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpOpenControlChannel(
    OUT PHANDLE pControlChannel,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // First, just try to open the driver.
    //

    status = HttpApiOpenDriverHelper(
                    pControlChannel,            // pHandle
                    GENERIC_READ |              // DesiredAccess
                        GENERIC_WRITE |
                        SYNCHRONIZE,
                    HttpApiControlChannelHandleType,    // handle type
                    NULL,                       // pObjectName
                    Options,                    // Options
                    FILE_OPEN,                  // CreateDisposition
                    NULL                        // pSecurityAttributes
                    );

    //
    // If we couldn't open the driver because it's not running, then try
    // to start the driver & retry the open.
    //

    if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
        status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        if (HttpApiTryToStartDriver())
        {
            status = HttpApiOpenDriverHelper(
                            pControlChannel,            // pHandle
                            GENERIC_READ |              // DesiredAccess
                                GENERIC_WRITE |
                                SYNCHRONIZE,
                            HttpApiControlChannelHandleType,    // handle type
                            NULL,                       // pObjectName
                            Options,                    // Options
                            FILE_OPEN,                  // CreateDisposition
                            NULL                        // pSecurityAttributes
                            );
        }
    }

    return HttpApiNtStatusToWin32Status( status );

} // HttpOpenControlChannel


/***************************************************************************++

Routine Description:

    Queries information from a control channel.

Arguments:

    ControlChannelHandle - Supplies a UL.SYS control channel handle.

    InformationClass - Supplies the type of information to query.

    pControlChannelInformation - Supplies a buffer for the query.

    Length - Supplies the length of pControlChannelInformation.

    pReturnLength - Receives the length of data written to the buffer.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpQueryControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    OUT PVOID pControlChannelInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    )
{
    NTSTATUS status;
    HTTP_CONTROL_CHANNEL_INFO channelInfo;

    //
    // Initialize the input structure.
    //

    channelInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_QUERY_CONTROL_CHANNEL,   // IoControlCode
                    &channelInfo,                       // pInputBuffer
                    sizeof(channelInfo),                // InputBufferLength
                    pControlChannelInformation,         // pOutputBuffer
                    Length,                             // OutputBufferLength
                    pReturnLength                       // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpQueryControlChannelInformation


/***************************************************************************++

Routine Description:

    Sets information in a control channel.

Arguments:

    ControlChannelHandle - Supplies a UL.SYS control channel handle.

    InformationClass - Supplies the type of information to set.

    pControlChannelInformation - Supplies the data to set.

    Length - Supplies the length of pControlChannelInformation.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSetControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length
    )
{
    NTSTATUS status;
    HTTP_CONTROL_CHANNEL_INFO channelInfo;

    //
    // Initialize the input structure.
    //

    channelInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,               // FileHandle
                    IOCTL_HTTP_SET_CONTROL_CHANNEL,     // IoControlCode
                    &channelInfo,                       // pInputBuffer
                    sizeof(channelInfo),                // InputBufferLength
                    pControlChannelInformation,         // pOutputBuffer
                    Length,                             // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpSetControlChannelInformation


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\init.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    init.c

Abstract:

    DLL initialization/termination routines.

Author:

    Keith Moore (keithmo)        02-Aug-1999

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs DLL initialization/termination.

Arguments:

    DllHandle - Supplies a handle to the current DLL.

    Reason - Supplies the notification code.

    pContext - Optionally supplies a context.

Return Value:

    BOOLEAN - TRUE if initialization completed successfully, FALSE
        otherwise. Ignored for notifications other than process
        attach.

--***************************************************************************/
BOOL
WINAPI
DllMain(
    IN HMODULE DllHandle,
    IN DWORD Reason,
    IN LPVOID pContext OPTIONAL
    )
{
    BOOL result = TRUE;

    //
    // Interpret the reason code.
    //

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls( DllHandle );
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return result;

}   // DllMain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\counter.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    counter.c

Abstract:

    User-mode interface to UL.SYS performance counter collection API

Author:

     Eric Stenson (ericsten)        28-Sept-2000

Revision History:

--*/


#include "precomp.h"

//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Gathers the perf counters for UL.SYS

Arguments:

    pControlChannelHandle - A handle to the control channel of UL.SYS

    CounterGroup - which counter set to get (global or site)

    pSizeCounterBlock - (IN) size of buffer, (OUT) bytes written if successful,
        zero otherwise

    pCounterBlocks - Buffer to receive the returned counter data block(s)

    pNumInstances - number of blocks returned.


Return Values:

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INVALID_DEVICE_REQUEST
    STATUS_INVALID_PARAMETER

--***************************************************************************/

ULONG
WINAPI
HttpGetCounters(
    IN HANDLE ControlChannelHandle,
    IN HTTP_COUNTER_GROUP CounterGroup,
    IN OUT PULONG pSizeCounterBlock,
    IN OUT PVOID pCounterBlocks,
    OUT PULONG pNumInstances OPTIONAL
    )
{
    NTSTATUS    Status;

    Status = HttpApiSynchronousDeviceControl(
                    ControlChannelHandle,           // FileHandle
                    IOCTL_HTTP_GET_COUNTERS,        // IoControlCode
                    &CounterGroup,                  // pInputBuffer
                    sizeof(HTTP_COUNTER_GROUP),     // InputBufferLength
                    pCounterBlocks,                 // pOutputBuffer
                    *pSizeCounterBlock,             // OutputBufferLength
                    pSizeCounterBlock               // pBytesTransferred
                    );

    //
    // Calc the number of blocks returned.
    //

    if (STATUS_SUCCESS == Status)
    {
        if (pNumInstances)
        {
            if (HttpCounterGroupGlobal == CounterGroup)
            {
                *pNumInstances = (*pSizeCounterBlock / sizeof(HTTP_GLOBAL_COUNTERS));
            }
            else
            {
                ASSERT(HttpCounterGroupSite == CounterGroup);
                *pNumInstances = (*pSizeCounterBlock / sizeof(HTTP_SITE_COUNTERS));
            }
        }
    }
    else
    {
        if (pSizeCounterBlock)
            *pSizeCounterBlock = 0;

        if (pNumInstances)
            *pNumInstances = 0;
    }

    return HttpApiNtStatusToWin32Status( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\apppool.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    apppool.c

Abstract:

    User-mode interface to UL.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Creates a new Application Pool.

Arguments:

    pAppPoolHandle - Receives a handle to the new application pool.
        object.

    pAppPoolName - Supplies the name of the new application pool.

    pSecurityAttributes - Optionally supplies security attributes for
        the new application pool.

    Options - Supplies creation options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpCreateAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiOpenDriverHelper(
                    pAppPoolHandle,             // pHandle
                    GENERIC_READ |              // DesiredAccess
                        GENERIC_WRITE |
                        SYNCHRONIZE |
                        WRITE_DAC,              // WAS needs WRITE DAC permissions
                                                // to support different worker process permissions.
                    HttpApiAppPoolHandleType,   // HandleType
                    pAppPoolName,               // pObjectName
                    Options,                    // Options
                    FILE_CREATE,                // CreateDisposition
                    pSecurityAttributes         // pSecurityAttributes
                    );

    //
    // If we couldn't open the driver because it's not running, then try
    // to start the driver & retry the open.
    //

    if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
        status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        if (HttpApiTryToStartDriver())
        {
            status = HttpApiOpenDriverHelper(
                            pAppPoolHandle,         // pHandle
                            GENERIC_READ |          // DesiredAccess
                                GENERIC_WRITE |
                                SYNCHRONIZE,
                            HttpApiAppPoolHandleType,   // HandleType
                            pAppPoolName,           // pObjectName
                            Options,                // Options
                            FILE_CREATE,            // CreateDisposition
                            pSecurityAttributes     // pSecurityAttributes
                            );
        }
    }

    return HttpApiNtStatusToWin32Status( status );

} // HttpCreateAppPool


/***************************************************************************++

Routine Description:

    Opens an existing application pool.

Arguments:

    pAppPoolHandle - Receives a handle to the existing application pool object.

    pAppPoolName - Supplies the name of the existing application pool.

    Options - Supplies open options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpOpenAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiOpenDriverHelper(
                    pAppPoolHandle,             // pHandle
                    GENERIC_READ |              // DesiredAccess
                        SYNCHRONIZE,
                    HttpApiAppPoolHandleType,   // HandleType
                    pAppPoolName,               // pObjectName
                    Options,                    // Options
                    FILE_OPEN,                  // CreateDisposition
                    NULL                        // pSecurityAttributes
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpOpenAppPool


/***************************************************************************++

Routine Description:

    Queries information from a application pool.

Arguments:

    AppPoolHandle - Supplies a handle to a UL.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    InformationClass - Supplies the type of information to query.

    pAppPoolInformation - Supplies a buffer for the query.

    Length - Supplies the length of pAppPoolInformation.

    pReturnLength - Receives the length of data written to the buffer.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpQueryAppPoolInformation(
    IN HANDLE AppPoolHandle,
    IN HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    OUT PVOID pAppPoolInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    )
{
    NTSTATUS status;
    HTTP_APP_POOL_INFO appPoolInfo;

    //
    // Initialize the input structure.
    //

    appPoolInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    AppPoolHandle,              // FileHandle
                    IOCTL_HTTP_QUERY_APP_POOL_INFORMATION,  // IoControlCode
                    &appPoolInfo,               // pInputBuffer
                    sizeof(appPoolInfo),        // InputBufferLength
                    pAppPoolInformation,        // pOutputBuffer
                    Length,                     // OutputBufferLength
                    pReturnLength               // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpQueryAppPoolInformation


/***************************************************************************++

Routine Description:

    Sets information in an admin container.

Arguments:

    AppPoolHandle - Supplies a handle to a UL.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    InformationClass - Supplies the type of information to set.

    pAppPoolInformation - Supplies the data to set.

    Length - Supplies the length of pAppPoolInformation.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSetAppPoolInformation(
    IN HANDLE AppPoolHandle,
    IN HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    IN PVOID pAppPoolInformation,
    IN ULONG Length
    )
{
    NTSTATUS status;
    HTTP_APP_POOL_INFO appPoolInfo;

    //
    // Initialize the input structure.
    //

    appPoolInfo.InformationClass = InformationClass;

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    AppPoolHandle,              // FileHandle
                    IOCTL_HTTP_SET_APP_POOL_INFORMATION, // IoControlCode
                    &appPoolInfo,               // pInputBuffer
                    sizeof(appPoolInfo),        // InputBufferLength
                    pAppPoolInformation,        // pOutputBuffer
                    Length,                     // OutputBufferLength
                    NULL                        // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpSetAppPoolInformation


/***************************************************************************++

Routine Description:

    Adds a transient URL prefix.

Arguments:

    AppPoolHandle - Supplies a handle to a UL.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    pFullyQualifiedUrl - the URL prefix to add

Return Value:

    Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpAddTransientUrl(
    IN HANDLE AppPoolHandle,
    IN PCWSTR pFullyQualifiedUrl
    )
{
    NTSTATUS status;
    HTTP_TRANSIENT_URL_INFO transientUrlInfo;

    //
    // Initialize the input structure.
    //
    
    RtlInitUnicodeString(
        &transientUrlInfo.FullyQualifiedUrl,
        pFullyQualifiedUrl
        );

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    IOCTL_HTTP_ADD_TRANSIENT_URL,       // IoControlCode
                    &transientUrlInfo,                  // pInputBuffer
                    sizeof(transientUrlInfo),           // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );
} // HttpAddTransientUrl


/***************************************************************************++

Routine Description:

    Removes a transient URL prefix.

Arguments:

    AppPoolHandle - Supplies a handle to a UL.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    pFullyQualifiedUrl - the URL prefix to add

Return Value:

    Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpRemoveTransientUrl(
    IN HANDLE AppPoolHandle,
    IN PCWSTR pFullyQualifiedUrl
    )
{
    NTSTATUS status;
    HTTP_TRANSIENT_URL_INFO transientUrlInfo;

    //
    // Initialize the input structure.
    //
    
    RtlInitUnicodeString(
        &transientUrlInfo.FullyQualifiedUrl,
        pFullyQualifiedUrl
        );

    //
    // Make the request.
    //

    status = HttpApiSynchronousDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    IOCTL_HTTP_REMOVE_TRANSIENT_URL,    // IoControlCode
                    &transientUrlInfo,                  // pInputBuffer
                    sizeof(transientUrlInfo),           // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );
} // HttpRemoveTransientUrl


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\httpio.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httpio.c

Abstract:

    User-mode interface to HTTP.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Waits for an incoming HTTP request from HTTP.SYS.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    RequestId - Supplies an opaque identifier to receive a specific
        request. If this value is HTTP_NULL_ID, then receive any request.

    Flags - Currently unused and must be zero.

    pRequestBuffer - Supplies a pointer to the request buffer to be filled
        in by HTTP.SYS.

    RequestBufferLength - Supplies the length of pRequestBuffer.

    pBytesReturned - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data returned in the request buffer
        if this request completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure for the
        request.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpReceiveHttpRequest(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN PHTTP_REQUEST pRequestBuffer,
    IN ULONG RequestBufferLength,
    OUT PULONG pBytesReturned OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;
    HTTP_RECEIVE_REQUEST_INFO ReceiveInfo;

#if DBG
    RtlFillMemory( pRequestBuffer, RequestBufferLength, '\xcc' );
#endif

    ReceiveInfo.RequestId = RequestId;
    ReceiveInfo.Flags = Flags;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    pOverlapped,                        // pOverlapped
                    IOCTL_HTTP_RECEIVE_HTTP_REQUEST,    // IoControlCode
                    &ReceiveInfo,                       // pInputBuffer
                    sizeof(ReceiveInfo),                // InputBufferLength
                    pRequestBuffer,                     // pOutputBuffer
                    RequestBufferLength,                // OutputBufferLength
                    pBytesReturned                      // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpReceiveHttpRequest

/***************************************************************************++

Routine Description:

    Receives entity body for a request already read via ReceiveHttpRequest.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    RequestId - Supplies an opaque identifier to receive a specific
        request. If this value is HTTP_NULL_ID, then receive any request.

    pEntityBodyBuffer - Supplies a pointer to the request buffer to be filled
        in by HTTP.SYS.

    EntityBufferLength - Supplies the length of pEntityBuffer.

    pBytesReturned - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data returned in the request buffer
        if this request completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure for the
        request.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpReceiveEntityBody(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    OUT PVOID pEntityBuffer,
    IN ULONG EntityBufferLength,
    OUT PULONG pBytesReturned,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS Status;
    HTTP_RECEIVE_REQUEST_INFO ReceiveInfo;

#if DBG
    if (pEntityBuffer != NULL)
    {
        RtlFillMemory( pEntityBuffer, EntityBufferLength, '\xcc' );
    }
#endif

    ReceiveInfo.RequestId = RequestId;
    ReceiveInfo.Flags = Flags;

    //
    // Make the request.
    //

    Status = HttpApiDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    pOverlapped,                        // pOverlapped
                    IOCTL_HTTP_RECEIVE_ENTITY_BODY,     // IoControlCode
                    &ReceiveInfo,                       // pInputBuffer
                    sizeof(ReceiveInfo),                // InputBufferLength
                    pEntityBuffer,                      // pOutputBuffer
                    EntityBufferLength,                 // OutputBufferLength
                    pBytesReturned                      // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( Status );

}


/***************************************************************************++

Routine Description:

    Sends an HTTP response on the specified connection.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    RequestId - Supplies an opaque identifier specifying the request
        the response is for.

    Flags - Supplies zero or more HTTP_SEND_RESPONSE_FLAG_* control flags.

    pHttpResponse - Supplies the HTTP response.

    pCachePolicy - Supplies caching policy for the response.

    pBytesSent - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data sent if this request
        completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSendHttpResponse(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN PHTTP_RESPONSE pHttpResponse,
    IN PHTTP_CACHE_POLICY pCachePolicy OPTIONAL,
    OUT PULONG pBytesSent OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL
    )
{
    NTSTATUS status;
    HTTP_SEND_HTTP_RESPONSE_INFO responseInfo;

    //
    // Build the response structure.
    //

    RtlZeroMemory(&responseInfo, sizeof(responseInfo));

    responseInfo.pHttpResponse      = pHttpResponse;
    responseInfo.EntityChunkCount   = pHttpResponse->EntityChunkCount;
    responseInfo.pEntityChunks      = pHttpResponse->pEntityChunks;

    if (pCachePolicy != NULL)
    {
        responseInfo.CachePolicy    = *pCachePolicy;
    } else {
        responseInfo.CachePolicy.Policy = HttpCachePolicyNocache;
        responseInfo.CachePolicy.SecondsToLive = 0;
    }

    responseInfo.RequestId          = RequestId;
    responseInfo.Flags              = Flags;    
    responseInfo.pLogData           = pLogData;
    
    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    pOverlapped,                        // pOverlapped
                    IOCTL_HTTP_SEND_HTTP_RESPONSE,      // IoControlCode
                    &responseInfo,                      // pInputBuffer
                    sizeof(responseInfo),               // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    pBytesSent                          // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpSendHttpResponse

/***************************************************************************++

Routine Description:

    Sends an HTTP response on the specified connection.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    RequestId - Supplies an opaque identifier specifying the request
        the response is for.

    Flags - Supplies zero or more HTTP_SEND_RESPONSE_FLAG_* control flags.

    pBytesSent - Optionally supplies a pointer to a ULONG which will
        receive the actual length of the data sent if this request
        completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpSendEntityBody(
    IN HANDLE AppPoolHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN ULONG EntityChunkCount OPTIONAL,
    IN PHTTP_DATA_CHUNK pEntityChunks OPTIONAL,
    OUT PULONG pBytesSent OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL
    )
{
    NTSTATUS status;
    HTTP_SEND_HTTP_RESPONSE_INFO responseInfo;

    //
    // Build the response structure.
    //

    RtlZeroMemory(&responseInfo, sizeof(responseInfo));

    responseInfo.EntityChunkCount   = EntityChunkCount;
    responseInfo.pEntityChunks      = pEntityChunks;
    responseInfo.RequestId          = RequestId;
    responseInfo.Flags              = Flags;
    responseInfo.pLogData           = pLogData;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    pOverlapped,                        // pOverlapped
                    IOCTL_HTTP_SEND_ENTITY_BODY,        // IoControlCode
                    &responseInfo,                      // pInputBuffer
                    sizeof(responseInfo),               // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    pBytesSent                          // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpSendEntityBody


/***************************************************************************++

Routine Description:

    Wait for the client to initiate a disconnect.

Arguments:

    AppPoolHandle - Supplies a handle to a HTTP.SYS application pool
        as returned from either HttpCreateAppPool() or
        HttpOpenAppPool().

    ConnectionId - Supplies an opaque identifier specifying the connection.

    pOverlapped - Optionally supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpWaitForDisconnect(
    IN HANDLE AppPoolHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;
    HTTP_WAIT_FOR_DISCONNECT_INFO waitInfo;

    //
    // Build the structure.
    //

    waitInfo.ConnectionId = ConnectionId;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    pOverlapped,                        // pOverlapped
                    IOCTL_HTTP_WAIT_FOR_DISCONNECT,     // IoControlCode
                    &waitInfo,                          // pInputBuffer
                    sizeof(waitInfo),                   // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpWaitForDisconnect


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\internal.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    internal.c

Abstract:

    User-mode interface to HTTP.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"

//
// Private definitions
//

typedef struct _CACHED_EVENT
{
    SINGLE_LIST_ENTRY       ListEntry;
    HANDLE                  EventHandle;
} CACHED_EVENT, *PCACHED_EVENT;

//
// Private globals
//

SLIST_HEADER                CachedEventList;

//
// Private macros.
//

#define EA_BUFFER_LENGTH                                                    \
    ( sizeof(FILE_FULL_EA_INFORMATION) +                                    \
      HTTP_OPEN_PACKET_NAME_LENGTH +                                        \
      sizeof(HTTP_OPEN_PACKET) )

//
// Private prototypes.
//

NTSTATUS
HttpApiAcquireCachedEvent(
    OUT CACHED_EVENT ** ppCachedEvent
    );

VOID
HttpApiReleaseCachedEvent(
    IN CACHED_EVENT * pCachedEvent
    );


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Synchronous wrapper around NtDeviceIoControlFile().

Arguments:

    FileHandle - Supplies a handle to the file on which the service is
        being performed.

    IoControlCode - Subfunction code to determine exactly what operation
        is being performed.

    pInputBuffer - Optionally supplies an input buffer to be passed to the
        device driver. Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the pInputBuffer in bytes.

    pOutputBuffer - Optionally supplies an output buffer to receive
        information from the device driver. Whether or not the buffer is
        actually optional is dependent on the IoControlCode.

    OutputBufferLength - Length of the pOutputBuffer in bytes.

    pBytesTransferred - Optionally receives the number of bytes transferred.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
HttpApiSynchronousDeviceControl(
    IN HANDLE FileHandle,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    CACHED_EVENT * pCachedEvent;
    LARGE_INTEGER timeout;

    //
    // Try to snag an event object.
    //

    status = HttpApiAcquireCachedEvent( &pCachedEvent );

    if (NT_SUCCESS(status))
    {
        ASSERT( pCachedEvent != NULL );
        
        //
        // Make the call.
        //

        status = NtDeviceIoControlFile(
                        FileHandle,                     // FileHandle
                        pCachedEvent->EventHandle,      // Event
                        NULL,                           // ApcRoutine
                        NULL,                           // ApcContext
                        &ioStatusBlock,                 // IoStatusBlock
                        IoControlCode,                  // IoControlCode
                        pInputBuffer,                   // InputBuffer
                        InputBufferLength,              // InputBufferLength
                        pOutputBuffer,                  // OutputBuffer
                        OutputBufferLength              // OutputBufferLength
                        );

        if (status == STATUS_PENDING)
        {
            //
            // Wait for it to complete.
            //

            timeout.LowPart = 0xFFFFFFFF;
            timeout.HighPart = 0x7FFFFFFF;

            status = NtWaitForSingleObject( pCachedEvent->EventHandle,
                                            FALSE,
                                            &timeout );
            ASSERT( status == STATUS_SUCCESS );

            status = ioStatusBlock.Status;
        }

        //
        // If the call didn't fail and the caller wants the number
        // of bytes transferred, grab the value from the I/O status
        // block & return it.
        //

        if (!NT_ERROR(status) && pBytesTransferred != NULL)
        {
            *pBytesTransferred = (ULONG)ioStatusBlock.Information;
        }

        //
        // Release the cached event object we acquired above.
        //

        HttpApiReleaseCachedEvent( pCachedEvent );
    }

    return status;

} // HttpApiSynchronousDeviceControl


/***************************************************************************++

Routine Description:

    Overlapped wrapper around NtDeviceIoControlFile().

Arguments:

    FileHandle - Supplies a handle to the file on which the service is
        being performed.

    pOverlapped - Supplies an OVERLAPPED structure.

    IoControlCode - Subfunction code to determine exactly what operation
        is being performed.

    pInputBuffer - Optionally supplies an input buffer to be passed to the
        device driver. Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the pInputBuffer in bytes.

    pOutputBuffer - Optionally supplies an output buffer to receive
        information from the device driver. Whether or not the buffer is
        actually optional is dependent on the IoControlCode.

    OutputBufferLength - Length of the pOutputBuffer in bytes.

    pBytesTransferred - Optionally receives the number of bytes transferred.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
HttpApiOverlappedDeviceControl(
    IN HANDLE FileHandle,
    IN OUT LPOVERLAPPED pOverlapped,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    )
{
    NTSTATUS status;

    //
    // Overlapped I/O gets a little more interesting. We'll strive to be
    // compatible with NT's KERNEL32 implementation. See DeviceIoControl()
    // in \\rastaman\ntwin\src\base\client\filehops.c for the gory details.
    //

    OVERLAPPED_TO_IO_STATUS(pOverlapped)->Status = STATUS_PENDING;

    status = NtDeviceIoControlFile(
                    FileHandle,                         // FileHandle
                    pOverlapped->hEvent,                // Event
                    NULL,                               // ApcRoutine
                    (ULONG_PTR)pOverlapped->hEvent & 1  // ApcContext
                        ? NULL : pOverlapped,
                    OVERLAPPED_TO_IO_STATUS(pOverlapped), // IoStatusBlock
                    IoControlCode,                      // IoControlCode
                    pInputBuffer,                       // InputBuffer
                    InputBufferLength,                  // InputBufferLength
                    pOutputBuffer,                      // OutputBuffer
                    OutputBufferLength                  // OutputBufferLength
                    );

    //
    // If the call didn't fail or pend and the caller wants the number of
    // bytes transferred, grab the value from the I/O status block &
    // return it.
    //

    if (status == STATUS_SUCCESS)
    {
        if (pBytesTransferred)
        {
            *pBytesTransferred =
                (ULONG)OVERLAPPED_TO_IO_STATUS(pOverlapped)->Information;
        }

        status = STATUS_PENDING;
    }

    return status;

} // HttpApiOverlappedDeviceControl


/***************************************************************************++

Routine Description:

    Initializes the event object cache.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiInitializeEventCache(
    VOID
    )
{
    RtlInitializeSListHead( &CachedEventList );
    return NO_ERROR;

} // HttpApiInitializeEventCache


/***************************************************************************++

Routine Description:

    Terminates the event object cache.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
HttpApiTerminateEventCache(
    VOID
    )
{
    CACHED_EVENT *          pCachedEvent;
    PSINGLE_LIST_ENTRY      Entry;

    for ( ;; )
    {
        Entry = RtlInterlockedPopEntrySList( &CachedEventList );
        if (Entry == NULL)
        {
            break;
        }

        pCachedEvent = CONTAINING_RECORD( Entry, CACHED_EVENT, ListEntry );

        NtClose( pCachedEvent->EventHandle );

        FREE_MEM( pCachedEvent );
    }

    return NO_ERROR;

} // HttpApiTerminateEventCache


/***************************************************************************++

Routine Description:

    This routine attempts to start UL.SYS.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--***************************************************************************/
BOOLEAN
HttpApiTryToStartDriver(
    VOID
    )
{
    BOOLEAN result;
    SC_HANDLE scHandle;
    SC_HANDLE svcHandle;

    result = FALSE; // until proven otherwise...

    //
    // Open the service controller.
    //

    scHandle = OpenSCManagerW(
                   NULL,                        // lpMachineName
                   NULL,                        // lpDatabaseName
                   SC_MANAGER_ALL_ACCESS        // dwDesiredAccess
                   );

    if (scHandle != NULL)
    {
        //
        // Try to open the UL service.
        //

        svcHandle = OpenServiceW(
                        scHandle,               // hSCManager
                        HTTP_SERVICE_NAME,      // lpServiceName
                        SERVICE_ALL_ACCESS      // dwDesiredAccess
                        );

        if (svcHandle != NULL)
        {
            //
            // Try to start it.
            //

            if (StartService( svcHandle, 0, NULL))
            {
                result = TRUE;
            }

            CloseServiceHandle( svcHandle );
        }

        CloseServiceHandle( scHandle );
    }

    return result;

} // HttpApiTryToStartDriver


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Helper routine for opening a UL.SYS handle.

Arguments:

    pHandle - Receives a handle if successful.

    DesiredAccess - Supplies the types of access requested to the file.

    HandleType - one of Filter, ControlChannel, or AppPool

    pObjectName - Optionally supplies the name of the application pool
        to create/open.

    Options - Supplies zero or more HTTP_OPTION_* flags.

    CreateDisposition - Supplies the creation disposition for the new
        object.

    pSecurityAttributes - Optionally supplies security attributes for
        the newly created application pool. Ignored if opening a
        control channel.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
HttpApiOpenDriverHelper(
    OUT PHANDLE pHandle,
    IN ACCESS_MASK DesiredAccess,
    IN HTTPAPI_HANDLE_TYPE HandleType,
    IN PCWSTR pObjectName OPTIONAL,
    IN ULONG Options,
    IN ULONG CreateDisposition,
    IN PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING deviceName;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG shareAccess;
    ULONG createOptions;
    PFILE_FULL_EA_INFORMATION pEaBuffer;
    PHTTP_OPEN_PACKET pOpenPacket;
    WCHAR deviceNameBuffer[MAX_PATH];
    UCHAR rawEaBuffer[EA_BUFFER_LENGTH];

    //
    // Validate the parameters.
    //

    if ((pHandle == NULL) ||
        (Options & ~HTTP_OPTION_VALID))
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ((HandleType != HttpApiControlChannelHandleType) &&
        (HandleType != HttpApiFilterChannelHandleType) &&
        (HandleType != HttpApiAppPoolHandleType))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build the open packet.
    //

    pEaBuffer = (PFILE_FULL_EA_INFORMATION)rawEaBuffer;

    pEaBuffer->NextEntryOffset = 0;
    pEaBuffer->Flags = 0;
    pEaBuffer->EaNameLength = HTTP_OPEN_PACKET_NAME_LENGTH;
    pEaBuffer->EaValueLength = sizeof(*pOpenPacket);

    RtlCopyMemory(
        pEaBuffer->EaName,
        HTTP_OPEN_PACKET_NAME,
        HTTP_OPEN_PACKET_NAME_LENGTH + 1
        );

    pOpenPacket =
        (PHTTP_OPEN_PACKET)( pEaBuffer->EaName + pEaBuffer->EaNameLength + 1 );

    pOpenPacket->MajorVersion = HTTP_INTERFACE_VERSION_MAJOR;
    pOpenPacket->MinorVersion = HTTP_INTERFACE_VERSION_MINOR;

    //
    // Build the device name.
    //

    if (HandleType == HttpApiControlChannelHandleType)
    {
        //
        // It's a control channel, so just use the appropriate device name.
        //

        wcscpy( deviceNameBuffer, HTTP_CONTROL_DEVICE_NAME );
    }
    else
    {
        if (HandleType == HttpApiFilterChannelHandleType)
        {
            //
            // It's a fitler channel, so start with the appropriate
            // device name.
            //

            wcscpy( deviceNameBuffer, HTTP_FILTER_DEVICE_NAME );
        }
        else
        {
            ASSERT(HandleType == HttpApiAppPoolHandleType);

            //
            // It's an app pool, so start with the appropriate device name.
            //

            wcscpy( deviceNameBuffer, HTTP_APP_POOL_DEVICE_NAME );

            //
            // Set WRITE_OWNER in DesiredAccess if AppPool is a controller.
            //

            if ((Options & HTTP_OPTION_CONTROLLER))
            {
                DesiredAccess |= WRITE_OWNER;
            }
        }
        
        if (pObjectName != NULL )
        {
            //
            // It's a named object, so append a slash and the name,
            // but first check to ensure we don't overrun our buffer.
            //

            if ((wcslen(deviceNameBuffer) + wcslen(pObjectName) + 2)
                    > DIMENSION(deviceNameBuffer))
            {
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }

            wcscat( deviceNameBuffer, L"\\" );
            wcscat( deviceNameBuffer, pObjectName );
        }
    }

    //
    // Determine the share access and create options based on the
    // Flags parameter.
    //

    shareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
    createOptions = 0;

    if ((Options & HTTP_OPTION_OVERLAPPED) == 0)
    {
        createOptions |= FILE_SYNCHRONOUS_IO_NONALERT;
    }

    //
    // Build the object attributes.
    //

    RtlInitUnicodeString( &deviceName, deviceNameBuffer );

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        &deviceName,                            // ObjectName
        OBJ_CASE_INSENSITIVE,                   // Attributes
        NULL,                                   // RootDirectory
        NULL,                                   // SecurityDescriptor
        );

    if (pSecurityAttributes != NULL)
    {
        objectAttributes.SecurityDescriptor =
            pSecurityAttributes->lpSecurityDescriptor;

        if (pSecurityAttributes->bInheritHandle)
        {
            objectAttributes.Attributes |= OBJ_INHERIT;
        }
    }

    //
    // Open the UL device.
    //

    status = NtCreateFile(
                pHandle,                        // FileHandle
                DesiredAccess,                  // DesiredAccess
                &objectAttributes,              // ObjectAttributes
                &ioStatusBlock,                 // IoStatusBlock
                NULL,                           // AllocationSize
                0,                              // FileAttributes
                shareAccess,                    // ShareAccess
                CreateDisposition,              // CreateDisposition
                createOptions,                  // CreateOptions
                pEaBuffer,                      // EaBuffer
                EA_BUFFER_LENGTH                // EaLength
                );

complete:

    if (!NT_SUCCESS(status))
    {
        *pHandle = NULL;
    }

    return status;

} // HttpApiOpenDriverHelper


/***************************************************************************++

Routine Description:

    Acquires a short-term event from the global event cache. This event
    object may only be used for pseudo-synchronous I/O.

Arguments:

    ppCachedEvent - Receives pointer to cached event structure

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
HttpApiAcquireCachedEvent(
    OUT CACHED_EVENT ** ppCachedEvent
    )
{
    PSINGLE_LIST_ENTRY      Entry;
    NTSTATUS                status;
    CACHED_EVENT *          pCachedEvent;
    
    Entry = RtlInterlockedPopEntrySList( &CachedEventList );
    if (Entry != NULL)
    {
        pCachedEvent = CONTAINING_RECORD( Entry, CACHED_EVENT, ListEntry );
    }
    else
    {
        pCachedEvent = ALLOC_MEM( sizeof( CACHED_EVENT ) );
        if (pCachedEvent == NULL)
        {
            return STATUS_NO_MEMORY;
        }

        status = NtCreateEvent(
                     &(pCachedEvent->EventHandle),      // EventHandle
                     EVENT_ALL_ACCESS,                  // DesiredAccess
                     NULL,                              // ObjectAttributes
                     SynchronizationEvent,              // EventType
                     FALSE                              // InitialState
                     );
                     
        if (!NT_SUCCESS( status ))
        {
            FREE_MEM( pCachedEvent );
            return status;   
        }
    }

    *ppCachedEvent = pCachedEvent;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Releases a cached event acquired via HttpApiAcquireCachedEvent().

Arguments:

    Event - Supplies the cached event to release

--***************************************************************************/
VOID
HttpApiReleaseCachedEvent(
    IN CACHED_EVENT * pCachedEvent
    )
{
    RtlInterlockedPushEntrySList( &CachedEventList,
                                  &pCachedEvent->ListEntry );
} // HttpApiReleaseCachedEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\makefile.inc ===
$(O)\ulapi.res: ulapi.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\filter.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    filter.c

Abstract:

    User-mode interface to UL.SYS.

Author:

    Michael Courage (mcourage)   17-Mar-2000

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Opens a filter channel to UL.SYS.

Arguments:

    pFilterHandle - Receives a handle to the new filter object.

    pFilterName - Supplies the name of the new filter.

    pSecurityAttributes - Optionally supplies security attributes for
        the new filter.

    Options - Supplies creation options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpCreateFilter(
    OUT PHANDLE pFilterHandle,
    IN PCWSTR pFilterName,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiOpenDriverHelper(
                    pFilterHandle,              // pHandle
                    GENERIC_READ |              // DesiredAccess
                        GENERIC_WRITE |
                        SYNCHRONIZE,
                    HttpApiFilterChannelHandleType, // HandleType
                    pFilterName,                // pObjectName
                    Options,                    // Options
                    FILE_CREATE,                // CreateDisposition
                    pSecurityAttributes         // pSecurityAttributes
                    );

    //
    // If we couldn't open the driver because it's not running, then try
    // to start the driver & retry the open.
    //

    if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
        status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        if (HttpApiTryToStartDriver())
        {
            status = HttpApiOpenDriverHelper(
                            pFilterHandle,              // pHandle
                            GENERIC_READ |              // DesiredAccess
                                GENERIC_WRITE |
                                SYNCHRONIZE,
                            HttpApiFilterChannelHandleType, // HandleType
                            pFilterName,                // pObjectName
                            Options,                    // Options
                            FILE_CREATE,                // CreateDisposition
                            pSecurityAttributes         // pSecurityAttributes
                            );
        }
    }

    return HttpApiNtStatusToWin32Status( status );

} // HttpApiCreateFilter



/***************************************************************************++

Routine Description:

    Opens an existing filter channel.

Arguments:

    pFilterHandle - Receives a handle to the new filter object.

    pFilterName - Supplies the name of the new filter.

    Options - Supplies open options.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpOpenFilter(
    OUT PHANDLE pFilterHandle,
    IN PCWSTR pFilterName,
    IN ULONG Options
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiOpenDriverHelper(
                    pFilterHandle,              // pHandle
                    GENERIC_READ |              // DesiredAccess
                        SYNCHRONIZE,
                    HttpApiFilterChannelHandleType, // HandleType
                    pFilterName,                // pObjectName
                    Options,                    // Options
                    FILE_OPEN,                  // CreateDisposition
                    NULL                        // pSecurityAttributes
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpApiOpenFilter



/***************************************************************************++

Routine Description:

    Accepts a new connection from the network, and optionally receives
    some data from that connection.

Arguments:

    FilterHandle - the filter channel
    pRawConnectionInfo - returns information about the accepted connection
    RawConnectionInfoSize - size of the raw info buffer
    pBytesReceived - returns the number of bytes received
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterAccept(
    IN HANDLE FilterHandle,
    OUT PHTTP_RAW_CONNECTION_INFO pRawConnectionInfo,
    IN ULONG RawConnectionInfoSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    FilterHandle,                   // FileHandle
                    pOverlapped,                    // pOverlapped
                    IOCTL_HTTP_FILTER_ACCEPT,       // IoControlCode
                    NULL,                           // pInputBuffer
                    0,                              // InputBufferLength
                    pRawConnectionInfo,             // pOutputBuffer
                    RawConnectionInfoSize,          // OutputBufferLength
                    pBytesReceived                  // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );
    
} // HttpFilterAccept


/***************************************************************************++

Routine Description:

    Closes a connection that was accepted with HttpFilterAccept.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the connection to close
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterClose(
    IN HANDLE FilterHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    FilterHandle,                   // FileHandle
                    pOverlapped,                    // pOverlapped
                    IOCTL_HTTP_FILTER_CLOSE,        // IoControlCode
                    &ConnectionId,                  // pInputBuffer
                    sizeof(ConnectionId),           // InputBufferLength
                    NULL,                           // pOutputBuffer
                    0,                              // OutputBufferLength
                    NULL                            // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );
    
} // HttpFilterClose


/***************************************************************************++

Routine Description:

    Reads data from a connection that was accepted with HttpFilterAccept.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the connection to read
    pBuffer - that's where we put the data
    BufferSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes read
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterRawRead(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    OUT PVOID pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    FilterHandle,                   // FileHandle
                    pOverlapped,                    // pOverlapped
                    IOCTL_HTTP_FILTER_RAW_READ,     // IoControlCode
                    &ConnectionId,                  // pInputBuffer
                    sizeof(ConnectionId),           // InputBufferLength
                    pBuffer,                        // pOutputBuffer
                    BufferSize,                     // OutputBufferLength
                    pBytesReceived                  // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpFilterRawRead


/***************************************************************************++

Routine Description:

    Writes data to a connection that was accepted with HttpFilterAccept.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the raw connection
    pBuffer - data to write
    BufferSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes written
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterRawWrite(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN PVOID pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    FilterHandle,                   // FileHandle
                    pOverlapped,                    // pOverlapped
                    IOCTL_HTTP_FILTER_RAW_WRITE,    // IoControlCode
                    &ConnectionId,                  // pInputBuffer
                    sizeof(ConnectionId),           // InputBufferLength
                    pBuffer,                        // pOutputBuffer
                    BufferSize,                     // OutputBufferLength
                    pBytesReceived                  // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );
} // HttpFilterRawWrite


/***************************************************************************++

Routine Description:

    Reads unfiltered data (or other requests like cert renegotiation) into
    the filter process from the http app.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the raw connection
    pBuffer - this is the buffer where we put the data
    BufferSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes written
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterAppRead(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    OUT PHTTP_FILTER_BUFFER pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;

    ASSERT(pBuffer);

    //
    // Store the ID in pBuffer.
    //

    pBuffer->Reserved = ConnectionId;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    FilterHandle,                   // FileHandle
                    pOverlapped,                    // pOverlapped
                    IOCTL_HTTP_FILTER_APP_READ,     // IoControlCode
                    pBuffer,                        // pInputBuffer
                    sizeof(HTTP_FILTER_BUFFER),     // InputBufferLength
                    pBuffer->pBuffer,               // pOutputBuffer
                    pBuffer->BufferSize,            // OutputBufferLength
                    pBytesReceived                  // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );
    
} // HttpFilterAppRead


/***************************************************************************++

Routine Description:

    Writes filtered data back to a connection. That data will be parsed
    and routed to an application pool.

Arguments:

    FilterHandle - the filter channel
    ConnectionId - ID of the raw connection
    pBuffer - data to write
    BufferSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes written
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpFilterAppWrite(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN PHTTP_FILTER_BUFFER pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;

    ASSERT(pBuffer);

    //
    // Store the ID in pBuffer.
    //

    pBuffer->Reserved = ConnectionId;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    FilterHandle,                   // FileHandle
                    pOverlapped,                    // pOverlapped
                    IOCTL_HTTP_FILTER_APP_WRITE,    // IoControlCode
                    pBuffer,                        // pInputBuffer
                    sizeof(HTTP_FILTER_BUFFER),     // InputBufferLength
                    pBuffer->pBuffer,               // pOutputBuffer
                    pBuffer->BufferSize,            // OutputBufferLength
                    pBytesReceived                  // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpFilterAppWrite


/***************************************************************************++

Routine Description:

    Asks the filter process to renegotiate the SSL connection to get a
    client certificate. The certificate is optionally mapped to a token.
    The resulting cert info and token are copied into the callers buffer.

Arguments:

    AppPoolHandle - the application pool
    ConnectionId - ID of the http connection
    Flags - valid flag is HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP
    pSslClientCertInfo - the buffer that receives cert info
    SslClientCertInfoSize - that's how big the buffer is
    pBytesReceived - gets the number of bytes written
    pOverlapped - y'know

--***************************************************************************/
ULONG
WINAPI
HttpReceiveClientCertificate(
    IN HANDLE AppPoolHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN ULONG Flags,
    OUT PHTTP_SSL_CLIENT_CERT_INFO pSslClientCertInfo,
    IN ULONG SslClientCertInfoSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped
    )
{
    NTSTATUS status;
    HTTP_FILTER_RECEIVE_CLIENT_CERT_INFO receiveCertInfo;

    //
    // Initialize the input structure.
    //

    receiveCertInfo.ConnectionId = ConnectionId;
    receiveCertInfo.Flags = Flags;
    
    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    AppPoolHandle,                  // FileHandle
                    pOverlapped,                    // pOverlapped
                    IOCTL_HTTP_FILTER_RECEIVE_CLIENT_CERT,  // IoControlCode
                    &receiveCertInfo,               // pInputBuffer
                    sizeof(receiveCertInfo),        // InputBufferLength
                    pSslClientCertInfo,             // pOutputBuffer
                    SslClientCertInfoSize,          // OutputBufferLength
                    pBytesReceived                  // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpReceiveClientCertificate

//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\apoolp.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    apoolp.h

Abstract:

    The private definitions of app pool module.

Author:

    Paul McDaniel (paulmcd)       28-Jan-1999


Revision History:

--*/


#ifndef _APOOLP_H_
#define _APOOLP_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// A structure for associating app pool processes with
// connections for UlWaitForDisconnect
//

#define IS_VALID_DISCONNECT_OBJECT(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_DISCONNECT_OBJECT_POOL_TAG))

typedef struct _UL_DISCONNECT_OBJECT
{
    ULONG               Signature;  // UL_DISCONNECT_OBJECT_POOL_TAG

    //
    // Lists for processes and connections
    //
    UL_NOTIFY_ENTRY     ProcessEntry;
    UL_NOTIFY_ENTRY     ConnectionEntry;

    //
    // The WaitForDisconnect IRP
    //
    PIRP                pIrp;

} UL_DISCONNECT_OBJECT, *PUL_DISCONNECT_OBJECT;

//
// Internal helper functions used in the module
//

VOID
UlpCancelDemandStart(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

VOID
UlpCancelDemandStartWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCancelHttpReceive(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

VOID
UlpCancelHttpReceiveWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

PIRP
UlpPopNewIrp(
    IN PUL_APP_POOL_OBJECT     pAppPool,
    OUT PUL_APP_POOL_PROCESS *  ppProcess
    );

PIRP
UlpPopIrpFromProcess(
    IN PUL_APP_POOL_PROCESS pProcess
    );

BOOLEAN
UlpIsProcessInAppPool(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_APP_POOL_OBJECT  pAppPool
    );

NTSTATUS
UlpQueueUnboundRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    );

// IRQL == PASSIVE_LEVEL
//
VOID
UlpQueuePendingRequest(
    IN PUL_APP_POOL_PROCESS     pProcess,
    IN PUL_INTERNAL_REQUEST     pRequest
    );

VOID
UlpUnbindQueuedRequests(
    IN PUL_APP_POOL_PROCESS pProcess
    );

VOID
UlpRedeliverRequestWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

BOOLEAN
UlpIsRequestQueueEmpty(
    IN PUL_APP_POOL_PROCESS pProcess
    );

NTSTATUS
UlpSetAppPoolQueueLength(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN LONG                 QueueLength
    );

LONG
UlpGetAppPoolQueueLength(
    IN  PUL_APP_POOL_PROCESS pProcess
    );

VOID
UlpCopyRequestToIrp(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP                 pIrp
    );

//
// functions to manipulate a UL_REQUEST_QUEUE
//
NTSTATUS
UlpInitRequestQueue(
    PUL_REQUEST_QUEUE   pQueue,
    LONG                MaxRequests
    );

NTSTATUS
UlpSetMaxQueueLength(
    PUL_REQUEST_QUEUE   pQueue,
    LONG                MaxRequests
    );

LONG
UlpQueryQueueLength(
    PUL_REQUEST_QUEUE   pQueue
    );

NTSTATUS
UlpQueueRequest(
    PUL_REQUEST_QUEUE       pQueue,
    PUL_INTERNAL_REQUEST    pRequest
    );

VOID
UlpRemoveRequest(
    PUL_REQUEST_QUEUE       pQueue,
    PUL_INTERNAL_REQUEST    pRequest
    );

PUL_INTERNAL_REQUEST
UlpDequeueRequest(
    PUL_REQUEST_QUEUE   pQueue
    );

NTSTATUS
UlpSetAppPoolState(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN HTTP_ENABLED_STATE   Enabled
    );

VOID
UlpCancelWaitForDisconnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelWaitForDisconnectWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

BOOLEAN
UlpNotifyCompleteWaitForDisconnect(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    );

PUL_DISCONNECT_OBJECT
UlpCreateDisconnectObject(
    IN PIRP pIrp
    );

VOID
UlpFreeDisconnectObject(
    IN PUL_DISCONNECT_OBJECT pObject
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _APOOLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\apool.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    apool.h

Abstract:

    The public definition of app pool interfaces.

Author:

    Paul McDaniel (paulmcd)       28-Jan-1999


Revision History:

--*/


#ifndef _APOOL_H_
#define _APOOL_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Kernel mode mappings to the user mode set defined in ulapi.h
//

//
// Forwarders.
//

typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_HTTP_CONNECTION *PUL_HTTP_CONNECTION;
typedef struct _UL_CONFIG_GROUP_OBJECT *PUL_CONFIG_GROUP_OBJECT;


//
// this structure contains a queue of HTTP_REQUEST objects
// CODEWORK: investigate using an NBQUEUE instead
//

typedef struct _UL_REQUEST_QUEUE
{
    LONG        RequestCount;
    LONG        MaxRequests;
    LIST_ENTRY  RequestHead;

} UL_REQUEST_QUEUE, *PUL_REQUEST_QUEUE;


//
// This structure represents an internal app pool object
//

#define IS_VALID_AP_OBJECT(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_APP_POOL_OBJECT_POOL_TAG) && ((pObject)->RefCount > 0))

typedef struct _UL_APP_POOL_OBJECT
{
    //
    // NonPagedPool
    //

    //
    // lock that protects NewRequestQueue, PendingRequestQueue
    // for each attached process and queue state of the request
    //
    // ensure it on cache-line and use InStackQueuedSpinLock for
    // better performance
    //
    UL_SPIN_LOCK            QueueSpinLock;

    //
    // UL_APP_POOL_OBJECT_POOL_TAG
    //
    ULONG                   Signature;

    //
    // Ref count for this app pool
    //
    LONG                    RefCount;

    //
    // links all apool objects, anchored by g_AppPoolListHead
    //
    LIST_ENTRY              ListEntry;

    //
    // Locks lists on the app pool & process objects, is refcounted and
    // given to the HTTP_REQUEST object to synchronize access to process
    // objects when connections drop and the request(s) need to be released
    //
    PUL_NONPAGED_RESOURCE   pResource;

    //
    // A apool wide new request list (when no irps are available)
    //
    UL_REQUEST_QUEUE        NewRequestQueue;

    //
    // the demand start irp (OPTIONAL)
    //
    PIRP                    pDemandStartIrp;
    PEPROCESS               pDemandStartProcess;

    //
    // the list of processes bound to this app pool
    //
    LIST_ENTRY              ProcessListHead;

    PSECURITY_DESCRIPTOR    pSecurityDescriptor;

    //
    // List of transient config groups
    //
    UL_NOTIFY_HEAD          TransientHead;

    //
    // the length of pName
    //
    ULONG                   NameLength;

    //
    // number of active processes in the AppPool, used to decide if binding
    // is necessary
    //
    ULONG                   NumberActiveProcesses;

    //
    // Only route requests to this AppPool if it's marked active
    //
    HTTP_ENABLED_STATE      Enabled;

    //
    // the apool's name
    //
    WCHAR                   pName[0];

} UL_APP_POOL_OBJECT, *PUL_APP_POOL_OBJECT;


//
// The structure representing a process bound to an app pool.
//

#define IS_VALID_AP_PROCESS(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_APP_POOL_PROCESS_POOL_TAG))

typedef struct _UL_APP_POOL_PROCESS
{
    //
    // NonPagedPool
    //

    //
    // UL_APP_POOL_PROCESS_POOL_TAG
    //
    ULONG                   Signature;

    //
    // set if we are in cleanup. You must check this flag before attaching
    // any IRPs to the process.
    //
    ULONG                   InCleanup : 1;

    //
    // set if process is attached with the HTTP_OPTION_CONTROLLER option
    //
    ULONG                   Controller : 1;

    //
    // used to link into the apool object
    //
    LIST_ENTRY              ListEntry;

    //
    // points to the app pool this process belongs
    //
    PUL_APP_POOL_OBJECT     pAppPool;

    //
    // a list of pending IRP(s) waiting to receive new requests
    //
    LIST_ENTRY              NewIrpHead;

    //
    // lock that protects the above list
    //
    UL_SPIN_LOCK            NewIrpSpinLock;

    //
    // links requests that would not fit in a irp buffer and need to wait for
    // the larger buffer
    //
    // and
    //
    // requests that this process is working on and need
    // i/o cancellation if the process detaches from the apool
    //
    UL_REQUEST_QUEUE        PendingRequestQueue;

    //
    // Pointer to the actual process (for debugging)
    //
    PEPROCESS               pProcess;

    //
    // List of pending "wait for disconnect" IRPs.
    //
    UL_NOTIFY_HEAD          WaitForDisconnectHead;

} UL_APP_POOL_PROCESS, *PUL_APP_POOL_PROCESS;


// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlAttachProcessToAppPool(
    IN  PWCHAR                          pName OPTIONAL,
    IN  ULONG                           NameLength,
    IN  BOOLEAN                         Create,
    IN  PACCESS_STATE                   pAccessState,
    IN  ACCESS_MASK                     DesiredAccess,
    IN  KPROCESSOR_MODE                 RequestorMode,
    OUT PUL_APP_POOL_PROCESS *          ppProcess
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlDetachProcessFromAppPool(
    IN  PUL_APP_POOL_PROCESS            pProcess
    );

// IRQL == PASSIVE_LEVEL
//
#if REFERENCE_DEBUG
VOID
UlReferenceAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    );
#else
__inline
VOID
FASTCALL
UlReferenceAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    )
{
    InterlockedIncrement(&pAppPool->RefCount);
}
#endif

#define REFERENCE_APP_POOL( papp )                                          \
    UlReferenceAppPool(                                                     \
        (papp)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

// IRQL == PASSIVE_LEVEL
//
VOID
UlDeleteAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DELETE_APP_POOL( papp )                                             \
    UlDeleteAppPool(                                                        \
        (papp)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#if REFERENCE_DEBUG
VOID
UlDereferenceAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    );
#else
__inline
VOID
FASTCALL
UlDereferenceAppPool(
    IN  PUL_APP_POOL_OBJECT             pAppPool
    )
{
    if (InterlockedDecrement(&pAppPool->RefCount) == 0)
    {
        UlDeleteAppPool(pAppPool);
    }
}
#endif

#define DEREFERENCE_APP_POOL( papp )                                        \
    UlDereferenceAppPool(                                                   \
        (papp)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlQueryAppPoolInformation(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    OUT PVOID                           pAppPoolInformation,
    IN  ULONG                           Length,
    OUT PULONG                          pReturnLength OPTIONAL
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlSetAppPoolInformation(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    IN  PVOID                           pAppPoolInformation,
    IN  ULONG                           Length
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlWaitForDemandStart(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  PIRP                            pIrp
    );


// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlReceiveHttpRequest(
    IN  HTTP_REQUEST_ID                 RequestId,
    IN  ULONG                           Flags,
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  PIRP                            pIrp
    );


// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlDeliverRequestToProcess(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlUnlinkRequestFromProcess(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlGetPoolFromHandle(
    IN HANDLE                           hAppPool,
    OUT PUL_APP_POOL_OBJECT *           ppAppPool
    );


NTSTATUS
UlInitializeAP(
    VOID
    );

VOID
UlTerminateAP(
    VOID
    );

PUL_APP_POOL_PROCESS
UlCreateAppPoolProcess(
    PUL_APP_POOL_OBJECT pObject
    );

VOID
UlFreeAppPoolProcess(
    PUL_APP_POOL_PROCESS pProcess
    );

PUL_APP_POOL_OBJECT
UlAppPoolObjectFromProcess(
    PUL_APP_POOL_PROCESS pProcess
    );

VOID
UlLinkConfigGroupToAppPool(
    IN PUL_CONFIG_GROUP_OBJECT pConfigGroup,
    IN PUL_APP_POOL_OBJECT pAppPool
    );

NTSTATUS
UlWaitForDisconnect(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_HTTP_CONNECTION  pHttpConn,
    IN PIRP pIrp
    );

VOID
UlCompleteAllWaitForDisconnect(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );

NTSTATUS
UlpCopyRequestToBuffer(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR pKernelBuffer,
    IN PVOID pUserBuffer,
    IN ULONG BufferLength,
    IN PUCHAR pEntityBody,
    IN ULONG EntityBodyLength
    );

PUL_INTERNAL_REQUEST
UlpDequeueNewRequest(
    IN PUL_APP_POOL_PROCESS pProcess
    );

__inline
NTSTATUS
FASTCALL
UlpComputeRequestBytesNeeded(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PULONG pBytesNeeded
    )
{
    NTSTATUS Status;
    ULONG SslInfoSize;

    //
    // Calculate the size needed for the request, we'll need it below.
    //

    *pBytesNeeded =
        sizeof(HTTP_REQUEST) +
        pRequest->TotalRequestSize +
        (pRequest->UnknownHeaderCount * sizeof(HTTP_UNKNOWN_HEADER));

    //
    // Include additional space for the local and remote addresses.
    //
    // CODEWORK: Make this transport independent.
    //

    *pBytesNeeded += sizeof(HTTP_NETWORK_ADDRESS_IPV4) * 2;

    //
    // Include space for any SSL information.
    //

    if (pRequest->pHttpConn->SecureConnection)
    {
        Status = UlGetSslInfo(
                        &pRequest->pHttpConn->pConnection->FilterInfo,
                        0,                      // BufferSize
                        NULL,                   // pUserBuffer
                        NULL,                   // pBuffer
                        &SslInfoSize            // pBytesNeeded
                        );

        if (NT_SUCCESS(Status))
        {
            //
            // Struct must be aligned; add some slop space
            //

            *pBytesNeeded = ALIGN_UP(*pBytesNeeded, PVOID);
            *pBytesNeeded += SslInfoSize;
        }
        else
        {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _APOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\apool.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    apool.cxx

Abstract:

    Note that most of the routines in this module assume they are called
    at PASSIVE_LEVEL.

Author:

    Paul McDaniel (paulmcd)       28-Jan-1999

Revision History:

--*/


#include "precomp.h"        // project wide headers
#include "apoolp.h"         // private header

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeAP )
#pragma alloc_text( PAGE, UlTerminateAP )

#pragma alloc_text( PAGE, UlAttachProcessToAppPool )
#pragma alloc_text( PAGE, UlDeliverRequestToProcess )

#if REFERENCE_DEBUG
#pragma alloc_text( PAGE, UlDereferenceAppPool )
#pragma alloc_text( PAGE, UlReferenceAppPool )
#endif

#pragma alloc_text( PAGE, UlDeleteAppPool )
#pragma alloc_text( PAGE, UlGetPoolFromHandle )
#pragma alloc_text( PAGE, UlQueryAppPoolInformation )
#pragma alloc_text( PAGE, UlSetAppPoolInformation )
#pragma alloc_text( PAGE, UlpSetAppPoolState )
#pragma alloc_text( PAGE, UlWaitForDemandStart )
#pragma alloc_text( PAGE, UlAppPoolObjectFromProcess )
#pragma alloc_text( PAGE, UlLinkConfigGroupToAppPool )

#pragma alloc_text( PAGE, UlpCancelDemandStartWorker )
#pragma alloc_text( PAGE, UlpCancelHttpReceiveWorker )

#pragma alloc_text( PAGE, UlpCopyRequestToIrp )
#pragma alloc_text( PAGE, UlpCopyRequestToBuffer )
#pragma alloc_text( PAGE, UlpPopNewIrp )
#pragma alloc_text( PAGE, UlpIsProcessInAppPool )
#pragma alloc_text( PAGE, UlpRedeliverRequestWorker )
#pragma alloc_text( PAGE, UlpIsRequestQueueEmpty )
#pragma alloc_text( PAGE, UlpSetAppPoolQueueLength )
#pragma alloc_text( PAGE, UlpGetAppPoolQueueLength )


#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlDetachProcessFromAppPool
NOT PAGEABLE -- UlReceiveHttpRequest
NOT PAGEABLE -- UlUnlinkRequestFromProcess
NOT PAGEABLE -- UlWaitForDisconnect

NOT PAGEABLE -- UlpPopIrpFromProcess
NOT PAGEABLE -- UlpQueuePendingRequest
NOT PAGEABLE -- UlpQueueUnboundRequest
NOT PAGEABLE -- UlpDequeueNewRequest
NOT PAGEABLE -- UlpUnbindQueuedRequests

NOT PAGEABLE -- UlCompleteAllWaitForDisconnect
NOT PAGEABLE -- UlpCancelDemandStart
NOT PAGEABLE -- UlpCancelHttpReceive
NOT PAGEABLE -- UlpCancelWaitForDisconnect
#endif


//
// Globals
//

LIST_ENTRY  g_AppPoolListHead = {NULL,NULL};
BOOLEAN     g_InitAPCalled = FALSE;


/***************************************************************************++

Routine Description:

    creates a new process object and attaches it to an apool .

    called by handle create and returns the process object to attach to the
    handle.

Arguments:

    pName - the name of the apool to attach to.

    NameLength - the byte count of pName.

    Create - whether or not a new apool should be created if pName does not
        exist.

    pAccessState -
    DesiredAccess -
    RequestorMode -

    ppProcess - returns the newly created PROCESS object.


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAttachProcessToAppPool(
    IN PWCHAR                   pName OPTIONAL,
    IN ULONG                    NameLength,
    IN BOOLEAN                  Create,
    IN PACCESS_STATE            pAccessState,
    IN ACCESS_MASK              DesiredAccess,
    IN KPROCESSOR_MODE          RequestorMode,
    OUT PUL_APP_POOL_PROCESS *  ppProcess
    )
{
    NTSTATUS                Status;
    PUL_APP_POOL_OBJECT     pObject = NULL;
    PUL_APP_POOL_PROCESS    pProcess = NULL;
    LIST_ENTRY *            pEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppProcess != NULL);

    Status = STATUS_SUCCESS;
    *ppProcess = NULL;


    //
    // try and find an existing app pool of this name
    //

    //
    // CODEWORK:  try and grab the lock shared first then upgrade to
    // exclusive if we need to create.
    //
    // also potentially pre-allocate the memory.
    //
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->AppPoolResource, TRUE);

    if (pName != NULL)
    {
        pEntry = g_AppPoolListHead.Flink;

        while (pEntry != &g_AppPoolListHead)
        {
            pObject = CONTAINING_RECORD(
                            pEntry,
                            UL_APP_POOL_OBJECT,
                            ListEntry
                            );

            if (pObject->NameLength == NameLength &&
                _wcsnicmp(pObject->pName, pName, NameLength/sizeof(WCHAR)) == 0)
            {
                //
                // match!
                //
                break;
            }

            pEntry = pEntry->Flink;
        }

        //
        // found 1?
        //
        if (pEntry == &g_AppPoolListHead)
        {
            pObject = NULL;
        }

    }

    //
    // Found 1?
    //

    if (pObject == NULL)
    {
        //
        // nope, allowed to create?
        //

        if (!Create)
        {
            UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto end;
        }

        //
        // create it
        //

        //
        // allocate the object memory
        //

        pObject = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPoolCacheAligned,
                        UL_APP_POOL_OBJECT,
                        NameLength + sizeof(WCHAR),
                        UL_APP_POOL_OBJECT_POOL_TAG
                        );

        if (pObject == NULL)
        {
            UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        RtlZeroMemory(
            pObject,
            NameLength + sizeof(WCHAR) +
            sizeof(UL_APP_POOL_OBJECT)
            );

        pObject->Signature  = UL_APP_POOL_OBJECT_POOL_TAG;
        pObject->RefCount   = 1;
        pObject->NameLength = NameLength;
        pObject->Enabled    = HttpEnabledStateActive;

        InitializeListHead(&pObject->ProcessListHead);

        UlInitializeNotifyHead(
            &pObject->TransientHead,
            &g_pUlNonpagedData->ConfigGroupResource
            );

        Status = UlpInitRequestQueue(
                        &pObject->NewRequestQueue,
                        DEFAULT_APP_POOL_QUEUE_MAX
                        );

        ASSERT(NT_SUCCESS(Status));     // default size can't be invalid.

        UlInitializeSpinLock(&pObject->QueueSpinLock, "QueueSpinLock");

        //
        // allocate the resource for sync
        //

        pObject->pResource = UlResourceNew(UL_APP_POOL_OBJECT_POOL_TAG);
        if (pObject->pResource == NULL)
        {
            UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        if (pName != NULL)
        {
            RtlCopyMemory(
                pObject->pName,
                pName,
                NameLength + sizeof(WCHAR)
                );
        }

        //
        // Set the security descriptor.
        //

        Status = UlAssignSecurity(
                        &pObject->pSecurityDescriptor,
                        pAccessState
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // Insert it into the global list
        //

        InsertHeadList(&g_AppPoolListHead, &pObject->ListEntry);

        UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);

        UlTrace(
            REFCOUNT,
            ("ul!UlAttachProcessToAppPool ap=%p refcount=%d\n",
                pObject,
                pObject->RefCount)
            );

    }
    else // if (pObject == NULL)
    {
        //
        // reference it
        //

        REFERENCE_APP_POOL( pObject );

        //
        // let the lock go
        //

        UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);

        //
        // we found one.  were we trying to create?
        //

        if (Create)
        {
            Status = STATUS_OBJECT_NAME_COLLISION;
            goto end;
        }

        //
        // Perform an access check against the app pool.
        //

        Status = UlAccessCheck(
                        pObject->pSecurityDescriptor,
                        pAccessState,
                        DesiredAccess,
                        RequestorMode,
                        pName
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
    }

    //
    // Create a process entry for it
    //

    pProcess = UlCreateAppPoolProcess(pObject);

    if (pProcess == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    //
    // put it in the app pool list
    //

    UlAcquireResourceExclusive(&pObject->pResource->Resource, TRUE);

    if (DesiredAccess & WRITE_OWNER)
    {
        pProcess->Controller = 1;
    }
    else
    {
        pObject->NumberActiveProcesses++;
    }

    InsertHeadList(&pObject->ProcessListHead, &pProcess->ListEntry);

    UlReleaseResource(&pObject->pResource->Resource);

    //
    // Return it
    //

    *ppProcess = pProcess;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pObject != NULL)
        {
            DEREFERENCE_APP_POOL(pObject);
            pObject = NULL;
        }
        if (pProcess != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pProcess, UL_APP_POOL_PROCESS_POOL_TAG);
        }
    }
    return Status;
}


/***************************************************************************++

Routine Description:

    this is called by UlCleanup when the handle count goes to 0.  it removes
    the PROCESS object from the apool, cancelling all i/o .

Arguments:

    pProcess - the process to detach.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDetachProcessFromAppPool(
    IN PUL_APP_POOL_PROCESS     pProcess
    )
{
    LIST_ENTRY PendingRequestHead;
    PUL_APP_POOL_OBJECT pAppPool;
    NTSTATUS CancelStatus = STATUS_CANCELLED;
    PUL_INTERNAL_REQUEST pRequest;
    KLOCK_QUEUE_HANDLE LockHandle;

    UlTrace(ROUTING, (
        "ul!UlDetachProcessFromAppPool(%p, %S)\n",
        pProcess,
        pProcess->pAppPool->pName
        ));

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    pAppPool = pProcess->pAppPool;
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    UlAcquireResourceExclusive(&pAppPool->pResource->Resource, TRUE);

    //
    // Mark the process as InCleanup so new I/O won't be attached
    //

    ASSERT( !pProcess->InCleanup );
    pProcess->InCleanup = 1;

    //
    // Unlink from the App Pool list.
    //

    RemoveEntryList(&pProcess->ListEntry);
    pProcess->ListEntry.Flink = pProcess->ListEntry.Blink = NULL;

    //
    // Kill our transient URL bindings
    //
    UlNotifyAllEntries(
        UlNotifyOrphanedConfigGroup,
        &pProcess->pAppPool->TransientHead,
        NULL
        );

    //
    // cancel any pending io.
    //

    if (pAppPool->pDemandStartIrp != NULL &&
        pAppPool->pDemandStartProcess == PsGetCurrentProcess())
    {
        if (IoSetCancelRoutine(pAppPool->pDemandStartIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // no need to complete it
            //
        }
        else
        {
            IoGetCurrentIrpStackLocation(
                pAppPool->pDemandStartIrp
                )->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pAppPool->pDemandStartIrp->IoStatus.Status = STATUS_CANCELLED;
            pAppPool->pDemandStartIrp->IoStatus.Information = 0;

            UlCompleteRequest(pAppPool->pDemandStartIrp, g_UlPriorityBoost);
        }

        pAppPool->pDemandStartIrp = NULL;
        pAppPool->pDemandStartProcess = NULL;
    }

    while (IsListEmpty(&pProcess->NewIrpHead) == FALSE)
    {
        PLIST_ENTRY pEntry;
        PIRP pIrp;

        //
        // Pop it off the list.
        //

        pEntry = RemoveHeadList(&pProcess->NewIrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looping
            //

            pIrp = NULL;

        }
        else
        {
            PUL_APP_POOL_OBJECT pProcessAppPool;

            //
            // cancel it.  even if pIrp->Cancel == TRUE we are supposed to
            // complete it, our cancel routine will never run.
            //

            pProcessAppPool = (PUL_APP_POOL_OBJECT)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pProcessAppPool == pAppPool);

            DEREFERENCE_APP_POOL(pProcessAppPool);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, g_UlPriorityBoost);
            pIrp = NULL;
        }
    }

    //
    // cancel I/O and move requests to local list
    //
    InitializeListHead(&PendingRequestHead);

    UlAcquireInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

    while (pRequest = UlpDequeueRequest(&pProcess->PendingRequestQueue))
    {
        //
        // move the entry to local list so we can close its
        // connection outside the app pool lock
        //
        InsertTailList(&PendingRequestHead, &pRequest->AppPool.AppPoolEntry);
    }

    UlReleaseInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

    //
    // tank any queued new requests
    //
    UlpUnbindQueuedRequests(pProcess);

    //
    // adjust number of active processes
    //
    if (!pProcess->Controller)
    {
        pAppPool->NumberActiveProcesses--;
    }

    UlReleaseResource(&pAppPool->pResource->Resource);

    //
    // close connections associated with the requests
    //
    while ( !IsListEmpty(&PendingRequestHead) )
    {
        PLIST_ENTRY             pEntry;
        PUL_INTERNAL_REQUEST    pRequest;
        NTSTATUS                Status;

        pEntry = RemoveHeadList(&PendingRequestHead);
        pEntry->Flink = pEntry->Blink = NULL;

        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));


        UlTrace(ROUTING, (
            "ul!UlDetachProcessFromAppPool(%p, %S): tanking pending req=%p\n",
            pProcess,
            pAppPool->pName,
            pRequest
            ));

        //
        // cancel any pending io
        //

        UlAcquireResourceExclusive(&(pRequest->pHttpConn->Resource), TRUE);

        UlCancelRequestIo(pRequest);

        UlReleaseResource(&(pRequest->pHttpConn->Resource));

        //
        // abort the connection this request is associated with
        //

        Status = UlCloseConnection(
                        pRequest->pHttpConn->pConnection,
                        TRUE,
                        NULL,
                        NULL
                        );

        CHECK_STATUS(Status);

        //
        // drop our list's reference
        //
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    ASSERT( IsListEmpty(&PendingRequestHead) );

    //
    // Cancel any remaining WaitForDisconnect IRPs
    //
    UlAcquireResourceExclusive( &g_pUlNonpagedData->DisconnectResource, TRUE );

    UlNotifyAllEntries(
        UlpNotifyCompleteWaitForDisconnect,
        &pProcess->WaitForDisconnectHead,
        &CancelStatus
        );

    UlReleaseResource( &g_pUlNonpagedData->DisconnectResource );

    //
    // Dereference
    //

    DEREFERENCE_APP_POOL(pAppPool);

    //
    // Kill any cache entries related to this process
    //
    UlFlushCacheByProcess(pProcess);


    return STATUS_SUCCESS;
}


#if REFERENCE_DEBUG
/***************************************************************************++

Routine Description:

    increments the refcount.

Arguments:

    pAppPool - the object to increment.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlReferenceAppPool(
    IN PUL_APP_POOL_OBJECT pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    refCount = InterlockedIncrement( &pAppPool->RefCount );

    WRITE_REF_TRACE_LOG(
        g_pAppPoolTraceLog,
        REF_ACTION_REFERENCE_APP_POOL,
        refCount,
        pAppPool,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("ul!UlReferenceAppPool ap=%p refcount=%d\n",
            pAppPool,
            refCount)
        );

}   // UlReferenceAppPool


/***************************************************************************++

Routine Description:

    decrements the refcount.  if it hits 0, destruct's the apool, cancelling
    all i/o and dumping all queued requests.

Arguments:

    pAppPool - the object to decrement.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlDereferenceAppPool(
    IN PUL_APP_POOL_OBJECT pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    refCount = InterlockedDecrement( &pAppPool->RefCount );

    //
    // Tracing.
    //
    WRITE_REF_TRACE_LOG(
        g_pAppPoolTraceLog,
        REF_ACTION_DEREFERENCE_APP_POOL,
        refCount,
        pAppPool,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("ul!UlDereferenceAppPool ap=%p refcount=%d\n",
            pAppPool,
            refCount)
        );

    //
    // Clean up if necessary.
    //

    if (refCount == 0)
    {
        DELETE_APP_POOL(pAppPool);
    }

}   // UlDereferenceAppPool
#endif


/***************************************************************************++

Routine Description:

    decrements the refcount.  if it hits 0, destruct's the apool, cancelling
    all i/o and dumping all queued requests.

Arguments:

    pAppPool - the object to decrement.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlDeleteAppPool(
    IN PUL_APP_POOL_OBJECT pAppPool
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUL_INTERNAL_REQUEST pRequest;

    UlAcquireResourceExclusive(&g_pUlNonpagedData->AppPoolResource, TRUE);

    RemoveEntryList(&pAppPool->ListEntry);
    pAppPool->ListEntry.Flink = pAppPool->ListEntry.Blink = NULL;

    UlReleaseResource(&g_pUlNonpagedData->AppPoolResource);

    ASSERT( UlDbgResourceUnownedExclusive( &pAppPool->pResource->Resource ) );

    //
    // there better not be any process objects hanging around
    //

    ASSERT(IsListEmpty(&pAppPool->ProcessListHead));

    //
    // there should not be any transient bindings around
    //
    ASSERT(IsListEmpty(&pAppPool->TransientHead.ListHead));

    //
    // tank any pending reqeusts
    //

    //
    // CODEWORK, BUGBUG:  need to close the connection ?
    //

    while (pRequest = UlpDequeueRequest(&pAppPool->NewRequestQueue))
    {
        //
        // mark it as unlinked and undo references
        //
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    //
    // Cleanup any security descriptor on the object.
    //

    UlDeassignSecurity( &pAppPool->pSecurityDescriptor );

    //
    // delete the resource
    //

    DEREFERENCE_RESOURCE( pAppPool->pResource );
    pAppPool->pResource = NULL;

    // CODEWORK: is this code right?

    UL_FREE_POOL_WITH_SIG(pAppPool, UL_APP_POOL_OBJECT_POOL_TAG);

}   // UlDeleteAppPool

/***************************************************************************++

Routine Description:

    Queries the app-pool queue length. If the supplied output buffer is NULL
    the required length is returned in the optional length argument.

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQueryAppPoolInformation(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    OUT PVOID                           pAppPoolInformation,
    IN  ULONG                           Length,
    OUT PULONG                          pReturnLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    //
    // This shouldn't happen, but just in case
    //

    if (!IS_VALID_AP_PROCESS(pProcess))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Do the action
    //

    switch (InformationClass)
    {
    case HttpAppPoolDemandStartInformation:
    case HttpAppPoolDemandStartFlagInformation:

        Status = STATUS_NOT_IMPLEMENTED;
        break;

    case HttpAppPoolQueueLengthInformation:

        if (pAppPoolInformation == NULL)
        {
            //
            // Return the size needed
            //

            *pReturnLength = sizeof(LONG);
        }

        //
        // check the size of the buffer
        //
        
        else if (Length >= sizeof(LONG)) 
        {                
            //
            // Get the request queue length
            //

            *((PLONG)pAppPoolInformation) = UlpGetAppPoolQueueLength(pProcess);
            *pReturnLength = sizeof(LONG);
        } 
        else 
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case HttpAppPoolStateInformation:

        if (pAppPoolInformation == NULL)
        {
            //
            // Return the size needed
            //

            *pReturnLength = sizeof(HTTP_ENABLED_STATE);
        }
        else if (Length < sizeof(HTTP_ENABLED_STATE))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            PHTTP_ENABLED_STATE pCurrentState =
                ((PHTTP_ENABLED_STATE) pAppPoolInformation);
            PUL_APP_POOL_OBJECT pAppPool = pProcess->pAppPool;

            ASSERT(IS_VALID_AP_OBJECT(pAppPool));

            *pCurrentState = pAppPool->Enabled;

            *pReturnLength = sizeof(HTTP_ENABLED_STATE);
        }

        break;
        
    default:
        // should have been caught in UlQueryAppPoolInformationIoctl
        ASSERT(FALSE);

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return Status;

} // UlQueryAppPoolInformation


/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetAppPoolInformation(
    IN PUL_APP_POOL_PROCESS             pProcess,
    IN HTTP_APP_POOL_INFORMATION_CLASS  InformationClass,
    IN PVOID                            pAppPoolInformation,
    IN ULONG                            Length
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    //
    // check parameters
    //

    // this shouldn't happen, but just in case
    if (!IS_VALID_AP_PROCESS(pProcess)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!pAppPoolInformation) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Do the action
    //
    switch (InformationClass)
    {
    case HttpAppPoolDemandStartInformation:
    case HttpAppPoolDemandStartFlagInformation:

        Status = STATUS_NOT_IMPLEMENTED;
        break;

    case HttpAppPoolQueueLengthInformation:

        //
        // check the size of the buffer
        //
        if (Length >= sizeof(LONG))
        {
            PLONG pQueueLength = (PLONG) pAppPoolInformation;

            //
            // Set the max incoming request queue length
            //
            Status = UlpSetAppPoolQueueLength(pProcess, * pQueueLength);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

        break;
        
    case HttpAppPoolStateInformation:
        if (Length < sizeof(HTTP_ENABLED_STATE))
        {
            Status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            HTTP_ENABLED_STATE NewState =
                *((PHTTP_ENABLED_STATE) pAppPoolInformation);

            if ((NewState != HttpEnabledStateActive)
                && (NewState != HttpEnabledStateInactive))
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                UlpSetAppPoolState(pProcess, NewState);
            }
        }

        break;
        
    default:
    
        // should have been caught in UlSetAppPoolInformationIoctl
        ASSERT(FALSE);

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return Status;
} // UlSetAppPoolInformation


/***************************************************************************++

Routine Description:

    Marks an app pool as active or inactive. If setting to inactive,
    will return immediately 503 on all requests queued to app pool.

Arguments:

    pProcess - the app pool process object with which the irp is associated.
    Enabled -  mark app pool as active or inactive

Return Value:
    NTSTATUS

--***************************************************************************/
NTSTATUS
UlpSetAppPoolState(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN HTTP_ENABLED_STATE   Enabled
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PUL_APP_POOL_OBJECT pAppPool;
    LIST_ENTRY          RequestQueueHead;
    KLOCK_QUEUE_HANDLE  LockHandle;
    
    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    
    pAppPool = pProcess->pAppPool;

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    UlTrace(ROUTING, (
        "http!UlpSetAppPoolState(AppPool=%p, %lu).\n",
        pAppPool, (ULONG) Enabled
        ));

    InitializeListHead(&RequestQueueHead);

    UlAcquireResourceExclusive(&pAppPool->pResource->Resource, TRUE);

    pAppPool->Enabled = Enabled;

    if (Enabled == HttpEnabledStateInactive)
    {
        // Make a copy of the app pool's new request queue
        if (IsListEmpty(&pAppPool->NewRequestQueue.RequestHead))
        {
            ASSERT(pAppPool->NewRequestQueue.RequestCount == 0);
        }
        else
        {
            RequestQueueHead.Flink
                = pAppPool->NewRequestQueue.RequestHead.Flink;
            RequestQueueHead.Blink
                = pAppPool->NewRequestQueue.RequestHead.Blink;

            RequestQueueHead.Blink->Flink = &RequestQueueHead;
            RequestQueueHead.Flink->Blink = &RequestQueueHead;

            ASSERT(pAppPool->NewRequestQueue.RequestCount > 0);

            // Now zap the app pool's new request queue
            InitializeListHead(&pAppPool->NewRequestQueue.RequestHead);
            pAppPool->NewRequestQueue.RequestCount = 0;
        }
    }

    UlReleaseResource(&pAppPool->pResource->Resource);

    // CODEWORK: need to check Enabled flag elsewhere?

    // Destroy the list outside of the app pool lock

    if (Enabled == HttpEnabledStateInactive)
    {
        ULONG cRequests = 0;

        while (! IsListEmpty(&RequestQueueHead))
        {
            PUL_INTERNAL_REQUEST pRequest
                = CONTAINING_RECORD(
                    RequestQueueHead.Flink,
                    UL_INTERNAL_REQUEST,
                    AppPool.AppPoolEntry
                    );
            PUL_HTTP_CONNECTION  pHttpConn = pRequest->pHttpConn;
                
            ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
            ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));

            UlAcquireInStackQueuedSpinLock(
                &pAppPool->QueueSpinLock,
                &LockHandle
                );

            RemoveEntryList(&pRequest->AppPool.AppPoolEntry);
            pRequest->AppPool.AppPoolEntry.Flink =
                pRequest->AppPool.AppPoolEntry.Blink = NULL;
            pRequest->AppPool.QueueState = QueueUnlinkedState;

            pRequest->ErrorCode = UlErrorUnavailable;   // 503

            UlReleaseInStackQueuedSpinLock(
                &pAppPool->QueueSpinLock,
                &LockHandle
                );

            UlAcquireResourceExclusive(&pHttpConn->Resource, TRUE);
            UlSendErrorResponse(pHttpConn);
            UlReleaseResource(&pHttpConn->Resource);

            // CODEWORK: Need to call UlCancelRequestIo()
            // or UlCloseConnection()?

            UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

            ++cRequests;
        }

        UlTrace(ROUTING, (
            "%lu unhandled requests 503'd from AppPool %p.\n",
            cRequests, pAppPool
            ));
    }

    ASSERT(IsListEmpty(&RequestQueueHead));

    return Status;
} // UlpSetAppPoolState


/***************************************************************************++

Routine Description:

    associates an irp with the apool that will be completed prior to any
    requests being queued.

Arguments:

    pProcess - the process object that is queueing this irp

    pIrp - the irp to associate.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlWaitForDemandStart(
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  PIRP                            pIrp
    )
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpSp;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(IS_VALID_AP_OBJECT(pProcess->pAppPool));
    ASSERT(pIrp != NULL);

    UlAcquireResourceExclusive(&pProcess->pAppPool->pResource->Resource, TRUE);

    //
    // Make sure we're not cleaning up the process
    //
    if (pProcess->InCleanup) {
        Status = STATUS_INVALID_HANDLE;

        UlReleaseResource(&pProcess->pAppPool->pResource->Resource);
        goto end;
    }

    //
    // already got one?
    //

    if (pProcess->pAppPool->pDemandStartIrp != NULL)
    {
        Status = STATUS_OBJECT_NAME_COLLISION;

        UlReleaseResource(&pProcess->pAppPool->pResource->Resource);
        goto end;
    }

    //
    // anything waiting in the queue?
    //

    if (UlpIsRequestQueueEmpty(pProcess))
    {

        //
        // nope, pend the irp
        //

        IoMarkIrpPending(pIrp);

        //
        // give the irp a pointer to the app pool
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pProcess->pAppPool;

        //
        // the cancel routine better not see an irp if it runs immediately
        //

        ASSERT(pProcess->pAppPool->pDemandStartIrp == NULL);

        IoSetCancelRoutine(pIrp, &UlpCancelDemandStart);

        //
        // cancelled?
        //

        if (pIrp->Cancel)
        {
            //
            // darn it, need to make sure the irp get's completed
            //

            if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
            {
                //
                // we are in charge of completion, IoCancelIrp didn't
                // see our cancel routine (and won't).  ioctl wrapper
                // will complete it
                //

                UlReleaseResource(&pProcess->pAppPool->pResource->Resource);

                pIrp->IoStatus.Information = 0;

                UlUnmarkIrpPending( pIrp );
                Status = STATUS_CANCELLED;
                goto end;
            }

            //
            // our cancel routine will run and complete the irp,
            // don't touch it
            //

            //
            // STATUS_PENDING will cause the ioctl wrapper to
            // not complete (or touch in any way) the irp
            //

            Status = STATUS_PENDING;

            UlReleaseResource(&pProcess->pAppPool->pResource->Resource);
            goto end;
        }


        //
        // now we are safe to queue it
        //

        pProcess->pAppPool->pDemandStartIrp = pIrp;
        pProcess->pAppPool->pDemandStartProcess = PsGetCurrentProcess();

        Status = STATUS_PENDING;

        UlReleaseResource(&pProcess->pAppPool->pResource->Resource);
        goto end;

    }
    else
    {
        //
        // something's in the queue, instant demand start
        //

        UlReleaseResource(&pProcess->pAppPool->pResource->Resource);

        IoMarkIrpPending(pIrp);

        pIrp->IoStatus.Status = STATUS_SUCCESS;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );

        Status = STATUS_PENDING;
        goto end;
    }

end:

    return Status;
} // UlWaitForDemandStart


/***************************************************************************++

Routine Description:

    receives a new http request into pIrp.

Arguments:

    RequestId - NULL for new requests, non-NULL for a specific request,
        which must be on the special queue.

    Flags - ignored

    pProcess - the process that wants the request

    pIrp - the irp to receive the request

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveHttpRequest(
    IN  HTTP_REQUEST_ID                 RequestId,
    IN  ULONG                           Flags,
    IN  PUL_APP_POOL_PROCESS            pProcess,
    IN  PIRP                            pIrp
    )
{
    NTSTATUS                Status;
    PUL_INTERNAL_REQUEST    pRequest = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(IS_VALID_AP_OBJECT(pProcess->pAppPool));
    ASSERT(pIrp != NULL);

    UlAcquireResourceShared(&pProcess->pAppPool->pResource->Resource, TRUE);

    //
    // Make sure we're not cleaning up the process
    //
    if (pProcess->InCleanup) {
        Status = STATUS_INVALID_HANDLE;

        UlReleaseResource(&pProcess->pAppPool->pResource->Resource);
        goto end;
    }

    //
    // Is this for a new request?
    //

    if (HTTP_IS_NULL_ID(&RequestId))
    {
        //
        // Do we have a queue'd new request?
        //

        pRequest = UlpDequeueNewRequest(pProcess);

        if (pRequest == NULL)
        {
            PIO_STACK_LOCATION pIrpSp;

            //
            // Nope, queue the irp up.
            //

            IoMarkIrpPending(pIrp);

            //
            // give the irp a pointer to the app pool
            //

            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pProcess->pAppPool;

            REFERENCE_APP_POOL(pProcess->pAppPool);

            //
            // set to these to null just in case the cancel routine runs
            //

            pIrp->Tail.Overlay.ListEntry.Flink = NULL;
            pIrp->Tail.Overlay.ListEntry.Blink = NULL;

            IoSetCancelRoutine(pIrp, &UlpCancelHttpReceive);

            //
            // cancelled?
            //

            if (pIrp->Cancel)
            {
                //
                // darn it, need to make sure the irp get's completed
                //

                if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
                {
                    //
                    // we are in charge of completion, IoCancelIrp didn't
                    // see our cancel routine (and won't).  ioctl wrapper
                    // will complete it
                    //

                    UlReleaseResource(&pProcess->pAppPool->pResource->Resource);

                    DEREFERENCE_APP_POOL(pProcess->pAppPool);

                    pIrp->IoStatus.Information = 0;

                    UlUnmarkIrpPending( pIrp );
                    Status = STATUS_CANCELLED;
                    goto end;
                }

                //
                // our cancel routine will run and complete the irp,
                // don't touch it
                //

                UlReleaseResource(&pProcess->pAppPool->pResource->Resource);

                //
                // STATUS_PENDING will cause the ioctl wrapper to
                // not complete (or touch in any way) the irp
                //

                Status = STATUS_PENDING;
                goto end;
            }

            //
            // now we are safe to queue it
            //

            ExInterlockedInsertTailList(
                &pProcess->NewIrpHead,
                &pIrp->Tail.Overlay.ListEntry,
                KSPIN_LOCK_FROM_UL_SPIN_LOCK(&pProcess->NewIrpSpinLock)
                );

            UlReleaseResource(&pProcess->pAppPool->pResource->Resource);

            Status = STATUS_PENDING;
            goto end;
        }
        else // if (pRequest == NULL)
        {
            //
            // Have a queue'd request, serve it up!
            //
            // UlpDequeueNewRequest gives ourselves a short-lived reference
            //

            //
            // all done with the app pool
            //

            UlReleaseResource(&pProcess->pAppPool->pResource->Resource);

            //
            // Copy it to the irp, the routine will take ownership
            // of pRequest if it is not able to copy it to the irp.
            //
            // it will also complete the irp so don't touch it later.
            //

            IoMarkIrpPending(pIrp);

            UlpCopyRequestToIrp(pRequest, pIrp);
            pIrp = NULL;

            //
            // let go our short-lived reference
            //

            UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
            pRequest = NULL;

            Status = STATUS_PENDING;
            goto end;
        }

    }
    else // if (HTTP_IS_NULL_ID(&RequestId))
    {
        //
        // need to grab the specific request
        //

        //
        // Get the object ptr from id
        //

        pRequest = UlGetRequestFromId(RequestId);

        if (UL_IS_VALID_INTERNAL_REQUEST(pRequest) == FALSE)
        {
            Status = STATUS_INVALID_PARAMETER;

            UlReleaseResource(&pProcess->pAppPool->pResource->Resource);
            goto end;
        }

        //
        // Is this request really queue'd on this process waiting ?
        //
        if ((pRequest->AppPool.QueueState != QueueCopiedState) ||
            (pRequest->AppPool.pProcess != pProcess))
        {
            Status = STATUS_INVALID_PARAMETER;

            UlReleaseResource(&pProcess->pAppPool->pResource->Resource);
            goto end;
        }

        UlTrace(ROUTING, (
            "ul!UlReceiveHttpRequest(ID = %I64x, pProcess = %p)\n"
            "    pAppPool = %p (%S)\n"
            "    Found pRequest = %p on PendingRequest queue\n",
            RequestId,
            pProcess,
            pProcess->pAppPool,
            pProcess->pAppPool->pName,
            pRequest
            ));

        //
        // let go the lock
        //

        UlReleaseResource(&pProcess->pAppPool->pResource->Resource);

        //
        // Copy it to the irp, the routine will take ownership
        // of pRequest if it is not able to copy it to the irp
        //

        IoMarkIrpPending(pIrp);

        UlpCopyRequestToIrp(pRequest, pIrp);

        //
        // let go our reference
        //

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        pRequest = NULL;

        Status = STATUS_PENDING;
        goto end;
    }

end:

    if (pRequest != NULL)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        pRequest = NULL;
    }

    //
    // At this point if Status != PENDING, the ioctl wrapper will
    // complete pIrp
    //

    return Status;
}



/***************************************************************************++

Routine Description:

    called by the http engine to deliver a request to an apool.

    this attemps to find a free irp from any process attached to the apool
    and copies the request to that irp.

    otherwise it queues the request, without taking a refcount on it. the
    request will remove itself from this queue if the connection is dropped.

Arguments:

    pRequest - the request to deliver

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDeliverRequestToProcess(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS                Status;
    PIRP                    pDemandStartIrp;
    PIRP                    pIrp = NULL;
    PUL_APP_POOL_PROCESS    pProcess = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_URL_CONFIG_GROUP_INFO(&pRequest->ConfigInfo));
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // Has the app pool been disabled?
    //
    
    if (pAppPool->Enabled == HttpEnabledStateInactive)
    {
        pRequest->ErrorCode = UlErrorUnavailable;   // 503
        return STATUS_PORT_DISCONNECTED;
    }

    Status = STATUS_SUCCESS;

    //
    // grab the lock!
    //

    UlAcquireResourceShared(&pAppPool->pResource->Resource, TRUE);

    UlTrace(ROUTING, (
        "ul!UlDeliverRequestToProcess(pRequest = %p)\n"
        "    verb + path -> %d %S\n"
        "    pAppPool = %p (%S)\n",
        pRequest,
        pRequest->Verb,
        pRequest->CookedUrl.pUrl,
        pAppPool,
        pAppPool->pName
        ));

    TRACE_TIME(
        pRequest->ConnectionId,
        pRequest->RequestId,
        TIME_ACTION_ROUTE_REQUEST
        );

    //
    // hook up request references
    //
    UL_REFERENCE_INTERNAL_REQUEST(pRequest);

    if (pAppPool->NumberActiveProcesses <= 1)
    {
        //
        // bypass process binding if we have only one active process
        //
        pProcess = NULL;
        pIrp = UlpPopNewIrp(pAppPool, &pProcess);
    }
    else
    {
        //
        // check for a process binding
        //
        pProcess = UlQueryProcessBinding(pRequest->pHttpConn, pAppPool);

        if (UlpIsProcessInAppPool(pProcess, pAppPool)) {
            //
            // we're bound to a valid process.
            // Try to get a free irp from that process
            //

            pIrp = UlpPopIrpFromProcess(pProcess);

        } else {
            //
            // we are unbound or bound to a process that went away.
            // Try and get an free irp from any process.
            //
            pProcess = NULL;
            pIrp = UlpPopNewIrp(pAppPool, &pProcess);

            //
            // establish a binding if we got something
            //
            if (pIrp != NULL) {
                ASSERT( IS_VALID_AP_PROCESS( pProcess ) );

                Status = UlBindConnectionToProcess(
                            pRequest->pHttpConn,
                            pAppPool,
                            pProcess
                            );

                //
                // Is there anything special we should do on
                // failure? I don't think it should be fatal..
                //
                Status = STATUS_SUCCESS;
            }
        }
    }

    //
    // If we have an IRP, complete it. Otherwise queue the request.
    //

    if (pIrp != NULL)
    {
        ASSERT( pIrp->MdlAddress != NULL );
        ASSERT( pProcess->InCleanup == 0 );

        //
        // attach the request to this process, this grabs the lock
        // we are about to let go of. this allows us to drop the
        // connection if the process dies in the middle of request processing.
        //

        UlpQueuePendingRequest(pProcess, pRequest);

        //
        // we are all done and about to complete the irp, free the lock
        //

        UlReleaseResource(&pAppPool->pResource->Resource);

        //
        // Copy it to the irp, the routine will take ownership
        // of pRequest if it is not able to copy it to the irp
        //
        // it will also complete the irp, don't touch it later
        //

        UlpCopyRequestToIrp(pRequest, pIrp);

    }
    else
    {
        ASSERT(pIrp == NULL);

        //
        // Either didn't find an IRP or there's stuff on the pending request
        // list, so queue this pending request.
        //

        Status = UlpQueueUnboundRequest(pAppPool, pRequest);
        if (!NT_SUCCESS(Status)) {
            //
            // doh! we couldn't queue it, so let go of the request
            //
            UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
            UlReleaseResource(&pAppPool->pResource->Resource);
            return Status;
        }

        //
        // complete the demand start
        //

        pDemandStartIrp = pAppPool->pDemandStartIrp;

        if (pDemandStartIrp != NULL)
        {
            pDemandStartIrp = (PIRP) InterlockedCompareExchangePointer(
                                        (PVOID *) &pAppPool->pDemandStartIrp,
                                        NULL,
                                        pDemandStartIrp
                                        );
        }

        if (pDemandStartIrp != NULL)
        {
            //
            // pop the cancel routine
            //

            if (IoSetCancelRoutine(pDemandStartIrp, NULL) == NULL)
            {
                //
                // IoCancelIrp pop'd it first
                //
                // ok to just ignore this irp, it's been pop'd off the queue
                // and will be completed in the cancel routine.
                //
                // no need to complete it
                //
            }
            else if (pDemandStartIrp->Cancel)
            {
                //
                // we pop'd it first. but the irp is being cancelled
                // and our cancel routine will never run.
                //

                IoGetCurrentIrpStackLocation(
                    pDemandStartIrp
                    )->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                pDemandStartIrp->IoStatus.Status = STATUS_CANCELLED;
                pDemandStartIrp->IoStatus.Information = 0;

                pIrp = pDemandStartIrp;
            }
            else
            {

                //
                // free to use the irp
                //

                IoGetCurrentIrpStackLocation(
                    pDemandStartIrp
                    )->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                pDemandStartIrp->IoStatus.Status = STATUS_SUCCESS;
                pDemandStartIrp->IoStatus.Information = 0;

                pIrp = pDemandStartIrp;
            }

            pAppPool->pDemandStartProcess = NULL;
        }

        //
        // now we finished queue'ing the request, free the lock
        //

        UlReleaseResource(&pAppPool->pResource->Resource);

        //
        // complete any demand start irp (after releasing the resource)
        //

        if (pIrp != NULL)
        {
            UlCompleteRequest(pIrp, g_UlPriorityBoost);
            pIrp = NULL;
        }


    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Removes a request from any app pool lists.

Arguments:

    pRequest - the request to be unlinked

--***************************************************************************/
VOID
UlUnlinkRequestFromProcess(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    UlAcquireInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

    //
    // remove from whatever queue we're on
    //
    switch (pRequest->AppPool.QueueState)
    {
    case QueueDeliveredState:
        //
        // we're on the apool object new request queue
        //
        UlpRemoveRequest(&pAppPool->NewRequestQueue, pRequest);
        pRequest->AppPool.QueueState = QueueUnlinkedState;

        //
        // clean up the references
        //
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

        break;

    case QueueCopiedState:
        //
        // we're on the apool process pending queue
        //
        ASSERT(IS_VALID_AP_PROCESS(pRequest->AppPool.pProcess));
        ASSERT(pRequest->AppPool.pProcess->pAppPool == pAppPool);

        UlpRemoveRequest(
            &pRequest->AppPool.pProcess->PendingRequestQueue,
            pRequest
            );
        pRequest->AppPool.QueueState = QueueUnlinkedState;

        //
        // clean up the references
        //
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

        break;

    case QueueUnroutedState:
    case QueueUnlinkedState:
        //
        // It's not on our lists, so we don't do anything
        //
        break;

    default:
        //
        // this shouldn't happen
        //
        ASSERT(FALSE);
        break;
    }


    UlReleaseInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

} // UlUnlinkRequestFromProcess


/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeAP(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(!g_InitAPCalled);

    if (!g_InitAPCalled)
    {
        InitializeListHead(&g_AppPoolListHead);

        Status = UlInitializeResource(
                        &g_pUlNonpagedData->AppPoolResource,
                        "AppPoolResource",
                        0,
                        UL_APP_POOL_RESOURCE_TAG
                        );
        ASSERT(NT_SUCCESS(Status)); // the call always returns success

        if (NT_SUCCESS(Status)) {
            Status = UlInitializeResource(
                            &g_pUlNonpagedData->DisconnectResource,
                            "DisconnectResource",
                            0,
                            UL_DISCONNECT_RESOURCE_TAG
                            );

            if (NT_SUCCESS(Status)) {
                //
                // finished, remember that we're initialized
                //
                g_InitAPCalled = TRUE;
            } else {

                UlDeleteResource(&g_pUlNonpagedData->AppPoolResource);
            }
        }
    }

    return Status;
}

/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlTerminateAP(
    VOID
    )
{
    NTSTATUS Status;

    if (g_InitAPCalled)
    {
        Status = UlDeleteResource(&g_pUlNonpagedData->AppPoolResource);
        ASSERT(NT_SUCCESS(Status));

        Status = UlDeleteResource(&g_pUlNonpagedData->DisconnectResource);
        ASSERT(NT_SUCCESS(Status));

        g_InitAPCalled = FALSE;
    }
}


/***************************************************************************++

Routine Description:

    Allocates and initializes a UL_APP_POOL_PROCESS object

Arguments:

    None.

Return Values:

    NULL on failure, process object on success

--***************************************************************************/
PUL_APP_POOL_PROCESS
UlCreateAppPoolProcess(
    PUL_APP_POOL_OBJECT pObject
    )
{
    PUL_APP_POOL_PROCESS pProcess;

    //
    // Sanity check
    //
    PAGED_CODE();

    pProcess = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    UL_APP_POOL_PROCESS,
                    UL_APP_POOL_PROCESS_POOL_TAG
                    );

    if (pProcess) {
        NTSTATUS Status;

        RtlZeroMemory(pProcess, sizeof(UL_APP_POOL_PROCESS));

        pProcess->Signature = UL_APP_POOL_PROCESS_POOL_TAG;
        pProcess->pAppPool  = pObject;

        InitializeListHead(&pProcess->NewIrpHead);

        Status = UlpInitRequestQueue(
                        &pProcess->PendingRequestQueue, // the queue
                        -1                              // unlimited size
                        );
        ASSERT(NT_SUCCESS(Status));

        UlInitializeSpinLock(&pProcess->NewIrpSpinLock, "NewIrpSpinLock");

        //
        // remember current process (for debugging)
        //
        pProcess->pProcess = PsGetCurrentProcess();

        //
        // Init list of WaitForDisconnect IRPs
        //
        UlInitializeNotifyHead(
            &pProcess->WaitForDisconnectHead,
            NULL
            );

    }

    return pProcess;
}

/***************************************************************************++

Routine Description:

    Destroys a UL_APP_POOL_PROCESS object

Arguments:

    pProcess - object to destory

--***************************************************************************/
VOID
UlFreeAppPoolProcess(
    PUL_APP_POOL_PROCESS pProcess
    )
{
    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );
    ASSERT( pProcess->InCleanup );

    //
    // free the pool
    //

    UL_FREE_POOL_WITH_SIG(pProcess, UL_APP_POOL_PROCESS_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    cancels the pending user mode irp which was to receive demand start
    notification. this routine ALWAYS results in the irp being completed.

    note: we queue off to cancel in order to process the cancellation at lower
    irql.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelDemandStart(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // queue the cancel to a worker to ensure passive irql.
    //

    UL_CALL_PASSIVE(
        UL_WORK_ITEM_FROM_IRP( pIrp ),
        &UlpCancelDemandStartWorker
        );

}

/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem - the work item to process.

--***************************************************************************/
VOID
UlpCancelDemandStartWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PIRP                pIrp;
    PUL_APP_POOL_OBJECT pAppPool;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // grab the app pool off the irp
    //

    pAppPool = (PUL_APP_POOL_OBJECT)(
                    IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer
                    );

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // grab the lock protecting the queue'd irp
    //

    UlAcquireResourceExclusive(&pAppPool->pResource->Resource, TRUE);

    //
    // does it need to be dequeue'd ?
    //

    if (pAppPool->pDemandStartIrp != NULL)
    {
        //
        // remove it
        //

        pAppPool->pDemandStartIrp = NULL;
        pAppPool->pDemandStartProcess = NULL;
    }

    //
    // let the lock go
    //

    UlReleaseResource(&pAppPool->pResource->Resource);

    //
    // let our reference go
    //

    IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    //
    // complete the irp
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

}

/***************************************************************************++

Routine Description:

    cancels the pending user mode irp which was to receive the http request.
    this routine ALWAYS results in the irp being completed.

    note: we queue off to cancel in order to process the cancellation at lower
    irql.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelHttpReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // queue the cancel to a worker to ensure passive irql.
    //

    UL_CALL_PASSIVE(
        UL_WORK_ITEM_FROM_IRP( pIrp ),
        &UlpCancelHttpReceiveWorker
        );

}

/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem - the work item to process.

--***************************************************************************/
VOID
UlpCancelHttpReceiveWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_APP_POOL_OBJECT pAppPool;
    PIRP                pIrp;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pWorkItem != NULL);

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // grab the app pool off the irp
    //

    pAppPool = (PUL_APP_POOL_OBJECT)(
                    IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer
                    );

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // grab the lock protecting the queue
    //

    UlAcquireResourceExclusive(&pAppPool->pResource->Resource, TRUE);

    //
    // does it need to be de-queue'd ?
    //

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        //
        // remove it
        //

        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    //
    // let the lock go
    //

    UlReleaseResource(&pAppPool->pResource->Resource);

    //
    // let our reference go
    //

    IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_APP_POOL(pAppPool);

    //
    // complete the irp
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

}   // UlpCancelHttpReceive

/******************************************************************************

Routine Description:

    Copy an HTTP request to a buffer.

Arguments:

    pRequest            - Pointer to this request.
    pBuffer             - Pointer to buffer where we'll copy.
    BufferLength        - Length of pBuffer.
    pEntityBody         - Pointer to entity body of request.
    EntityBodyLength    - Length of entity body.


******************************************************************************/

NTSTATUS
UlpCopyRequestToBuffer(
    PUL_INTERNAL_REQUEST    pRequest,
    PUCHAR                  pKernelBuffer,
    PVOID                   pUserBuffer,
    ULONG                   BufferLength,
    PUCHAR                  pEntityBody,
    ULONG                   EntityBodyLength
    )
{
    PHTTP_REQUEST               pHttpRequest;
    PHTTP_UNKNOWN_HEADER        pUserCurrentUnknownHeader;
    PUCHAR                      pCurrentBufferPtr;
    ULONG                       i;
    ULONG                       BytesCopied;
    ULONG                       HeaderCount = 0;
    PHTTP_NETWORK_ADDRESS_IPV4  pLocalAddress;
    PHTTP_NETWORK_ADDRESS_IPV4  pRemoteAddress;
    PHTTP_TRANSPORT_ADDRESS     pAddress;
    PHTTP_COOKED_URL            pCookedUrl;
    PLIST_ENTRY                 pListEntry;
    NTSTATUS                    Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(pKernelBuffer != NULL);
    ASSERT(pUserBuffer != NULL);
    ASSERT(BufferLength > sizeof(HTTP_REQUEST));

    Status = STATUS_SUCCESS;

    //
    // Set up our pointers to the HTTP_REQUESTS structure, the
    // header arrays we're going to fill in, and the pointer to
    // where we're going to start filling them in.
    //
    // CODEWORK: Make this transport independent.
    //

    pHttpRequest = (PHTTP_REQUEST)pKernelBuffer;

    pLocalAddress = (PHTTP_NETWORK_ADDRESS_IPV4)( pHttpRequest + 1 );
    pRemoteAddress = pLocalAddress + 1;

    pUserCurrentUnknownHeader = (PHTTP_UNKNOWN_HEADER)( pRemoteAddress + 1 );

    pCurrentBufferPtr = (PUCHAR)(pUserCurrentUnknownHeader +
                                 pRequest->UnknownHeaderCount);

    //
    // Now fill in the HTTP request structure.
    //

    ASSERT(!HTTP_IS_NULL_ID(&pRequest->ConnectionId));
    ASSERT(!HTTP_IS_NULL_ID(&pRequest->RequestIdCopy));

    pHttpRequest->ConnectionId  = pRequest->ConnectionId;
    pHttpRequest->RequestId     = pRequest->RequestIdCopy;
    pHttpRequest->UrlContext    = pRequest->ConfigInfo.UrlContext;
    pHttpRequest->Version       = pRequest->Version;
    pHttpRequest->Verb          = pRequest->Verb;
    pHttpRequest->Reason        = pRequest->Reason;
    pHttpRequest->BytesReceived = pRequest->BytesReceived;

    pAddress = &pHttpRequest->Address;

    pAddress->RemoteAddressLength = sizeof(HTTP_NETWORK_ADDRESS_IPV4);
    pAddress->RemoteAddressType = HTTP_NETWORK_ADDRESS_TYPE_IPV4;
    pAddress->pRemoteAddress = FIXUP_PTR(
                                        PVOID,
                                        pUserBuffer,
                                        pKernelBuffer,
                                        pRemoteAddress,
                                        BufferLength
                                        );
    pRemoteAddress->IpAddress =  pRequest->pHttpConn->pConnection->RemoteAddress;
    pRemoteAddress->Port =  pRequest->pHttpConn->pConnection->RemotePort;

    pAddress->LocalAddressLength = sizeof(HTTP_NETWORK_ADDRESS_IPV4);
    pAddress->LocalAddressType = HTTP_NETWORK_ADDRESS_TYPE_IPV4;
    pAddress->pLocalAddress = FIXUP_PTR(
                                        PVOID,
                                        pUserBuffer,
                                        pKernelBuffer,
                                        pLocalAddress,
                                        BufferLength
                                        );

    pLocalAddress->IpAddress = pRequest->pHttpConn->pConnection->LocalAddress;
    pLocalAddress->Port =  pRequest->pHttpConn->pConnection->LocalPort;

    //
    // and now the cooked url sections
    //

    //
    // Unicode strings must be at 2-byte boundaries. All previous data
    // are structures, so the assertion should be true.
    //

    ASSERT(((ULONG_PTR) pCurrentBufferPtr % sizeof(WCHAR)) == 0);

    //
    // make sure they are valid
    //

    ASSERT(pRequest->CookedUrl.pUrl != NULL);
    ASSERT(pRequest->CookedUrl.pHost != NULL);
    ASSERT(pRequest->CookedUrl.pAbsPath != NULL);

    //
    // do the full url
    //

    ASSERT(pRequest->CookedUrl.Length <= 0xffff);

    pCookedUrl = &pHttpRequest->CookedUrl;

    pCookedUrl->FullUrlLength = (USHORT)(pRequest->CookedUrl.Length);
    pCookedUrl->pFullUrl = FIXUP_PTR(
                                    PWSTR,
                                    pUserBuffer,
                                    pKernelBuffer,
                                    pCurrentBufferPtr,
                                    BufferLength
                                    );

    //
    // and the host
    //

    pCookedUrl->HostLength = DIFF(pRequest->CookedUrl.pAbsPath - pRequest->CookedUrl.pHost)
                                    * sizeof(WCHAR);

    pCookedUrl->pHost = pCookedUrl->pFullUrl +
                                DIFF(pRequest->CookedUrl.pHost - pRequest->CookedUrl.pUrl);

    //
    // is there a query string?
    //

    if (pRequest->CookedUrl.pQueryString != NULL)
    {
        pCookedUrl->AbsPathLength = DIFF(pRequest->CookedUrl.pQueryString -
                                        pRequest->CookedUrl.pAbsPath) * sizeof(WCHAR);

        pCookedUrl->pAbsPath = pCookedUrl->pHost +
                                    (pCookedUrl->HostLength / sizeof(WCHAR));

        pCookedUrl->QueryStringLength = (USHORT)(pRequest->CookedUrl.Length) - (
                                            DIFF(
                                                pRequest->CookedUrl.pQueryString -
                                                pRequest->CookedUrl.pUrl
                                                ) * sizeof(WCHAR)
                                            );

        pCookedUrl->pQueryString = pCookedUrl->pAbsPath +
                                        (pCookedUrl->AbsPathLength / sizeof(WCHAR));
    }
    else
    {
        pCookedUrl->AbsPathLength = (USHORT)(pRequest->CookedUrl.Length) - (
                                        DIFF(
                                            pRequest->CookedUrl.pAbsPath -
                                            pRequest->CookedUrl.pUrl
                                            ) * sizeof(WCHAR)
                                        );

        pCookedUrl->pAbsPath = pCookedUrl->pHost +
                                    (pCookedUrl->HostLength / sizeof(WCHAR));

        pCookedUrl->QueryStringLength = 0;
        pCookedUrl->pQueryString = NULL;
    }

    //
    // copy the full url
    //

    RtlCopyMemory(
        pCurrentBufferPtr,
        pRequest->CookedUrl.pUrl,
        pRequest->CookedUrl.Length
        );

    pCurrentBufferPtr += pRequest->CookedUrl.Length;

    //
    // terminate it
    //

    ((PWSTR)pCurrentBufferPtr)[0] = UNICODE_NULL;
    pCurrentBufferPtr += sizeof(WCHAR);

    //
    // any raw verb?
    //

    if (pRequest->Verb == HttpVerbUnknown)
    {
        //
        // Need to copy in the raw verb for the client.
        //

        ASSERT(pRequest->RawVerbLength <= 0x7fff);

        pHttpRequest->UnknownVerbLength = (USHORT)(pRequest->RawVerbLength * sizeof(CHAR));
        pHttpRequest->pUnknownVerb = FIXUP_PTR(
                                            PSTR,
                                            pUserBuffer,
                                            pKernelBuffer,
                                            pCurrentBufferPtr,
                                            BufferLength
                                            );

        RtlCopyMemory(
            pCurrentBufferPtr,
            pRequest->pRawVerb,
            pRequest->RawVerbLength
            );

        BytesCopied = pRequest->RawVerbLength * sizeof(CHAR);
        pCurrentBufferPtr += BytesCopied;

        //
        // terminate it
        //

        ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
        pCurrentBufferPtr += sizeof(CHAR);

    }
    else
    {
        pHttpRequest->UnknownVerbLength = 0;
        pHttpRequest->pUnknownVerb = NULL;
    }

    //
    // copy the raw url
    //

    ASSERT(pRequest->RawUrl.Length <= 0x7fff);

    pHttpRequest->RawUrlLength = (USHORT)(pRequest->RawUrl.Length * sizeof(CHAR));
    pHttpRequest->pRawUrl = FIXUP_PTR(
                                PSTR,
                                pUserBuffer,
                                pKernelBuffer,
                                pCurrentBufferPtr,
                                BufferLength
                                );

    RtlCopyMemory(
        pCurrentBufferPtr,
        pRequest->RawUrl.pUrl,
        pRequest->RawUrl.Length
        );

    BytesCopied = pRequest->RawUrl.Length * sizeof(CHAR);
    pCurrentBufferPtr += BytesCopied;

    //
    // terminate it
    //

    ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
    pCurrentBufferPtr += sizeof(CHAR);

    //
    // no entity body, CODEWORK.
    //

    if (pRequest->ContentLength > 0 || pRequest->Chunked == 1)
    {
        pHttpRequest->MoreEntityBodyExists = 1;
    }
    else
    {
        pHttpRequest->MoreEntityBodyExists = 0;
    }

    pHttpRequest->EntityChunkCount = 0;
    pHttpRequest->pEntityChunks = NULL;

    //
    // Copy in the known headers.
    //
    // Loop through the known header array in the HTTP connection,
    // and copy any that we have.
    //

    RtlZeroMemory(
        pHttpRequest->Headers.pKnownHeaders,
        HttpHeaderRequestMaximum * sizeof(HTTP_KNOWN_HEADER)
        );

    for (i = 0; i < HttpHeaderRequestMaximum; i++)
    {
        HTTP_HEADER_ID HeaderId = (HTTP_HEADER_ID)pRequest->HeaderIndex[i];

        if (HeaderId == HttpHeaderRequestMaximum)
        {
            break;
        }

        //
        // Have a header here we need to copy in.
        //

        ASSERT(pRequest->HeaderValid[HeaderId]);
        ASSERT(pRequest->Headers[HeaderId].HeaderLength <= 0x7fff);

        //
        // ok for HeaderLength to be 0 .  we will give usermode a pointer
        // pointing to a NULL string.  RawValueLength will be 0.
        //

        pHttpRequest->Headers.pKnownHeaders[HeaderId].RawValueLength =
            (USHORT)(pRequest->Headers[HeaderId].HeaderLength * sizeof(CHAR));

        pHttpRequest->Headers.pKnownHeaders[HeaderId].pRawValue =
            FIXUP_PTR(
                PSTR,
                pUserBuffer,
                pKernelBuffer,
                pCurrentBufferPtr,
                BufferLength
                );

        RtlCopyMemory(
            pCurrentBufferPtr,
            pRequest->Headers[HeaderId].pHeader,
            pRequest->Headers[HeaderId].HeaderLength
            );

        BytesCopied = pRequest->Headers[HeaderId].HeaderLength * sizeof(CHAR);
        pCurrentBufferPtr += BytesCopied;

        //
        // terminate it
        //

        ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
        pCurrentBufferPtr += sizeof(CHAR);
    }

    //
    // Now loop through the unknown headers, and copy them in.
    //

    pHttpRequest->Headers.UnknownHeaderCount = pRequest->UnknownHeaderCount;

    if (pRequest->UnknownHeaderCount == 0)
    {
        pHttpRequest->Headers.pUnknownHeaders = NULL;
    }
    else
    {
        pHttpRequest->Headers.pUnknownHeaders =
            FIXUP_PTR(
                PHTTP_UNKNOWN_HEADER,
                pUserBuffer,
                pKernelBuffer,
                pUserCurrentUnknownHeader,
                BufferLength
                );
    }

    pListEntry = pRequest->UnknownHeaderList.Flink;

    while (pListEntry != &pRequest->UnknownHeaderList)
    {
        PUL_HTTP_UNKNOWN_HEADER     pUnknownHeader;

        pUnknownHeader = CONTAINING_RECORD(
                                pListEntry,
                                UL_HTTP_UNKNOWN_HEADER,
                                List
                                );

        pListEntry = pListEntry->Flink;

        HeaderCount++;
        ASSERT(HeaderCount <= pRequest->UnknownHeaderCount);

        //
        // First copy in the header name.
        //

        pUserCurrentUnknownHeader->NameLength =
            (USHORT)pUnknownHeader->HeaderNameLength * sizeof(CHAR);

        pUserCurrentUnknownHeader->pName =
            FIXUP_PTR(
                PSTR,
                pUserBuffer,
                pKernelBuffer,
                pCurrentBufferPtr,
                BufferLength
                );

        RtlCopyMemory(
            pCurrentBufferPtr,
            pUnknownHeader->pHeaderName,
            pUnknownHeader->HeaderNameLength
            );

        BytesCopied = pUnknownHeader->HeaderNameLength * sizeof(CHAR);
        pCurrentBufferPtr += BytesCopied;

        //
        // terminate it
        //

        ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
        pCurrentBufferPtr += sizeof(CHAR);

        //
        // Now copy in the header value.
        //

        ASSERT(pUnknownHeader->HeaderValue.HeaderLength <= 0x7fff);

        if (pUnknownHeader->HeaderValue.HeaderLength == 0)
        {
            pUserCurrentUnknownHeader->RawValueLength = 0;
            pUserCurrentUnknownHeader->pRawValue = NULL;
        }
        else
        {

            pUserCurrentUnknownHeader->RawValueLength =
                (USHORT)(pUnknownHeader->HeaderValue.HeaderLength * sizeof(CHAR));

            pUserCurrentUnknownHeader->pRawValue =
                FIXUP_PTR(
                    PSTR,
                    pUserBuffer,
                    pKernelBuffer,
                    pCurrentBufferPtr,
                    BufferLength
                    );

            RtlCopyMemory(
                pCurrentBufferPtr,
                pUnknownHeader->HeaderValue.pHeader,
                pUnknownHeader->HeaderValue.HeaderLength
                );

            BytesCopied = pUnknownHeader->HeaderValue.HeaderLength * sizeof(CHAR);
            pCurrentBufferPtr += BytesCopied;

            //
            // terminate it
            //

            ((PSTR)pCurrentBufferPtr)[0] = ANSI_NULL;
            pCurrentBufferPtr += sizeof(CHAR);

        }

        //
        // skip to the next header
        //

        pUserCurrentUnknownHeader++;
    }

    //
    // Copy raw connection ID.
    //

    pHttpRequest->RawConnectionId = pRequest->RawConnectionId;

    //
    // Copy in SSL information.
    //

    if (pRequest->pHttpConn->SecureConnection == FALSE)
    {
        pHttpRequest->pSslInfo = NULL;
    }
    else
    {
        pCurrentBufferPtr = (PUCHAR)ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID);

        Status = UlGetSslInfo(
                    &pRequest->pHttpConn->pConnection->FilterInfo,
                    BufferLength - DIFF(pCurrentBufferPtr - pKernelBuffer),
                    FIXUP_PTR(
                        PUCHAR,
                        pUserBuffer,
                        pKernelBuffer,
                        pCurrentBufferPtr,
                        BufferLength
                        ),
                    pCurrentBufferPtr,
                    &BytesCopied
                    );

        if (NT_SUCCESS(Status) && BytesCopied)
        {
            pHttpRequest->pSslInfo = FIXUP_PTR(
                                        PHTTP_SSL_INFO,
                                        pUserBuffer,
                                        pKernelBuffer,
                                        pCurrentBufferPtr,
                                        BufferLength
                                        );

            pCurrentBufferPtr += BytesCopied;
        }
        else
        {
            pHttpRequest->pSslInfo = NULL;
        }
    }

    //
    // Make sure we didn't use too much
    //

    ASSERT(DIFF(pCurrentBufferPtr - pKernelBuffer) <= BufferLength);

    TRACE_TIME(
        pRequest->ConnectionId,
        pRequest->RequestId,
        TIME_ACTION_COPY_REQUEST
        );

    return Status;

}   // UlpCopyRequestToBuffer


/******************************************************************************

Routine Description:

    Find a pending IRP to deliver a request to. This routine must
    be called with the lock on the apool held.

Arguments:

    pAppPool - the apool to search for the irp

    ppProcess - the process that we got the irp from

Return Value:

    A pointer to an IRP if we've found one, or NULL if we didn't.


******************************************************************************/
PIRP
UlpPopNewIrp(
    IN  PUL_APP_POOL_OBJECT pAppPool,
    OUT PUL_APP_POOL_PROCESS * ppProcess
    )
{
    PUL_APP_POOL_PROCESS    pProcess;
    PIRP                    pIrp = NULL;
    PLIST_ENTRY             pEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_AP_OBJECT(pAppPool));
    ASSERT(ppProcess != NULL);

    //
    // Start looking for a process with a free IRP. We tend to always go to
    // the first one to try and prevent process thrashing.
    //

    pEntry = pAppPool->ProcessListHead.Flink;
    while (pEntry != &(pAppPool->ProcessListHead))
    {
        pProcess = CONTAINING_RECORD(
                        pEntry,
                        UL_APP_POOL_PROCESS,
                        ListEntry
                        );

        ASSERT(IS_VALID_AP_PROCESS(pProcess));

        //
        // get an IRP from this process
        //
        pIrp = UlpPopIrpFromProcess(pProcess);

        //
        // did we find one ?
        //

        if (pIrp != NULL)
        {
            *ppProcess = pProcess;
            break;
        }

        //
        // keep looking - move on to the next process entry
        //

        pEntry = pProcess->ListEntry.Flink;

    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Pulls an IRP off the given processes queue if there is one.

Arguments:

    pProcess - a pointer to the process to search

Return Value:

    A pointer to an IRP if we've found one, or NULL if we didn't.

--***************************************************************************/
PIRP
UlpPopIrpFromProcess(
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_APP_POOL_OBJECT pProcessAppPool;
    PLIST_ENTRY pEntry;
    PIRP pIrp = NULL;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(IS_VALID_AP_PROCESS(pProcess));

    pEntry = ExInterlockedRemoveHeadList(
                &pProcess->NewIrpHead,
                KSPIN_LOCK_FROM_UL_SPIN_LOCK(&pProcess->NewIrpSpinLock)
                );

    if (pEntry != NULL)
    {
        //
        // Found a free irp !
        //

        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }
        else if (pIrp->Cancel)
        {

            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run. lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //

            pProcessAppPool = (PUL_APP_POOL_OBJECT)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pProcessAppPool == pProcess->pAppPool);

            DEREFERENCE_APP_POOL(pProcessAppPool);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, g_UlPriorityBoost);

            pIrp = NULL;
        }
        else
        {

            //
            // we are free to use this irp !
            //

            pProcessAppPool = (PUL_APP_POOL_OBJECT)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pProcessAppPool == pProcess->pAppPool);

            DEREFERENCE_APP_POOL(pProcessAppPool);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        }
    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Loops through an app pool's list of processes, looking for the specified
    process.

Arguments:

    pProcess - the process to search for
    pAppPool - the app pool to search

Return Values:

    TRUE if the process was found, FALSE otherwise

--***************************************************************************/
BOOLEAN
UlpIsProcessInAppPool(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_APP_POOL_OBJECT  pAppPool
    )
{
    BOOLEAN Found = FALSE;
    PLIST_ENTRY pEntry;
    PUL_APP_POOL_PROCESS pCurrentProc;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // only look if process isn't NULL.
    //
    if (pProcess != NULL) {

        //
        // Start looking for the process.
        //
        pEntry = pAppPool->ProcessListHead.Flink;
        while (pEntry != &(pAppPool->ProcessListHead))
        {
            pCurrentProc = CONTAINING_RECORD(
                            pEntry,
                            UL_APP_POOL_PROCESS,
                            ListEntry
                            );

            ASSERT(IS_VALID_AP_PROCESS(pCurrentProc));

            //
            // did we find it?
            //
            if (pCurrentProc == pProcess) {
                Found = TRUE;
                break;
            }

            //
            // keep looking - move on to the next process entry
            //

            pEntry = pCurrentProc->ListEntry.Flink;
        }

        if (!Found) {
            //
            // process must have gone away.
            //
            UlTrace(ROUTING, (
                "ul!UlpIsProcessInAppPool(\n"
                "        pProcess = %p\n"
                "        pAppPool = %p (%S) )\n"
                "    returning FALSE\n",
                pProcess,
                pAppPool,
                pAppPool->pName
                ));
        }
    }

    return Found;
}


/***************************************************************************++

Routine Description:

    Adds a request to the unbound queue. These requests can be routed to
    any process in the app pool.

Arguments:

    pAppPool - the pool which is getting the request
    pRequest - the request to queue

--***************************************************************************/
NTSTATUS
UlpQueueUnboundRequest(
    IN PUL_APP_POOL_OBJECT  pAppPool,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_AP_OBJECT(pAppPool) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );

    UlAcquireInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

    //
    // add it to the queue
    //
    Status = UlpQueueRequest(&pAppPool->NewRequestQueue, pRequest);

    //
    // if it's in, change the queue state
    //
    if (NT_SUCCESS(Status)) {
        pRequest->AppPool.QueueState = QueueDeliveredState;
    } else {
        //
        // the queue is too full, return an error to the client
        //
        UlTrace(ROUTING, (
            "ul!UlpQueueUnboundRequest(pAppPool = %p, pRequest = %p)\n"
            "         Rejecting request. AppPool Queue is full (%d items)\n",
            pAppPool,
            pRequest,
            UlpQueryQueueLength(&pAppPool->NewRequestQueue)
            ));

        pRequest->ErrorCode = UlErrorUnavailable; // 503
    }

    UlReleaseInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

    return Status;
} // UlpQueueUnboundRequest


/***************************************************************************++

Routine Description:

    Searches request queues for a request available to the specified process.
    If a request is found, it is removed from the queue and returned.

Arguments:

    pProcess - the process that will get the request

Return Values:

    Pointer to an HTTP_REQUEST if one is found.
    NULL otherwise.

--***************************************************************************/
PUL_INTERNAL_REQUEST
UlpDequeueNewRequest(
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PLIST_ENTRY pEntry;
    PUL_INTERNAL_REQUEST pRequest = NULL;
    PUL_APP_POOL_OBJECT pAppPool;
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );

    pAppPool = pProcess->pAppPool;

    ASSERT( IS_VALID_AP_OBJECT(pAppPool) );

    UlAcquireInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

    //
    //  find a usable request
    //
    pEntry = pAppPool->NewRequestQueue.RequestHead.Flink;

    while (pEntry != &pAppPool->NewRequestQueue.RequestHead) {
        PUL_APP_POOL_PROCESS pProcBinding;

        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );

        if (pAppPool->NumberActiveProcesses <= 1) {
            //
            // done if there is only one active process
            //
            break;
        }

        //
        // check the binding
        //
        pProcBinding = UlQueryProcessBinding(
                            pRequest->pHttpConn,
                            pAppPool
                            );

        if (pProcBinding == pProcess) {
            //
            // found a request bound to the correct process
            //
            break;
        } else if (pProcBinding == NULL) {
            //
            // found an unbound request
            //

            //
            // bind unbound request to this process
            // Note: we're ignoring the return val
            // of UlBindConnectionToProcess because
            // it's probably not a fatal error..
            //
            UlBindConnectionToProcess(
                pRequest->pHttpConn,
                pAppPool,
                pProcess
                );

            break;
        }

        //
        // try the next one
        //
        pEntry = pEntry->Flink;
    }

    //
    // if we found something, remove it from the NewRequestQueue 
    // and pend it onto the PendingRequestQuueue
    //
    if (pRequest)
    {
        UlpRemoveRequest(&pAppPool->NewRequestQueue, pRequest);

        //
        // attach the request to this process. this allows us to drop the
        // connection if the process dies in the middle of request
        // processing
        //
        pRequest->AppPool.pProcess = pProcess;
        pRequest->AppPool.QueueState = QueueCopiedState;

        //
        // add a reference to the request so as to allow unlink from
        // process to happen once we let go of the lock 
        //
        UL_REFERENCE_INTERNAL_REQUEST(pRequest);

        UlpQueueRequest(
            &pProcess->PendingRequestQueue,
            pRequest
            );
    }

    UlReleaseInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

    return pRequest;
} // UlpDequeueNewRequest


/***************************************************************************++

Routine Description:

    Takes all the queued requests bound to the given process and makes them
    available to all processes.

Arguments:

    pProcess - the process whose requests are to be redistributed

--***************************************************************************/
VOID
UlpUnbindQueuedRequests(
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PLIST_ENTRY pEntry;
    PUL_INTERNAL_REQUEST pRequest = NULL;
    PUL_APP_POOL_OBJECT pAppPool;
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );

    pAppPool = pProcess->pAppPool;

    ASSERT( IS_VALID_AP_OBJECT(pAppPool) );

    UlAcquireInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

    //
    // find a bound request
    //
    pEntry = pAppPool->NewRequestQueue.RequestHead.Flink;

    while (pEntry != &pAppPool->NewRequestQueue.RequestHead) {
        PUL_APP_POOL_PROCESS pProcBinding;

        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );

        //
        // remember the next one
        //
        pEntry = pEntry->Flink;

        //
        // check the binding
        //
        if (pAppPool->NumberActiveProcesses <= 1) {
            pProcBinding = pProcess;
        } else {
            pProcBinding = UlQueryProcessBinding(
                                pRequest->pHttpConn,
                                pAppPool
                                );
        }

        if (pProcBinding == pProcess) {
            //
            // remove from the list
            //
            UlpRemoveRequest(&pAppPool->NewRequestQueue, pRequest);

            //
            // mark it as unrouted
            //
            pRequest->AppPool.QueueState = QueueUnroutedState;

            UlTrace(ROUTING, (
                "STICKY KILL cid %I64x to proc %p\n",
                pRequest->ConnectionId,
                pProcess
                ));

            //
            // kill the binding
            //
            UlBindConnectionToProcess(
                pRequest->pHttpConn,
                pProcess->pAppPool,
                NULL
                );

            //
            // there may be an IRP for this newly unbound
            // request, so redeliver the request outside
            // the locks we're holding.
            //
            UL_QUEUE_WORK_ITEM(
                &pRequest->WorkItem,
                &UlpRedeliverRequestWorker
                );
        }
    }

    UlReleaseInStackQueuedSpinLock(&pAppPool->QueueSpinLock, &LockHandle);

}


/***************************************************************************++

Routine Description:

    Delivers the given request to an App Pool. UlpUnbindQueuedRequests
    uses this routine to call into UlDeliverRequestToProcess outside
    of any locks.

Arguments:

    pWorkItem - embedded in the request to deliver

--***************************************************************************/
VOID
UlpRedeliverRequestWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    PUL_INTERNAL_REQUEST pRequest;

    pRequest = CONTAINING_RECORD(
                    pWorkItem,
                    UL_INTERNAL_REQUEST,
                    WorkItem
                    );

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );
    ASSERT( IS_VALID_URL_CONFIG_GROUP_INFO(&pRequest->ConfigInfo) );
    ASSERT( pRequest->ConfigInfo.pAppPool );

    Status = UlDeliverRequestToProcess(
                    pRequest->ConfigInfo.pAppPool,
                    pRequest
                    );

    //
    // remove the extra reference added in UlpUnbindQueuedRequests
    //
    UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

    CHECK_STATUS(Status);
}


/***************************************************************************++

Routine Description:

    Checks the request queue to see if there are any requests available
    to the specified process.

Arguments:

    pProcess - the process doing the check

Return Values:

    TRUE if there are no requests available, FALSE if there are requests

--***************************************************************************/
BOOLEAN
UlpIsRequestQueueEmpty(
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_APP_POOL_OBJECT pAppPool;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );

    pAppPool = pProcess->pAppPool;

    ASSERT( IS_VALID_AP_OBJECT(pAppPool) );

    return (UlpQueryQueueLength(&pAppPool->NewRequestQueue) == 0);
}


/***************************************************************************++

Routine Description:

    Changes the maximum length of the incoming request queue on the app pool.

Arguments:

    pProcess - App pool process object
    QueueLength - the new max length of the queue

--***************************************************************************/
NTSTATUS
UlpSetAppPoolQueueLength(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN LONG                 QueueLength
    )
{
    PUL_APP_POOL_OBJECT pAppPool;
    PLONG               pQueueLength;
    NTSTATUS            Status;

    pAppPool = pProcess->pAppPool;
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // set the new value
    //

    UlAcquireResourceExclusive(&pAppPool->pResource->Resource, TRUE);

    Status = UlpSetMaxQueueLength(&pAppPool->NewRequestQueue, QueueLength);

    UlTrace(ROUTING, (
        "ul!UlpSetAppPoolQueueLength(pProcess = %p, QueueLength = %d)\n"
        "        pAppPool = %p (%ws), Status = 0x%08x\n",
        pProcess,
        QueueLength,
        pAppPool,
        pAppPool->pName,
        Status
        ));

    UlReleaseResource(&pAppPool->pResource->Resource);

    RETURN(Status);
}


/***************************************************************************++

Routine Description:

    Gets the maximum length of the incoming request queue on the app pool.

Arguments:

    pProcess - App pool process object
    return value -  max length of the queue

--***************************************************************************/
LONG
UlpGetAppPoolQueueLength(
    IN  PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_APP_POOL_OBJECT pAppPool;
    NTSTATUS            Status;
    LONG                QueueLength;

    pAppPool = pProcess->pAppPool;
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));

    //
    // Get the max length
    //

    UlAcquireResourceExclusive(&pAppPool->pResource->Resource, TRUE);

    QueueLength = pAppPool->NewRequestQueue.MaxRequests;

    UlReleaseResource(&pAppPool->pResource->Resource);

    return QueueLength;
}

/******************************************************************************

Routine Description:

    this copies a request into a free irp.

    if the request is too large, it queues to request onto the process and
    completes the irp, so that the process can come back later with a larger
    buffer.


Arguments:

    pRequest - the request to copy

    pProcess - the process that owns pIrp

    pIrp - the irp to copy pRequest to

Return Value:

    VOID - it always works.

******************************************************************************/
VOID
UlpCopyRequestToIrp(
    PUL_INTERNAL_REQUEST    pRequest,
    PIRP                    pIrp
    )
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpSp;
    ULONG               BytesNeeded;
    PUCHAR              pKernelBuffer;
    PVOID               pUserBuffer;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(pIrp != NULL);

    __try
    {
        //
        // Make sure this is big enough to handle the request, and
        // if so copy it in.
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

        //
        // Calculate the size needed for the request, we'll need it below.
        //

        Status = UlpComputeRequestBytesNeeded(pRequest, &BytesNeeded);

        if (!NT_SUCCESS(Status))
        {
            goto complete;
        }

        //
        // Make sure we've got enough space to handle the whole request.
        //

        if (BytesNeeded <= pIrpSp->Parameters.DeviceIoControl.OutputBufferLength)
        {
            //
            // get the addresses for the buffer
            //

            pKernelBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                        pIrp->MdlAddress,
                                        NormalPagePriority
                                        );

            if (pKernelBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto complete;
            }

            //
            // Make sure we are properly aligned.
            //


            if (((ULONG_PTR) pKernelBuffer) & (TYPE_ALIGNMENT(HTTP_REQUEST) - 1))
            {
                UlTrace(ROUTING, (
                    "UlpCopyRequestToIrp: pKernelBuffer = %p, Alignment = %p\n"
                    "        ((ULONG_PTR) pKernelBuffer) & (TYPE_ALIGNMENT(HTTP_REQUEST) - 1) = %p\n",
                    pKernelBuffer,
                    TYPE_ALIGNMENT(HTTP_REQUEST),
                    ((ULONG_PTR) pKernelBuffer) & (TYPE_ALIGNMENT(HTTP_REQUEST) - 1)
                    ));

                Status = STATUS_DATATYPE_MISALIGNMENT_ERROR;
                goto complete;
            }

            pUserBuffer = MmGetMdlVirtualAddress( pIrp->MdlAddress );
            ASSERT( pUserBuffer != NULL );

            //
            // This request will fit in this buffer, so copy it.
            //

            Status = UlpCopyRequestToBuffer(
                            pRequest,
                            pKernelBuffer,
                            pUserBuffer,
                            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            NULL,
                            0
                            );

            if (NT_SUCCESS(Status))
            {
                pIrp->IoStatus.Information = BytesNeeded;
            }
            else
            {
                goto complete;
            }
        }
        else
        {
            //
            // the user buffer is too small
            //

            Status = STATUS_BUFFER_OVERFLOW;

            //
            // is it big enough to hold the basic structure?
            //

            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                sizeof(HTTP_REQUEST))
            {
                PHTTP_REQUEST pUserRequest;

                pUserRequest = (PHTTP_REQUEST)MmGetSystemAddressForMdlSafe(
                                    pIrp->MdlAddress,
                                    NormalPagePriority
                                    );

                if (pUserRequest == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;
                }

                //
                // Copy the request ID into the output buffer. Copy it from the
                // private copy that request holds. Original opaque id may get
                // nulled if connection cleanup happens before we get here.
                //

                ASSERT(!HTTP_IS_NULL_ID(&pRequest->RequestIdCopy));

                pUserRequest->RequestId     = pRequest->RequestIdCopy;
                pUserRequest->ConnectionId  = pRequest->ConnectionId;

                //
                // and tell how much we actually need
                //

                pIrp->IoStatus.Information  = BytesNeeded;

            }
            else
            {
                //
                // Very bad, we can never get here as we check the length in ioctl.cxx
                //

                ASSERT(FALSE);

                pIrp->IoStatus.Information = 0;

            }
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    //
    // complete the irp
    //

complete:

    UlTrace(ROUTING, (
        "ul!UlpCopyRequestToIrp(\n"
        "        pRequest = %p,\n"
        "        pIrp = %p) Completing Irp\n"
        "    pAppPool                   = %p (%S)\n"
        "    pRequest->ConnectionId     = %I64x\n"
        "    pIrpSp->Parameters.DeviceIoControl.OutputBufferLength = %d\n"
        "    pIrp->IoStatus.Status      = 0x%x\n"
        "    pIrp->IoStatus.Information = %d\n",
        pRequest,
        pIrp,
        pRequest->ConfigInfo.pAppPool,
        pRequest->ConfigInfo.pAppPool->pName,
        pRequest->ConnectionId,
        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
        Status,
        pIrp->IoStatus.Information
        ));

    pIrp->IoStatus.Status = Status;

    UlCompleteRequest(pIrp, g_UlPriorityBoost);

    //
    // success.  we completed the irp
    //


}   // UlpCopyRequestToIrp


/******************************************************************************

Routine Description:

    this will return the apool object reference by this handle, bumping the
    refcount on the apool.

    this is called by UlSetConfigGroupInformation when user mode wants to
    associate an app pool to the config group by handle.

    the config group keeps a pointer to the apool.

Arguments:

    AppPool - the handle of the apool

    ppAppPool - returns the apool object the handle represented.

Return Value:

    NTSTATUS

******************************************************************************/
NTSTATUS
UlGetPoolFromHandle(
    IN HANDLE                           AppPool,
    OUT PUL_APP_POOL_OBJECT *           ppAppPool
    )
{
    NTSTATUS        Status;
    PFILE_OBJECT    pFileObject = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppAppPool != NULL);

    Status = ObReferenceObjectByHandle(
                    AppPool,
                    0,                          // DesiredAccess
                    *IoFileObjectType,          // ObjectType
                    KernelMode,                 // AccessMode
                    (void**)&pFileObject,       // Object
                    NULL                        // HandleInformation
                    );

    if (NT_SUCCESS(Status) == FALSE)
    {
        goto end;
    }

    if (IS_APP_POOL(pFileObject) == FALSE ||
        IS_VALID_AP_PROCESS(GET_APP_POOL_PROCESS(pFileObject)) == FALSE)
    {
        Status = STATUS_INVALID_HANDLE;
        goto end;
    }

    *ppAppPool = GET_APP_POOL_PROCESS(pFileObject)->pAppPool;

    ASSERT(IS_VALID_AP_OBJECT(*ppAppPool));

    REFERENCE_APP_POOL(*ppAppPool);

end:

    if (pFileObject != NULL)
    {
        ObDereferenceObject( pFileObject );
    }

    return Status;
}

/******************************************************************************

Routine Description:

    this routine is called to associate a HTTP_REQUEST with an apool
    process.

    this is basically always done (used to be for 2 [now 3] reasons):

        1) the process called ReceiveEntityBody and pended an IRP to the
        request.  if the process detaches from the apool (CloseHandle,
        ExitProcess) UlDetachProcessFromAppPool will walk the request queue
        and cancel all i/o.

        2) the request did not fit into a waiting irp, so the request is queued
        for a larger irp to come down and fetch it.

        3) the response has not been fully sent for the request.  the request
        is linked with the process so that the connection can be aborted
        if the process aborts.

Arguments:

    pProcess - the process to associate the request with.

    pRequest - the request.

Return Value:

    VOID - it always works.


******************************************************************************/
VOID
UlpQueuePendingRequest(
    IN PUL_APP_POOL_PROCESS     pProcess,
    IN PUL_INTERNAL_REQUEST     pRequest
    )
{
    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    UlTrace(ROUTING, (
        "ul!UlpQueuePendingRequest(pRequest = %p, pProcess = %p)\n"
        "    pAppPool = %p (%S)\n",
        pRequest,
        pProcess,
        pProcess->pAppPool,
        pProcess->pAppPool->pName
        ));

    UlAcquireInStackQueuedSpinLock(
        &pProcess->pAppPool->QueueSpinLock,
        &LockHandle
        );

    //
    // save a pointer to the process in the object so we can confirm
    // that it's on our list.
    //

    pRequest->AppPool.pProcess = pProcess;
    pRequest->AppPool.QueueState = QueueCopiedState;

    //
    // put it on the list
    //

    ASSERT(pRequest->AppPool.AppPoolEntry.Flink == NULL);

    Status = UlpQueueRequest(
                    &pProcess->PendingRequestQueue,
                    pRequest
                    );

    // queue is unlimited
    ASSERT(NT_SUCCESS(Status));

    UlReleaseInStackQueuedSpinLock(
        &pProcess->pAppPool->QueueSpinLock,
        &LockHandle
        );

}   // UlpQueuePendingRequest


//
// functions to manipulate a UL_REQUEST_QUEUE
//

/***************************************************************************++

Routine Description:

    Initializes a UL_REQUEST_QUEUE object.

Arguments:

    pQueue      - The queue object to initialize
    MaxRequests - The maximum allowed length of the queue

--***************************************************************************/
NTSTATUS
UlpInitRequestQueue(
    PUL_REQUEST_QUEUE   pQueue,
    LONG                MaxRequests
    )
{
    ASSERT(pQueue);

    if ((MaxRequests < 0) && (MaxRequests != -1)) {
        return STATUS_INVALID_PARAMETER;
    }

    pQueue->RequestCount = 0;
    pQueue->MaxRequests = MaxRequests;
    InitializeListHead(&pQueue->RequestHead);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Changes the maximum length of a queue.

Arguments:

    pQueue      - The queue object to change
    MaxRequests - The maximum allowed length of the queue

--***************************************************************************/
NTSTATUS
UlpSetMaxQueueLength(
    PUL_REQUEST_QUEUE   pQueue,
    LONG                MaxRequests
    )
{
    ASSERT(pQueue);

    if ((MaxRequests < 0) && (MaxRequests != -1)) {
        return STATUS_INVALID_PARAMETER;
    }

    pQueue->MaxRequests = MaxRequests;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Queries the current length of a queue.

Arguments:

    pQueue - The queue object to query

Return values:

    LONG - the current length of the queue

--***************************************************************************/
LONG
UlpQueryQueueLength(
    PUL_REQUEST_QUEUE   pQueue
    )
{
    ASSERT(pQueue);
    return pQueue->RequestCount;
}


/***************************************************************************++

Routine Description:

    Adds a request to the tail of the queue.

Arguments:

    pQueue      - The queue object
    pRequest    - The request to be added

--***************************************************************************/
NTSTATUS
UlpQueueRequest(
    PUL_REQUEST_QUEUE       pQueue,
    PUL_INTERNAL_REQUEST    pRequest
    )
{
    ASSERT(pQueue);
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    if ((pQueue->RequestCount < pQueue->MaxRequests) ||
        (pQueue->MaxRequests == -1))
    {
        //
        // add to the end of the queue
        //
        InsertTailList(&pQueue->RequestHead, &pRequest->AppPool.AppPoolEntry);
        pQueue->RequestCount++;

        ASSERT(pQueue->RequestCount >= 1);

        return STATUS_SUCCESS;
    } else {
        //
        // the queue is too full, return an error to the client
        //
        return STATUS_DEVICE_BUSY;
    }
}


/***************************************************************************++

Routine Description:

    Removes a particular request from the queue.

Arguments:

    pQueue      - The queue object
    pRequest    - The request to be removed

--***************************************************************************/
VOID
UlpRemoveRequest(
    PUL_REQUEST_QUEUE       pQueue,
    PUL_INTERNAL_REQUEST    pRequest
    )
{
    ASSERT(pQueue);
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(NULL != pRequest->AppPool.AppPoolEntry.Flink);
    
    RemoveEntryList(&pRequest->AppPool.AppPoolEntry);
    pRequest->AppPool.AppPoolEntry.Flink =
        pRequest->AppPool.AppPoolEntry.Blink = NULL;

    pQueue->RequestCount--;

    ASSERT(pQueue->RequestCount >= 0);
}


/***************************************************************************++

Routine Description:

    Removes a request from the head of a queue if there is one.
    App Pool lock must be held.

Arguments:

    pQueue      - The queue object

Return values:

    Pointer to the request or NULL if the queue is empty.

--***************************************************************************/
PUL_INTERNAL_REQUEST
UlpDequeueRequest(
    PUL_REQUEST_QUEUE   pQueue
    )
{
    PLIST_ENTRY pEntry;
    PUL_INTERNAL_REQUEST pRequest = NULL;

    ASSERT(pQueue);

    if (pQueue->RequestCount)
    {
        pEntry = RemoveHeadList(&pQueue->RequestHead);
        ASSERT(pEntry != NULL);
        pEntry->Flink = pEntry->Blink = NULL;

        pQueue->RequestCount--;

        pRequest = CONTAINING_RECORD(
                        pEntry,
                        UL_INTERNAL_REQUEST,
                        AppPool.AppPoolEntry
                        );

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        pRequest->AppPool.QueueState = QueueUnlinkedState;
    } 
    else
        ASSERT(IsListEmpty(&pQueue->RequestHead));


    return pRequest;
}

/***************************************************************************++

Routine Description:

    A little utility function to get the app pool pointer out of the
    opaque app pool process object.

Arguments:

    pProcess - the process object

--***************************************************************************/
PUL_APP_POOL_OBJECT
UlAppPoolObjectFromProcess(
    PUL_APP_POOL_PROCESS pProcess
    )
{
    PAGED_CODE();
    ASSERT(IS_VALID_AP_PROCESS(pProcess));
    ASSERT(IS_VALID_AP_OBJECT(pProcess->pAppPool));
    return pProcess->pAppPool;
}


/***************************************************************************++

Routine Description:

    Adds a config group to the list of transient registrations associated
    with this app pool.

Arguments:

    pConfigGroup - the transient group
    pAppPool - the app pool with the registration

--***************************************************************************/
VOID
UlLinkConfigGroupToAppPool(
    IN PUL_CONFIG_GROUP_OBJECT pConfigGroup,
    IN PUL_APP_POOL_OBJECT pAppPool
    )
{
    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT(IS_VALID_AP_OBJECT(pAppPool));
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));
    ASSERT(pConfigGroup->AppPoolFlags.Present);
    ASSERT(pConfigGroup->pAppPool == pAppPool);

    UlAddNotifyEntry(
        &pAppPool->TransientHead,
        &pConfigGroup->HandleEntry
        );
}


/***************************************************************************++

Routine Description:

    Determines if the specified connection has been disconnected. If so,
    the IRP is completed immediately, otherwise the IRP is pended.

Arguments:

    pProcess - the app pool process object with which the irp is associated.

    pHttpConn - Supplies the connection to wait for.
        N.B. Since this connection was retrieved via a opaque ID, it has
        an outstanding reference for this request on the assumption the
        IRP will pend. If this routine does not pend the IRP, the reference
        must be removed.

    pIrp - Supplies the IRP to either complete or pend.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlWaitForDisconnect(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_HTTP_CONNECTION pHttpConn,
    IN PIRP pIrp
    )
{
    PDRIVER_CANCEL pCancelRoutine;
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;
    PUL_DISCONNECT_OBJECT pDisconnectObj;

    //
    // Allocate an object to associate the IRP with the connection
    // and the app pool
    //
    pDisconnectObj = UlpCreateDisconnectObject(pIrp);

    if (!pDisconnectObj) {
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);
        return STATUS_NO_MEMORY;
    }

    //
    // Acquire the lock protecting the disconnect data and determine
    // if we should queue the IRP or complete it immediately.
    //

    UlAcquireResourceExclusive( &g_pUlNonpagedData->DisconnectResource, TRUE );

    if (pHttpConn->DisconnectFlag)
    {
        //
        // Connection already disconnected, complete the IRP immediately.
        //
        UlReleaseResource( &g_pUlNonpagedData->DisconnectResource );
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);
        UlpFreeDisconnectObject(pDisconnectObj);

        IoMarkIrpPending(pIrp);
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        UlCompleteRequest( pIrp, g_UlPriorityBoost );

        return STATUS_PENDING;
    }

    //
    // Save a pointer to the disconnect object in the IRP so we
    // can find it inside our cancel routine.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pDisconnectObj;

    //
    // Make the IRP cancellable.
    //

    IoMarkIrpPending( pIrp );
    IoSetCancelRoutine( pIrp, &UlpCancelWaitForDisconnect );

    if (pIrp->Cancel)
    {
        //
        // The IRP has either already been cancelled IRP is in the
        // process of being cancelled.
        //

        pCancelRoutine = IoSetCancelRoutine( pIrp, NULL );

        if (pCancelRoutine == NULL)
        {
            //
            // The previous cancel routine was already NULL, meaning that
            // it has either already run or will run Real Soon Now, so
            // we can just ignore it. Returning STATUS_PENDING causes
            // the IOCTL wrapper to not attempt to complete the IRP.
            //

            status = STATUS_PENDING;
            goto dont_queue;
        }
        else
        {
            //
            // We have to cancel it ourselves, so we'll just complete
            // the IRP immediately with STATUS_CANCELLED.
            //

            status = STATUS_CANCELLED;
            goto dont_queue;
        }
    }

    //
    // The IRP has not been cancelled yet. Queue it on the connection
    // and return with the connection still referenced. The reference
    // is removed when the IRP is dequeued & completed or cancelled.
    //
    // Also queue it on the app pool process in case the pool handle
    // gets closed before the connection does.
    //

    UlAddNotifyEntry(
        &pHttpConn->WaitForDisconnectHead,
        &pDisconnectObj->ConnectionEntry
        );

    UlAddNotifyEntry(
        &pProcess->WaitForDisconnectHead,
        &pDisconnectObj->ProcessEntry
        );

    UlReleaseResource( &g_pUlNonpagedData->DisconnectResource );

    //
    // now that we're on the lists we don't need the reference to
    // the HTTP_CONNECTION.
    //
    UL_DEREFERENCE_HTTP_CONNECTION( pHttpConn );

    return STATUS_PENDING;

dont_queue:

    UL_DEREFERENCE_HTTP_CONNECTION( pHttpConn );

    UlUnmarkIrpPending( pIrp );
    UlReleaseResource( &g_pUlNonpagedData->DisconnectResource );
    UlpFreeDisconnectObject(pDisconnectObj);
    return status;

}   // UlWaitForDisconnect


/***************************************************************************++

Routine Description:

    Cancels the pending "wait for disconnect" IRP.

Arguments:

    pDeviceObject - Supplies the device object for the request.
    pIrp - Supplies the IRP to cancel.

--***************************************************************************/
VOID
UlpCancelWaitForDisconnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // queue the cancel to a worker to ensure passive irql.
    //

    UL_CALL_PASSIVE(
        UL_WORK_ITEM_FROM_IRP( pIrp ),
        &UlpCancelWaitForDisconnectWorker
        );
}

/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem - the work item to process.

--***************************************************************************/
VOID
UlpCancelWaitForDisconnectWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    PUL_DISCONNECT_OBJECT pDisconnectObj;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // grab the disconnect object off the irp
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pDisconnectObj = (PUL_DISCONNECT_OBJECT)(
                            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer
                            );

    ASSERT(IS_VALID_DISCONNECT_OBJECT(pDisconnectObj));

    //
    // Acquire the lock protecting the disconnect data, and remove the
    // IRP if necessary.
    //

    UlAcquireResourceExclusive( &g_pUlNonpagedData->DisconnectResource, TRUE );

    UlRemoveNotifyEntry(&pDisconnectObj->ConnectionEntry);
    UlRemoveNotifyEntry(&pDisconnectObj->ProcessEntry);

    UlReleaseResource( &g_pUlNonpagedData->DisconnectResource );

    //
    // Free the disconnect object and complete the IRP.
    //

    UlpFreeDisconnectObject(pDisconnectObj);

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

}   // UlpCancelWaitForDisconnectWorker


/***************************************************************************++

Routine Description:

    Completes all WaitForDisconnect IRPs attached to an http connection
    has been disconnected.

Arguments:

    pHttpConnection - the connection that's disconnected

--***************************************************************************/
VOID
UlCompleteAllWaitForDisconnect(
    IN PUL_HTTP_CONNECTION pHttpConnection
    )
{
    PLIST_ENTRY pListEntry;
    PIRP pIrp;
    NTSTATUS Success = STATUS_SUCCESS;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

    UlAcquireResourceExclusive( &g_pUlNonpagedData->DisconnectResource, TRUE);

    //
    // prevent new IRPs from getting attached to the connection,
    // by setting the DisconnectFlag.
    //
    ASSERT(!pHttpConnection->DisconnectFlag);
    pHttpConnection->DisconnectFlag = TRUE;

    //
    // Complete any pending "wait for disconnect" IRPs.
    //

    UlNotifyAllEntries(
        &UlpNotifyCompleteWaitForDisconnect,
        &pHttpConnection->WaitForDisconnectHead,
        &Success
        );

    UlReleaseResource( &g_pUlNonpagedData->DisconnectResource );
}


/***************************************************************************++

Routine Description:

    Removes a UL_DISCONNECT_OBJECT from its lists and completes the IRP.

Arguments:

    pEntry - the notify list entry
    pHost - the UL_DISCONNECT_OBJECT
    pv - pointer to an NTSTATUS to be returned

--***************************************************************************/
BOOLEAN
UlpNotifyCompleteWaitForDisconnect(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    )
{
    PUL_DISCONNECT_OBJECT pDisconnectObj;
    PIRP pIrp;
    PDRIVER_CANCEL pCancelRoutine;
    PNTSTATUS pStatus;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT(pEntry);
    ASSERT(pHost);
    ASSERT(pv);

    pStatus = (PNTSTATUS) pv;
    pDisconnectObj = (PUL_DISCONNECT_OBJECT) pHost;
    ASSERT(IS_VALID_DISCONNECT_OBJECT(pDisconnectObj));

    //
    // remove object from lists
    //
    UlRemoveNotifyEntry(&pDisconnectObj->ConnectionEntry);
    UlRemoveNotifyEntry(&pDisconnectObj->ProcessEntry);

    //
    // complete the IRP
    //

    pIrp = pDisconnectObj->pIrp;

    //
    // We'll be completing the IRP real soon, so make it
    // non-cancellable.
    //

    pCancelRoutine = IoSetCancelRoutine( pIrp, NULL );

    if (pCancelRoutine == NULL)
    {
        //
        // The cancel routine is already NULL, meaning that the
        // cancel routine will run Real Soon Now, so we can
        // just drop this IRP on the floor.
        //
    }
    else
    {
        //
        // Complete the IRP, then free the disconnect object
        //

        pIrp->IoStatus.Status = *pStatus;
        pIrp->IoStatus.Information = 0;
        UlCompleteRequest( pIrp, g_UlPriorityBoost );

        UlpFreeDisconnectObject(pDisconnectObj);
    }

    return TRUE;
}



/***************************************************************************++

Routine Description:

    Allocates and initializes a disconnect object.

Arguments:

    pIrp - a UlWaitForDisconnect IRP

--***************************************************************************/
PUL_DISCONNECT_OBJECT
UlpCreateDisconnectObject(
    IN PIRP pIrp
    )
{
    PUL_DISCONNECT_OBJECT pObject;

    pObject = UL_ALLOCATE_STRUCT(
                    PagedPool,
                    UL_DISCONNECT_OBJECT,
                    UL_DISCONNECT_OBJECT_POOL_TAG
                    );

    if (pObject) {
        pObject->Signature = UL_DISCONNECT_OBJECT_POOL_TAG;
        pObject->pIrp = pIrp;

        UlInitializeNotifyEntry(&pObject->ProcessEntry, pObject);
        UlInitializeNotifyEntry(&pObject->ConnectionEntry, pObject);
    }

    return pObject;
}

/***************************************************************************++

Routine Description:

    Gets rid of a disconnect object

Arguments:

    pObject - the disconnect object to free

--***************************************************************************/
VOID
UlpFreeDisconnectObject(
    IN PUL_DISCONNECT_OBJECT pObject
    )
{
    UL_FREE_POOL_WITH_SIG(pObject, UL_DISCONNECT_OBJECT_POOL_TAG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\misc.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    misc.c

Abstract:

    User-mode interface to HTTP.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization.

Arguments:

    Reserved - Must be zero. May be used in future for interface version
        negotiation.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpInitialize(
    IN ULONG Reserved
    )
{
    ULONG result;

    if( Reserved == 0 ) {
        result = HttpApiInitializeEventCache();
    } else {
        result = ERROR_INVALID_PARAMETER;
    }

    return result;

} // HttpInitialize


/***************************************************************************++

Routine Description:

    Performs global termination.

--***************************************************************************/
VOID
WINAPI
HttpTerminate(
    VOID
    )
{
    ULONG result;

    result = HttpApiTerminateEventCache();

} // HttpTerminate


/***************************************************************************++

Routine Description:

    Flushes the response cache.

Arguments:

    AppPoolHandle - Supplies a handle to a application pool.

    pFullyQualifiedUrl - Supplies the fully qualified URL to flush.

    Flags - Supplies behavior control flags.

    pOverlapped - Supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpFlushResponseCache(
    IN HANDLE AppPoolHandle,
    IN PCWSTR pFullyQualifiedUrl,
    IN ULONG Flags,
    IN LPOVERLAPPED pOverlapped
    )
{
    NTSTATUS status;
    HTTP_FLUSH_RESPONSE_CACHE_INFO flushInfo;

    //
    // Initialize the input structure.
    //

    RtlInitUnicodeString( &flushInfo.FullyQualifiedUrl, pFullyQualifiedUrl );
    flushInfo.Flags = Flags;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    pOverlapped,                        // pOverlapped
                    IOCTL_HTTP_FLUSH_RESPONSE_CACHE,    // IoControlCode
                    &flushInfo,                         // pInputBuffer
                    sizeof(flushInfo),                  // InputBufferLength
                    NULL,                               // pOutputBuffer
                    0,                                  // OutputBufferLength
                    NULL                                // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpFlushResponseCache


/***************************************************************************++

Routine Description:

    Wait for a demand start notification.

Arguments:

    AppPoolHandle - Supplies a handle to a application pool.

    pBuffer - Unused, must be NULL.

    BufferLength - Unused, must be zero.

    pBytesReceived - Unused, must be NULL.

    pOverlapped - Supplies an OVERLAPPED structure.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
HttpWaitForDemandStart(
    IN HANDLE AppPoolHandle,
    IN OUT PVOID pBuffer OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    IN PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS status;

    //
    // Make the request.
    //

    status = HttpApiDeviceControl(
                    AppPoolHandle,                      // FileHandle
                    pOverlapped,                        // pOverlapped
                    IOCTL_HTTP_WAIT_FOR_DEMAND_START,   // IoControlCode
                    pBuffer,                            // pInputBuffer
                    BufferLength,                       // InputBufferLength
                    pBuffer,                            // pOutputBuffer
                    BufferLength,                       // OutputBufferLength
                    pBytesReceived                      // pBytesTransferred
                    );

    return HttpApiNtStatusToWin32Status( status );

} // HttpWaitForDemandStart


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\cachep.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    cachep.h

Abstract:

    The private definition of response cache interfaces.

Author:

    Michael Courage (mcourage)      17-May-1999

Revision History:

--*/


#ifndef _CACHEP_H_
#define _CACHEP_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// constants
//
#define CACHE_ENTRY_AGE_THRESHOLD   1
#define ZOMBIE_AGE_THRESHOLD        5

//
// Cache statistics
//
typedef struct _UL_URI_CACHE_STATS {
    ULONG       UriCount;               // entries in hash table
    ULONG       UriCountMax;            // high water mark
    ULONGLONG   UriAddedTotal;          // total entries ever added

    ULONGLONG   ByteCount;              // memory used for cache
    ULONGLONG   ByteCountMax;           // high water

    ULONG       ZombieCount;            // length of zombie list
    ULONG       ZombieCountMax;         // high water

    ULONG       HitCount;               // table lookup succeeded
    ULONG       MissTableCount;         // entry not in table
    ULONG       MissPreconditionCount;  // request not cacheable
    ULONG       MissConfigCount;        // config invalidated
} UL_URI_CACHE_STATS, *PUL_URI_CACHE_STATS;

enum ULC_RETCODE {
    ULC_SUCCESS = 0,                    // everything's okay
    ULC_KEY_EXISTS,                     // key already present for
};

enum UL_CACHE_PREDICATE {

    ULC_ABORT           = 1,            // Stop walking the table immediately
    ULC_NO_ACTION       = 2,            // No action, just keep walking
    ULC_PERFORM         = 3,            // Perform action and continue walking
    ULC_PERFORM_STOP    = 4,            // Perform action, then stop
    ULC_DELETE          = 5,            // Delete record and keep walking
    ULC_DELETE_STOP     = 6,            // Delete record, then stop
};

//
// THIS enum is primarily for debugging.
// It tells you what precondition forced a cache miss.
//
typedef enum _URI_PRECONDITION {
    URI_PRE_OK,                 // OK to serve
    URI_PRE_DISABLED,           // Cache disabled

    // request conditions
    URI_PRE_ENTITY_BODY = 10,   // There was an entity body
    URI_PRE_VERB,               // Verb wasn't GET
    URI_PRE_PROTOCOL,           // Wasn't 1.x request
    URI_PRE_TRANSLATE,          // Translate: f
    URI_PRE_AUTHORIZATION,      // Auth headers present
    URI_PRE_CONDITIONAL,        // Unhandled conditionals present
    URI_PRE_ACCEPT,             // Accept: mismatch
    URI_PRE_OTHER_HEADER,       // Other evil header present

    // response conditions
    URI_PRE_REQUEST = 50,       // Problem with the request
    URI_PRE_POLICY,             // Policy was wrong
    URI_PRE_SIZE,               // Response too big
    URI_PRE_NOMEMORY,           // No space in cache
    URI_PRE_FRAGMENT,           // Didn't get whole response
    URI_PRE_BOGUS               // Bogus response
} URI_PRECONDITION;


BOOLEAN
UlpCheckTableSpace(
    IN ULONGLONG EntrySize
    );

BOOLEAN
UlpCheckSpaceAndAddEntryStats(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );

VOID
UlpRemoveEntryStats(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );

VOID
UlpAddZombie(
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    BOOLEAN             fTakeZombieLock
    );

VOID
UlpClearZombieList(
    VOID
    );


// Passed down to the filter callback functions by UlpFilteredFlushUriCache
typedef struct _URI_FILTER_CONTEXT
{
    ULONG           Signature;      // URI_FILTER_CONTEXT_POOL_TAG
    UL_WORK_ITEM    WorkItem;       // for UlQueueWorkItem
    LIST_ENTRY      ZombieListHead; // UL_URI_CACHE_ENTRYs to be zombified
    PVOID           pCallerContext; // context passed down by caller
    ULONG           ZombieCount;    // for statistics
} URI_FILTER_CONTEXT, *PURI_FILTER_CONTEXT;

// filter function pointer
typedef
UL_CACHE_PREDICATE
(*PUL_URI_FILTER)(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pvUriFilterContext
    );

VOID
UlpFilteredFlushUriCache(
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pCallerContext
    );

UL_CACHE_PREDICATE
UlpFlushFilterAll(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    );

UL_CACHE_PREDICATE
UlpFlushFilterProcess(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    );

VOID
UlpFlushUri(
    IN PWSTR pUri,
    IN ULONG Length,
    PUL_APP_POOL_PROCESS pProcess
    );

UL_CACHE_PREDICATE
UlpZombifyEntry(
    BOOLEAN                MustZombify,
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PURI_FILTER_CONTEXT pUriFilterContext
    );

VOID
UlpZombifyList(
    IN PUL_WORK_ITEM pWorkItem
    );

//
// Cache entry stuff
//

// CODEWORK: make this function (and put in cache.h header)
PUL_URI_CACHE_ENTRY
UlAllocateUriCacheEntry(
    // much stuff
    );

VOID
UlpDestroyUriCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );


//
// Scavenger stuff
//
VOID
UlpInitializeScavenger(
    VOID
    );

VOID
UlpTerminateScavenger(
    VOID
    );

VOID
UlpSetScavengerTimer(
    VOID
    );

VOID
UlpScavengerDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
UlpScavenger(
    IN PUL_WORK_ITEM pWorkItem
    );

UL_CACHE_PREDICATE
UlpFlushFilterScavenger(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pvUriFilterContext
    );

//
// Other cache routines.
//

BOOLEAN
UlpQueryTranslateHeader(
    IN PUL_INTERNAL_REQUEST pRequest
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _CACHEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\api\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file for HTTPAPI.LIB user-mode interface to HTTP.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#define HTTPAPI_LINKAGE
#include <http.h>
#include <httpapi.h>


//
// Private macros.
//

#define ALLOC_MEM(cb) RtlAllocateHeap( RtlProcessHeap(), 0, (cb) )
#define FREE_MEM(ptr) RtlFreeHeap( RtlProcessHeap(), 0, (ptr) )

#define ALIGN_DOWN(length, type)                                \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type)                                  \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define OVERLAPPED_TO_IO_STATUS( pOverlapped )                  \
    ((PIO_STATUS_BLOCK)&(pOverlapped)->Internal)

#define DIMENSION( array )                                      \
    ( sizeof(array) / sizeof((array)[0]) )

//
// Private types.
//

typedef enum _HTTPAPI_HANDLE_TYPE
{
    HttpApiControlChannelHandleType,
    HttpApiFilterChannelHandleType,
    HttpApiAppPoolHandleType,

    HttpApiMaxHandleType

} HTTPAPI_HANDLE_TYPE;

//
// Private prototypes.
//

BOOL
WINAPI
DllMain(
    IN HMODULE DllHandle,
    IN DWORD Reason,
    IN LPVOID pContext OPTIONAL
    );

#define HttpApiNtStatusToWin32Status( Status )  \
    ( ( (Status) == STATUS_SUCCESS )            \
          ? NO_ERROR                            \
          : RtlNtStatusToDosError( Status ) )

NTSTATUS
HttpApiOpenDriverHelper(
    OUT PHANDLE pHandle,
    IN ACCESS_MASK DesiredAccess,
    IN HTTPAPI_HANDLE_TYPE HandleType,
    IN PCWSTR pObjectName OPTIONAL,
    IN ULONG Options,
    IN ULONG CreateDisposition,
    IN PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL
    );

NTSTATUS
HttpApiSynchronousDeviceControl(
    IN HANDLE FileHandle,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    );

NTSTATUS
HttpApiOverlappedDeviceControl(
    IN HANDLE FileHandle,
    IN OUT LPOVERLAPPED pOverlapped,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    );

ULONG
HttpApiInitializeEventCache(
    VOID
    );

ULONG
HttpApiTerminateEventCache(
    VOID
    );

BOOLEAN
HttpApiTryToStartDriver(
    VOID
    );

__inline
NTSTATUS
HttpApiDeviceControl(
    IN HANDLE FileHandle,
    IN OUT LPOVERLAPPED pOverlapped,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    )
{
    if (pOverlapped == NULL)
    {
        return HttpApiSynchronousDeviceControl(
                    FileHandle,
                    IoControlCode,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pBytesTransferred
                    );
    }
    else
    {
        return HttpApiOverlappedDeviceControl(
                    FileHandle,
                    pOverlapped,
                    IoControlCode,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pBytesTransferred
                    );
    }
}


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\cache.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    cache.cxx

Abstract:

    Contains the HTTP response cache logic.

Author:

    Michael Courage (mcourage)      17-May-1999

Revision History:

--*/

#include    "precomp.h"
#include    "cachep.h"


PTRACE_LOG          g_UriTraceLog;
BOOLEAN             g_InitUriCacheCalled;

//
// Global hash table
//

HASHTABLE           g_UriCacheTable;

LIST_ENTRY          g_ZombieListHead;

UL_URI_CACHE_CONFIG g_UriCacheConfig;
UL_URI_CACHE_STATS  g_UriCacheStats;

UL_SPIN_LOCK        g_UriCacheSpinLock;

//
// Scavenger stuff.
//

UL_SPIN_LOCK    g_UriScavengerSpinLock;
BOOLEAN         g_UriScavengerInitialized;
KDPC            g_UriScavengerDpc;
KTIMER          g_UriScavengerTimer;
KEVENT          g_UriScavengerTerminationEvent;
UL_WORK_ITEM    g_UriScavengerWorkItem;
LONG            g_UriScavengerRunning;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeUriCache )
#pragma alloc_text( PAGE, UlTerminateUriCache )
#pragma alloc_text( INIT, UlpInitializeScavenger )

#pragma alloc_text( PAGE, UlCheckCachePreconditions )
#pragma alloc_text( PAGE, UlCheckCacheResponseConditions )
#pragma alloc_text( PAGE, UlCheckoutUriCacheEntry )
#pragma alloc_text( PAGE, UlCheckinUriCacheEntry )
#pragma alloc_text( PAGE, UlFlushCache )
#pragma alloc_text( PAGE, UlpFlushFilterAll )
#pragma alloc_text( PAGE, UlFlushCacheByProcess )
#pragma alloc_text( PAGE, UlpFlushFilterProcess )
#pragma alloc_text( PAGE, UlFlushCacheByUri )
#pragma alloc_text( PAGE, UlpFlushUri )
#pragma alloc_text( PAGE, UlAddCacheEntry )
#pragma alloc_text( PAGE, UlpFilteredFlushUriCache )
#pragma alloc_text( PAGE, UlpAddZombie )
#pragma alloc_text( PAGE, UlpClearZombieList )
#pragma alloc_text( PAGE, UlpDestroyUriCacheEntry )
#pragma alloc_text( PAGE, UlpFlushFilterScavenger )
#pragma alloc_text( PAGE, UlpQueryTranslateHeader )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpCheckTableSpace
NOT PAGEABLE -- UlpCheckSpaceAndAddEntryStats
NOT PAGEABLE -- UlpRemoveEntryStats
NOT PAGEABLE -- UlpTerminateScavenger
NOT PAGEABLE -- UlpScavengerDpcRoutine
NOT PAGEABLE -- UlpSetScavengerTimer
NOT PAGEABLE -- UlpScavenger
#endif


/***************************************************************************++

Routine Description:

    Performs global initialization of the URI cache.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeUriCache(
    PUL_CONFIG pConfig
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( !g_InitUriCacheCalled );
    UlTrace(URI_CACHE, ("Http!UlInitializeUriCache\n"));

    if ( !g_InitUriCacheCalled )
    {
        PUL_URI_CACHE_CONFIG pUriConfig = &pConfig->UriConfig;

        g_UriCacheConfig.EnableCache        = pUriConfig->EnableCache;
        g_UriCacheConfig.MaxCacheUriCount   = pUriConfig->MaxCacheUriCount;
        g_UriCacheConfig.MaxCacheMegabyteCount =
            min((ULONG)pConfig->LargeMemMegabytes, pUriConfig->MaxCacheMegabyteCount);

        //
        // Don't want to scavenge more than once every ten seconds.
        // In particular, do not want to scavenge every 0 seconds, as the
        // machine will become completely unresponsive.
        //

        g_UriCacheConfig.ScavengerPeriod    =
            max(pUriConfig->ScavengerPeriod, 10);

        g_UriCacheConfig.MaxUriBytes        = pUriConfig->MaxUriBytes;
        g_UriCacheConfig.HashTableBits      = pUriConfig->HashTableBits;

        RtlZeroMemory(&g_UriCacheStats, sizeof(g_UriCacheStats));
        InitializeListHead(&g_ZombieListHead);

        UlInitializeSpinLock( &g_UriCacheSpinLock, "g_UriCacheSpinLock" );

        if (g_UriCacheConfig.EnableCache)
        {
            Status = UlInitializeResource(
                            &g_pUlNonpagedData->UriZombieResource,
                            "UriZombieResource",
                            0,
                            UL_ZOMBIE_RESOURCE_TAG
                            );

            if (NT_SUCCESS(Status))
            {
                Status = UlInitializeHashTable(
                        &g_UriCacheTable,
                        PagedPool, 
                        g_UriCacheConfig.HashTableBits
                        );

                if (NT_SUCCESS(Status))
                {
                    ASSERT(IS_VALID_HASHTABLE(&g_UriCacheTable));
                    
                    CREATE_REF_TRACE_LOG( g_UriTraceLog,
                                          2048 - REF_TRACE_OVERHEAD, 0 );

                    UlpInitializeScavenger();

                    g_InitUriCacheCalled = TRUE;
                }
            }
            else
            {

                UlDeleteResource(&g_pUlNonpagedData->UriZombieResource);
            }

        }
        else
        {
            UlTrace(URI_CACHE, ("URI Cache disabled.\n"));
            g_InitUriCacheCalled = TRUE;
        }

    }
    else
    {
        UlTrace(URI_CACHE, ("URI CACHE INITIALIZED TWICE!\n"));
    }

    return Status;
}   // UlInitializeUriCache


/***************************************************************************++

Routine Description:

    Performs global termination of the URI cache.

--***************************************************************************/
VOID
UlTerminateUriCache(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();
    UlTrace(URI_CACHE, ("Http!UlTerminateUriCache\n"));

    if (g_InitUriCacheCalled && g_UriCacheConfig.EnableCache)
    {
        // Must terminate the scavenger before destroying the hash table
        UlpTerminateScavenger();

        UlTerminateHashTable(&g_UriCacheTable);

        Status = UlDeleteResource(&g_pUlNonpagedData->UriZombieResource);
        ASSERT(NT_SUCCESS(Status));
        
        DESTROY_REF_TRACE_LOG( g_UriTraceLog );
        g_UriTraceLog = NULL;
    }

    g_InitUriCacheCalled = FALSE;

}   // UlTerminateUriCache

/***************************************************************************++

Routine Description:

    This routine checks a request (and its connection) to see if it's
    ok to serve this request from the cache. Basically we only accept
    simple GET requests with no conditional headers.

Arguments:

    pHttpConn - The connection to be checked

Return Value:

    BOOLEAN - True if it's ok to serve from cache

--***************************************************************************/
BOOLEAN
UlCheckCachePreconditions(
    PUL_INTERNAL_REQUEST    pRequest,
    PUL_HTTP_CONNECTION     pHttpConn
    )
{
    URI_PRECONDITION Precondition = URI_PRE_OK;

    //
    // Sanity check
    //
    PAGED_CODE();

    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConn) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );

    if (!g_UriCacheConfig.EnableCache)
    {
        Precondition = URI_PRE_DISABLED;
    }

    else if (pRequest->ParseState != ParseDoneState)
    {
        Precondition = URI_PRE_ENTITY_BODY;
    }

    else if (pRequest->Verb != HttpVerbGET)
    {
        Precondition = URI_PRE_VERB;
    }

    else if (HTTP_NOT_EQUAL_VERSION(pRequest->Version, 1, 1)
                && HTTP_NOT_EQUAL_VERSION(pRequest->Version, 1, 0))
    {
        Precondition = URI_PRE_PROTOCOL;
    }

    // check for Translate: f (DAV)
    else if ( UlpQueryTranslateHeader(pRequest) )
    {
        Precondition = URI_PRE_TRANSLATE;
    }

    // check for Authorization header
    else if (pRequest->HeaderValid[HttpHeaderAuthorization])
    {
        Precondition = URI_PRE_AUTHORIZATION;
    }

    //
    // check for some of the If-* headers
    // NOTE: See UlpCheckCacheControlHeaders for handling of other If-* headers
    //
    else if (pRequest->HeaderValid[HttpHeaderIfRange])
    {
        Precondition = URI_PRE_CONDITIONAL;
    }

    // CODEWORK: check for other evil headers
    else if (pRequest->HeaderValid[HttpHeaderRange])
    {
        Precondition = URI_PRE_OTHER_HEADER;
    }

    UlTrace(URI_CACHE, (
                "Http!UlCheckCachePreconditions(req = %p, httpconn = %p)\n"
                "        OkToServeFromCache = %d, Precondition = %d\n",
                pRequest,
                pHttpConn,
                (URI_PRE_OK == Precondition) ? 1 : 0,
                Precondition
                ));
    //
    // update stats
    //
    if (URI_PRE_OK != Precondition) {
        InterlockedIncrement((PLONG) &g_UriCacheStats.MissPreconditionCount);
    }

    return (URI_PRE_OK == Precondition);
} // UlCheckCachePreconditions


/***************************************************************************++

Routine Description:

    This routine checks a response to see if it's cacheable. Basically
    we'll take it if:

       * the cache policy is right
       * the size is small enough
       * there is room in the cache
       * we get the response all at once

Arguments:

    pHttpConn - The connection to be checked

Return Value:

    BOOLEAN - True if it's ok to serve from cache

--***************************************************************************/
BOOLEAN
UlCheckCacheResponseConditions(
    PUL_INTERNAL_REQUEST        pRequest,
    PUL_INTERNAL_RESPONSE       pResponse,
    ULONG                       Flags,
    HTTP_CACHE_POLICY           CachePolicy
    )
{
    URI_PRECONDITION Precondition = URI_PRE_OK;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE(pResponse) );

    if (pRequest->CachePreconditions == FALSE) {
        Precondition = URI_PRE_REQUEST;
    }

    // check policy
    else if (CachePolicy.Policy == HttpCachePolicyNocache) {
        Precondition = URI_PRE_POLICY;
    }

    // check size of response
    else if ((pResponse->ResponseLength - pResponse->HeaderLength) >
             g_UriCacheConfig.MaxUriBytes) {
        Precondition = URI_PRE_SIZE;
    }

    // check for full response
    else if (Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) {
        Precondition = URI_PRE_FRAGMENT;
    }

    // check available cache table space
    else if (!UlpCheckTableSpace(pResponse->ResponseLength)) {
        Precondition = URI_PRE_NOMEMORY;
    }

    // Check for bogus responses
    // BUGBUG: this check should be in ioctl.cxx
    else if ((pResponse->ResponseLength < 1) || (pResponse->ChunkCount < 2)) {
        Precondition = URI_PRE_BOGUS;
    }

    UlTrace(URI_CACHE, (
                "Http!UlCheckCacheResponseConditions(pRequest = %p, pResponse = %p)\n"
                "    OkToCache = %d, Precondition = %d\n",
                pRequest,
                pResponse,
                (URI_PRE_OK == Precondition),
                Precondition
                ));

    return (URI_PRE_OK == Precondition);
} // UlCheckCacheResponseConditions



/***************************************************************************++

Routine Description:

    This routine does a cache lookup to see if there is a valid entry
    corresponding to the request URI.

Arguments:

    pRequest - The request

Return Value:

    PUL_URI_CACHE_ENTRY - Pointer to the entry, if found. NULL otherwise.
--***************************************************************************/
PUL_URI_CACHE_ENTRY
UlCheckoutUriCacheEntry(
    PUL_INTERNAL_REQUEST pRequest
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry = NULL;
    ULONG                   BucketNumber;
    URI_KEY                 Key;

    //
    // Sanity check
    //
    PAGED_CODE();

    //
    // find bucket
    //
    Key.Hash = pRequest->CookedUrl.Hash;
    Key.Length = pRequest->CookedUrl.Length;
    Key.pUri = pRequest->CookedUrl.pUrl;

    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));

    pUriCacheEntry = UlGetFromHashTable(&g_UriCacheTable, &Key);

    if (pUriCacheEntry != NULL)
    {
        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
        ASSERT(! pUriCacheEntry->Zombie);

        InterlockedIncrement((PLONG) &pUriCacheEntry->HitCount);

        // reset scavenger counter
        pUriCacheEntry->ScavengerTicks = 0;

        UlTrace(URI_CACHE, (
                    "Http!UlCheckoutUriCacheEntry(pUriCacheEntry %p, '%ls') "
                    "refcount = %d\n",
                    pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
                    pUriCacheEntry->ReferenceCount
                    ));

        //
        // update stats
        //

        InterlockedIncrement((PLONG) &g_UriCacheStats.HitCount);
        UlIncCounter(HttpGlobalCounterUriCacheHits);
    }
    else
    {
        InterlockedIncrement((PLONG) &g_UriCacheStats.MissTableCount);
        UlIncCounter(HttpGlobalCounterUriCacheMisses);
    }

    return pUriCacheEntry;
} // UlCheckoutUriCacheEntry

/***************************************************************************++

Routine Description:

    Decrements the refcount on a cache entry. Cleans up non-cached
    entries.

Arguments:

    pUriCacheEntry - the entry to deref

--***************************************************************************/
VOID
UlCheckinUriCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    LONG ReferenceCount;
    BOOLEAN Cached;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    //
    // check to see if it was cached while we have a reference
    //
    Cached = pUriCacheEntry->Cached;

    //
    // decrement count
    //

    ReferenceCount = DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, CHECKIN);

    ASSERT(ReferenceCount >= 0);

    if (ReferenceCount == 0)
    {
        // CODEWORK: add this entry to the zombie list, instead of
        // deleting synchronously
        // Make sure the zombie list gets periodically purged, even
        // if the ScavengerPeriod is huge.

        // The refcount of a cached entry can be zero if the entry
        // was flushed from the cache while the entry was being
        // sent back to a client.

    }
    else
    {
        // If the reference was not marked as cached, its refcount
        // must now be zero
        ASSERT(Cached);
    }
} // UlCheckinUriCacheEntry



/***************************************************************************++

Routine Description:

    Removes all cache entries

--***************************************************************************/
VOID
UlFlushCache(
    VOID
    )
{
    //
    // sanity check
    //
    PAGED_CODE();
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));

    if (g_UriCacheConfig.EnableCache) {

        UlTrace(URI_CACHE, (
                    "Http!UlFlushCache()\n"
                    ));

        UlpFilteredFlushUriCache(UlpFlushFilterAll, NULL);
    }
} // UlFlushCache


/***************************************************************************++

Routine Description:

    A filter for UlFlushCache. Called by UlpFilteredFlushUriCache.

Arguments:

    pUriCacheEntry - the entry to check
    pContext - ignored

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterAll(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
    PURI_FILTER_CONTEXT  pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriFilterContext != NULL
            &&  URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature
            &&  pUriFilterContext->pCallerContext == NULL );

    UlTrace(URI_CACHE, (
        "Http!UlpFlushFilterAll(pUriCacheEntry %p '%ls') refcount = %d\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
        pUriCacheEntry->ReferenceCount));

    return UlpZombifyEntry(
                TRUE,
                pUriCacheEntry,
                pUriFilterContext
                );

} // UlpFlushFilterAll


/***************************************************************************++

Routine Description:

    Removes any cache entries that were created by the given process.

Arguments:

    pProcess - a process that is going away

--***************************************************************************/
VOID
UlFlushCacheByProcess(
    PUL_APP_POOL_PROCESS pProcess
    )
{
    //
    // sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));

    if (g_UriCacheConfig.EnableCache) {

        UlTrace(URI_CACHE, (
                    "Http!UlFlushCacheByProcess(proc = %p)\n",
                    pProcess
                    ));

        UlpFilteredFlushUriCache(UlpFlushFilterProcess, pProcess);
    }
} // UlFlushCacheByProcess


/***************************************************************************++

Routine Description:

    Removes any cache entries that were created by the given process
    whose url has a given prefix.

Arguments:

    pUri     - the uri prefix to match against
    Length   - length of the prefix
    Flags    - HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE indicates a tree flush
    pProcess - the process that made the call

--***************************************************************************/
VOID
UlFlushCacheByUri(
    IN PWSTR pUri,
    IN ULONG Length,
    IN ULONG Flags,
    PUL_APP_POOL_PROCESS pProcess
    )
{
    //
    // sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));

    if (g_UriCacheConfig.EnableCache)
    {
        UlTrace(URI_CACHE, (
                    "Http!UlFlushCacheByUri(\n"
                    "    uri   = '%S'\n"
                    "    len   = %d\n"
                    "    flags = %08x\n"
                    "    proc  = %p\n",
                    pUri,
                    Length,
                    Flags,
                    pProcess
                    ));

        if (Flags & HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE) {
            //
            // CODEWORK: restrict the flush to the ones they actually
            // asked for!
            //
            UlpFilteredFlushUriCache(UlpFlushFilterProcess, pProcess);
        } else {
            UlpFlushUri(
                pUri,
                Length,
                pProcess
                );

            UlpClearZombieList();
        }
    }
} // UlFlushCacheByUri


/***************************************************************************++

Routine Description:

    Removes a single URI from the table if the name and process match an
    entry.

Arguments:


--***************************************************************************/
VOID
UlpFlushUri(
    IN PWSTR pUri,
    IN ULONG Length,
    PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry = NULL;
    URI_KEY                 Key;
    LONG                    ReferenceCount;

    //
    // Sanity check
    //
    PAGED_CODE();

    //
    // find bucket
    //

    Key.Hash = HashRandomizeBits(HashStringNoCaseW(pUri, 0));
    Key.Length = Length;
    Key.pUri = pUri;

    pUriCacheEntry = UlDeleteFromHashTable(&g_UriCacheTable, &Key);

    if (NULL != pUriCacheEntry)
    {

        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

        UlTrace(URI_CACHE, (
            "Http!UlpFlushUri(pUriCacheEntry %p '%ls') refcount = %d\n",
            pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
            pUriCacheEntry->ReferenceCount));

        DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, FLUSH);

        //
        // Perfmon counters
        //

        UlIncCounter(HttpGlobalCounterTotalFlushedUris);
    }

} // UlpFlushUri


/***************************************************************************++

Routine Description:

    A filter for UlFlushCacheByProcess. Called by UlpFilteredFlushUriCache.

Arguments:

    pUriCacheEntry - the entry to check
    pContext - pointer to the UL_APP_POOL_PROCESS that's going away

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterProcess(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
    PURI_FILTER_CONTEXT  pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;
    PUL_APP_POOL_PROCESS pProcess;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriFilterContext != NULL
            &&  URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature
            &&  pUriFilterContext->pCallerContext != NULL );

    pProcess = (PUL_APP_POOL_PROCESS) pUriFilterContext->pCallerContext;
    ASSERT( IS_VALID_AP_PROCESS(pProcess) );

    return UlpZombifyEntry(
                (pProcess == pUriCacheEntry->pProcess),
                pUriCacheEntry,
                pUriFilterContext
                );

} // UlpFlushFilterProcess


/***************************************************************************++

Routine Description:

    Checks the hash table to make sure there is room for one more
    entry of a given size.

    This routine must be called with the table resource held.

Arguments:

    EntrySize - the size in bytes of the entry to be added

--***************************************************************************/
BOOLEAN
UlpCheckTableSpace(
    IN ULONGLONG EntrySize
    )
{
    ULONG UriCount;
    ULONGLONG ByteCount;

    UriCount  = g_UriCacheStats.UriCount + 1;
    ByteCount = g_UriCacheStats.ByteCount + EntrySize;

    //
    // CODEWORK: MaxCacheMegabyteCount of zero should mean adaptive limit,
    // but for now I'll take it to mean "no limit".
    //

    if (g_UriCacheConfig.MaxCacheMegabyteCount == 0) {
        ByteCount = 0;
    }

    //
    // MaxCacheUriCount of zero means no limit on number of URIs cached
    //

    if (g_UriCacheConfig.MaxCacheUriCount == 0) {
        UriCount = 0;
    }

    if (
        UriCount  <=  g_UriCacheConfig.MaxCacheUriCount &&
        ByteCount <= (g_UriCacheConfig.MaxCacheMegabyteCount << MEGABYTE_SHIFT)
        )
    {
        return TRUE;
    } else {
        UlTrace(URI_CACHE, (
                    "Http!UlpCheckTableSpace(%d) FALSE\n"
                    "    UriCount              = %d\n"
                    "    ByteCount             = %I64d (%dMB)\n"
                    "    MaxCacheUriCount      = %d\n"
                    "    MaxCacheMegabyteCount = %dMB\n",
                    EntrySize,
                    g_UriCacheStats.UriCount,
                    g_UriCacheStats.ByteCount,
                    g_UriCacheStats.ByteCount >> MEGABYTE_SHIFT,
                    g_UriCacheConfig.MaxCacheUriCount,
                    g_UriCacheConfig.MaxCacheMegabyteCount
                    ));

        return FALSE;
    }
} // UlpCheckTableSpace


/***************************************************************************++

Routine Description:

    Tries to add a cache entry to the hash table.

Arguments:

    pUriCacheEntry - the entry to be added

--***************************************************************************/
VOID
UlAddCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    ULC_RETCODE rc = ULC_SUCCESS;

    //
    // Sanity check
    //

    PAGED_CODE();
    ASSERT(!g_UriCacheConfig.EnableCache
           || IS_VALID_HASHTABLE(&g_UriCacheTable));
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT(! pUriCacheEntry->Zombie);

    pUriCacheEntry->BucketEntry.Next = NULL;
    pUriCacheEntry->Cached = FALSE;

    // First, check if still has space for storing the cache entry

    if (UlpCheckSpaceAndAddEntryStats(pUriCacheEntry))
    {

        pUriCacheEntry->Cached = TRUE;

        //
        // Insert this record into the hash table
        // Check first to see if the key already presents
        //

       rc = UlAddToHashTable(&g_UriCacheTable, pUriCacheEntry);

    }

    UlTrace(URI_CACHE, (
                "Http!UlAddCacheEntry(urientry %p '%ls') %s added to table. "
                "RefCount=%d, lkrc=%d.\n",
                pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
                pUriCacheEntry->Cached ? "was" : "was not",
                pUriCacheEntry->ReferenceCount,
                rc
                ));

} // UlAddCacheEntry


/***************************************************************************++

Routine Description:

    Check to see if we have space to add this cache entry and if so update
    cache statistics to reflect the addition of an entry.  This has to be
    done together inside a lock.

Arguments:

    pUriCacheEntry - entry being added

--***************************************************************************/
BOOLEAN
UlpCheckSpaceAndAddEntryStats(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    KIRQL OldIrql;
    ULONG EntrySize;

    //
    // Sanity check
    //

    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    EntrySize = pUriCacheEntry->HeaderLength + pUriCacheEntry->ContentLength;

    if (!pUriCacheEntry->LongTermCacheable)
    {
        //
        // Schedule the scavenger immediately, but only do it once
        //

        if (FALSE == InterlockedExchange(&g_UriScavengerRunning, TRUE))
        {
            UL_QUEUE_WORK_ITEM(
                &g_UriScavengerWorkItem,
                &UlpScavenger
                );
        }

        return FALSE;
    }

    UlAcquireSpinLock( &g_UriCacheSpinLock, &OldIrql );

    if (UlpCheckTableSpace(EntrySize))
    {
        g_UriCacheStats.UriCount++;
        g_UriCacheStats.UriAddedTotal++;

        g_UriCacheStats.UriCountMax = MAX(
                                        g_UriCacheStats.UriCountMax,
                                        g_UriCacheStats.UriCount
                                        );

        g_UriCacheStats.ByteCount += EntrySize;

        g_UriCacheStats.ByteCountMax = MAX(
                                        g_UriCacheStats.ByteCountMax,
                                        g_UriCacheStats.ByteCount
                                        );

        UlReleaseSpinLock( &g_UriCacheSpinLock, OldIrql );

        UlTrace(URI_CACHE, (
                "Http!UlpCheckSpaceAndAddEntryStats (urientry %p '%ls')\n",
                pUriCacheEntry, pUriCacheEntry->UriKey.pUri
                ));

        //
        // Perfmon counters
        //

        UlIncCounter(HttpGlobalCounterCurrentUrisCached);
        UlIncCounter(HttpGlobalCounterTotalUrisCached);

        return TRUE;
    }

    UlReleaseSpinLock( &g_UriCacheSpinLock, OldIrql );

    return FALSE;
} // UlpCheckSpaceAndAddEntryStats


/***************************************************************************++

Routine Description:

    Updates cache statistics to reflect the removal of an entry

Arguments:

    pUriCacheEntry - entry being added

--***************************************************************************/
VOID
UlpRemoveEntryStats(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    KIRQL OldIrql;
    ULONG EntrySize;

    //
    // Sanity check
    //

    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriCacheEntry->Cached );

    EntrySize = pUriCacheEntry->HeaderLength + pUriCacheEntry->ContentLength;

    UlAcquireSpinLock( &g_UriCacheSpinLock, &OldIrql );

    g_UriCacheStats.UriCount--;
    g_UriCacheStats.ByteCount -= EntrySize;

    UlReleaseSpinLock( &g_UriCacheSpinLock, OldIrql );

    UlTrace(URI_CACHE, (
        "Http!UlpRemoveEntryStats (urientry %p '%ls')\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri
        ));

    //
    // Perfmon counters
    //

    UlDecCounter(HttpGlobalCounterCurrentUrisCached);
} // UlpRemoveEntryStats



/***************************************************************************++

Routine Description:

    Helper function for the filter callbacks indirectly invoked by
    UlpFilteredFlushUriCache. Adds deleteable entries to a temporary
    list.

Arguments:

    MustZombify - if TRUE, add entry to the private zombie list
    pUriCacheEntry - entry to zombify
    pUriFilterContext - contains private list

--***************************************************************************/
UL_CACHE_PREDICATE
UlpZombifyEntry(
    BOOLEAN                MustZombify,
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PURI_FILTER_CONTEXT pUriFilterContext
    )
{
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT(URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature);

    ASSERT(! pUriCacheEntry->Zombie);
    ASSERT(NULL == pUriCacheEntry->ZombieListEntry.Flink);

    if (MustZombify)
    {
        //
        // Temporarily bump the refcount up so that it won't go down
        // to zero when it's removed from the hash table, automatically
        // invoking UlpDestroyUriCacheEntry, which we are trying to defer.
        //
        pUriCacheEntry->ZombieAddReffed = TRUE;

        REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, ZOMBIFY);

        InsertTailList(
            &pUriFilterContext->ZombieListHead,
            &pUriCacheEntry->ZombieListEntry);

        pUriCacheEntry->Zombie = TRUE;

        //
        // reset timer so we can track how long an entry is on the list
        //
        pUriCacheEntry->ScavengerTicks = 0;

        ++ pUriFilterContext->ZombieCount;

        // now remove it from the hash table
        return ULC_DELETE;
    }

    // do not remove pUriCacheEntry from table
    return ULC_NO_ACTION;
} // UlpZombifyEntry



/***************************************************************************++

Routine Description:

    Adds a list of entries to the global zombie list, then calls
    UlpClearZombieList. This cleans up the list of deferred deletions
    built up by UlpFilteredFlushUriCache.
    Runs at passive level.

Arguments:

    pWorkItem - workitem within a URI_FILTER_CONTEXT containing private list

--***************************************************************************/
VOID
UlpZombifyList(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PAGED_CODE();

    ASSERT(NULL != pWorkItem);

    PURI_FILTER_CONTEXT pUriFilterContext
        = CONTAINING_RECORD(pWorkItem, URI_FILTER_CONTEXT, WorkItem);

    ASSERT(URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature);

    UlTrace(URI_CACHE, (
        "http!UlpZombifyList, ctxt = %p\n",
        pUriFilterContext
        ));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->UriZombieResource, TRUE);

    //
    // Splice the entire private list into the head of the Zombie list
    //

    ASSERT(! IsListEmpty(&pUriFilterContext->ZombieListHead));

    PLIST_ENTRY pContextHead = pUriFilterContext->ZombieListHead.Flink;
    PLIST_ENTRY pContextTail = pUriFilterContext->ZombieListHead.Blink;
    PLIST_ENTRY pZombieHead  = g_ZombieListHead.Flink;

    pContextTail->Flink = pZombieHead;
    pZombieHead->Blink  = pContextTail;

    g_ZombieListHead.Flink = pContextHead;
    pContextHead->Blink    = &g_ZombieListHead;

    // Update stats
    g_UriCacheStats.ZombieCount += pUriFilterContext->ZombieCount;
    g_UriCacheStats.ZombieCountMax = MAX(g_UriCacheStats.ZombieCount,
                                         g_UriCacheStats.ZombieCountMax);

#if DBG
    PLIST_ENTRY pEntry;
    ULONG       ZombieCount;

    // Walk forwards through the zombie list and check that it contains
    // exactly as many valid zombied UriCacheEntries as we expect.
    for (pEntry =  g_ZombieListHead.Flink, ZombieCount = 0;
         pEntry != &g_ZombieListHead;
         pEntry =  pEntry->Flink, ++ZombieCount)
    {
        PUL_URI_CACHE_ENTRY pUriCacheEntry
            = CONTAINING_RECORD(pEntry, UL_URI_CACHE_ENTRY, ZombieListEntry);

        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
        ASSERT(pUriCacheEntry->Zombie);
        ASSERT(pUriCacheEntry->ZombieAddReffed
               ?  pUriCacheEntry->ScavengerTicks == 0
               :  pUriCacheEntry->ScavengerTicks > 0);
        ASSERT(ZombieCount < g_UriCacheStats.ZombieCount);
    }

    ASSERT(ZombieCount == g_UriCacheStats.ZombieCount);

    // And backwards too, like Ginger Rogers
    for (pEntry =  g_ZombieListHead.Blink, ZombieCount = 0;
         pEntry != &g_ZombieListHead;
         pEntry =  pEntry->Blink, ++ZombieCount)
    {
        PUL_URI_CACHE_ENTRY pUriCacheEntry
            = CONTAINING_RECORD(pEntry, UL_URI_CACHE_ENTRY, ZombieListEntry);

        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
        ASSERT(pUriCacheEntry->Zombie);
        ASSERT(pUriCacheEntry->ZombieAddReffed
               ?  pUriCacheEntry->ScavengerTicks == 0
               :  pUriCacheEntry->ScavengerTicks > 0);
        ASSERT(ZombieCount < g_UriCacheStats.ZombieCount);
    }

    ASSERT(ZombieCount == g_UriCacheStats.ZombieCount);
#endif // DBG

    UlReleaseResource(&g_pUlNonpagedData->UriZombieResource);

    UL_FREE_POOL_WITH_SIG(pUriFilterContext, URI_FILTER_CONTEXT_POOL_TAG);

    // Now purge those entries, if there are no outstanding references
    UlpClearZombieList();

} // UlpZombifyList



/***************************************************************************++

Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a
    parameter. The function will be called with each item in the cache.
    The function should conclude with a call to UlpZombifyEntry, passing
    in whether or not the item should be deleted. See sample usage
    elsewhere in this file.

Arguments:

    pFilterRoutine - A pointer to the filter function
    pCallerContext - a parameter to the filter function

--***************************************************************************/
VOID
UlpFilteredFlushUriCache(
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pCallerContext
    )
{
    PURI_FILTER_CONTEXT pUriFilterContext;
    LONG                ZombieCount = 0;

    //
    // sanity check
    //

    PAGED_CODE();
    ASSERT( NULL != pFilterRoutine );

    //
    // Perfmon counters
    //

    UlIncCounter(HttpGlobalCounterUriCacheFlushes);

    pUriFilterContext = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    URI_FILTER_CONTEXT,
                    URI_FILTER_CONTEXT_POOL_TAG);

    if (pUriFilterContext == NULL)
        return;

    pUriFilterContext->Signature = URI_FILTER_CONTEXT_POOL_TAG;
    InitializeListHead(&pUriFilterContext->ZombieListHead);
    pUriFilterContext->pCallerContext = pCallerContext;
    pUriFilterContext->ZombieCount = 0;

    UlTrace(URI_CACHE, (
                "Http!UlFilteredFlushUriCache(filt = %p, ctxt = %p)\n",
                pFilterRoutine, pUriFilterContext
                ));

    if (IS_VALID_HASHTABLE(&g_UriCacheTable))
    {
        ZombieCount = UlFilterFlushHashTable(
                            &g_UriCacheTable,
                            pFilterRoutine,
                            pUriFilterContext
                            );
        
        ASSERT(ZombieCount == pUriFilterContext->ZombieCount);

        if (0 != ZombieCount)
        {
            UlAddCounter(HttpGlobalCounterTotalFlushedUris, ZombieCount);

            UL_QUEUE_WORK_ITEM(
                &pUriFilterContext->WorkItem,
                UlpZombifyList
                );
        }
        else
        {
            UL_FREE_POOL_WITH_SIG(pUriFilterContext,
                                  URI_FILTER_CONTEXT_POOL_TAG);
        }

        UlTrace(URI_CACHE, (
                    "Http!UlFilteredFlushUriCache(filt = %p, caller ctxt = %p)"
                    " Zombified: %d\n",
                    pFilterRoutine,
                    pCallerContext,
                    ZombieCount
                    ));
    }

} // UlpFilteredFlushUriCache

/***************************************************************************++

Routine Description:

    Scans the zombie list for entries whose refcount has dropped to "zero".
    (The calling routine is generally expected to have added a reference
    (and set the ZombieAddReffed field within the entries), so that
    otherwise unreferenced entries will actually have a refcount of one. It
    works this way because we don't want the scavenger directly triggering
    calls to UlpDestroyUriCacheEntry)

--***************************************************************************/
VOID
UlpClearZombieList(
    VOID
    )
{
    ULONG               ZombiesFreed = 0;
    ULONG               ZombiesSpared = 0;
    PLIST_ENTRY         pCurrent;
    LONG                ReferenceCount;

    //
    // sanity check
    //
    PAGED_CODE();

    UlAcquireResourceExclusive(&g_pUlNonpagedData->UriZombieResource, TRUE);

    pCurrent = g_ZombieListHead.Flink;

    while (pCurrent != &g_ZombieListHead)
    {
        PUL_URI_CACHE_ENTRY pUriCacheEntry
            = CONTAINING_RECORD(pCurrent, UL_URI_CACHE_ENTRY, ZombieListEntry);

        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
        ASSERT(pUriCacheEntry->Zombie);

        //
        // get next entry now, because we might destroy this one
        //
        pCurrent = pCurrent->Flink;

        //
        // ReferenceCount is modified with interlocked ops, but in
        // this case we know the ReferenceCount can't go up on
        // a Zombie, and if an entry hits one just after we look
        // at it, we'll just get it on the next pass
        //
        if (pUriCacheEntry->ZombieAddReffed)
        {
            bool LastRef = (pUriCacheEntry->ReferenceCount == 1);

            if (LastRef)
            {
                RemoveEntryList(&pUriCacheEntry->ZombieListEntry);
                pUriCacheEntry->ZombieListEntry.Flink = NULL;
                ++ ZombiesFreed;

                ASSERT(g_UriCacheStats.ZombieCount > 0);
                -- g_UriCacheStats.ZombieCount;
            }
            else
            {
                // track age of zombie
                ++ pUriCacheEntry->ScavengerTicks;
                ++ ZombiesSpared;
            }

            pUriCacheEntry->ZombieAddReffed = FALSE;

            DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, UNZOMBIFY);
        }
        else
        {
            ASSERT(pUriCacheEntry->ScavengerTicks > 0);

            // If we've released the zombie reference on it and it's still
            // on the zombie list, somebody'd better have a reference.
            ASSERT(pUriCacheEntry->ReferenceCount > 0);

            // track age of zombie
            ++ pUriCacheEntry->ScavengerTicks;
            ++ ZombiesSpared;

            if (pUriCacheEntry->ScavengerTicks > ZOMBIE_AGE_THRESHOLD)
            {
                UlTrace(URI_CACHE, (
                            "Http!UlpClearZombieList()\n"
                            "    WARNING: %p '%ls' (refs = %d) "
                            "has been a zombie for %d ticks!\n",
                            pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
                            pUriCacheEntry->ReferenceCount,
                            pUriCacheEntry->ScavengerTicks
                            ));
            }
        }
    }

    ASSERT(ZombiesSpared == g_UriCacheStats.ZombieCount);

    ASSERT((g_UriCacheStats.ZombieCount == 0)
                == IsListEmpty(&g_ZombieListHead));

    UlReleaseResource(&g_pUlNonpagedData->UriZombieResource);

    UlTrace(URI_CACHE, (
                "Http!UlpClearZombieList(): Freed = %d, Remaining = %d.\n",
                ZombiesFreed,
                ZombiesSpared
                ));
} // UlpClearZombieList


/***************************************************************************++

Routine Description:

    Frees a URI entry to the pool. Removes references to other objects.

Arguments:

    pTracker - Supplies the UL_READ_TRACKER to manipulate.

--***************************************************************************/
VOID
UlpDestroyUriCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    )
{
    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    // CODEWORK: real cleanup will need to release
    // config & process references.

    ASSERT(0 == pUriCacheEntry->ReferenceCount);

    UlTrace(URI_CACHE, (
        "Http!UlpDestroyUriCacheEntry: Entry %p, '%ls', Refs=%d\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
        pUriCacheEntry->ReferenceCount
        ));

    //
    // Release the UL_URL_CONFIG_GROUP_INFO block
    //

    UlpConfigGroupInfoRelease(&pUriCacheEntry->ConfigInfo);

    UlLargeMemFree(pUriCacheEntry->pResponseMdl);

    //
    // Remove from g_ZombieListHead if neccessary
    //

    if (pUriCacheEntry->ZombieListEntry.Flink != NULL)
    {
        ASSERT(pUriCacheEntry->Zombie);
        ASSERT(! pUriCacheEntry->ZombieAddReffed);

        UlAcquireResourceExclusive(
            &g_pUlNonpagedData->UriZombieResource,
            TRUE);

        RemoveEntryList(&pUriCacheEntry->ZombieListEntry);

        ASSERT(g_UriCacheStats.ZombieCount > 0);
        -- g_UriCacheStats.ZombieCount;

        UlReleaseResource(&g_pUlNonpagedData->UriZombieResource);
    }

    UL_FREE_POOL_WITH_SIG(
        pUriCacheEntry,
        UL_URI_CACHE_ENTRY_POOL_TAG
        );
} // UlpDestroyUriCacheEntry



/***************************************************************************++

Routine Description:

    Initializes the cache scavenger.

--***************************************************************************/
VOID
UlpInitializeScavenger(
    VOID
    )
{
    UlTrace(URI_CACHE, (
                "Http!UlpInitializeScavenger\n"
                ));

    g_UriScavengerInitialized = TRUE;
    g_UriScavengerRunning = FALSE;

    UlInitializeSpinLock(
        &g_UriScavengerSpinLock,
        "g_UriScavengerSpinLock"
        );

    KeInitializeDpc(
        &g_UriScavengerDpc,         // DPC object
        &UlpScavengerDpcRoutine,    // DPC routine
        NULL                        // context
        );

    KeInitializeTimer(
        &g_UriScavengerTimer
        );

    KeInitializeEvent(
        &g_UriScavengerTerminationEvent,
        NotificationEvent,
        FALSE
        );

    UlpSetScavengerTimer();

} // UlpInitializeScavenger



/***************************************************************************++

Routine Description:

    Increments the current chunk pointer in the tracker and initializes
    some of the "from file" related tracker fields if necessary.

Arguments:

    pTracker - Supplies the UL_READ_TRACKER to manipulate.

--***************************************************************************/
VOID
UlpTerminateScavenger(
    VOID
    )
{
    KIRQL oldIrql;

    UlTrace(URI_CACHE, (
                "Http!UlpTerminateScavenger\n"
                ));


    if (g_UriScavengerInitialized)
    {
        //
        // Clear the "initialized" flag. If the scavenger runs soon,
        // it will see this flag, set the termination event, and exit
        // quickly.
        //

        UlAcquireSpinLock(
            &g_UriScavengerSpinLock,
            &oldIrql
            );

        g_UriScavengerInitialized = FALSE;

        UlReleaseSpinLock(
            &g_UriScavengerSpinLock,
            oldIrql
            );

        //
        // Cancel the scavenger timer. If the cancel fails, then the
        // scavenger is either running or scheduled to run soon. In
        // either case, wait for it to terminate.
        //

        if ( !KeCancelTimer( &g_UriScavengerTimer ) )
        {
            KeWaitForSingleObject(
                (PVOID)&g_UriScavengerTerminationEvent,
                UserRequest,
                KernelMode,
                FALSE,
                NULL
                );
        }
    }

    //
    // clear out anything remaining
    //
    UlpClearZombieList();

    //
    // The EndpointDrain should have closed all connections and released
    // all references to cache entries
    //
    ASSERT( g_UriCacheStats.ZombieCount == 0 );
    ASSERT( IsListEmpty(&g_ZombieListHead) );
} // UlpTerminateScavenger



/***************************************************************************++

Routine Description:

    Figures out the scavenger interval in 100 ns ticks, and sets the timer.

--***************************************************************************/
VOID
UlpSetScavengerTimer(
    VOID
    )
{
    LARGE_INTEGER ScavengerInterval;

    //
    // convert seconds to 100 nanosecond intervals (x * 10^7)
    // negative numbers mean relative time
    //

    ScavengerInterval.QuadPart= g_UriCacheConfig.ScavengerPeriod
                                  * -C_NS_TICKS_PER_SEC;

    UlTrace(URI_CACHE, (
                "Http!UlpSetScavengerTimer: %d seconds = %I64d 100ns ticks\n",
                g_UriCacheConfig.ScavengerPeriod,
                ScavengerInterval.QuadPart
                ));

    KeSetTimer(
        &g_UriScavengerTimer,
        ScavengerInterval,
        &g_UriScavengerDpc
        );

} // UlpSetScavengerTimer


/***************************************************************************++

Routine Description:

    Executes every UriScavengerPeriodSeconds, or when our timer gets
    cancelled (on shutdown). If we're not shutting down, we run the
    UlpScavenger (at passive level).

Arguments:

    I ignore all of these.

--***************************************************************************/
VOID
UlpScavengerDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{

//    UlTrace(URI_CACHE, (
//                "Http!UlpScavengerDpcRoutine(...)\n"
//                ));

    UlAcquireSpinLockAtDpcLevel(
        &g_UriScavengerSpinLock
        );

    if( !g_UriScavengerInitialized ) {

        //
        // We're shutting down, so signal the termination event.
        //

        KeSetEvent(
            &g_UriScavengerTerminationEvent,
            0,
            FALSE
            );

    } else {

        //
        // Do that scavenger thang.
        //

        if (FALSE == InterlockedExchange(&g_UriScavengerRunning, TRUE)) {

            UL_QUEUE_WORK_ITEM(
                &g_UriScavengerWorkItem,
                &UlpScavenger
            );
        }
    }

    UlReleaseSpinLockFromDpcLevel(
        &g_UriScavengerSpinLock
        );

} // UlpScavengerDpcRoutine


/***************************************************************************++

Routine Description:

    Looks through the cache for expired entries to put on the zombie list,
    and then empties out the list.

Arguments:

    pWorkItem - ignored

--***************************************************************************/
VOID
UlpScavenger(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    KIRQL oldIrql;

    UlTrace(URI_CACHE, (
                "Http!UlpScavenger()\n"
                ));

    ASSERT( TRUE == g_UriScavengerRunning );
    ASSERT( &g_UriScavengerWorkItem == pWorkItem );

    if (g_UriScavengerInitialized)
    {
        UlpFilteredFlushUriCache(UlpFlushFilterScavenger, NULL);

        //
        // allow other instances of the scavenger to run
        //
        InterlockedExchange(&g_UriScavengerRunning, FALSE);
    }

    UlAcquireSpinLock(&g_UriScavengerSpinLock, &oldIrql);

    if (g_UriScavengerInitialized)
    {
        //
        // restart the timer
        //

        UlpSetScavengerTimer();
    }
    else
    {
        KeSetEvent(
            &g_UriScavengerTerminationEvent,
            0,
            FALSE
            );
    }

    UlReleaseSpinLock(&g_UriScavengerSpinLock, oldIrql);

} // UlpScavenger


/***************************************************************************++

Routine Description:

    A filter for UlpScavenger. Called by UlpFilteredFlushUriCache.

Arguments:

    pUriCacheEntry - the entry to check
    pContext - ignored

--***************************************************************************/
UL_CACHE_PREDICATE
UlpFlushFilterScavenger(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN PVOID               pContext
    )
{
    PURI_FILTER_CONTEXT pUriFilterContext = (PURI_FILTER_CONTEXT) pContext;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( pUriFilterContext != NULL
            &&  URI_FILTER_CONTEXT_POOL_TAG == pUriFilterContext->Signature
            &&  pUriFilterContext->pCallerContext == NULL );

    pUriCacheEntry->ScavengerTicks++;

    //
    // CODEWORK: need to check for expiration time as well
    //

    return UlpZombifyEntry(
                (pUriCacheEntry->ScavengerTicks > CACHE_ENTRY_AGE_THRESHOLD),
                pUriCacheEntry,
                pUriFilterContext
                );

} // UlpFlushFilterScavenger



/***************************************************************************++

Routine Description:

    Determine if the Translate header is present AND has a value of 'F' or 'f'.

Arguments:

    pRequest - Supplies the request to query.

Return Value:

    BOOLEAN - TRUE if "Translate: F", FALSE otherwise

--***************************************************************************/
BOOLEAN
UlpQueryTranslateHeader(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    BOOLEAN ret = FALSE;

    if ( pRequest->HeaderValid[HttpHeaderTranslate] )
    {
        PUCHAR pValue = pRequest->Headers[HttpHeaderTranslate].pHeader;

        ASSERT(NULL != pValue);

        if ('f' == pValue[0] || 'F' == pValue[0])
        {
            ret = TRUE;
        }
    }

    return ret;

} // UlpQueryTranslateHeader

/***************************************************************************++

Routine Description:

    Add a reference on a cache entry

Arguments:

    pUriCacheEntry - the entry to addref

--***************************************************************************/
LONG
UlAddRefUriCacheEntry(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN REFTRACE_ACTION     Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    LONG RefCount = InterlockedIncrement(&pUriCacheEntry->ReferenceCount);

    WRITE_REF_TRACE_LOG(
        g_UriTraceLog,
        Action,
        RefCount,
        pUriCacheEntry,
        pFileName,
        LineNumber
        );

    UlTrace(URI_CACHE, (
        "Http!UlAddRefUriCacheEntry: Entry %p, refcount=%d.\n",
        pUriCacheEntry, RefCount
        ));

    ASSERT(RefCount > 0);

    return RefCount;

} // UlAddRefUriCacheEntry



/***************************************************************************++

Routine Description:

    Release a reference on a cache entry

Arguments:

    pUriCacheEntry - the entry to release

--***************************************************************************/
LONG
UlReleaseUriCacheEntry(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN REFTRACE_ACTION     Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    LONG RefCount = InterlockedDecrement(&pUriCacheEntry->ReferenceCount);

    WRITE_REF_TRACE_LOG(
        g_UriTraceLog,
        Action,
        RefCount,
        pUriCacheEntry,
        pFileName,
        LineNumber
        );

    UlTrace(URI_CACHE, (
        "Http!UlReleaseUriCacheEntry: (pUriCacheEntry %p '%ls')"
        "refcount = %d\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri,
        RefCount
        ));

    ASSERT(RefCount >= 0);

    if (RefCount == 0)
    {
        if (pUriCacheEntry->Cached)
            UlpRemoveEntryStats(pUriCacheEntry);

        UlpDestroyUriCacheEntry(pUriCacheEntry);
    }

    return RefCount;

} // UlReleaseUriCacheEntry



/***************************************************************************++

Routine Description:

    UL_URI_CACHE_ENTRY pseudo-constructor. Primarily used for
    AddRef and tracelogging.

Arguments:

    pUriCacheEntry - the entry to initialize
    Hash - Hash code of pUrl
    Length - Length (in bytes) of pUrl
    pUrl - Unicode URL to copy

--***************************************************************************/
VOID
UlInitCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    ULONG               Hash,
    ULONG               Length,
    PCWSTR              pUrl
    )
{
    pUriCacheEntry->Signature = UL_URI_CACHE_ENTRY_POOL_TAG;
    pUriCacheEntry->ReferenceCount = 0;
    pUriCacheEntry->HitCount = 1;
    pUriCacheEntry->Zombie = FALSE;
    pUriCacheEntry->ZombieAddReffed = FALSE;
    pUriCacheEntry->ZombieListEntry.Flink = NULL;
    pUriCacheEntry->ZombieListEntry.Blink = NULL;
    pUriCacheEntry->Cached = FALSE;
    pUriCacheEntry->ScavengerTicks = 0;

    pUriCacheEntry->UriKey.Hash = Hash;
    pUriCacheEntry->UriKey.Length = Length;
    pUriCacheEntry->UriKey.pUri = (PWSTR) ((PCHAR)pUriCacheEntry +
                                ALIGN_UP(sizeof(UL_URI_CACHE_ENTRY), PVOID));

    RtlCopyMemory(
        pUriCacheEntry->UriKey.pUri,
        pUrl,
        pUriCacheEntry->UriKey.Length + sizeof(WCHAR)
        );

    REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, CREATE);

    UlTrace(URI_CACHE, (
        "Http!UlInitCacheEntry (%p = '%ls')\n",
        pUriCacheEntry, pUriCacheEntry->UriKey.pUri
        ));

} // UlInitCacheEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\cache.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    cache.h

Abstract:

    The public definition of response cache interfaces.

Author:

    Michael Courage (mcourage)      17-May-1999

Revision History:

--*/


#ifndef _CACHE_H_
#define _CACHE_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Forwards
//
typedef struct _UL_INTERNAL_RESPONSE *PUL_INTERNAL_RESPONSE;
typedef struct _UL_INTERNAL_DATA_CHUNK *PUL_INTERNAL_DATA_CHUNK;

//
// Cache configuration
//
typedef struct _UL_URI_CACHE_CONFIG {
    BOOLEAN     EnableCache;
    ULONG       MaxCacheUriCount;
    ULONG       MaxCacheMegabyteCount;
    ULONG       ScavengerPeriod;
    ULONG       MaxUriBytes;
    LONG        HashTableBits;
} UL_URI_CACHE_CONFIG, *PUL_URI_CACHE_CONFIG;

extern UL_URI_CACHE_CONFIG g_UriCacheConfig;


//
// Structure of an HTTP cache table entry.
//

typedef struct _URI_KEY
{
    ULONG               Hash;
    ULONG               Length; // #bytes in pUri, excluding L'\0'
    PWSTR               pUri;
} URI_KEY, *PURI_KEY;


//
// Structure for holding the split-up content type.  Assumes that types and
// subtypes will never be longer than MAX_TYPE_LEN.
//
#define MAX_TYPE_LENGTH     32
#define MAX_SUBTYPE_LENGTH  64

typedef struct _UL_CONTENT_TYPE
{
    ULONG       TypeLen;
    UCHAR       Type[MAX_TYPE_LENGTH];

    ULONG       SubTypeLen;
    UCHAR       SubType[MAX_SUBTYPE_LENGTH];

} UL_CONTENT_TYPE, *PUL_CONTENT_TYPE;


#define IS_VALID_URI_CACHE_ENTRY(pEntry) \
    ((pEntry) != NULL  &&  UL_URI_CACHE_ENTRY_POOL_TAG == (pEntry)->Signature)

typedef struct _UL_URI_CACHE_ENTRY  // CacheEntry
{
    //
    // PagedPool
    //

    ULONG                   Signature;      // UL_URI_CACHE_ENTRY_POOL_TAG

    LONG                    ReferenceCount;

    //
    // cache info
    //
    SINGLE_LIST_ENTRY       BucketEntry;

    URI_KEY                 UriKey;


    ULONG                   HitCount;

    LIST_ENTRY              ZombieListEntry;
    BOOLEAN                 Zombie;
    BOOLEAN                 ZombieAddReffed;

    BOOLEAN                 Cached;
    BOOLEAN                 ContentLengthSpecified; // hack
    USHORT                  StatusCode;
    HTTP_VERB               Verb;
    ULONG                   ScavengerTicks;

    HTTP_CACHE_POLICY       CachePolicy;
    LARGE_INTEGER           ExpirationTime;

    //
    // System time of Date that went out on original response
    //
    LARGE_INTEGER           CreationTime;

    //
    // ETag of original response
    //
    ULONG                   ETagLength; // Including NULL
    PUCHAR                  pETag;

    //
    // Content-Type of original response
    //
    UL_CONTENT_TYPE         ContentType;

    //
    // config and process data for invalidation
    //
    UL_URL_CONFIG_GROUP_INFO    ConfigInfo;

    PUL_APP_POOL_PROCESS    pProcess;

    //
    // Response data
    //
    ULONG                   HeaderLength;
    ULONG                   ContentLength;
    PMDL                    pResponseMdl;   // including content + header
    BOOLEAN                 LongTermCacheable;

    //
    // Logging Information
    //

    BOOLEAN                 LoggingEnabled;
    USHORT                  UsedOffset1;
    USHORT                  UsedOffset2;
    ULONG                   MaxLength;
    ULONG                   LogDataLength;
    PUCHAR                  pLogData;

    // WSTR                 Uri[];
    // UCHAR                ETag[];
    // UCHAR                LogData[];

} UL_URI_CACHE_ENTRY, *PUL_URI_CACHE_ENTRY;




//
// public functions
//
NTSTATUS
UlInitializeUriCache(
    PUL_CONFIG pConfig
    );

VOID
UlTerminateUriCache(
    VOID
    );

VOID
UlInitCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    ULONG               Hash,
    ULONG               Length,
    PCWSTR              pUrl
    );

VOID
UlAddCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );

PUL_URI_CACHE_ENTRY
UlCheckoutUriCacheEntry(
    PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlCheckinUriCacheEntry(
    PUL_URI_CACHE_ENTRY pUriCacheEntry
    );

VOID
UlFlushCache(
    VOID
    );

VOID
UlFlushCacheByProcess(
    PUL_APP_POOL_PROCESS pProcess
    );

VOID
UlFlushCacheByUri(
    IN PWSTR pUri,
    IN ULONG Length,
    IN ULONG Flags,
    PUL_APP_POOL_PROCESS pProcess
    );


//
// cachability test functions
//


BOOLEAN
UlCheckCachePreconditions(
    PUL_INTERNAL_REQUEST    pRequest,
    PUL_HTTP_CONNECTION     pHttpConn
    );

BOOLEAN
UlCheckCacheResponseConditions(
    PUL_INTERNAL_REQUEST        pRequest,
    PUL_INTERNAL_RESPONSE       pResponse,
    ULONG                       Flags,
    HTTP_CACHE_POLICY           CachePolicy
    );

// reference counting

LONG
UlAddRefUriCacheEntry(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN REFTRACE_ACTION     Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

LONG
UlReleaseUriCacheEntry(
    IN PUL_URI_CACHE_ENTRY pUriCacheEntry,
    IN REFTRACE_ACTION     Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_URI_CACHE_ENTRY( pEntry, Action )                         \
    UlAddRefUriCacheEntry(                                                  \
        (pEntry),                                                           \
        (REF_ACTION_##Action##_URI_ENTRY)                                   \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define DEREFERENCE_URI_CACHE_ENTRY( pEntry, Action )                       \
    UlReleaseUriCacheEntry(                                                 \
        (pEntry),                                                           \
        (REF_ACTION_##Action##_URI_ENTRY)                                   \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

#endif // _CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\cgroup.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    cgroup.cxx

Abstract:

    Note that most of the routines in this module assume they are called
    at PASSIVE_LEVEL.


Author:

    Paul McDaniel (paulmcd)       12-Jan-1999

Revision History:

--*/

#include "precomp.h"        // Project wide headers
#include "cgroupp.h"        // Private data structures

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeCG )
#pragma alloc_text( PAGE, UlTerminateCG )

#pragma alloc_text( PAGE, UlAddUrlToConfigGroup )
#pragma alloc_text( PAGE, UlConfigGroupFromListEntry )
#pragma alloc_text( PAGE, UlCreateConfigGroup )
#pragma alloc_text( PAGE, UlDeleteConfigGroup )
#pragma alloc_text( PAGE, UlGetConfigGroupInfoForUrl )
#pragma alloc_text( PAGE, UlQueryConfigGroupInformation )
#pragma alloc_text( PAGE, UlRemoveUrlFromConfigGroup )
#pragma alloc_text( PAGE, UlRemoveAllUrlsFromConfigGroup )
#pragma alloc_text( PAGE, UlAddTransientUrl )
#pragma alloc_text( PAGE, UlRemoveTransientUrl )
#pragma alloc_text( PAGE, UlSetConfigGroupInformation )
#pragma alloc_text( PAGE, UlNotifyOrphanedConfigGroup )

#pragma alloc_text( PAGE, UlpCreateConfigGroupObject )
#pragma alloc_text( PAGE, UlpCleanAllUrls )
#pragma alloc_text( PAGE, UlpDeferredRemoveSite )
#pragma alloc_text( PAGE, UlpDeferredRemoveSiteWorker )
#pragma alloc_text( PAGE, UlpSanitizeUrl )
#pragma alloc_text( PAGE, UlpSetUrlInfo )
#pragma alloc_text( PAGE, UlpConfigGroupInfoRelease )
#pragma alloc_text( PAGE, UlpConfigGroupInfoDeepCopy )
#pragma alloc_text( PAGE, UlpTreeFreeNode )
#pragma alloc_text( PAGE, UlpTreeFindNode )
#pragma alloc_text( PAGE, UlpTreeFindNodeWalker )
#pragma alloc_text( PAGE, UlpTreeFindEntry )
#pragma alloc_text( PAGE, UlpTreeFindSite )
#pragma alloc_text( PAGE, UlpTreeFindWildcardMatch )
#pragma alloc_text( PAGE, UlpTreeFindIpMatch )
#pragma alloc_text( PAGE, UlpTreeInsert )
#pragma alloc_text( PAGE, UlpTreeInsertEntry )
#endif  // ALLOC_PRAGMA

#if 0
#endif

//
// Globals
//

PUL_CG_URL_TREE_HEADER      g_pSites = NULL;

BOOLEAN                     g_InitCGCalled = FALSE;


/***************************************************************************++

Routine Description:

    Free's the node pEntry.  This funciton walks up and tree of parent entries
    and deletes them if they are supposed to free'd (dummy nodes) .

    it will free the memory pEntry + unlink it from the config group LIST_ENTRY.

Arguments:

    IN PUL_CG_URL_TREE_ENTRY pEntry - the entry to free

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFreeNode(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    )
{
    NTSTATUS                Status;
    PUL_CG_URL_TREE_HEADER  pHeader;
    ULONG                   Index;
    PUL_CG_URL_TREE_ENTRY   pParent;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_TREE_ENTRY(pEntry));

    Status = STATUS_SUCCESS;

    //
    // Loop!  we are going to walk up the tree deleting as much
    // as we can of this branch.
    //

    while (pEntry != NULL)
    {

        ASSERT(IS_VALID_TREE_ENTRY(pEntry));

        //
        // Init
        //

        pParent = NULL;

        UlTrace(
            CONFIG_GROUP_TREE, (
                "http!UlpTreeFreeNode - pEntry('%S', %d, %S, %S%S)\n",
                pEntry->pToken,
                pEntry->FullUrl,
                (pEntry->pChildren == NULL || pEntry->pChildren->UsedCount == 0) ? L"no children" : L"children",
                pEntry->pParent == NULL ? L"no parent" : L"parent=",
                pEntry->pParent == NULL ? L"" : pEntry->pParent->pToken
                )
            );

        //
        // 1) might not be a "real" leaf - we are walking up the tree in this loop
        //
        // 2) also we clean this first because we might not be deleting
        // this node at all, if it has dependent children.
        //

        if (pEntry->FullUrl == 1)
        {
            //
            // Remove it from the cfg group list
            //

            RemoveEntryList(&(pEntry->ConfigGroupListEntry));
            pEntry->ConfigGroupListEntry.Flink = pEntry->ConfigGroupListEntry.Blink = NULL;
            pEntry->pConfigGroup = NULL;

            //
            // Mark it as a dummy node
            //

            pEntry->FullUrl = 0;
        }

        //
        // do we have children?
        //

        if (pEntry->pChildren != NULL && pEntry->pChildren->UsedCount > 0)
        {
            //
            // can't delete it.  dependant children exist.
            // it's already be converted to a dummy node above.
            //
            // leave it.  it will get cleaned by a subsequent child.
            //

            break;
        }

        //
        // we are really deleting this one, remove it from the sibling list.
        //

        //
        // find our location in the sibling list
        //

        if (pEntry->pParent == NULL)
        {
            pHeader = g_pSites;
        }
        else
        {
            pHeader = pEntry->pParent->pChildren;
        }

        Status  = UlpTreeFindEntry(
                        pHeader,
                        pEntry->pToken,
                        pEntry->TokenLength,
                        pEntry->TokenHash,
                        &Index,
                        NULL
                        );

        if (NT_SUCCESS(Status) == FALSE)
        {
            ASSERT(FALSE);
            goto end;
        }

        //
        // time to remove it
        //
        // if not the last one, shift left the array at Index
        //

        if (Index < (pHeader->UsedCount-1))
        {
            RtlMoveMemory(
                &(pHeader->pEntries[Index]),
                &(pHeader->pEntries[Index+1]),
                (pHeader->UsedCount - 1 - Index) * sizeof(UL_CG_HEADER_ENTRY)
                );
        }

        //
        // now we have 1 less
        //

        pHeader->UsedCount -= 1;

        //
        // need to clean parent entries that were here just for this leaf
        //

        if (pEntry->pParent != NULL)
        {
            //
            // Does this parent have any other children?
            //

            ASSERT(IS_VALID_TREE_HEADER(pEntry->pParent->pChildren));

            if (pEntry->pParent->pChildren->UsedCount == 0)
            {
                //
                // no more, time to clean the child list
                //

                UL_FREE_POOL_WITH_SIG(pEntry->pParent->pChildren, UL_CG_TREE_HEADER_POOL_TAG);

                //
                // is the parent a real url entry?
                //

                if (pEntry->pParent->FullUrl != 1)
                {
                    //
                    // nope .  let's scrub it.
                    //

                    pParent = pEntry->pParent;

                }
            }
            else
            {
                //
                // ouch.  siblings.  can't nuke parent.
                //
            }
        }
        else
        {
            //
            // we are deleting a site node; stop listening.
            // We have to stop listening on another thread
            // because otherwise there will be a deadlock
            // between the config group lock and http connection
            // locks.
            //

            UlpDeferredRemoveSite(pEntry);
        }

        //
        // Free the entry
        //

        UL_FREE_POOL_WITH_SIG(pEntry, UL_CG_TREE_ENTRY_POOL_TAG);

        //
        // Move on to the next one
        //

        pEntry = pParent;


    }

end:
    return Status;
}


/***************************************************************************++

Routine Description:

    Allocates and initializes a config group object.

Arguments:

    ppObject - gets a pointer to the object on success

--***************************************************************************/
NTSTATUS
UlpCreateConfigGroupObject(
    PUL_CONFIG_GROUP_OBJECT * ppObject
    )
{
    HTTP_CONFIG_GROUP_ID    NewId = HTTP_NULL_ID;
    PUL_CONFIG_GROUP_OBJECT pNewObject = NULL;
    NTSTATUS                Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppObject != NULL);

    UlTrace(CONFIG_GROUP_FNC, ("http!UlpCreateConfigGroupObject\n"));

    //
    // Create an empty config group object structure - PAGED
    //

    pNewObject = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UL_CONFIG_GROUP_OBJECT,
                        UL_CG_OBJECT_POOL_TAG
                        );

    if (pNewObject == NULL)
    {
        //
        // Oops.  Couldn't allocate the memory for it.
        //

        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlZeroMemory(pNewObject, sizeof(UL_CONFIG_GROUP_OBJECT));

    //
    // Create an opaque id for it
    //

    Status = UlAllocateOpaqueId(
                    &NewId,                     // pOpaqueId
                    UlOpaqueIdTypeConfigGroup,  // OpaqueIdType
                    pNewObject                  // pContext
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Fill in the structure
    //

    pNewObject->Signature                       = UL_CG_OBJECT_POOL_TAG;
    pNewObject->RefCount                        = 1;
    pNewObject->ConfigGroupId                   = NewId;

    pNewObject->AppPoolFlags.Present            = 0;
    pNewObject->pAppPool                        = NULL;

    pNewObject->pAutoResponse                   = NULL;

    pNewObject->MaxBandwidth.Flags.Present      = 0;
    pNewObject->MaxConnections.Flags.Present    = 0;
    pNewObject->State.Flags.Present             = 0;
    pNewObject->Security.Flags.Present          = 0;
    pNewObject->LoggingConfig.Flags.Present     = 0;
    pNewObject->pLogFileEntry                   = NULL;

    //
    // init the bandwidth throttling flow list
    //
    InitializeListHead(&pNewObject->FlowListHead);

    //
    // init notification entries & head
    //
    UlInitializeNotifyEntry(&pNewObject->HandleEntry, pNewObject);
    UlInitializeNotifyEntry(&pNewObject->ParentEntry, pNewObject);

    UlInitializeNotifyHead(
        &pNewObject->ChildHead,
        &g_pUlNonpagedData->ConfigGroupResource
        );

    //
    // init the url list
    //

    InitializeListHead(&pNewObject->UrlListHead);

    //
    // return the pointer
    //
    *ppObject = pNewObject;

end:

    if (!NT_SUCCESS(Status))
    {
        //
        // Something failed. Let's clean up.
        //

        if (pNewObject != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pNewObject, UL_CG_OBJECT_POOL_TAG);
        }

        if (!HTTP_IS_NULL_ID(&NewId))
        {
            UlFreeOpaqueId(NewId, UlOpaqueIdTypeConfigGroup);
        }
    }

    return Status;
} // UlpCreateConfigGroupObject

/***************************************************************************++

Routine Description:

    This will clean all of the urls in the LIST_ENTRY for the config group

Arguments:

    IN PUL_CONFIG_GROUP_OBJECT pObject  the group to clean the urls for

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCleanAllUrls(
    IN PUL_CONFIG_GROUP_OBJECT pObject
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pObject != NULL);

    Status = STATUS_SUCCESS;

    //
    // Remove all of the url's associated with this cfg group
    //

    //
    // walk the list
    //

    while (IsListEmpty(&pObject->UrlListHead) == FALSE)
    {
        PUL_CG_URL_TREE_ENTRY pTreeEntry;

        //
        // get the containing struct
        //
        pTreeEntry = CONTAINING_RECORD(
                            pObject->UrlListHead.Flink,
                            UL_CG_URL_TREE_ENTRY,
                            ConfigGroupListEntry
                            );

        ASSERT(IS_VALID_TREE_ENTRY(pTreeEntry) && pTreeEntry->FullUrl == 1);

        //
        // delete it - this unlinks it from the list
        //

        if (NT_SUCCESS(Status))
        {
            Status = UlpTreeFreeNode(pTreeEntry);
        }
        else
        {
            //
            // just record the first error, but still attempt to free all
            //
            UlpTreeFreeNode(pTreeEntry);
        }

    }

    // the list is empty now
    //
    return Status;
} // UlpCleanAllUrls


/***************************************************************************++

Routine Description:

    Removes a site entry's url from the listening endpoint.

Arguments:

    pEntry - the site entry

--***************************************************************************/
VOID
UlpDeferredRemoveSite(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    )
{
    PUL_DEFERRED_REMOVE_ITEM pItem;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( IS_VALID_TREE_ENTRY(pEntry) );
    ASSERT( pEntry->pParent == NULL );
    ASSERT( pEntry->TokenLength > 0 );

    pItem = UL_ALLOCATE_STRUCT_WITH_SPACE(
                NonPagedPool,
                UL_DEFERRED_REMOVE_ITEM,
                pEntry->TokenLength + sizeof(WCHAR),
                UL_DEFERRED_REMOVE_ITEM_POOL_TAG
                );

    if (pItem) {
        pItem->NameLength = pEntry->TokenLength;

        RtlCopyMemory(
            pItem->pName,
            pEntry->pToken,
            pEntry->TokenLength + sizeof(WCHAR)
            );

        //
        // REVIEW: Because UlRemoveSiteFromEndpointList can block
        // REVIEW: indefinitely while waiting for other work items
        // REVIEW: to complete, we must not queue it with UlQueueWorkItem.
        // REVIEW: (could lead to deadlock, esp. in a single-threded queue)
        //

        UL_QUEUE_BLOCKING_ITEM(
            &pItem->WorkItem,
            &UlpDeferredRemoveSiteWorker
            );
    }
}


/***************************************************************************++

Routine Description:

    Removes a site entry's url from the listening endpoint.

Arguments:

    pWorkItem - in a UL_DEFERRED_REMOVE_ITEM struct with the endpoint name

--***************************************************************************/
VOID
UlpDeferredRemoveSiteWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    PUL_DEFERRED_REMOVE_ITEM pItem;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( pWorkItem );

    //
    // get the name of the site
    //

    pItem = CONTAINING_RECORD(
                pWorkItem,
                UL_DEFERRED_REMOVE_ITEM,
                WorkItem
                );

    ASSERT( pItem->pName[pItem->NameLength / 2] == UNICODE_NULL );

    //
    // remove it
    //
    Status = UlRemoveSiteFromEndpointList(pItem->pName);

    if (!NT_SUCCESS(Status)) {
        // c'est la vie
        UlTrace(CONFIG_GROUP_TREE, (
            "http!UlpDeferredRemoveSiteWorker(%ws) failed %08x\n",
            pItem->pName,
            Status
            ));
    }

    //
    // free the work item
    //
    UL_FREE_POOL(pItem, UL_DEFERRED_REMOVE_ITEM_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    This will return a fresh buffer containing the url sanitized.  caller
    must free this from paged pool.

Arguments:

    IN PUNICODE_STRING pUrl,            the url to clean

    OUT PWSTR * ppUrl                   the cleaned url

Return Value:

    NTSTATUS - Completion status.

        STATUS_NO_MEMORY;               the memroy alloc failed

--***************************************************************************/
NTSTATUS
UlpSanitizeUrl(
    IN PUNICODE_STRING pUrl,
    OUT PWSTR * ppUrl
    )
{
    NTSTATUS    Status;
    PWSTR       pNewUrl = NULL;
    PWSTR       pPort;
    PWSTR       pEnd;
    PWSTR       pStart;
    ULONGLONG   PortNum;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL && pUrl->Length > 0 && pUrl->Buffer != NULL);
    ASSERT(ppUrl != NULL);

    //
    // Is the url prefix too long?
    //

    if ( (pUrl->Length / sizeof(WCHAR) ) > g_UlMaxUrlLength )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Make a private copy of the url
    //

    pNewUrl = UL_ALLOCATE_ARRAY(
                    PagedPool,
                    WCHAR,
                    (pUrl->Length / sizeof(WCHAR)) + 1,
                    URL_POOL_TAG
                    );

    if (pNewUrl == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlCopyMemory(pNewUrl, pUrl->Buffer, pUrl->Length);

    //
    // NULL terminate it
    //

    pNewUrl[pUrl->Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Validate it
    //

    if (pUrl->Length < (sizeof(L"https://")-sizeof(WCHAR)))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    if (_wcsnicmp(pNewUrl, L"http://", (sizeof(L"http://")-1)/sizeof(WCHAR)) != 0 &&
        _wcsnicmp(pNewUrl, L"https://", (sizeof(L"https://")-1)/sizeof(WCHAR)) != 0)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    pStart = wcschr(pNewUrl, ':');
    ASSERT(pStart != NULL);  // already checked above

    //
    // skip the "://" to find the start
    //

    pStart += 3;

    //
    // find the end, right before the trailing slash
    //

    pEnd = wcschr(pStart, '/');
    if (pEnd == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // find the port (right after the colon) colon
    //

    pPort = wcschr(pStart, ':');
    if (pPort == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }
    pPort += 1;

    //
    // no hostname || no port (or colon past the end)
    //

    if (pPort == (pStart + 1) || pPort >= pEnd)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // NULL terminate it
    //

    pEnd[0] = UNICODE_NULL;

    //
    // Now convert the port to a number
    //

    Status = UlUnicodeToULongLong(pPort, 10, &PortNum);

    pEnd[0] = L'/';

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (PortNum > 0xffff || PortNum == 0)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // return the clean url
    //

    *ppUrl = pNewUrl;

    Status = STATUS_SUCCESS;

end:
    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pNewUrl != NULL)
        {
            UL_FREE_POOL(pNewUrl, URL_POOL_TAG);
            pNewUrl = NULL;
        }
    }

    RETURN(Status);
}

/***************************************************************************++

Routine Description:

    walks the tree and find's a matching entry for pUrl.  2 output options,
    you can get the entry back, or a computed URL_INFO with inheritence applied.
    you must free the URL_INFO from NonPagedPool.

Arguments:

    IN PUL_CG_URL_TREE_ENTRY pEntry,            the top of the tree

    IN PWSTR pNextToken,                        where to start looking under
                                                the tree

    IN OUT PUL_URL_CONFIG_GROUP_INFO * ppInfo,  [optional] the info to set,
                                                might have to grow it.

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry         [optional] returns the found
                                                entry

Return Value:

    NTSTATUS - Completion status.

        STATUS_OBJECT_NAME_NOT_FOUND    no entry found

--***************************************************************************/
NTSTATUS
UlpTreeFindNodeWalker(
    IN      PUL_CG_URL_TREE_ENTRY pEntry,
    IN      PWSTR pNextToken,
    IN OUT  PUL_URL_CONFIG_GROUP_INFO pInfo OPTIONAL,
    OUT     PUL_CG_URL_TREE_ENTRY * ppEntry OPTIONAL
    )
{
    NTSTATUS                    Status;
    PWSTR                       pToken = NULL;
    ULONG                       TokenLength;
    PUL_CG_URL_TREE_ENTRY       pMatchEntry;
    ULONG                       Index;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_TREE_ENTRY(pEntry));
    ASSERT(pNextToken != NULL);
    ASSERT(pInfo != NULL || ppEntry != NULL);

    //
    // walk the site tree looking for more matches
    //

    pMatchEntry = NULL;
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    while (TRUE)
    {
        //
        // A bonafide match?
        //

        if (pEntry->FullUrl == 1)
        {
            pMatchEntry = pEntry;

            if (pInfo != NULL)
            {
                Status = UlpSetUrlInfo(pInfo, pMatchEntry);
                if (NT_SUCCESS(Status) == FALSE)
                    goto end;
            }
        }

        //
        // Are we already at the end of the url?
        //

        if (pNextToken == NULL || *pNextToken == UNICODE_NULL)
            break;

        //
        // find the next token
        //

        pToken = pNextToken;
        pNextToken = wcschr(pNextToken, L'/');

        //
        // can be null if this is a leaf
        //

        if (pNextToken != NULL)
        {
            //
            // replace the '/' with a null, we'll fix it later
            //

            pNextToken[0] = UNICODE_NULL;

            TokenLength = DIFF(pNextToken - pToken) * sizeof(WCHAR);
            pNextToken += 1;
        }
        else
        {
            TokenLength = wcslen(pToken) * sizeof(WCHAR);
        }

        //
        // match?
        //

        Status = UlpTreeBinaryFindEntry(
                        pEntry->pChildren,
                        pToken,
                        TokenLength,
                        HASH_INVALID_SIGNATURE,
                        &Index
                        );

        if (pNextToken != NULL)
        {
            //
            // Fix the string, i replaced the '/' with a UNICODE_NULL
            //

            (pNextToken-1)[0] = L'/';
        }

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // it's a sorted tree, the first non-match means we're done
            //
            break;
        }

        //
        // other error?
        //

        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        //
        // found a match, look for deeper matches.
        //

        pEntry = pEntry->pChildren->pEntries[Index].pEntry;

        ASSERT(IS_VALID_TREE_ENTRY(pEntry));

    }

    //
    // did we find a match?
    //

    if (pMatchEntry != NULL)
    {
        Status = STATUS_SUCCESS;
        if (ppEntry != NULL)
        {
            *ppEntry = pMatchEntry;
        }
    }
    else
    {
        ASSERT(Status == STATUS_OBJECT_NAME_NOT_FOUND || NT_SUCCESS(Status));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

end:

    return Status;
}

/***************************************************************************++

Routine Description:

    walks the tree and find's a matching entry for pUrl.  2 output options,
    you can get the entry back, or a computed URL_INFO with inheritence applied.
    you must free the URL_INFO from NonPagedPool.

Arguments:

    IN PWSTR pUrl,                              the entry to find

    CheckWildcard                               Should we do a wildcard match?

    pHttpConn                                   [optional] If non-NULL, use IP of
                                                server to find Node (if not found
                                                on first pass).  This search is done
                                                prior to the Wildcard search.

    OUT PUL_URL_CONFIG_GROUP_INFO * ppInfo,     [optional] will be alloced
                                                and generated.

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry         [optional] returns the found
                                                entry

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFindNode(
    IN PWSTR pUrl,
    IN BOOLEAN CheckWildcard,
    IN PUL_HTTP_CONNECTION pHttpConn OPTIONAL,
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo OPTIONAL,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry OPTIONAL
    )
{
    NTSTATUS                    Status;
    PWSTR                       pNextToken;
    PUL_CG_URL_TREE_ENTRY       pEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL);
    ASSERT(pInfo != NULL || ppEntry != NULL);

    //
    // get the site match
    //

    Status = UlpTreeFindSite(pUrl, &pNextToken, &pEntry, FALSE);
    if (NT_SUCCESS(Status))
    {

        //
        // does it exist in this tree?
        //

        Status = UlpTreeFindNodeWalker(pEntry, pNextToken, pInfo, ppEntry);

    }

    if ( (Status == STATUS_OBJECT_NAME_NOT_FOUND) && (NULL != pHttpConn) )
    {
        ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));

        //
        // Didn't find it in first try.  See if there is a binding for
        // the IP address & TCP Port on which the request was received.
        //

        Status = UlpTreeFindIpMatch(pUrl, pHttpConn, &pNextToken, &pEntry);
        if (NT_SUCCESS(Status))
        {
            //
            // and now check in the wildcard tree
            //

            Status = UlpTreeFindNodeWalker(pEntry, pNextToken, pInfo, ppEntry);

        }

    }

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND && CheckWildcard)
    {
        //
        // shoot, didn't find a match.  let's check wildcards
        //

        Status = UlpTreeFindWildcardMatch(pUrl, &pNextToken, &pEntry);
        if (NT_SUCCESS(Status))
        {
            //
            // and now check in the wildcard tree
            //

            Status = UlpTreeFindNodeWalker(pEntry, pNextToken, pInfo, ppEntry);

        }

    }

    //
    // all done.
    //

    return Status;

} // UlpTreeFindNode

/***************************************************************************++

Routine Description:

    finds any matching wildcard site in g_pSites for pUrl.

Arguments:

    IN PWSTR pUrl,                          the url to match

    OUT PWSTR * ppNextToken,                output's the next token after
                                            matching the url

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry,    returns the entry

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFindWildcardMatch(
    IN  PWSTR pUrl,
    OUT PWSTR * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    )
{
    NTSTATUS    Status;
    PWSTR       pNextToken;
    ULONG       TokenLength;
    ULONG       Index;
    PWSTR       pPortNum;
    ULONG       PortLength;
    WCHAR       WildSiteUrl[HTTPS_WILD_PREFIX_LENGTH + MAX_PORT_LENGTH + 1];

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL);
    ASSERT(ppNextToken != NULL);
    ASSERT(ppEntry != NULL);

    //
    // find the port # (colon location + 1 for https + 1 to skip the colon = + 2)
    //

    pPortNum = wcschr(pUrl + HTTP_PREFIX_COLON_INDEX + 2, L':');
    if (pPortNum == NULL)
    {

        //
        // ouch
        //

        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Skip the ':'
    //

    pPortNum += 1;

    //
    // find the trailing '/' after the port number
    //

    pNextToken = wcschr(pPortNum, '/');
    if (pNextToken == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // HTTPS or HTTP?
    //

    if (pUrl[HTTP_PREFIX_COLON_INDEX] == L':')
    {
        RtlCopyMemory(
            WildSiteUrl,
            HTTP_WILD_PREFIX,
            HTTP_WILD_PREFIX_LENGTH * sizeof(WCHAR)
            );

        PortLength = DIFF(pNextToken - pPortNum) * sizeof(WCHAR);
        TokenLength = HTTP_WILD_PREFIX_LENGTH + PortLength;

        ASSERT(TokenLength < (sizeof(WildSiteUrl)-sizeof(WCHAR)));

        RtlCopyMemory(
            &(WildSiteUrl[HTTP_WILD_PREFIX_LENGTH/sizeof(WCHAR)]),
            pPortNum,
            PortLength
            );

        WildSiteUrl[TokenLength/sizeof(WCHAR)] = UNICODE_NULL;
    }
    else
    {
        RtlCopyMemory(
            WildSiteUrl,
            HTTPS_WILD_PREFIX,
            HTTPS_WILD_PREFIX_LENGTH * sizeof(WCHAR)
            );

        PortLength = DIFF(pNextToken - pPortNum) * sizeof(WCHAR);
        TokenLength = HTTPS_WILD_PREFIX_LENGTH + PortLength;

        ASSERT(TokenLength < (sizeof(WildSiteUrl)-sizeof(WCHAR)));

        RtlCopyMemory(
            &(WildSiteUrl[HTTPS_WILD_PREFIX_LENGTH/sizeof(WCHAR)]),
            pPortNum,
            PortLength
            );

        WildSiteUrl[TokenLength/sizeof(WCHAR)] = UNICODE_NULL;
    }

    //
    // is there a wildcard entry?
    //

    Status = UlpTreeBinaryFindEntry(
                    g_pSites,
                    WildSiteUrl,
                    TokenLength,
                    HASH_INVALID_SIGNATURE,
                    &Index
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // return the spot right after the token we just ate
    //

    *ppNextToken = pNextToken + 1;

    //
    // and return the entry
    //

    *ppEntry = g_pSites->pEntries[Index].pEntry;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        *ppEntry = NULL;
        *ppNextToken = NULL;
    }

    return Status;
} // UlpTreeFindWildcardMatch


/***************************************************************************++

Routine Description:

    finds any matching wildcard site in g_pSites for pUrl.
    ASSUMES that the pUrl ALWASY contains a port number and trailing slash,
    e.g.:
      http://<host>:<port>/
      https://<host>:<port>/
      http://<host>:<port>/foo/bar/banana.htm
      https://<host>:<port>/foo/bar/

Arguments:

    IN PWSTR pUrl,                          the url to match

    pHttpConn                               HTTP Connection object to
                                            get the Server's IP & Port.

    CODEWORK: If TDI ever starts giving us back the LocalAddress by default,
    we should change this param to be that address (since that's the only
    reason we need the pHttpConn).

    OUT PWSTR * ppNextToken,                output's the next token after
                                            matching the url

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry,    returns the entry

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFindIpMatch(
    IN PWSTR pUrl,
    IN PUL_HTTP_CONNECTION pHttpConn,
    OUT PWSTR * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    )
{
    NTSTATUS    Status;
    PWSTR       pNextToken;
    ULONG       TokenLength;    // Length, in bytes, of token, not counting the NULL
    ULONG       Index;
    WCHAR       IpSiteUrl[HTTPS_IP_PREFIX_LENGTH + MAX_ADDRESS_LENGTH + 1];
    PWSTR       pPortNum;
    PWSTR       pTmp;
    TA_IP_ADDRESS RawAddress;
    USHORT      IpPortNum;
    ULONG       IpAddress;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL);
    ASSERT(ppNextToken != NULL);
    ASSERT(ppEntry != NULL);

    //
    // find the port # (colon location + 1 for https + 1 to skip the colon = + 2)
    //

    pPortNum = wcschr(pUrl + HTTP_PREFIX_COLON_INDEX + 2, L':');
    if (pPortNum == NULL)
    {

        //
        // ouch
        //

        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Skip the ':'
    //

    pPortNum += 1;

    //
    // find the trailing '/' after the port number
    //

    pNextToken = wcschr(pPortNum, '/');
    if (pNextToken == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Build IP & Port URL
    //

    //
    // HTTPS or HTTP?
    //

    if (pUrl[HTTP_PREFIX_COLON_INDEX] == L':')
    {
        // HTTP

        RtlCopyMemory(
            IpSiteUrl,
            HTTP_IP_PREFIX,
            HTTP_IP_PREFIX_LENGTH /* * sizeof(WCHAR) */
            );

        TokenLength = HTTP_IP_PREFIX_LENGTH;
    }
    else
    {
        // HTTPS

        RtlCopyMemory(
            IpSiteUrl,
            HTTPS_IP_PREFIX,
            HTTPS_IP_PREFIX_LENGTH /* * sizeof(WCHAR) */
            );

        TokenLength = HTTPS_IP_PREFIX_LENGTH;
    }

    //
    // Add IP & PORT to url
    //

    ASSERT( IS_VALID_CONNECTION(pHttpConn->pConnection) );

    IpAddress = pHttpConn->pConnection->LocalAddress;
    IpPortNum = pHttpConn->pConnection->LocalPort;

    TokenLength += HostAddressAndPortToStringW(
                        &(IpSiteUrl[TokenLength/sizeof(WCHAR)]),
                        IpAddress,
                        IpPortNum
                        );

    //
    // Finally, is there an IP & PORT entry?
    //

    Status = UlpTreeFindEntry(
                    g_pSites,
                    IpSiteUrl,
                    TokenLength,
                    HASH_INVALID_SIGNATURE,
                    &Index,
                    NULL
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // return the spot right after the token we just ate
    //

    *ppNextToken = pNextToken + 1;

    //
    // and return the entry
    //

    *ppEntry = g_pSites->pEntries[Index].pEntry;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        *ppEntry = NULL;
        *ppNextToken = NULL;
    }

    return Status;

} // UlpTreeFindIpMatch


/***************************************************************************++

Routine Description:

    finds the matching site in g_pSites for pUrl.

Arguments:

    IN PWSTR pUrl,                          the url to match

    OUT PWSTR * ppNextToken,                output's the next token after
                                            matching the url

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry,    returns the entry

    BOOLEAN AutoCreate                      should the entry be created?

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpTreeFindSite(
    IN  PWSTR pUrl,
    OUT PWSTR * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry,
    OUT BOOLEAN AutoCreate
    )
{
    NTSTATUS    Status;
    PWSTR       pToken;
    PWSTR       pNextToken = NULL;
    ULONG       TokenLength;
    ULONG       TokenHash;
    ULONG       Index;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL);
    ASSERT(ppNextToken != NULL);
    ASSERT(ppEntry != NULL);

    //
    // find the very first '/'
    //

    pToken = wcschr(pUrl, L'/');
    if (pToken == NULL)
    {

        //
        // ouch
        //

        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // skip the '/' and the trailing '/'
    //

    if (pToken[1] != L'/')
    {

        //
        // ouch
        //

        Status = STATUS_INVALID_PARAMETER;
        goto end;

    }

    //
    // skip the "//"
    //

    pToken += 2;

    //
    // Find the closing '/'
    //

    pNextToken = wcschr(pToken, L'/');
    if (pNextToken == NULL)
    {

        //
        // ouch
        //

        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // replace the '/' with a null, we'll fix it later
    //

    pNextToken[0] = UNICODE_NULL;

    //
    // Use the entire prefix as the site token
    //

    pToken = pUrl;

    //
    // CODEWORK longer than 64k token?
    //

    TokenLength = DIFF(pNextToken - pToken) * sizeof(WCHAR);
    pNextToken += 1;

    //
    // find the matching site
    //

    if (AutoCreate)
    {
        Status = UlpTreeFindEntry(
                    g_pSites,
                    pToken,
                    TokenLength,
                    HASH_INVALID_SIGNATURE,
                    &Index,
                    &TokenHash
                    );

        //
        // no match?
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // autocreate the new site
            //

            Status = UlpTreeInsertEntry(
                        &g_pSites,
                        NULL,
                        pToken,
                        TokenLength,
                        TokenHash,
                        Index
                        );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // start listening for this site
            //

            Status = UlAddSiteToEndpointList(pToken);
            if (!NT_SUCCESS(Status))
            {
                NTSTATUS TempStatus;

                //
                // free the site we just created
                //

                TempStatus = UlpTreeFreeNode(g_pSites->pEntries[Index].pEntry);
                ASSERT(NT_SUCCESS(TempStatus));

                goto end;
            }
        }
        else if (!NT_SUCCESS(Status))
        {
            //
            // UlpTreeFindEntry returned an error other than
            // "not found". Bail out.
            //
            goto end;
        }
    }
    else
    {
        Status = UlpTreeBinaryFindEntry(
                    g_pSites,
                    pToken,
                    TokenLength,
                    HASH_INVALID_SIGNATURE,
                    &Index
                    );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
    }

    //
    // set returns
    //

    *ppEntry     = g_pSites->pEntries[Index].pEntry;
    *ppNextToken = pNextToken;

end:

    if (pNextToken != NULL)
    {
        //
        // Fix the string, i replaced the '/' with a UNICODE_NULL
        //

        (pNextToken-1)[0] = L'/';
    }

    if (!NT_SUCCESS(Status))
    {
        *ppEntry = NULL;
        *ppNextToken = NULL;
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    walks the sorted children array pHeader looking for a matching entry
    for pToken.

Arguments:

    IN PUL_CG_URL_TREE_HEADER pHeader,  The children array to look in

    IN PWSTR pToken,                    the token to look for

    IN ULONG TokenLength,               the length in char's of pToken

    OUT ULONG * pIndex                  the found index.  or if not found
                                        the index of the place an entry
                                        with pToken should be inserted.

Return Value:

    NTSTATUS - Completion status.

        STATUS_OBJECT_NAME_NOT_FOUND    didn't find it

--***************************************************************************/
NTSTATUS
UlpTreeFindEntry(
    IN PUL_CG_URL_TREE_HEADER pHeader OPTIONAL,
    IN PWSTR pToken,
    IN ULONG TokenLength,
    IN ULONG TokenHash OPTIONAL,
    OUT ULONG * pIndex,
    OUT ULONG * pTokenHash OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG Index = 0;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pHeader == NULL || IS_VALID_TREE_HEADER(pHeader));
    ASSERT(pIndex != NULL);


    if (TokenLength == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Assume we didn't find it
    //

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    ASSERT(TokenLength > 0 && pToken != NULL && pToken[0] != UNICODE_NULL);

    //
    // compute the hash
    //

    if (TokenHash == HASH_INVALID_SIGNATURE)
    {
        TokenHash = HashRandomizeBits(HashStringNoCaseW(pToken, 0));
        ASSERT(TokenHash != HASH_INVALID_SIGNATURE);
    }


    //
    // any siblings to search through?
    //

    if (pHeader != NULL)
    {

        //
        // Walk the sorted array looking for a match (linear)
        //

        //
        // CODEWORK:  make this a binary search!
        //

        for (Index = 0; Index < pHeader->UsedCount; Index++)
        {
            ASSERT(IS_VALID_TREE_ENTRY(pHeader->pEntries[Index].pEntry));

            //
            // How does the hash compare?
            //

            if (TokenHash == pHeader->pEntries[Index].TokenHash)
            {
                //
                // and the length?
                //

                if (TokenLength == pHeader->pEntries[Index].pEntry->TokenLength)
                {
                    //
                    // double check with a strcmp just for fun
                    //

                    int Temp = _wcsnicmp(
                                    pToken,
                                    pHeader->pEntries[Index].pEntry->pToken,
                                    TokenLength/sizeof(WCHAR)
                                    );

                    if (Temp > 0)
                    {
                        //
                        // larger , time to stop
                        //
                        break;
                    }
                    else if (Temp == 0)
                    {
                        // Found it
                        //
                        Status = STATUS_SUCCESS;
                        break;
                    }

                    //
                    // else if (Temp < 0) keep scanning,
                    //

                }
                else if (TokenLength > pHeader->pEntries[Index].pEntry->TokenLength)
                {
                    //
                    // larger, time to stop
                    //
                    break;
                }
            }
            else if (TokenHash > pHeader->pEntries[Index].TokenHash)
            {
                //
                // larger, time to stop
                //
                break;
            }
        }
    }

    //
    // return vals
    //

    *pIndex = Index;

    if (pTokenHash != NULL)
    {
        *pTokenHash = TokenHash;
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    walks the sorted children array pHeader looking for a matching entry
    for pToken.

Arguments:

    IN PUL_CG_URL_TREE_HEADER pHeader,  The children array to look in

    IN PWSTR pToken,                    the token to look for

    IN ULONG TokenLength,               the length in char's of pToken

    OUT ULONG * pIndex                  the found index.  or if not found
                                        the index of the place an entry
                                        with pToken should be inserted.

Return Value:

    NTSTATUS - Completion status.

        STATUS_OBJECT_NAME_NOT_FOUND    didn't find it

--***************************************************************************/
NTSTATUS
UlpTreeBinaryFindEntry(
    IN PUL_CG_URL_TREE_HEADER pHeader OPTIONAL,
    IN PWSTR pToken,
    IN ULONG TokenLength,
    IN ULONG TokenHash OPTIONAL,
    OUT PULONG pIndex
    )
{
    NTSTATUS Status;
    LONG Index = 0;
    LONG StartIndex;
    LONG EndIndex;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pHeader == NULL || IS_VALID_TREE_HEADER(pHeader));
    ASSERT(pIndex != NULL);

    if (TokenLength == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Assume we didn't find it
    //

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    ASSERT(TokenLength > 0 && pToken != NULL && pToken[0] != UNICODE_NULL);

    //
    // any siblings to search through?
    //

    if (pHeader != NULL)
    {
        //
        // compute the hash
        //

        if (TokenHash == HASH_INVALID_SIGNATURE)
        {
            TokenHash = HashRandomizeBits(HashStringNoCaseW(pToken, 0));
            ASSERT(TokenHash != HASH_INVALID_SIGNATURE);
        }

        //
        // Walk the sorted array looking for a match (binary search)
        //

        StartIndex = 0;
        EndIndex = pHeader->UsedCount - 1;

        while (StartIndex <= EndIndex)
        {
            Index = (StartIndex + EndIndex) / 2;

            ASSERT(IS_VALID_TREE_ENTRY(pHeader->pEntries[Index].pEntry));

            //
            // How does the hash compare?
            //

            if (TokenHash == pHeader->pEntries[Index].TokenHash)
            {
                //
                // and the length?
                //

                if (TokenLength == pHeader->pEntries[Index].pEntry->TokenLength)
                {
                    //
                    // double check with a strcmp just for fun
                    //

                    int Temp = _wcsnicmp(
                                    pToken,
                                    pHeader->pEntries[Index].pEntry->pToken,
                                    TokenLength/sizeof(WCHAR)
                                    );

                    if (Temp == 0)
                    {
                        // Found it
                        //
                        Status = STATUS_SUCCESS;
                        break;
                    }
                    else
                    {
                        if (Temp < 0)
                        {
                            //
                            // Adjust StartIndex forward.
                            //
                            StartIndex = Index + 1;
                        }
                        else
                        {
                            //
                            // Adjust EndIndex backward.
                            //
                            EndIndex = Index - 1;
                        }
                    }
                }
                else
                {
                    if (TokenLength < pHeader->pEntries[Index].pEntry->TokenLength)
                    {
                        //
                        // Adjust StartIndex forward.
                        //
                        StartIndex = Index + 1;
                    }
                    else
                    {
                        //
                        // Adjust EndIndex backward.
                        //
                        EndIndex = Index - 1;
                    }
                }
            }
            else
            {
                if (TokenHash < pHeader->pEntries[Index].TokenHash)
                {
                    //
                    // Adjust StartIndex forward.
                    //
                    StartIndex = Index + 1;
                }
                else
                {
                    //
                    // Adjust EndIndex backward.
                    //
                    EndIndex = Index - 1;
                }
            }
        }
    }

    //
    // return vals
    //

    *pIndex = Index;

    return Status;
}

/***************************************************************************++

Routine Description:

    inserts a new entry storing pToken as a child in the array ppHeader.
    it will grow/allocate ppHeader as necessary.

Arguments:

    IN OUT PUL_CG_URL_TREE_HEADER * ppHeader,   the children array (might change)

    IN PUL_CG_URL_TREE_ENTRY pParent,           the parent to set this child to

    IN PWSTR pToken,                            the token of the new entry

    IN ULONG TokenLength,                       token length

    IN ULONG Index                              the index to insert it at.
                                                it will shuffle the array
                                                if necessary.

Return Value:

    NTSTATUS - Completion status.

        STATUS_NO_MEMORY                        allocation failed

--***************************************************************************/
NTSTATUS
UlpTreeInsertEntry(
    IN OUT PUL_CG_URL_TREE_HEADER * ppHeader,
    IN PUL_CG_URL_TREE_ENTRY pParent OPTIONAL,
    IN PWSTR pToken,
    IN ULONG TokenLength,
    IN ULONG TokenHash,
    IN ULONG Index
    )
{
    NTSTATUS Status;
    PUL_CG_URL_TREE_HEADER pHeader = NULL;
    PUL_CG_URL_TREE_ENTRY  pEntry = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppHeader != NULL);
    ASSERT(pParent == NULL || IS_VALID_TREE_ENTRY(pParent));
    ASSERT(pToken != NULL);
    ASSERT(TokenLength > 0);
    ASSERT(TokenHash != HASH_INVALID_SIGNATURE);
    ASSERT(
        (*ppHeader == NULL) ?
        Index == 0 :
        IS_VALID_TREE_HEADER(*ppHeader) && (Index <= (*ppHeader)->UsedCount)
        );

    pHeader = *ppHeader;

    //
    // any exiting siblings?
    //

    if (pHeader == NULL)
    {
        //
        // allocate a sibling array
        //

        pHeader = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        PagedPool,
                        UL_CG_URL_TREE_HEADER,
                        sizeof(UL_CG_HEADER_ENTRY) * UL_CG_DEFAULT_TREE_WIDTH,
                        UL_CG_TREE_HEADER_POOL_TAG
                        );

        if (pHeader == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        RtlZeroMemory(
            pHeader,
            sizeof(UL_CG_URL_TREE_HEADER) +
                sizeof(UL_CG_HEADER_ENTRY) * UL_CG_DEFAULT_TREE_WIDTH
            );

        pHeader->Signature = UL_CG_TREE_HEADER_POOL_TAG;
        pHeader->AllocCount = UL_CG_DEFAULT_TREE_WIDTH;

    }
    else if ((pHeader->UsedCount + 1) > pHeader->AllocCount)
    {
        PUL_CG_URL_TREE_HEADER pNewHeader;

        //
        // Grow a bigger array
        //

        pNewHeader = UL_ALLOCATE_STRUCT_WITH_SPACE(
                            PagedPool,
                            UL_CG_URL_TREE_HEADER,
                            sizeof(UL_CG_HEADER_ENTRY) * (pHeader->AllocCount * 2),
                            UL_CG_TREE_HEADER_POOL_TAG
                            );

        if (pNewHeader == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        RtlCopyMemory(
            pNewHeader,
            pHeader,
            sizeof(UL_CG_URL_TREE_HEADER) +
                sizeof(UL_CG_HEADER_ENTRY) * pHeader->AllocCount
            );

        RtlZeroMemory(
            ((PUCHAR)pNewHeader) + sizeof(UL_CG_URL_TREE_HEADER) +
                sizeof(UL_CG_HEADER_ENTRY) * pHeader->AllocCount,
            sizeof(UL_CG_HEADER_ENTRY) * pHeader->AllocCount
            );

        pNewHeader->AllocCount *= 2;

        pHeader = pNewHeader;

    }

    //
    // Allocate an entry
    //

    pEntry = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    UL_CG_URL_TREE_ENTRY,
                    TokenLength + sizeof(WCHAR),
                    UL_CG_TREE_ENTRY_POOL_TAG
                    );

    if (pEntry == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlZeroMemory(
        pEntry,
        sizeof(UL_CG_URL_TREE_ENTRY) +
        TokenLength + sizeof(WCHAR)
        );

    pEntry->Signature   = UL_CG_TREE_ENTRY_POOL_TAG;
    pEntry->pParent     = pParent;
    pEntry->TokenHash   = TokenHash;
    pEntry->TokenLength = TokenLength;

    RtlCopyMemory(pEntry->pToken, pToken, TokenLength + sizeof(WCHAR));

    //
    // need to shuffle things around?
    //

    if (Index < pHeader->UsedCount)
    {
        //
        // shift right the chunk at Index
        //

        RtlMoveMemory(
            &(pHeader->pEntries[Index+1]),
            &(pHeader->pEntries[Index]),
            (pHeader->UsedCount - Index) * sizeof(UL_CG_HEADER_ENTRY)
            );
    }

    pHeader->pEntries[Index].TokenHash = TokenHash;
    pHeader->pEntries[Index].pEntry    = pEntry;

    pHeader->UsedCount += 1;

    Status = STATUS_SUCCESS;

    UlTrace(
        CONFIG_GROUP_TREE, (
            "http!UlpTreeInsertEntry('%S', %d) %S%S\n",
            pToken,
            Index,
            (Index < (pHeader->UsedCount - 1)) ? L"[shifted]" : L"",
            (*ppHeader == NULL) ? L"[alloc'd siblings]" : L""
            )
        );

end:
    if (NT_SUCCESS(Status) == FALSE)
    {
        if (*ppHeader != pHeader && pHeader != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pHeader, UL_CG_TREE_HEADER_POOL_TAG);
        }
        if (pEntry != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pEntry, UL_CG_TREE_ENTRY_POOL_TAG);
        }

    }
    else
    {
        //
        // return a new buffer to the caller ?
        //

        if (*ppHeader != pHeader)
        {
            if (*ppHeader != NULL)
            {
                //
                // free the old one
                //

                UL_FREE_POOL_WITH_SIG(*ppHeader, UL_CG_TREE_HEADER_POOL_TAG);

            }

            *ppHeader = pHeader;
        }
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Inserts pUrl into the url tree.  returns the inserted entry.

Arguments:

    IN PWSTR pUrl,                          the url to insert

    OUT PUL_CG_URL_TREE_ENTRY * ppEntry     the new entry

Return Value:

    NTSTATUS - Completion status.

        STATUS_ADDRESS_ALREADY_EXISTS       this url is already in the tree

--***************************************************************************/
NTSTATUS
UlpTreeInsert(
    IN PWSTR pUrl,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    )
{
    NTSTATUS                Status;
    PWSTR                   pToken;
    PWSTR                   pNextToken;
    ULONG                   TokenLength;
    ULONG                   TokenHash;
    PUL_CG_URL_TREE_ENTRY   pEntry = NULL;
    ULONG                   Index;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(g_pSites != NULL);
    ASSERT(ppEntry != NULL);
    ASSERT(pUrl != NULL && pUrl[0] != UNICODE_NULL);

    UlTrace(CONFIG_GROUP_TREE, ("http!UlpTreeInsert('%S')\n", pUrl));

    //
    // get the site match
    //

    Status = UlpTreeFindSite(pUrl, &pNextToken, &pEntry, TRUE);
    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    ASSERT(IS_VALID_TREE_ENTRY(pEntry));

    //
    // any abs_path to add also?
    //

    while (pNextToken != NULL && pNextToken[0] != UNICODE_NULL)
    {

        pToken = pNextToken;

        pNextToken = wcschr(pNextToken, L'/');

        //
        // can be null if this is a leaf
        //

        if (pNextToken != NULL)
        {
            pNextToken[0] = UNICODE_NULL;

            // CODEWORK, longer than 64k token?

            TokenLength = DIFF(pNextToken - pToken) * sizeof(WCHAR);
            pNextToken += 1;
        }
        else
        {
            TokenLength = wcslen(pToken) * sizeof(WCHAR);
        }

        //
        // insert this token as a child
        //

        Status = UlpTreeFindEntry(
                        pEntry->pChildren,
                        pToken,
                        TokenLength,
                        HASH_INVALID_SIGNATURE,
                        &Index,
                        &TokenHash
                        );

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            //
            // no match, let's add this new one
            //

            Status = UlpTreeInsertEntry(
                            &pEntry->pChildren,
                            pEntry,
                            pToken,
                            TokenLength,
                            TokenHash,
                            Index
                            );

        }

        if (pNextToken != NULL)
        {

            //
            // fixup the UNICODE_NULL from above
            //

            (pNextToken-1)[0] = L'/';
        }

        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        //
        // dive down deeper !
        //

        pEntry = pEntry->pChildren->pEntries[Index].pEntry;

        ASSERT(IS_VALID_TREE_ENTRY(pEntry));

        //
        // loop!
        //
    }

    //
    // Are we actually creating anything?
    //

    if (pEntry->FullUrl == 1)
    {
        //
        // nope, a dup. bail.
        //

        Status = STATUS_ADDRESS_ALREADY_EXISTS;
        goto end;
    }

    //
    // at the leaf node, set our leaf marks
    //

    pEntry->FullUrl = 1;

    //
    // return the entry
    //

    *ppEntry = pEntry;

    //
    // all done
    //

    Status = STATUS_SUCCESS;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        //
        // Something failed. Need to clean up the partial branch
        //

        if (pEntry != NULL && pEntry->FullUrl == 0)
        {
            NTSTATUS TempStatus;

            TempStatus = UlpTreeFreeNode(pEntry);
            ASSERT(NT_SUCCESS(TempStatus));
        }
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    init code.  not re-entrant.

Arguments:

    none.

Return Value:

    NTSTATUS - Completion status.

        STATUS_NO_MEMORY                allocation failed

--***************************************************************************/
NTSTATUS
UlInitializeCG(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( g_InitCGCalled == FALSE );

    if (g_InitCGCalled == FALSE)
    {
        //
        // init our globals
        //

        //
        // Alloc our site array
        //

        g_pSites = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        PagedPool,
                        UL_CG_URL_TREE_HEADER,
                        sizeof(UL_CG_HEADER_ENTRY) * UL_CG_DEFAULT_TREE_WIDTH,
                        UL_CG_TREE_HEADER_POOL_TAG
                        );

        if (g_pSites == NULL)
            return STATUS_NO_MEMORY;

        RtlZeroMemory(
            g_pSites,
            sizeof(UL_CG_URL_TREE_HEADER) +
            sizeof(UL_CG_HEADER_ENTRY) * UL_CG_DEFAULT_TREE_WIDTH
            );

        g_pSites->Signature = UL_CG_TREE_HEADER_POOL_TAG;
        g_pSites->AllocCount = UL_CG_DEFAULT_TREE_WIDTH;

        //
        // init our non-paged entries
        //

        Status = UlInitializeResource(
                        &(g_pUlNonpagedData->ConfigGroupResource),
                        "ConfigGroupResource",
                        0,
                        UL_CG_RESOURCE_TAG
                        );

        if (NT_SUCCESS(Status) == FALSE)
        {
            UL_FREE_POOL_WITH_SIG(g_pSites, UL_CG_TREE_HEADER_POOL_TAG);
            return Status;
        }

        g_InitCGCalled = TRUE;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    termination code

Arguments:

    none.

Return Value:

    none.

--***************************************************************************/
VOID
UlTerminateCG(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (g_InitCGCalled)
    {

        Status = UlDeleteResource(&(g_pUlNonpagedData->ConfigGroupResource));
        ASSERT(NT_SUCCESS(Status));

        if (g_pSites != NULL)
        {
            ASSERT( g_pSites->UsedCount == 0 );

            //
            // Nuke the header.
            //

            UL_FREE_POOL_WITH_SIG(
                g_pSites,
                UL_CG_TREE_HEADER_POOL_TAG
                );
        }

        //
        // The tree should be gone, all handles have been closed
        //

        ASSERT(g_pSites == NULL || g_pSites->UsedCount == 0);

        g_InitCGCalled = FALSE;
    }
}


/***************************************************************************++

Routine Description:

    creates a new config group and returns the id

Arguments:

    OUT PUL_CONFIG_GROUP_ID pConfigGroupId      returns the new id

Return Value:

    NTSTATUS - Completion status.

        STATUS_NO_MEMORY                        allocation failed

--***************************************************************************/
NTSTATUS
UlCreateConfigGroup(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroupId
    )
{
    PUL_CONFIG_GROUP_OBJECT pNewObject = NULL;
    NTSTATUS                Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pControlChannel != NULL);
    ASSERT(pConfigGroupId != NULL);

    UlTrace(CONFIG_GROUP_FNC, ("http!UlCreateConfigGroup\n"));

    //
    // Create an empty config group object structure - PAGED
    //
    Status = UlpCreateConfigGroupObject(&pNewObject);

    if (!NT_SUCCESS(Status)) {
        goto end;
    }

    //
    // Link it into the control channel
    //

    UlAddNotifyEntry(
        &pControlChannel->ConfigGroupHead,
        &pNewObject->HandleEntry
        );

    //
    // remember the control channel
    //

    pNewObject->pControlChannel = pControlChannel;

    //
    // Return the new id.
    //

    *pConfigGroupId = pNewObject->ConfigGroupId;

end:

    if (!NT_SUCCESS(Status))
    {
        //
        // Something failed. Let's clean up.
        //

        HTTP_SET_NULL_ID(pConfigGroupId);

        if (pNewObject != NULL)
        {
            UlDeleteConfigGroup(pNewObject->ConfigGroupId);
        }
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    returns the config group id that matches the config group object linked
    in list_entry

Arguments:

    IN PLIST_ENTRY pControlChannelEntry - the listentry for this config group

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
HTTP_CONFIG_GROUP_ID
UlConfigGroupFromListEntry(
    IN PLIST_ENTRY pControlChannelEntry
    )
{
    PUL_CONFIG_GROUP_OBJECT pObject;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pControlChannelEntry != NULL);

    pObject = CONTAINING_RECORD(
                    pControlChannelEntry,
                    UL_CONFIG_GROUP_OBJECT,
                    ControlChannelEntry
                    );

    ASSERT(IS_VALID_CONFIG_GROUP(pObject));

    return pObject->ConfigGroupId;
}


/***************************************************************************++

Routine Description:

    deletes the config group ConfigGroupId cleaning all of it's urls.

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId     the group to delete

Return Value:

    NTSTATUS - Completion status.

        STATUS_INVALID_PARAMETER               bad config group id

--***************************************************************************/
NTSTATUS
UlDeleteConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    )
{
    NTSTATUS Status;
    PUL_CONFIG_GROUP_OBJECT pObject;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(CONFIG_GROUP_FNC, ("http!UlDeleteConfigGroup\n"));

    CG_LOCK_WRITE();

    //
    // Get ConfigGroup from opaque id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)
                UlGetObjectFromOpaqueId(
                    ConfigGroupId,
                    UlOpaqueIdTypeConfigGroup,
                    UlReferenceConfigGroup
                    );

    if (pObject == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    ASSERT(IS_VALID_CONFIG_GROUP(pObject));

    HTTP_SET_NULL_ID(&(pObject->ConfigGroupId));

    //
    // Drop the extra reference as a result of the successful get
    //

    DEREFERENCE_CONFIG_GROUP(pObject);

    //
    // Unlink it from the control channel and parent
    //

    UlRemoveNotifyEntry(&pObject->HandleEntry);
    UlRemoveNotifyEntry(&pObject->ParentEntry);

    //
    // let the control channel go
    //

    pObject->pControlChannel = NULL;

    //
    // flush the URI cache.
    // CODEWORK: if we were smarter we could make this more granular
    //
    UlFlushCache();

    //
    // unlink any transient urls below us
    //
    UlNotifyAllEntries(
        UlNotifyOrphanedConfigGroup,
        &pObject->ChildHead,
        NULL
        );

    //
    // Unlink all of the url's in the config group
    //

    Status = UlpCleanAllUrls(pObject);

    //
    // let the error fall through ....
    //

    //
    // remove the opaque id and its reference
    //

    UlFreeOpaqueId(ConfigGroupId, UlOpaqueIdTypeConfigGroup);

    DEREFERENCE_CONFIG_GROUP(pObject);

    //
    // all done
    //

end:

    CG_UNLOCK_WRITE();
    return Status;

} // UlDeleteConfigGroup



/***************************************************************************++

Routine Description:

    Addref's the config group object

Arguments:

    pConfigGroup - the object to add ref

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlReferenceConfigGroup(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    PUL_CONFIG_GROUP_OBJECT pConfigGroup = (PUL_CONFIG_GROUP_OBJECT) pObject;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    refCount = InterlockedIncrement(&pConfigGroup->RefCount);

    WRITE_REF_TRACE_LOG(
        g_pConfigGroupTraceLog,
        REF_ACTION_REFERENCE_CONFIG_GROUP,
        refCount,
        pConfigGroup,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT, (
            "http!UlReferenceConfigGroup cgroup=%p refcount=%d\n",
            pConfigGroup,
            refCount)
        );

}   // UlReferenceConfigGroup


/***************************************************************************++

Routine Description:

    Releases the config group object

Arguments:

    pConfigGroup - the object to deref

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlDereferenceConfigGroup(
    PUL_CONFIG_GROUP_OBJECT pConfigGroup
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    refCount = InterlockedDecrement( &pConfigGroup->RefCount );

    WRITE_REF_TRACE_LOG(
        g_pConfigGroupTraceLog,
        REF_ACTION_DEREFERENCE_CONFIG_GROUP,
        refCount,
        pConfigGroup,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT, (
            "http!UlDereferenceConfigGroup cgroup=%p refcount=%d\n",
            pConfigGroup,
            refCount)
        );

    if (refCount == 0)
    {
        //
        // now it's time to free the object
        //

        // If OpaqueId is non-zero, then refCount should not be zero
        ASSERT(HTTP_IS_NULL_ID(&pConfigGroup->ConfigGroupId));

#if INVESTIGATE_LATER

        //
        // Release the opaque id
        //

        UlFreeOpaqueId(pConfigGroup->ConfigGroupId, UlOpaqueIdTypeConfigGroup);
#endif

        //
        // Release the app pool
        //

        if (pConfigGroup->AppPoolFlags.Present == 1)
        {
            if (pConfigGroup->pAppPool != NULL)
            {
                DEREFERENCE_APP_POOL(pConfigGroup->pAppPool);
                pConfigGroup->pAppPool = NULL;
            }

            pConfigGroup->AppPoolFlags.Present = 0;
        }

        //
        // Release the autoresponse buffer
        //

        if (pConfigGroup->pAutoResponse != NULL)
        {
            UL_DEREFERENCE_INTERNAL_RESPONSE(pConfigGroup->pAutoResponse);
            pConfigGroup->pAutoResponse = NULL;
        }

        //
        // Release the entire object
        //

        if (pConfigGroup->LoggingConfig.Flags.Present &&
            pConfigGroup->LoggingConfig.LogFileDir.Buffer != NULL )
        {
            UL_FREE_POOL(
                pConfigGroup->LoggingConfig.LogFileDir.Buffer,
                UL_CG_LOGDIR_POOL_TAG );

            if ( pConfigGroup->pLogFileEntry )
                UlRemoveLogFileEntry( pConfigGroup->pLogFileEntry );
        }
        else
        {
            ASSERT( NULL == pConfigGroup->pLogFileEntry );
        }


        //
        // Remove any qos flows for this site. This settings should
        // only exists for the root app's cgroup.
        //

        if (pConfigGroup->MaxBandwidth.Flags.Present &&
            pConfigGroup->MaxBandwidth.MaxBandwidth != HTTP_LIMIT_INFINITE )
        {
            UlTcRemoveFlowsForSite( pConfigGroup );
        }

        ASSERT(IsListEmpty(&pConfigGroup->FlowListHead));

        // Deref the connection limit stuff
        if (pConfigGroup->pConnectionCountEntry)
        {
            DEREFERENCE_CONNECTION_COUNT_ENTRY(pConfigGroup->pConnectionCountEntry);
        }

        // deref Site Counters object
        if (pConfigGroup->pSiteCounters)
        {
            DEREFERENCE_SITE_COUNTER_ENTRY(pConfigGroup->pSiteCounters);
        }

        UL_FREE_POOL_WITH_SIG(pConfigGroup, UL_CG_OBJECT_POOL_TAG);
    }

}   // UlDereferenceConfigGroup

/***************************************************************************++

Routine Description:

    adds pUrl to the config group ConfigGroupId.

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,    the cgroup id

    IN PUNICODE_STRING pUrl,                the url. must be null terminated.

    IN HTTP_URL_CONTEXT UrlContext            the context to associate


Return Value:

    NTSTATUS - Completion status.

        STATUS_INVALID_PARAMETER               bad config group id

--***************************************************************************/
NTSTATUS
UlAddUrlToConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PUNICODE_STRING pUrl,
    IN HTTP_URL_CONTEXT UrlContext
    )
{
    NTSTATUS                Status;
    PUL_CONFIG_GROUP_OBJECT pObject = NULL;
    PUL_CG_URL_TREE_ENTRY   pEntry;
    PUL_CG_URL_TREE_ENTRY   pParent;
    PWSTR                   pNewUrl = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL && pUrl->Length > 0 && pUrl->Buffer != NULL);
    ASSERT(pUrl->Buffer[pUrl->Length / sizeof(WCHAR)] == UNICODE_NULL);

    UlTrace(CONFIG_GROUP_FNC,
        ("http!UlAddUrlToConfigGroup('%S' -> %d)\n", pUrl->Buffer, ConfigGroupId));

    //
    // Clean up the url
    //

    Status = UlpSanitizeUrl(pUrl, &pNewUrl);
    if (NT_SUCCESS(Status) == FALSE)
    {
        //
        // no goto end, resource not grabbed
        //

        RETURN(Status);
    }

    CG_LOCK_WRITE();

    //
    // Get the object ptr from id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)(
                    UlGetObjectFromOpaqueId(
                        ConfigGroupId,
                        UlOpaqueIdTypeConfigGroup,
                        UlReferenceConfigGroup
                        )
                    );

    if (IS_VALID_CONFIG_GROUP(pObject) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // insert it into the tree
    //

    Status = UlpTreeInsert(pNewUrl, &pEntry);
    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    ASSERT(IS_VALID_TREE_ENTRY(pEntry));

    //
    // context associated with this url
    //

    pEntry->UrlContext = UrlContext;

    //
    // link the cfg group + the url
    //

    ASSERT(pEntry->pConfigGroup == NULL);
    ASSERT(pEntry->ConfigGroupListEntry.Flink == NULL);

    pEntry->pConfigGroup = pObject;
    InsertTailList(&pObject->UrlListHead, &pEntry->ConfigGroupListEntry);

    //
    // flush the URI cache.
    // CODEWORK: if we were smarter we could make this more granular
    //
    UlFlushCache();

    //
    // Make sure to also mark a parent dirty .
    // need to search for a non-dummy parent
    //
    // pParent can be NULL for site entries
    //
    //

    pParent = pEntry->pParent;
    while (pParent != NULL)
    {

        ASSERT(IS_VALID_TREE_ENTRY(pParent));

        //
        // a non-dummy?
        //

        if (pParent->FullUrl == 1)
        {
            ASSERT(pParent->pConfigGroup != NULL);
            ASSERT(IS_VALID_CONFIG_GROUP(pParent->pConfigGroup));

            //
            // 1 is enough
            //

            break;
        }

        //
        // walk higher, keep looking for a non-dummy
        //

        pParent = pParent->pParent;
    }



end:

    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    CG_UNLOCK_WRITE();

    if (pNewUrl != NULL)
    {
        UL_FREE_POOL(pNewUrl, URL_POOL_TAG);
        pNewUrl = NULL;
    }


    RETURN(Status);
} // UlAddUrlToConfigGroup

/***************************************************************************++

Routine Description:

    removes pUrl from the url tree (and thus the config group) .

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,    the cgroup id.  ignored.

    IN PUNICODE_STRING pUrl,                the url. must be null terminated.


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveUrlFromConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PUNICODE_STRING pUrl
    )
{
    NTSTATUS                Status;
    PUL_CG_URL_TREE_ENTRY   pEntry;
    PWSTR                   pNewUrl = NULL;
    PUL_CONFIG_GROUP_OBJECT pObject = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL && pUrl->Buffer != NULL && pUrl->Length > 0);

    UlTrace(CONFIG_GROUP_FNC, ("http!UlRemoveUrlFromConfigGroup\n"));

    //
    // Cleanup the passed in url
    //

    Status = UlpSanitizeUrl(pUrl, &pNewUrl);
    if (!NT_SUCCESS(Status))
    {
        //
        // no goto end, resource not grabbed
        //
        return Status;
    }

    //
    // grab the lock
    //

    CG_LOCK_WRITE();

    //
    // Get the object ptr from id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)(
                    UlGetObjectFromOpaqueId(
                        ConfigGroupId,
                        UlOpaqueIdTypeConfigGroup,
                        UlReferenceConfigGroup
                        )
                    );

    if (!IS_VALID_CONFIG_GROUP(pObject))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Lookup the entry in the tree
    //

    Status = UlpTreeFindNode(pNewUrl, FALSE, NULL, NULL, &pEntry);
    if (!NT_SUCCESS(Status)) {
        goto end;
    }

    ASSERT(IS_VALID_TREE_ENTRY(pEntry));

    //
    // Does this tree entry match this config group?
    //

    if (pEntry->pConfigGroup != pObject)
    {
        Status = STATUS_INVALID_OWNER;
        goto end;
    }

    //
    // flush the URI cache.
    // CODEWORK: if we were smarter we could make this more granular
    //
    UlFlushCache();

    //
    // Everything looks good, free the node!
    //

    Status = UlpTreeFreeNode(pEntry);
    if (!NT_SUCCESS(Status)) {
        goto end;
    }

    //
    // NOTE:  don't do any more cleanup here... put it in freenode.
    // otherwise it won't get cleaned on handle closes.
    //

end:

    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    CG_UNLOCK_WRITE();

    if (pNewUrl != NULL)
    {
        UL_FREE_POOL(pNewUrl, URL_POOL_TAG);
        pNewUrl = NULL;
    }

    return Status;
} // UlRemoveUrlFromConfigGroup

/***************************************************************************++

Routine Description:

    Removes all URLS from the config group.

Arguments:

    ConfigGroupId - Supplies the config group ID.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveAllUrlsFromConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    )
{
    NTSTATUS                Status;
    PUL_CONFIG_GROUP_OBJECT pObject = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(CONFIG_GROUP_FNC, ("http!UlRemoveAllUrlsFromConfigGroup\n"));

    //
    // grab the lock
    //

    CG_LOCK_WRITE();

    //
    // Get the object ptr from id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)(
                    UlGetObjectFromOpaqueId(
                        ConfigGroupId,
                        UlOpaqueIdTypeConfigGroup,
                        UlReferenceConfigGroup
                        )
                    );

    if (IS_VALID_CONFIG_GROUP(pObject) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // flush the URI cache.
    // CODEWORK: if we were smarter we could make this more granular
    //
    UlFlushCache();

    //
    // Clean it.
    //

    Status = UlpCleanAllUrls( pObject );

end:

    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    CG_UNLOCK_WRITE();

    return Status;

}   // UlRemoveAllUrlsFromConfigGroup


/***************************************************************************++

Routine Description:

    Adds a transiently registered URL to the processes special transient
    registration config group. Requests matching this URL will be routed
    to this pool.

Arguments:

    pProcess - the apool process that will receive the requests
    pUrl - the URL prefix to be mapped in

--***************************************************************************/
NTSTATUS
UlAddTransientUrl(
    PUL_APP_POOL_OBJECT pAppPool,
    PUNICODE_STRING pUrl
    )
{
    NTSTATUS Status;
    PUL_CONFIG_GROUP_OBJECT pObject = NULL;
    PWSTR pNewUrl = NULL;
    PUL_CG_URL_TREE_ENTRY pEntry = NULL;
    PUL_CG_URL_TREE_ENTRY pParent;
    PUL_CONFIG_GROUP_OBJECT pParentObject;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT(pAppPool);
    ASSERT(pUrl);

    UlTrace(CONFIG_GROUP_FNC, (
        "http!UlAddTransientUrl(pAppPool = %p, Url '%S')\n",
        pAppPool,
        pUrl->Buffer
        ));

    //
    // Clean up the url
    //

    Status = UlpSanitizeUrl(pUrl, &pNewUrl);
    if (!NT_SUCCESS(Status)) {
        RETURN(Status);
    }

    //
    // create a new config group
    //
    Status = UlpCreateConfigGroupObject(&pObject);
    if (!NT_SUCCESS(Status)) {
        UL_FREE_POOL(pNewUrl, URL_POOL_TAG);
        RETURN(Status);
    }

    ASSERT(IS_VALID_CONFIG_GROUP(pObject));
    UlTrace(CONFIG_GROUP_FNC, (
        "http!UlAddTransientUrl(pAppPool = %p, Url '%S')\n"
        "        Created pObject = %p\n",
        pAppPool,
        pUrl->Buffer,
        pObject
        ));

    //
    // Set the app pool in the object
    //
    REFERENCE_APP_POOL(pAppPool);

    pObject->AppPoolFlags.Present = 1;
    pObject->pAppPool = pAppPool;

    //
    // lock the tree
    //
    CG_LOCK_WRITE();

    //
    // Add to the tree
    //
    Status = UlpTreeInsert(pNewUrl, &pEntry);

    if (NT_SUCCESS(Status)) {
        ASSERT(IS_VALID_TREE_ENTRY(pEntry));

        UlTrace(CONFIG_GROUP_FNC, (
            "http!UlAddTransientUrl(pAppPool = %p, Url '%S')\n"
            "        Created pEntry = %p\n",
            pAppPool,
            pUrl->Buffer,
            pEntry
            ));

        //
        // remember that this is a transient registration
        //
        pEntry->TransientUrl = 1;

        //
        // link the cfg group + the url
        //

        ASSERT(pEntry->pConfigGroup == NULL);
        ASSERT(pEntry->ConfigGroupListEntry.Flink == NULL);

        pEntry->pConfigGroup = pObject;
        InsertTailList(&pObject->UrlListHead, &pEntry->ConfigGroupListEntry);

        //
        // Find parent config group
        //
        pParent = pEntry->pParent;
        while (pParent && (pParent->TransientUrl || !pParent->FullUrl)) {
            pParent = pParent->pParent;
        }

        if (pParent) {
            pParentObject = pParent->pConfigGroup;

            //
            // check security
            //
            if (pParentObject->Security.Flags.Present) {
                SECURITY_SUBJECT_CONTEXT SubjectContext;
                BOOLEAN AccessOk;
                PPRIVILEGE_SET pPrivileges = NULL;
                ACCESS_MASK grantedAccess;

                SeCaptureSubjectContext(&SubjectContext);

                AccessOk = SeAccessCheck(
                                pParentObject->Security.pSecurityDescriptor,
                                &SubjectContext,
                                FALSE,          // SubjectContextLocked
                                FILE_GENERIC_WRITE,
                                0,              // PrevioslyGrantedAccess
                                &pPrivileges,
                                IoGetFileObjectGenericMapping(),
                                UserMode,
                                &grantedAccess,
                                &Status
                                );


                SeReleaseSubjectContext(&SubjectContext);
            } else {
                //
                // if there is no security we do not allow
                // transient registration
                //
                Status = STATUS_ACCESS_DENIED;
            }

            if (NT_SUCCESS(Status)) {
                //
                // link the group to the app pool
                //
                UlAddNotifyEntry(
                    &pParentObject->ChildHead,
                    &pObject->ParentEntry
                    );
            }

        } else {
            //
            // couldn't find a valid parent. We don't allow
            // transients without parents.
            //

            Status = STATUS_ACCESS_DENIED;
        }
    }

    //
    // flush the URI cache.
    // CODEWORK: if we were smarter we could make this more granular
    //
    UlFlushCache();

    //
    // Let go of the tree
    //
    CG_UNLOCK_WRITE();

    if (NT_SUCCESS(Status)) {
        //
        // Link into app pool
        //
        UlLinkConfigGroupToAppPool(pObject, pAppPool);
    } else {
        //
        // No static parent was found or we failed the
        // access check. Clean up.
        //
        UlDeleteConfigGroup(pObject->ConfigGroupId);
    }

    UL_FREE_POOL(pNewUrl, URL_POOL_TAG);

    RETURN(Status);
}

/***************************************************************************++

Routine Description:

    Removes a transiently registered URL from the processes special transient
    registration config group.

Arguments:

    pProcess - the apool process that had the registration
    pUrl - the URL prefix to be removed

--***************************************************************************/
NTSTATUS
UlRemoveTransientUrl(
    PUL_APP_POOL_OBJECT pAppPool,
    PUNICODE_STRING pUrl
    )
{
    NTSTATUS                Status;
    PUL_CG_URL_TREE_ENTRY   pEntry;
    PWSTR                   pNewUrl = NULL;
    HTTP_CONFIG_GROUP_ID    ConfigId = HTTP_NULL_ID;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(pAppPool);
    ASSERT(pUrl != NULL && pUrl->Buffer != NULL && pUrl->Length > 0);

    UlTrace(CONFIG_GROUP_FNC, (
        "http!UlRemoveTransientUrl(pAppPool = %p, Url '%S')\n",
        pAppPool,
        pUrl->Buffer
        ));

    //
    // Cleanup the passed in url
    //

    Status = UlpSanitizeUrl(pUrl, &pNewUrl);
    if (!NT_SUCCESS(Status))
    {
        RETURN(Status);
    }

    //
    // grab the lock
    //

    CG_LOCK_WRITE();

    //
    // Lookup the entry in the tree
    //

    Status = UlpTreeFindNode(pNewUrl, FALSE, NULL, NULL, &pEntry);

    if (NT_SUCCESS(Status)) {

        ASSERT(IS_VALID_TREE_ENTRY(pEntry));

        //
        // Is it a transient URL for this app pool?
        //
        if (pEntry->TransientUrl &&
            pEntry->pConfigGroup->AppPoolFlags.Present &&
            pEntry->pConfigGroup->pAppPool == pAppPool)
        {
            ConfigId = pEntry->pConfigGroup->ConfigGroupId;
        } else {
            Status = STATUS_INVALID_OWNER;
        }
    }

    CG_UNLOCK_WRITE();

    //
    // Everything looks good, free the group!
    //
    if (!HTTP_IS_NULL_ID(&ConfigId)) {
        ASSERT(NT_SUCCESS(Status));

        Status = UlDeleteConfigGroup(ConfigId);
    }


    if (pNewUrl != NULL)
    {
        UL_FREE_POOL(pNewUrl, URL_POOL_TAG);
        pNewUrl = NULL;
    }

    RETURN(Status);
} // UlRemoveTransientUrl

/***************************************************************************++

Routine Description:

    allows query information for cgroups.  see uldef.h

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,  cgroup id

    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,  what to fetch

    IN PVOID pConfigGroupInformation,       output buffer

    IN ULONG Length,                        length of pConfigGroupInformation

    OUT PULONG pReturnLength OPTIONAL       how much was copied into the
                                            output buffer


Return Value:

    NTSTATUS - Completion status.

        STATUS_INVALID_PARAMETER            bad cgroup id

        STATUS_BUFFER_TOO_SMALL             output buffer too small

        STATUS_INVALID_PARAMETER            invalid infoclass

--***************************************************************************/
NTSTATUS
UlQueryConfigGroupInformation(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PUL_CONFIG_GROUP_OBJECT pObject = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pConfigGroupInformation != NULL || pReturnLength != NULL);
    ASSERT(pConfigGroupInformation == NULL || Length > 0);

    //
    // If no buffer is supplied, we are being asked to return the length needed
    //

    if (pConfigGroupInformation == NULL && pReturnLength == NULL)
        return STATUS_INVALID_PARAMETER;

    CG_LOCK_READ();

    //
    // Get the object ptr from id
    //

    pObject = (PUL_CONFIG_GROUP_OBJECT)(
                    UlGetObjectFromOpaqueId(
                        ConfigGroupId,
                        UlOpaqueIdTypeConfigGroup,
                        UlReferenceConfigGroup
                        )
                    );

    if (IS_VALID_CONFIG_GROUP(pObject) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // What are we being asked to do?
    //

    switch (InformationClass)
    {

    case HttpConfigGroupBandwidthInformation:

        if (pConfigGroupInformation == NULL)
        {
            //
            // return the size needed
            //

            *pReturnLength = sizeof(HTTP_CONFIG_GROUP_MAX_BANDWIDTH);
        }
        else
        {

            if (Length < sizeof(HTTP_CONFIG_GROUP_MAX_BANDWIDTH))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                goto end;
            }

            *((PHTTP_CONFIG_GROUP_MAX_BANDWIDTH)pConfigGroupInformation) = pObject->MaxBandwidth;
        }
        break;

    case HttpConfigGroupConnectionInformation:

        if (pConfigGroupInformation == NULL)
        {
            //
            // return the size needed
            //

            *pReturnLength = sizeof(HTTP_CONFIG_GROUP_MAX_CONNECTIONS);
        }
        else
        {
            if (Length < sizeof(HTTP_CONFIG_GROUP_MAX_CONNECTIONS))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                goto end;
            }

            *((PHTTP_CONFIG_GROUP_MAX_CONNECTIONS)pConfigGroupInformation) = pObject->MaxConnections;
        }
        break;

    case HttpConfigGroupStateInformation:

        if (pConfigGroupInformation == NULL)
        {
            //
            // return the size needed
            //

            *pReturnLength = sizeof(HTTP_CONFIG_GROUP_STATE);
        }
        else
        {
            if (Length < sizeof(HTTP_CONFIG_GROUP_STATE))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                goto end;
            }

            *((PHTTP_CONFIG_GROUP_STATE)pConfigGroupInformation) = pObject->State;
        }
        break;

    case HttpConfigGroupConnectionTimeoutInformation:
        if (pConfigGroupInformation == NULL)
        {
            //
            // return the size needed
            //

            *pReturnLength = sizeof(ULONG);
        }
        else
        {
            *((ULONG *)pConfigGroupInformation) =
                (ULONG)(pObject->ConnectionTimeout / C_NS_TICKS_PER_SEC);
        }
        break;

    case HttpConfigGroupAppPoolInformation:
    case HttpConfigGroupAutoResponseInformation:
    case HttpConfigGroupSecurityInformation:

        //
        // this is illegal
        //

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;

    }

    Status = STATUS_SUCCESS;

end:
    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }


    CG_UNLOCK_READ();
    return Status;

} // UlQueryConfigGroupInformation

/***************************************************************************++

Routine Description:

    allows you to set info for the cgroup.  see uldef.h

Arguments:

    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,  cgroup id

    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,  what to fetch

    IN PVOID pConfigGroupInformation,       input buffer

    IN ULONG Length,                        length of pConfigGroupInformation


Return Value:

    NTSTATUS - Completion status.

        STATUS_INVALID_PARAMETER            bad cgroup id

        STATUS_BUFFER_TOO_SMALL             input buffer too small

        STATUS_INVALID_PARAMETER            invalid infoclass

--***************************************************************************/
NTSTATUS
UlSetConfigGroupInformation(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_CONFIG_GROUP_OBJECT pObject;
    PHTTP_CONFIG_GROUP_LOGGING pLoggingInfo;
    PHTTP_CONFIG_GROUP_MAX_BANDWIDTH pMaxBandwidth;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // no buffer?
    //

    if (pConfigGroupInformation == NULL)
        return STATUS_INVALID_PARAMETER;

    CG_LOCK_WRITE();

    __try
    {
        //
        // Get the object ptr from id
        //

        pObject = (PUL_CONFIG_GROUP_OBJECT)(
                        UlGetObjectFromOpaqueId(
                            ConfigGroupId,
                            UlOpaqueIdTypeConfigGroup,
                            UlReferenceConfigGroup
                            )
                        );

        if (IS_VALID_CONFIG_GROUP(pObject) == FALSE)
        {
            Status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        //
        // What are we being asked to do?
        //

        switch (InformationClass)
        {

        case HttpConfigGroupAutoResponseInformation:
        {
            PHTTP_AUTO_RESPONSE pAutoResponse;

            pAutoResponse = (PHTTP_AUTO_RESPONSE)pConfigGroupInformation;

            //
            //  double check the buffer is big enough
            //

            if (Length < sizeof(HTTP_AUTO_RESPONSE))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            //
            // Is there an auto-response?
            //

            // BUGBUG: temp optional
    //        if (pAutoResponse->Flags.Present == 1 && pAutoResponse->pResponse != NULL)
            if (pAutoResponse->Flags.Present == 1)
            {
                HTTP_VERSION HttpVersion11 = {1,1};

                //
                // Are we replacing one already there?
                //

                if (pObject->pAutoResponse != NULL)
                {
                    UL_DEREFERENCE_INTERNAL_RESPONSE(pObject->pAutoResponse);
                    pObject->pAutoResponse = NULL;
                }

                //
                // Convert it to kernel mode
                //

                Status = UlCaptureHttpResponse(
                                pAutoResponse->pResponse,
                                NULL,
                                HttpVersion11,
                                HttpVerbUnknown,
                                pAutoResponse->EntityChunkCount,
                                pAutoResponse->pEntityChunks,
                                UlCaptureCopyData,
                                FALSE,
                                NULL,
                                &pObject->pAutoResponse
                                );

                if (NT_SUCCESS(Status) == FALSE)
                {
                    pObject->pAutoResponse = NULL;
                    __leave;
                }

                Status = UlPrepareHttpResponse(
                                HttpVersion11,
                                pAutoResponse->pResponse,
                                pObject->pAutoResponse
                                );

                if (NT_SUCCESS(Status) == FALSE)
                {
                    UL_DEREFERENCE_INTERNAL_RESPONSE(pObject->pAutoResponse);
                    pObject->pAutoResponse = NULL;
                    __leave;
                }

            }
            else
            {
                //
                // Remove ours?
                //

                if (pObject->pAutoResponse != NULL)
                {
                    UL_DEREFERENCE_INTERNAL_RESPONSE(pObject->pAutoResponse);
                }
                pObject->pAutoResponse = NULL;
            }

        }
            break;

        case HttpConfigGroupAppPoolInformation:
        {
            PHTTP_CONFIG_GROUP_APP_POOL pAppPoolInfo;
            PUL_APP_POOL_OBJECT         pOldAppPool;

            pAppPoolInfo = (PHTTP_CONFIG_GROUP_APP_POOL)pConfigGroupInformation;

            //
            //  double check the buffer is big enough
            //

            if (Length < sizeof(HTTP_CONFIG_GROUP_APP_POOL))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            //
            // remember the old app pool if there is one, so we can deref it
            // if we need to
            //
            if (pObject->AppPoolFlags.Present == 1 && pObject->pAppPool != NULL)
            {
                pOldAppPool = pObject->pAppPool;
            } else {
                pOldAppPool = NULL;
            }

            if (pAppPoolInfo->Flags.Present == 1)
            {
                //
                // ok, were expecting a handle to the file object for the app pool
                //
                // let's open it
                //

                Status = UlGetPoolFromHandle(
                                pAppPoolInfo->AppPoolHandle,
                                &pObject->pAppPool
                                );

                if (NT_SUCCESS(Status) == FALSE)
                    __leave;

                pObject->AppPoolFlags.Present = 1;

            }
            else
            {
                pObject->AppPoolFlags.Present = 0;
                pObject->pAppPool = NULL;
            }

            //
            // deref the old app pool
            //
            if (pOldAppPool) {
                DEREFERENCE_APP_POOL(pOldAppPool);
            }
        }
            break;


        case HttpConfigGroupLogInformation:
        {
            //
            // Sanity Check first
            //

            if (Length < sizeof(HTTP_CONFIG_GROUP_LOGGING))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            __leave;
            }

            pLoggingInfo = (PHTTP_CONFIG_GROUP_LOGGING)pConfigGroupInformation;

            if ( !IS_VALID_DIR_NAME(&pLoggingInfo->LogFileDir) )
            {
                //
                // If the passed down Directory_Name is corrupted or
                // abnormally big. Then reject it.
                //

                Status = STATUS_INVALID_PARAMETER;
                __leave;
            }

            __try
            {
                if (pObject->LoggingConfig.Flags.Present)
                {
                    //
                    // Check to see if log dir is correct
                    //

                    Status = UlCheckLogDirectory( &pLoggingInfo->LogFileDir );
                    if ( NT_SUCCESS(Status) )
                    {
                        //
                        // Log settings are being reconfigured
                        //

                        Status = UlReConfigureLogEntry(
                                        pObject,                  // For the file entry
                                        &pObject->LoggingConfig,  // The old config
                                        pLoggingInfo              // The new config
                                        );
                    }
                    //
                    // Otherwise keep the old settings
                    //
                }
                else
                {
                    // Save to config group
                    pObject->LoggingConfig = *pLoggingInfo;

                    pObject->LoggingConfig.LogFileDir.Buffer =
                            (PWSTR) UL_ALLOCATE_ARRAY(
                                PagedPool,
                                UCHAR,
                                pLoggingInfo->LogFileDir.MaximumLength,
                                UL_CG_LOGDIR_POOL_TAG
                                );
                    if (pObject->LoggingConfig.LogFileDir.Buffer == NULL)
                    {
                        Status = STATUS_NO_MEMORY;
                        __leave;
                    }

                    RtlCopyMemory(
                        pObject->LoggingConfig.LogFileDir.Buffer,
                        pLoggingInfo->LogFileDir.Buffer,
                        pObject->LoggingConfig.LogFileDir.MaximumLength
                    );

                    pObject->LoggingConfig.Flags.Present = 1;

                    Status = UlCreateLog( pObject );

                    if ( !NT_SUCCESS(Status) )
                    {
                        //
                        // Clean up and return to logging not present state
                        //

                        UlTrace( LOGGING,
                            ("UlSetConfigGroupInformation: directory %S failure %08lx\n",
                              pObject->LoggingConfig.LogFileDir.Buffer,
                              Status
                              ));

                        UL_FREE_POOL(
                            pObject->LoggingConfig.LogFileDir.Buffer,
                            UL_CG_LOGDIR_POOL_TAG
                            );

                        pObject->LoggingConfig.LogFileDir.Buffer = NULL;

                        if ( pObject->pLogFileEntry )
                            UlRemoveLogFileEntry( pObject->pLogFileEntry );

                        pObject->pLogFileEntry = NULL;
                        pObject->LoggingConfig.Flags.Present = 0;
                        pObject->LoggingConfig.LoggingEnabled = FALSE;
                    }
                }

            }
            __except( UL_EXCEPTION_FILTER() )
            {
                Status = GetExceptionCode();
            }

            if (!NT_SUCCESS(Status))
                __leave;

            // both cleared or both set
            ASSERT(!pObject->LoggingConfig.LoggingEnabled
                        == !pObject->pLogFileEntry);
        }
            break;

        case HttpConfigGroupBandwidthInformation:
        {
            //
            // Sanity Check first
            //
            if (Length < sizeof(HTTP_CONFIG_GROUP_MAX_BANDWIDTH))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            pMaxBandwidth = (PHTTP_CONFIG_GROUP_MAX_BANDWIDTH) pConfigGroupInformation;

            //
            // Interpret the ZERO as HTTP_LIMIT_INFINITE
            //
            if (pMaxBandwidth->MaxBandwidth == 0)
            {
                pMaxBandwidth->MaxBandwidth = HTTP_LIMIT_INFINITE;
            }

            //
            // But check to see if PSched is installed or not before proceeding.
            // By returning an error here, WAS will raise an event warning but
            // proceed w/o terminating the web server
            //
            if (!UlTcPSchedInstalled())
            {
                Status = STATUS_SUCCESS;
                __leave;
#if 0
                // Enable when WAS get updated to expect this error.

                if (pMaxBandwidth->MaxBandwidth != HTTP_LIMIT_INFINITE)
                {
                    // There's a BWT limit coming down but PSched is not installed

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    __leave;
                }
                else
                {
                    // By default Config Store has HTTP_LIMIT_INFINITE. Therefore
                    // return success for non-actions to prevent unnecessary event
                    // warnings.

                    Status = STATUS_SUCCESS;
                    __leave;
                }
#endif
            }

            //
            // Create the flow if this is the first time we see Bandwidth set
            // otherwise call reconfiguration for the existing flow. The case
            // that the limit is infinite can be interpreted as BTW  disabled
            //
            if (pObject->MaxBandwidth.Flags.Present &&
                pObject->MaxBandwidth.MaxBandwidth != HTTP_LIMIT_INFINITE)
            {
                // To see if there is a real change
                if (pMaxBandwidth->MaxBandwidth != pObject->MaxBandwidth.MaxBandwidth)
                {
                    if (pMaxBandwidth->MaxBandwidth != HTTP_LIMIT_INFINITE)
                    {
                        // This will modify all the flows on all interfaces for this site
                        Status = UlTcModifyFlowsForSite(
                                    pObject,                        // for this site
                                    pMaxBandwidth->MaxBandwidth     // the new bandwidth
                                    );
                        if (!NT_SUCCESS(Status))
                            __leave;
                    }
                    else
                    {
                        // Handle BTW disabling by removing the existing flows
                        Status = UlTcRemoveFlowsForSite(pObject);
                        if (!NT_SUCCESS(Status))
                            __leave;
                    }

                    // Don't forget to update the cgroup object if it was a success
                    pObject->MaxBandwidth.MaxBandwidth = pMaxBandwidth->MaxBandwidth;
                }
            }
            else
            {
                // Its about time to add a flow for a site entry.
                if (pMaxBandwidth->MaxBandwidth != HTTP_LIMIT_INFINITE)
                {
                    Status = UlTcAddFlowsForSite(
                                pObject,
                                pMaxBandwidth->MaxBandwidth
                                );

                    if (!NT_SUCCESS(Status))
                        __leave;
                }

                //
                // Success! Remember the bandwidth limit inside the cgroup
                //
                pObject->MaxBandwidth = *pMaxBandwidth;
                pObject->MaxBandwidth.Flags.Present = 1;

                //
                // When the last reference to this  cgroup  released,   corresponding
                // flows are going to be removed.Alternatively flows might be removed
                // by explicitly setting the bandwidth  throttling  limit to infinite
                // or reseting the  flags.present.The latter case  is  handled  above
                // Look at the deref config group for the former.
                //
            }
        }
            break;

        case HttpConfigGroupConnectionInformation:

            if (Length < sizeof(HTTP_CONFIG_GROUP_MAX_CONNECTIONS))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            pObject->MaxConnections =
                *((PHTTP_CONFIG_GROUP_MAX_CONNECTIONS)pConfigGroupInformation);

            if (pObject->pConnectionCountEntry)
            {
                // Update
                UlSetMaxConnections(
                    &pObject->pConnectionCountEntry->MaxConnections,
                     pObject->MaxConnections.MaxConnections
                     );
            }
            else
            {
                // Create
                Status = UlCreateConnectionCountEntry(
                            pObject,
                            pObject->MaxConnections.MaxConnections
                            );
            }
            break;

        case HttpConfigGroupStateInformation:

            if (Length < sizeof(HTTP_CONFIG_GROUP_STATE))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }
            else
            {
                PHTTP_CONFIG_GROUP_STATE pCGState =
                    ((PHTTP_CONFIG_GROUP_STATE) pConfigGroupInformation);
                HTTP_ENABLED_STATE NewState = pCGState->State;

                if ((NewState != HttpEnabledStateActive)
                    && (NewState != HttpEnabledStateInactive))
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    pObject->State = *pCGState;

                    UlTrace(ROUTING,
                            ("UlSetConfigGroupInfo(StateInfo): obj=%p, "
                             "Flags.Present=%lu, State=%sactive.\n",
                             pObject,
                             (ULONG) pObject->State.Flags.Present,
                             (NewState == HttpEnabledStateActive) ? "" : "in"
                             )); 
                }
            }

            break;

        case HttpConfigGroupSecurityInformation:
        {
            PHTTP_CONFIG_GROUP_SECURITY pSecurity;
            PSECURITY_DESCRIPTOR pSecurityDescriptor;

            if (Length < sizeof(HTTP_CONFIG_GROUP_SECURITY))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            //
            // get a copy of the new descriptor (do we need this step?)
            //
            pSecurity = (PHTTP_CONFIG_GROUP_SECURITY) pConfigGroupInformation;

            if (pSecurity->Flags.Present && pSecurity->pSecurityDescriptor) {
                Status = SeCaptureSecurityDescriptor(
                                pSecurity->pSecurityDescriptor,
                                UserMode,
                                PagedPool,
                                FALSE,
                                &pSecurityDescriptor
                                );

                if (NT_SUCCESS(Status)) {
                    SECURITY_SUBJECT_CONTEXT SubjectContext;

                    SeCaptureSubjectContext(&SubjectContext);
                    SeLockSubjectContext(&SubjectContext);

                    //
                    // stuff it in the structure
                    //
                    Status = SeAssignSecurity(
                                    NULL,               // ParentDescriptor
                                    pSecurityDescriptor,
                                    &pSecurity->pSecurityDescriptor,
                                    FALSE,              // IsDirectoryObject
                                    &SubjectContext,
                                    IoGetFileObjectGenericMapping(),
                                    PagedPool
                                    );

                    SeUnlockSubjectContext(&SubjectContext);
                    SeReleaseSubjectContext(&SubjectContext);

                    ExFreePool(pSecurityDescriptor);
                }
            } else {
                pSecurity->Flags.Present = 0;
                pSecurityDescriptor = NULL;
            }

            //
            // replace the old information
            //
            if (NT_SUCCESS(Status)) {
                if (pObject->Security.Flags.Present) {
                    ASSERT(pObject->Security.pSecurityDescriptor);

                    ExFreePool(pObject->Security.pSecurityDescriptor);
                }

                pObject->Security = *pSecurity;
            } else {
                // return the error
                __leave;
            }

        }
            break;

        case HttpConfigGroupSiteInformation:
        {
            PHTTP_CONFIG_GROUP_SITE  pSite;

            if (Length < sizeof(HTTP_CONFIG_GROUP_SITE))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            pSite = (PHTTP_CONFIG_GROUP_SITE)pConfigGroupInformation;

            Status = UlCreateSiteCounterEntry(
                            pObject,
                            pSite->SiteId
                            );
        }

            break;

        case HttpConfigGroupConnectionTimeoutInformation:
            if (Length < sizeof(ULONG))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }
            else
            {
                LONGLONG Timeout;

                Timeout = *((ULONG *)pConfigGroupInformation);

                //
                // Set the per site Connection Timeout limit override
                //
                pObject->ConnectionTimeout = Timeout * C_NS_TICKS_PER_SEC;
            }

            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            __leave;

        }

        //
        // flush the URI cache.
        // CODEWORK: if we were smarter we could make this more granular
        //
        UlFlushCache();

        Status = STATUS_SUCCESS;
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }


    if (pObject != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pObject);
        pObject = NULL;
    }

    CG_UNLOCK_WRITE();
    return Status;

} // UlSetConfigGroupInformation

/***************************************************************************++

Routine Description:

    applies the inheritence, gradually setting the information from pMatchEntry
    into pInfo.  it only copies present info from pMatchEntry.

    also updates the timestamp info in pInfo.  there MUST be enough space for
    1 more index prior to calling this function.

Arguments:

    IN PUL_URL_CONFIG_GROUP_INFO pInfo,     the place to set the info

    IN PUL_CG_URL_TREE_ENTRY pMatchEntry    the entry to use to set it

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetUrlInfo(
    IN OUT PUL_URL_CONFIG_GROUP_INFO pInfo,
    IN PUL_CG_URL_TREE_ENTRY pMatchEntry
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pInfo != NULL && IS_VALID_URL_CONFIG_GROUP_INFO(pInfo));
    ASSERT(IS_VALID_TREE_ENTRY(pMatchEntry));
    ASSERT(pMatchEntry->FullUrl == 1);
    ASSERT(IS_VALID_CONFIG_GROUP(pMatchEntry->pConfigGroup));

    //
    // set the control channel. The current level might
    // not have one (if it's transient), but in that
    // case a parent should have had one.
    //

    if (pMatchEntry->pConfigGroup->pControlChannel) {
        pInfo->pControlChannel = pMatchEntry->pConfigGroup->pControlChannel;
    }
    ASSERT(pInfo->pControlChannel);

    if (pMatchEntry->pConfigGroup->AppPoolFlags.Present == 1)
    {
        if (pInfo->pAppPool != NULL)
        {
            //
            // let go the one already there
            //

            DEREFERENCE_APP_POOL(pInfo->pAppPool);
        }

        pInfo->pAppPool = pMatchEntry->pConfigGroup->pAppPool;
        REFERENCE_APP_POOL(pInfo->pAppPool);
    }

    //
    // and the auto response
    //

    if (pMatchEntry->pConfigGroup->pAutoResponse != NULL)
    {
        if (pInfo->pAutoResponse != NULL)
        {
            //
            // let go the one already there
            //

            UL_DEREFERENCE_INTERNAL_RESPONSE(pInfo->pAutoResponse);
        }
        pInfo->pAutoResponse = pMatchEntry->pConfigGroup->pAutoResponse;
        UL_REFERENCE_INTERNAL_RESPONSE(pInfo->pAutoResponse);
    }
    else if (pInfo->pAutoResponse == NULL &&
             pInfo->pControlChannel->pAutoResponse != NULL)
    {
        //
        // set the one from the control channel
        //

        pInfo->pAutoResponse = pInfo->pControlChannel->pAutoResponse;

        UL_REFERENCE_INTERNAL_RESPONSE(pInfo->pAutoResponse);
    }

    //
    // url context
    //

    pInfo->UrlContext   = pMatchEntry->UrlContext;

    //

    if (pMatchEntry->pConfigGroup->MaxBandwidth.Flags.Present == 1)
    {
        if (pInfo->pMaxBandwidth == NULL)
        {
            pInfo->pMaxBandwidth = pMatchEntry->pConfigGroup;
            REFERENCE_CONFIG_GROUP(pInfo->pMaxBandwidth);
        }
    }

    if (pMatchEntry->pConfigGroup->MaxConnections.Flags.Present == 1)
    {
        if (pInfo->pMaxConnections == NULL)
        {
            pInfo->pMaxConnections = pMatchEntry->pConfigGroup;
            REFERENCE_CONFIG_GROUP(pInfo->pMaxConnections);

            pInfo->pConnectionCountEntry = pMatchEntry->pConfigGroup->pConnectionCountEntry;
            REFERENCE_CONNECTION_COUNT_ENTRY(pInfo->pConnectionCountEntry);
        }
    }

    //
    // Logging Info config can only be set from the Root App of
    // the site. We do not need to keep updating it down the tree
    // Therefore its update is slightly different.
    //

    if (pMatchEntry->pConfigGroup->LoggingConfig.Flags.Present == 1)
    {
        if (pInfo->pLoggingConfig == NULL)
        {
            pInfo->pLoggingConfig = pMatchEntry->pConfigGroup;
            REFERENCE_CONFIG_GROUP(pInfo->pLoggingConfig);
        }
    }

    //
    // Site Counter Entry
    //
    if (pMatchEntry->pConfigGroup->pSiteCounters)
    {
        // the pSiteCounters entry will only be set on
        // the "Site" ConfigGroup object.
        if (NULL == pInfo->pSiteCounters)
        {
            UlTrace(PERF_COUNTERS,
                    ("http!UlpSetUrlInfo: pSiteCounters %p set on pInfo %p for SiteId %d\n",
                     pMatchEntry->pConfigGroup->pSiteCounters,
                     pInfo,
                     pMatchEntry->pConfigGroup->pSiteCounters->Counters.SiteId
                     ));

            pInfo->pSiteCounters = pMatchEntry->pConfigGroup->pSiteCounters;
            pInfo->SiteId = pInfo->pSiteCounters->Counters.SiteId;

            REFERENCE_SITE_COUNTER_ENTRY(pInfo->pSiteCounters);
        }
    }

    //
    // Connection Timeout (100ns Ticks)
    //
    if ( pMatchEntry->pConfigGroup->ConnectionTimeout )
    {
        pInfo->ConnectionTimeout = pMatchEntry->pConfigGroup->ConnectionTimeout;
    }

    if (pMatchEntry->pConfigGroup->State.Flags.Present == 1)
    {
        if (pInfo->pCurrentState != NULL)
        {
            DEREFERENCE_CONFIG_GROUP(pInfo->pCurrentState);
        }

        pInfo->pCurrentState = pMatchEntry->pConfigGroup;
        REFERENCE_CONFIG_GROUP(pInfo->pCurrentState);

        //
        // and a copy
        //

        pInfo->CurrentState = pInfo->pCurrentState->State.State;
    }

    UlTrace(
        CONFIG_GROUP_TREE, (
            "http!UlpSetUrlInfo: Matching entry(%S) points to cfg group(%p)\n",
            pMatchEntry->pToken,
            pMatchEntry->pConfigGroup
            )
        );

    return STATUS_SUCCESS;
} // UlpSetUrlInfo


/***************************************************************************++

Routine Description:

    walks the url tree and builds the URL_INFO.

Arguments:

    IN PUNICODE_STRING pUrl,                    the url to fetch info for

    OUT PUL_URL_CONFIG_GROUP_INFO * ppInfo      the info.  caller must free it.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetConfigGroupInfoForUrl(
    IN PWSTR pUrl,
    IN PUL_HTTP_CONNECTION pHttpConn,
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUrl != NULL);
    ASSERT(pInfo != NULL);

    UlTrace(CONFIG_GROUP_FNC, ("http!UlGetConfigGroupInfoForUrl(%S)\n", pUrl));

    //
    // grab the lock
    //

    CG_LOCK_READ();

    Status = UlpTreeFindNode(pUrl, TRUE, pHttpConn, pInfo, NULL);

    CG_UNLOCK_READ();

    return Status;
}


/***************************************************************************++

Routine Description:

    must be called to free the info buffer.

Arguments:

    IN PUL_URL_CONFIG_GROUP_INFO pInfo      the info to free

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpConfigGroupInfoRelease(
    IN PUL_URL_CONFIG_GROUP_INFO pInfo
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pInfo != NULL);

    UlTrace(CONFIG_GROUP_FNC, ("http!UlpConfigGroupInfoRelease(%p)\n", pInfo));

    if (pInfo->pAppPool != NULL)
    {
        DEREFERENCE_APP_POOL(pInfo->pAppPool);
    }

    if (pInfo->pAutoResponse != NULL)
    {
        UL_DEREFERENCE_INTERNAL_RESPONSE(pInfo->pAutoResponse);
    }

    if (pInfo->pMaxBandwidth != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pInfo->pMaxBandwidth);
    }

    if (pInfo->pMaxConnections != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pInfo->pMaxConnections);
    }

    if (pInfo->pCurrentState != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pInfo->pCurrentState);
    }

    if (pInfo->pLoggingConfig != NULL)
    {
        DEREFERENCE_CONFIG_GROUP(pInfo->pLoggingConfig);
    }

    // UL_SITE_COUNTER_ENTRY
    if (pInfo->pSiteCounters != NULL)
    {
        DEREFERENCE_SITE_COUNTER_ENTRY(pInfo->pSiteCounters);
    }

    if (pInfo->pConnectionCountEntry != NULL)
    {
        DEREFERENCE_CONNECTION_COUNT_ENTRY(pInfo->pConnectionCountEntry);
    }

    return STATUS_SUCCESS;

} // UlpConfigGroupInfoRelease

/***************************************************************************++

Routine Description:

    Rough equivalent of the asignment operator for safely copying the
    UL_URL_CONFIG_GROUP_INFO object and all of its contained pointers.

Arguments:

    IN pOrigInfo      the info to copy from
    IN OUT pNewInfo   the destination object

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpConfigGroupInfoDeepCopy(
    IN const PUL_URL_CONFIG_GROUP_INFO pOrigInfo,
    IN OUT PUL_URL_CONFIG_GROUP_INFO pNewInfo
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(CONFIG_GROUP_FNC,
            ("http!UlpConfigGroupInfoDeepCopy(Orig: %p, New: %p)\n",
            pOrigInfo,
            pNewInfo
            ));

    ASSERT( pOrigInfo != NULL && pNewInfo != NULL );


    if (pOrigInfo->pAppPool != NULL)
    {
        REFERENCE_APP_POOL(pOrigInfo->pAppPool);
    }

    if (pOrigInfo->pAutoResponse != NULL)
    {
        UL_REFERENCE_INTERNAL_RESPONSE(pOrigInfo->pAutoResponse);
    }

    if (pOrigInfo->pMaxBandwidth != NULL)
    {
        REFERENCE_CONFIG_GROUP(pOrigInfo->pMaxBandwidth);
    }

    if (pOrigInfo->pMaxConnections != NULL)
    {
        REFERENCE_CONFIG_GROUP(pOrigInfo->pMaxConnections);
    }

    if (pOrigInfo->pCurrentState != NULL)
    {
        REFERENCE_CONFIG_GROUP(pOrigInfo->pCurrentState);
    }

    if (pOrigInfo->pLoggingConfig != NULL)
    {
        REFERENCE_CONFIG_GROUP(pOrigInfo->pLoggingConfig);
    }

    // UL_SITE_COUNTER_ENTRY
    if (pOrigInfo->pSiteCounters != NULL)
    {
        REFERENCE_SITE_COUNTER_ENTRY(pOrigInfo->pSiteCounters);
    }

    if (pOrigInfo->pConnectionCountEntry != NULL)
    {
        REFERENCE_CONNECTION_COUNT_ENTRY(pOrigInfo->pConnectionCountEntry);
    }

    //
    // Copy the old stuff over
    //

    RtlCopyMemory(
        pNewInfo,
        pOrigInfo,
        sizeof(UL_URL_CONFIG_GROUP_INFO)
        );

    return STATUS_SUCCESS;

} // UlpConfigGroupInfoDeepCopy


/***************************************************************************++

Routine Description:

    This function gets called when a static config group's control channel
    goes away, or when a transient config group's app pool or static parent
    goes away.

    Deletes the config group.

Arguments:

    pEntry - A pointer to HandleEntry or ParentEntry.
    pHost - Pointer to the config group
    pv - unused

--***************************************************************************/
BOOLEAN
UlNotifyOrphanedConfigGroup(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    )
{
    PUL_CONFIG_GROUP_OBJECT pObject = (PUL_CONFIG_GROUP_OBJECT) pHost;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT(pEntry);
    ASSERT(IS_VALID_CONFIG_GROUP(pObject));

    UlDeleteConfigGroup(pObject->ConfigGroupId);

    return TRUE;
} // UlNotifyOrphanedConfigGroup


/***************************************************************************++

[design notes]


[url format]

url format = http[s]://[ ip-address|hostname|* :port-number/ [abs_path] ]

no escaping is allowed.

[caching cfg group info]
the tree was designed for quick lookup, but it is still costly to do the
traversal.  so the cfg info for an url was designed to be cached and stored
in the actual response cache, which will be able to be directly hashed into.

this is the fast fast path.

in order to do this, the buffer for is allocated in non-paged pool.  the
timestamp for each cfg group used to build the info (see building the url
info) is remembered in the returned struct.  actually just indexes into the
global timestamp array are kept.  the latest timestamp is then stored in the
struct itself.

later, if a cfg group is updated, the timestamp for that cfg group (in the
global array) is updated to current time.

if a request comes in, and we have a resposne cache hit, the driver will
check to see if it's cfg group info is stale.  this simple requires scanning
the global timestamp array to see if any stamps are greater than the stamp
in the struct.  this is not expensive .  1 memory lookup per level of url
depth.

this means that the passive mode code + dispatch mode code contend for the
timestamp spinlock.  care is made to not hold this lock long.  memory
allocs + frees are carefully moved outside the spinlocks.

care is also made as to the nature of tree updates + invalidating cached
data.  to do this, the parent cfg group (non-dummy) is marked dirty.  this
is to prevent the case that a new child cfg group is added that suddenly
affects an url it didn't effect before.  image http://paul.com:80/ being
the only registered cfg group.  a request comes in for /images/1.jpg.
the matching cfg group is that root one.  later, a /images cfg group
is created.  it now is a matching cfg group for that url sitting in the
response cache.  thus needs to be invalidated.


[paging + irq]
the entire module assumes that it is called at IRQ==PASSIVE except for the
stale detection code.

this code accesses the timestamp array (see caching cfg group info) which
is stored in non-paged memory and synch'd with passive level access
using a spinlock.


[the tree]

the tree is made up of headers + entries.  headers represent a group of entries
that share a parent.  it's basically a length prefixed array of entries.

the parent pointer is in the entry not the header, as the entry does not really
now it's an element in an array.

entries have a pointer to a header that represents it's children.  a header is
all of an entries children.  headers don't link horizontally.  they dyna-grow.
if you need to add a child to an entry, and his children header is full, boom.
gotta realloc to grow .

each node in the tree represents a token in a url, the things between the '/'
characters.

the entries in a header array are sorted.  today they are sorted by their hash
value.  this might change if the tokens are small enough, it's probably more
expensive to compute the hash value then just strcmp.  the hash is 2bytes.  the
token length is also 2bytes so no tokens greater than 32k.

i chose an array at first to attempt to get rid of right-left pointers.  it
turned out to be futile as my array is an array of pointers.  it has to be
an array of pointers as i grow + shrink it to keep it sorted.  so i'm not
saving memory.  however, as an array of pointers, it enables a binary search
as the array is sorted.  this yields log(n) perf on a width search.

there are 2 types of entries in the tree.  dummy entries and full url entries.
a full url is the leaf of an actual entry to UlAddUrl... dummy nodes are ones
that are there only to be parents to full url nodes.

dummy nodes have 2 ptrs + 2 ulongs.
full urls nodes have an extra 4 ptrs.

both store the actual token along with the entry. (unicode baby.  2 bytes per char).

at the top of the tree are sites.  these are stored in a global header as siblings
in g_pSites.  this can grow quite wide.

adding a full url entry creates the branch down to the entry.

deleting a full entry removes as far up the branch as possible without removing other
entries parents.

delete is also careful to not actually delete if other children exist.  in this case
the full url entry is converted to a dummy node entry.

it was attempted to have big string url stored in the leaf node and the dummy nodes
simply point into this string for it's pToken.  this doesn't work as the dummy nodes
pointers become invalid if the leaf node is later deleted.  individual ownership of
tokens is needed to allow shared parents in the tree, with arbitrary node deletion.

an assumption throughout this code is that the tree is relatively static.  changes
don't happen that often.  basically inserts only on boot.  and deletes only on
shutdown.  this is why single clusters of siblings were chosen, as opposed to linked
clusters.  children group width will remain fairly static meaning array growth is
rare.

[is it a graph or a tree?]
notice that the cfg groups are stored as a simple list with no relationships.  its
the urls that are indexed with their relations.

so the urls build a tree, however do to the links from url to cfg group, it kind
of builds a graph also.   2 urls can be in the same cfg group.  1 url's child
can be in the same cfg group as the original url's parent.

when you focus on the actual url tree, it becomes less confusing.  it really is a
tree.  there can even be duplicates in the inheritence model, but the tree cleans
everything.

example of duplicates:

cgroup A = a/b + a/b/c/d
cgroup B = a/b/c

this walking the lineage branch for a/b/c/d you get A, then B, and A again.  nodes
lower in the tree override parent values, so in this case A's values override B's .

[recursion]



[a sample tree]

server runs sites msw and has EVERY directory mapped to a cfg groups (really obscene)

<coming later>



[memory assumptions with the url tree]

[Paged]
    a node per token in the url.  2 types.  dummy nodes + leaf nodes.

    (note: when 2 sizes are given, the second size is the sundown size)

    dummy node = 4/6 longs
    leaf node  = 8/14 longs
    + each node holds 2 * TokenLength+1 for the token.
    + each cluster of siblings holds 2 longs + 1/2 longs per node in the cluster.

[NonPaged]

    2 longs per config group


[assume]
    sites
        max 100k
        average <10
        assume 32 char hostname

    max apps per site
        in the max case : 2 (main + admin)
        in the avg case : 10
        max apps        : 1000s (in 1 site)
        assume 32 char app name

(assume just hostheader access for now)

[max]

    hostname strings = 100000*((32+1)*2)   =  6.6 MB
    cluster entries  = 100000*8*4          =  3.2 MB
    cluster header   = 1*(2+(1*100000))*4  =   .4 MB
    total                                  = 10.2 MB

    per site:
    app strings      = 2*((32+1)*2)        =  132 B
    cluster entries  = 2*8*4               =   64 B
    cluster header   = 1*(2+(1*2))*4       =   16 B
                     = 132 + 64 + 16       =  212 B
    total            = 100000*(212)        = 21.2 MB

    Paged Total      = 10.2mb + 21.2mb     = 31.4 MB
    NonPaged Total   = 200k*2*4            =  1.6 MB

[avg]

    hostname strings = 10*((32+1)*2)       =  660 B
    cluster entries  = 10*8*4              =  320 B
    cluster header   = 1*(2+(1*10))*4      =   48 B
    total                                  = 1028 B

    per site:
    app strings      = 10*((32+1)*2)       =  660 B
    cluster entries  = 10*8*4              =  320 B
    cluster header   = 1*(2+(1*10))*4      =   48 B
    total            = 10*(1028)           = 10.2 KB

    Paged Total      = 1028b + 10.2lKB     = 11.3 KB
    NonPaged Total   = 110*2*4             =  880 B

note: can we save space by refcounting strings.  if all of these
100k have apps with the same name, we save massive string space.
~13MB .

[efficiency of the tree]

    [lookup]

    [insert]

    [delete]

    [data locality]

[alterates investigated to the tree]

hashing - was pretty much scrapped due to the longest prefix match issue.
basically to hash, we would have to compute a hash for each level in
the url, to see if there is a match.  then we have the complete list
of matches.  assuming an additive hash, the hash expense could be
minimized, but the lookup still requires cycles.


alpha trie  - was expense for memory.  however the tree we have though
is very very similar to a trie.  each level of the tree is a token,
however, not a letter.


[building the url info]

the url info is actually built walking down the tree.  for each match
node, we set the info.  this allows for the top-down inheritence.
we also snapshot the timestamp offsets for each matching node in the
tree as we dive down it (see caching) .

this dynamic building of an urls' match was chosen over precomputing
every possible config through the inheritence tree.  each leaf node
could have stored a cooked version of this, but it would have made
updates a bear.  it's not that expensive to build it while we walk down
as we already visit each node in our lineage branch.

autoresponses are never copied, but refcounted.

[locking]

2 locks are used in the module.  a spinlock to protect the global
timestamp array, and a resource to protect both the cgroup objects
and the url tree (which links to the cgroup objects) .

the spinlock is sometimes acquired while the resource is locked,
but never vice-versa.  also, while the spinlock is held, very
little is done, and definetly no other locks are contended.

1 issue here is granularity of contention.  currently the entire
tree + object list is protected with 1 resource, which is reader
writer.  if this is a perf issue, we can look into locking single
lineage branches (sites) .


[legal]
> 1 cfg groups in an app pool
children cfg groups with no app pool (they inherit)
children cfg groups with no auto-response (they inherit)
children cfg groups with no max bandwitdth (they inherit)
children cfg groups with no max connections (they inherit)
* for a host name
fully qualified url of for http[s]://[host|*]:post/[abs_path]/
must have trailing slash if not pting to a file
only 1 cfg group for the site AND the root url.  e.g. http://foo.com:80/
allow you to set config on http:// and https:// for "root" config info

[not legal]
an url in > 1 cfg group
> 1 app pools for 1 cfg group
> 1 root cfg group
* embedded anywhere in the url other than replacing a hostname
query strings in url's.
url's not ending in slash.




--***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\controlp.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    controlp.h

Abstract:

    This module contains private declarations for the UL control channel.

Author:

    Keith Moore (keithmo)       09-Feb-1999

Revision History:

--*/


#ifndef _CONTROLP_H_
#define _CONTROLP_H_

#ifdef __cplusplus
extern "C" {
#endif


VOID
UlpSetFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel,
    IN BOOLEAN FilterOnlySsl
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _CONTROLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\close.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    close.cxx

Abstract:

    This module contains code for cleanup and close IRPs.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlClose )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlCleanup
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the routine that handles Cleanup IRPs in UL. Cleanup IRPs
    are issued after the last handle to the file object is closed.

Arguments:

    pDeviceObject - Supplies a pointer to the target device object.

    pIrp - Supplies a pointer to IO request packet.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCleanup(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{

    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;

    UL_ENTER_DRIVER( "UlCleanup", pIrp );

    //
    // Snag the current IRP stack pointer.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    IF_DEBUG( OPEN_CLOSE )
    {
        KdPrint((
            "UlCleanup: cleanup on file object %lx\n",
            pIrpSp->FileObject
            ));
    }

    //
    // app pool or control channel?
    //

    if (pDeviceObject == g_pUlAppPoolDeviceObject &&
        IS_APP_POOL( pIrpSp->FileObject ))
    {
        //
        // app pool, let's detach this process from the app pool
        //

        status = UlDetachProcessFromAppPool(
                        GET_APP_POOL_PROCESS(pIrpSp->FileObject)
                        );

        MARK_INVALID_APP_POOL( pIrpSp->FileObject );
    }
    else if (pDeviceObject == g_pUlFilterDeviceObject &&
             IS_FILTER_PROCESS( pIrpSp->FileObject ))
    {
        //
        // filter channel
        //

        status = UlDetachFilterProcess(
                        GET_FILTER_PROCESS(pIrpSp->FileObject)
                        );

        MARK_INVALID_FILTER_CHANNEL( pIrpSp->FileObject );
    }
    else if (IS_CONTROL_CHANNEL( pIrpSp->FileObject ))
    {
        status = UlCloseControlChannel(
                        GET_CONTROL_CHANNEL(pIrpSp->FileObject)
                        );

        MARK_INVALID_CONTROL_CHANNEL( pIrpSp->FileObject );
    }
    else
    {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Status = status;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

    UL_LEAVE_DRIVER( "UlCleanup" );
    RETURN(status);

}   // UlCleanup


/***************************************************************************++

Routine Description:

    This is the routine that handles Close IRPs in UL. Close IRPs are
    issued after the last reference to the file object is removed.

Arguments:

    pDeviceObject - Supplies a pointer to the target device object.

    pIrp - Supplies a pointer to IO request packet.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{

    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;

    UNREFERENCED_PARAMETER( pDeviceObject );

    //
    // Sanity check.
    //

    PAGED_CODE();
    UL_ENTER_DRIVER( "UlClose", pIrp );

    status = STATUS_SUCCESS;

    //
    // Snag the current IRP stack pointer.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    //
    // If it's an App Pool or filter channel we have to delete
    // the associated object.
    //
    if (pDeviceObject == g_pUlAppPoolDeviceObject &&
        IS_EX_APP_POOL( pIrpSp->FileObject ))
    {
        UlFreeAppPoolProcess(GET_APP_POOL_PROCESS(pIrpSp->FileObject));
    }
    else if (pDeviceObject == g_pUlFilterDeviceObject &&
             IS_EX_FILTER_PROCESS( pIrpSp->FileObject ))
    {
        UlFreeFilterProcess(GET_FILTER_PROCESS(pIrpSp->FileObject));
    }

    IF_DEBUG( OPEN_CLOSE )
    {
        KdPrint((
            "UlClose: closing file object %lx\n",
            pIrpSp->FileObject
            ));
    }

    pIrp->IoStatus.Status = status;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

    UL_LEAVE_DRIVER( "UlClose" );
    RETURN(status);

}   // UlClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\control.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    control.cxx

Abstract:

    This module implements the UL control channel.

Author:

    Keith Moore (keithmo)       09-Feb-1999

Revision History:

--*/


#include "precomp.h"
#include "controlp.h"


//
// Private constants.
//

#define FAKE_CONTROL_CHANNEL    ((PUL_CONTROL_CHANNEL)1)


//
// Private globals.
//

PUL_FILTER_CHANNEL  g_pFilterChannel = NULL;
BOOLEAN             g_FilterOnlySsl = FALSE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeControlChannel )
#pragma alloc_text( PAGE, UlTerminateControlChannel )
#pragma alloc_text( PAGE, UlOpenControlChannel )
#pragma alloc_text( PAGE, UlCloseControlChannel )
#pragma alloc_text( PAGE, UlQueryFilterChannel )

#pragma alloc_text( PAGE, UlpSetFilterChannel )

#endif  // ALLOC_PRAGMA
#if 0
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeControlChannel(
    VOID
    )
{
    return STATUS_SUCCESS;

}   // UlInitializeControlChannel


/***************************************************************************++

Routine Description:

    Performs global termination of this module.

--***************************************************************************/
VOID
UlTerminateControlChannel(
    VOID
    )
{

}   // UlTerminateControlChannel


/***************************************************************************++

Routine Description:

    Opens a control channel.

Arguments:

    pControlChannel - Receives a pointer to the newly created control
        channel if successful.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlOpenControlChannel(
    OUT PUL_CONTROL_CHANNEL *ppControlChannel
    )
{
    PUL_CONTROL_CHANNEL pControlChannel;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pControlChannel = UL_ALLOCATE_STRUCT(
                            PagedPool,
                            UL_CONTROL_CHANNEL,
                            UL_CONTROL_CHANNEL_POOL_TAG
                            );

    if (pControlChannel == NULL)
        return STATUS_NO_MEMORY;

    RtlZeroMemory(pControlChannel, sizeof(*pControlChannel));

    pControlChannel->Signature = UL_CONTROL_CHANNEL_POOL_TAG;

    pControlChannel->State = HttpEnabledStateInactive;

    UlInitializeNotifyHead(
        &pControlChannel->ConfigGroupHead,
        &g_pUlNonpagedData->ConfigGroupResource
        );

    // No Qos limit as default
    pControlChannel->MaxBandwidth   = HTTP_LIMIT_INFINITE;
    pControlChannel->MaxConnections = HTTP_LIMIT_INFINITE;


    *ppControlChannel = pControlChannel;

    return STATUS_SUCCESS;

}   // UlOpenControlChannel


/***************************************************************************++

Routine Description:

    Closes a control channel.

Arguments:

    pControlChannel - Supplies the control channel to close.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCloseControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    // a good pointer?
    //
    if (pControlChannel != NULL)
    {
        PLIST_ENTRY pEntry;

        // check the signature
        //
        if (pControlChannel->Signature != UL_CONTROL_CHANNEL_POOL_TAG)
            return RPC_NT_INVALID_TAG;

        // Free all the orphaned config groups
        //
        UlNotifyAllEntries(
            &UlNotifyOrphanedConfigGroup,
            &pControlChannel->ConfigGroupHead,
            NULL
            );

        //
        // release the auto-response
        //

        if (pControlChannel->pAutoResponse != NULL)
        {
            UL_DEREFERENCE_INTERNAL_RESPONSE(pControlChannel->pAutoResponse);
            pControlChannel->pAutoResponse = NULL;
        }

        //
        // release the filter channel
        //
        UlpSetFilterChannel(NULL, FALSE);

        //
        // remove QoS flows if they exist
        //
        if (pControlChannel->MaxBandwidth != HTTP_LIMIT_INFINITE)
        {
            UlTcRemoveGlobalFlows();
        }

        // free the memory
        //
        UL_FREE_POOL(pControlChannel, UL_CONTROL_CHANNEL_POOL_TAG);
    }

    return STATUS_SUCCESS;

}   // UlCloseControlChannel



/***************************************************************************++

Routine Description:

    Sets control channel information.

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetControlChannelInformation(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length
    )
{
    NTSTATUS Status;
    HTTP_BANDWIDTH_LIMIT NewMaxBandwidth;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

    //
    // no buffer?
    //

    if (pControlChannelInformation == NULL)
        return STATUS_INVALID_PARAMETER;

    CG_LOCK_WRITE();

    //
    // What are we being asked to do?
    //

    switch (InformationClass)
    {
    case HttpControlChannelStateInformation:

        if (Length < sizeof(HTTP_ENABLED_STATE))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto end;
        }

        pControlChannel->State = *((PHTTP_ENABLED_STATE)pControlChannelInformation);

        //
        // flush the URI cache.
        // CODEWORK: if we were smarter we might not need to flush
        //
        UlFlushCache();

        break;

    case HttpControlChannelAutoResponseInformation:
    {
        PHTTP_AUTO_RESPONSE pAutoResponse;

        pAutoResponse = (PHTTP_AUTO_RESPONSE)pControlChannelInformation;

        //
        //  double check the buffer is big enough
        //

        if (Length < sizeof(HTTP_AUTO_RESPONSE))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto end;
        }

        //
        // Is there an auto-response?
        //

        // BUGBUG: temp optional
//        if (pAutoResponse->Flags.Present == 1 && pAutoResponse->pResponse != NULL)
        if (pAutoResponse->Flags.Present == 1)
        {
            HTTP_VERSION HttpVersion11 = {1,1};

            //
            // Are we replacing one already there?
            //

            if (pControlChannel->pAutoResponse != NULL)
            {
                UL_DEREFERENCE_INTERNAL_RESPONSE(pControlChannel->pAutoResponse);
                pControlChannel->pAutoResponse = NULL;
            }

            //
            // Convert it to kernel mode
            //

            Status = UlCaptureHttpResponse(
                            pAutoResponse->pResponse,
                            NULL,
                            HttpVersion11,
                            HttpVerbUnknown,
                            pAutoResponse->EntityChunkCount,
                            pAutoResponse->pEntityChunks,
                            UlCaptureCopyData,
                            FALSE,
                            NULL,
                            &(pControlChannel->pAutoResponse)
                            );

            if (NT_SUCCESS(Status) == FALSE)
            {
                pControlChannel->pAutoResponse = NULL;
                goto end;
            }

            Status = UlPrepareHttpResponse(
                            HttpVersion11,
                            pAutoResponse->pResponse,
                            pControlChannel->pAutoResponse
                            );

            if (NT_SUCCESS(Status) == FALSE)
            {
                UL_DEREFERENCE_INTERNAL_RESPONSE(pControlChannel->pAutoResponse);
                pControlChannel->pAutoResponse = NULL;
                goto end;
            }

        }
        else
        {
            //
            // Remove ours?
            //

            if (pControlChannel->pAutoResponse != NULL)
            {
                UL_DEREFERENCE_INTERNAL_RESPONSE(pControlChannel->pAutoResponse);
            }
            pControlChannel->pAutoResponse = NULL;
        }

    }
        break;

    case HttpControlChannelFilterInformation:
    {
        PHTTP_CONTROL_CHANNEL_FILTER pFiltInfo;
        PUL_FILTER_CHANNEL pFilterChannel = NULL;

        //
        // Check the parameters.
        //
        if (Length < sizeof(HTTP_CONTROL_CHANNEL_FILTER))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto end;
        }

        pFiltInfo = (PHTTP_CONTROL_CHANNEL_FILTER) pControlChannelInformation;

        //
        // Record the new information.
        //
        if (pFiltInfo->Flags.Present)
        {
            Status = UlGetFilterFromHandle(
                            pFiltInfo->FilterHandle,
                            &pFilterChannel
                            );

            if (NT_SUCCESS(Status))
            {
                UlpSetFilterChannel(pFilterChannel, pFiltInfo->FilterOnlySsl);
            }
            else
            {
                goto end;
            }
        }
        else
        {
            UlpSetFilterChannel(NULL, FALSE);
        }
    }
        break;


    case HttpControlChannelBandwidthInformation:
    {
        //
        // Sanity Check first
        //
        if (Length < sizeof(HTTP_BANDWIDTH_LIMIT))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto end;
        }

        NewMaxBandwidth = *((PHTTP_BANDWIDTH_LIMIT) pControlChannelInformation);

        //
        // Interpret the ZERO as HTTP_LIMIT_INFINITE
        //
        if (NewMaxBandwidth == 0)
        {
            NewMaxBandwidth = HTTP_LIMIT_INFINITE;
        }

        //
        // But check to see if PSched is installed or not before proceeding.
        // By returning an error here, WAS will raise an event warning but
        // proceed w/o terminating the web server
        //
        if (!UlTcPSchedInstalled())
        {
            Status = STATUS_SUCCESS;
            goto end;
#if 0
            // Enable when WAS start expecting this error

            if (NewMaxBandwidth != HTTP_LIMIT_INFINITE)
            {
                // There's a BWT limit coming down but PSched is not installed

                Status = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }
            else
            {
                // By default Config Store has HTTP_LIMIT_INFINITE. Therefore
                // return success for non-actions to prevent unnecessary event
                // warnings.

                Status = STATUS_SUCCESS;
                goto end;
            }
#endif
        }

        //
        // Take a look at the similar "set cgroup ioctl" for detailed comments
        //
        if (pControlChannel->MaxBandwidth != HTTP_LIMIT_INFINITE)
        {
            // To see if there is a real change
            if (NewMaxBandwidth != pControlChannel->MaxBandwidth)
            {
                if (NewMaxBandwidth != HTTP_LIMIT_INFINITE)
                {
                    // This will modify global flows on all interfaces
                    Status = UlTcModifyGlobalFlows(NewMaxBandwidth);
                    if (!NT_SUCCESS(Status))
                        goto end;
                }
                else
                {
                    // Handle BTW disabling by removing the global flows
                    Status = UlTcRemoveGlobalFlows();
                    if (!NT_SUCCESS(Status))
                        goto end;
                }

                // Don't forget to update the control channel if it was a success
                pControlChannel->MaxBandwidth = NewMaxBandwidth;
            }
        }
        else
        {
            // Create global flows on all interfaces
            if (NewMaxBandwidth != HTTP_LIMIT_INFINITE)
            {
                Status = UlTcAddGlobalFlows(NewMaxBandwidth);
                if (!NT_SUCCESS(Status))
                    goto end;

                // Success! Remember the global bandwidth limit in control channel
                pControlChannel->MaxBandwidth = NewMaxBandwidth;
            }

            //
            // When UlCloseControlChannel is called, the global flows on all  interfaces
            // are also going  to be removed.  Alternatively flows might be  removed  by
            // explicitly setting the bandwidth throttling limit to infinite or reseting
            // the flags.present.  The latter cases  are handled by the  reconfiguration
            // function UlTcModifyGlobalFlows.
            //
        }
    }
        break;

    case HttpControlChannelConnectionInformation:
    {
        if (Length < sizeof(HTTP_CONNECTION_LIMIT))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            pControlChannel->MaxConnections =
                *((PHTTP_CONNECTION_LIMIT)pControlChannelInformation);

            UlSetGlobalConnectionLimit( (ULONG) pControlChannel->MaxConnections );
        }
    }
        break;

    case HttpControlChannelTimeoutInformation:
    {
        if ( Length < sizeof(HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT) )
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            UlSetTimeoutMonitorInformation(
                (PHTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT) pControlChannelInformation
                );
        }
    }
        break;

    case HttpControlChannelUTF8Logging:
    {
        if ( Length < sizeof(HTTP_CONTROL_CHANNEL_UTF8_LOGGING) )
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            pControlChannel->UTF8Logging =
                *((PHTTP_CONTROL_CHANNEL_UTF8_LOGGING)pControlChannelInformation);

            UlSetUTF8Logging( pControlChannel->UTF8Logging );
        }
    }
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }


    Status = STATUS_SUCCESS;

end:

    CG_UNLOCK_WRITE();
    return Status;

}   // UlSetControlChannelInformation

/***************************************************************************++

Routine Description:

    Gets control channel information. For each element of the control channel
    if the supplied buffer is NULL, then we return the required length in the
    optional length field.

Arguments:

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetControlChannelInformation(
    IN  PUL_CONTROL_CHANNEL pControlChannel,
    IN  HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN  PVOID   pControlChannelInformation,
    IN  ULONG   Length,
    OUT PULONG  pReturnLength OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

    CG_LOCK_READ();

    //
    // What are we being asked to do?
    //

    switch (InformationClass)
    {
    case HttpControlChannelStateInformation:
    {
        if (pControlChannelInformation==NULL)
        {
            //
            // Return the necessary size
            //
            *pReturnLength = sizeof(HTTP_ENABLED_STATE);
        }
        else
        {
            if (Length < sizeof(HTTP_ENABLED_STATE))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                goto end;
            }
            *((PHTTP_ENABLED_STATE)pControlChannelInformation) = pControlChannel->State;
            *pReturnLength = sizeof(HTTP_ENABLED_STATE);
        }
    }
    break;

    case HttpControlChannelBandwidthInformation:
    {
        if (pControlChannelInformation == NULL)
        {
            *pReturnLength = sizeof(HTTP_BANDWIDTH_LIMIT);
        }
        else
        {
            if (Length < sizeof(HTTP_BANDWIDTH_LIMIT))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                goto end;
            }

            *((PHTTP_BANDWIDTH_LIMIT)pControlChannelInformation) =
                pControlChannel->MaxBandwidth;

            *pReturnLength = sizeof(HTTP_BANDWIDTH_LIMIT);
        }
    }
    break;

    case HttpControlChannelConnectionInformation:
    {
        if (pControlChannelInformation == NULL)
        {
            *pReturnLength = sizeof(HTTP_CONNECTION_LIMIT);
        }
        else
        {
            if (Length < sizeof(HTTP_CONNECTION_LIMIT))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                goto end;
            }

            *((PHTTP_CONNECTION_LIMIT)pControlChannelInformation) =
                pControlChannel->MaxConnections;

            *pReturnLength = sizeof(HTTP_CONNECTION_LIMIT);
        }
    }
    break;

    case HttpControlChannelAutoResponseInformation: // Cannot be querried ...
    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    Status = STATUS_SUCCESS;
end:
    CG_UNLOCK_READ();
    return Status;

}   // UlGetControlChannelInformation

/***************************************************************************++

Routine Description:

    Queries the filter channel information. Gives the caller a reference
    if the channel exists and the caller is supposed to be filtered.
    Secure (SSL) connections are always filtered. If g_FilterOnlySsl is
    FALSE then everything gets filtered.

Arguments:

    SecureConnection - tells us if the caller is on a secure endpoint.

Return values:

    A reference to the filter channel if the connection is filtered.
    NULL if it is not.

--***************************************************************************/
PUL_FILTER_CHANNEL
UlQueryFilterChannel(
    IN BOOLEAN SecureConnection
    )
{
    PUL_FILTER_CHANNEL pChannel;

    //
    // Sanity check.
    //
    PAGED_CODE();

    CG_LOCK_READ();

    if (g_pFilterChannel && (SecureConnection || !g_FilterOnlySsl))
    {
        REFERENCE_FILTER_CHANNEL(g_pFilterChannel);
        pChannel = g_pFilterChannel;
    }
    else
    {
        pChannel = NULL;
    }

    CG_UNLOCK_READ();

    UlTrace(FILTER, (
        "ul!UlQueryFilterChannel(secure = %s) returning %p\n",
        SecureConnection ? "TRUE" : "FALSE",
        pChannel
        ));

    return pChannel;
}

/***************************************************************************++

Routine Description:

    Checks to see if the callers filter channel matches the filter
    channel that would be returned by UlQueryFilterChannel.

    Note, this function intentionally does not acquire the config
    group read lock, because it doesn't really matter if we get
    a consistent view of the channel settings.

Arguments:

    pChannel - the callers current filter channel setting

    SecureConnection - tells us if the caller is on a secure endpoint.

Return values:

    Returns TRUE if the filter channel settings are up to date.

--***************************************************************************/
BOOLEAN
UlValidateFilterChannel(
    IN PUL_FILTER_CHANNEL pChannel,
    IN BOOLEAN SecureConnection
    )
{
    BOOLEAN UpToDate;

    //
    // Sanity check.
    //
    ASSERT(!pChannel || IS_VALID_FILTER_CHANNEL(pChannel));

    if (g_pFilterChannel && (SecureConnection || !g_FilterOnlySsl))
    {
        //
        // The connection should be filtered, so its channel
        // should match g_pFilterChannel.
        //
        
        UpToDate = (pChannel == g_pFilterChannel);
    }
    else
    {
        //
        // The connection is not filtered, so its channel
        // should be NULL.
        //
        
        UpToDate = (pChannel == NULL);
    }

    return UpToDate;
}


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Saves the global filter channel object, which is attached to new
    endpoints as they are created.

    The global data is protected by the config group lock, which we
    assume is held by the caller.

Arguments:

    pFilterChannel - the filter channel object
    FilterOnlySsl - filter only ssl data, or all data

--***************************************************************************/
VOID
UlpSetFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel,
    IN BOOLEAN FilterOnlySsl
    )
{
    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Dump the old channel if there was one.
    //
    if (g_pFilterChannel)
    {
        DEREFERENCE_FILTER_CHANNEL(g_pFilterChannel);
    }

    //
    // Save the new values.
    //
    g_pFilterChannel = pFilterChannel;
    g_FilterOnlySsl = FilterOnlySsl;

} // UlSetFilterChannel
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\config.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    config.h

Abstract:

    This module contains global configuration constants.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _CONFIG_H_
#define _CONFIG_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Set ALLOW_UNLOAD to a non-zero value to enable driver unloading.
//
// Set REFERENCE_DEBUG to a non-zero value to enable ref trace logging.
//
// Set ENABLE_OWNER_REF_TRACE to a non-zero value to enable
// owner reference tracing
//
// Set USE_FREE_POOL_WITH_TAG to a non-zero value to enable use of
// the new-for-NT5 ExFreePoolWithTag() API.
//
// Set ENABLE_IRP_TRACE to a non-zero value to enable IRP tracing.
//
// Set ENABLE_TIME_TRACE to a non-zero value to enable time tracing.
//
// Set ENABLE_REPL_TRACE to a non-zero value to enable replenish tracing.
//
// Set ENABLE_FILTQ_TRACE to a non-zero value to enable filter queue tracing.
//

#if DBG
#define ALLOW_UNLOAD            1
#define REFERENCE_DEBUG         1
#define ENABLE_OWNER_REF_TRACE  1
#define ENABLE_IRP_TRACE        0
#define ENABLE_TIME_TRACE       0
#define ENABLE_REPL_TRACE       0
#define ENABLE_FILTQ_TRACE      1
#else   // !DBG
#define ALLOW_UNLOAD            1
#define REFERENCE_DEBUG         0
#define ENABLE_OWNER_REF_TRACE  0
#define ENABLE_IRP_TRACE        0
#define ENABLE_TIME_TRACE       0
#define ENABLE_REPL_TRACE       0
#define ENABLE_FILTQ_TRACE      0
#endif  // DBG

#define USE_FREE_POOL_WITH_TAG  0


//
// ENABLE_*_TRACE flags require REFERENCE_DEBUG to get the logging
// stuff. Enforce this here.
//

#if (ENABLE_TIME_TRACE || ENABLE_IRP_TRACE || ENABLE_REPL_TRACE || ENABLE_FILTQ_TRACE || ENABLE_OWNER_REF_TRACE) && !REFERENCE_DEBUG
#undef REFERENCE_DEBUG
#define REFERENCE_DEBUG 1
#endif


//
// Define the additional formal and actual parameters used for the
// various Reference/Dereference functions when reference debugging
// is enabled.
//

#if REFERENCE_DEBUG
#define REFERENCE_DEBUG_FORMAL_PARAMS ,PSTR pFileName,USHORT LineNumber
#define REFERENCE_DEBUG_ACTUAL_PARAMS ,(PSTR)__FILE__,(USHORT)__LINE__
#else   // !REFERENCE_DEBUG
#define REFERENCE_DEBUG_FORMAL_PARAMS
#define REFERENCE_DEBUG_ACTUAL_PARAMS
#endif  // REFERENCE_DEBUG


//
// Make a free structure signature from a valid signature.
//

#define MAKE_FREE_SIGNATURE(sig)    ( (((ULONG)(sig)) << 8) | 'x' )


//
// Pool tags.
//

#if USE_FREE_POOL_WITH_TAG
#define MAKE_TAG(tag)   ( (ULONG)(tag) | PROTECTED_POOL )
#define MyFreePoolWithTag(a,t) ExFreePoolWithTag(a,t)
#else   // !USE_FREE_POOL_WITH_TAG
#define MAKE_TAG(tag)   ( (ULONG)(tag) )
#define MyFreePoolWithTag(a,t) ExFreePool(a)
#endif  // USE_FREE_POOL_WITH_TAG

#define MAKE_FREE_TAG(Tag)  (((Tag) & 0xffffff00) | (ULONG)'x')
#define IS_VALID_TAG(Tag)   (((Tag) & 0x0000ffff) == 'lU' )


//
// NOTE: Keep these reverse sorted by tag so it's easy to see dup's
//
// If you add, change, or remove a tag, please make the corresponding
// change to .\pooltag.txt
//

#define UL_AUXILIARY_BUFFER_POOL_TAG        MAKE_TAG( 'BAlU' )
#define UL_APP_POOL_OBJECT_POOL_TAG         MAKE_TAG( 'OAlU' )
#define UL_APP_POOL_PROCESS_POOL_TAG        MAKE_TAG( 'PAlU' )
#define UL_APP_POOL_RESOURCE_TAG            MAKE_TAG( 'RAlU' )

#define UL_BUFFER_IO_POOL_TAG               MAKE_TAG( 'OBlU' )

#define UL_CONTROL_CHANNEL_POOL_TAG         MAKE_TAG( 'CClU' )
#define UL_CG_TREE_ENTRY_POOL_TAG           MAKE_TAG( 'EClU' )
#define UL_CG_TREE_HEADER_POOL_TAG          MAKE_TAG( 'HClU' )
#define UL_CG_URL_INFO_POOL_TAG             MAKE_TAG( 'IClU' )
#define UL_CG_OBJECT_POOL_TAG               MAKE_TAG( 'JClU' )
#define UL_CHUNK_TRACKER_POOL_TAG           MAKE_TAG( 'KClU' )
#define UL_CG_LOGDIR_POOL_TAG               MAKE_TAG( 'LClU' )
#define UL_CONNECTION_POOL_TAG              MAKE_TAG( 'OClU' )
#define UL_CG_RESOURCE_TAG                  MAKE_TAG( 'qClU' )
#define UL_CG_TIMESTAMP_POOL_TAG            MAKE_TAG( 'TClU' )
#define UL_CONNECTION_COUNT_ENTRY_POOL_TAG  MAKE_TAG( 'YClU' )

#define UL_DEBUG_POOL_TAG                   MAKE_TAG( 'BDlU' )
#define UL_DATE_HEADER_RESOURCE_TAG         MAKE_TAG( 'HDlU' )
#define UL_DISCONNECT_OBJECT_POOL_TAG       MAKE_TAG( 'ODlU' )
#define UL_DISCONNECT_RESOURCE_TAG          MAKE_TAG( 'qDlU' )
#define UL_DEFERRED_REMOVE_ITEM_POOL_TAG    MAKE_TAG( 'RDlU' )
#define UL_DEBUG_THREAD_POOL_TAG            MAKE_TAG( 'TDlU' )

#define UL_ENDPOINT_POOL_TAG                MAKE_TAG( 'PElU' )

#define UL_FILE_CACHE_ENTRY_POOL_TAG        MAKE_TAG( 'CFlU' )
#define URI_FILTER_CONTEXT_POOL_TAG         MAKE_TAG( 'cflU' )
#define UL_NONCACHED_FILE_DATA_POOL_TAG     MAKE_TAG( 'DFlU' )
#define UL_FILTER_PROCESS_POOL_TAG          MAKE_TAG( 'PFlU' )
#define UL_FILTER_CHANNEL_POOL_TAG          MAKE_TAG( 'TFlU' )
#define UL_FULL_TRACKER_POOL_TAG            MAKE_TAG( 'UFlU' )
#define UX_FILTER_WRITE_TRACKER_POOL_TAG    MAKE_TAG( 'WFlU' )

#define UL_HTTP_CONNECTION_POOL_TAG         MAKE_TAG( 'CHlU' )
#define UL_HTTP_CONNECTION_RESOURCE_TAG     MAKE_TAG( 'qHlU' )
#define UL_INTERNAL_REQUEST_POOL_TAG        MAKE_TAG( 'RHlU' )
#define UL_HASH_TABLE_POOL_TAG              MAKE_TAG( 'THlU' )
#define HEADER_VALUE_POOL_TAG               MAKE_TAG( 'VHlU' )

#define UL_IRP_CONTEXT_POOL_TAG             MAKE_TAG( 'CIlU' )
#define UL_CONN_ID_TABLE_POOL_TAG           MAKE_TAG( 'DIlU' )
#define UL_INTERNAL_RESPONSE_POOL_TAG       MAKE_TAG( 'RIlU' )

#define UL_LARGE_ALLOC_TAG                  MAKE_TAG( 'ALlU' )
#define UL_LOG_DATA_BUFFER_POOL_TAG         MAKE_TAG( 'BLlU' )
#define UL_LOG_FIELD_POOL_TAG               MAKE_TAG( 'DLlU' )
#define UL_LOG_FILE_ENTRY_POOL_TAG          MAKE_TAG( 'FLlU' )
#define UL_LOG_GENERIC_POOL_TAG             MAKE_TAG( 'GLlU' )
#define UL_LOG_FILE_BUFFER_POOL_TAG         MAKE_TAG( 'LLlU' )
#define UL_LOG_LIST_RESOURCE_TAG            MAKE_TAG( 'RLlU' )

#define UL_NONPAGED_DATA_POOL_TAG           MAKE_TAG( 'PNlU' )
#define UL_NSGO_POOL_TAG                    MAKE_TAG( 'ONlU' )

#define UL_OWNER_REF_POOL_TAG               MAKE_TAG( 'ROlU' )
#define UL_OPAQUE_ID_TABLE_POOL_TAG         MAKE_TAG( 'TOlU' )

#define UL_APOOL_PROC_BINDING_POOL_TAG      MAKE_TAG( 'BPlU' )
#define UL_PIPELINE_POOL_TAG                MAKE_TAG( 'LPlU' )

#define UL_TCI_FILTER_POOL_TAG              MAKE_TAG( 'FQlU' )
#define UL_TCI_GENERIC_POOL_TAG             MAKE_TAG( 'GQlU' )
#define UL_TCI_INTERFACE_POOL_TAG           MAKE_TAG( 'IQlU' )
#define UL_TCI_FLOW_POOL_TAG                MAKE_TAG( 'LQlU' )
#define UL_TCI_RESOURCE_TAG                 MAKE_TAG( 'RQlU' )
#define UL_TCI_TRACKER_POOL_TAG             MAKE_TAG( 'TQlU' )
#define UL_TCI_WMI_POOL_TAG                 MAKE_TAG( 'WQlU' )

#define UL_RCV_BUFFER_POOL_TAG              MAKE_TAG( 'BRlU' )
#define UL_REGISTRY_DATA_POOL_TAG           MAKE_TAG( 'DRlU' )
#define UL_REQUEST_BODY_BUFFER_POOL_TAG     MAKE_TAG( 'ERlU' )
#define UL_REQUEST_BUFFER_POOL_TAG          MAKE_TAG( 'PRlU' )
#define UL_REF_REQUEST_BUFFER_POOL_TAG      MAKE_TAG( 'RRlU' )
#define UL_NONPAGED_RESOURCE_POOL_TAG       MAKE_TAG( 'SRlU' )
#define UL_REF_OWNER_TRACELOG_POOL_TAG      MAKE_TAG( 'TRlU' )

#define UL_SIMPLE_STATUS_ITEM_TAG           MAKE_TAG( 'SSlU' )

#define UL_SSL_CERT_DATA_POOL_TAG           MAKE_TAG( 'CSlU' )
#define UL_SECURITY_DATA_POOL_TAG           MAKE_TAG( 'DSlU' )
#define UL_SITE_COUNTER_ENTRY_POOL_TAG      MAKE_TAG( 'OSlU' )

#define UL_ADDRESS_POOL_TAG                 MAKE_TAG( 'ATlU' )
#define UL_THREAD_TRACKER_POOL_TAG          MAKE_TAG( 'TTlU' )

#define UL_URI_CACHE_ENTRY_POOL_TAG         MAKE_TAG( 'CUlU' )
#define UL_HTTP_UNKNOWN_HEADER_POOL_TAG     MAKE_TAG( 'HUlU' )
#define URL_POOL_TAG                        MAKE_TAG( 'LUlU' )
#define UL_URLMAP_POOL_TAG                  MAKE_TAG( 'MUlU' )

#define UL_VIRTHOST_POOL_TAG                MAKE_TAG( 'HVlU' )

#define UL_WORK_CONTEXT_POOL_TAG            MAKE_TAG( 'CWlU' )
#define UL_WORK_ITEM_POOL_TAG               MAKE_TAG( 'IWlU' )
#define UL_ZOMBIE_RESOURCE_TAG              MAKE_TAG( 'RZlU' )

//
// Registry paths.
// If you change or add a setting, please update the ConfigTable
// in ul\util\tul.c.
//

#define REGISTRY_PARAMETERS                     L"Parameters"
#define REGISTRY_UL_INFORMATION                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Http"
#define REGISTRY_IIS_INFORMATION                L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Inetinfo"

#define REGISTRY_IRP_STACK_SIZE                 L"IrpStackSize"
#define REGISTRY_PRIORITY_BOOST                 L"PriorityBoost"
#define REGISTRY_DEBUG_FLAGS                    L"DebugFlags"
#define REGISTRY_BREAK_ON_STARTUP               L"BreakOnStartup"
#define REGISTRY_BREAK_ON_ERROR                 L"BreakOnError"
#define REGISTRY_VERBOSE_ERRORS                 L"VerboseErrors"
#define REGISTRY_ENABLE_UNLOAD                  L"EnableUnload"
#define REGISTRY_ENABLE_SECURITY                L"EnableSecurity"
#define REGISTRY_MIN_IDLE_CONNECTIONS           L"MinIdleConnections"
#define REGISTRY_MAX_IDLE_CONNECTIONS           L"MaxIdleConnections"
#define REGISTRY_IRP_CONTEXT_LOOKASIDE_DEPTH    L"IrpContextLookasideDepth"
#define REGISTRY_RCV_BUFFER_SIZE                L"ReceiveBufferSize"
#define REGISTRY_RCV_BUFFER_LOOKASIDE_DEPTH     L"ReceiveBufferLookasideDepth"
#define REGISTRY_RESOURCE_LOOKASIDE_DEPTH       L"ResourceLookasideDepth"
#define REGISTRY_REQ_BUFFER_LOOKASIDE_DEPTH     L"RequestBufferLookasideDepth"
#define REGISTRY_INT_REQUEST_LOOKASIDE_DEPTH    L"InternalRequestLookasideDepth"
#define REGISTRY_RESP_BUFFER_SIZE               L"ResponseBufferSize"
#define REGISTRY_RESP_BUFFER_LOOKASIDE_DEPTH    L"ResponseBufferLookasideDepth"
#define REGISTRY_SEND_TRACKER_LOOKASIDE_DEPTH   L"SendTrackerLookasideDepth"
#define REGISTRY_LOG_BUFFER_LOOKASIDE_DEPTH     L"LogBufferLookasideDepth"
#define REGISTRY_MAX_INTERNAL_URL_LENGTH        L"MaxInternalUrlLength"
#define REGISTRY_MAX_REQUEST_BYTES              L"MaxRequestBytes"
#define REGISTRY_ENABLE_CONNECTION_REUSE        L"EnableConnectionReuse"
#define REGISTRY_ENABLE_NAGLING                 L"EnableNagling"
#define REGISTRY_ENABLE_THREAD_AFFINITY         L"EnableThreadAffinity"
#define REGISTRY_THREAD_AFFINITY_MASK           L"ThreadAffinityMask"
#define REGISTRY_THREADS_PER_CPU                L"ThreadsPerCpu"
#define REGISTRY_MAX_URL_LENGTH                 L"MaxUrlLength"
#define REGISTRY_MAX_WORK_QUEUE_DEPTH           L"MaxWorkQueueDepth"
#define REGISTRY_MIN_WORK_DEQUEUE_DEPTH         L"MinWorkDequeueDepth"
#define REGISTRY_OPAQUE_ID_TABLE_SIZE           L"OpaqueIdTableSize"
#define REGISTRY_MAX_FIELD_LENGTH               L"MaxFieldLength"
#define REGISTRY_DEBUG_LOGTIMER_CYCLE           L"DebugLogTimerCycle"
#define REGISTRY_DEBUG_LOG_BUFFER_PERIOD        L"DebugLogBufferPeriod"
#define REGISTRY_LOG_BUFFER_SIZE                L"LogBufferSize"


#define REGISTRY_ENABLE_NON_UTF8_URL            L"EnableNonUTF8"
#define REGISTRY_ENABLE_DBCS_URL                L"EnableDBCS"
#define REGISTRY_FAVOR_DBCS_URL                 L"FavorDBCS"

#define REGISTRY_CACHE_ENABLED                  L"UriEnableCache"
#define REGISTRY_MAX_CACHE_URI_COUNT            L"UriMaxCacheUriCount"
#define REGISTRY_MAX_CACHE_MEGABYTE_COUNT       L"UriMaxCacheMegabyteCount"
#define REGISTRY_CACHE_SCAVENGER_PERIOD         L"UriScavengerPeriod"
#define REGISTRY_MAX_URI_BYTES                  L"UriMaxUriBytes"
#define REGISTRY_HASH_TABLE_BITS                L"HashTableBits"

#define REGISTRY_LARGE_MEM_MEGABYTES            L"LargeMemMegabytes"

// Foward declaration; defined in data.h
typedef struct _UL_CONFIG *PUL_CONFIG;


//
// IO parameters.
//

#define DEFAULT_IRP_STACK_SIZE              1
#define DEFAULT_PRIORITY_BOOST              2


//
// Cache line requirement.
//

#ifdef _WIN64
#define UL_CACHE_LINE                       64
#else
#define UL_CACHE_LINE                       32
#endif


//
// Debugging parameters.
//

#define DEFAULT_DEBUG_FLAGS                 0x00000000
#define DEFAULT_BREAK_ON_STARTUP            FALSE
#define DEFAULT_BREAK_ON_ERROR              FALSE
#define DEFAULT_VERBOSE_ERRORS              FALSE
#define DEFAULT_ENABLE_UNLOAD               FALSE
#define DEFAULT_ENABLE_SECURITY             TRUE


//
// URI Cache parameters.
//

#define DEFAULT_CACHE_ENABLED               1           /* enabled by default */
#define DEFAULT_MAX_CACHE_URI_COUNT         0           /* max cache entries: 0 => none*/
#define DEFAULT_MAX_CACHE_MEGABYTE_COUNT    0           /* adaptive limit by default */
#define DEFAULT_CACHE_SCAVENGER_PERIOD      120         /* two-minute scavenger */
#define DEFAULT_MAX_URI_BYTES               (256<<10)   /* 256KB per entry */
#define DEFAULT_HASH_TABLE_BITS             (-1)        /* -1: determined by system mem size later */


//
// Queueing and timeouts
//

#define DEFAULT_APP_POOL_QUEUE_MAX          3000


//
// Miscellaneous
//

#define POOL_VERIFIER_OVERHEAD 64 // for large page-size allocations


//
// Other parameters.
//

#define DEFAULT_MIN_IDLE_CONNECTIONS            10
#define DEFAULT_MAX_IDLE_CONNECTIONS            64
#define DEFAULT_LOOKASIDE_DEPTH                 64
#define DEFAULT_IRP_CONTEXT_LOOKASIDE_DEPTH     64
#define DEFAULT_RCV_BUFFER_SIZE                 (8192-POOL_VERIFIER_OVERHEAD)
#define DEFAULT_RCV_BUFFER_LOOKASIDE_DEPTH      64
#define DEFAULT_RESOURCE_LOOKASIDE_DEPTH        32
#define DEFAULT_REQ_BUFFER_LOOKASIDE_DEPTH      64
#define DEFAULT_INT_REQUEST_LOOKASIDE_DEPTH     64
#define DEFAULT_RESP_BUFFER_LOOKASIDE_DEPTH     64
#define DEFAULT_RESP_BUFFER_SIZE                (8192-POOL_VERIFIER_OVERHEAD)
#define DEFAULT_SEND_TRACKER_LOOKASIDE_DEPTH    64
#define DEFAULT_LOG_BUFFER_LOOKASIDE_DEPTH      16
#define DEFAULT_MAX_REQUEST_BYTES               (16*1024)
#define DEFAULT_ENABLE_CONNECTION_REUSE         TRUE
#define DEFAULT_ENABLE_NAGLING                  FALSE
#define DEFAULT_ENABLE_THREAD_AFFINITY          FALSE
#define DEFAULT_THREADS_PER_CPU                 1
#define DEFAULT_MAX_URL_LENGTH                  (16*1024)
#define DEFAULT_MAX_FIELD_LENGTH                (16*1024)
#define DEFAULT_ENABLE_NON_UTF8_URL             FALSE
#define DEFAULT_ENABLE_DBCS_URL                 FALSE
#define DEFAULT_FAVOR_DBCS_URL                  FALSE
#define DEFAULT_MAX_REQUEST_BUFFER_SIZE         1504
#define DEFAULT_MAX_INTERNAL_URL_LENGTH         1024
#define DEFAULT_MAX_UNKNOWN_HEADERS             8
#define DEFAULT_MAX_IRP_STACK_SIZE              8
#define DEFAULT_MAX_FIXED_HEADER_SIZE           1024
#define DEFAULT_MAX_CONNECTION_ACTIVE_LISTS     64
#define DEFAULT_LARGE_MEM_MEGABYTES             (-1)
#define DEFAULT_MAX_BUFFERED_BYTES              (16*1024)
#define DEFAULT_MAX_WORK_QUEUE_DEPTH            1
#define DEFAULT_MIN_WORK_DEQUEUE_DEPTH          1
#define DEFAULT_MAX_COPY_THRESHOLD              (2048)
#define DEFAULT_MAX_SEND_BUFFERED_BYTES         (8192)
#define DEFAULT_OPAQUE_ID_TABLE_SIZE            1024
#define DEFAULT_DEBUG_LOGTIMER_CYCLE            0
#define DEFAULT_DEBUG_LOG_BUFFER_PERIOD         0
#define DEFAULT_LOG_BUFFER_SIZE                 0


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _CONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\cgroup.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    cgroup.h

Abstract:

    The public definition of config group interfaces.

Author:

    Paul McDaniel (paulmcd)       11-Jan-1999


Revision History:

--*/


#ifndef _CGROUP_H_
#define _CGROUP_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Forwarders.
//

typedef struct _UL_CONNECTION_COUNT_ENTRY *PUL_CONNECTION_COUNT_ENTRY;
typedef struct _UL_CG_URL_TREE_HEADER *PUL_CG_URL_TREE_HEADER;
typedef struct _UL_CG_URL_TREE_ENTRY *PUL_CG_URL_TREE_ENTRY;
typedef struct _UL_CONTROL_CHANNEL *PUL_CONTROL_CHANNEL;
typedef struct _UL_APP_POOL_OBJECT *PUL_APP_POOL_OBJECT;
typedef struct _UL_INTERNAL_RESPONSE *PUL_INTERNAL_RESPONSE;
typedef struct _UL_LOG_FILE_ENTRY *PUL_LOG_FILE_ENTRY;
typedef struct _UL_SITE_COUNTER_ENTRY *PUL_SITE_COUNTER_ENTRY;
typedef struct _UL_HTTP_CONNECTION *PUL_HTTP_CONNECTION;

//
// Kernel mode mappings to the user mode set defined in ulapi.h :
//

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlCreateConfigGroup(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    OUT HTTP_CONFIG_GROUP_ID * pConfigGroupId
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlDeleteConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlAddUrlToConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PUNICODE_STRING pUrl,
    IN HTTP_URL_CONTEXT UrlContext
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlRemoveUrlFromConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PUNICODE_STRING pUrl
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlRemoveAllUrlsFromConfigGroup(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlAddTransientUrl(
    PUL_APP_POOL_OBJECT pAppPool,
    PUNICODE_STRING pUrl
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlRemoveTransientUrl(
    PUL_APP_POOL_OBJECT pAppPool,
    PUNICODE_STRING pUrl
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlQueryConfigGroupInformation(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    );

// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlSetConfigGroupInformation(
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    );

//
// This structure represents an internal cfg group object.  These are linked
// and owned by control channels via a LIST_ENTRY list.
//

#define IS_VALID_CONFIG_GROUP(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_CG_OBJECT_POOL_TAG))


typedef struct _UL_CONFIG_GROUP_OBJECT
{

    //
    // PagedPool
    //

    ULONG                           Signature;          // UL_CG_OBJECT_POOL_TAG

    LONG                            RefCount;

    HTTP_CONFIG_GROUP_ID            ConfigGroupId;

    UL_NOTIFY_ENTRY                 HandleEntry;        // Links us to an apool or
                                                        // control channel handle

    UL_NOTIFY_ENTRY                 ParentEntry;        // Links transient groups
                                                        // to their static parents

    UL_NOTIFY_HEAD                  ChildHead;          // Links transient children
                                                        // into this group

    LIST_ENTRY                      ControlChannelEntry;// Links into the
                                                        // control channel

    PUL_CONTROL_CHANNEL             pControlChannel;    // the control channel

    LIST_ENTRY                      UrlListHead;        // Links UL_CG_URL_TREE_ENTRY
                                                        // into this group

    HTTP_PROPERTY_FLAGS             AppPoolFlags;
    PUL_APP_POOL_OBJECT             pAppPool;           // Maps to our app
                                                        // pool.

    PUL_INTERNAL_RESPONSE           pAutoResponse;      // The kernel version
                                                        // of the auto-response.

    HTTP_CONFIG_GROUP_MAX_BANDWIDTH MaxBandwidth;       // Applies all the flows below

    LIST_ENTRY                      FlowListHead;       // Links our flows to us so we can
                                                        // do a faster lookup and cleanup.

    HTTP_CONFIG_GROUP_MAX_CONNECTIONS MaxConnections;

    PUL_CONNECTION_COUNT_ENTRY      pConnectionCountEntry;

    HTTP_CONFIG_GROUP_STATE         State;              // The current state
                                                        // (active, etc.)

    HTTP_CONFIG_GROUP_SECURITY      Security;           // Security descriptor for
                                                        // transient registrations


    HTTP_CONFIG_GROUP_LOGGING       LoggingConfig;      // logging config for the
                                                        // sites root app.                                                            //

    PUL_LOG_FILE_ENTRY              pLogFileEntry;



    PUL_SITE_COUNTER_ENTRY          pSiteCounters;      // Perfmon Counters (ref'd)

    LONGLONG                        ConnectionTimeout;  // Connection Timeout override
                                                        // in 100ns ticks


} UL_CONFIG_GROUP_OBJECT, *PUL_CONFIG_GROUP_OBJECT;

//
// Public functions for config group objects:
//

//
// IRQL == PASSIVE_LEVEL
//

VOID
UlReferenceConfigGroup(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_CONFIG_GROUP( pConfigGroup )                              \
    UlReferenceConfigGroup(                                                 \
        (pConfigGroup)                                                      \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// IRQL == PASSIVE_LEVEL
//

VOID
UlDereferenceConfigGroup(
    PUL_CONFIG_GROUP_OBJECT pConfigGroup
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DEREFERENCE_CONFIG_GROUP( pConfigGroup )                            \
    UlDereferenceConfigGroup(                                               \
        (pConfigGroup)                                                      \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// IRQL == PASSIVE_LEVEL
//
HTTP_CONFIG_GROUP_ID
UlConfigGroupFromListEntry(
    IN PLIST_ENTRY pControlChannelEntry
    );



//
// This info is built for an URL, and returned from UlGetConfigGroupForUrl
//

#define IS_VALID_URL_CONFIG_GROUP_INFO(pInfo) \
    (((pInfo) != NULL) && ((pInfo)->Signature == UL_CG_URL_INFO_POOL_TAG))

typedef struct _UL_URL_CONFIG_GROUP_INFO
{
    //
    // NonPagedPool
    //

    //
    // UL_CG_URL_INFO_POOL_TAG
    //

    ULONG                       Signature;

    //
    // used by the cache mgr and need to be live from the
    // real config group objects
    //

    PUL_CONFIG_GROUP_OBJECT     pMaxBandwidth;
    PUL_CONFIG_GROUP_OBJECT     pMaxConnections;
    PUL_CONNECTION_COUNT_ENTRY  pConnectionCountEntry;
    PUL_CONFIG_GROUP_OBJECT     pCurrentState;
    PUL_CONFIG_GROUP_OBJECT     pLoggingConfig;

    //
    // Site Counters (ref'd)
    //
    ULONG                       SiteId;
    PUL_SITE_COUNTER_ENTRY      pSiteCounters;

    //
    // Connection Timeout (100ns Ticks)
    //
    LONGLONG                    ConnectionTimeout;

    //
    // used by the http engine routing to the app pool, no
    // need to be live.  copies work great.
    //

    HTTP_ENABLED_STATE          CurrentState;   // a copy of the above, for
                                                // callers that don't need
                                                // live access
    PUL_CONTROL_CHANNEL         pControlChannel;

    HTTP_URL_CONTEXT            UrlContext;     // The context for the url.
                                                // NULL = not set

    PUL_APP_POOL_OBJECT         pAppPool;       // Points the app pool
                                                // associated with this url

    PUL_INTERNAL_RESPONSE       pAutoResponse;  // The kernel version of the
                                                // auto-response.

} UL_URL_CONFIG_GROUP_INFO, *PUL_URL_CONFIG_GROUP_INFO;

//
// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlGetConfigGroupInfoForUrl(
    IN PWSTR pUrl,
    IN PUL_HTTP_CONNECTION pHttpConn,
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo
    );

//
// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlInitializeCG(
    VOID
    );

VOID
UlTerminateCG(
    VOID
    );

BOOLEAN
UlNotifyOrphanedConfigGroup(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    );

//
// url info helpers
//

NTSTATUS
UlpSetUrlInfo(
    IN OUT PUL_URL_CONFIG_GROUP_INFO pInfo,
    IN PUL_CG_URL_TREE_ENTRY pMatchEntry
    );

__inline
VOID
FASTCALL
UlpInitializeUrlInfo(
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo
    )
{
    ASSERT(pInfo != NULL);

    RtlZeroMemory(
        (PCHAR)pInfo,
        sizeof(UL_URL_CONFIG_GROUP_INFO)
        );

    pInfo->Signature    = UL_CG_URL_INFO_POOL_TAG;
    pInfo->CurrentState = HttpEnabledStateInactive;
}

//
// IRQL == PASSIVE_LEVEL
//
NTSTATUS
UlpConfigGroupInfoRelease(
    IN PUL_URL_CONFIG_GROUP_INFO pInfo
    );

NTSTATUS
UlpConfigGroupInfoDeepCopy(
    IN const PUL_URL_CONFIG_GROUP_INFO pOrigInfo,
    IN OUT PUL_URL_CONFIG_GROUP_INFO pNewInfo
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _CGROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\cgroupp.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    cgroupp.h

Abstract:

    The private definitions of config group module.

Author:

    Paul McDaniel (paulmcd)       11-Jan-1999


Revision History:

--*/


#ifndef _CGROUPP_H_
#define _CGROUPP_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// The tree.
//
// This is used to do all url prefix matching to decide what app pool
// a url lives in, along with other config group information.
//
// it's a sorted tree made up of 2 data structures: HEADER + ENTRY.
//
// a header is an array of ENTRY pointers that represent siblings
// at a level in the tree.  This is sorted by ENTRY::TokenHash.  the
// pointers are seperately allocated, and not embedded in the HEADER
// memory.
//
// ENTRY represents a node in the tree.  there are 2 types of ENTRY's.
// FullUrl ENTRY's and "dummy" entries.  Dummy ENTRY's exist simple as
// place holders.  they have children that are FullUrl ENTRY's.  they
// are auto-deleted when they are no longer needed.
//
// each ENTRY stores in it the part of the url it is responsible for.
// this is pToken.  For all non-site entries this is the string without
// the preceding '/' or the trailing '/'.  for top level site ENTRY's
// it is everything up the, and not including, the 3rd '/'.
// e.g. "http://www.microsoft.com:80".  These top level sites also
// have NULL ENTRY::pParent.
//
// a tree with these url's in it:
//
//      http://www.microsoft.com:80/
//      http://www.microsoft.com:80/app1
//      http://www.microsoft.com:80/app1/app2
//      http://www.microsoft.com:80/dir1/dir2/app3
//
//      http://www.msnbc.com:80/dir1/dir2/app1
//
// looks like this:
//
//  +-------------------------------------------------------------+
//  |   +---------------------------+   +-----------------------+ |
//  |   |http://www.microsoft.com:80|   |http://www.msnbc.com:80| |
//  |   +---------------------------+   +-----------------------+ |
//  +-------------------------------------------------------------+
//                 |                               |
//      +-------------------+                 +----------+
//      | +----+     +----+ |                 |  +----+  |
//      | |app1|     |dir1| |                 |  |dir1|  |
//      | +----+     +----+ |                 |  +----+  |
//      +-------------------+                 +----------+
//           |         |                           |
//      +--------+ +--------+                 +----------+
//      | +----+ | | +----+ |                 |  +----+  |
//      | |app2| | | |dir2| |                 |  |dir2|  |
//      | +----+ | | +----+ |                 |  +----+  |
//      +--------+ +--------+                 +----------+
//                     |                           |
//                 +--------+                 +----------+
//                 | +----+ |                 |  +----+  |
//                 | |app3| |                 |  |app3|  |
//                 | +----+ |                 |  +----+  |
//                 +--------+                 +----------+
//
//  and this:
//
//      g_pSites->UsedCount == 2;
//      g_pSites->ppEntries[0] == 0x10;
//      g_pSites->ppEntries[1] == 0x20;
//
//      0x10->pParent       == NULL;
//      0x10->pChildren     == 0x100;
//      0x10->TokenHash     == 0x4F74;
//      0x10->TokenLength   == 0x0036;
//      0x10->FullUrl       == 1;
//      0x10->pToken        == L"http://www.microsoft.com:80"
//
//          0x100->UsedCount    == 2;
//          0x100->ppEntries[0] == 0x110;
//          0x100->ppEntries[1] == 0x300;
//
//          0x110->pParent       == 0x10;
//          0x110->pChildren     == 0x200;
//          0x110->TokenHash     == 0x9214;
//          0x110->TokenLength   == 0x0008;
//          0x110->FullUrl       == 1;
//          0x110->pToken        == L"app1"
//
//              0x200->UsedCount    == 1;
//              0x200->ppEntries[0] == 0x210;
//
//              0x210->pParent       == 0x110;
//              0x210->pChildren     == NULL;
//              0x210->TokenHash     == ;
//              0x210->TokenLength   == 0x0008;
//              0x210->FullUrl       == 1;
//              0x210->pToken        == L"app2"
//
//          0x300->pParent       == 0x10;
//          0x300->pChildren     == 0x400;
//          0x300->TokenHash     == 0xAFDE;
//          0x300->TokenLength   == 0x0008;
//          0x300->FullUrl       == 0;
//          0x300->pToken        == L"dir1"
//
//              0x400->UsedCount    == 1;
//              0x400->ppEntries[0] == 0x410;
//
//              0x410->pParent       == 0x300;
//              0x410->pChildren     == 0x500;
//              0x410->TokenHash     == ;
//              0x410->TokenLength   == 0x0008;
//              0x410->FullUrl       == 0;
//              0x410->pToken        == L"dir2"
//
//                  0x500->UsedCount    == 1;
//                  0x500->ppEntries[0] == 0x510;
//
//                  0x510->pParent       == 0x300;
//                  0x510->pChildren     == NULL;
//                  0x510->TokenHash     == ;
//                  0x510->TokenLength   == 0x0008;
//                  0x510->FullUrl       == 1;
//                  0x510->pToken        == L"app3"
//
//      0x20->pParent       == NULL;
//      0x20->pChildren     == 0x600;
//      0x20->TokenHash     == 0x9B0D;
//      0x20->TokenLength   == 0x002E;
//      0x20->FullUrl       == 0;
//      0x20->pToken        == L"http://www.msnbc.com:80"
//
//          0x600->pParent       == 0x20;
//          0x600->pChildren     == 0x700;
//          0x600->TokenHash     == 0xAFDE;
//          0x600->TokenLength   == 0x0008;
//          0x600->FullUrl       == 0;
//          0x600->pToken        == L"dir1"
//
//              0x700->UsedCount    == 1;
//              0x700->ppEntries[0] == 0x710;
//
//              0x710->pParent       == 0x600;
//              0x710->pChildren     == 0x800;
//              0x710->TokenHash     == ;
//              0x710->TokenLength   == 0x0008;
//              0x710->FullUrl       == 0;
//              0x710->pToken        == L"dir2"
//
//                  0x800->UsedCount    == 1;
//                  0x800->ppEntries[0] == 0x810;
//
//                  0x810->pParent       == 0x710;
//                  0x810->pChildren     == NULL;
//                  0x810->TokenHash     == 0x9214;
//                  0x810->TokenLength   == 0x0008;
//                  0x810->FullUrl       == 1;
//                  0x810->pToken        == L"app1"
//
//

typedef struct _UL_CG_URL_TREE_HEADER UL_CG_URL_TREE_HEADER, * PUL_CG_URL_TREE_HEADER;
typedef struct _UL_CG_URL_TREE_ENTRY  UL_CG_URL_TREE_ENTRY, * PUL_CG_URL_TREE_ENTRY;


#define IS_VALID_TREE_ENTRY(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_CG_TREE_ENTRY_POOL_TAG))


typedef struct _UL_CG_URL_TREE_ENTRY
{

    //
    // PagedPool
    //

    //
    // base properties for dummy nodes
    //

    ULONG                   Signature;      // UL_CG_TREE_ENTRY_POOL_TAG

    PUL_CG_URL_TREE_ENTRY   pParent;        // points to the parent entry
    PUL_CG_URL_TREE_HEADER  pChildren;      // points to the child header

    ULONG                   TokenHash;      // a Hash() of pToken
    ULONG                   TokenLength;    // byte count of pToken

    ULONG                   FullUrl:1;      // a full_entry ?
    ULONG                   TransientUrl:1; // a transient url?

    //
    // extended properties for full nodes
    //

    HTTP_URL_CONTEXT        UrlContext;             // context for this url
    PUL_CONFIG_GROUP_OBJECT pConfigGroup;           // the cfg group for the url
    LIST_ENTRY              ConfigGroupListEntry;   // links into pConfigGroup

    //
    // the token string follows the struct header
    //

    WCHAR                   pToken[0];


} UL_CG_URL_TREE_ENTRY, * PUL_CG_URL_TREE_ENTRY;

//
// this allows us to duplicate the hash value of the entry
// inline with the header.  this makes the search faster as
// the hash value is in the cache line and no pointer deref
// is necessary.
//

typedef struct _UL_CG_HEADER_ENTRY
{

    ULONG                   TokenHash;
    PUL_CG_URL_TREE_ENTRY   pEntry;

} UL_CG_HEADER_ENTRY, *PUL_CG_HEADER_ENTRY;


#define IS_VALID_TREE_HEADER(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_CG_TREE_HEADER_POOL_TAG))


typedef struct _UL_CG_URL_TREE_HEADER
{

    //
    // PagedPool
    //

    ULONG                   Signature;      // UL_CG_TREE_HEADER_POOL_TAG

    ULONG                   AllocCount;     // the count of allocated space
    ULONG                   UsedCount;      // how many entries are used

    UL_CG_HEADER_ENTRY      pEntries[0];    // the entries

} UL_CG_URL_TREE_HEADER, * PUL_CG_URL_TREE_HEADER;


//
// default settings, CODEWORK move these to the registry ?
//

#define UL_CG_DEFAULT_TREE_WIDTH    10  // used to initially allocate sibling
                                        // arrays + the global site array
                                        //

#define HTTP_PREFIX_COLON_INDEX     4   // the colon location for http: (+4)

#define HTTPS_WILD_PREFIX           L"https://*:"
#define HTTPS_WILD_PREFIX_LENGTH    (sizeof(HTTPS_WILD_PREFIX)-sizeof(WCHAR))
#define HTTP_WILD_PREFIX            L"http://*:"
#define HTTP_WILD_PREFIX_LENGTH     (sizeof(HTTP_WILD_PREFIX)-sizeof(WCHAR))

#define HTTP_IP_PREFIX              L"http://"
#define HTTP_IP_PREFIX_LENGTH       (sizeof(HTTP_IP_PREFIX)-sizeof(WCHAR))
#define HTTPS_IP_PREFIX             L"https://"
#define HTTPS_IP_PREFIX_LENGTH      (sizeof(HTTPS_IP_PREFIX)-sizeof(WCHAR))

//
// work item for deferred site shutdown
// NOTE: Uses ExQueueWorkItem, not UlQueueWorkItem
//
typedef struct _UL_DEFERRED_REMOVE_ITEM {
    UL_WORK_ITEM    WorkItem;

    ULONG           NameLength;
    WCHAR           pName[0];
} UL_DEFERRED_REMOVE_ITEM, *PUL_DEFERRED_REMOVE_ITEM;

//
// Internal helper functions used in the module
//

//
// misc helpers
//

NTSTATUS
UlpCreateConfigGroupObject(
    OUT PUL_CONFIG_GROUP_OBJECT * ppObject
    );

NTSTATUS
UlpCleanAllUrls(
    IN PUL_CONFIG_GROUP_OBJECT pObject
    );

VOID
UlpDeferredRemoveSite(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    );

VOID
UlpDeferredRemoveSiteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpSanitizeUrl(
    IN  PUNICODE_STRING pUrl,
    OUT PWSTR * ppUrl
    );

//
// tree helpers
//
NTSTATUS
UlpTreeFindNodeWalker(
    IN      PUL_CG_URL_TREE_ENTRY pEntry,
    IN      PWSTR pNextToken,
    IN OUT  PUL_URL_CONFIG_GROUP_INFO pInfo OPTIONAL,
    OUT     PUL_CG_URL_TREE_ENTRY * ppEntry OPTIONAL
    );

NTSTATUS
UlpTreeFindNode(
    IN PWSTR pUrl,
    IN BOOLEAN CheckWildcard,
    IN PUL_HTTP_CONNECTION pHttpConn OPTIONAL,
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo OPTIONAL,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry OPTIONAL
    );

NTSTATUS
UlpTreeFindIpMatch(
    IN PWSTR pUrl,
    IN PUL_HTTP_CONNECTION pHttpConn,
    OUT PWSTR * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    );

NTSTATUS
UlpTreeFindWildcardMatch(
    IN  PWSTR pUrl,
    OUT PWSTR * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    );

NTSTATUS
UlpTreeFindSite(
    IN  PWSTR pUrl,
    OUT PWSTR * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry,
    IN  BOOLEAN AutoCreate
    );

NTSTATUS
UlpTreeFindEntry(
    IN  PUL_CG_URL_TREE_HEADER pHeader OPTIONAL,
    IN  PWSTR pToken,
    IN  ULONG TokenLength,
    IN  ULONG TokenHash OPTIONAL,
    OUT ULONG * pIndex,
    OUT ULONG * pTokenHash OPTIONAL
    );

NTSTATUS
UlpTreeBinaryFindEntry(
    IN  PUL_CG_URL_TREE_HEADER pHeader OPTIONAL,
    IN  PWSTR pToken,
    IN  ULONG TokenLength,
    IN  ULONG TokenHash OPTIONAL,
    OUT PULONG pIndex
    );

NTSTATUS
UlpTreeFreeNode(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    );

NTSTATUS
UlpTreeInsert(
    IN PWSTR pUrl,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    );

NTSTATUS
UlpTreeInsertEntry(
    IN OUT PUL_CG_URL_TREE_HEADER * ppHeader,
    IN PUL_CG_URL_TREE_ENTRY pParent OPTIONAL,
    IN PWSTR pToken,
    IN ULONG TokenLength,
    IN ULONG TokenHash,
    IN ULONG Index
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _CGROUPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\control.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    control.h

Abstract:

    This module contains public declarations for the UL control channel.

Author:

    Keith Moore (keithmo)       09-Feb-1999

Revision History:

--*/


#ifndef _CONTROL_H_
#define _CONTROL_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// The control channel
//

#define IS_VALID_CONTROL_CHANNEL(pControlChannel) \
    (((pControlChannel) != NULL) && ((pControlChannel)->Signature == UL_CONTROL_CHANNEL_POOL_TAG))


typedef struct _UL_CONTROL_CHANNEL
{
    ULONG                               Signature;      // UL_CONTROL_CHANNEL_POOL_TAG

    UL_NOTIFY_HEAD                      ConfigGroupHead;// All of the config groups
                                                        // created off this control
                                                        // channel

    HTTP_ENABLED_STATE                  State;          // The current state

    HTTP_BANDWIDTH_LIMIT                MaxBandwidth;   // The global Bandwidth throttling
                                                        // limit if it exists

    HTTP_CONNECTION_LIMIT               MaxConnections; // The global connection limit
                                                        // if it exists

    PUL_INTERNAL_RESPONSE               pAutoResponse;  // The kernel version of the
                                                        // auto-response.

    HTTP_CONTROL_CHANNEL_UTF8_LOGGING   UTF8Logging;    // Shows if Utf8 Logging is on or off

    //
    // Note, filter channel information is stored in a separate data
    // structure instead of here so that ultdi can query it when it
    // creates new endpoints.
    //

} UL_CONTROL_CHANNEL, *PUL_CONTROL_CHANNEL;

//
// Initialize/terminate functions.
//

NTSTATUS
UlInitializeControlChannel(
    VOID
    );

VOID
UlTerminateControlChannel(
    VOID
    );


//
// Open a new control channel.
//

NTSTATUS
UlOpenControlChannel(
    OUT PUL_CONTROL_CHANNEL *ppControlChannel
    );

NTSTATUS
UlCloseControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    );

NTSTATUS
UlSetControlChannelInformation(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length
    );

NTSTATUS
UlGetControlChannelInformation(
    IN  PUL_CONTROL_CHANNEL pControlChannel,
    IN  HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN  PVOID   pControlChannelInformation,
    IN  ULONG   Length,
    OUT PULONG  pReturnLength OPTIONAL
    );

PUL_FILTER_CHANNEL
UlQueryFilterChannel(
    IN BOOLEAN SecureConnection
    );

BOOLEAN
UlValidateFilterChannel(
    IN PUL_FILTER_CHANNEL pChannel,
    IN BOOLEAN SecureConnection
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _CONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\countersp.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    countersp.h

Abstract:

    Contains the performance monitoring counter management code

Author:

    Eric Stenson (ericsten)      25-Sep-2000

Revision History:

--*/

#ifndef __COUNTERSP_H__
#define __COUNTERSP_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOLEAN
UlpIsInSiteCounterList(ULONG SiteId);


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // __COUNTERSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\data.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    data.cxx

Abstract:

    This module contains global data for UL.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeData )
#pragma alloc_text( PAGE, UlTerminateData )
#endif  // ALLOC_PRAGMA


//
// The number of processors in the system.
//

CLONG     g_UlNumberOfProcessors = 1;
ULONGLONG g_UlThreadAffinityMask = 1;

//
// The largest cache line size the system
//

ULONG g_UlCacheLineSize = 0;
ULONG g_UlCacheLineBits = 0; // see init.cxx


//
// Our nonpaged data.
//

PUL_NONPAGED_DATA g_pUlNonpagedData = NULL;


//
// A pointer to the system process.
//

PKPROCESS g_pUlSystemProcess = NULL;


//
// Our device objects and their container.
//

HANDLE g_UlDirectoryObject = NULL;

PDEVICE_OBJECT g_pUlControlDeviceObject = NULL;
PDEVICE_OBJECT g_pUlFilterDeviceObject  = NULL;
PDEVICE_OBJECT g_pUlAppPoolDeviceObject = NULL;

//
// Cached Date header string.
//

LARGE_INTEGER g_UlSystemTime;
UCHAR g_UlDateString[DATE_HDR_LENGTH+1];
ULONG g_UlDateStringLength;


//
// Various pieces of configuration information, with default values.
//

CCHAR g_UlPriorityBoost = DEFAULT_PRIORITY_BOOST;
CCHAR g_UlIrpStackSize = DEFAULT_IRP_STACK_SIZE;
USHORT g_UlMinIdleConnections = DEFAULT_MIN_IDLE_CONNECTIONS;
USHORT g_UlMaxIdleConnections = DEFAULT_MAX_IDLE_CONNECTIONS;
ULONG g_UlReceiveBufferSize = DEFAULT_RCV_BUFFER_SIZE;
ULONG g_UlMaxRequestBytes = DEFAULT_MAX_REQUEST_BYTES;
BOOLEAN g_UlEnableConnectionReuse = DEFAULT_ENABLE_CONNECTION_REUSE;
BOOLEAN g_UlEnableNagling = DEFAULT_ENABLE_NAGLING;
BOOLEAN g_UlEnableThreadAffinity = DEFAULT_ENABLE_THREAD_AFFINITY;
ULONG g_UlMaxUrlLength = DEFAULT_MAX_URL_LENGTH;
ULONG g_UlMaxFieldLength = DEFAULT_MAX_FIELD_LENGTH;
USHORT g_UlDebugLogTimerCycle = DEFAULT_DEBUG_LOGTIMER_CYCLE;
USHORT g_UlDebugLogBufferPeriod = DEFAULT_DEBUG_LOG_BUFFER_PERIOD;
ULONG  g_UlLogBufferSize = DEFAULT_LOG_BUFFER_SIZE;
BOOLEAN g_UlEnableNonUTF8 = DEFAULT_ENABLE_NON_UTF8_URL;
BOOLEAN g_UlEnableDBCS = DEFAULT_ENABLE_DBCS_URL;
BOOLEAN g_UlFavorDBCS = DEFAULT_FAVOR_DBCS_URL;
USHORT g_UlMaxInternalUrlLength = DEFAULT_MAX_INTERNAL_URL_LENGTH;
ULONG g_UlResponseBufferSize = DEFAULT_RESP_BUFFER_SIZE;
ULONG g_UlMaxBufferedBytes = DEFAULT_MAX_BUFFERED_BYTES;
ULONG g_UlMaxCopyThreshold = DEFAULT_MAX_COPY_THRESHOLD;
ULONG g_UlMaxSendBufferedBytes = DEFAULT_MAX_SEND_BUFFERED_BYTES;
ULONG g_UlMaxWorkQueueDepth = DEFAULT_MAX_WORK_QUEUE_DEPTH;
ULONG g_UlMinWorkDequeueDepth = DEFAULT_MIN_WORK_DEQUEUE_DEPTH;
ULONG g_UlOpaqueIdTableSize = DEFAULT_OPAQUE_ID_TABLE_SIZE;

//
// The following are generated during initialization.
//

ULONG g_UlMaxVariableHeaderSize = 0;
ULONG g_UlMaxFixedHeaderSize = 0;
ULONG g_UlFixedHeadersMdlLength = 0;
ULONG g_UlVariableHeadersMdlLength = 0;
ULONG g_UlContentMdlLength = 0;
ULONG g_UlChunkTrackerSize = 0;
ULONG g_UlFullTrackerSize = 0;

//
// Make life easier for the debugger extension.
//

#if DBG
ULONG g_UlCheckedBuild = TRUE;
#else
ULONG g_UlCheckedBuild = FALSE;
#endif


//
// Debug stuff.
//

#if DBG
ULONG g_UlDebug = DEFAULT_DEBUG_FLAGS;
ULONG g_UlBreakOnError = DEFAULT_BREAK_ON_ERROR;
ULONG g_UlVerboseErrors = DEFAULT_VERBOSE_ERRORS;
UL_DEBUG_STATISTICS_INFO g_UlDebugStats = { 0 };
#endif  // DBG

#if REFERENCE_DEBUG
PTRACE_LOG g_pMondoGlobalTraceLog = NULL;
PTRACE_LOG g_pTdiTraceLog = NULL;
PTRACE_LOG g_pHttpRequestTraceLog = NULL;
PTRACE_LOG g_pHttpConnectionTraceLog = NULL;
PTRACE_LOG g_pHttpResponseTraceLog = NULL;
PTRACE_LOG g_pAppPoolTraceLog = NULL;
PTRACE_LOG g_pConfigGroupTraceLog = NULL;
PTRACE_LOG g_pThreadTraceLog = NULL;
PTRACE_LOG g_pFilterTraceLog = NULL;
PTRACE_LOG g_pIrpTraceLog = NULL;
PTRACE_LOG g_pTimeTraceLog = NULL;
PTRACE_LOG g_pReplenishTraceLog = NULL;
PTRACE_LOG g_pFilterQueueTraceLog = NULL;
PTRACE_LOG g_pMdlTraceLog = NULL;
PTRACE_LOG g_pSiteCounterTraceLog = NULL;
PTRACE_LOG g_pConnectionCountTraceLog = NULL;
PTRACE_LOG g_pConfigGroupInfoTraceLog = NULL;
PTRACE_LOG g_pChunkTrackerTraceLog = NULL;
PTRACE_LOG g_pWorkItemTraceLog = NULL;

#endif  // REFERENCE_DEBUG


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global data initialization.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeData(
    PUL_CONFIG pConfig
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Initialize the nonpaged data.
    //

    g_pUlNonpagedData = UL_ALLOCATE_STRUCT(
                            NonPagedPool,
                            UL_NONPAGED_DATA,
                            UL_NONPAGED_DATA_POOL_TAG
                            );

    if (g_pUlNonpagedData == NULL )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(g_pUlNonpagedData, sizeof(*g_pUlNonpagedData));

#if DBG
    //
    // Initialize any debug-specific data.
    //

    UlDbgInitializeDebugData( );
#endif  // DBG

    //
    // Initialize the maximum variable header size.
    //

    g_UlMaxVariableHeaderSize = UlComputeMaxVariableHeaderSize();
    g_UlMaxVariableHeaderSize = ALIGN_UP(g_UlMaxVariableHeaderSize, PVOID);

    g_UlMaxFixedHeaderSize = DEFAULT_MAX_FIXED_HEADER_SIZE;

    //
    // Initialize the maximum cache Mdl length.
    //

    ASSERT( g_UlMaxFixedHeaderSize <= MAX_BYTES_BUFFERED );
    ASSERT( g_UlMaxVariableHeaderSize <= MAX_BYTES_BUFFERED );
    ASSERT( g_UlMaxCopyThreshold <= MAX_BYTES_BUFFERED );

    //
    // MDL Length for FixedHeaders or UserBuffer.
    //

    g_UlFixedHeadersMdlLength = (ULONG)
        MmSizeOfMdl(
            (PVOID)(PAGE_SIZE - 1),
            MAX_BYTES_BUFFERED
            );

    g_UlFixedHeadersMdlLength = ALIGN_UP(g_UlFixedHeadersMdlLength, PVOID);

    //
    // MDL Length for VariableHeaders or FixedHeaders + VariablesHeaders +
    // CopiedBuffer.
    //

    g_UlVariableHeadersMdlLength = (ULONG)
        MmSizeOfMdl(
            (PVOID)(PAGE_SIZE - 1),
            g_UlMaxFixedHeaderSize +
                g_UlMaxVariableHeaderSize +
                g_UlMaxCopyThreshold
            );

    g_UlVariableHeadersMdlLength = ALIGN_UP(g_UlVariableHeadersMdlLength, PVOID);

    //
    // MDL Length for Content.
    //

    g_UlContentMdlLength = (ULONG)
        MmSizeOfMdl(
            (PVOID)(PAGE_SIZE - 1),
            pConfig->UriConfig.MaxUriBytes
            );

    g_UlContentMdlLength = ALIGN_UP(g_UlContentMdlLength, PVOID);

    //
    // Initialize chunk and cache tracker size.
    //

    g_UlChunkTrackerSize =
        ALIGN_UP(sizeof(UL_CHUNK_TRACKER), PVOID) +
            2 * ALIGN_UP(IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE), PVOID) +
            g_UlMaxVariableHeaderSize;

    g_UlFullTrackerSize =
        ALIGN_UP(sizeof(UL_FULL_TRACKER), PVOID) +
            ALIGN_UP(IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE), PVOID) +
            g_UlMaxFixedHeaderSize +
            g_UlMaxVariableHeaderSize +
            g_UlMaxCopyThreshold +
            g_UlFixedHeadersMdlLength +
            g_UlVariableHeadersMdlLength +
            g_UlContentMdlLength;

    g_UlFullTrackerSize = ALIGN_UP(g_UlFullTrackerSize, PVOID);

    //
    // Initialize the lookaside lists.
    //

    g_pUlNonpagedData->IrpContextLookaside =
        PplCreatePool(
            &UlAllocateIrpContextPool,              // Allocate
            &UlFreeIrpContextPool,                  // Free
            0,                                      // Flags
            sizeof(UL_IRP_CONTEXT),                 // Size
            UL_IRP_CONTEXT_POOL_TAG,                // Tag
            pConfig->IrpContextLookasideDepth       // Depth
            );

    if (!g_pUlNonpagedData->IrpContextLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->ReceiveBufferLookaside =
        PplCreatePool(
            &UlAllocateReceiveBufferPool,           // Allocate
            &UlFreeReceiveBufferPool,               // Free
            0,                                      // Flags
            sizeof(UL_RECEIVE_BUFFER),              // Size
            UL_RCV_BUFFER_POOL_TAG,                 // Tag
            pConfig->ReceiveBufferLookasideDepth    // Depth
            );

    if (!g_pUlNonpagedData->ReceiveBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->ResponseBufferLookaside =
        PplCreatePool(
            &UlAllocateResponseBufferPool,          // Allocate
            &UlFreeResponseBufferPool,              // Free
            0,                                      // Flags
            g_UlResponseBufferSize,                 // Size
            UL_INTERNAL_RESPONSE_POOL_TAG,          // Tag
            pConfig->ResponseBufferLookasideDepth   // Depth
            );

    if (!g_pUlNonpagedData->ResponseBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->ResourceLookaside =
        PplCreatePool(
            &UlResourceAllocatePool,                // Allocate
            &UlResourceFreePool,                    // Free
            0,                                      // Flags
            sizeof(UL_NONPAGED_RESOURCE),           // Size
            UL_NONPAGED_RESOURCE_POOL_TAG,          // Tag
            pConfig->ResourceLookasideDepth         // Depth
            );

    if (!g_pUlNonpagedData->ResourceLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->RequestBufferLookaside =
        PplCreatePool(
            &UlAllocateRequestBufferPool,           // Allocate
            &UlFreeRequestBufferPool,               // Free
            0,                                      // Flags
            DEFAULT_MAX_REQUEST_BUFFER_SIZE,        // Size
            UL_REQUEST_BUFFER_POOL_TAG,             // Tag
            pConfig->RequestBufferLookasideDepth    // Depth
            );

    if (!g_pUlNonpagedData->RequestBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->InternalRequestLookaside =
        PplCreatePool(
            &UlAllocateInternalRequestPool,         // Allocate
            &UlFreeInternalRequestPool,             // Free
            0,                                      // Flags
            sizeof(UL_INTERNAL_REQUEST),            // Size
            UL_INTERNAL_REQUEST_POOL_TAG,           // Tag
            pConfig->InternalRequestLookasideDepth  // Depth
            );

    if (!g_pUlNonpagedData->InternalRequestLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->ChunkTrackerLookaside =
        PplCreatePool(
            &UlAllocateChunkTrackerPool,            // Allocate
            &UlFreeChunkTrackerPool,                // Free
            0,                                      // Flags
            g_UlChunkTrackerSize,                   // Size
            UL_CHUNK_TRACKER_POOL_TAG,              // Tag
            pConfig->SendTrackerLookasideDepth      // Depth
            );

    if (!g_pUlNonpagedData->ChunkTrackerLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->FullTrackerLookaside =
        PplCreatePool(
            &UlAllocateFullTrackerPool,             // Allocate
            &UlFreeFullTrackerPool,                 // Free
            0,                                      // Flags
            g_UlFullTrackerSize,                    // Size
            UL_FULL_TRACKER_POOL_TAG,               // Tag
            pConfig->SendTrackerLookasideDepth      // Depth
            );

    if (!g_pUlNonpagedData->FullTrackerLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->LogBufferLookaside =
        PplCreatePool(
            &UlAllocateLogBufferPool,               // Allocate
            &UlFreeLogBufferPool,                   // Free
            0,                                      // Flags
            sizeof(UL_LOG_FILE_BUFFER),             // Size
            UL_LOG_FILE_BUFFER_POOL_TAG,            // Tag
            pConfig->LogBufferLookasideDepth        // Depth
            );

    if (!g_pUlNonpagedData->LogBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;

}   // UlInitializeData


/***************************************************************************++

Routine Description:

    Performs global data termination.

--***************************************************************************/
VOID
UlTerminateData(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    if (g_pUlNonpagedData != NULL)
    {
        //
        // Kill the lookaside lists.
        //

        if (g_pUlNonpagedData->IrpContextLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->IrpContextLookaside );
        }

        if (g_pUlNonpagedData->ReceiveBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->ReceiveBufferLookaside );
        }

        if (g_pUlNonpagedData->ResourceLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->ResourceLookaside );
        }

        if (g_pUlNonpagedData->RequestBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->RequestBufferLookaside );
        }

        if (g_pUlNonpagedData->InternalRequestLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->InternalRequestLookaside );
        }

        if (g_pUlNonpagedData->ChunkTrackerLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->ChunkTrackerLookaside );
        }

        if (g_pUlNonpagedData->FullTrackerLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->FullTrackerLookaside );
        }

        if (g_pUlNonpagedData->ResponseBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->ResponseBufferLookaside );
        }

        if (g_pUlNonpagedData->LogBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->LogBufferLookaside );
        }

        //
        // Free the nonpaged data.
        //

        UL_FREE_POOL( g_pUlNonpagedData, UL_NONPAGED_DATA_POOL_TAG );
    }

}   // UlTerminateData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\counters.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    counters.h

Abstract:

    Contains the performance monitoring counter management
    function declarations

Author:

    Eric Stenson (ericsten)      25-Sep-2000

Revision History:

--*/


#ifndef __COUNTERS_H__
#define __COUNTERS_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// structure to hold info for Site Counters.
//

typedef struct _UL_SITE_COUNTER_ENTRY {

    //
    // Signature is UL_SITE_COUNTER_ENTRY_POOL_TAG
    //

    ULONG               Signature;

    //
    // Ref count for this Site Counter Entry
    //
    LONG                RefCount;

    //
    // Lock protets whole entry; used primarily when touching
    // 64-bit counters
    //

    FAST_MUTEX          EntryMutex;

    //
    // links all site counter entries
    //

    LIST_ENTRY          ListEntry;

    //
    // the block which actually contains the counter data to be
    // passed back to WAS
    //

    HTTP_SITE_COUNTERS  Counters;

} UL_SITE_COUNTER_ENTRY, *PUL_SITE_COUNTER_ENTRY;

#define IS_VALID_SITE_COUNTER_ENTRY( entry )                                  \
    ( (entry != NULL) && ((entry)->Signature == UL_SITE_COUNTER_ENTRY_POOL_TAG) )


//
// Private globals
//

extern BOOLEAN                  g_InitCountersCalled;
extern HTTP_GLOBAL_COUNTERS     g_UlGlobalCounters;
extern FAST_MUTEX               g_SiteCounterListMutex;
extern LIST_ENTRY               g_SiteCounterListHead;
extern LONG                     g_SiteCounterListCount;

extern HTTP_PROP_DESC           aIISULGlobalDescription[];
extern HTTP_PROP_DESC           aIISULSiteDescription[];


//
// Init
//

NTSTATUS
UlInitializeCounters(
    VOID
    );

VOID
UlTerminateCounters(
    VOID
    );


//
// Site Counter Entry
//

NTSTATUS
UlCreateSiteCounterEntry(
    IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup,
    IN ULONG SiteId
    );

#if REFERENCE_DEBUG
VOID
UlDereferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DEREFERENCE_SITE_COUNTER_ENTRY( pSC )                               \
    UlDereferenceSiteCounterEntry(                                          \
        (pSC)                                                               \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

VOID
UlReferenceSiteCounterEntry(
    IN  PUL_SITE_COUNTER_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_SITE_COUNTER_ENTRY( pSC )                                 \
    UlReferenceSiteCounterEntry(                                            \
    (pSC)                                                                   \
    REFERENCE_DEBUG_ACTUAL_PARAMS                                           \
    )
#else
__inline
VOID
FASTCALL
UlReferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    )
{
    InterlockedIncrement(&pEntry->RefCount);
}

__inline
VOID
FASTCALL
UlDereferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    )
{
    if (InterlockedDecrement(&pEntry->RefCount) == 0)
    {
        ExAcquireFastMutex(&g_SiteCounterListMutex);

        RemoveEntryList(&pEntry->ListEntry);
        pEntry->ListEntry.Flink = pEntry->ListEntry.Blink = NULL;
        g_SiteCounterListCount--;

        ExReleaseFastMutex(&g_SiteCounterListMutex);

        UL_FREE_POOL_WITH_SIG(pEntry, UL_SITE_COUNTER_ENTRY_POOL_TAG);
    }
}

#define REFERENCE_SITE_COUNTER_ENTRY    UlReferenceSiteCounterEntry
#define DEREFERENCE_SITE_COUNTER_ENTRY  UlDereferenceSiteCounterEntry
#endif


//
// Global (cache) counters
//

#if REFERENCE_DEBUG
VOID
UlIncCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr
    );

VOID
UlDecCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr
    );

VOID
UlAddCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr,
    ULONG Value
    );

VOID
UlResetCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr
    );
#else
__inline
VOID
FASTCALL
UlIncCounter(
    IN HTTP_GLOBAL_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&g_UlGlobalCounters;
    pCounter += aIISULGlobalDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULGlobalDescription[CounterId].Size)
    {
        InterlockedIncrement((PLONG)pCounter);
    }
    else
    {
        UlInterlockedIncrement64((PLONGLONG)pCounter);
    }
}

__inline
VOID
FASTCALL
UlDecCounter(
    IN HTTP_GLOBAL_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&g_UlGlobalCounters;
    pCounter += aIISULGlobalDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULGlobalDescription[CounterId].Size)
    {
        InterlockedDecrement((PLONG)pCounter);
    }
    else
    {
        UlInterlockedDecrement64((PLONGLONG)pCounter);
    }
}

__inline
VOID
FASTCALL
UlAddCounter(
    IN HTTP_GLOBAL_COUNTER_ID CounterId,
    IN ULONG Value
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&g_UlGlobalCounters;
    pCounter += aIISULGlobalDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULGlobalDescription[CounterId].Size)
    {
        InterlockedExchangeAdd((PLONG)pCounter, Value);
    }
    else
    {
        UlInterlockedAdd64((PLONGLONG)pCounter, Value);
    }
}

__inline
VOID
FASTCALL
UlResetCounter(
    IN HTTP_GLOBAL_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&g_UlGlobalCounters;
    pCounter += aIISULGlobalDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULGlobalDescription[CounterId].Size)
    {
        InterlockedExchange((PLONG)pCounter, 0);
    }
    else
    {
        UlInterlockedExchange64((PLONGLONG)pCounter, 0);
    }
}
#endif


//
// Instance (site) counters
//

#if REFERENCE_DEBUG

VOID
UlIncSiteNonCriticalCounterUlong(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID CounterId
    );

VOID
UlIncSiteNonCriticalCounterUlonglong(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID CounterId
    );


LONGLONG
UlIncSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    );

VOID
UlDecSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    );

VOID
UlAddSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONG Value
    );

VOID
UlAddSiteCounter64(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONGLONG llValue
    );

VOID
UlResetSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    );

VOID
UlMaxSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONG Value
    );

VOID
UlMaxSiteCounter64(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    LONGLONG llValue
    );

#else

__inline
VOID
UlIncSiteNonCriticalCounterUlong(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR       pCounter;
    PLONG       plValue;

    pCounter = (PCHAR) &(pEntry->Counters);
    pCounter += aIISULSiteDescription[CounterId].Offset;

    plValue = (PLONG) pCounter;
    ++(*plValue);
}

__inline
VOID
UlIncSiteNonCriticalCounterUlonglong(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR       pCounter;
    PLONGLONG   pllValue;


    pCounter = (PCHAR) &(pEntry->Counters);
    pCounter += aIISULSiteDescription[CounterId].Offset;

    pllValue = (PLONGLONG) pCounter;
    ++(*pllValue);
}

__inline
LONGLONG
FASTCALL
UlIncSiteCounter(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULSiteDescription[CounterId].Size)
    {
        return (LONGLONG)InterlockedIncrement((PLONG)pCounter);
    }
    else
    {
        return UlInterlockedIncrement64((PLONGLONG)pCounter);
    }
}

__inline
VOID
FASTCALL
UlDecSiteCounter(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULSiteDescription[CounterId].Size)
    {
        InterlockedDecrement((PLONG)pCounter);
    }
    else
    {
        UlInterlockedDecrement64((PLONGLONG)pCounter);
    }
}

__inline
VOID
FASTCALL
UlAddSiteCounter(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId,
    IN ULONG Value
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    InterlockedExchangeAdd((PLONG)pCounter, Value);
}

__inline
VOID
FASTCALL
UlAddSiteCounter64(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId,
    IN ULONGLONG Value
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    UlInterlockedAdd64((PLONGLONG)pCounter, Value);
}

__inline
VOID
FASTCALL
UlResetSiteCounter(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULSiteDescription[CounterId].Size)
    {
        InterlockedExchange((PLONG)pCounter, 0);
    }
    else
    {
        UlInterlockedExchange64((PLONGLONG)pCounter, 0);
    }
}

__inline
VOID
FASTCALL
UlMaxSiteCounter(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId,
    IN ULONG Value
    )
{
    PCHAR pCounter;
    LONG LocalMaxed;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    do {
        LocalMaxed = *((volatile LONG *)pCounter);
        if ((LONG)Value <= LocalMaxed)
        {
            break;
        }
    } while (LocalMaxed != InterlockedCompareExchange(
                                (PLONG)pCounter,
                                Value,
                                LocalMaxed
                                ));
}

__inline
VOID
FASTCALL
UlMaxSiteCounter64(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId,
    IN LONGLONG Value
    )
{
    PCHAR pCounter;
    LONGLONG LocalMaxed;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    do {
        LocalMaxed = *((volatile LONGLONG *)pCounter);
        if (Value <= LocalMaxed)
        {
            break;
        }
    } while (LocalMaxed != InterlockedCompareExchange64(
                                (PLONGLONG)pCounter,
                                Value,
                                LocalMaxed
                                ));
}
#endif

//
// Collection
//

NTSTATUS
UlGetGlobalCounters(
    PVOID   IN OUT pCounter,
    ULONG   IN     BlockSize,
    PULONG  OUT    pBytesWritten
    );

NTSTATUS
UlGetSiteCounters(
    PVOID   IN OUT pCounter,
    ULONG   IN     BlockSize,
    PULONG  OUT    pBytesWritten,
    PULONG  OUT    pBlocksWritten
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // __COUNTERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\data.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    data.h

Abstract:

    This module declares global data for HTTP.SYS.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _DATA_H_
#define _DATA_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Some data types.
//

typedef struct _UL_CONFIG
{
    USHORT              ThreadsPerCpu;
    USHORT              IrpContextLookasideDepth;
    USHORT              ReceiveBufferLookasideDepth;
    USHORT              ResourceLookasideDepth;
    USHORT              RequestBufferLookasideDepth;
    USHORT              InternalRequestLookasideDepth;
    USHORT              SendTrackerLookasideDepth;
    USHORT              ResponseBufferLookasideDepth;
    USHORT              LogBufferLookasideDepth;
    BOOLEAN             EnableUnload;
    BOOLEAN             EnableSecurity;

    UL_URI_CACHE_CONFIG UriConfig;

    LONG                LargeMemMegabytes;

} UL_CONFIG, *PUL_CONFIG;


//
// The number of processors in the system.
//

extern CLONG g_UlNumberOfProcessors;

//
// The largest cache line in the system
//

extern ULONG g_UlCacheLineSize;
extern ULONG g_UlCacheLineBits;


//
// Our nonpaged data.
//

extern PUL_NONPAGED_DATA g_pUlNonpagedData;


//
// A pointer to the system process.
//

extern PKPROCESS g_pUlSystemProcess;


//
// Our device objects and their container.
//

extern HANDLE g_UlDirectoryObject;

extern PDEVICE_OBJECT g_pUlControlDeviceObject;
extern PDEVICE_OBJECT g_pUlFilterDeviceObject;
extern PDEVICE_OBJECT g_pUlAppPoolDeviceObject;


//
// Various pieces of configuration information.
//

extern CCHAR g_UlPriorityBoost;
extern CCHAR g_UlIrpStackSize;
extern USHORT g_UlMinIdleConnections;
extern USHORT g_UlMaxIdleConnections;
extern ULONG g_UlReceiveBufferSize;
extern ULONG g_UlMaxRequestBytes;
extern BOOLEAN g_UlEnableConnectionReuse;
extern BOOLEAN g_UlEnableNagling;
extern BOOLEAN g_UlEnableThreadAffinity;
extern ULONGLONG g_UlThreadAffinityMask;
extern ULONG g_UlMaxUrlLength;
extern ULONG g_UlMaxFieldLength;
extern USHORT g_UlDebugLogTimerCycle;
extern USHORT g_UlDebugLogBufferPeriod;
extern ULONG  g_UlLogBufferSize;
extern BOOLEAN g_UlEnableNonUTF8;
extern BOOLEAN g_UlEnableDBCS;
extern BOOLEAN g_UlFavorDBCS;
extern USHORT g_UlMaxInternalUrlLength;
extern ULONG g_UlMaxVariableHeaderSize;
extern ULONG g_UlMaxFixedHeaderSize;
extern ULONG g_UlFixedHeadersMdlLength;
extern ULONG g_UlVariableHeadersMdlLength;
extern ULONG g_UlContentMdlLength;
extern ULONG g_UlChunkTrackerSize;
extern ULONG g_UlFullTrackerSize;
extern ULONG g_UlResponseBufferSize;
extern ULONG g_UlMaxBufferedBytes;
extern ULONG g_UlMaxCopyThreshold;
extern ULONG g_UlMaxSendBufferedBytes;
extern ULONG g_UlMaxWorkQueueDepth;
extern ULONG g_UlMinWorkDequeueDepth;
extern ULONG g_UlOpaqueIdTableSize;


//
// Cached Date header string.
//

extern LARGE_INTEGER g_UlSystemTime;
extern UCHAR g_UlDateString[];
extern ULONG g_UlDateStringLength;


//
// Debug stuff.
//

#if DBG
extern ULONG g_UlDebug;
extern ULONG g_UlBreakOnError;
extern ULONG g_UlVerboseErrors;
extern UL_DEBUG_STATISTICS_INFO g_UlDebugStats;
#endif  // DBG

#if REFERENCE_DEBUG
extern PTRACE_LOG g_pMondoGlobalTraceLog;
extern PTRACE_LOG g_pTdiTraceLog;
extern PTRACE_LOG g_pHttpRequestTraceLog;
extern PTRACE_LOG g_pHttpConnectionTraceLog;
extern PTRACE_LOG g_pHttpResponseTraceLog;
extern PTRACE_LOG g_pAppPoolTraceLog;
extern PTRACE_LOG g_pConfigGroupTraceLog;
extern PTRACE_LOG g_pThreadTraceLog;
extern PTRACE_LOG g_pFilterTraceLog;
extern PTRACE_LOG g_pIrpTraceLog;
extern PTRACE_LOG g_pTimeTraceLog;
extern PTRACE_LOG g_pReplenishTraceLog;
extern PTRACE_LOG g_pFilterQueueTraceLog;
extern PTRACE_LOG g_pMdlTraceLog;
extern PTRACE_LOG g_pSiteCounterTraceLog;
extern PTRACE_LOG g_pConnectionCountTraceLog;
extern PTRACE_LOG g_pConfigGroupInfoTraceLog;
extern PTRACE_LOG g_pChunkTrackerTraceLog;
extern PTRACE_LOG g_pWorkItemTraceLog;

#endif  // REFERENCE_DEBUG


//
// Object types exported by the kernel but not in any header file.
//

extern POBJECT_TYPE *IoFileObjectType;


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\create.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    create.cxx

Abstract:

    This module contains code for opening a handle to UL.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlCreate )
#endif  // ALLOC_PRAGMA


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the routine that handles Create IRPs in UL. Create IRPs are
    issued when the file object is created.

Arguments:

    pDeviceObject - Supplies a pointer to the target device object.

    pIrp - Supplies a pointer to IO request packet.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreate(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;
    PFILE_OBJECT pFileObject;
    PFILE_FULL_EA_INFORMATION pEaBuffer;
    PHTTP_OPEN_PACKET pOpenPacket;
    UCHAR createDisposition;
    PWSTR pName;
    ULONG nameLength;
    PIO_SECURITY_CONTEXT pSecurityContext;

    //
    // Sanity check.
    //

    PAGED_CODE();
    UL_ENTER_DRIVER( "UlCreate", pIrp );

    //
    // Find and validate the open packet.
    //

    pEaBuffer = (PFILE_FULL_EA_INFORMATION)(pIrp->AssociatedIrp.SystemBuffer);

    if (pEaBuffer == NULL ||
        pEaBuffer->EaValueLength != sizeof(*pOpenPacket) ||
        pEaBuffer->EaNameLength != HTTP_OPEN_PACKET_NAME_LENGTH ||
        strcmp( pEaBuffer->EaName, HTTP_OPEN_PACKET_NAME ) )
    {
        status = STATUS_REVISION_MISMATCH;
        goto complete;
    }

    pOpenPacket =
        (PHTTP_OPEN_PACKET)( pEaBuffer->EaName + pEaBuffer->EaNameLength + 1 );

    ASSERT( (((ULONG_PTR)pOpenPacket) & 7) == 0 );

    //
    // For now, we'll fail if the incoming version doesn't EXACTLY match
    // the expected version. In future, we may need to be a bit more
    // flexible to allow down-level clients.
    //

    if (pOpenPacket->MajorVersion != HTTP_INTERFACE_VERSION_MAJOR ||
        pOpenPacket->MinorVersion != HTTP_INTERFACE_VERSION_MINOR)
    {
        status = STATUS_REVISION_MISMATCH;
        goto complete;
    }

    //
    // Snag the current IRP stack pointer, then extract the creation
    // disposition. IO stores this as the high byte of the Options field.
    // Also snag the file object; we'll need it often.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    createDisposition = (UCHAR)( pIrpSp->Parameters.Create.Options >> 24 );
    pFileObject = pIrpSp->FileObject;
    pSecurityContext = pIrpSp->Parameters.Create.SecurityContext;
    ASSERT( pSecurityContext != NULL );

    //
    // Determine if this is a request to open a control channel or
    // open/create an app pool.
    //

    if (pDeviceObject == g_pUlControlDeviceObject)
    {
        //
        // It's a control channel.
        //
        // Validate the creation disposition. We allow open only.
        //

        if (createDisposition != FILE_OPEN)
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // Open the control channel.
        //

        status = UlOpenControlChannel(GET_PP_CONTROL_CHANNEL(pFileObject));

        if (NT_SUCCESS(status))
        {
            ASSERT( GET_CONTROL_CHANNEL(pFileObject) != NULL );
            MARK_VALID_CONTROL_CHANNEL( pFileObject );
        }
    }
    else if (pDeviceObject == g_pUlFilterDeviceObject)
    {
        //
        // It's a filter channel.
        //
        // Validate the creation disposition. We allow create and open
        //

        if (createDisposition != FILE_CREATE && createDisposition != FILE_OPEN)
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // Make sure there's a name with a reasonable length
        //
        if (pFileObject->FileName.Buffer == NULL ||
            pFileObject->FileName.Length < sizeof(WCHAR) ||
            pFileObject->FileName.Length > UL_MAX_FILTER_NAME_LENGTH)
        {
            status = STATUS_OBJECT_NAME_INVALID;
            goto complete;
        }

        //
        // Bind to the specified filter channel.
        //
        pName = pFileObject->FileName.Buffer + 1;
        nameLength = pFileObject->FileName.Length - sizeof(WCHAR);

        status = UlAttachFilterProcess(
                        pName,
                        nameLength,
                        (BOOLEAN)(createDisposition == FILE_CREATE),
                        pSecurityContext->AccessState,
                        pSecurityContext->DesiredAccess,
                        pIrp->RequestorMode,
                        GET_PP_FILTER_PROCESS(pFileObject)
                        );

        if (NT_SUCCESS(status))
        {
            ASSERT( GET_FILTER_PROCESS(pFileObject) != NULL );
            MARK_VALID_FILTER_CHANNEL( pFileObject );
        }

    }
    else
    {
        ASSERT( pDeviceObject == g_pUlAppPoolDeviceObject );

        //
        // It's an app pool.
        //
        // Validate the creation disposition. We allow create and open.
        //

        if (createDisposition != FILE_CREATE && createDisposition != FILE_OPEN)
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // Bind to the specified app pool.
        //

        if (pFileObject->FileName.Buffer == NULL ||
            pFileObject->FileName.Length < sizeof(WCHAR))
        {
            pName = NULL;
            nameLength = 0;
        }
        else
        {
            pName = pFileObject->FileName.Buffer + 1;
            nameLength = pFileObject->FileName.Length - sizeof(WCHAR);
        }

        status = UlAttachProcessToAppPool(
                        pName,
                        nameLength,
                        (BOOLEAN)(createDisposition == FILE_CREATE),
                        pSecurityContext->AccessState,
                        pSecurityContext->DesiredAccess,
                        pIrp->RequestorMode,
                        GET_PP_APP_POOL_PROCESS(pFileObject)
                        );

        if (NT_SUCCESS(status))
        {
            ASSERT( GET_APP_POOL_PROCESS(pFileObject) != NULL );
            MARK_VALID_APP_POOL( pFileObject );
        }
    }

    //
    // Complete the request.
    //

complete:

    if (NT_SUCCESS(status))
    {
        IF_DEBUG( OPEN_CLOSE )
        {
            KdPrint((
                "UlCreate: opened file object = %lx\n",
                pFileObject
                ));
        }
    }

    pIrp->IoStatus.Status = status;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

    UL_LEAVE_DRIVER( "UlCreate" );
    RETURN(status);

}   // UlCreate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\counters.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    counters.cxx

Abstract:

    Contains the performance monitoring counter management code

Author:

    Eric Stenson (ericsten)      25-Sep-2000

Revision History:

--*/

#include    "precomp.h"
#include    "countersp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeCounters )
#pragma alloc_text( PAGE, UlTerminateCounters )
#pragma alloc_text( PAGE, UlCreateSiteCounterEntry )

#if REFERENCE_DEBUG
#pragma alloc_text( PAGE, UlReferenceSiteCounterEntry )
#pragma alloc_text( PAGE, UlDereferenceSiteCounterEntry )
#endif

#pragma alloc_text( PAGE, UlGetGlobalCounters )
#pragma alloc_text( PAGE, UlGetSiteCounters )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlIncCounter
NOT PAGEABLE -- UlDecCounter
NOT PAGEABLE -- UlAddCounter
NOT PAGEABLE -- UlResetCounter

NOT PAGEABLE -- UlIncSiteCounter
NOT PAGEABLE -- UlDecSiteCounter
NOT PAGEABLE -- UlAddSiteCounter
NOT PAGEABLE -- UlResetSiteCounter
NOT PAGEABLE -- UlMaxSiteCounter
NOT PAGEABLE -- UlMaxSiteCounter64
#endif


BOOLEAN                  g_InitCountersCalled = FALSE;
HTTP_GLOBAL_COUNTERS     g_UlGlobalCounters;
FAST_MUTEX               g_SiteCounterListMutex;
LIST_ENTRY               g_SiteCounterListHead  = {NULL,NULL};
LONG                     g_SiteCounterListCount = 0;


/***************************************************************************++

Routine Description:

    Performs global initialization of the global (cache) and instance (per
    site) counters.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeCounters(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( !g_InitCountersCalled );

    UlTrace(PERF_COUNTERS, ("http!UlInitializeCounters\n"));

    if (!g_InitCountersCalled)
    {
        //
        // zero out global counter block
        //

        RtlZeroMemory(&g_UlGlobalCounters, sizeof(HTTP_GLOBAL_COUNTERS));

        //
        // init Site Counter list
        //

        ExInitializeFastMutex(&g_SiteCounterListMutex);
        InitializeListHead(&g_SiteCounterListHead);
        g_SiteCounterListCount = 0;

        // done!
        g_InitCountersCalled = TRUE;
    }

    RETURN( Status );

} // UlInitializeCounters


/***************************************************************************++

Routine Description:

    Performs global cleanup of the global (cache) and instance (per
    site) counters.

--***************************************************************************/
VOID
UlTerminateCounters(
    VOID
    )
{
    //
    // [debug only] Walk list of counters and check the ref count for each counter block.
    //

#if DBG
    PLIST_ENTRY             pEntry;
    PUL_SITE_COUNTER_ENTRY  pCounterEntry;

    if (!g_InitCountersCalled)
    {
        goto End;
    }

    if (IsListEmpty(&g_SiteCounterListHead))
    {
        ASSERT(0 == g_SiteCounterListCount);
        // Good!  No counters left behind!
        goto End;
    }

    //
    // Walk list of Site Counter Entries
    //

    pEntry = g_SiteCounterListHead.Flink;
    while (pEntry != &g_SiteCounterListHead)
    {
        pCounterEntry = CONTAINING_RECORD(
                            pEntry,
                            UL_SITE_COUNTER_ENTRY,
                            ListEntry
                            );

        ASSERT(IS_VALID_SITE_COUNTER_ENTRY(pCounterEntry));

        UlTrace(PERF_COUNTERS,
                ("http!UlTerminateCounters: Error: pCounterEntry %p SiteId %d RefCount %d\n",
                 pCounterEntry,
                 pCounterEntry->Counters.SiteId,
                 pCounterEntry->RefCount
                 ));

        pEntry = pEntry->Flink;
    }

End:
    return;
#endif // DBG
}


///////////////////////////////////////////////////////////////////////////////
// Site Counter Entry
//


/***************************************************************************++

Routine Description:

    Creates a new site counter entry for the given SiteId.

Arguments:

    SiteId - the site id for the site counters.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateSiteCounterEntry(
        IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup,
        ULONG SiteId
    )
{
    NTSTATUS                Status;
    PUL_SITE_COUNTER_ENTRY  pNewEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pConfigGroup != NULL );

    //
    // Setup locals so we know how to cleanup on exit.
    //
    Status     = STATUS_SUCCESS;

    //
    // [debug only] Check to see if the SiteId is already
    // in the list of existing Site Counter Entries.
    //
    ASSERT(!UlpIsInSiteCounterList(SiteId));

    // Alloc new struct w/space from Non Paged Pool
    pNewEntry = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UL_SITE_COUNTER_ENTRY,
                        UL_SITE_COUNTER_ENTRY_POOL_TAG);
    if (pNewEntry)
    {

        UlTrace( PERF_COUNTERS,
            ("http!UlCreateSiteCounterEntry: pNewEntry %p, pConfigGroup %p, SiteId %d\n",
            pNewEntry,
            pConfigGroup,
            SiteId )
            );

        pNewEntry->Signature = UL_SITE_COUNTER_ENTRY_POOL_TAG;

        pNewEntry->RefCount = 1;

        // Zero out counters
        RtlZeroMemory(&(pNewEntry->Counters), sizeof(HTTP_SITE_COUNTERS));

        // Set Site ID
        pNewEntry->Counters.SiteId = SiteId;

        // Init Counter Mutex
        ExInitializeFastMutex(&(pNewEntry->EntryMutex));

        // Add to Site Counter List
        ExAcquireFastMutex(&g_SiteCounterListMutex);

        InsertTailList(
                &g_SiteCounterListHead,
                &(pNewEntry->ListEntry)
                );
        g_SiteCounterListCount++;

        ExReleaseFastMutex(&g_SiteCounterListMutex);

        // Check for wrap-around of Site List count.
        ASSERT( 0 != g_SiteCounterListCount );
    }
    else
    {
        UlTrace( PERF_COUNTERS,
            ("http!UlCreateSiteCounterEntry: Error: NO_MEMORY pConfigGroup %p, SiteId %d\n",
            pNewEntry,
            pConfigGroup,
            SiteId )
            );

        Status = STATUS_NO_MEMORY;
    }

    pConfigGroup->pSiteCounters = pNewEntry;

    RETURN( Status );
}

#if REFERENCE_DEBUG
/***************************************************************************++

Routine Description:

    increments the refcount.

Arguments:

    pEntry - the object to increment.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlReferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    refCount = InterlockedIncrement( &pEntry->RefCount );

    //
    // Tracing.
    //
    WRITE_REF_TRACE_LOG(
        g_pSiteCounterTraceLog,
        REF_ACTION_REFERENCE_SITE_COUNTER_ENTRY,
        refCount,
        pEntry,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("http!UlReferenceSiteCounterEntry pEntry=%p refcount=%d SiteId=%d\n",
         pEntry,
         refCount,
         pEntry->Counters.SiteId)
        );

}   // UlReferenceAppPool


/***************************************************************************++

Routine Description:

    decrements the refcount.  if it hits 0, destruct's the site counter entry
    block.

Arguments:

    pEntry - the object to decrement.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlDereferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    refCount = InterlockedDecrement( &pEntry->RefCount );

    //
    // Tracing.
    //
    WRITE_REF_TRACE_LOG(
        g_pSiteCounterTraceLog,
        REF_ACTION_DEREFERENCE_SITE_COUNTER_ENTRY,
        refCount,
        pEntry,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("http!UlDereferenceSiteCounter pEntry=%p refcount=%d SiteId=%d\n",
         pEntry,
         refCount,
         pEntry->Counters.SiteId)
        );

    //
    // Remove from the list if we hit zero
    //
    if (refCount == 0)
    {
        ASSERT( 0 != g_SiteCounterListCount );

        UlTrace(
            PERF_COUNTERS,
            ("http!UlDereferenceSiteCounter: Removing pEntry=%p  SiteId=%d\n",
             pEntry,
             pEntry->Counters.SiteId)
            );

        // Remove from list
        ExAcquireFastMutex(&g_SiteCounterListMutex);

        RemoveEntryList(&pEntry->ListEntry);
        pEntry->ListEntry.Flink = pEntry->ListEntry.Blink = NULL;
        g_SiteCounterListCount--;

        ExReleaseFastMutex(&g_SiteCounterListMutex);

        // Release memory
        UL_FREE_POOL_WITH_SIG(pEntry, UL_SITE_COUNTER_ENTRY_POOL_TAG);

    }

}
#endif


///////////////////////////////////////////////////////////////////////////////
// Collection
//

/***************************************************************************++

Routine Description:

    Gets the Global (cache) counters.

Arguments:
    pCounter - pointer to block of memory where the counter data should be
    written.

    BlockSize - Maximum size available at pCounter.

    pBytesWritten - On success, count of bytes written into the block of
    memory at pCounter.  On failure, the required count of bytes for the
    memory at pCounter.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetGlobalCounters(
    PVOID   IN OUT pCounter,
    ULONG   IN     BlockSize,
    PULONG  OUT    pBytesWritten
    )
{
    ULONG   i;

    PAGED_CODE();

    ASSERT( pBytesWritten );

    UlTraceVerbose(PERF_COUNTERS,
              ("http!UlGetGlobalCounters\n"));

    if (BlockSize < sizeof(HTTP_GLOBAL_COUNTERS))
    {
        //
        // Tell the caller how many bytes are required.
        //

        *pBytesWritten = sizeof(HTTP_GLOBAL_COUNTERS);
        RETURN( STATUS_BUFFER_TOO_SMALL );
    }

    RtlCopyMemory(
        pCounter,
        &g_UlGlobalCounters,
        sizeof(g_UlGlobalCounters)
        );

    //
    // Zero out any counters that must be zeroed.
    //

    for ( i = 0; i < HttpGlobalCounterMaximum; i++ )
    {
        if (TRUE == aIISULGlobalDescription[i].WPZeros)
        {
            // Zero it out
            UlResetCounter((HTTP_GLOBAL_COUNTER_ID) i);
        }
    }

    *pBytesWritten = sizeof(HTTP_GLOBAL_COUNTERS);

    RETURN( STATUS_SUCCESS );

} // UlpGetGlobalCounters


/***************************************************************************++

Routine Description:

    Gets the Site (instance) counters for all sites

Arguments:

    pCounter - pointer to block of memory where the counter data should be
      written.

    BlockSize - Maximum size available at pCounter.

    pBytesWritten - On success, count of bytes written into the block of
      memory at pCounter.  On failure, the required count of bytes for the
      memory at pCounter.

    pBlocksWritten - (optional) On success, count of site counter blocks
      written to pCounter.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetSiteCounters(
    PVOID   IN OUT pCounter,
    ULONG   IN     BlockSize,
    PULONG  OUT    pBytesWritten,
    PULONG  OUT    pBlocksWritten OPTIONAL
    )
{
    NTSTATUS        Status;
    ULONG           i;
    ULONG           BytesNeeded;
    ULONG           BytesToGo;
    ULONG           BlocksSeen;
    PUCHAR          pBlock;
    PLIST_ENTRY     pEntry;
    PUL_SITE_COUNTER_ENTRY pCounterEntry;

    PAGED_CODE();

    ASSERT( pBytesWritten );

    UlTraceVerbose(PERF_COUNTERS,
            ("http!UlGetSiteCounters\n"));

    //
    // Setup locals so we know how to cleanup on exit.
    //
    Status      = STATUS_SUCCESS;
    BytesToGo   = BlockSize;
    BlocksSeen  = 0;
    pBlock      = (PUCHAR) pCounter;

    BytesNeeded = g_SiteCounterListCount * sizeof(HTTP_SITE_COUNTERS);

    if (BytesNeeded > BlockSize)
    {
        // Need more space
        *pBytesWritten = BytesNeeded;
        Status = STATUS_BUFFER_TOO_SMALL;
        goto End;
    }

    if (IsListEmpty(&g_SiteCounterListHead))
    {
        // No counters to return.
        goto End;
    }

    //
    // NOTE: g_SiteCounterListHead is the only member of
    // the list which isn't contained within a UL_SITE_COUNTER_ENTRY.
    //
    pEntry = g_SiteCounterListHead.Flink;

    //
    // Walk list of Site Counter Entries
    //
    while (pEntry != &g_SiteCounterListHead)
    {
        pCounterEntry = CONTAINING_RECORD(
                            pEntry,
                            UL_SITE_COUNTER_ENTRY,
                            ListEntry
                            );

        if (BytesToGo < sizeof(HTTP_SITE_COUNTERS))
        {
            // NOTE: the only way this can happen is if someone
            // added a site to the end of the site list before
            // we finished walking the counter list.

            *pBytesWritten = BlockSize + sizeof(HTTP_SITE_COUNTERS);
            Status = STATUS_BUFFER_TOO_SMALL;
            goto End;
        }

        RtlCopyMemory(pBlock,
                      &(pCounterEntry->Counters),
                      sizeof(HTTP_SITE_COUNTERS)
                      );

        //
        // Zero out any counters that must be zeroed.
        //

        for ( i = 0; i < HttpSiteCounterMaximum; i++ )
        {
            if (TRUE == aIISULSiteDescription[i].WPZeros)
            {
                // Zero it out
                UlResetSiteCounter(pCounterEntry, (HTTP_SITE_COUNTER_ID) i);
            }
        }

        //
        // Continue to next block
        //

        pBlock     += sizeof(HTTP_SITE_COUNTERS);
        BytesToGo  -= sizeof(HTTP_SITE_COUNTERS);
        BlocksSeen++;

        pEntry = pEntry->Flink;
    }

End:

    //
    // Set callers values
    //

    if (STATUS_SUCCESS == Status)
    {
        // REVIEW: If we failed, *pBytesWritten already contains
        // the bytes required value.
        *pBytesWritten = DIFF(pBlock - ((PUCHAR)pCounter));
    }

    if (pBlocksWritten)
    {
        *pBlocksWritten = BlocksSeen;
    }

    RETURN( Status );

} // UlpGetSiteCounters


#if REFERENCE_DEBUG
///////////////////////////////////////////////////////////////////////////////
// Global Counter functions
//


/***************************************************************************++

Routine Description:

    Increment a Global (cache) performance counter.

Arguments:

    Ctr - ID of Counter to increment

--***************************************************************************/
VOID
UlIncCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpGlobalCounterMaximum );  // REVIEW: signed/unsigned issues?

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlIncCounter (Ctr == %d)\n", Ctr) );

    //
    // figure out offset of Ctr in g_UlGlobalCounters
    //

    pCtr = (PCHAR) &g_UlGlobalCounters;
    pCtr += aIISULGlobalDescription[Ctr].Offset;

    // figure out data size of Ctr and do
    // apropriate thread-safe increment

    if (sizeof(ULONG) == aIISULGlobalDescription[Ctr].Size)
    {
        // ULONG
        InterlockedIncrement((PLONG) pCtr);
    }
    else
    {
        // ULONGLONG
        UlInterlockedIncrement64((PLONGLONG) pCtr);
    }

} // UlIncCounter

/***************************************************************************++

Routine Description:

    Decrement a Global (cache) performance counter.

Arguments:

    Ctr - ID of Counter to decrement

--***************************************************************************/
VOID
UlDecCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpGlobalCounterMaximum );  // REVIEW: signed/unsigned issues?

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlDecCounter (Ctr == %d)\n", Ctr));
    
    //
    // figure out offset of Ctr in g_UlGlobalCounters
    //

    pCtr = (PCHAR) &g_UlGlobalCounters;
    pCtr += aIISULGlobalDescription[Ctr].Offset;

    // figure out data size of Ctr and do
    // apropriate thread-safe increment

    if (sizeof(ULONG) == aIISULGlobalDescription[Ctr].Size)
    {
        // ULONG
        InterlockedDecrement((PLONG) pCtr);
    }
    else
    {
        // ULONGLONG
        UlInterlockedDecrement64((PLONGLONG) pCtr);
    }
}


/***************************************************************************++

Routine Description:

    Add a ULONG value to a Global (cache) performance counter.

Arguments:

    Ctr - ID of counter to which the Value should be added

    Value - The amount to add to the counter


--***************************************************************************/
VOID
UlAddCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr,
    ULONG Value
    )
{
    PCHAR    pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpGlobalCounterMaximum );  // REVIEW: signed/unsigned issues?

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlAddCounter (Ctr == %d, Value == %d)\n", Ctr, Value));
    
    //
    // figure out offset of Ctr in g_UlGlobalCounters
    //

    pCtr = (PCHAR) &g_UlGlobalCounters;
    pCtr += aIISULGlobalDescription[Ctr].Offset;

    //
    // figure out data size of Ctr and do
    // apropriate thread-safe increment
    //

    if (sizeof(ULONG) == aIISULGlobalDescription[Ctr].Size)
    {
        // ULONG
        InterlockedExchangeAdd((PLONG) pCtr, Value);
    }
    else
    {
        // ULONGLONG
        UlInterlockedAdd64((PLONGLONG) pCtr, Value);
    }

} // UlAddCounter


/***************************************************************************++

Routine Description:

    Zero-out a Global (cache) performance counter.

Arguments:

    Ctr - ID of Counter to be reset.


--***************************************************************************/
VOID
UlResetCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr
    )
{
    // Special Case
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpGlobalCounterMaximum );  // REVIEW: signed/unsigned issues?

    UlTraceVerbose(PERF_COUNTERS,
            ("http!UlResetCounter (Ctr == %d)\n", Ctr));
    
    //
    // figure out offset of Ctr in g_UlGlobalCounters
    //

    pCtr = (PCHAR) &g_UlGlobalCounters;
    pCtr += aIISULGlobalDescription[Ctr].Offset;

    //
    // do apropriate "set" for data size of Ctr
    //

    if (sizeof(ULONG) == aIISULGlobalDescription[Ctr].Size)
    {
        // ULONG
        InterlockedExchange((PLONG) pCtr, 0);
    }
    else
    {
        // ULONGLONG
        LONGLONG localCtr;
        LONGLONG originalCtr;
        LONGLONG localZero = 0;

        do {

            localCtr = *((volatile LONGLONG *) pCtr);

            originalCtr = InterlockedCompareExchange64( (PLONGLONG) pCtr,
                                                        localZero,
                                                        localCtr );

        } while (originalCtr != localCtr);

    }
} // UlResetCounter


///////////////////////////////////////////////////////////////////////////////
// Site Counter functions
//

/***************************************************************************++

Routine Description:

    Increment a NonCritical Site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    CounterId - ID of Counter to increment

Returns:

    Nothing

--***************************************************************************/
VOID
UlIncSiteNonCriticalCounterUlong(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR       pCounter;
    PLONG       plValue;

    pCounter = (PCHAR) &(pEntry->Counters);
    pCounter += aIISULSiteDescription[CounterId].Offset;

    plValue = (PLONG) pCounter;
    ++(*plValue);
}

/***************************************************************************++

Routine Description:

    Increment a NonCritical Site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    CounterId - ID of Counter to increment

Returns:

    Nothing

--***************************************************************************/
VOID
UlIncSiteNonCriticalCounterUlonglong(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR       pCounter;
    PLONGLONG   pllValue;


    pCounter = (PCHAR) &(pEntry->Counters);
    pCounter += aIISULSiteDescription[CounterId].Offset;

    pllValue = (PLONGLONG) pCounter;
    ++(*pllValue);
}

/***************************************************************************++

Routine Description:

    Increment a Site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of Counter to increment

Returns:

    Value of counter after incrementing

--***************************************************************************/
LONGLONG
UlIncSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    )
{
    PCHAR   pCtr;
    LONGLONG   llValue;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlIncSiteCounter Ctr=%d SiteId=%d\n",
             Ctr,
             pEntry->Counters.SiteId
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // figure out data size of Ctr and do
    // apropriate thread-safe increment

    if (sizeof(ULONG) == aIISULSiteDescription[Ctr].Size)
    {
        // ULONG
        llValue = (LONGLONG) InterlockedIncrement((PLONG) pCtr);
    }
    else
    {
        // ULONGLONG
        llValue = UlInterlockedIncrement64((PLONGLONG) pCtr);
    }

    return llValue;
}

/***************************************************************************++

Routine Description:

    Decrement a Site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of Counter to decrement

--***************************************************************************/
VOID
UlDecSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlDecSiteCounter Ctr=%d SiteId=%d\n",
             Ctr,
             pEntry->Counters.SiteId
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // figure out data size of Ctr and do
    // apropriate thread-safe increment

    if (sizeof(ULONG) == aIISULSiteDescription[Ctr].Size)
    {
        // ULONG
        InterlockedDecrement((PLONG) pCtr);
    }
    else
    {
        // ULONGLONG
        UlInterlockedDecrement64((PLONGLONG) pCtr);
    }
}

/***************************************************************************++

Routine Description:

    Add a ULONG value to a 32-bit site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter to which the Value should be added

    Value - The amount to add to the counter


--***************************************************************************/
VOID
UlAddSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONG Value
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlAddSiteCounter Ctr=%d SiteId=%d Value=%d\n",
             Ctr,
             pEntry->Counters.SiteId,
             Value
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // figure out data size of Ctr and do
    // apropriate thread-safe increment

    ASSERT(sizeof(ULONG) == aIISULSiteDescription[Ctr].Size);
    InterlockedExchangeAdd((PLONG) pCtr, Value);
}

/***************************************************************************++

Routine Description:

    Add a ULONGLONG value to a 64-bit site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter to which the Value should be added

    Value - The amount to add to the counter


--***************************************************************************/
VOID
UlAddSiteCounter64(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONGLONG llValue
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    
    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlAddSiteCounter64 Ctr=%d SiteId=%d Value=%I64d\n",
             Ctr,
             pEntry->Counters.SiteId,
             llValue
            ));
             

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    ASSERT(sizeof(ULONGLONG) == aIISULSiteDescription[Ctr].Size);
    UlInterlockedAdd64((PLONGLONG) pCtr, llValue);
}



/***************************************************************************++

Routine Description:

    Reset a Site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter to be reset


--***************************************************************************/
VOID
UlResetSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

   
    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlResetSiteCounter Ctr=%d SiteId=%d\n",
             Ctr,
             pEntry->Counters.SiteId
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    //
    // do apropriate "set" for data size of Ctr
    //

    if (sizeof(ULONG) == aIISULSiteDescription[Ctr].Size)
    {
        // ULONG
        InterlockedExchange((PLONG) pCtr, 0);
    }
    else
    {
        // ULONGLONG
        LONGLONG localCtr;
        LONGLONG originalCtr;
        LONGLONG localZero = 0;

        do {

            localCtr = *((volatile LONGLONG *) pCtr);

            originalCtr = InterlockedCompareExchange64( (PLONGLONG) pCtr,
                                                        localZero,
                                                        localCtr );

        } while (originalCtr != localCtr);

    }

}


/***************************************************************************++

Routine Description:

    Determine if a new maximum value of a Site performance counter has been
    hit and set the counter to the new maximum if necessary. (ULONG version)

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter

    Value - possible new maximum (NOTE: Assumes that the counter Ctr is a
      32-bit value)

--***************************************************************************/
VOID
UlMaxSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONG Value
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlMaxSiteCounter Ctr=%d SiteId=%d Value=%d\n",
             Ctr,
             pEntry->Counters.SiteId,
             Value
             ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // Grab counter block mutex
    ExAcquireFastMutex(&pEntry->EntryMutex);

    if (Value > (ULONG) *pCtr)
    {
        InterlockedExchange((PLONG) pCtr, Value);
    }

    // Release counter block mutex
    ExReleaseFastMutex(&pEntry->EntryMutex);

}


/***************************************************************************++

Routine Description:

    Determine if a new maximum value of a Site performance counter has been
    hit and set the counter to the new maximum if necessary. (LONGLONG version)

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter

    Value - possible new maximum (NOTE: Assumes that the counter Ctr is a
      64-bit value)

--***************************************************************************/
VOID
UlMaxSiteCounter64(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    LONGLONG llValue
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlMaxSiteCounter64 Ctr=%d SiteId=%d Value=%I64d\n",
             Ctr,
             pEntry->Counters.SiteId,
             llValue
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // Grab counter block mutex
    ExAcquireFastMutex(&pEntry->EntryMutex);

    if (llValue > (LONGLONG) *pCtr)
    {
        *((PLONGLONG) pCtr) = llValue;
#if 0
        // REVIEW: There *must* be a better way to do this...
        // REVIEW: I want to do: (LONGLONG) *pCtr = llValue;
        // REVIEW: But casting something seems to make it a constant.
        // REVIEW: Also, there isn't an "InterlockedExchange64" for x86.
        // REVIEW: Any suggestions? --EricSten
        RtlCopyMemory(
            pCtr,
            &llValue,
            sizeof(LONGLONG)
            );
#endif // 0
    }

    // Release counter block mutex
    ExReleaseFastMutex(&pEntry->EntryMutex);

}
#endif


/***************************************************************************++

Routine Description:

    Predicate to test if a site counter entry already exists for the given
    SiteId

Arguments:

    SiteId - ID of site

Return Value:

    TRUE if found

    FALSE if not found

--***************************************************************************/
BOOLEAN
UlpIsInSiteCounterList(ULONG SiteId)
{
    PLIST_ENTRY             pEntry;
    PUL_SITE_COUNTER_ENTRY  pCounterEntry;
    BOOLEAN                 IsFound = FALSE;

    if (IsListEmpty(&g_SiteCounterListHead))
    {
        ASSERT(0 == g_SiteCounterListCount);
        // Good!  No counters left behind!
        goto End;
    }

    //
    // Walk list of Site Counter Entries
    //

    pEntry = g_SiteCounterListHead.Flink;
    while (pEntry != &g_SiteCounterListHead)
    {
        pCounterEntry = CONTAINING_RECORD(
                            pEntry,
                            UL_SITE_COUNTER_ENTRY,
                            ListEntry
                            );

        ASSERT(IS_VALID_SITE_COUNTER_ENTRY(pCounterEntry));

        if (SiteId == pCounterEntry->Counters.SiteId)
        {
            IsFound = TRUE;
            goto End;
        }

        pEntry = pEntry->Flink;
    }

End:
    return IsFound;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\debugp.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    debugp.h

Abstract:

    This module contains definitions private to the debug support.
    These declarations are placed in a separate .H file to make it
    easier to access them from within the kernel debugger extension DLL.


Author:

    Keith Moore (keithmo)       07-Apr-1999

Revision History:

--*/


#ifndef _DEBUGP_H_
#define _DEBUGP_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Per-thread data.
//

typedef struct _UL_DEBUG_THREAD_DATA
{
    //
    // Links onto the global list.
    //

    LIST_ENTRY ThreadDataListEntry;

    //
    // The thread.
    //

    PETHREAD pThread;

    //
    // Reference count.
    //

    LONG ReferenceCount;

    //
    // Total number of resources held.
    //

    LONG ResourceCount;

    //
    // If we call another driver they may call our
    // completion routine in-line. Remember that
    // we are inside an external call to avoid
    // getting confused.
    //

    LONG ExternalCallCount;

} UL_DEBUG_THREAD_DATA, *PUL_DEBUG_THREAD_DATA;


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _DEBUGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\debug.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains debug support routines.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"
#include "debugp.h"


#if DBG


#undef ExAllocatePool
#undef ExFreePool


//
// Private constants.
//

#define NUM_THREAD_HASH_BUCKETS 31
#define RANDOM_CONSTANT         314159269UL
#define RANDOM_PRIME            1000000007UL

#define HASH_SCRAMBLE(hash)                                                 \
    (ULONG_PTR)((((ULONG_PTR)(hash)) * (ULONG_PTR)RANDOM_CONSTANT)          \
        % (ULONG_PTR)RANDOM_PRIME)

#define HASH_FROM_THREAD(thrd)                                              \
    ((ULONG)(HASH_SCRAMBLE(thrd) % (ULONG_PTR)NUM_THREAD_HASH_BUCKETS))

#define SET_RESOURCE_OWNED_EXCLUSIVE( pLock )                               \
    (pLock)->pExclusiveOwner = PsGetCurrentThread()

#define SET_RESOURCE_NOT_OWNED_EXCLUSIVE( pLock )                           \
    (pLock)->pPreviousOwner = (pLock)->pExclusiveOwner;                     \
    (pLock)->pExclusiveOwner = NULL

#define SET_SPIN_LOCK_OWNED( pLock )                                        \
    do {                                                                    \
        (pLock)->pOwnerThread = PsGetCurrentThread();                       \
        (pLock)->OwnerProcessor = (ULONG)KeGetCurrentProcessorNumber();            \
    } while (FALSE)

#define SET_SPIN_LOCK_NOT_OWNED( pLock )                                    \
    do {                                                                    \
        (pLock)->pOwnerThread = NULL;                                       \
        (pLock)->OwnerProcessor = (ULONG)-1L;                               \
    } while (FALSE)


//
// Private types.
//

typedef struct _UL_POOL_HEADER {
    PSTR pFileName;
    USHORT LineNumber;
    SIZE_T Size;
    ULONG Tag;
} UL_POOL_HEADER, *PUL_POOL_HEADER;

typedef struct _UL_THREAD_HASH_BUCKET
{
    UL_SPIN_LOCK BucketSpinLock;
    LIST_ENTRY BucketListHead;

} UL_THREAD_HASH_BUCKET, *PUL_THREAD_HASH_BUCKET;


//
// Private prototypes.
//

VOID
UlpDbgUpdatePoolCounter(
    IN OUT PLARGE_INTEGER pAddend,
    IN SIZE_T Increment
    );

PSTR
UlpDbgFindFilePart(
    IN PSTR pPath
    );

PUL_DEBUG_THREAD_DATA
UlpDbgFindThread(
    BOOLEAN OkToCreate,
    PSTR pFileName,
    USHORT LineNumber
    );

VOID
UlpDbgDereferenceThread(
    IN PUL_DEBUG_THREAD_DATA pData
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

//
// Private macros.
//
#define ULP_DBG_FIND_THREAD() \
    UlpDbgFindThread(FALSE, (PSTR)__FILE__, (USHORT)__LINE__)

#define ULP_DBG_FIND_OR_CREATE_THREAD() \
    UlpDbgFindThread(TRUE, (PSTR)__FILE__, (USHORT)__LINE__)

#define ULP_DBG_DEREFERENCE_THREAD(pData) \
    UlpDbgDereferenceThread((pData) REFERENCE_DEBUG_ACTUAL_PARAMS)


#ifdef ALLOC_PRAGMA
#if DBG
#pragma alloc_text( INIT, UlDbgInitializeDebugData )
#pragma alloc_text( PAGE, UlDbgTerminateDebugData )
#pragma alloc_text( PAGE, UlDbgAcquireResourceExclusive )
#pragma alloc_text( PAGE, UlDbgAcquireResourceShared )
#pragma alloc_text( PAGE, UlDbgReleaseResource )
#pragma alloc_text( PAGE, UlDbgConvertExclusiveToShared)
// #pragma alloc_text( PAGE, UlDbgTryToAcquireResourceExclusive)
#pragma alloc_text( PAGE, UlDbgResourceOwnedExclusive )
#pragma alloc_text( PAGE, UlDbgResourceUnownedExclusive )
#endif  // DBG
#if 0
NOT PAGEABLE -- UlDbgAllocatePool
NOT PAGEABLE -- UlDbgFreePool
NOT PAGEABLE -- UlDbgInitializeSpinLock
NOT PAGEABLE -- UlDbgAcquireSpinLock
NOT PAGEABLE -- UlDbgReleaseSpinLock
NOT PAGEABLE -- UlDbgAcquireSpinLockAtDpcLevel
NOT PAGEABLE -- UlDbgReleaseSpinLockFromDpcLevel
NOT PAGEABLE -- UlDbgSpinLockOwned
NOT PAGEABLE -- UlDbgSpinLockUnowned
NOT PAGEABLE -- UlDbgExceptionFilter
NOT PAGEABLE -- UlDbgInvalidCompletionRoutine
NOT PAGEABLE -- UlDbgStatus
NOT PAGEABLE -- UlDbgEnterDriver
NOT PAGEABLE -- UlDbgLeaveDriver
NOT PAGEABLE -- UlDbgInitializeResource
NOT PAGEABLE -- UlDbgDeleteResource
NOT PAGEABLE -- UlDbgAllocateIrp
NOT PAGEABLE -- UlDbgFreeIrp
NOT PAGEABLE -- UlDbgCallDriver
NOT PAGEABLE -- UlDbgCompleteRequest
NOT PAGEABLE -- UlDbgAllocateMdl
NOT PAGEABLE -- UlDbgFreeMdl
NOT PAGEABLE -- UlpDbgUpdatePoolCounter
NOT PAGEABLE -- UlpDbgFindFilePart
NOT PAGEABLE -- UlpDbgFindThread
NOT PAGEABLE -- UlpDbgDereferenceThread
#endif
#endif  // ALLOC_PRAGMA


//
// Private globals.
//

UL_THREAD_HASH_BUCKET g_DbgThreadHashBuckets[NUM_THREAD_HASH_BUCKETS];
LONG g_DbgThreadCreated;
LONG g_DbgThreadDestroyed;
UL_SPIN_LOCK g_DbgSpinLock;
LIST_ENTRY g_DbgGlobalResourceListHead;


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initializes global debug-specific data.

--***************************************************************************/
VOID
UlDbgInitializeDebugData(
    VOID
    )
{
    ULONG i;
    CHAR spinLockName[sizeof("g_DbgThreadHashBuckets[00000].BucketSpinLock")];

    //
    // Initialize the lock lists.
    //

    UlInitializeSpinLock( &g_DbgSpinLock, "g_DbgSpinLock" );
    InitializeListHead( &g_DbgGlobalResourceListHead );

    //
    // Initialize the thread hash buckets.
    //

    for (i = 0 ; i < NUM_THREAD_HASH_BUCKETS ; i++)
    {
        sprintf(
            spinLockName,
            "g_DbgThreadHashBuckets[%lu].BucketSpinLock",
            i
            );

        UlInitializeSpinLock(
            &g_DbgThreadHashBuckets[i].BucketSpinLock,
            spinLockName
            );

        InitializeListHead(
            &g_DbgThreadHashBuckets[i].BucketListHead
            );
    }

}   // UlDbgInitializeDebugData


/***************************************************************************++

Routine Description:

    Undoes any initialization performed in UlDbgInitializeDebugData().

--***************************************************************************/
VOID
UlDbgTerminateDebugData(
    VOID
    )
{
    ULONG i;

    //
    // Ensure the thread hash buckets are empty.
    //

    for (i = 0 ; i < NUM_THREAD_HASH_BUCKETS ; i++)
    {
        ASSERT( IsListEmpty( &g_DbgThreadHashBuckets[i].BucketListHead ) );
    }

    //
    // Ensure the lock lists are empty.
    //

    ASSERT( IsListEmpty( &g_DbgGlobalResourceListHead ) );

}   // UlDbgTerminateDebugData


/***************************************************************************++

Routine Description:

    Prettyprints a buffer to DbgPrint output. More or less turns it back
    into a C-style string.

    CODEWORK: produce a Unicode version of this helper function

Arguments:

    Buffer - Buffer to prettyprint

    BufferSize - number of bytes to prettyprint

Return Value:

    ULONG - number of prettyprinted characters sent to DbgPrint,
        excluding inserted newlines.

--***************************************************************************/
ULONG
UlDbgPrettyPrintBuffer(
    const UCHAR* pBuffer,
    ULONG        BufferSize
    )
{
    int     i;
    CHAR    OutputBuffer[200];
    PCHAR   pOut = OutputBuffer;
    BOOLEAN CrLfNeeded = FALSE, JustCrLfd = FALSE;
    ULONG   cch = 0;

    if (pBuffer == NULL  ||  BufferSize == 0)
        return 0;

    for (i = 0;  i < (int)BufferSize;  ++i)
    {
        UCHAR ch = pBuffer[i];

        if ('\r' == ch)         // CR
        {
            *pOut++ = '\\'; *pOut++ = 'r';
            if (i + 1 == BufferSize  ||  pBuffer[i + 1] != '\n')
                CrLfNeeded = TRUE;
        }
        else if ('\n' == ch)    // LF
        {
            *pOut++ = '\\'; *pOut++ = 'n';
            CrLfNeeded = TRUE;
        }
        else if ('\t' == ch)    // TAB
        {
            *pOut++ = '\\'; *pOut++ = 't';
        }
        else if ('\0' == ch)    // NUL
        {
            *pOut++ = '\\'; *pOut++ = '0';
        }
        else if ('\\' == ch)    // \ (backslash)
        {
            *pOut++ = '\\'; *pOut++ = '\\';
        }
        else if (ch < 0x20  ||  ch == 127)  // control chars
        {
            const UCHAR HexString[] = "0123456789abcdef";

            *pOut++ = '\\'; *pOut++ = 'x';
            *pOut++ = HexString[ch >> 4]; *pOut++ = HexString[ch & 0xf];
        }
        else
        {
            *pOut++ = ch;
        }

        if (pOut - OutputBuffer >= sizeof(OutputBuffer) - 4) // strlen("\xAB")
            CrLfNeeded = TRUE;

        if (CrLfNeeded)
        {
            *pOut++ = '\n'; *pOut = '\0';
            DbgPrint(OutputBuffer);
            cch += (ULONG) (pOut - 1  - OutputBuffer);
            pOut = OutputBuffer;
            CrLfNeeded = FALSE;
            JustCrLfd  = TRUE;
        }
        else
        {
            JustCrLfd = FALSE;
        }
    }

    if (! JustCrLfd)
    {
        *pOut++ = '\n'; *pOut = '\0';
        DbgPrint(OutputBuffer);
        cch += (ULONG) (pOut - 1  - OutputBuffer);
    }

    return cch;
} // UlDbgPrettyPrintBuffer



/***************************************************************************++

Routine Description:

    Debug memory allocator. Allocates a block of pool with a header
    containing the filename & line number of the caller, plus the
    tag for the data.

Arguments:

    PoolType - Supplies the pool to allocate from. Must be either
        NonPagedPool, NonPagedPoolMustSucceed, or PagedPool.

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies a four-byte tag for the pool block. Useful for
        debugging leaks.

    pFileName - Supplies the filename of the caller.
        function.

    LineNumber - Supplies the line number of the caller.

Return Value:

    PVOID - Pointer to the allocated block if successful, NULL otherwise.

--***************************************************************************/
PVOID
UlDbgAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_POOL_HEADER pHeader;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool ||
            PoolType == NonPagedPoolMustSucceed ||
            PoolType == NonPagedPoolCacheAligned ||
            PoolType == PagedPool );

    ASSERT( IS_VALID_TAG( Tag ) );

    //
    // Allocate the block with additional space for the header.
    //

    pHeader = (PUL_POOL_HEADER)(
                    ExAllocatePoolWithTag(
                        PoolType,
                        NumberOfBytes + sizeof(*pHeader),
                        Tag
                        )
                    );

    if (pHeader == NULL)
    {
        return NULL;
    }

    //
    // Initialize the header.
    //

    pHeader->pFileName = pFileName;
    pHeader->LineNumber = LineNumber;
    pHeader->Size = NumberOfBytes;
    pHeader->Tag = Tag;

    //
    // Fill the body with garbage.
    //

    RtlFillMemory( (PVOID)(pHeader + 1), NumberOfBytes, '\xcc' );

    //
    // Update the statistics.
    //

    InterlockedIncrement(
        &g_UlDebugStats.TotalAllocations
        );

    UlpDbgUpdatePoolCounter(
        &g_UlDebugStats.TotalBytesAllocated,
        NumberOfBytes
        );

    //
    // Return a pointer to the body.
    //

    return (PVOID)(pHeader + 1);

}   // UlDbgAllocatePool


/***************************************************************************++

Routine Description:

    Frees memory allocated by UlDbgAllocatePool(), ensuring that the tags
    match.

Arguments:

    pPointer - Supplies a pointer to the pool block to free.

    Tag - Supplies the tag for the block to be freed. If the supplied
        tag does not match the tag of the allocated block, an assertion
        failure is generated.

--***************************************************************************/
VOID
UlDbgFreePool(
    IN PVOID pPointer,
    IN ULONG Tag
    )
{
    PUL_POOL_HEADER pHeader;

    //
    // Get a pointer to the header.
    //

    pHeader = (PUL_POOL_HEADER)pPointer - 1;

    //
    // Update the statistics.
    //

    InterlockedIncrement(
        &g_UlDebugStats.TotalFrees
        );

    UlpDbgUpdatePoolCounter(
        &g_UlDebugStats.TotalBytesFreed,
        pHeader->Size
        );

    //
    // Validate the tag.
    //

    if( pHeader->Tag == Tag )
    {
        ASSERT( IS_VALID_TAG( Tag ) );
        pHeader->Tag = MAKE_FREE_TAG( Tag );
    }
    else
    {
        ASSERT( !"Invalid tag" );
    }

    //
    // Actually free the block.
    //

    MyFreePoolWithTag(
        (PVOID)pHeader,
        Tag
        );

}   // UlDbgFreePool


/***************************************************************************++

Routine Description:

    Initializes an instrumented spinlock.

--***************************************************************************/
VOID
UlDbgInitializeSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pSpinLockName,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Initialize the spinlock.
    //

    RtlZeroMemory( pSpinLock, sizeof(*pSpinLock) );
    pSpinLock->pSpinLockName = pSpinLockName;
    KeInitializeSpinLock( &pSpinLock->KSpinLock );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    //
    // Update the global statistics.
    //

    InterlockedIncrement( &g_UlDebugStats.TotalSpinLocksInitialized );

}   // UlDbgInitializeSpinLock


/***************************************************************************++

Routine Description:

    Acquires an instrumented spinlock.

--***************************************************************************/
VOID
UlDbgAcquireSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKIRQL pOldIrql,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );

    //
    // Acquire the lock.
    //

    KeAcquireSpinLock(
        &pSpinLock->KSpinLock,
        pOldIrql
        );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( UlDbgSpinLockUnowned( pSpinLock ) );
    SET_SPIN_LOCK_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->Acquisitions++;
    pSpinLock->pLastAcquireFileName = pFileName;
    pSpinLock->LastAcquireLineNumber = LineNumber;

    InterlockedIncrement(
        &g_UlDebugStats.TotalAcquisitions
        );

}   // UlDbgAcquireSpinLock


/***************************************************************************++

Routine Description:

    Releases an instrumented spinlock.

--***************************************************************************/
VOID
UlDbgReleaseSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN KIRQL OldIrql,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    InterlockedIncrement(
        &g_UlDebugStats.TotalReleases
        );

    pSpinLock->Releases++;
    pSpinLock->pLastReleaseFileName = pFileName;
    pSpinLock->LastReleaseLineNumber = LineNumber;

    //
    // Release the lock.
    //

    KeReleaseSpinLock(
        &pSpinLock->KSpinLock,
        OldIrql
        );

}   // UlDbgReleaseSpinLock


/***************************************************************************++

Routine Description:

    Acquires an instrumented spinlock while running at DPC level.

--***************************************************************************/
VOID
UlDbgAcquireSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );

    //
    // Acquire the lock.
    //

    KeAcquireSpinLockAtDpcLevel(
        &pSpinLock->KSpinLock
        );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->AcquisitionsAtDpcLevel++;
    pSpinLock->pLastAcquireFileName = pFileName;
    pSpinLock->LastAcquireLineNumber = LineNumber;

    InterlockedIncrement(
        &g_UlDebugStats.TotalAcquisitionsAtDpcLevel
        );

}   // UlDbgAcquireSpinLockAtDpcLevel


/***************************************************************************++

Routine Description:

    Releases an instrumented spinlock acquired at DPC level.

--***************************************************************************/
VOID
UlDbgReleaseSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    InterlockedIncrement(
        &g_UlDebugStats.TotalReleasesFromDpcLevel
        );

    pSpinLock->ReleasesFromDpcLevel++;
    pSpinLock->pLastReleaseFileName = pFileName;
    pSpinLock->LastReleaseLineNumber = LineNumber;

    //
    // Release the lock.
    //

    KeReleaseSpinLockFromDpcLevel(
        &pSpinLock->KSpinLock
        );

}   // UlDbgReleaseSpinLockAtDpcLevel


/***************************************************************************++

Routine Description:

    Acquires an instrumented in-stack-queue spinlock.

--***************************************************************************/
VOID
UlDbgAcquireInStackQueuedSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );

    //
    // Acquire the lock.
    //

    KeAcquireInStackQueuedSpinLock(
        &pSpinLock->KSpinLock,
        pLockHandle
        );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( UlDbgSpinLockUnowned( pSpinLock ) );
    SET_SPIN_LOCK_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->Acquisitions++;
    pSpinLock->pLastAcquireFileName = pFileName;
    pSpinLock->LastAcquireLineNumber = LineNumber;

    InterlockedIncrement(
        &g_UlDebugStats.TotalAcquisitions
        );

}   // UlDbgAcquireInStackQueuedSpinLock


/***************************************************************************++

Routine Description:

    Releases an instrumented in-stack-queue spinlock.

--***************************************************************************/
VOID
UlDbgReleaseInStackQueuedSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    InterlockedIncrement(
        &g_UlDebugStats.TotalReleases
        );

    pSpinLock->Releases++;
    pSpinLock->pLastReleaseFileName = pFileName;
    pSpinLock->LastReleaseLineNumber = LineNumber;

    //
    // Release the lock.
    //

    KeReleaseInStackQueuedSpinLock(
        pLockHandle
        );

}   // UlDbgReleaseInStackQueuedSpinLock


/***************************************************************************++

Routine Description:

    Acquires an instrumented in-stack-queue spinlock while running at DPC level.

--***************************************************************************/
VOID
UlDbgAcquireSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );

    //
    // Acquire the lock.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel(
        &pSpinLock->KSpinLock,
        pLockHandle
        );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->AcquisitionsAtDpcLevel++;
    pSpinLock->pLastAcquireFileName = pFileName;
    pSpinLock->LastAcquireLineNumber = LineNumber;

    InterlockedIncrement(
        &g_UlDebugStats.TotalAcquisitionsAtDpcLevel
        );

}   // UlDbgAcquireInStackQueuedSpinLockAtDpcLevel


/***************************************************************************++

Routine Description:

    Releases an instrumented in-stack-queue spinlock acquired at DPC level.

--***************************************************************************/
VOID
UlDbgReleaseSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    InterlockedIncrement(
        &g_UlDebugStats.TotalReleasesFromDpcLevel
        );

    pSpinLock->ReleasesFromDpcLevel++;
    pSpinLock->pLastReleaseFileName = pFileName;
    pSpinLock->LastReleaseLineNumber = LineNumber;

    //
    // Release the lock.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(
        pLockHandle
        );

}   // UlDbgReleaseInStackQueuedSpinLockFromDpcLevel


/***************************************************************************++

Routine Description:

    Determines if the specified spinlock is owned by the current thread.

Arguments:

    pSpinLock - Supplies the spinlock to test.

Return Value:

    BOOLEAN - TRUE if the spinlock is owned by the current thread, FALSE
        otherwise.

--***************************************************************************/
BOOLEAN
UlDbgSpinLockOwned(
    IN PUL_SPIN_LOCK pSpinLock
    )
{
    if (pSpinLock->pOwnerThread == PsGetCurrentThread())
    {
        ASSERT( pSpinLock->OwnerProcessor == (ULONG)KeGetCurrentProcessorNumber() );
        return TRUE;
    }

    return FALSE;

}   // UlDbgSpinLockOwned


/***************************************************************************++

Routine Description:

    Determines if the specified spinlock is unowned.

Arguments:

    pSpinLock - Supplies the spinlock to test.

Return Value:

    BOOLEAN - TRUE if the spinlock is unowned, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlDbgSpinLockUnowned(
    IN PUL_SPIN_LOCK pSpinLock
    )
{
    if (pSpinLock->pOwnerThread == NULL)
    {
        return TRUE;
    }

    return FALSE;

}   // UlDbgSpinLockUnowned


/***************************************************************************++

Routine Description:

    Filter for exceptions caught with try/except.

Arguments:

    pExceptionPointers - Supplies information identifying the source
        and type of exception raised.

    pFileName - Supplies the name of the file generating the exception.

    LineNumber - Supplies the line number of the exception filter that
        caught the exception.

Return Value:

    LONG - Should always be EXCEPTION_EXECUTE_HANDLER

--***************************************************************************/
LONG
UlDbgExceptionFilter(
    IN PEXCEPTION_POINTERS pExceptionPointers,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Protect ourselves just in case the process is completely messed up.
    //

    __try
    {
        //
        // Whine about it.
        //

        KdPrint((
            "UlDbgExceptionFilter: exception %08lx @ %p, caught in %s:%d\n",
            pExceptionPointers->ExceptionRecord->ExceptionCode,
            pExceptionPointers->ExceptionRecord->ExceptionAddress,
            UlpDbgFindFilePart( pFileName ),
            LineNumber
            ));
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // Not much we can do here...
        //

        NOTHING;
    }

    return EXCEPTION_EXECUTE_HANDLER;

}   // UlDbgExceptionFilter

/***************************************************************************++

Routine Description:

    Sometimes it's not acceptable to proceed with warnings ( as status ) after
    we caught an exception. I.e. Caught an missaligned warning during sendresponse
    and called the IoCompleteRequest with status misaligned. This will cause Io
    Manager to complete request to port, even though we don't want it to happen.

    In that case we have to carefully replace warnings with a generic error.

Arguments:

    pExceptionPointers - Supplies information identifying the source
        and type of exception raised.

    pFileName - Supplies the name of the file generating the exception.

    LineNumber - Supplies the line number of the exception filter that
        caught the exception.

Return Value:

    NTSTATUS - Converted error value : UL_DEFAULT_ERROR_ON_EXCEPTION

--***************************************************************************/

NTSTATUS
UlDbgConvertExceptionCode(
    IN NTSTATUS status,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Whine about it.
    //

    KdPrint((
        "UlDbgConvertExceptionCode: exception %08lx converted to %08lx, at %s:%d\n",
        status,
        UL_DEFAULT_ERROR_ON_EXCEPTION,
        UlpDbgFindFilePart( pFileName ),
        LineNumber
        ));

    return UL_DEFAULT_ERROR_ON_EXCEPTION;
}

/***************************************************************************++

Routine Description:

    Completion handler for incomplete IRP contexts.

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

--***************************************************************************/
VOID
UlDbgInvalidCompletionRoutine(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    DbgPrint(
        "UlDbgInvalidCompletionRoutine called!\n"
        "    pCompletionContext = %p\n"
        "    Status = %08lx\n"
        "    Information = %p\n",
        pCompletionContext,
        Status,
        Information
        );

    ASSERT( !"UlDbgInvalidCompletionRoutine called!" );

}   // UlDbgInvalidCompletionRoutine


/***************************************************************************++

Routine Description:

    Hook for catching failed operations. This routine is called within each
    routine with the completion status.

Arguments:

    Status - Supplies the completion status.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDbgStatus(
    IN NTSTATUS Status,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // paulmcd: ignore STATUS_END_OF_FILE.  this is a non-fatal return value
    //

    if (!NT_SUCCESS(Status) && Status != STATUS_END_OF_FILE)
    {
        if (g_UlVerboseErrors)
        {
            DbgPrint(
                "UlDbgStatus: %s:%lu returning %08lx\n",
                UlpDbgFindFilePart( pFileName ),
                LineNumber,
                Status
                );
        }

        if (g_UlBreakOnError)
        {
            DbgBreakPoint();
        }
    }

    return Status;

}   // UlDbgStatus


/***************************************************************************++

Routine Description:

    Routine invoked upon entry into the driver.

Arguments:

    pFunctionName - Supplies the name of the function used to enter
        the driver.

    pIrp - Supplies an optional IRP to log.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
VOID
UlDbgEnterDriver(
    IN PSTR pFunctionName,
    IN PIRP pIrp OPTIONAL,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Log the IRP.
    //

    if (pIrp != NULL)
    {
        WRITE_IRP_TRACE_LOG(
            g_pIrpTraceLog,
            IRP_ACTION_INCOMING_IRP,
            pIrp,
            pFileName,
            LineNumber
            );
    }

    //
    // Find/create an entry for the current thread.
    //

    pData = ULP_DBG_FIND_OR_CREATE_THREAD();

    if (pData != NULL)
    {

        //
        // This should be the first time we enter the driver
        // unless we are stealing this thread due to an interrupt,
        // or we are calling another driver and they are calling
        // our completion routine in-line.
        //

        ASSERT( KeGetCurrentIrql() > PASSIVE_LEVEL ||
                pData->ExternalCallCount > 0 ||
                pData->ResourceCount == 0 );
    }

}   // UlDbgEnterDriver


/***************************************************************************++

Routine Description:

    Routine invoked upon exit from the driver.

Arguments:

    pFunctionName - Supplies the name of the function used to enter
        the driver.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
VOID
UlDbgLeaveDriver(
    IN PSTR pFunctionName,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Ensure no resources are acquired, then kill the thread data.
        //
        // we might have a resource acquired if we borrowed the thread
        // due to an interrupt.
        //
        // N.B. We dereference the thread data twice: once for the
        //      call to ULP_DBG_FIND_THREAD() above, once for the call
        //      made when entering the driver.
        //

        ASSERT( KeGetCurrentIrql() > PASSIVE_LEVEL ||
                pData->ExternalCallCount > 0 ||
                pData->ResourceCount == 0 );

        ASSERT( pData->ReferenceCount >= 2 );
        ULP_DBG_DEREFERENCE_THREAD( pData );
        ULP_DBG_DEREFERENCE_THREAD( pData );
    }

}   // UlDbgLeaveDriver


/***************************************************************************++

Routine Description:

    Initialize an instrumented resource.

Arguments:

    pResource - Supplies the resource to initialize.

    pResourceName - Supplies a display name for the resource.

    Parameter - Supplies a ULONG_PTR parameter passed into sprintf()
        when creating the resource name.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDbgInitializeResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pResourceName,
    IN ULONG_PTR Parameter,
    IN ULONG OwnerTag,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    NTSTATUS status;
    KIRQL oldIrql;

    //
    // Initialize the resource.
    //

    status = ExInitializeResource( &pResource->Resource );

    if (NT_SUCCESS(status))
    {
        pResource->ExclusiveCount = 0;
        pResource->SharedCount = 0;
        pResource->ReleaseCount = 0;
        pResource->OwnerTag = OwnerTag;

        _snprintf(
            (char*) pResource->ResourceName,
            sizeof(pResource->ResourceName) - 1,
            pResourceName,
            Parameter
            );

        pResource->ResourceName[sizeof(pResource->ResourceName) - 1] = '\0';

        SET_RESOURCE_NOT_OWNED_EXCLUSIVE( pResource );

        //
        // Put it on the global list.
        //

        UlAcquireSpinLock( &g_DbgSpinLock, &oldIrql );
        InsertHeadList(
            &g_DbgGlobalResourceListHead,
            &pResource->GlobalResourceListEntry
            );
        UlReleaseSpinLock( &g_DbgSpinLock, oldIrql );
    }
    else
    {
        pResource->GlobalResourceListEntry.Flink = NULL;
    }

    return status;

}   // UlDbgInitializeResource


/***************************************************************************++

Routine Description:

    Deletes an instrumented resource.

Arguments:

    pResource - Supplies the resource to delete.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDbgDeleteResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    NTSTATUS status;
    KIRQL oldIrql;
    PETHREAD pExclusiveOwner;

    //
    // Sanity check.
    //

    pExclusiveOwner = pResource->pExclusiveOwner;

    if (pExclusiveOwner != NULL)
    {
        DbgBreakPoint();

        DbgPrint(
            "Resource %p [%s] owned by thread %p\n",
            pResource,
            pResource->ResourceName,
            pExclusiveOwner
            );

        DbgBreakPoint();
    }

//    ASSERT( UlDbgResourceUnownedExclusive( pResource ) );

    //
    // Delete the resource.
    //

    status = ExDeleteResource( &pResource->Resource );

    //
    // Remove it from the global list.
    //

    if (pResource->GlobalResourceListEntry.Flink != NULL)
    {
        UlAcquireSpinLock( &g_DbgSpinLock, &oldIrql );
        RemoveEntryList( &pResource->GlobalResourceListEntry );
        UlReleaseSpinLock( &g_DbgSpinLock, oldIrql );
    }

    return status;

}   // UlDbgDeleteResource


/***************************************************************************++

Routine Description:

    Acquires exclusive access to an instrumented resource.

Arguments:

    pResource - Supplies the resource to acquire.

    Wait - Supplies TRUE if the thread should block waiting for the
        resource.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    BOOLEAN - Completion status.

--***************************************************************************/
BOOLEAN
UlDbgAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;
    BOOLEAN result;

    //
    // Sanity check.
    //
    ASSERT(pResource);
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the resource count.
        //

        pData->ResourceCount++;
        ASSERT( pData->ResourceCount > 0 );

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_ACQUIRE_RESOURCE_EXCLUSIVE,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }

    //
    // Acquire the resource.
    //

    KeEnterCriticalRegion();
    result = ExAcquireResourceExclusive( &pResource->Resource, Wait );

    //
    // either we already own it (recursive acquisition), or nobody owns it.
    //

    ASSERT( UlDbgResourceUnownedExclusive( pResource ) ||
            UlDbgResourceOwnedExclusive( pResource ) );

    //
    // Mark it as owned by the current thread.
    //

    SET_RESOURCE_OWNED_EXCLUSIVE( pResource );

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->ExclusiveCount );

    return result;

}   // UlDbgAcquireResourceExclusive


/***************************************************************************++

Routine Description:

    Acquires shared access to an instrumented resource.

Arguments:

    pResource - Supplies the resource to acquire.

    Wait - Supplies TRUE if the thread should block waiting for the
        resource.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    BOOLEAN - Completion status.

--***************************************************************************/
BOOLEAN
UlDbgAcquireResourceShared(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;
    BOOLEAN result;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the resource count.
        //

        pData->ResourceCount++;
        ASSERT( pData->ResourceCount > 0 );

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_ACQUIRE_RESOURCE_SHARED,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }

    //
    // Acquire the resource.
    //

    KeEnterCriticalRegion();
    result = ExAcquireResourceShared( &pResource->Resource, Wait );

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->SharedCount );

    return result;

}   // UlDbgAcquireResourceShared


/***************************************************************************++

Routine Description:

    Releases an instrumented resource.

Arguments:

    pResource - Supplies the resource to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
VOID
UlDbgReleaseResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the resource count.
        //

        ASSERT( pData->ResourceCount > 0 );
        pData->ResourceCount--;

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_RELEASE_RESOURCE,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }

    //
    // Mark it as unowned.
    //

    SET_RESOURCE_NOT_OWNED_EXCLUSIVE( pResource );

    //
    // Release the resource.
    //

    ExReleaseResource( &pResource->Resource );
    KeLeaveCriticalRegion();

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->ReleaseCount );


}   // UlDbgReleaseResource



/***************************************************************************++

Routine Description:

    This routine converts the specified resource from acquired for exclusive
    access to acquired for shared access.

Arguments:

    pResource - Supplies the resource to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
VOID
UlDbgConvertExclusiveToShared(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;

    ASSERT(UlDbgResourceOwnedExclusive(pResource));

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Don't update the resource count.
        //

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_CONVERT_RESOURCE_EXCLUSIVE_TO_SHARED,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }

    //
    // Acquire the resource.
    //

    ExConvertExclusiveToSharedLite( &pResource->Resource );

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->SharedCount );
    SET_RESOURCE_NOT_OWNED_EXCLUSIVE( pResource );

}   // UlDbgConvertExclusiveToShared


#ifdef UL_TRY_RESOURCE_EXCLUSIVE
// ExTryToAcquireResourceExclusiveLite is not currently exported
// from ntoskrnl

/***************************************************************************++

Routine Description:

    The routine attempts to acquire the specified resource for exclusive
    access.

Arguments:

    pResource - Supplies the resource to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
BOOLEAN
UlDbgTryToAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;
    BOOLEAN result;

    //
    // Sanity check.
    //
    ASSERT(pResource);
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Acquire the resource.
    //

    KeEnterCriticalRegion();
    result = ExTryToAcquireResourceExclusiveLite( &pResource->Resource );

    // Did we acquire the lock exclusively?
    if (! result)
    {
        KeLeaveCriticalRegion();
        return FALSE;
    }

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the resource count.
        //

        pData->ResourceCount++;
        ASSERT( pData->ResourceCount > 0 );

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_TRY_ACQUIRE_RESOURCE_EXCLUSIVE,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }

    //
    // either we already own it (recursive acquisition), or nobody owns it.
    //

    ASSERT( UlDbgResourceUnownedExclusive( pResource ) ||
            UlDbgResourceOwnedExclusive( pResource ) );

    //
    // Mark it as owned by the current thread.
    //

    SET_RESOURCE_OWNED_EXCLUSIVE( pResource );

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->ExclusiveCount );

    return result;

}   // UlDbgTryToAcquireResourceExclusive

#endif // UL_TRY_RESOURCE_EXCLUSIVE


/***************************************************************************++

Routine Description:

    Determines if the specified resource is owned exclusively by the
    current thread.

Arguments:

    pResource - Supplies the resource to test.

Return Value:

    BOOLEAN - TRUE if the resource is owned exclusively by the current
        thread, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlDbgResourceOwnedExclusive(
    IN PUL_ERESOURCE pResource
    )
{
    if (pResource->pExclusiveOwner == PsGetCurrentThread())
    {
        return TRUE;
    }

    // CODEWORK: handle the case of recursive exclusive locks correctly

    return FALSE;

}   // UlDbgResourceOwnedExclusive


/***************************************************************************++

Routine Description:

    Determines if the specified resource is not currently owned exclusively
    by any thread.

Arguments:

    pResource - Supplies the resource to test.

Return Value:

    BOOLEAN - TRUE if the resource is not currently owned exclusively by
        any thread, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlDbgResourceUnownedExclusive(
    IN PUL_ERESOURCE pResource
    )
{
    if (pResource->pExclusiveOwner == NULL)
    {
        return TRUE;
    }

    return FALSE;

}   // UlDbgResourceUnownedExclusive

VOID
UlDbgDumpRequestBuffer(
    IN struct _UL_REQUEST_BUFFER *pBuffer,
    IN PSTR pName
    )
{
    DbgPrint(
        "%s @ %p\n"
        "    Signature      = %08lx\n"
        "    ListEntry      @ %p%s\n"
        "    pConnection    = %p\n"
        "    WorkItem       @ %p\n"
        "    UsedBytes      = %lu\n"
        "    AllocBytes     = %lu\n"
        "    ParsedBytes    = %lu\n"
        "    BufferNumber   = %lu\n"
        "    JumboBuffer    = %lu\n"
        "    pBuffer        @ %p\n",
        pName,
        pBuffer,
        pBuffer->Signature,
        &pBuffer->ListEntry,
        IsListEmpty( &pBuffer->ListEntry ) ? " EMPTY" : "",
        pBuffer->pConnection,
        &pBuffer->WorkItem,
        pBuffer->UsedBytes,
        pBuffer->AllocBytes,
        pBuffer->ParsedBytes,
        pBuffer->BufferNumber,
        pBuffer->JumboBuffer,
        &pBuffer->pBuffer[0]
        );

}   // UlDbgDumpRequestBuffer

VOID
UlDbgDumpHttpConnection(
    IN struct _UL_HTTP_CONNECTION *pConnection,
    IN PSTR pName
    )
{
    DbgPrint(
        "%s @ %p\n"
        "    Signature          = %08lx\n"
        "    ConnectionId       = %08lx%08lx\n"
        "    WorkItem           @ %p\n"
        "    RefCount           = %lu\n"
        "    NextRecvNumber     = %lu\n"
        "    NextBufferNumber   = %lu\n"
        "    NextBufferToParse  = %lu\n"
        "    pConnection        = %p\n"
        "    pRequest           = %p\n",
        pName,
        pConnection,
        pConnection->Signature,
        pConnection->ConnectionId,
        &pConnection->WorkItem,
        pConnection->RefCount,
        pConnection->NextRecvNumber,
        pConnection->NextBufferNumber,
        pConnection->NextBufferToParse,
        pConnection->pConnection,
        pConnection->pRequest
        );

    DbgPrint(
        "%s @ %p (cont.)\n"
        "    Resource           @ %p\n"
        "    BufferHead         @ %p%s\n"
        "    pCurrentBuffer     = %p\n"
        "    NeedMoreData       = %lu\n"
#if REFERENCE_DEBUG
        "    pTraceLog          = %p\n"
#endif
        ,
        pName,
        pConnection,
        &pConnection->Resource,
        &pConnection->BufferHead,
        IsListEmpty( &pConnection->BufferHead ) ? " EMPTY" : "",
        pConnection->pCurrentBuffer,
        pConnection->NeedMoreData
#if REFERENCE_DEBUG
        ,
        pConnection->pTraceLog
#endif
        );

}   // UlDbgDumpHttpConnection

PIRP
UlDbgAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PIRP pIrp;

    pIrp = IoAllocateIrp( StackSize, ChargeQuota );

    if (pIrp != NULL)
    {
        WRITE_IRP_TRACE_LOG(
            g_pIrpTraceLog,
            IRP_ACTION_ALLOCATE_IRP,
            pIrp,
            pFileName,
            LineNumber
            );
    }

    return pIrp;

}   // UlDbgAllocateIrp

BOOLEAN g_ReallyFreeIrps = TRUE;

VOID
UlDbgFreeIrp(
    IN PIRP pIrp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    WRITE_IRP_TRACE_LOG(
        g_pIrpTraceLog,
        IRP_ACTION_FREE_IRP,
        pIrp,
        pFileName,
        LineNumber
        );

    if (g_ReallyFreeIrps)
    {
        IoFreeIrp( pIrp );
    }

}   // UlDbgFreeIrp

NTSTATUS
UlDbgCallDriver(
    IN PDEVICE_OBJECT pDeviceObject,
    IN OUT PIRP pIrp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;
    NTSTATUS Status;

    //
    // Record the fact that we are about to call another
    // driver in the thread data. That way if the driver
    // calls our completion routine in-line our debug
    // code won't get confused about it.
    //

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the external call count.
        //

        pData->ExternalCallCount++;
        ASSERT( pData->ExternalCallCount > 0 );
    }

    WRITE_IRP_TRACE_LOG(
        g_pIrpTraceLog,
        IRP_ACTION_CALL_DRIVER,
        pIrp,
        pFileName,
        LineNumber
        );

    //
    // Call the driver.
    //

    Status = IoCallDriver( pDeviceObject, pIrp );

    //
    // Update the external call count.
    //

    if (pData != NULL)
    {
        pData->ExternalCallCount--;
        ASSERT( pData->ExternalCallCount >= 0 );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }

    return Status;

}   // UlDbgCallDriver

VOID
UlDbgCompleteRequest(
    IN PIRP pIrp,
    IN CCHAR PriorityBoost,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    WRITE_IRP_TRACE_LOG(
        g_pIrpTraceLog,
        IRP_ACTION_COMPLETE_IRP,
        pIrp,
        pFileName,
        LineNumber
        );

    IoCompleteRequest( pIrp, PriorityBoost );

}   // UlDbgCompleteRequest

PMDL
UlDbgAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    PMDL mdl;

    mdl = IoAllocateMdl(
                VirtualAddress,
                Length,
                SecondaryBuffer,
                ChargeQuota,
                Irp
                );

    if (mdl != NULL)
    {
        WRITE_REF_TRACE_LOG(
            g_pMdlTraceLog,
            REF_ACTION_ALLOCATE_MDL,
            PtrToLong(mdl->Next),   // bugbug64
            mdl,
            pFileName,
            LineNumber
            );

#ifdef SPECIAL_MDL_FLAG
    ASSERT( (mdl->MdlFlags & SPECIAL_MDL_FLAG) == 0 );
#endif
    }

    return mdl;

}   // UlDbgAllocateMdl

BOOLEAN g_ReallyFreeMdls = TRUE;

VOID
UlDbgFreeMdl(
    IN PMDL Mdl,
    IN PSTR pFileName,
    IN USHORT LineNumber
    )
{
    WRITE_REF_TRACE_LOG(
        g_pMdlTraceLog,
        REF_ACTION_FREE_MDL,
        PtrToLong(Mdl->Next),   // bugbug64
        Mdl,
        pFileName,
        LineNumber
        );

#ifdef SPECIAL_MDL_FLAG
    ASSERT( (Mdl->MdlFlags & SPECIAL_MDL_FLAG) == 0 );
#endif

    if (g_ReallyFreeMdls)
    {
        IoFreeMdl( Mdl );
    }

}   // UlDbgFreeMdl


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Updates a pool counter.

Arguments:

    pAddend - Supplies the counter to update.

    Increment - Supplies the value to add to the counter.

--***************************************************************************/
VOID
UlpDbgUpdatePoolCounter(
    IN OUT PLARGE_INTEGER pAddend,
    IN SIZE_T Increment
    )
{
    ULONG tmp;

    tmp = (ULONG)Increment;
    ASSERT( (SIZE_T)tmp == Increment );

    ExInterlockedAddLargeStatistic(
        pAddend,
        tmp
        );

}   // UlpDbgUpdatePoolCounter


/***************************************************************************++

Routine Description:

    Locates the file part of a fully qualified path.

Arguments:

    pPath - Supplies the path to scan.

Return Value:

    PSTR - The file part.

--***************************************************************************/
PSTR
UlpDbgFindFilePart(
    IN PSTR pPath
    )
{
    PSTR pFilePart;

    //
    // Strip off the path from the path.
    //

    pFilePart = strrchr( pPath, '\\' );

    if (pFilePart == NULL)
    {
        pFilePart = pPath;
    }
    else
    {
        pFilePart++;
    }

    return pFilePart;

}   // UlpDbgFindFilePart


/***************************************************************************++

Routine Description:

    Locates and optionally creates per-thread data for the current thread.

Return Value:

    PUL_DEBUG_THREAD_DATA - The thread data if successful, NULL otherwise.

--***************************************************************************/
PUL_DEBUG_THREAD_DATA
UlpDbgFindThread(
    BOOLEAN OkToCreate,
    PSTR pFileName,
    USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;
    PUL_THREAD_HASH_BUCKET pBucket;
    PETHREAD pThread;
    KIRQL oldIrql;
    PLIST_ENTRY pListEntry;
    ULONG refCount;

    //
    // Get the current thread, find the correct bucket.
    //

    pThread = PsGetCurrentThread();
    pBucket = &g_DbgThreadHashBuckets[HASH_FROM_THREAD(pThread)];

    //
    // Lock the bucket.
    //

    UlAcquireSpinLock( &pBucket->BucketSpinLock, &oldIrql );

    //
    // Try to find an existing entry for the current thread.
    //

    for (pListEntry = pBucket->BucketListHead.Flink ;
         pListEntry != &pBucket->BucketListHead ;
         pListEntry = pListEntry->Flink)
    {
        pData = CONTAINING_RECORD(
                    pListEntry,
                    UL_DEBUG_THREAD_DATA,
                    ThreadDataListEntry
                    );

        if (pData->pThread == pThread)
        {
            //
            // Found one. Update the reference count, then return the
            // existing entry.
            //

            pData->ReferenceCount++;
            refCount = pData->ReferenceCount;
            UlReleaseSpinLock( &pBucket->BucketSpinLock, oldIrql );

            //
            // Trace it.
            //

            WRITE_REF_TRACE_LOG(
                g_pThreadTraceLog,
                REF_ACTION_REFERENCE_THREAD,
                refCount,
                pData,
                pFileName,
                LineNumber
                );

            return pData;
        }
    }

    //
    // If we made it this far, then data has not yet been created for
    // the current thread. Create & initialize it now if we're allowed.
    // Basically it's only ok if we're called from UlDbgEnterDriver.
    //

    if (OkToCreate)
    {
        pData = (PUL_DEBUG_THREAD_DATA) UL_ALLOCATE_POOL(
                    NonPagedPool,
                    sizeof(*pData),
                    UL_DEBUG_THREAD_POOL_TAG
                    );

        if (pData != NULL)
        {
            RtlZeroMemory( pData, sizeof(*pData) );

            pData->pThread = pThread;
            pData->ReferenceCount = 1;
            pData->ResourceCount = 0;

            InsertHeadList(
                &pBucket->BucketListHead,
                &pData->ThreadDataListEntry
                );

            InterlockedIncrement( &g_DbgThreadCreated );
        }

    }
    else
    {
        pData = NULL;
    }

    UlReleaseSpinLock( &pBucket->BucketSpinLock, oldIrql );

    return pData;

}   // UlpDbgFindThread


/***************************************************************************++

Routine Description:

    Dereferences per-thread data.

Arguments:

    pData - Supplies the thread data to dereference.

--***************************************************************************/
VOID
UlpDbgDereferenceThread(
    IN PUL_DEBUG_THREAD_DATA pData
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUL_THREAD_HASH_BUCKET pBucket;
    KIRQL oldIrql;
    ULONG refCount;

    //
    // Find the correct bucket.
    //

    pBucket = &g_DbgThreadHashBuckets[HASH_FROM_THREAD(pData->pThread)];

    //
    // Update the reference count.
    //

    UlAcquireSpinLock( &pBucket->BucketSpinLock, &oldIrql );

    ASSERT( pData->ReferenceCount > 0 );
    pData->ReferenceCount--;

    refCount = pData->ReferenceCount;

    if (pData->ReferenceCount == 0)
    {
        //
        // It dropped to zero, so remove the thread from the bucket
        // and free the resources.
        //

        RemoveEntryList( &pData->ThreadDataListEntry );
        UlReleaseSpinLock( &pBucket->BucketSpinLock, oldIrql );

        UL_FREE_POOL( pData, UL_DEBUG_THREAD_POOL_TAG );
        InterlockedIncrement( &g_DbgThreadDestroyed );
    }
    else
    {
        UlReleaseSpinLock( &pBucket->BucketSpinLock, oldIrql );
    }

    //
    // Trace it.
    //

    WRITE_REF_TRACE_LOG(
        g_pThreadTraceLog,
        REF_ACTION_DEREFERENCE_THREAD,
        refCount,
        pData,
        pFileName,
        LineNumber
        );

}   // UlpDbgDereferenceThread


#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\debug.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains debug-specific declarations.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef __cplusplus
extern "C" {
#endif

#define UL_DEFAULT_ERROR_ON_EXCEPTION       STATUS_INVALID_PARAMETER

// BUGBUG: should not need to declare these functions ourselves.
// Declared in ntddk.h but not in ntosp.h.
NTKERNELAPI
VOID
ExConvertExclusiveToSharedLite(
    IN PERESOURCE Resource
    );

#undef UL_TRY_RESOURCE_EXCLUSIVE

#ifdef UL_TRY_RESOURCE_EXCLUSIVE
// ExTryToAcquireResourceExclusiveLite is not currently exported
// from ntoskrnl
NTKERNELAPI
BOOLEAN
ExTryToAcquireResourceExclusiveLite(
    IN PERESOURCE Resource
    );
#endif // UL_TRY_RESOURCE_EXCLUSIVE

#if DBG

//
// Initialization/termination functions.
//

VOID
UlDbgInitializeDebugData(
    VOID
    );

VOID
UlDbgTerminateDebugData(
    VOID
    );

//
// Driver entry/exit notifications.
//

VOID
UlDbgEnterDriver(
    IN PSTR pFunctionName,
    IN PIRP pIrp OPTIONAL,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgLeaveDriver(
    IN PSTR pFunctionName,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_ENTER_DRIVER( function, pirp )                                   \
    UlDbgEnterDriver(                                                       \
        (function),                                                         \
        (pirp),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UL_LEAVE_DRIVER( function )                                         \
    UlDbgLeaveDriver(                                                       \
        (function),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


//
// An instrumented resource.
//

#define MAX_RESOURCE_NAME_LENGTH    64

typedef struct _UL_ERESOURCE
{
    //
    // The actual resource.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    ERESOURCE Resource;

    //
    // Links onto the global resource list.
    //

    LIST_ENTRY GlobalResourceListEntry;

    //
    // Pointer to the thread that owns this lock exclusively.
    //

    PETHREAD pExclusiveOwner;
    PETHREAD pPreviousOwner;

    //
    // Statistics.
    //

    LONG ExclusiveCount;
    LONG SharedCount;
    LONG ReleaseCount;

    //
    // The object that created this lock
    //

    ULONG OwnerTag;

    //
    // The name of the resource, for display purposes.
    //

    UCHAR ResourceName[MAX_RESOURCE_NAME_LENGTH];

} UL_ERESOURCE, *PUL_ERESOURCE;

NTSTATUS
UlDbgInitializeResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pResourceName,
    IN ULONG_PTR Parameter,
    IN ULONG OwnerTag,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

NTSTATUS
UlDbgDeleteResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgAcquireResourceShared(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseResource(
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgConvertExclusiveToShared(                                          \
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#ifdef UL_TRY_RESOURCE_EXCLUSIVE
BOOLEAN
UlDbgTryToAcquireResourceExclusive(                                     \
    IN PUL_ERESOURCE pResource,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );
#endif // UL_TRY_RESOURCE_EXCLUSIVE

BOOLEAN
UlDbgResourceOwnedExclusive(
    IN PUL_ERESOURCE pResource
    );

BOOLEAN
UlDbgResourceUnownedExclusive(
    IN PUL_ERESOURCE pResource
    );

#define UlInitializeResource( resource, name, param, tag )                  \
    UlDbgInitializeResource(                                                \
        (resource),                                                         \
        (name),                                                             \
        (ULONG_PTR)(param),                                                 \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlDeleteResource( resource )                                        \
    UlDbgDeleteResource(                                                    \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireResourceExclusive( resource, wait )                        \
    UlDbgAcquireResourceExclusive(                                          \
        (resource),                                                         \
        (wait),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireResourceShared( resource, wait )                           \
    UlDbgAcquireResourceShared(                                             \
        (resource),                                                         \
        (wait),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseResource( resource )                                       \
    UlDbgReleaseResource(                                                   \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlConvertExclusiveToShared( resource )                              \
    UlDbgConvertExclusiveToShared(                                          \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#ifdef UL_TRY_RESOURCE_EXCLUSIVE
#define UlTryToAcquireResourceExclusive( resource )                         \
    UlDbgTryToAcquireResourceExclusive(                                     \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )
#endif // UL_TRY_RESOURCE_EXCLUSIVE

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->Resource.SystemResourcesList.Flink != NULL)


//
// An instrumented spinlock.
//

typedef struct _UL_SPIN_LOCK    // SpinLock
{
    //
    // The actual lock.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    KSPIN_LOCK KSpinLock;

    //
    // The name of the spinlock, for display purposes.
    //

    PSTR pSpinLockName;

    //
    // Pointer to the thread that owns this lock.
    //

    PETHREAD pOwnerThread;

    //
    // Statistics.
    //

    PSTR pLastAcquireFileName;
    PSTR pLastReleaseFileName;
    USHORT LastAcquireLineNumber;
    USHORT LastReleaseLineNumber;
    ULONG OwnerProcessor;
    LONG Acquisitions;
    LONG Releases;
    LONG AcquisitionsAtDpcLevel;
    LONG ReleasesFromDpcLevel;
    LONG Spare;

} UL_SPIN_LOCK, *PUL_SPIN_LOCK;

#define KSPIN_LOCK_FROM_UL_SPIN_LOCK( pLock )                               \
    &((pLock)->KSpinLock)

VOID
UlDbgInitializeSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pSpinLockName,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKIRQL pOldIrql,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN KIRQL OldIrql,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireInStackQueuedSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseInStackQueuedSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireInStackQueuedSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseInStackQueuedSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgSpinLockOwned(
    IN PUL_SPIN_LOCK pSpinLock
    );

BOOLEAN
UlDbgSpinLockUnowned(
    IN PUL_SPIN_LOCK pSpinLock
    );

#define UlInitializeSpinLock( spinlock, name )                              \
    UlDbgInitializeSpinLock(                                                \
        (spinlock),                                                         \
        (name),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireSpinLock( spinlock, oldirql )                              \
    UlDbgAcquireSpinLock(                                                   \
        (spinlock),                                                         \
        (oldirql),                                                          \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseSpinLock( spinlock, oldirql )                              \
    UlDbgReleaseSpinLock(                                                   \
        (spinlock),                                                         \
        (oldirql),                                                          \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireSpinLockAtDpcLevel( spinlock )                             \
    UlDbgAcquireSpinLockAtDpcLevel(                                         \
        (spinlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseSpinLockFromDpcLevel( spinlock )                           \
    UlDbgReleaseSpinLockFromDpcLevel(                                       \
        (spinlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireInStackQueuedSpinLock( spinlock, lockhandle )               \
    UlDbgAcquireInStackQueuedSpinLock(                                       \
        (spinlock),                                                         \
        (lockhandle),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseInStackQueuedSpinLock( spinlock, lockhandle )               \
    UlDbgReleaseInStackQueuedSpinLock(                                       \
        (spinlock),                                                         \
        (lockhandle),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireInStackQueuedSpinLockAtDpcLevel( spinlock, lockhandle )     \
    UlDbgAcquireInStackQueuedSpinLockAtDpcLevel(                             \
        (spinlock),                                                         \
        (lockhandle),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseInStackQueuedSpinLockFromDpcLevel( spinlock, lockhandle )   \
    UlDbgReleaseInStackQueuedSpinLockFromDpcLevel(                           \
        (spinlock),                                                         \
        (lockhandle),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


//
// Debug spew control.
// If you change or add a flag, please update the FlagTable
// in ul\util\tul.c.
//

#undef IF_DEBUG
#define IF_DEBUG(a)         \
    if ( ((UL_DEBUG_ ## a) & g_UlDebug) != 0 )
#define IF_DEBUG2(a, b)     \
    if ( (((UL_DEBUG_ ## a) | (UL_DEBUG_ ## b)) & g_UlDebug) \
         == ((UL_DEBUG_ ## a) | (UL_DEBUG_ ## b)) )

#define UL_DEBUG_OPEN_CLOSE                 0x00000001
#define UL_DEBUG_SEND_RESPONSE              0x00000002
#define UL_DEBUG_SEND_BUFFER                0x00000004
#define UL_DEBUG_TDI                        0x00000008

#define UL_DEBUG_FILE_CACHE                 0x00000010
#define UL_DEBUG_CONFIG_GROUP_FNC           0x00000020
#define UL_DEBUG_CONFIG_GROUP_TREE          0x00000040
#define UL_DEBUG_REFCOUNT                   0x00000080

#define UL_DEBUG_HTTP_IO                    0x00000100
#define UL_DEBUG_ROUTING                    0x00000200
#define UL_DEBUG_URI_CACHE                  0x00000400
#define UL_DEBUG_PARSER                     0x00000800

#define UL_DEBUG_SITE                       0x00001000
#define UL_DEBUG_WORK_ITEM                  0x00002000
#define UL_DEBUG_FILTER                     0x00004000
#define UL_DEBUG_LOGGING                    0x00008000

#define UL_DEBUG_TC                         0x00010000
#define UL_DEBUG_OPAQUE_ID                  0x00020000
#define UL_DEBUG_PERF_COUNTERS              0x00040000
#define UL_DEBUG_LKRHASH                    0x00080000

#define UL_DEBUG_TIMEOUTS                   0x00100000
#define UL_DEBUG_LIMITS                     0x00200000
#define UL_DEBUG_LARGE_MEM                  0x00400000
#define UL_DEBUG_IOCTL                      0x00800000

#define UL_DEBUG_VERBOSE                    0x40000000

#define DEBUG


//
// Tracing.
//
extern ULONG g_UlDebug;

#define UlTrace(a, _b_)                                                     \
    do                                                                      \
    {                                                                       \
        IF_DEBUG(##a)                                                       \
        {                                                                   \
            DbgPrint _b_ ;                                                  \
        }                                                                   \
    } while (FALSE)

#define UlTrace2(a1, a2, _b_)                                               \
    do                                                                      \
    {                                                                       \
        IF_DEBUG2(##a1, ##a2)                                               \
        {                                                                   \
            DbgPrint _b_ ;                                                  \
        }                                                                   \
    } while (FALSE)

#define UlTraceVerbose(a, _b_)  UlTrace2(a, VERBOSE, _b_)

ULONG
UlDbgPrettyPrintBuffer(
    const UCHAR* pBuffer,
    ULONG        BufferSize
    );

//
// Debug pool allocator.
//

PVOID
UlDbgAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreePool (
    IN PVOID pPointer,
    IN ULONG Tag
    );

#define UL_ALLOCATE_POOL( type, len, tag )                                  \
    UlDbgAllocatePool(                                                      \
        (type),                                                             \
        (len),                                                              \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UL_FREE_POOL( ptr, tag )                                            \
    UlDbgFreePool(                                                          \
        (ptr),                                                              \
        (tag)                                                               \
        )

//
// Exception filter.
//

LONG
UlDbgExceptionFilter(
    IN PEXCEPTION_POINTERS pExceptionPointers,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_EXCEPTION_FILTER()                                               \
    UlDbgExceptionFilter(                                                   \
        GetExceptionInformation(),                                          \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

//
// Exception warning converter.
//

NTSTATUS
UlDbgConvertExceptionCode(
    IN NTSTATUS status,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_CONVERT_EXCEPTION_CODE(status)                                   \
        (NT_WARNING(status)   ?                                             \
                UlDbgConvertExceptionCode(                                  \
                    (status),                                               \
                    (PSTR)__FILE__,                                         \
                    (USHORT)__LINE__ )                                      \
                :                                                           \
                (status))

//
// Invalid completion routine for catching incomplete IRP contexts.
//

VOID
UlDbgInvalidCompletionRoutine(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


//
// Error handlers.
//

NTSTATUS
UlDbgStatus(
    IN NTSTATUS Status,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define RETURN(status)                                                      \
    return UlDbgStatus(                                                     \
                (status),                                                   \
                __FILE__,                                                   \
                __LINE__                                                    \
                )

#define CHECK_STATUS(status)                                                \
    UlDbgStatus(                                                            \
        (status),                                                           \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

//
// Random structure dumpers.
//

VOID
UlDbgDumpRequestBuffer(
    IN struct _UL_REQUEST_BUFFER *pBuffer,
    IN PSTR pName
    );

VOID
UlDbgDumpHttpConnection(
    IN struct _UL_HTTP_CONNECTION *pConnection,
    IN PSTR pName
    );


//
// IO wrappers.
//

PIRP
UlDbgAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreeIrp(
    IN PIRP pIrp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

NTSTATUS
UlDbgCallDriver(
    IN PDEVICE_OBJECT pDeviceObject,
    IN OUT PIRP pIrp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgCompleteRequest(
    IN PIRP pIrp,
    IN CCHAR PriorityBoost,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UlAllocateIrp( stack, quota )                                       \
    UlDbgAllocateIrp(                                                       \
        (stack),                                                            \
        (quota),                                                            \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlFreeIrp( pirp )                                                   \
    UlDbgFreeIrp(                                                           \
        (pirp),                                                             \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlCallDriver( pdevice, pirp )                                       \
    UlDbgCallDriver(                                                        \
        (pdevice),                                                          \
        (pirp),                                                             \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlCompleteRequest( pirp, boost )                                    \
    UlDbgCompleteRequest(                                                   \
        (pirp),                                                             \
        (boost),                                                            \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

PMDL
UlDbgAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreeMdl(
    IN PMDL Mdl,
    IN PSTR pFileName,
    IN USHORT LineNumber
    );

#define UlAllocateMdl( add, len, second, quota, irp )                       \
    UlDbgAllocateMdl(                                                       \
        (add),                                                              \
        (len),                                                              \
        (second),                                                           \
        (quota),                                                            \
        (irp),                                                              \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

#define UlFreeMdl( mdl )                                                    \
    UlDbgFreeMdl(                                                           \
        (mdl),                                                              \
        (PSTR)__FILE__,                                                     \
        (USHORT)__LINE__                                                    \
        )

// #define SPECIAL_MDL_FLAG    0x8000


//
// List Manipulation
//

#define UlRemoveEntryList(pEntry)   {                                       \
        ASSERT(NULL != (pEntry));                                           \
        ASSERT(NULL != (pEntry)->Flink);                                    \
        ASSERT(NULL != (pEntry)->Blink);                                    \
        RemoveEntryList(pEntry);                                            \
        (pEntry)->Flink = (pEntry)->Blink = NULL;                           \
    }


#else   // !DBG  -----------------------------------------------------------


//
// Disable all of the above.
//

#define UL_ENTER_DRIVER( function, pirp )
#define UL_LEAVE_DRIVER( function )

#define UL_ERESOURCE ERESOURCE
#define PUL_ERESOURCE PERESOURCE

#define UlInitializeResource( resource, name, param, tag )                  \
    ExInitializeResourceLite( (resource) )

#define UlDeleteResource( resource )                                        \
    ExDeleteResourceLite( (resource) )

#define UlAcquireResourceExclusive( resource, wait )                        \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceExclusiveLite( (resource), (wait) );               \
    } while (FALSE)

#define UlAcquireResourceShared( resource, wait )                           \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceSharedLite( (resource), (wait) );                  \
    } while (FALSE)

#define UlReleaseResource( resource )                                       \
    do                                                                      \
    {                                                                       \
        ExReleaseResourceLite( (resource) );                                \
        KeLeaveCriticalRegion();                                            \
    } while (FALSE)

#define UlConvertExclusiveToShared( resource )                              \
    ExConvertExclusiveToSharedLite( (resource) )

#ifdef UL_TRY_RESOURCE_EXCLUSIVE
__inline
NTKERNELAPI
BOOLEAN
UlTryToAcquireResourceExclusive(
    IN PERESOURCE Resource
    )
{
    BOOLEAN fLocked;
    KeEnterCriticalRegion();
    fLocked = ExTryToAcquireResourceExclusiveLite( Resource );
    if (! fLocked )
        KeLeaveCriticalRegion();
    return fLocked;
}
#endif // UL_TRY_RESOURCE_EXCLUSIVE

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->SystemResourcesList.Flink != NULL)

#define UL_SPIN_LOCK  KSPIN_LOCK
#define PUL_SPIN_LOCK PKSPIN_LOCK

#define KSPIN_LOCK_FROM_UL_SPIN_LOCK( pLock ) (pLock)

#define UlInitializeSpinLock( spinlock, name )                              \
    KeInitializeSpinLock( (spinlock) )

#define UlAcquireSpinLock( spinlock, oldirql )                              \
    KeAcquireSpinLock( (spinlock), (oldirql) )

#define UlReleaseSpinLock( spinlock, oldirql )                              \
    KeReleaseSpinLock( (spinlock), (oldirql) )

#define UlAcquireSpinLockAtDpcLevel( spinlock )                             \
    KeAcquireSpinLockAtDpcLevel( (spinlock) )

#define UlReleaseSpinLockFromDpcLevel( spinlock )                           \
    KeReleaseSpinLockFromDpcLevel( (spinlock) )

#define UlAcquireInStackQueuedSpinLock( spinlock, lockhandle )              \
    KeAcquireInStackQueuedSpinLock( (spinlock), (lockhandle) )

#define UlReleaseInStackQueuedSpinLock( spinlock, lockhandle )              \
    KeReleaseInStackQueuedSpinLock( (lockhandle) )

#define KeAcquireInStackQueueddSpinLockAtDpcLevel( spinlock, lockhandle )   \
    KeAcquireInStackQueuedSpinLockAtDpcLevel( (spinlock), (lockhandle) )

#define UlReleaseInStackQueuedSpinLockFromDpcLevel( spinlock, lockhandle )  \
    KeReleaseInStackQueuedSpinLockFromDpcLevel( (lockhandle) )

#undef IF_DEBUG
#define IF_DEBUG(a)         if (FALSE)
#define IF_DEBUG2(a, b)     if (FALSE)
#define DEBUG               if ( FALSE )

#define UlTrace(a, _b_)                                 ((void) 0)
#define UlTrace2(a1, a2, _b_)                           ((void) 0)
#define UlTraceVerbose(a, _b_)                          ((void) 0)
#define UlDbgPrettyPrintBuffer(pBuffer, BufferSize)     ((void) 0)

#define UL_ALLOCATE_POOL( type, len, tag )                                  \
    ExAllocatePoolWithTag(                                                  \
        (type),                                                             \
        (len),                                                              \
        (tag)                                                               \
        )

#define UL_FREE_POOL( ptr, tag )                                            \
    MyFreePoolWithTag(                                                      \
        (ptr),                                                              \
        (tag)                                                               \
        )

#define UL_EXCEPTION_FILTER() EXCEPTION_EXECUTE_HANDLER

#define UL_CONVERT_EXCEPTION_CODE(status)                                   \
        (NT_WARNING(status) ? UL_DEFAULT_ERROR_ON_EXCEPTION : (status))

#define RETURN(status) return (status)
#define CHECK_STATUS(Status)

#define UlAllocateIrp( stack, quota )                                       \
    IoAllocateIrp( (stack), (quota) )

#define UlFreeIrp( pirp )                                                   \
    IoFreeIrp( (pirp) )

#define UlCallDriver( pdevice, pirp )                                       \
    IoCallDriver( (pdevice), (pirp) )

#define UlCompleteRequest( pirp, boost )                                    \
    IoCompleteRequest( (pirp), (boost) )

#define UlAllocateMdl( add, len, second, quota, irp )                       \
    IoAllocateMdl(                                                          \
        (add),                                                              \
        (len),                                                              \
        (second),                                                           \
        (quota),                                                            \
        (irp)                                                               \
        )

#define UlFreeMdl( mdl )                                                    \
    IoFreeMdl(                                                              \
        (mdl)                                                               \
        )

#define UlRemoveEntryList(pEntry)                                           \
    RemoveEntryList(pEntry)

#endif  // DBG

// BUGBUG: ALIGN_UP(PVOID) won't work. It needs to be the type of
// the first entry of the following data (paulmcd 4/29/99)

#define UL_ALLOCATE_STRUCT_WITH_SPACE(pt,ot,cb,t)   \
    (ot *)(UL_ALLOCATE_POOL(pt,ALIGN_UP(sizeof(ot),PVOID)+(cb),t))

#define UL_ALLOCATE_STRUCT(pt,ot,t)                 \
    (ot *)(UL_ALLOCATE_POOL(pt,sizeof(ot),t))

#define UL_ALLOCATE_ARRAY(pt,et,c,t)                \
    (et *)(UL_ALLOCATE_POOL(pt,sizeof(et)*(c),t))

#define UL_FREE_POOL_WITH_SIG(a,t)                  \
    do {                                            \
        (a)->Signature = MAKE_FREE_TAG(t);          \
        UL_FREE_POOL(a,t);                          \
        (a) = NULL;                                 \
    } while (0)

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\filecache.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    filecache.cxx

Abstract:

    This module implements the open file handle cache.

Author:

    Keith Moore (keithmo)       21-Aug-1998

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

//
// Private types.
//

#ifdef __cplusplus

extern "C" {
#endif // __cplusplus

//
// Private prototypes.
//


VOID
UlpDestroyFileCacheEntry(
    IN PUL_WORK_ITEM pWorkItem
    );

BOOLEAN
UlpFailMdlReadDev(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
UlpFailMdlReadCompleteDev(
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

NTSTATUS
UlpRestartReadFileEntry(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

#ifdef __cplusplus

}; // extern "C"
#endif // __cplusplus



//
// Private globals.
//


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, InitializeFileCache )
#pragma alloc_text( PAGE, TerminateFileCache )
#pragma alloc_text( PAGE, UlCreateFileEntry )
#pragma alloc_text( PAGE, UlpFailMdlReadDev )
#pragma alloc_text( PAGE, UlpFailMdlReadCompleteDev )
#pragma alloc_text( PAGE, UlReadFileEntry )
#pragma alloc_text( PAGE, UlReadFileEntryFast )
#pragma alloc_text( PAGE, UlReadCompleteFileEntry )
#pragma alloc_text( PAGE, UlReadCompleteFileEntryFast )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- ReferenceCachedFile
NOT PAGEABLE -- DereferenceCachedFile
NOT PAGEABLE -- UlpRestartReadFileEntry
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of the open file cache.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
InitializeFileCache(
    VOID
    )
{
    return STATUS_SUCCESS;  // NYI

}   // InitializeFileCache


/***************************************************************************++

Routine Description:

    Performs global termination of the open file cache.

--***************************************************************************/
VOID
TerminateFileCache(
    VOID
    )
{

}   // TerminateFileCache

/***************************************************************************++

Routine Description:

    References the specified file cache entry.

Arguments:

    pFileCacheEntry - Supplies the file cache entry to reference.

--***************************************************************************/
VOID
ReferenceCachedFile(
    IN PUL_FILE_CACHE_ENTRY pFileCacheEntry
    )
{
    LONG result;

    result = InterlockedIncrement( &pFileCacheEntry->ReferenceCount );
    ASSERT( result > 1 );

    IF_DEBUG( FILE_CACHE )
    {
        KdPrint((
            "ReferenceCachedFile: entry %p, ref %ld\n",
            pFileCacheEntry,
            result
            ));
    }

}   // ReferenceCachedFile


/***************************************************************************++

Routine Description:

    Dereferences the specified file cache entry.

Arguments:

    pFileCacheEntry - Supplies the file cache entry to dereference.

--***************************************************************************/
VOID
DereferenceCachedFile(
    IN PUL_FILE_CACHE_ENTRY pFileCacheEntry
    )
{
    LONG result;

    result = InterlockedDecrement( &pFileCacheEntry->ReferenceCount );
    ASSERT( result >= 0 );

    IF_DEBUG( FILE_CACHE )
    {
        KdPrint((
            "DereferenceCachedFile: entry %p, ref %ld\n",
            pFileCacheEntry,
            result
            ));
    }

    if (result == 0)
    {
        UL_CALL_PASSIVE(
            &pFileCacheEntry->WorkItem,
            &UlpDestroyFileCacheEntry
            );
    }

}   // DereferenceCachedFile


/***************************************************************************++

Routine Description:

    Creates a new file entry for the specified file.

Arguments:

    pFileName - Supplies the name of the file to open.

    FileHandle - the optional file handle.  ONLY 1 can be provided.  
        name OR handle.

    pFileCacheEntry - Receives the newly created file cache entry if
        successful.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateFileEntry(
    IN PUNICODE_STRING pFileName OPTIONAL,
    IN HANDLE FileHandle OPTIONAL,
    IN KPROCESSOR_MODE AccessMode,
    OUT PUL_FILE_CACHE_ENTRY *pFileCacheEntry
    )
{
    NTSTATUS status;
    PUL_FILE_CACHE_ENTRY pNewEntry;
    HANDLE fileHandle;
    PFILE_OBJECT pFileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    PFAST_IO_DISPATCH pFastIoDispatch;
    BOOLEAN AttachedToSysProc;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Setup locals so we know how to cleanup on exit.
    //

    pNewEntry = NULL;
    fileHandle = NULL;
    pFileObject = NULL;
    AttachedToSysProc = FALSE;
    
    status = STATUS_SUCCESS;

    //
    // Only 1 can be passed in 
    //
    
    if (pFileName != NULL && FileHandle != NULL)
    {
        status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    IF_DEBUG( FILE_CACHE )
    {
        if (pFileName != NULL)
        {
            KdPrint((
                "UlCreateFileEntry: file %wZ\n",
                pFileName
                ));
        }
        else
        {
            KdPrint((
                "UlCreateFileEntry: handle %p\n",
                (PVOID)FileHandle
                ));

        }
    }

    //
    // Allocate the entry.
    //

    pNewEntry = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_FILE_CACHE_ENTRY,
                    (pFileName == NULL) ? 0 : pFileName->MaximumLength,
                    UL_FILE_CACHE_ENTRY_POOL_TAG
                    );

    if (pNewEntry == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }

    RtlZeroMemory( pNewEntry, sizeof(*pNewEntry) );
    pNewEntry->Signature = UL_FILE_CACHE_ENTRY_SIGNATURE;

    if (pFileName != NULL)
    {
        //
        // Open the file.
        //

        InitializeObjectAttributes(
            &objectAttributes,                      // ObjectAttributes
            pFileName,                              // ObjectName
            OBJ_CASE_INSENSITIVE |                  // Attributes
                UL_KERNEL_HANDLE,
            NULL,                                   // RootDirectory
            NULL                                    // SecurityDescriptor
            );

        UlAttachToSystemProcess();
        AttachedToSysProc = TRUE;

        status = IoCreateFile(
                        &fileHandle,                // FileHandle
                        FILE_GENERIC_READ,          // DesiredAccess
                        &objectAttributes,          // ObjectAttributes
                        &ioStatusBlock,             // IoStatusBlock
                        NULL,                       // AllocationSize
                        0,                          // FileAttributes
                        FILE_SHARE_READ |           // ShareAccess
                            FILE_SHARE_WRITE,
                        FILE_OPEN,                  // CreateDisposition
                        0,                          // CreateOptions
                        NULL,                       // EaBuffer
                        0,                          // EaLength
                        CreateFileTypeNone,         // CreateFileType
                        NULL,                       // ExtraCreateParameters
                        IO_NO_PARAMETER_CHECKING    // Options
                        );

        if (NT_SUCCESS(status) == FALSE)
            goto end;

        AccessMode = KernelMode;
    }
    else
    {
        //
        // use the passed in handle
        //
        
        fileHandle = FileHandle;

    }
    
    //
    // Get a referenced pointer to the file object.
    //

    status = ObReferenceObjectByHandle(
                fileHandle,                 // Handle
                0,                          // DesiredAccess
                *IoFileObjectType,          // ObjectType
                AccessMode,                 // AccessMode
                (void**)&pFileObject,       // Object
                NULL                        // HandleInformation
                );
                
    if (NT_SUCCESS(status) == FALSE)
        goto end;
        
    //
    // Get the file size, etc from the file. Note that, since we *may*
    // be running in the context of a user-mode thread, we need to
    // use the Zw form of the API rather than the Nt form.
    //

    status = ZwQueryInformationFile(
                    fileHandle,             // FileHandle
                    &ioStatusBlock,         // IoStatusBlock,
                    &pNewEntry->FileInfo,   // FileInformation,
                    sizeof(pNewEntry->FileInfo), // Length
                    FileStandardInformation // FileInformationClass
                    );
                    
    if (NT_SUCCESS(status) == FALSE)
        goto end;
                        
    if (AttachedToSysProc)
    {
        //
        // detach from the sys process
        //
        
        UlDetachFromSystemProcess();
        AttachedToSysProc = FALSE;
    }

    //
    // Snag the device object from the file object, then fill in the
    // fast I/O routines. The code here was shamelessly stolen from
    // the NT SMB server.
    //

    pNewEntry->pDeviceObject = IoGetRelatedDeviceObject( pFileObject );

    pFastIoDispatch = pNewEntry->pDeviceObject->DriverObject->FastIoDispatch;

    if (pFastIoDispatch != NULL)
    {
        //
        // Fill in Mdl calls. If the file system's vector is large
        // enough, we still need to check if one of the routines is
        // specified. If one is specified, they all must be.
        //

        if ((pFastIoDispatch->SizeOfFastIoDispatch >
                FIELD_OFFSET(FAST_IO_DISPATCH, MdlReadComplete)) &&
            (pFastIoDispatch->MdlRead != NULL))
        {
            pNewEntry->pMdlRead = pFastIoDispatch->MdlRead;
            pNewEntry->pMdlReadComplete = pFastIoDispatch->MdlReadComplete;
        }
        else
        if (IoGetBaseFileSystemDeviceObject( pFileObject ) ==
                pNewEntry->pDeviceObject)
        {
            //
            // Otherwise default to the original FsRtl routines if we
            // are right atop a filesystem.
            //

            pNewEntry->pMdlRead = &FsRtlMdlReadDev;
            pNewEntry->pMdlReadComplete = &FsRtlMdlReadCompleteDev;
        }
        else
        {
            //
            // Otherwise, make them fail.
            //

            pNewEntry->pMdlRead = &UlpFailMdlReadDev;
            pNewEntry->pMdlReadComplete = &UlpFailMdlReadCompleteDev;
        }
    }
    else
    {
        //
        // No fast dispatch, so make the fast routines fail.
        //

        pNewEntry->pMdlRead = &UlpFailMdlReadDev;
        pNewEntry->pMdlReadComplete = &UlpFailMdlReadCompleteDev;
    }

    //
    // Initialize the new entry.
    //

    pNewEntry->ReferenceCount = 1;

    if (pFileName != NULL)
    {
        pNewEntry->FileName.Length = pFileName->Length;
        pNewEntry->FileName.MaximumLength = pFileName->MaximumLength;
        pNewEntry->FileName.Buffer = (PWSTR)( pNewEntry + 1 );
    
        RtlCopyMemory(
            pNewEntry->FileName.Buffer,
            pFileName->Buffer,
            pNewEntry->FileName.MaximumLength
            );

        //
        // only set the handle if it's one we opened, destroy will close it
        //
    
        pNewEntry->FileHandle = fileHandle;
    
    }
    
    pNewEntry->pFileObject = pFileObject;

    //
    // Success!
    //

    IF_DEBUG( FILE_CACHE )
    {
        KdPrint((
            "UlCreateFileEntry: entry %p, file %wZ, handle %lx [%p]\n",
            pNewEntry,
            pFileName,
            fileHandle,
            pFileObject
            ));
    }

    *pFileCacheEntry = pNewEntry;

end:
    if (NT_SUCCESS(status) == FALSE)
    {
        //
        // If we made it to this point, then the open has failed.
        //

        IF_DEBUG( FILE_CACHE )
        {
            if (pFileName != NULL)
            {
                KdPrint((
                    "UlCreateFileEntry: file %wZ, failure %08lx\n",
                    pFileName,
                    status
                    ));
            }
            else
            {
                KdPrint((
                    "UlCreateFileEntry: handle %p, failure %08lx\n",
                    FileHandle,
                    status
                    ));
            }   
        }

        if (pNewEntry != NULL)
        {
            UlpDestroyFileCacheEntry(&pNewEntry->WorkItem);
            pNewEntry = NULL;
        }
    }
    
    RETURN(status);

}   // UlCreateFileEntry


/***************************************************************************++

Routine Description:

    Reads data from a file. Does a MDL read for filesystems that support
    MDL reads. If the fs doesn't support MDL reads, this function
    allocates a buffer to hold the data.

Arguments:

    pFileBuffer - Contains all the info about the read, and the data
                    once that's been read.

    pIrp - This IRP is used to issue the read.

--***************************************************************************/
NTSTATUS
UlReadFileEntry(
    IN OUT PUL_FILE_BUFFER pFileBuffer,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION pIrpSp;
    PUL_FILE_CACHE_ENTRY pFile;

    //
    // Sanity check.
    //
    PAGED_CODE();

    ASSERT(pFileBuffer);
    ASSERT(IS_FILE_BUFFER_IN_USE(pFileBuffer));
    ASSERT(IS_VALID_FILE_CACHE_ENTRY(pFileBuffer->pFileCacheEntry));
    ASSERT(IS_VALID_IRP(pIrp));

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        UlTrace(FILE_CACHE, (
            "http!UlReadFileEntry(Buffer = %p, pFile = %p, pIrp = %p) MDL Read\n",
            pFileBuffer,
            pFile,
            pIrp
            ));
    
        //
        // Caching file system. Do a MDL read.
        //

        pIrpSp = IoGetNextIrpStackLocation( pIrp );
        pIrpSp->MajorFunction = IRP_MJ_READ;
        pIrpSp->MinorFunction = IRP_MN_MDL;
        pIrpSp->FileObject = pFile->pFileObject;
        pIrpSp->DeviceObject = pFile->pDeviceObject;

        //
        // Initialize the IRP.
        //

        pIrp->MdlAddress = NULL;
        pIrp->Tail.Overlay.Thread = UlQueryIrpThread();

        //
        // Indicate to the file system that this operation can be handled
        // synchronously.  Basically, this means that the file system can
        // use our thread to fault pages in, etc.  This avoids
        // having to context switch to a file system thread.
        //
        pIrp->Flags = IRP_SYNCHRONOUS_API;

        //
        // Set the number of bytes to read and the offset.
        //
        pIrpSp->Parameters.Read.Length = pFileBuffer->Length;
        pIrpSp->Parameters.Read.ByteOffset = pFileBuffer->FileOffset;
        
        ASSERT(pIrpSp->Parameters.Read.Key == 0);

        //
        // Set up the completion routine.
        //
        IoSetCompletionRoutine(
            pIrp,                       // Irp
            UlpRestartReadFileEntry,    // CompletionRoutine
            pFileBuffer,                // Context
            TRUE,                       // InvokeOnSuccess
            TRUE,                       // InvokeOnError
            TRUE                        // InvokeOnCancel
            );

        //
        // Call the driver. Note that we always set status to
        // STATUS_PENDING, since we set the IRP completion routine
        // to *always* be called.
        //

        UlCallDriver( pFile->pDeviceObject, pIrp );

        Status = STATUS_PENDING;

    }
    else
    {
        PUCHAR pFileData;
        PMDL pMdl;
    
        UlTrace(FILE_CACHE, (
            "http!UlReadFileEntry(Buffer = %p, pFile = %p, pIrp = %p) Normal Read\n",
            pFileBuffer,
            pFile,
            pIrp
            ));
            
        //
        // Non-caching file system. Allocate a buffer and issue a
        // normal read.
        //

        pFileData = (PUCHAR)UL_ALLOCATE_POOL(
                        NonPagedPool,
                        pFileBuffer->Length,
                        UL_NONCACHED_FILE_DATA_POOL_TAG
                        );

        if (!pFileData)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        //
        // Get a MDL for our buffer.
        //
        pMdl = IoAllocateMdl(
                    pFileData,
                    pFileBuffer->Length,
                    FALSE,
                    FALSE,
                    NULL
                    );

        if (!pMdl)
        {
            UL_FREE_POOL(
                pFileData,
                UL_NONCACHED_FILE_DATA_POOL_TAG
                );

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        MmBuildMdlForNonPagedPool(pMdl);

        pFileBuffer->pMdl = pMdl;

        //
        // Remember where the data is.
        //
        pFileBuffer->pFileData = pFileData;

        //
        // Set up the read information.
        //

        pIrpSp = IoGetNextIrpStackLocation( pIrp );
        pIrpSp->MajorFunction = IRP_MJ_READ;
        pIrpSp->MinorFunction = IRP_MN_NORMAL;
        pIrpSp->FileObject = pFile->pFileObject;
        pIrpSp->DeviceObject = pFile->pDeviceObject;

        //
        // Initialize the IRP.
        //

        pIrp->MdlAddress = NULL;
        pIrp->Tail.Overlay.Thread = UlQueryIrpThread();

        //
        // Indicate to the file system that this operation can be handled
        // synchronously.  Basically, this means that the file system can
        // use the server's thread to fault pages in, etc.  This avoids
        // having to context switch to a file system thread.
        //
        pIrp->Flags = IRP_SYNCHRONOUS_API;
        
        //
        // Set the number of bytes to read and the offset.
        //
        pIrpSp->Parameters.Read.Length = pFileBuffer->Length;
        pIrpSp->Parameters.Read.ByteOffset = pFileBuffer->FileOffset;
        
        ASSERT(pIrpSp->Parameters.Read.Key == 0);

        //
        // If the target device does buffered I/O, load the address of the
        // caller's buffer as the "system buffered I/O buffer".  If the
        // target device does direct I/O, load the MDL address.  If it does
        // neither, load both the user buffer address and the MDL address.
        // (This is necessary to support file systems, such as HPFS, that
        // sometimes treat the I/O as buffered and sometimes treat it as
        // direct.)
        //

        if (pFileBuffer->pFileCacheEntry->pDeviceObject->Flags & DO_BUFFERED_IO)
        {

            pIrp->AssociatedIrp.SystemBuffer = pFileData;
            pIrp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;

        }
        else if (pFileBuffer->pFileCacheEntry->pDeviceObject->Flags & DO_DIRECT_IO)
        {
            pIrp->MdlAddress = pMdl;

        }
        else
        {
            pIrp->UserBuffer = pFileData;
            pIrp->MdlAddress = pMdl;
        }
    
        //
        // Set up the completion routine.
        //
        IoSetCompletionRoutine(
            pIrp,                       // Irp
            UlpRestartReadFileEntry,    // CompletionRoutine
            pFileBuffer,                // Context
            TRUE,                       // InvokeOnSuccess
            TRUE,                       // InvokeOnError
            TRUE                        // InvokeOnCancel
            );

        //
        // Call the driver. Note that we always set status to
        // STATUS_PENDING, since we set the IRP completion routine
        // to *always* be called.
        //

        UlCallDriver( pFile->pDeviceObject, pIrp );

        Status = STATUS_PENDING;
        
    }

end:
    return Status;
}
    
/***************************************************************************++

Routine Description:

    Reads data from a file. Does a MDL read for filesystems that support
    MDL reads and Fast I/O. If the FS doesn't support fast i/o and MDL
    reads, the function returns with a failure status.

Arguments:

    pFileBuffer - Contains all the info about the read, and the data
                    once that's been read.

--***************************************************************************/
NTSTATUS
UlReadFileEntryFast(
    IN OUT PUL_FILE_BUFFER pFileBuffer
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PUL_FILE_CACHE_ENTRY pFile;

    //
    // Sanity check.
    //
    PAGED_CODE();

    ASSERT(pFileBuffer);
    ASSERT(IS_FILE_BUFFER_IN_USE(pFileBuffer));
    ASSERT(IS_VALID_FILE_CACHE_ENTRY(pFileBuffer->pFileCacheEntry));

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        UlTrace(FILE_CACHE, (
            "http!UlReadFileEntryFast(Buffer = %p, pFile = %p) MDL Read\n",
            pFileBuffer,
            pFile
            ));

        //
        // Cached filesystem. Try to use the fast path for the MDL read
        // complete.
        //
        
        if (pFileBuffer->pFileCacheEntry->pMdlRead(
                pFileBuffer->pFileCacheEntry->pFileObject,
                &pFileBuffer->FileOffset,
                pFileBuffer->Length,
                0,
                &pFileBuffer->pMdl,
                &IoStatus,
                pFileBuffer->pFileCacheEntry->pDeviceObject
                ))
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // It didn't work. The caller must now use the IRP path
            // by calling UlReadFileEntry.
            //
            
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        UlTrace(FILE_CACHE, (
            "http!UlReadFileEntryFast(Buffer = %p, pFile = %p) Normal Read\n",
            pFileBuffer,
            pFile
            ));
        //
        // Non-caching file system. No fast i/o. The caller should
        // use the IRP path by calling UlReadFileEntry.
        //

        Status = STATUS_UNSUCCESSFUL;

    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Frees up resources allocated by UlReadFileEntry (or UlReadFileEntryFast).
    Should be called when the file data read is no longer in use.

Arguments:

    pFileBuffer - Contains all the info about the read, and the data
                    that was read.

    pIrp - This IRP is used to issue the read completion.

--***************************************************************************/
NTSTATUS
UlReadCompleteFileEntry(
    IN PUL_FILE_BUFFER pFileBuffer,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION pIrpSp;
    PUL_FILE_CACHE_ENTRY pFile;
    
    //
    // Sanity check.
    //
    PAGED_CODE();

    ASSERT(pFileBuffer);
    ASSERT(IS_FILE_BUFFER_IN_USE(pFileBuffer));
    ASSERT(IS_VALID_FILE_CACHE_ENTRY(pFileBuffer->pFileCacheEntry));
    ASSERT(IS_VALID_IRP(pIrp));

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        UlTrace(FILE_CACHE, (
            "http!UlReadCompleteFileEntry(Buffer = %p, pFile = %p, pIrp = %p) MDL Read\n",
            pFileBuffer,
            pFile,
            pIrp
            ));
        //
        // Caching file system. Do a MDL read completion.
        //

        pIrpSp = IoGetNextIrpStackLocation( pIrp );
        pIrpSp->MajorFunction = IRP_MJ_READ;
        pIrpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;
        pIrpSp->FileObject = pFile->pFileObject;
        pIrpSp->DeviceObject = pFile->pDeviceObject;

        //
        // Initialize the IRP.
        //
        pIrp->MdlAddress = pFileBuffer->pMdl;
        pIrp->Tail.Overlay.Thread = UlQueryIrpThread();

        //
        // MDL functions are inherently synchronous.
        //
        pIrp->Flags = IRP_SYNCHRONOUS_API;

        //
        // Set the number of bytes to read and the offset.
        //
        pIrpSp->Parameters.Read.Length = pFileBuffer->Length;
        pIrpSp->Parameters.Read.ByteOffset = pFileBuffer->FileOffset;
        
        ASSERT(pIrpSp->Parameters.Read.Key == 0);

        //
        // Set up the completion routine. We don't need to do anything
        // on the completion, so we'll just have the I/O manager call
        // our callers routine directly.
        //
        IoSetCompletionRoutine(
            pIrp,                               // Irp
            pFileBuffer->pCompletionRoutine,    // CompletionRoutine
            pFileBuffer->pContext,              // Context
            TRUE,                               // InvokeOnSuccess
            TRUE,                               // InvokeOnError
            TRUE                                // InvokeOnCancel
            );

        //
        // Call the driver. Note that we always set status to
        // STATUS_PENDING, since we set the IRP completion routine
        // to *always* be called.
        //

        UlCallDriver( pFile->pDeviceObject, pIrp );

        Status = STATUS_PENDING;

    }
    else
    {
        UlTrace(FILE_CACHE, (
            "http!UlReadCompleteFileEntry(Buffer = %p, pFile = %p) Normal Read\n",
            pFileBuffer,
            pFile
            ));
        //
        // Non-caching file system. We allocated this buffer. Just
        // free it and call the completion routine.
        //

        ASSERT(pFileBuffer->pMdl);
        
        IoFreeMdl(pFileBuffer->pMdl);
        pFileBuffer->pMdl = NULL;

        ASSERT(pFileBuffer->pFileData);
        
        UL_FREE_POOL(
            pFileBuffer->pFileData,
            UL_NONCACHED_FILE_DATA_POOL_TAG
            );

        pFileBuffer->pFileData = NULL;

        //
        // Fake the completion here.
        //
        pFileBuffer->pCompletionRoutine(
            pFileBuffer->pFileCacheEntry->pDeviceObject,
            pIrp,
            pFileBuffer->pContext
            );

        //
        // Return pending, since we called their completion routine.
        //
        Status = STATUS_PENDING;
    }

    if (!NT_SUCCESS(Status))
    {
        UlTrace(FILE_CACHE, (
            "http!UlReadCompleteFileEntry(Buffer = %p, pFile = %p) FAILED! %x\n",
            pFileBuffer,
            pFile,
            Status
            ));
        
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Frees up resources allocated by UlReadFileEntry (or UlReadFileEntryFast).
    Should be called when the file data read is no longer in use.

Arguments:

    pFileBuffer - Contains all the info about the read, and the data
                    that was read.

--***************************************************************************/
NTSTATUS
UlReadCompleteFileEntryFast(
    IN PUL_FILE_BUFFER pFileBuffer
    )
{
    NTSTATUS Status;
    PUL_FILE_CACHE_ENTRY pFile;

    //
    // Sanity check.
    //
    PAGED_CODE();

    ASSERT(pFileBuffer);
    ASSERT(IS_FILE_BUFFER_IN_USE(pFileBuffer));
    ASSERT(IS_VALID_FILE_CACHE_ENTRY(pFileBuffer->pFileCacheEntry));

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        UlTrace(FILE_CACHE, (
            "http!UlReadCompleteFileEntryFast(Buffer = %p, pFile = %p) MDL Read\n",
            pFileBuffer,
            pFile
            ));

        //
        // Cached filesystem. Try to use the fast path for the MDL read
        // complete.
        //
        
        if (pFileBuffer->pFileCacheEntry->pMdlReadComplete(
                pFileBuffer->pFileCacheEntry->pFileObject,
                pFileBuffer->pMdl,
                pFileBuffer->pFileCacheEntry->pDeviceObject
                ))
        {
            pFileBuffer->pMdl = NULL;
            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // It didn't work. The caller must now use the IRP path
            // by calling UlReadCompleteFileEntry.
            //
            
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        UlTrace(FILE_CACHE, (
            "http!UlReadCompleteFileEntryFast(Buffer = %p, pFile = %p) Normal Read\n",
            pFileBuffer,
            pFile
            ));
        //
        // Non-caching file system. We allocated this buffer. Just
        // free it.
        //

        ASSERT(pFileBuffer->pMdl);
        
        IoFreeMdl(pFileBuffer->pMdl);
        pFileBuffer->pMdl = NULL;

        ASSERT(pFileBuffer->pFileData);
        
        UL_FREE_POOL(
            pFileBuffer->pFileData,
            UL_NONCACHED_FILE_DATA_POOL_TAG
            );

        Status = STATUS_SUCCESS;

    }

    return Status;
}



//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Helper function to destroy a file cache entry.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_FILE_CACHE_ENTRY.

--***************************************************************************/
VOID
UlpDestroyFileCacheEntry(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_FILE_CACHE_ENTRY pFileCacheEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pFileCacheEntry = CONTAINING_RECORD(
                            pWorkItem,
                            UL_FILE_CACHE_ENTRY,
                            WorkItem
                            );

    IF_DEBUG( FILE_CACHE )
    {
        KdPrint((
            "UlpDestroyFileCacheEntry: entry %p\n",
            pFileCacheEntry
            ));
    }

    ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileCacheEntry ) );

    //
    // Cleanup the file system stuff.
    //

    if (pFileCacheEntry->pFileObject != NULL)
    {
        ObDereferenceObject( pFileCacheEntry->pFileObject );
    }

    if (pFileCacheEntry->FileHandle != NULL)
    {
        UlCloseSystemHandle( pFileCacheEntry->FileHandle );
    }

    //
    // Now release the entry's resources.
    //

    pFileCacheEntry->Signature = UL_FILE_CACHE_ENTRY_SIGNATURE_X;
    UL_FREE_POOL( pFileCacheEntry, UL_FILE_CACHE_ENTRY_POOL_TAG );

}   // UlpDestroyFileCacheEntry


/***************************************************************************++

Routine Description:

    Dummy function to fail MDL reads.

Arguments:

    Same as FsRtlMdlReadDev().

Return Value:

    BOOLEAN - Always FALSE (failure).

--***************************************************************************/
BOOLEAN
UlpFailMdlReadDev(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PAGED_CODE();
    return FALSE;

}   // UlpFailMdlReadDev


/***************************************************************************++

Routine Description:

    Dummy function to fail MDL read completes.

Arguments:

    Same as FsRtlMdlReadCompleteDev().

Return Value:

    BOOLEAN - Always FALSE (failure).

--***************************************************************************/
BOOLEAN
UlpFailMdlReadCompleteDev(
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PAGED_CODE();
    return FALSE;

}   // UlpFailMdlReadCompleteDev


/***************************************************************************++

Routine Description:

    Completion routine for UlReadFileEntry. Sets the data fields in
    the UL_FILE_BUFFER and calls the completion routine passed to
    UlReadFileEntry.

Arguments:

    pDeviceObject - the file system device object (not used)

    pIrp - the IRP used to do the read

    pContext - pointer to the UL_FILE_BUFFER

--***************************************************************************/
NTSTATUS
UlpRestartReadFileEntry(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    NTSTATUS Status;
    PUL_FILE_BUFFER pFileBuffer = (PUL_FILE_BUFFER)pContext;
    PUL_FILE_CACHE_ENTRY pFile;

    //
    // Sanity check.
    //
    ASSERT(pFileBuffer);
    ASSERT(IS_FILE_BUFFER_IN_USE(pFileBuffer));
    ASSERT(IS_VALID_FILE_CACHE_ENTRY(pFileBuffer->pFileCacheEntry));

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        //
        // This was a MDL read.
        //

        if (NT_SUCCESS(pIrp->IoStatus.Status))
        {
            pFileBuffer->pMdl = pIrp->MdlAddress;
        }
    }
    else
    {
        //
        // This was a Normal Read. pFileBuffer->pMdl
        // was already set by UlReadFileEntry.
        //
        ASSERT(pFileBuffer->pMdl);

    }

    if (pFileBuffer->pCompletionRoutine)
    {
        Status = (pFileBuffer->pCompletionRoutine)(
                        pDeviceObject,
                        pIrp,
                        pFileBuffer->pContext
                        );
    }
    else
    {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\fastio.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    fastio.h

Abstract:

    This module contains declarations related to fast I/O.

Author:

    Chun Ye (chunye)    09-Dec-2000

Revision History:

--*/


#ifndef _FASTIO_H_
#define _FASTIO_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Some useful macroes.
//

#define IS_LENGTH_SPECIFIED( pKnownHeaders )                                \
    (pKnownHeaders[HttpHeaderContentLength].RawValueLength > 0)

#define IS_CHUNK_SPECIFIED( pKnownHeaders )                                 \
    (pKnownHeaders[HttpHeaderTransferEncoding].RawValueLength > 0 &&        \
     0 == _strnicmp(                                                        \
                pKnownHeaders[HttpHeaderTransferEncoding].pRawValue,        \
                "chunked",                                                  \
                strlen("chunked")                                           \
                ))                                                          \


//
// Inline functions to allocate/free a fast tracker.
//

__inline
PUL_FULL_TRACKER
FASTCALL
UlpAllocateFastTracker(
    IN ULONG FixedHeaderLength,
    IN CCHAR SendIrpStackSize
    )
{
    PUL_FULL_TRACKER pTracker;
    ULONG SpaceLength;
    ULONG MaxFixedHeaderSize;
    USHORT MaxSendIrpSize;
    CCHAR MaxSendIrpStackSize;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (FixedHeaderLength > g_UlMaxFixedHeaderSize ||
        SendIrpStackSize > DEFAULT_MAX_IRP_STACK_SIZE)
    {
        MaxFixedHeaderSize = MAX(FixedHeaderLength, g_UlMaxFixedHeaderSize);
        MaxSendIrpStackSize = MAX(SendIrpStackSize, DEFAULT_MAX_IRP_STACK_SIZE);
        MaxSendIrpSize = (USHORT)ALIGN_UP(IoSizeOfIrp(MaxSendIrpStackSize), PVOID);

        SpaceLength =
            ALIGN_UP(sizeof(UL_FULL_TRACKER), PVOID) +
                MaxSendIrpSize +
                MaxFixedHeaderSize +
                g_UlMaxVariableHeaderSize +
                g_UlMaxCopyThreshold +
                g_UlFixedHeadersMdlLength +
                g_UlVariableHeadersMdlLength +
                g_UlContentMdlLength;

        pTracker = (PUL_FULL_TRACKER)UL_ALLOCATE_POOL(
                                        NonPagedPool,
                                        SpaceLength,
                                        UL_FULL_TRACKER_POOL_TAG
                                        );

        if (pTracker)
        {
            pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
            pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
            pTracker->IsFromLookaside = FALSE;
            pTracker->IsFromRequest = FALSE;
            pTracker->AuxilaryBufferLength =
                MaxFixedHeaderSize +
                g_UlMaxVariableHeaderSize +
                g_UlMaxCopyThreshold;

            UlInitializeFullTrackerPool( pTracker, MaxSendIrpStackSize );
        }
    }
    else
    {
        pTracker = UlPplAllocateFullTracker();

        if (pTracker)
        {
            ASSERT(pTracker->Signature == MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG));
            pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
            pTracker->pLogData = NULL;

            // BUGBUG: I know we're trying to squeeze every last cycle
            // out of the fast path, but can we really get away with
            // this little initialization?
        }
    }

    return pTracker;
} // UlpAllocateFastTracker


__inline
VOID
FASTCALL
UlpFreeFastTracker(
    IN PUL_FULL_TRACKER pTracker
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_FULL_TRACKER( pTracker ) );

    if (pTracker->pLogData)
    {
        UlDestroyLogDataBuffer( pTracker->pLogData );
    }

    if (pTracker->IsFromRequest == FALSE)
    {
        if (pTracker->IsFromLookaside)
        {
            pTracker->Signature = MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG);
            UlPplFreeFullTracker( pTracker );
        }
        else
        {
            UL_FREE_POOL_WITH_SIG( pTracker, UL_FULL_TRACKER_POOL_TAG );
        }
    }
} // UlpFreeFastTracker


//
// Dispatch routines for fast I/O.
//

extern FAST_IO_DISPATCH UlFastIoDispatch;


//
// Fast I/O routines.
//

BOOLEAN
UlFastIoDeviceControl (
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN Wait,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN PDEVICE_OBJECT pDeviceObject
    );


BOOLEAN
UlSendHttpResponseFastIo(
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN Wait,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN PDEVICE_OBJECT pDeviceObject,
    IN BOOLEAN RawResponse
    );

BOOLEAN
UlReceiveHttpRequestFastIo(
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN Wait,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN PDEVICE_OBJECT pDeviceObject
    );


//
// Private prototypes.
//

NTSTATUS
UlpFastSendHttpResponse(
    IN PHTTP_RESPONSE pUserResponse OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL,
    IN PHTTP_DATA_CHUNK pDataChunk,
    IN ULONG ChunkCount,
    IN ULONG Flags,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP pUserIrp OPTIONAL,
    OUT PULONG BytesSent
    );

VOID
UlpRestartFastSendHttpResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpFastSendCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpFastReceiveHttpRequest(
    IN HTTP_REQUEST_ID RequestId,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesRead
    );

NTSTATUS
UlpFastCopyHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesRead
    );


//
// An inline function to generate the content-length string.
//

__inline
ULONG
FASTCALL
UlpFastGenerateContentLength(
    IN PCHAR LengthString,
    IN ULONG Length
    )
{
    ASSERT( ALIGN_UP_POINTER(LengthString, ULONG) == (PVOID)LengthString );
    ASSERT( Length < 100000 );

    if (Length >= 10000)
    {
        *((PULONG)LengthString) = *((PULONG)"0000");
        LengthString[0] += (CHAR)((Length / 10000) % 10);
        LengthString[1] += (CHAR)((Length / 1000) % 10);
        LengthString[2] += (CHAR)((Length / 100) % 10);
        LengthString[3] += (CHAR)((Length / 10) % 10);
        LengthString[4] = (CHAR)('0' + (Length / 1) % 10);
        LengthString[5] = ANSI_NULL;
        return 5;
    }
    else
    if (Length >= 1000)
    {
        *((PULONG)LengthString) = *((PULONG)"0000");
        LengthString[0] += (CHAR)((Length / 1000) % 10);
        LengthString[1] += (CHAR)((Length / 100) % 10);
        LengthString[2] += (CHAR)((Length / 10) % 10);
        LengthString[3] += (CHAR)((Length / 1) % 10);
        LengthString[4] = ANSI_NULL;
        return 4;
    }
    else
    if (Length >= 100)
    {
        *((PULONG)LengthString) = *((PULONG)"0000");
        LengthString[0] += (CHAR)((Length / 100) % 10);
        LengthString[1] += (CHAR)((Length / 10) % 10);
        LengthString[2] += (CHAR)((Length / 1) % 10);
        LengthString[3] = ANSI_NULL;
        return 3;
    }
    else
    if (Length >= 10)
    {
        *((PUSHORT)LengthString) = *((PUSHORT)"00");
        LengthString[0] += (CHAR)((Length / 10) % 10);
        LengthString[1] += (CHAR)((Length / 1) % 10);
        LengthString[2] = ANSI_NULL;
        return 2;
    }
    else
    {
        LengthString[0] = (CHAR)('0' + (Length / 1) % 10);
        LengthString[1] = ANSI_NULL;
        return 1;
    }
} // UlpFastGenerateContentLength


//
// An inline function to ProbeForRead the header portions of the HTTP_RESPONSE.
//

#define UL_MAX_HTTP_STATUS_CODE     999

__inline
NTSTATUS
FASTCALL
UlProbeHttpHeaders(
    IN PHTTP_RESPONSE pUserResponse
    )
{
    NTSTATUS Status;
    PHTTP_UNKNOWN_HEADER pUnknownHeaders;
    USHORT Length;
    LONG i;

    Status = STATUS_SUCCESS;

    if (pUserResponse == NULL)
    {
        return Status;
    }

    __try
    {
        //
        // Check flags and status code.
        //

        if ((pUserResponse->Flags & ~HTTP_RESPONSE_FLAG_VALID) ||
            (pUserResponse->StatusCode > UL_MAX_HTTP_STATUS_CODE))
        {
            ExRaiseStatus( STATUS_INVALID_PARAMETER );
        }

        //
        // Check the response structure.
        //

        ProbeTestForRead(
            pUserResponse,
            sizeof(HTTP_RESPONSE),
            sizeof(USHORT)
            );

        //
        // Check the reason string.
        //

        ProbeTestForRead(
            pUserResponse->pReason,
            pUserResponse->ReasonLength,
            sizeof(CHAR)
            );

        //
        // Loop through the known headers.
        //

        for (i = 0; i < HttpHeaderResponseMaximum; i++)
        {
            Length = pUserResponse->Headers.pKnownHeaders[i].RawValueLength;

            if (Length > 0)
            {
                ProbeTestForRead(
                    pUserResponse->Headers.pKnownHeaders[i].pRawValue,
                    Length,
                    sizeof(CHAR)
                    );
            }
        }

        //
        // And the unknown headers (this might throw an exception).
        //

        pUnknownHeaders = pUserResponse->Headers.pUnknownHeaders;

        if (pUnknownHeaders != NULL)
        {
            ProbeTestForRead(
                pUnknownHeaders,
                sizeof(HTTP_UNKNOWN_HEADER) * pUserResponse->Headers.UnknownHeaderCount,
                sizeof(ULONG)
                );

            for (i = 0; i < (LONG)(pUserResponse->Headers.UnknownHeaderCount); i++)
            {
                if (pUnknownHeaders[i].NameLength > 0)
                {
                    ProbeTestForRead(
                        pUnknownHeaders[i].pName,
                        pUnknownHeaders[i].NameLength,
                        sizeof(CHAR)
                        );

                    ProbeTestForRead(
                        pUnknownHeaders[i].pRawValue,
                        pUnknownHeaders[i].RawValueLength,
                        sizeof(CHAR)
                        );
                }
            }
        }

        
        UlTrace(IOCTL,
                ("UlProbeHttpHeaders validated the headers: %x\n", Status));
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        UlTrace(IOCTL,
                ("UlProbeHttpHeaders caught an exception: %x\n", Status));
    }

    return Status;
} // UlProbeHttpHeaders


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _FASTIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\devctrl.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    devctrl.cxx

Abstract:

    This module contains the dispatcher for device control IRPs.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlDeviceControl
#endif


//
// Lookup table to verify incoming IOCTL codes.
//

typedef
NTSTATUS
(NTAPI * PFN_IOCTL_HANDLER)(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

typedef struct _UL_IOCTL_TABLE
{
    ULONG IoControlCode;

#if DBG
    PCSTR IoControlName;
# define UL_IOCTL(code) IOCTL_HTTP_##code, #code
#else // !DBG
# define UL_IOCTL(code) IOCTL_HTTP_##code
#endif // !DBG

    PFN_IOCTL_HANDLER Handler;
} UL_IOCTL_TABLE, *PUL_IOCTL_TABLE;


UL_IOCTL_TABLE UlIoctlTable[] =
    {
        { UL_IOCTL(QUERY_CONTROL_CHANNEL),
          &UlQueryControlChannelIoctl
        },
        { UL_IOCTL(SET_CONTROL_CHANNEL),
          &UlSetControlChannelIoctl
        },
        { UL_IOCTL(CREATE_CONFIG_GROUP),
          &UlCreateConfigGroupIoctl
        },
        { UL_IOCTL(DELETE_CONFIG_GROUP),
          &UlDeleteConfigGroupIoctl
        },
        { UL_IOCTL(QUERY_CONFIG_GROUP),
          &UlQueryConfigGroupIoctl
        },
        { UL_IOCTL(SET_CONFIG_GROUP),
          &UlSetConfigGroupIoctl
        },
        { UL_IOCTL(ADD_URL_TO_CONFIG_GROUP),
          &UlAddUrlToConfigGroupIoctl
        },
        { UL_IOCTL(REMOVE_URL_FROM_CONFIG_GROUP),
          &UlRemoveUrlFromConfigGroupIoctl
        },
        { UL_IOCTL(QUERY_APP_POOL_INFORMATION),
          &UlQueryAppPoolInformationIoctl
        },
        { UL_IOCTL(SET_APP_POOL_INFORMATION),
          &UlSetAppPoolInformationIoctl
        },
        { UL_IOCTL(RECEIVE_HTTP_REQUEST),
          &UlReceiveHttpRequestIoctl
        },
        { UL_IOCTL(RECEIVE_ENTITY_BODY),
          &UlReceiveEntityBodyIoctl
        },
        { UL_IOCTL(SEND_HTTP_RESPONSE),
          &UlSendHttpResponseIoctl
        },
        { UL_IOCTL(SEND_ENTITY_BODY),
          &UlSendEntityBodyIoctl
        },
        { UL_IOCTL(FLUSH_RESPONSE_CACHE),
          &UlFlushResponseCacheIoctl
        },
        { UL_IOCTL(WAIT_FOR_DEMAND_START),
          &UlWaitForDemandStartIoctl
        },
        { UL_IOCTL(WAIT_FOR_DISCONNECT),
          &UlWaitForDisconnectIoctl
        },
        { UL_IOCTL(REMOVE_ALL_URLS_FROM_CONFIG_GROUP),
          &UlRemoveAllUrlsFromConfigGroupIoctl
        },
        { UL_IOCTL(ADD_TRANSIENT_URL),
          &UlAddTransientUrlIoctl
        },
        { UL_IOCTL(REMOVE_TRANSIENT_URL),
          &UlRemoveTransientUrlIoctl
        },
        { UL_IOCTL(FILTER_ACCEPT),
          &UlFilterAcceptIoctl
        },
        { UL_IOCTL(FILTER_CLOSE),
          &UlFilterCloseIoctl
        },
        { UL_IOCTL(FILTER_RAW_READ),
          &UlFilterRawReadIoctl
        },
        { UL_IOCTL(FILTER_RAW_WRITE),
          &UlFilterRawWriteIoctl
        },
        { UL_IOCTL(FILTER_APP_READ),   
          &UlFilterAppReadIoctl
        },
        { UL_IOCTL(FILTER_APP_WRITE),
          &UlFilterAppWriteIoctl
        },
        { UL_IOCTL(FILTER_RECEIVE_CLIENT_CERT),
          &UlReceiveClientCertIoctl
        },
        { UL_IOCTL(GET_COUNTERS),
          &UlGetCountersIoctl
        },
    };

C_ASSERT( HTTP_NUM_IOCTLS == DIMENSION(UlIoctlTable) );


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the dispatch routine for IOCTL IRPs.

Arguments:

    pDeviceObject - Pointer to device object for target device.

    pIrp - Pointer to IO request packet.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--***************************************************************************/
NTSTATUS
UlDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    ULONG code;
    ULONG request;
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;

    UL_ENTER_DRIVER( "UlDeviceControl", pIrp );

    //
    // Snag the current IRP stack pointer.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    //
    // Extract the IOCTL control code and process the request.
    //

    code = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    request = _HTTP_REQUEST(code);

    if (request < HTTP_NUM_IOCTLS &&
        UlIoctlTable[request].IoControlCode == code)
    {
#if DBG
        KIRQL oldIrql = KeGetCurrentIrql();
#endif  // DBG

        UlTrace(IOCTL,
                ("UlDeviceControl: %-30s code=0x%08lx, "
                 "pIrp=%p, pIrpSp=%p.\n",
                 UlIoctlTable[request].IoControlName, code,
                 pIrp, pIrpSp
                 ));

        status = (UlIoctlTable[request].Handler)( pIrp, pIrpSp );
        ASSERT( KeGetCurrentIrql() == oldIrql );
    }
    else
    {
        //
        // If we made it this far, then the ioctl is invalid.
        //

        KdPrint(( "UlDeviceControl: invalid IOCTL %08lX\n", code ));

        status = STATUS_INVALID_DEVICE_REQUEST;
        pIrp->IoStatus.Status = status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    UL_LEAVE_DRIVER( "UlDeviceControl" );

    return status;

}   // UlDeviceControl


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\fastio.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    fastio.cxx

Abstract:

    This module implements the fast I/O logic of HTTP.SYS.

Author:

    Chun Ye (chunye)    09-Dec-2000

Revision History:

--*/


#include "precomp.h"


//
// Private globals.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlFastIoDeviceControl )
#pragma alloc_text( PAGE, UlSendHttpResponseFastIo )
#pragma alloc_text( PAGE, UlReceiveHttpRequestFastIo )
#pragma alloc_text( PAGE, UlpFastSendHttpResponse )
#pragma alloc_text( PAGE, UlpFastReceiveHttpRequest )
#pragma alloc_text( PAGE, UlpFastCopyHttpRequest )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpRestartFastSendHttpResponse
NOT PAGEABLE -- UlpFastSendCompleteWorker
#endif


FAST_IO_DISPATCH UlFastIoDispatch =
{
    sizeof(FAST_IO_DISPATCH),   // SizeOfFastIoDispatch
    NULL,                       // FastIoCheckIfPossible
    NULL,                       // FastIoRead
    NULL,                       // FastIoWrite
    NULL,                       // FastIoQueryBasicInfo
    NULL,                       // FastIoQueryStandardInfo
    NULL,                       // FastIoLock
    NULL,                       // FastIoUnlockSingle
    NULL,                       // FastIoUnlockAll
    NULL,                       // FastIoUnlockAllByKey
    UlFastIoDeviceControl       // FastIoDeviceControl
};


//
// Public functions.
//

BOOLEAN
UlFastIoDeviceControl(
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN Wait,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN PDEVICE_OBJECT pDeviceObject
    )
{
    if (IoControlCode == IOCTL_HTTP_SEND_HTTP_RESPONSE ||
        IoControlCode == IOCTL_HTTP_SEND_ENTITY_BODY)
    {
        return UlSendHttpResponseFastIo(
                    pFileObject,
                    Wait,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pIoStatus,
                    pDeviceObject,
                    IoControlCode == IOCTL_HTTP_SEND_ENTITY_BODY? TRUE: FALSE
                    );
    }
    else
    if (IoControlCode == IOCTL_HTTP_RECEIVE_HTTP_REQUEST)
    {
        return UlReceiveHttpRequestFastIo(
                    pFileObject,
                    Wait,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pIoStatus,
                    pDeviceObject
                    );
    }
    else
    {
        return FALSE;
    }
} // UlFastIoDeviceControl


BOOLEAN
UlSendHttpResponseFastIo(
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN Wait,
    IN PVOID pInputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN PDEVICE_OBJECT pDeviceObject,
    IN BOOLEAN RawResponse
    )
{
    NTSTATUS Status;
    PHTTP_SEND_HTTP_RESPONSE_INFO pSendInfo;
    PUL_INTERNAL_REQUEST pRequest = NULL;
    LONG BufferLength = 0;
    ULONG BytesSent;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Initialize IoStatus in the failure case.
    //

    pIoStatus->Information = 0;

    //
    // Ensure this is really an app pool, not a control channel.
    //

    if (IS_APP_POOL(pFileObject) == FALSE)
    {
        //
        // Not an app pool.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pInputBuffer == NULL || InputBufferLength < sizeof(*pSendInfo))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    pSendInfo = (PHTTP_SEND_HTTP_RESPONSE_INFO)pInputBuffer;

    //
    // Check if fast path can be taken for this response.
    //

    __try
    {
        ProbeTestForRead(
            pSendInfo,
            sizeof(*pSendInfo),
            sizeof(PVOID)
            );

        //
        // Fast path is only enabled if the response can be buffered.
        //

        if (RawResponse == FALSE &&
            pSendInfo->CachePolicy.Policy != HttpCachePolicyNocache &&
            g_UriCacheConfig.EnableCache)
        {
            //
            // Take the slow path if we need to build a cache entry.
            //

            Status = STATUS_NOT_IMPLEMENTED;
        }
        else
        if (pSendInfo->EntityChunkCount == 0)
        {
            //
            // Fast path should have no problem handling zero chunk responses.
            // Validate the response type.
            //

            if (RawResponse)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                Status = STATUS_SUCCESS;
            }
        }
        else
        {
            PHTTP_DATA_CHUNK pEntityChunks = pSendInfo->pEntityChunks;
            ULONG i;

            //
            // Make sure all chunks are from memory and their total size
            // is <= g_UlMaxCopyThreshold. Take the slow path if this is
            // not the case.
            //

            Status = STATUS_SUCCESS;

            for (i = 0; i < pSendInfo->EntityChunkCount; i++)
            {
                ProbeTestForRead(
                    pEntityChunks,
                    sizeof(HTTP_DATA_CHUNK),
                    sizeof(PVOID)
                    );

                if (pEntityChunks->DataChunkType != HttpDataChunkFromMemory)
                {
                    Status = STATUS_NOT_SUPPORTED;
                    break;
                }

                BufferLength += pEntityChunks->FromMemory.BufferLength;

                if (BufferLength > (LONG)g_UlMaxCopyThreshold)
                {
                    Status = STATUS_NOT_SUPPORTED;
                    break;
                }

                pEntityChunks++;
            }
        }
    }
     __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }

    if (NT_SUCCESS(Status) == FALSE)
    {
        // BUGBUG: should close connection
        goto end;
    }

    //
    // SendHttpResponse *must* take a PHTTP_RESPONSE. This will
    // protect us from those whackos that attempt to build their own
    // raw response headers. This is ok for SendEntityBody. The
    // two cases are differentiated by the RawResponse flag.
    //

    if (RawResponse == FALSE && pSendInfo->pHttpResponse == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Now get the request from the request ID. This gives us a reference
    // to the request.
    //

    pRequest = UlGetRequestFromId( pSendInfo->RequestId );

    if (pRequest == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pRequest->pHttpConn ) );

    //
    // Check if we have exceeded maximum SendBufferedBytes limit.
    //

    if ((BufferLength + pRequest->pHttpConn->SendBufferedBytes) >
        (LONG)g_UlMaxSendBufferedBytes)
    {
        Status = STATUS_ALLOTTED_SPACE_EXCEEDED;
        goto end;
    }

    //
    // Check if a response has already been sent on this request. We can test
    // this without acquiring the request resource, since the flag is only
    // set (never reset).
    //

    if (RawResponse == FALSE)
    {
        //
        // Make sure only one response header goes back.
        //

        if (1 == InterlockedCompareExchange(
                    (PLONG)&pRequest->SentResponse,
                    1,
                    0
                    ))
        {
            Status = STATUS_INVALID_DEVICE_STATE;
            goto end;
        }
    }
    else
    if (pRequest->SentResponse == 0)
    {
        //
        // Ensure a response has already been sent. If the application is
        // sending entity without first having sent a response header, check
        // the HTTP_SEND_RESPONSE_FLAG_RAW_HEADER flag.
        //

        if ((pSendInfo->Flags & HTTP_SEND_RESPONSE_FLAG_RAW_HEADER))
        {
            //
            // Make sure only one response header goes back.
            //

            if (1 == InterlockedCompareExchange(
                        (PLONG)&pRequest->SentResponse,
                        1,
                        0
                        ))
            {
                Status = STATUS_INVALID_DEVICE_STATE;
                goto end;
            }
        }
        else
        {
            Status = STATUS_INVALID_DEVICE_STATE;
            goto end;
        }
    }

    //
    // Also ensure that all previous calls to SendHttpResponse
    // and SendEntityBody had the MORE_DATA flag set.
    //

    if ((pSendInfo->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0)
    {
        //
        // Set if we have sent the last response, but bail out if the flag
        // is already set since there can be only one last response.
        //

        if (1 == InterlockedCompareExchange(
                    (PLONG)&pRequest->SentLast,
                    1,
                    0
                    ))
        {
            Status = STATUS_INVALID_DEVICE_STATE;
            goto end;
        }
    }
    else
    if (pRequest->SentLast == 1)
    {
        Status = STATUS_INVALID_DEVICE_STATE;
        goto end;
    }

    //
    // OK, we have the connection. Now capture the incoming HTTP_RESPONSE
    // structure, map it to our internal format and send the response.
    //

    Status = UlpFastSendHttpResponse(
                    pSendInfo->pHttpResponse,
                    pSendInfo->pLogData,
                    pSendInfo->pEntityChunks,
                    pSendInfo->EntityChunkCount,
                    pSendInfo->Flags,
                    pRequest,
                    NULL,
                    &BytesSent
                    );

    if (NT_SUCCESS(Status))
    {
        //
        // Record the number of bytes we have sent successfully.
        //

        pIoStatus->Information = BytesSent;
    }

end:

    if (pRequest != NULL)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );
    }

    //
    // Complete the fast I/O.
    //

    if (NT_SUCCESS(Status))
    {
        //
        // If we took the fast path, always return success even if completion
        // routine returns failure later.
        //

        pIoStatus->Status = STATUS_SUCCESS;
        return TRUE;
    }
    else
    {
        pIoStatus->Status = Status;
        return FALSE;
    }
} // UlSendHttpResponseFastIo


BOOLEAN
UlReceiveHttpRequestFastIo(
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN Wait,
    IN PVOID pInputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN PDEVICE_OBJECT pDeviceObject
    )
{
    NTSTATUS Status;
    PHTTP_RECEIVE_REQUEST_INFO pRequestInfo;
    ULONG BytesRead;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure this is really an app pool, not a control channel.
    //

    if (IS_APP_POOL(pFileObject) || NULL != pInputBuffer)
    {
        if (NULL != pOutputBuffer &&
            OutputBufferLength >= sizeof(HTTP_REQUEST) &&
            InputBufferLength == sizeof(HTTP_RECEIVE_REQUEST_INFO))
        {
            pRequestInfo = (PHTTP_RECEIVE_REQUEST_INFO) pInputBuffer;

            Status = STATUS_SUCCESS;

            __try
            {
                ProbeTestForRead(
                    pRequestInfo,
                    sizeof(*pRequestInfo),
                    sizeof(PVOID)
                    );
            }
            __except( UL_EXCEPTION_FILTER() )
            {
                Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
            }

            if (NT_SUCCESS(Status))
            {
                Status = UlpFastReceiveHttpRequest(
                            pRequestInfo->RequestId,
                            GET_APP_POOL_PROCESS(pFileObject),
                            pOutputBuffer,
                            OutputBufferLength,
                            &BytesRead
                            );
            }
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Complete the fast I/O.
    //

    if (NT_SUCCESS(Status))
    {
        pIoStatus->Status = STATUS_SUCCESS;
        pIoStatus->Information = BytesRead;
        return TRUE;
    }
    else
    {
        pIoStatus->Status = Status;
        pIoStatus->Information = 0;
        return FALSE;
    }
} // UlReceiveHttpRequestFastIo


//
// Private functions.
//

NTSTATUS
UlpFastSendHttpResponse(
    IN PHTTP_RESPONSE pUserResponse OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pUserLogData OPTIONAL,
    IN PHTTP_DATA_CHUNK pUserEntityDataChunk,
    IN ULONG ChunkCount,
    IN ULONG Flags,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP pUserIrp OPTIONAL,
    OUT PULONG BytesSent
    )
{
    NTSTATUS Status;
    PUCHAR pResponseBuffer;
    ULONG ResponseBufferLength;
    ULONG HeaderLength;
    ULONG FixedHeaderLength;
    ULONG VarHeaderLength;
    ULONG ContentLength = 0;
    ULONG TotalResponseSize;
    ULONG ContentLengthStringLength;
    CHAR ContentLengthString[MAX_ULONGLONG_STR];
    PUL_FULL_TRACKER pTracker = NULL;
    PUL_HTTP_CONNECTION pHttpConnection = NULL;
    PUL_CONNECTION pConnection;
    CCHAR SendIrpStackSize;
    BOOLEAN Disconnect;
    UL_CONN_HDR ConnHeader;
    LARGE_INTEGER TimeSent;
    BOOLEAN LastResponse;
    PMDL pSendMdl;
    ULONG i;
    KIRQL OldIrql;

    //
    // Sanity check.
    //

    PAGED_CODE();

    __try
    {
        //
        // Setup locals so we know how to cleanup on exit.
        //

        Status = UlProbeHttpHeaders( pUserResponse );

        if (NT_SUCCESS(Status) == FALSE)
        {
            // BUGBUG: 389145: should close the connection
            goto end;
        }

        for (i = 0; i < ChunkCount; i++)
        {
            ContentLength += pUserEntityDataChunk[i].FromMemory.BufferLength;
        }

        ASSERT( pUserIrp != NULL || ContentLength <= g_UlMaxCopyThreshold );
        ASSERT( pUserIrp == NULL || ContentLength <= MAX_BYTES_BUFFERED );

        //
        // Allocate a fast tracker to send the response.
        //

        pConnection = pRequest->pHttpConn->pConnection;
        SendIrpStackSize = pConnection->ConnectionObject.pDeviceObject->StackSize;
        LastResponse = (0 == (Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA));

        if (LastResponse && SendIrpStackSize <= DEFAULT_MAX_IRP_STACK_SIZE)
        {
            pTracker = pRequest->pTracker;
        }
        else
        {
            pTracker = UlpAllocateFastTracker( 0, SendIrpStackSize );
        }

        if (pTracker == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        //
        // Try to generate the fixed header within the default fixed header
        // buffer first. If this fails, take the normal path.
        //

        pResponseBuffer = pTracker->pAuxiliaryBuffer;

        if (pUserIrp != NULL)
        {
            ResponseBufferLength =
                g_UlMaxFixedHeaderSize + g_UlMaxCopyThreshold;
        }
        else
        {
            ResponseBufferLength =
                g_UlMaxFixedHeaderSize + g_UlMaxCopyThreshold - ContentLength;
        }

        if (pUserResponse != NULL)
        {
            Status = UlGenerateFixedHeaders(
                        pRequest->Version,
                        pUserResponse,
                        ResponseBufferLength,
                        pResponseBuffer,
                        &FixedHeaderLength
                        );

            if (!NT_SUCCESS(Status))
            {
                // Either the buffer was too small or an exception was thrown.
                if (Status != STATUS_INSUFFICIENT_RESOURCES)
                    goto end;

                if (pTracker->IsFromRequest == FALSE)
                {
                    if (pTracker->IsFromLookaside)
                    {
                        pTracker->Signature
                            = MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG);
                        UlPplFreeFullTracker( pTracker );
                    }
                    else
                    {
                        UL_FREE_POOL_WITH_SIG(
                                pTracker,
                                UL_FULL_TRACKER_POOL_TAG
                                );
                    }
                }

                //
                // Calculate the fixed header size.
                //

                Status = UlComputeFixedHeaderSize(
                                    pRequest->Version,
                                    pUserResponse,
                                    &HeaderLength
                                    );

                if (!NT_SUCCESS(Status))
                    goto end;

                ASSERT( HeaderLength > ResponseBufferLength );

                pTracker = UlpAllocateFastTracker(
                                 HeaderLength,
                                 SendIrpStackSize
                                 );

                if (pTracker == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto end;
                }

                pResponseBuffer = pTracker->pAuxiliaryBuffer;

                Status = UlGenerateFixedHeaders(
                                pRequest->Version,
                                pUserResponse,
                                HeaderLength,
                                pResponseBuffer,
                                &FixedHeaderLength
                                );

                if (!NT_SUCCESS(Status))
                    goto end;

                ASSERT( HeaderLength == FixedHeaderLength );
            }

            pResponseBuffer += FixedHeaderLength;
        }
        else
        {
            FixedHeaderLength = 0;
        }

        //
        // Take a reference of HTTP connection for the tracker.
        //

        pHttpConnection = pRequest->pHttpConn;

        ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

        UL_REFERENCE_HTTP_CONNECTION( pHttpConnection );

        //
        // Take a reference of the request too because logging needs it.
        //

        UL_REFERENCE_INTERNAL_REQUEST( pRequest );

        //
        // Initialization.
        //

        pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
        pTracker->pRequest = pRequest;
        pTracker->pHttpConnection = pHttpConnection;
        pTracker->Flags = Flags;
        pTracker->pLogData = NULL;
        pTracker->pUserIrp = pUserIrp;
        pTracker->SendBufferedBytes = 0;

        //
        // Capture the log data.
        //

        if (NULL != pUserLogData &&
            LastResponse &&
            pRequest->ConfigInfo.pLoggingConfig)
        {
            Status = UlProbeLogData( pUserLogData );

            if (NT_SUCCESS(Status) == FALSE)
            {
                goto end;
            }

            pTracker->pLogData = &pRequest->LogData;

            Status = UlAllocateLogDataBuffer(
                            pTracker->pLogData,
                            pRequest,
                            pRequest->ConfigInfo.pLoggingConfig
                            );
            ASSERT( NT_SUCCESS( Status ) );

            Status = UlCaptureLogFields(
                            pUserLogData,
                            pRequest->Version,
                            pTracker->pLogData
                            );

            if (NT_SUCCESS(Status) == FALSE)
            {
                goto end;
            }
        }

        //
        // Generate the variable header.
        //

        if (FixedHeaderLength > 0)
        {
            //
            // Should we close the connection?
            //

            Disconnect = FALSE;

            if ((Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT) != 0)
            {
                //
                // Caller is forcing a disconnect.
                //

                Disconnect = TRUE;
            }
            else
            if (LastResponse)
            {
                //
                // No more data is coming, should we disconnect?
                //

                if (UlCheckDisconnectInfo(pRequest))
                {
                    Disconnect = TRUE;
                    pTracker->Flags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
                }
            }

            //
            // Choose the connection header to send back.
            //

            ConnHeader = UlChooseConnectionHeader( pRequest->Version, Disconnect );

            //
            // Decide if we need to generate a content-length header.
            //

            if (IS_LENGTH_SPECIFIED(pUserResponse->Headers.pKnownHeaders) == FALSE &&
                IS_CHUNK_SPECIFIED(pUserResponse->Headers.pKnownHeaders) == FALSE &&
                UlNeedToGenerateContentLength(
                    pRequest->Verb,
                    pUserResponse->StatusCode,
                    pTracker->Flags
                    ))
            {
                //
                // Autogenerate a content-length header. We can use our own fast
                // generator here because we know the content-length is <= 64k.
                //

                ContentLengthStringLength = UlpFastGenerateContentLength(
                                                ContentLengthString,
                                                ContentLength
                                                );
            }
            else
            {
                ContentLengthString[0] = ANSI_NULL;
                ContentLengthStringLength = 0;
            }

            //
            // Now generate the variable header.
            //

            UlGenerateVariableHeaders(
                ConnHeader,
                (PUCHAR)ContentLengthString,
                ContentLengthStringLength,
                pResponseBuffer,
                &VarHeaderLength,
                &TimeSent
                );

            ASSERT( VarHeaderLength <= g_UlMaxVariableHeaderSize );

            pResponseBuffer += VarHeaderLength;
        }
        else
        {
            VarHeaderLength = 0;
        }

        pTracker->pMdlAuxiliary->ByteCount
            = FixedHeaderLength + VarHeaderLength;

        //
        // If this routine is called from the fast I/O path, copy the content
        // to the auxilary buffer inside the tracker and set up the send MDL.
        // Otherwise, we need to MmProbeAndLock the user buffer into another
        // separate MDL.
        //

        if (pUserIrp == NULL)
        {
            PUCHAR pAuxiliaryBuffer = pResponseBuffer;

            Status = STATUS_SUCCESS;

            __try
            {
                for (i = 0; i < ChunkCount; i++)
                {
                    if (pUserEntityDataChunk[i].FromMemory.BufferLength == 0 ||
                        pUserEntityDataChunk[i].FromMemory.pBuffer == NULL)
                    {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }

                    ProbeTestForRead(
                        pUserEntityDataChunk[i].FromMemory.pBuffer,
                        pUserEntityDataChunk[i].FromMemory.BufferLength,
                        sizeof(CHAR)
                        );

                    RtlCopyMemory(
                        pAuxiliaryBuffer,
                        pUserEntityDataChunk[i].FromMemory.pBuffer,
                        pUserEntityDataChunk[i].FromMemory.BufferLength
                        );

                    pAuxiliaryBuffer
                        += pUserEntityDataChunk[i].FromMemory.BufferLength;
                }
            }
             __except( UL_EXCEPTION_FILTER() )
            {
                Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
            }

            if (NT_SUCCESS(Status) == FALSE)
            {
                goto end;
            }

            pTracker->pMdlAuxiliary->ByteCount += ContentLength;
            pTracker->pMdlAuxiliary->Next = NULL;
        }
        else
        {
            ASSERT( ChunkCount == 1 );

            Status = STATUS_SUCCESS;

            __try
            {
                if (pUserEntityDataChunk->FromMemory.BufferLength == 0 ||
                    pUserEntityDataChunk->FromMemory.pBuffer == NULL)
                {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }

                ProbeTestForRead(
                    pUserEntityDataChunk->FromMemory.pBuffer,
                    pUserEntityDataChunk->FromMemory.BufferLength,
                    sizeof(CHAR)
                    );

                Status = UlpInitializeAndLockMdl(
                            pTracker->pMdlUserBuffer,
                            pUserEntityDataChunk->FromMemory.pBuffer,
                            ContentLength,
                            IoReadAccess
                            );
            }
             __except( UL_EXCEPTION_FILTER() )
            {
                Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
            }

            if (NT_SUCCESS(Status) == FALSE)
            {
                goto end;
            }

            pTracker->pMdlAuxiliary->Next = pTracker->pMdlUserBuffer;
        }

        TotalResponseSize = FixedHeaderLength + VarHeaderLength + ContentLength;

        //
        // Fail the zero length response which can be generated in the case
        // where the request is 0.9 and there is no body attached to the
        // response.  We have to take this code path to possibly force a
        // disconnect here because the slow path may not go far enough to the
        // disconnect logic since we may have flags such as SentLast or
        // SentResponse set.
        //

        if (TotalResponseSize == 0)
        {
            if (IS_DISCONNECT_TIME(pTracker))
            {
                UlCloseConnection(
                    pTracker->pHttpConnection->pConnection,
                    FALSE,
                    NULL,
                    NULL
                    );
            }

            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // Add to MinKBSec watch list, since we now know TotalResponseSize.
        //

        UlSetMinKBSecTimer(
            &pHttpConnection->TimeoutInfo,
            TotalResponseSize
            );

        //
        // Mark the IRP as pending before the send as we are guaranteed to
        // return pending from this point on.
        //

        if (pUserIrp != NULL)
        {
            IoMarkIrpPending( pUserIrp );
        }

        //
        // Skip the zero length MDL if created one.
        //

        pSendMdl = pTracker->pMdlAuxiliary;

        if (pSendMdl->ByteCount == 0)
        {
            pSendMdl = pSendMdl->Next;
        }

        ASSERT( pSendMdl != NULL );
        ASSERT( pSendMdl->ByteCount != 0 );

        //
        // Adjust SendBufferedBytes for the fast I/O path only.
        //

        if (pUserIrp == NULL)
        {
            pTracker->SendBufferedBytes = ContentLength;

            InterlockedExchangeAdd(
                &pHttpConnection->SendBufferedBytes,
                ContentLength
                );
        }

        //
        // Send the response. Notice the logic to disconnect the connection is
        // different from sending back a disconnect header.
        //

        Status = UlSendData(
                    pHttpConnection->pConnection,
                    pSendMdl,
                    TotalResponseSize,
                    &UlpRestartFastSendHttpResponse,
                    pTracker,
                    pTracker->pSendIrp,
                    &pTracker->IrpContext,
                    IS_DISCONNECT_TIME(pTracker)
                    );

        ASSERT( Status == STATUS_PENDING );

        if (BytesSent != NULL)
        {
            *BytesSent = TotalResponseSize;
        }

        return STATUS_PENDING;
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }


  end:
    
    //
    // Cleanup.
    //
    
    if (pTracker)
    {
        UlpFreeFastTracker( pTracker );
        
        //
        // Let the references go.
        //

        if (pHttpConnection != NULL)
        {
            UL_DEREFERENCE_HTTP_CONNECTION( pHttpConnection );
            UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );
        }
    }

    return Status;
} // UlpFastSendHttpResponse


VOID
UlpRestartFastSendHttpResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_FULL_TRACKER pTracker;
    PIRP pIrp;

    pTracker = (PUL_FULL_TRACKER)pCompletionContext;

    ASSERT( IS_VALID_FULL_TRACKER( pTracker ) );

    //
    // Set status and bytes transferred fields as returned.
    //

    pTracker->IoStatus.Status = Status;
    pTracker->IoStatus.Information = Information;

    if (NT_SUCCESS(Status) == FALSE &&
        IS_DISCONNECT_TIME(pTracker) == FALSE)
    {
        //
        // Disconnect if there was an error and we didn't disconnect already.
        //

        UlCloseConnection(
            pTracker->pHttpConnection->pConnection,
            TRUE,
            NULL,
            NULL
            );
    }

    //
    // Complete the orignal user send IRP if set.
    //

    pIrp = pTracker->pUserIrp;

    if (pIrp != NULL)
    {
        //
        // Don't forget to unlock the user buffer.
        //

        ASSERT( pTracker->pMdlAuxiliary->Next != NULL );
        ASSERT( pTracker->pMdlAuxiliary->Next == pTracker->pMdlUserBuffer );

        MmUnlockPages( pTracker->pMdlUserBuffer );

        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = Information;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }
    else
    {
        //
        // Adjust SendBufferedBytes.
        //

        InterlockedExchangeAdd(
            &pTracker->pHttpConnection->SendBufferedBytes,
            - pTracker->SendBufferedBytes
            );
    }

    UL_QUEUE_WORK_ITEM(
        &pTracker->WorkItem,
        &UlpFastSendCompleteWorker
        );
} // UlpRestartFastSendHttpResponse


VOID
UlpFastSendCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_FULL_TRACKER pTracker;
    PUL_HTTP_CONNECTION pHttpConnection;
    PUL_INTERNAL_REQUEST pRequest;
    NTSTATUS Status;
    KIRQL OldIrql;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_FULL_TRACKER,
                    WorkItem
                    );

    ASSERT( IS_VALID_FULL_TRACKER( pTracker ) );

    Status = pTracker->IoStatus.Status;

    pHttpConnection = pTracker->pHttpConnection;
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );

    pRequest = pTracker->pRequest;
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );

    //
    // Update the BytesSent counter in the request.
    //

    UlInterlockedAdd64(
        (PLONGLONG)&pRequest->BytesSent,
        pTracker->IoStatus.Information
        );

    if ((pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0)
    {
        //
        // Stop the MinKBSec timer and start Idle timer
        //

        UlLockTimeoutInfo(
            &pHttpConnection->TimeoutInfo,
            &OldIrql
            );

        UlResetConnectionTimer(
            &pHttpConnection->TimeoutInfo,
            TimerMinKBSec
            );

        UlSetConnectionTimer(
            &pHttpConnection->TimeoutInfo,
            TimerConnectionIdle
            );

        UlUnlockTimeoutInfo(
            &pHttpConnection->TimeoutInfo,
            OldIrql
            );

        UlEvaluateTimerState(
            &pHttpConnection->TimeoutInfo
            );
    }

    //
    // If this is the last response for this request and there was a log
    // data passed down by the user then now its time to log.
    //

    if (NULL != pTracker->pLogData)
    {
        UlLogHttpHit( pTracker->pLogData );
    }

    //
    // Kick the parser on the connection and release our hold.
    //

    if (Status == STATUS_SUCCESS &&
        (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0 &&
        (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT) == 0)
    {
        UlResumeParsing( pHttpConnection );
    }

    //
    // Cleanup.
    //

    UlpFreeFastTracker( pTracker );

    UL_DEREFERENCE_HTTP_CONNECTION( pHttpConnection );
    UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );
} // UlpFastSendCompleteWorker


NTSTATUS
UlpFastReceiveHttpRequest(
    IN HTTP_REQUEST_ID RequestId,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesRead
    )
{
    NTSTATUS Status;
    PUL_INTERNAL_REQUEST pRequest = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_AP_PROCESS(pProcess) );
    ASSERT( IS_VALID_AP_OBJECT(pProcess->pAppPool) );
    ASSERT( pOutputBuffer != NULL);

    UlAcquireResourceShared( &pProcess->pAppPool->pResource->Resource, TRUE );

    //
    // Make sure we're not cleaning up the process.
    //

    if (!pProcess->InCleanup)
    {
        //
        // Obtain the request based on the request ID. This can be from the
        // NewRequestQueue of the AppPool if the ID is NULL, or directly
        // from the matching opaque ID entry.
        //

        if (HTTP_IS_NULL_ID(&RequestId))
        {
            pRequest = UlpDequeueNewRequest( pProcess );
        }
        else
        {
            pRequest = UlGetRequestFromId( RequestId );

            if (NULL != pRequest)
            {
                ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );

                //
                // Weed out the request in bad state.
                //

                if (pRequest->AppPool.QueueState != QueueCopiedState ||
                    pRequest->AppPool.pProcess != pProcess)
                {
                    UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );
                    pRequest = NULL;
                }
            }
        }
    }

    //
    // Let go the lock since we have taken a short-lived reference of
    // the request in the success case.
    //

    UlReleaseResource( &pProcess->pAppPool->pResource->Resource );

    //
    // Return immediately if no request is found and let the slow path
    // handle this.
    //

    if (NULL == pRequest)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy it to the output buffer.
    //

    Status = UlpFastCopyHttpRequest(
                pRequest,
                pOutputBuffer,
                OutputBufferLength,
                pBytesRead
                );

    //
    // Let go our reference.
    //

    UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );

    return Status;
} // UlpFastReceiveHttpRequest


NTSTATUS
UlpFastCopyHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesRead
    )
{
    NTSTATUS Status;
    ULONG BytesNeeded;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );
    ASSERT( pOutputBuffer != NULL);

    //
    // Make sure this is big enough to handle the request, and
    // if so copy it in.
    //

    Status = UlpComputeRequestBytesNeeded( pRequest, &BytesNeeded );

    if (NT_SUCCESS(Status))
    {
        //
        // Make sure we've got enough space to handle the whole request.
        //

        if (BytesNeeded <= OutputBufferLength)
        {
            //
            // This request will fit in this buffer, so copy it.
            //

            __try
            {
                ProbeForWrite(
                    pOutputBuffer,
                    OutputBufferLength,
                    TYPE_ALIGNMENT(HTTP_REQUEST)
                    );

                Status = UlpCopyRequestToBuffer(
                            pRequest,
                            (PUCHAR) pOutputBuffer,
                            pOutputBuffer,
                            OutputBufferLength,
                            NULL,
                            0
                            );
            }
            __except( UL_EXCEPTION_FILTER() )
            {
                Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
            }

            if (NT_SUCCESS(Status))
            {
                *pBytesRead = BytesNeeded;
            }
        }
        else
        {
            //
            // Let the slow path handle this.
            //

            Status = STATUS_BUFFER_OVERFLOW;
        }
    }

    return Status;
} // UlpFastCopyHttpRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\filecache.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    filecache.h

Abstract:

    This module contains declarations for the open file handle cache.

Author:

    Keith Moore (keithmo)       21-Aug-1998

Revision History:

--*/


#ifndef _FILECACHE_H_
#define _FILECACHE_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Data used to track a file cache entry.
//

typedef struct _UL_FILE_CACHE_ENTRY
{
    //
    // Signature.
    //

    ULONG Signature;

    //
    // A reference count.
    //

    LONG ReferenceCount;

    //
    // A pre-referenced file object pointer for this file. This pointer
    // is valid in *any* thread/process context.
    //

    PFILE_OBJECT pFileObject;

    //
    // The *correct* device object referenced by the above file object.
    //

    PDEVICE_OBJECT pDeviceObject;

    //
    // Fast I/O routines.
    //

    PFAST_IO_MDL_READ pMdlRead;
    PFAST_IO_MDL_READ_COMPLETE pMdlReadComplete;

    //
    // The name of the file.
    //

    UNICODE_STRING FileName;

    //
    // The open file handle. Note that this handle is only valid
    // in the context of the system process.
    //

    HANDLE FileHandle;

    //
    // A work item for deferred operations.
    //

    UL_WORK_ITEM WorkItem;

    //
    // File-specific information gleaned from the file system.
    //

    FILE_STANDARD_INFORMATION FileInfo;

} UL_FILE_CACHE_ENTRY, *PUL_FILE_CACHE_ENTRY;

#define UL_FILE_CACHE_ENTRY_SIGNATURE       ((ULONG)'ELIF')
#define UL_FILE_CACHE_ENTRY_SIGNATURE_X     MAKE_FREE_SIGNATURE(UL_FILE_CACHE_ENTRY_SIGNATURE)

#define IS_VALID_FILE_CACHE_ENTRY( entry )                                  \
    ( (entry)->Signature == UL_FILE_CACHE_ENTRY_SIGNATURE )


//
// A file buffer contains the results of a read from a file cache entry.
// The file cache read and read complete routines take pointers to this
// structure. A read fills it in, and a read complete frees the data.
//

typedef struct _UL_FILE_BUFFER
{
    //
    // The file that provided the data.
    //
    PUL_FILE_CACHE_ENTRY    pFileCacheEntry;

    //
    // The data read from the file. Filled in by
    // the read routines.
    //
    PMDL                    pMdl;

    //
    // If we have to allocate our own buffer to hold file data
    // we'll save a pointer to the data buffer here.
    //
    PUCHAR                  pFileData;

    //
    // Information about the data buffers.
    // Filled in by the read routine's caller.
    //
    LARGE_INTEGER           FileOffset;
    ULONG                   Length;

    //
    // Completion routine and context information set by the caller.
    //
    PIO_COMPLETION_ROUTINE  pCompletionRoutine;
    PVOID                   pContext;
    
} UL_FILE_BUFFER, *PUL_FILE_BUFFER;


NTSTATUS
InitializeFileCache(
    VOID
    );

VOID
TerminateFileCache(
    VOID
    );

//
// Routines to create, reference and release a cache entry.
//

NTSTATUS
UlCreateFileEntry(
    IN PUNICODE_STRING pFileName OPTIONAL,
    IN HANDLE FileHandle OPTIONAL,
    IN KPROCESSOR_MODE AccessMode,
    OUT PUL_FILE_CACHE_ENTRY *pFileCacheEntry
    );

VOID
ReferenceCachedFile(
    IN PUL_FILE_CACHE_ENTRY pFileCacheEntry
    );

VOID
DereferenceCachedFile(
    IN PUL_FILE_CACHE_ENTRY pFileCacheEntry
    );


//
// Read and read complete routines.
//
// The fast versions complete immediately, but sometimes fail.
// The normal versions use an IRP provided by the caller.
//

NTSTATUS
UlReadFileEntry(
    IN OUT PUL_FILE_BUFFER pFileBuffer,
    IN PIRP pIrp
    );

NTSTATUS
UlReadFileEntryFast(
    IN OUT PUL_FILE_BUFFER pFileBuffer
    );

NTSTATUS
UlReadCompleteFileEntry(
    IN PUL_FILE_BUFFER pFileBuffer,
    IN PIRP pIrp
    );

NTSTATUS
UlReadCompleteFileEntryFast(
    IN PUL_FILE_BUFFER pFileBuffer
    );

//
// UL_FILE_BUFFER macros.
//

#define INITIALIZE_FILE_BUFFER(fbuf)                                    \
        do {                                                            \
            (fbuf)->pFileCacheEntry = NULL;                             \
            (fbuf)->pMdl = NULL;                                        \
            (fbuf)->pFileData = NULL;                                   \
            (fbuf)->FileOffset.QuadPart = 0;                            \
            (fbuf)->Length = 0;                                         \
        } while (0)

#define IS_FILE_BUFFER_IN_USE(fbuf) ((fbuf)->pFileCacheEntry)

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _FILECACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\filter.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    filter.h

Abstract:

    This module contains public declarations for the UL filter channel.

Author:

    Michael Courage (mcourage)  17-Mar-2000

Revision History:

--*/


#ifndef _FILTER_H_
#define _FILTER_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants.
//
#define UL_MAX_FILTER_NAME_LENGTH 260


//
// Forwards.
//
typedef struct _UL_FILTER_WRITE_QUEUE *PUL_FILTER_WRITE_QUEUE;
typedef struct _UL_APP_POOL_PROCESS *PUL_APP_POOL_PROCESS;

//
// The filter channel types.
//

typedef struct _UL_FILTER_CHANNEL *PUL_FILTER_CHANNEL;
typedef struct _UL_FILTER_PROCESS *PUL_FILTER_PROCESS;

#ifndef offsetof
#define offsetof(s,m)     (size_t)&(((s *)0)->m)
#endif

//
// Initialize/terminate functions.
//

NTSTATUS
UlInitializeFilterChannel(
    VOID
    );

VOID
UlTerminateFilterChannel(
    VOID
    );


//
// Open/close a new filter channel.
//

NTSTATUS
UlAttachFilterProcess(
    IN PWCHAR pName OPTIONAL,
    IN ULONG NameLength,
    IN BOOLEAN Create,
    IN PACCESS_STATE pAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PUL_FILTER_PROCESS *ppFilterProcess
    );

NTSTATUS
UlDetachFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    );

VOID
UlFreeFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    );

//
// Filter channel I/O operations.
//
NTSTATUS
UlFilterAccept(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterClose(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterRawRead(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterRawWrite(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG BufferLength,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterAppRead(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterAppWrite(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

//
// SSL related app pool operations.
//

NTSTATUS
UlReceiveClientCert(
    PUL_APP_POOL_PROCESS pProcess,
    PUX_FILTER_CONNECTION pConnection,
    ULONG Flags,
    PIRP pIrp
    );


//
// Filter channel reference counting.
//
VOID
UlReferenceFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_FILTER_CHANNEL( pFilt )                                   \
    UlReferenceFilterChannel(                                               \
        (pFilt)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

VOID
UlDereferenceFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DEREFERENCE_FILTER_CHANNEL( pFilt )                                 \
    UlDereferenceFilterChannel(                                             \
        (pFilt)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// Interface for ultdi.
//

NTSTATUS
UlFilterReceiveHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pTakenLength
    );

NTSTATUS
UlFilterSendHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_IRP_CONTEXT pIrpContext
    );

NTSTATUS
UlFilterReadHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    OUT PBYTE pBuffer,
    IN ULONG BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlFilterCloseHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

VOID
UlUnbindConnectionFromFilter(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UlDestroyFilterConnection(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UlInitializeFilterWriteQueue(
    IN PUL_FILTER_WRITE_QUEUE pWriteQueue
    );

//
// Interface for apool.
//

NTSTATUS
UlGetSslInfo(
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG BufferSize,
    IN PUCHAR pUserBuffer OPTIONAL,
    OUT PUCHAR pBuffer OPTIONAL,
    OUT PULONG pBytesCopied OPTIONAL
    );

//
// Utility.
//

NTSTATUS
UlGetFilterFromHandle(
    IN HANDLE FilterHandle,
    OUT PUL_FILTER_CHANNEL *ppFilterChannel
    );

PUX_FILTER_CONNECTION
UlGetRawConnectionFromId(
    IN HTTP_RAW_CONNECTION_ID ConnectionId
    );

VOID
UxReferenceConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

NTSTATUS
UxInitializeFilterConnection(
    IN PUX_FILTER_CONNECTION                    pConnection,
    IN PUL_FILTER_CHANNEL                       pChannel,
    IN BOOLEAN                                  Secure,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE           pfnReferenceFunction,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE           pfnDereferenceFunction,
    IN PUX_FILTER_CLOSE_CONNECTION              pfnConnectionClose,
    IN PUX_FILTER_SEND_RAW_DATA                 pfnRawSend,
    IN PUX_FILTER_RECEIVE_RAW_DATA              pfnRawReceive,
    IN PUL_DATA_RECEIVE                         pfnDataReceive,
    IN PUX_FILTER_COMPUTE_RAW_CONNECTION_LENGTH pfnRawConnLength,
    IN PUX_FILTER_GENERATE_RAW_CONNECTION_INFO  pfnGenerateRawConnInfo,
    IN PUX_FILTER_SERVER_CERT_INDICATE          pfnServerCertIndicate,
    IN PVOID                                    pListenContext,
    IN PVOID                                    pConnectionContext
    );

NTSTATUS
UlDeliverConnectionToFilter(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    );

PUL_FILTER_CHANNEL
UxRetrieveServerFilterChannel(
    VOID
    );

PUL_FILTER_CHANNEL
UxRetrieveClientFilterChannel(
    VOID
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\engine.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    engine.h

Abstract:

    The public definition of HTTP protocol interfaces.

Author:

    Michael Courage (mcourage)      17-Sep-1999

Revision History:

--*/


#ifndef _ENGINE_H_
#define _ENGINE_H_

#ifdef __cplusplus
extern "C" {
#endif


typedef enum _UL_CONN_HDR
{
    ConnHdrNone,
    ConnHdrClose,
    ConnHdrKeepAlive,

    ConnHdrMax

} UL_CONN_HDR, *PUL_CONN_HDR;


__inline
UL_CONN_HDR
FASTCALL
UlChooseConnectionHeader(
    IN HTTP_VERSION Version,
    IN BOOLEAN Disconnect
    )
{
    UL_CONN_HDR ConnHeader;

    //
    // Sanity check
    //
    PAGED_CODE();

    ConnHeader = ConnHdrNone;

    if (Disconnect) {
        if (HTTP_GREATER_EQUAL_VERSION(Version, 1, 0) || HTTP_EQUAL_VERSION(Version, 0, 0)) {
            //
            // Connection: close
            //
            ConnHeader = ConnHdrClose;
        }
    } else {
        if (HTTP_EQUAL_VERSION(Version, 1, 0)) {
            //
            // Connection: keep-alive
            //
            ConnHeader = ConnHdrKeepAlive;
        }
    }

    return ConnHeader;
}


__inline
BOOLEAN
FASTCALL
UlCheckDisconnectInfo(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    BOOLEAN Disconnect;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );

    if (
        //
        // pre-version 1.0
        //

        (HTTP_LESS_VERSION(pRequest->Version, 1, 0)) ||

        //
        // or version 1.0 with no Connection: Keep-Alive
        // CODEWORK: and no Keep-Alive header
        //

        (HTTP_EQUAL_VERSION(pRequest->Version, 1, 0) &&
            (pRequest->HeaderValid[HttpHeaderConnection] == FALSE ||
            !(pRequest->Headers[HttpHeaderConnection].HeaderLength == 10 &&
                (_stricmp(
                    (const char*) pRequest->Headers[HttpHeaderConnection].pHeader,
                    "keep-alive"
                    ) == 0)))) ||

        //
        // or version 1.1 with a Connection: close
        // CODEWORK: move to parser or just make better in general..
        //

        (HTTP_EQUAL_VERSION(pRequest->Version, 1, 1) &&
            pRequest->HeaderValid[HttpHeaderConnection] &&
            pRequest->Headers[HttpHeaderConnection].HeaderLength == 5 &&
            _stricmp((const char*) pRequest->Headers[HttpHeaderConnection].pHeader, "close") == 0)
        )
    {
        Disconnect = TRUE;
    } else {
        Disconnect = FALSE;
    }

    return Disconnect;
}


__inline
NTSTATUS
FASTCALL
UlCheckProtocolCompliance(
    IN PUL_HTTP_CONNECTION pConnection,
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pConnection) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );

    //
    // check for entity body. TRACE is not allowed
    // to have a body.
    //
    if ((pRequest->ParseState != ParseDoneState)
        && ((pRequest->Verb == HttpVerbTRACE)
            || (pRequest->Verb == HttpVerbTRACK)))
    {
        Status = STATUS_INVALID_PARAMETER;
    }


    //
    // make sure that PUTs and POSTs do have a message body.
    // HTTP/1.0 requests must have a content length. HTTP/1.1 requests
    // must either be chunked or have a content length.
    //
    if (((pRequest->Verb == HttpVerbPUT)
        || (pRequest->Verb == HttpVerbPOST))
            && (!pRequest->HeaderValid[HttpHeaderContentLength])
            && ((HTTP_LESS_VERSION(pRequest->Version, 1, 1)) ||
                !pRequest->Chunked))
    {
        pRequest->ErrorCode = UlErrorContentLength;
        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // 1.1 requests MUST have a host header
    // should we be checking >= UlHttpVersion11?
    //
    if ((HTTP_EQUAL_VERSION(pRequest->Version, 1, 1))
        && (!pRequest->HeaderValid[HttpHeaderHost]))
    {
        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // If the major version is greater than 1, fail.
    //

    if (HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 2, 0))
    {
        pRequest->ErrorCode = UlErrorVersion;
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}


__inline
BOOLEAN
FASTCALL
UlNeedToGenerateContentLength(
    IN HTTP_VERB Verb,
    IN USHORT StatusCode,
    IN ULONG Flags
    )
{
    //
    // Fast path: If there is more data on the way, then don't generate
    // the header.
    //

    if ((Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) != 0)
    {
        return FALSE;
    }

    //
    // RFC2616 section 4.3.
    //

    if (((StatusCode / 100) == 1) ||                // 1xx (informational)
        (StatusCode == 204) ||                      // 204 (no content)
        (StatusCode == 304))                        // 304 (not modified)
    {
        return FALSE;
    }

    if (Verb == HttpVerbHEAD)
    {
        return FALSE;
    }

    //
    // Otherwise, we can generate a content-length header.
    //

    return TRUE;

}


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\filterp.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    filterp.h

Abstract:

    This module contains public declarations for the UL filter channel.

Author:

    Michael Courage (mcourage)  17-Mar-2000

Revision History:

--*/


#ifndef _FILTERP_H_
#define _FILTERP_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _UX_FILTER_CONNECTION *PUX_FILTER_CONNECTION;
typedef struct _UX_FILTER_WRITE_TRACKER *PUX_FILTER_WRITE_TRACKER;
typedef struct _UL_IRP_CONTEXT *PUL_IRP_CONTEXT;
typedef struct _UL_FILTER_CHANNEL *PUL_FILTER_CHANNEL;

//
// The filter channel types.
//

#define IS_VALID_FILTER_CHANNEL(pFilterChannel) \
    (((pFilterChannel) != NULL) && ((pFilterChannel)->Signature == UL_FILTER_CHANNEL_POOL_TAG))


typedef struct _UL_FILTER_CHANNEL
{
    //
    // UL_FILTER_CHANNEL_POOL_TAG
    //
    ULONG                   Signature;

    //
    // Ref count for this object
    //
    LONG                    RefCount;

    //
    // links all filter objects, anchored by g_FilterListHead
    //
    LIST_ENTRY              ListEntry;

    //
    // the demand start irp (OPTIONAL)
    //
    PIRP                    pDemandStartIrp;
    PEPROCESS               pDemandStartProcess;

    //
    // Synchronizes the process list, connection queue,
    // and lists within the process object.
    //
    UL_SPIN_LOCK            SpinLock;

    //
    // List of processes attached to this filter channel.
    //
    LIST_ENTRY              ProcessListHead;

    //
    // Queue of connections ready to be accepted.
    //
    LIST_ENTRY              ConnectionListHead;

    //
    // security on this object
    //
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;

    //
    // the length of pName
    //
    ULONG                   NameLength;

    //
    // the apool's name
    //
    WCHAR                   pName[0];

} UL_FILTER_CHANNEL, *PUL_FILTER_CHANNEL;

//
// Per-process filter channel object.
//

#define IS_VALID_FILTER_PROCESS(pFilterProcess) \
    (((pFilterProcess) != NULL) && ((pFilterProcess)->Signature == UL_FILTER_PROCESS_POOL_TAG))

typedef struct _UL_FILTER_PROCESS
{
    //
    // UL_FILTER_PROCESS_POOL_TAG
    //
    ULONG                       Signature;

    //
    // Flags.
    //

    //
    // set if we are in cleanup. You must check this flag before attaching
    // any IRPs to the process.
    //
    ULONG                       InCleanup : 1;

    //
    // Pointer to our UL_FILTER_CHANNEL.
    //
    PUL_FILTER_CHANNEL          pFilterChannel;

    //
    // List entry for UL_FILTER_CHANNEL.
    //
    LIST_ENTRY                  ListEntry;

    //
    // List of connections attached to this process.
    //
    LIST_ENTRY                  ConnectionHead;

    //
    // List of accept IRPs pending on this process.
    //
    LIST_ENTRY                  IrpHead;

    //
    // Pointer to the actual process (for debugging)
    //
    PEPROCESS                   pProcess;

} UL_FILTER_PROCESS, *PUL_FILTER_PROCESS;

//
// An object for tracking MDL chain to IRP copies.
//
typedef struct _UL_MDL_CHAIN_COPY_TRACKER
{
    PMDL pMdl;              // the current MDL
    ULONG Offset;           // offset into current MDL

    ULONG Length;           // length of MDL chain in bytes
    ULONG BytesCopied;      // number of bytes copied so far

} UL_MDL_CHAIN_COPY_TRACKER, *PUL_MDL_CHAIN_COPY_TRACKER;


typedef
NTSTATUS
(*PUL_DATA_RECEIVE)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pTakenLength
    );

typedef
NTSTATUS
(*PUX_FILTER_CLOSE_CONNECTION)(
    IN PVOID                  pConnectionContext,
    IN BOOLEAN                AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    );

typedef
NTSTATUS
(*PUX_FILTER_RECEIVE_RAW_DATA)(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    );

typedef
NTSTATUS
(*PUX_FILTER_SEND_RAW_DATA)(
    IN PVOID          pConnection,
    IN PMDL           pMdlChain,
    IN ULONG          Length,
    PUL_IRP_CONTEXT   pIrpContext
    );

#define DEREFERENCE_FILTER_CONNECTION( pconn )       \
    ((pconn)->pDereferenceHandler)                   \
        ((pconn)->pConnectionContext                 \
         REFERENCE_DEBUG_ACTUAL_PARAMS               \
    )

#define REFERENCE_FILTER_CONNECTION( pconn )       \
    ((pconn)->pReferenceHandler)                   \
        ((pconn)->pConnectionContext               \
         REFERENCE_DEBUG_ACTUAL_PARAMS             \
    )

#define UX_FILTER_CONNECTION_SIGNATURE     ((ULONG)'TLIF')
#define UX_FILTER_CONNECTION_SIGNATURE_X   MAKE_FREE_SIGNATURE(UL_CONNECTION_SIGNATURE)

#define IS_VALID_FILTER_CONNECTION(pConnection)                             \
    ( ((pConnection) != NULL) &&                                            \
      ((pConnection)->Signature == UX_FILTER_CONNECTION_SIGNATURE) )

//
// Connection state related to filtering.
//
// The filtering API (mostly implemented in filter.cxx) exists
// to enable SSL and raw data filters in a way that is transparent
// to clients of ultdi.
//
// Most of the state is either for tracking the producer/consumer
// relationship between filters and the ultdi client, and
// for simulating TDI behavior so that the client doesn't know
// is really talking to a filter process.
//

//
// Filter Connection state.
//
// The connection is Inactive until the first data is received
// from the network. Then it transitions to Connected if a
// FilterAccept IRP is available, or to Queued if the connection
// must instead be queued on its filter channel. The state will
// move to Disconnected after any disconnect.
//
// If the connection is about to be closed, the state is set
// to WillDisconnect so that further data will not be delivered,
// but the disconnect notification can still be sent.
//

typedef enum _UL_FILTER_CONN_STATE
{
    UlFilterConnStateInactive,
    UlFilterConnStateQueued,
    UlFilterConnStateWillDisconnect,
    UlFilterConnStateConnected,
    UlFilterConnStateDisconnected,

    UlFilterConnStateMaximum

} UL_FILTER_CONN_STATE, *PUL_FILTER_CONN_STATE;


//
// UL_FILTER_WRITE_QUEUE
//
// This queue maintains a list of read IRPs, and synchronizes
// access to that list. Read IRPs are always placed on the
// queue when they arrive. Writers are blocked until there
// are read IRPs available.
//
// If a writer is unblocked, but the available buffers
// can only handle part of its data, then it sets the
// BlockedPartialWrite flag, and waits for the PartialWriteEvent.
// When new buffers arrive, this writer is woken up before
// any others.
//
typedef struct _UL_FILTER_WRITE_QUEUE
{
    ULONG ReadIrps;
    ULONG Writers;
    BOOLEAN WriterActive;

    LIST_ENTRY ReadIrpListHead;
    KEVENT ReadIrpAvailableEvent;

    BOOLEAN BlockedPartialWrite;
    KEVENT PartialWriteEvent;

} UL_FILTER_WRITE_QUEUE, *PUL_FILTER_WRITE_QUEUE;


//
// UX_FILTER_WRITE_QUEUE & UX_FILTER_WRITE_TRACKER
//
// CODEWORK: switch the AppToFilt queue to use this.
//
// This is a producer/consumer queue used for moving
// data between the filter process and the worker
// processes. Both reads are writes are asynchronous.
// The same data structure is used to move data
// from Filter -> App (worker process), and from
// App -> Filter. The UX_FILTER_WRITE_TRACKER is
// used to queue writes.
//
// The operation of the queue is somewhat different
// depending on the direction of the data transfer.
//
// Filter->App:
//
// The data to be sent arrives in FilterAppWrite IRPs.
// Normally this data is "indicated" to the app in
// a callback and completely consumed, however the
// app may consume only some of the indicated data,
// in which case the write must be queued until
// the app grabs the rest of the data with a read.
// The read arrives as a plain buffer.
// Once all the queued bytes are consumed the normal
// indication method of transferring data resumes.
// This system emulates the way TDI sends data to the
// app.
//
// App->Filter:
//
// The data to be sent arrives as a MDL chain and
// UL_IRP_CONTEXT. The data is always consumed by
// FilterAppRead IRPs from the filter process. If there
// are not enough FilterAppRead IRPs around to handle the
// data then we have to queue the write until more IRPs
// arrive.
//


//
// When you initialize a filter write queue you pass in
// a several function pointers that can get called when
// queuing, dequeuing or completing a write.
//

//
// Called before queuing a write tracker.
//
typedef
NTSTATUS
(*PUX_FILTER_WRITE_ENQUEUE)(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

//
// Called before dequeuing a tracker.
//
typedef
NTSTATUS
(*PUX_FILTER_WRITE_DEQUEUE)(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

//
// Called when a queued write has completed.
//
typedef
VOID
(*PUX_FILTER_WRITE_QUEUE_COMPLETION)(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

typedef
ULONG
(*PUX_FILTER_COMPUTE_RAW_CONNECTION_LENGTH)(
    IN PVOID pConnectionContext
    );

typedef
ULONG
(*PUX_FILTER_GENERATE_RAW_CONNECTION_INFO)(
    IN PVOID pConnectionContext,
    IN PUCHAR pKernelBuffer,
    IN PVOID  pUserBuffer,
    IN ULONG  OutLength,
    IN PUCHAR pBuffer,
    IN ULONG  InitialLength
    );

typedef
VOID
(*PUX_FILTER_SERVER_CERT_INDICATE)(
    IN PVOID pConnectionContext
    );

//
// There are two UX_FILTER_WRITE_QUEUEs for each connection.
// FiltToApp and AppToFilt.
//

typedef struct _UX_FILTER_WRITE_QUEUE
{
    //
    // Counts of pending operations.
    //

    ULONG       PendingWriteCount;
    ULONG       PendingReadCount;

    //
    // List of pending writes.
    //

    LIST_ENTRY  WriteTrackerListHead;

    //
    // List of pending read IRPs.
    //

    LIST_ENTRY  ReadIrpListHead;

    //
    // Some function pointers called at various stages
    // of processing a request. In the App -> Filt case
    // the enqueue and dequeue routines are used to
    // do the required magic to queue and dequeue IRPs
    // (which may be cancelled at any time). In both
    // paths the write completion routine is called when
    // every time we finish a queued write.
    //

    PUX_FILTER_WRITE_ENQUEUE            pWriteEnqueueRoutine;
    PUX_FILTER_WRITE_DEQUEUE            pWriteDequeueRoutine;
    PUX_FILTER_WRITE_QUEUE_COMPLETION   pWriteCompletionRoutine;

} UX_FILTER_WRITE_QUEUE, *PUX_FILTER_WRITE_QUEUE;

//
// There is one UX_FILTER_WRITE_TRACKER for every queued write.
//

#define IS_VALID_FILTER_WRITE_TRACKER(pTracker)                         \
    ( ((pTracker) != NULL) &&                                           \
      ((pTracker)->Signature == UX_FILTER_WRITE_TRACKER_POOL_TAG) )

typedef struct _UX_FILTER_WRITE_TRACKER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SINGLE_LIST_ENTRY       LookasideEntry;

    //
    // A signature.
    //

    ULONG                   Signature;

    //
    // Our write queue entry.
    //

    LIST_ENTRY              ListEntry;

    //
    // Pointers to the connection and write queue
    // which we need to dequeue the tracker if the
    // write gets cancelled.
    //

    PUX_FILTER_CONNECTION   pConnection;
    PUX_FILTER_WRITE_QUEUE  pWriteQueue;

    //
    // Pointer to the current MDL being written and
    // an offset into that MDL.
    //

    PMDL                    pMdl;
    ULONG                   Offset;

    //
    // Total length of the MDL chain being written
    // and the total number of bytes we have copied
    // so far.
    //

    ULONG                   Length;
    ULONG                   BytesCopied;

    //
    // A context object we use to complete the
    // write operation. In the App -> Filter case
    // this is a UL_IRP_CONTEXT. In the Filter -> App
    // case this is a FilterAppWrite IRP.
    //

    PVOID                   pContext;

} UX_FILTER_WRITE_TRACKER, *PUX_FILTER_WRITE_TRACKER;


//
// UL_SSL_INFORMATION
//
// This structure is an internal representation of SSL
// connection and certificate information attached
// to the UL_CONNECTION.
//

typedef struct _UL_SSL_INFORMATION
{
    //
    // Standard information.
    //
    USHORT  ServerCertKeySize;
    USHORT  ConnectionKeySize;
    PUCHAR  pServerCertIssuer;
    ULONG   ServerCertIssuerSize;
    PUCHAR  pServerCertSubject;
    ULONG   ServerCertSubjectSize;

    PUCHAR  pServerCertData;

    //
    // Client certificate information.
    //
    ULONG   CertEncodedSize;
    PUCHAR  pCertEncoded;
    ULONG   CertFlags;
    PVOID   Token;

    //
    // Flags
    //
    ULONG   SslRenegotiationFailed:1;
    ULONG   CertDeniedByMapper:1;

} UL_SSL_INFORMATION, *PUL_SSL_INFORMATION;

//
// A UX_FILTER_CONNECTION is a common wrapper that encapsulates filter
// related information for a client (UC_CONNECTION) or a server
// (UL_CONNECTION) entities.
//
typedef struct _UX_FILTER_CONNECTION
{
    ULONG                   Signature;
    PUL_FILTER_CHANNEL      pFilterChannel;
    BOOLEAN                 SecureConnection;
    HTTP_RAW_CONNECTION_ID  ConnectionId;
    LIST_ENTRY              ChannelEntry;

    //
    // Filtered connection state.
    // Synchronized by FilterConnLock.
    //
    UL_FILTER_CONN_STATE    ConnState;
    UL_FILTER_WRITE_QUEUE   AppToFiltQueue;
    UX_FILTER_WRITE_QUEUE   FiltToAppQueue;
    PIRP                    pReceiveCertIrp;

    //
    // Incoming transport data queue.
    // Synchronized by FilterConnLock.
    //
    ULONG                   TransportBytesNotTaken;
    LIST_ENTRY              RawReadIrpHead;
    BOOLEAN                 TdiReadPending;

    //
    // Pointers to the functions for holding the ref on the respective
    // connections
    //
    PUL_OPAQUE_ID_OBJECT_REFERENCE           pReferenceHandler;
    PUL_OPAQUE_ID_OBJECT_REFERENCE           pDereferenceHandler;
    PVOID                                    pConnectionContext;
    PUX_FILTER_CLOSE_CONNECTION              pCloseConnectionHandler;
    PUX_FILTER_SEND_RAW_DATA                 pSendRawDataHandler;
    PUX_FILTER_RECEIVE_RAW_DATA              pReceiveDataHandler;
    PUL_DATA_RECEIVE                         pDummyTdiReceiveHandler;
    PUX_FILTER_COMPUTE_RAW_CONNECTION_LENGTH pComputeRawConnectionLengthHandler;
    PUX_FILTER_GENERATE_RAW_CONNECTION_INFO  pGenerateRawConnectionInfoHandler;
    PUX_FILTER_SERVER_CERT_INDICATE          pServerCertIndicateHandler;

    //
    // Filter flags.
    //
    ULONG ConnectionDelivered   : 1;    // Uses TDI callback synch.
    ULONG SslInfoPresent        : 1;    // Uses FilterConnLock
    ULONG SslClientCertRequested: 1;    // Uses FilterConnLock
    ULONG SslClientCertPresent  : 1;    // Uses FilterConnLock

    //
    // SSL information.
    //
    UL_SSL_INFORMATION SslInfo;

    //
    // This should be the last entry in this struct to avoid confusing
    // !ulkd.ulconn when dealing with debug or retail versions of http.sys
    //
    UL_SPIN_LOCK            FilterConnLock;

} UX_FILTER_CONNECTION, *PUX_FILTER_CONNECTION;



//
// Function prototypes.
//

PUL_FILTER_CHANNEL
UlpFindFilterChannel(
    IN PWCHAR pName,
    IN ULONG NameLength
    );

NTSTATUS
UlpCreateFilterChannel(
    IN PWCHAR pName,
    IN ULONG NameLength,
    IN PACCESS_STATE pAccessState,
    OUT PUL_FILTER_CHANNEL *ppFilterChannel
    );

PUL_FILTER_PROCESS
UlpCreateFilterProcess(
    IN PUL_FILTER_CHANNEL pChannel
    );

NTSTATUS
UlpValidateFilterCall(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UlpRestartFilterClose(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartFilterRawRead(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartFilterRawWrite(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartFilterAppWrite(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpCancelFilterAccept(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelFilterAcceptWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCancelFilterRawRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelFilterAppRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelFilterAppWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelReceiveClientCert(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
UlpFilterAppWriteStream(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp,
    IN PUCHAR pDataBuffer,
    IN ULONG DataBufferSize,
    OUT PULONG pTakenLength
    );

NTSTATUS
UlpEnqueueFilterAppWrite(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

NTSTATUS
UlpDequeueFilterAppWrite(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

NTSTATUS
UlpCaptureSslInfo(
    IN PHTTP_SSL_INFO pHttpSslInfo,
    IN ULONG HttpSslInfoSize,
    OUT PUL_SSL_INFORMATION pUlSslInfo,
    OUT PULONG pTakenLength
    );

NTSTATUS
UlpCaptureSslClientCert(
    IN BOOLEAN CertMapped,
    IN PHTTP_SSL_CLIENT_CERT_INFO pCertInfo,
    IN ULONG SslCertInfoSize,
    OUT PUL_SSL_INFORMATION pUlSslInfo,
    OUT PULONG pTakenLength
    );

NTSTATUS
UlpAddSslInfoToConnection(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_SSL_INFORMATION pSslInfo
    );

NTSTATUS
UlpAddSslClientCertToConnection(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_SSL_INFORMATION pSslInfo
    );

VOID
UlpAddSslClientCertToConnectionWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpGetSslClientCert(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PEPROCESS pProcess,
    IN ULONG BufferSize,
    IN PUCHAR pUserBuffer OPTIONAL,
    OUT PUCHAR pBuffer OPTIONAL,
    OUT PULONG pBytesCopied OPTIONAL
    );

PIRP
UlpPopAcceptIrp(
    IN PUL_FILTER_CHANNEL pFilterChannel,
    OUT PUL_FILTER_PROCESS * ppFilterProcess
    );

PIRP
UlpPopAcceptIrpFromProcess(
    IN PUL_FILTER_PROCESS pProcess
    );

VOID
UlpCompleteAcceptIrp(
    IN PIRP pIrp,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer OPTIONAL,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength OPTIONAL
    );

NTSTATUS
UlpCompleteAppReadIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN HTTP_FILTER_BUFFER_TYPE BufferType
    );

NTSTATUS
UlpCompleteAppReadIrpWithData(
    IN PUX_FILTER_CONNECTION pConnection,
    IN OUT PUL_MDL_CHAIN_COPY_TRACKER pCopyTracker
    );

NTSTATUS
UlpCompleteReceiveClientCertIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PEPROCESS pProcess,
    IN PIRP pIrp
    );

NTSTATUS
UlpDuplicateHandle(
    IN PEPROCESS SourceProcess,
    IN HANDLE SourceHandle,
    IN PEPROCESS TargetProcess,
    OUT PHANDLE pTargetHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options,
    IN KPROCESSOR_MODE PreviousMode
    );


//
// Functions for handling the raw read queue and incoming
// network data.
//

NTSTATUS
UxpQueueRawReadIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

PIRP
UxpDequeueRawReadIrp(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UxpCancelAllQueuedRawReads(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UxpSetBytesNotTaken(
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG TransportBytesNotTaken
    );

NTSTATUS
UxpProcessIndicatedData(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    );

VOID
UxpProcessRawReadQueue(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UxpProcessRawReadQueueWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UxpRestartProcessRawReadQueue(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


//
// Functions for manipulating a UL_FILTER_WRITE_QUEUE.
//

NTSTATUS
UlpQueueFilterIrp(
    IN PIRP pIrp,
    IN PDRIVER_CANCEL pCancelRoutine,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_FILTER_WRITE_QUEUE pWriteQueue
    );

PIRP
UlpPopFilterIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_FILTER_WRITE_QUEUE pWriteQueue
    );

VOID
UlpStartAppToFiltWriter(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UlpFinishAppToFiltWriter(
    IN PUX_FILTER_CONNECTION pConnection
    );

//
// Functions for manipulating a UX_FILTER_WRITE_QUEUE.
//

VOID
UxpInitializeFilterWriteQueue(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_ENQUEUE pWriteEnqueueRoutine,
    IN PUX_FILTER_WRITE_DEQUEUE pWriteDequeueRoutine,
    IN PUX_FILTER_WRITE_QUEUE_COMPLETION pWriteCompletionRoutine
    );

NTSTATUS
UxpQueueFilterWrite(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

NTSTATUS
UxpRequeueFilterWrite(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

PUX_FILTER_WRITE_TRACKER
UxpDequeueFilterWrite(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    );

NTSTATUS
UxpCopyQueuedWriteData(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    OUT PBYTE pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pBytesCopied
    );

VOID
UxpCompleteQueuedWrite(
    IN NTSTATUS Status,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

VOID
UxpCancelAllQueuedWrites(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    );

//
// Filter write queue tracker allocators.
//

PUX_FILTER_WRITE_TRACKER
UxpCreateFilterWriteTracker(
    IN PMDL pMdlChain,
    IN ULONG MdlOffset,
    IN ULONG TotalBytes,
    IN ULONG BytesCopied,
    IN PVOID pContext
    );

VOID
UxpDeleteFilterWriteTracker(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

PVOID
UxpAllocateFilterWriteTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UxpFreeFilterWriteTrackerPool(
    IN PVOID pBuffer
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _FILTERP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\filter.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    filter.cxx

Abstract:

    This module implements the filter channel.

    CODEWORK: Data writes between from the app to the filter
    channel are currently synchronous. Make them async. Should be able
    to do this by using the UX version of the queue that we used
    for the filter to app direction.

Author:

    Michael Courage (mcourage)  17-Mar-2000

Revision History:

--*/


#include "precomp.h"
#include "filterp.h"


//
// Private globals.
//

LIST_ENTRY  g_FilterListHead = {NULL,NULL};
BOOLEAN     g_InitFilterCalled = FALSE;
HANDLE      g_FilterWriteTrackerLookaside = NULL;
PUL_FILTER_CHANNEL g_pSslServerFilterChannel;
PUL_FILTER_CHANNEL g_pSslClientFilterChannel;


//
// Private macros.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeFilterChannel )
#pragma alloc_text( PAGE, UlTerminateFilterChannel )
#pragma alloc_text( PAGE, UlFreeFilterProcess )
#pragma alloc_text( PAGE, UlInitializeFilterWriteQueue )

#pragma alloc_text( PAGE, UlpCreateFilterChannel )
#pragma alloc_text( PAGE, UlpCreateFilterProcess )

#pragma alloc_text( PAGE, UlpAddSslClientCertToConnectionWorker )
#pragma alloc_text( PAGE, UxpProcessRawReadQueueWorker )

#pragma alloc_text( PAGE, UxpInitializeFilterWriteQueue )

#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlAttachFilterProcess
NOT PAGEABLE -- UlDetachFilterProcess
NOT PAGEABLE -- UlFilterAccept
NOT PAGEABLE -- UlFilterClose
NOT PAGEABLE -- UlFilterRawRead
NOT PAGEABLE -- UlFilterRawWrite
NOT PAGEABLE -- UlFilterAppRead
NOT PAGEABLE -- UlFilterAppWrite
NOT PAGEABLE -- UlReceiveClientCert
NOT PAGEABLE -- UlReferenceFilterChannel
NOT PAGEABLE -- UlDereferenceFilterChannel
NOT PAGEABLE -- UlFilterReceiveHandler
NOT PAGEABLE -- UlFilterSendHandler
NOT PAGEABLE -- UlFilterReadHandler
NOT PAGEABLE -- UlFilterCloseHandler
NOT PAGEABLE -- UlUnbindConnectionFromFilter
NOT PAGEABLE -- UlDestroyFilterConnection
NOT PAGEABLE -- UlGetSslInfo

NOT PAGEABLE -- UlpFindFilterChannel
NOT PAGEABLE -- UlpRestartFilterClose
NOT PAGEABLE -- UlpRestartFilterRawRead
NOT PAGEABLE -- UlpRestartFilterRawWrite
NOT PAGEABLE -- UlpCancelFilterAccept
NOT PAGEABLE -- UlpCancelFilterAcceptWorker
NOT PAGEABLE -- UlpCancelFilterRawRead
NOT PAGEABLE -- UlpCancelFilterAppRead
NOT PAGEABLE -- UlpCancelReceiveClientCert
NOT PAGEABLE -- UlDeliverConnectionToFilter
NOT PAGEABLE -- UlpFilterAppWriteStream
NOT PAGEABLE -- UlpEnqueueFilterAppWrite
NOT PAGEABLE -- UlpDequeueFilterAppWrite
NOT PAGEABLE -- UlpCaptureSslInfo
NOT PAGEABLE -- UlpCaptureSslClientCert
NOT PAGEABLE -- UlpAddSslInfoToConnection
NOT PAGEABLE -- UlpAddSslClientCertToConnection
NOT PAGEABLE -- UlpGetSslClientCert
NOT PAGEABLE -- UlpPopAcceptIrp
NOT PAGEABLE -- UlpPopAcceptIrpFromProcess
NOT PAGEABLE -- UlpCompleteAcceptIrp
NOT PAGEABLE -- UlpCompleteAppReadIrp
NOT PAGEABLE -- UlpCompleteAppReadIrpWithData
NOT PAGEABLE -- UlpDuplicateHandle

NOT PAGEABLE -- UxpQueueRawReadIrp
NOT PAGEABLE -- UxpDequeueRawReadIrp
NOT PAGEABLE -- UxpCancelAllQueuedRawReads
NOT PAGEABLE -- UxpSetBytesNotTaken
NOT PAGEABLE -- UxpProcessIndicatedData
NOT PAGEABLE -- UxpProcessRawReadQueue
NOT PAGEABLE -- UxpRestartProcessRawReadQueue

NOT PAGEABLE -- UlpQueueFilterIrp
NOT PAGEABLE -- UlpPopFilterIrp
NOT PAGEABLE -- UlpStartAppToFiltWriter
NOT PAGEABLE -- UlpFinishAppToFiltWriter

NOT PAGEABLE -- UxpQueueFilterWrite
NOT PAGEABLE -- UxpRequeueFilterWrite
NOT PAGEABLE -- UxpDequeueFilterWrite
NOT PAGEABLE -- UxpCopyQueuedWriteData
NOT PAGEABLE -- UxpCompleteQueuedWrite
NOT PAGEABLE -- UxpCancelAllQueuedWrites
NOT PAGEABLE -- UxpCreateFilterWriteTracker
NOT PAGEABLE -- UxpDeleteFilterWriteTracker
NOT PAGEABLE -- UxpAllocateFilterWriteTrackerPool
NOT PAGEABLE -- UxpFreeFilterWriteTrackerPool

#endif


//
// Public functions.
//


/***************************************************************************++

Routine Description:

    Initializes global data related to filter channels.

--***************************************************************************/
NTSTATUS
UlInitializeFilterChannel(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(!g_InitFilterCalled);

    if (!g_InitFilterCalled)
    {
        InitializeListHead(&g_FilterListHead);

        UlInitializeSpinLock(
            &g_pUlNonpagedData->FilterSpinLock,
            "FilterSpinLock"
            );

        //
        // Initialize lookaside list for filter write tracker
        // objects.
        //
        // CODEWORK: make the depth configurable.
        //
        
        g_FilterWriteTrackerLookaside =
            PplCreatePool(
                &UxpAllocateFilterWriteTrackerPool,     // Allocate
                &UxpFreeFilterWriteTrackerPool,         // Free
                0,                                      // Flags
                sizeof(UX_FILTER_WRITE_TRACKER),        // Size
                UX_FILTER_WRITE_TRACKER_POOL_TAG,       // Tag
                DEFAULT_LOOKASIDE_DEPTH                 // Depth
                );

        if (g_FilterWriteTrackerLookaside)
        {
            g_InitFilterCalled = TRUE;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }

    }
    
    return Status;
}

/***************************************************************************++

Routine Description:

    Cleans up global data related to filter channels.

--***************************************************************************/
VOID
UlTerminateFilterChannel(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //
    PAGED_CODE();

    if (g_InitFilterCalled)
    {
        PplDestroyPool( g_FilterWriteTrackerLookaside );

        g_InitFilterCalled = FALSE;
    }
}

/***************************************************************************++

Routine Description:

    Attaches a process to a filter channel. If the filter channel does
    not yet exist and the Create flag is set, this function will create
    a new one.

Arguments:

    pName - name of the filter channel
    NameLength - length of the name in bytes
    Create - set if non-existant channel should be created
    pAccessState - security crap
    DesiredAccess - security crap
    RequestorMode - kernel or user

    ppFilterProcess - returns the filter process object

--***************************************************************************/
NTSTATUS
UlAttachFilterProcess(
    IN PWCHAR pName,
    IN ULONG NameLength,
    IN BOOLEAN Create,
    IN PACCESS_STATE pAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PUL_FILTER_PROCESS *ppFilterProcess
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_FILTER_CHANNEL pChannel = NULL;
    PUL_FILTER_PROCESS pProcess = NULL;
    KIRQL oldIrql;
    WCHAR SafeName[(UL_MAX_FILTER_NAME_LENGTH / sizeof(WCHAR)) + 1];

    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
//    PAGED_CODE();
    ASSERT(pName);
    ASSERT(NameLength < UL_MAX_FILTER_NAME_LENGTH);
    ASSERT(ppFilterProcess);

    //
    // Copy the name into non-paged memory.
    //
    RtlCopyMemory(&SafeName, pName, NameLength);
    pName = (PWCHAR) &SafeName;

    //
    // Try to find a filter channel with the given name.
    //
//    UlAcquireResourceExclusive(&g_pUlNonpagedData->FilterResource, TRUE);
    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    pChannel = UlpFindFilterChannel(pName, NameLength);

    if (pChannel)
    {
        //
        // Ref for the new process object
        //
        REFERENCE_FILTER_CHANNEL(pChannel);
    }
    
    //
    // We're done with the list for now.
    //
//        UlReleaseResource(&g_pUlNonpagedData->FilterResource);
    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);
    
    //
    // If we didn't find a filter channel, try to create one.
    //
    if (!pChannel)
    {
        if (Create)
        {
            PUL_FILTER_CHANNEL pNewChannel = NULL;
            
            Status = UlpCreateFilterChannel(
                            pName,
                            NameLength,
                            pAccessState,
                            &pNewChannel
                            );

            //
            // OK. We've created a filter channel. Now insert it into
            // the list. Before we do that though, check to make sure
            // that no one else has created another channel with the
            // same name while we we're working on ours.
            //
            if (NT_SUCCESS(Status))
            {
                UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

                pChannel = UlpFindFilterChannel(pName, NameLength);

                if (!pChannel)
                {
                    //
                    // Ours is unique. Add it to the list.
                    //
                    pChannel = pNewChannel;
                    InsertHeadList(&g_FilterListHead, &pChannel->ListEntry);

                    //
                    // If this is the SSL channel for client or server, 
                    // store them in some globals.
                    //
                    if(NameLength == HTTP_SSL_SERVER_FILTER_CHANNEL_NAME_LENGTH
                       &&
                       (_wcsnicmp(
                            pName,
                            HTTP_SSL_SERVER_FILTER_CHANNEL_NAME,
                            HTTP_SSL_SERVER_FILTER_CHANNEL_NAME_LENGTH/
                                    sizeof(WCHAR)) == 0))
                    {
                        ASSERT(g_pSslServerFilterChannel == NULL);
                        g_pSslServerFilterChannel = pChannel;
                        REFERENCE_FILTER_CHANNEL(pChannel);
                    }
                    else
                    {
                        if(NameLength == 
                                HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME_LENGTH &&
                           (_wcsnicmp(
                                pName,
                                HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME,
                                HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME_LENGTH/
                                    sizeof(WCHAR)) == 0))
                        {
                            ASSERT(g_pSslClientFilterChannel == NULL);
                            g_pSslClientFilterChannel = pChannel;
                            REFERENCE_FILTER_CHANNEL(pChannel);
                        }
                    }
                }
                
                UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

                //
                // Now that we're outside the spinlock, we can deref
                // our filter channel if it was a duplicate.
                //
                if (pChannel != pNewChannel)
                {
                    //
                    // The channel has been added already.
                    // Get rid of the one we just created, and
                    // ref the one we found.
                    //
                    DEREFERENCE_FILTER_CHANNEL(pNewChannel);
                    REFERENCE_FILTER_CHANNEL(pChannel);
                }
            }            
        }
        else
        {
            //
            // Didn't find a channel and can't create one.
            //
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

    }
    else
    {
        //
        // Attach to the existing filter channel.
        //

        if (!Create)
        {
            //
            // If we pass the access check, we're all set.
            //
            Status = UlAccessCheck(
                            pChannel->pSecurityDescriptor,
                            pAccessState,
                            DesiredAccess,
                            RequestorMode,
                            pName
                            );
        }
        else
        {
            //
            // We were trying to create an object that already
            // exists..
            //
            Status = STATUS_OBJECT_NAME_COLLISION;
        }
    }

    if (NT_SUCCESS(Status))
    {
        //
        // We've got a filter channel, create the process object
        // and link it into the channel's list.
        //
        pProcess = UlpCreateFilterProcess(pChannel);

        if (pProcess)
        {
            //
            // Put it in the filter channel list.
            //

            UlAcquireSpinLock(&pChannel->SpinLock, &oldIrql);
            InsertHeadList(&pChannel->ProcessListHead, &pProcess->ListEntry);
            UlReleaseSpinLock(&pChannel->SpinLock, oldIrql);

            //
            // Return it to the caller.
            //

            *ppFilterProcess = pProcess;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    //
    // Done. Clean up if anything failed.
    //
    if (!NT_SUCCESS(Status))
    {
        if (pChannel != NULL)
        {
            DEREFERENCE_FILTER_CHANNEL(pChannel);
        }
        if (pProcess != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pProcess, UL_FILTER_PROCESS_POOL_TAG);
        }
    }

    return Status;
}
   

/***************************************************************************++

Routine Description:

    Detaches a process from a filter channel.

    This is called by UlCleanup when the handle count goes to 0.  It removes
    the process object from the filter channel and cancels all i/o.

Arguments:

    pFilterProcess - the process object to detach

--***************************************************************************/
NTSTATUS
UlDetachFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    )
{
    PUL_FILTER_CHANNEL pChannel;
    KIRQL oldIrql;
    LIST_ENTRY ConnectionHead;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(IS_VALID_FILTER_PROCESS(pFilterProcess));
    
    pChannel = pFilterProcess->pFilterChannel;
    ASSERT(IS_VALID_FILTER_CHANNEL(pChannel));
    

    UlAcquireSpinLock(&pChannel->SpinLock, &oldIrql);
    
    //
    // Mark the process as InCleanup so new I/O won't be attached
    //
    ASSERT( !pFilterProcess->InCleanup );
    pFilterProcess->InCleanup = 1;
    
    //
    // Unlink from filter channel list.
    //
    RemoveEntryList(&pFilterProcess->ListEntry);


    if(pChannel == g_pSslServerFilterChannel)
    {
        g_pSslServerFilterChannel = NULL;
        DEREFERENCE_FILTER_CHANNEL(pChannel);
    }
    else if(pChannel == g_pSslClientFilterChannel)
    {
        g_pSslClientFilterChannel = NULL;
        DEREFERENCE_FILTER_CHANNEL(pChannel);
    }

    //
    // Cancel outstanding I/O.
    //

    //
    // Cancel FilterAccept IRPs.
    //
    while (!IsListEmpty(&pFilterProcess->IrpHead))
    {
        PLIST_ENTRY pEntry;
        PIRP pIrp;

        //
        // Pop it off the list.
        //

        pEntry = RemoveHeadList(&pFilterProcess->IrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looping
            //

            pIrp = NULL;

        }
        else
        {
            PUL_FILTER_CHANNEL pFilterChannel;

            //
            // cancel it.  even if pIrp->Cancel == TRUE we are supposed to
            // complete it, our cancel routine will never run.
            //

            pFilterChannel = (PUL_FILTER_CHANNEL)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pFilterChannel == pChannel);

            DEREFERENCE_FILTER_CHANNEL(pFilterChannel);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, g_UlPriorityBoost);
            pIrp = NULL;
        }
    }

    //
    // Close all connections attached to the process.
    // We need to move them to a private list, release
    // the channel spinlock, and then call close on 
    // each connection.
    //
    InitializeListHead(&ConnectionHead);
    
    while (!IsListEmpty(&pFilterProcess->ConnectionHead))
    {
        PUX_FILTER_CONNECTION pConnection;
        PLIST_ENTRY pEntry;
        BOOLEAN Disconnect;

        pEntry = RemoveHeadList(&pFilterProcess->ConnectionHead);
        pConnection = CONTAINING_RECORD(
                            pEntry,
                            UX_FILTER_CONNECTION,
                            ChannelEntry
                            );

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

        UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

        ASSERT(pConnection->ConnState != UlFilterConnStateInactive);

        if (pConnection->ConnState == UlFilterConnStateQueued ||
            pConnection->ConnState == UlFilterConnStateConnected)
        {
            pConnection->ConnState = UlFilterConnStateWillDisconnect;
            Disconnect = TRUE;
        }
        else
        {
            Disconnect = FALSE;
        }

        UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

        if (Disconnect)
        {
            InsertHeadList(&ConnectionHead, &pConnection->ChannelEntry);
        }
        else
        {
            DEREFERENCE_FILTER_CONNECTION(pConnection);
    
        }
    }

    UlReleaseSpinLock(&pChannel->SpinLock, oldIrql);

    //
    // Now that we're outside the lock we can
    // close all the connections.
    //
    while (!IsListEmpty(&ConnectionHead))
    {
        PUX_FILTER_CONNECTION pConnection;
        PLIST_ENTRY           pEntry;

        pEntry = RemoveHeadList(&ConnectionHead);
        pConnection = CONTAINING_RECORD(
                            pEntry,
                            UX_FILTER_CONNECTION,
                            ChannelEntry
                            );

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));


        pConnection->ChannelEntry.Flink = NULL;
        pConnection->ChannelEntry.Blink = NULL;

        (pConnection->pCloseConnectionHandler)(
            pConnection->pConnectionContext,
            TRUE,           // AbortiveDisconnect
            NULL,           // pCompletionRoutine
            NULL            // pCompletionContext
            );

        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // We're now detached from the filter channel.
    //
    DEREFERENCE_FILTER_CHANNEL(pFilterProcess->pFilterChannel);
    
    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Frees the memory used by a UL_FILTER_PROCESS object.

Arguments:

    pFilterProcess - the process object to free

--***************************************************************************/
VOID
UlFreeFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    )
{
    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );

    UL_FREE_POOL_WITH_SIG(pFilterProcess, UL_FILTER_PROCESS_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    Accepts a raw connection that's been routed to the filter channel.

Arguments:

    pFilterProcess - the calling filter process
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterAccept(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    PUL_FILTER_CHANNEL pChannel;
    PUX_FILTER_CONNECTION pConnection;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( pIrp );

    //
    // Always return pending unless we are going to fail
    // inline. In that case we have to remember to
    // remove the pending flag from the IRP.
    //
    
    IoMarkIrpPending(pIrp);

    Status = STATUS_PENDING;
    pConnection = NULL;
    
    pChannel = pFilterProcess->pFilterChannel;

    UlAcquireSpinLock(&pChannel->SpinLock, &oldIrql);
    
    //
    // Make sure we're not cleaning up the process
    //
    if (pFilterProcess->InCleanup) {
        Status = STATUS_INVALID_HANDLE;
        goto end;
    }

    //
    // Do we have a queued new connection?
    //
    if (!IsListEmpty(&pFilterProcess->pFilterChannel->ConnectionListHead))
    {
        PLIST_ENTRY pEntry;
        
        //
        // Accept a queued connection.
        //

        pEntry = RemoveHeadList(&pChannel->ConnectionListHead);
        pConnection = CONTAINING_RECORD(
                            pEntry,
                            UX_FILTER_CONNECTION,
                            ChannelEntry
                            );

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
        ASSERT(pConnection->ConnState == UlFilterConnStateQueued);
        
        pConnection->ChannelEntry.Flink = NULL;
        pConnection->ChannelEntry.Blink = NULL;

        UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);
        
        pConnection->ConnState = UlFilterConnStateConnected;

        UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

        //
        // Transfer (referenced) connection to the calling process.
        //
        InsertTailList(
            &pFilterProcess->ConnectionHead,
            &pConnection->ChannelEntry
            );

        //
        // Deliver the data outside spinlocks.
        //

    }
    else
    {
        PIO_STACK_LOCATION pIrpSp;

        //
        // No connection available. Queue the IRP.
        //

        //
        // give the irp a pointer to the filter channel
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pChannel;

        REFERENCE_FILTER_CHANNEL(pChannel);

        //
        // set to these to null just in case the cancel routine runs
        //

        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

        IoSetCancelRoutine(pIrp, &UlpCancelFilterAccept);

        //
        // cancelled?
        //

        if (pIrp->Cancel)
        {
            //
            // darn it, need to make sure the irp get's completed
            //

            if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
            {
                //
                // we are in charge of completion, IoCancelIrp didn't
                // see our cancel routine (and won't).  ioctl wrapper
                // will complete it
                //

                DEREFERENCE_FILTER_CHANNEL(pChannel);

                pIrp->IoStatus.Information = 0;

                Status = STATUS_CANCELLED;
                goto end;
            }

            //
            // our cancel routine will run and complete the irp,
            // don't touch it
            //

            //
            // STATUS_PENDING will cause the ioctl wrapper to
            // not complete (or touch in any way) the irp
            //

            Status = STATUS_PENDING;
            goto end;
        }

        //
        // now we are safe to queue it
        //

        InsertTailList(
            &pFilterProcess->IrpHead,
            &pIrp->Tail.Overlay.ListEntry
            );

        Status = STATUS_PENDING;
    }
    

end:
    UlReleaseSpinLock(&pChannel->SpinLock, oldIrql);

    //
    // Now that we're outside the spin lock, we can complete
    // the IRP if we have a connection. Don't bother to
    // try keep track of initial data. Let the filter process
    // request it.
    //
    if (pConnection)
    {
        UlpCompleteAcceptIrp(
            pIrp,
            pConnection,
            NULL,               // pBuffer
            0,                  // IndicatedLength
            NULL                // pTakenLength
            );

    }

    if (Status != STATUS_PENDING)
    {
        UlUnmarkIrpPending( pIrp );
    }

    RETURN(Status);
}


/***************************************************************************++

Routine Description:

    Closes a raw connection.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection to close
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterClose(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    BOOLEAN CloseConnection;

    //
    // Init locals so we know how to clean up.
    //
    CloseConnection = FALSE;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( pIrp );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);
    
    Status = UlpValidateFilterCall(pFilterProcess, pConnection);


    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Do the close outside the spin lock.
    // Go ahead and mark the IRP as pending, then
    // guarantee that we'll only return pending from
    // this point on.
    //

    IoMarkIrpPending( pIrp );
    Status = STATUS_PENDING;

    CloseConnection = TRUE;
    

end:
    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (CloseConnection)
    {
        (pConnection->pCloseConnectionHandler)(
            pConnection->pConnectionContext,
            FALSE,                      // AbortiveDisconnect
            UlpRestartFilterClose,      // pCompletionRoutine
            pIrp                        // pCompletionContext
            );

    }

    UlTrace(FILTER, (
        "ul!UlFilterClose pConn = %p returning %x\n",
        pConnection,
        Status
        ));

    RETURN(Status);

}


/***************************************************************************++

Routine Description:

    Reads data from a raw connection.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection from which to read
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterRawRead(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( pIrp );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);
    
    Status = UlpValidateFilterCall(pFilterProcess, pConnection);


    if (NT_SUCCESS(Status))
    {
        UlTrace(FILTER, (
            "http!UlFilterRawRead(pConn = %p, pIrp = %p) size = %lu\n",
            pConnection,
            pIrp,
            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.OutputBufferLength
            ));
    
        //
        // Always queue the IRP.
        //

        Status = UxpQueueRawReadIrp(pConnection, pIrp);
    }

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (NT_SUCCESS(Status))
    {
        //
        // If we successfully queued the IRP, see if we need to grab some
        // data from TDI.
        //

        UxpProcessRawReadQueue(pConnection);
    }

    RETURN(Status);
}

/***************************************************************************++

Routine Description:

    Writes filtered data back to the network.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection from which the data originated
    BufferLength - the size of pBuffer
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterRawWrite(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG BufferLength,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    PUL_IRP_CONTEXT pIrpContext;
    KIRQL oldIrql;

    //
    // This function always returns STATUS_PENDING.
    //

    ASSERT(IS_VALID_IRP(pIrp));
    IoMarkIrpPending(pIrp);

    //
    // Setup locals so we know how to cleanup on failure.
    //

    pIrpContext = NULL;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);
    
    Status = UlpValidateFilterCall(pFilterProcess, pConnection);

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (!NT_SUCCESS(Status))
    {
        goto fatal;
    }

    //
    // Allocate & initialize a context structure if necessary.
    //

    pIrpContext = UlPplAllocateIrpContext();

    if (pIrpContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID)pConnection->pConnectionContext;
    pIrpContext->pCompletionRoutine = &UlpRestartFilterRawWrite;
    pIrpContext->pCompletionContext = pIrp;
    pIrpContext->pOwnIrp            = NULL;

    //
    // Try to send the data.
    //

    Status = (pConnection->pSendRawDataHandler)(
                    pConnection->pConnectionContext,
                    pIrp->MdlAddress,
                    BufferLength,
                    pIrpContext
                    );

    if (!NT_SUCCESS(Status))
    {
        goto fatal;
    }

    return STATUS_PENDING;
    
fatal:
    ASSERT(!NT_SUCCESS(Status));

    if (pIrpContext != NULL)
    {
        UlPplFreeIrpContext( pIrpContext );
    }

    (pConnection->pCloseConnectionHandler)(
                pConnection->pConnectionContext,
                TRUE,           // AbortiveDisconnect
                NULL,           // pCompletionRoutine
                NULL            // pCompletionContext
                );

    //
    // Complete the IRP.
    //
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    
    UlTrace(FILTER, (
        "ul!UlFilterRawWrite sent %d bytes from %p. Status = %x\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status
        ));

    UlCompleteRequest(pIrp, g_UlPriorityBoost);    

    //
    // STATUS_PENDING will cause the ioctl wrapper to
    // not complete (or touch in any way) the irp
    //

    Status = STATUS_PENDING;

    RETURN(Status);

}

/***************************************************************************++

Routine Description:

    Receives unfiltered data from the http application. All we do here is
    put the IRP on a queue. It will be consumed later by a writer. If
    there is a writer waiting for IRPs, we'll wake him up.
    
Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection from which the data originated
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterAppRead(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( pIrp );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);
    
    Status = UlpValidateFilterCall(pFilterProcess, pConnection);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Queue the IRP.
    //
    Status = UlpQueueFilterIrp(
                    pIrp,
                    &UlpCancelFilterAppRead,
                    pConnection,
                    &pConnection->AppToFiltQueue
                    );


end:
    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (NT_SUCCESS(Status))
    {
        UlTrace(FILTER, (
            "UlFilterAppRead(pConn = %p, pIrp = %p) queued irp\n",
            pConnection,
            pIrp
            ));
    }

    RETURN(Status);

}


/***************************************************************************++

Routine Description:

    Writes filtered data back to a connection. That data will be parsed
    and routed to an application pool.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection from which the data originated
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterAppWrite(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    BOOLEAN QueuedIrp = FALSE;
    KIRQL oldIrql;
    BOOLEAN CertMapped;
    UL_SSL_INFORMATION SslInformation;

    ULONG TakenLength;
    PHTTP_FILTER_BUFFER pFiltBuffer;
    PUCHAR pDataBuffer;
    ULONG DataBufferSize;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( pIrp );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);
    
    Status = UlpValidateFilterCall(pFilterProcess, pConnection);

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (!NT_SUCCESS(Status))
    {
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
        goto end;
    }

    //
    // Get buffer info.
    //

    pFiltBuffer = (PHTTP_FILTER_BUFFER) pIrp->AssociatedIrp.SystemBuffer;
    
    pDataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                        pIrp->MdlAddress,
                        LowPagePriority
                        );

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    DataBufferSize = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (!pDataBuffer)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        //
        // Actually do something with the data.
        //

        switch (pFiltBuffer->BufferType)
        {
        case HttpFilterBufferHttpStream:
            //
            // Handle this case later inside the filter lock.
            //
        
            break;

        case HttpFilterBufferSslInitInfo:
        
            //
            // Capture all the SSL info.
            //

            RtlZeroMemory(&SslInformation, sizeof(SslInformation));

            Status = UlpCaptureSslInfo(
                            (PHTTP_SSL_INFO)pDataBuffer,
                            DataBufferSize,
                            &SslInformation,
                            &TakenLength
                            );
            break;

        case HttpFilterBufferSslClientCert:
        case HttpFilterBufferSslClientCertAndMap:
        
            //
            // Capture the client certificate.
            //

            RtlZeroMemory(&SslInformation, sizeof(SslInformation));

            CertMapped =
                (pFiltBuffer->BufferType == HttpFilterBufferSslClientCertAndMap);

            Status = UlpCaptureSslClientCert(
                            CertMapped,
                            (PHTTP_SSL_CLIENT_CERT_INFO)pDataBuffer,
                            DataBufferSize,
                            &SslInformation,
                            &TakenLength
                            );
            
            Status = STATUS_SUCCESS;
            break;
            
        default:
        
            UlTrace(FILTER, (
                "ul!UlFilterAppWrite invalid buffer type: %d\n",
                pFiltBuffer->BufferType
                ));
                
            Status = STATUS_INVALID_PARAMETER;
            break;    
        }
    }

    if (!NT_SUCCESS(Status))
    {
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
        goto end;
    }

    //
    // Now acquire the lock and either pass data to the app
    // or update the connection with captured certificate information.
    //

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    if (pConnection->ConnState == UlFilterConnStateConnected)
    {
        switch (pFiltBuffer->BufferType)
        {
        case HttpFilterBufferHttpStream:

            Status = UlpFilterAppWriteStream(
                            pConnection,
                            pIrp,
                            pDataBuffer,
                            DataBufferSize,
                            &TakenLength
                            );

            if (Status == STATUS_PENDING)
            {
                //
                // Remember we queued the IRP so we don't
                // complete it at the bottom of this function.
                //

                QueuedIrp = TRUE;
            }

            break;
            

        case HttpFilterBufferSslInitInfo:
        
            //
            // Store the SSL info in the connection.
            //
            
            Status = UlpAddSslInfoToConnection(
                            pConnection,
                            &SslInformation
                            );
            break;

        case HttpFilterBufferSslClientCert:
        case HttpFilterBufferSslClientCertAndMap:
        
            //
            // Store the client certificate in the connection.
            //

            Status = UlpAddSslClientCertToConnection(
                            pConnection,
                            &SslInformation
                            );
            
            Status = STATUS_SUCCESS;
            break;
            
        default:
            ASSERT(!"Previous switch statement should have caught this!\n");
        
            UlTrace(FILTER, (
                "ul!UlFilterAppWrite invalid buffer type: %d\n",
                pFiltBuffer->BufferType
                ));
                
            Status = STATUS_INVALID_PARAMETER;
            break;    
        }
        
        //
        // Set IRP status
        //
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = TakenLength;

        //
        // On success we always complete the IRP ourselves and
        // return pending.
        //
        if (NT_SUCCESS(Status))
        {
            Status = STATUS_PENDING;
        }

    }
    else
    {
        //
        // Connection is closed. Don't do a callback.
        //
        Status = STATUS_INVALID_PARAMETER;
        
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
    }

    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // See if the parent connection code is interested in knowing about when 
    // the server certificate got installed.
    //

    if(pConnection->pServerCertIndicateHandler &&
       pFiltBuffer->BufferType == HttpFilterBufferSslInitInfo &&
       NT_SUCCESS(Status))
    {
        (pConnection->pServerCertIndicateHandler)
            (pConnection->pConnectionContext);
    }

end:
    //
    // Complete the IRP if we we're successful. Otherwise
    // the ioctl wrapper will handle the completion.
    //
    UlTrace(FILTER, (
        "ul!UlFilterAppWrite copied %d bytes from %p. Status = %x\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status
        ));

    if (NT_SUCCESS(Status) && !QueuedIrp)
    {
        UlCompleteRequest(pIrp, g_UlPriorityBoost);    
    }

    RETURN(Status);

}


/***************************************************************************++

Routine Description:

    Requests a client certificate from the filter process. If a cert
    is present, this function returns it. Otherwise the IRP is queued
    on the connection until a cert arrives. Only one such IRP can
    be queued at a time. After the IRP is queued a request for the
    client cert is sent to the filter process.

Arguments:

    pProcess - the calling worker process
    pHttpConn - the connection on which to renegotiate
    Flags - e.g. UL_RECEIVE_CLIENT_CERT_FLAG_MAP
    pIrp - the IRP from the caller

--***************************************************************************/
NTSTATUS
UlReceiveClientCert(
    PUL_APP_POOL_PROCESS pProcess,
    PUX_FILTER_CONNECTION pConnection,
    ULONG Flags,
    PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    PIO_STACK_LOCATION pIrpSp;
    PUL_FILTER_CHANNEL pFilterChannel;
    BOOLEAN DoCertRequest;
    HTTP_FILTER_BUFFER_TYPE CertRequestType;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    
    ASSERT( IS_VALID_IRP(pIrp) );

    if (!pConnection->SecureConnection)
    {
        //
        // this is not a secure connection.
        //

        return STATUS_INVALID_PARAMETER;
    }

    pFilterChannel = pConnection->pFilterChannel;
    ASSERT( IS_VALID_FILTER_CHANNEL(pFilterChannel) );

    //
    // Set up cert request info.
    //
    DoCertRequest = FALSE;

    if (Flags & HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP)
    {
        CertRequestType = HttpFilterBufferSslRenegotiateAndMap;
    }
    else
    {
        CertRequestType = HttpFilterBufferSslRenegotiate;
    }

    //
    // Now we can try to retrieve the certificate.
    //

    UlAcquireSpinLock(&pFilterChannel->SpinLock, &oldIrql);
    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);
    
    if (pConnection->SslClientCertPresent)
    {
        //
        // We have the data. Copy it in.
        //
        
        Status = UlpCompleteReceiveClientCertIrp(
                        pConnection,
                        PsGetCurrentProcess(),
                        pIrp
                        );

    }
    else
    {
        //
        // Queue the IRP.
        //

        if (pConnection->pReceiveCertIrp)
        {
            //
            // There is already an IRP here, we can't queue a second
            // one.
            //
            ASSERT(pConnection->SslClientCertRequested == 1);
            
            Status = STATUS_OBJECT_NAME_COLLISION;
            goto end;
        }

        ASSERT(pConnection->SslClientCertRequested == 0);

        //
        // Mark it pending.
        //

        IoMarkIrpPending(pIrp);

        //
        // Give the irp a pointer to the connection.
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

        // Make sure we don't already have a reference to the UL_CONNECTION on this Irp.
        ASSERT( pConnection != pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer );

        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

        REFERENCE_FILTER_CONNECTION(pConnection);

        //
        // Save away a pointer to the process in the
        // IRP. We have to be sure that the DriverContext (PVOID [4])
        // in the IRP is big enough to hold both
        // the process pointer and a UL_WORK_ITEM for
        // this to work.
        //
        C_ASSERT(offsetof(UL_WORK_ITEM, pWorkRoutine)
                    < (4 - 2) * sizeof(PVOID));
        
        pIrp->Tail.Overlay.DriverContext[3] =
            PsGetCurrentProcess();

        //
        // Set to these to null just in case the cancel routine runs.
        //

        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

        //
        // Set the cancel routine.
        //
        IoSetCancelRoutine(pIrp, &UlpCancelReceiveClientCert);

        //
        // cancelled?
        //

        if (pIrp->Cancel)
        {
            //
            // darn it, need to make sure the irp get's completed
            //

            if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
            {
                //
                // we are in charge of completion, IoCancelIrp didn't
                // see our cancel routine (and won't).  ioctl wrapper
                // will complete it
                //
                DEREFERENCE_FILTER_CONNECTION(pConnection);

                pIrp->IoStatus.Information = 0;

                UlUnmarkIrpPending( pIrp );
                Status = STATUS_CANCELLED;
                goto end;
            }

            //
            // our cancel routine will run and complete the irp,
            // don't touch it
            //

            //
            // STATUS_PENDING will cause the ioctl wrapper to
            // not complete (or touch in any way) the IRP.
            //

            Status = STATUS_PENDING;
            goto end;
        }

        //
        // now we are safe to queue it
        //

        pConnection->pReceiveCertIrp = pIrp;

        // Do we need this flag?
        pConnection->SslClientCertRequested = 1;

        //
        // We need a cert. Remember to request it after we
        // get outside the lock.
        //
        DoCertRequest = TRUE;
    }

end:
    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterChannel->SpinLock, oldIrql);

    //
    // If we need a cert from the filter process then request it
    // now that we're outside the lock.
    //
    if (DoCertRequest)
    {
        //
        // Actually request the data by completing an app read IRP
        //
        Status = UlpCompleteAppReadIrp(
                        pConnection,
                        CertRequestType
                        );

        if (NT_SUCCESS(Status))
        {
            Status = STATUS_PENDING;
        }
        else
        {
            // 
            // Failed during UlpCompleteAppReadIrp; need to clean up
            // Irp...
            //

            if (IoSetCancelRoutine( pConnection->pReceiveCertIrp, NULL ) != NULL)
            {
                UlTrace(FILTER, (
                    "http!UlReceiveClientCert: cleaning up failed UlpCompleteAppReadIrp\n  pConn = %p returning %x\n",
                    pConnection,
                    Status
                    ));
                    
                pConnection->pReceiveCertIrp->Cancel = TRUE; 

                IoGetCurrentIrpStackLocation(
                    pConnection->pReceiveCertIrp
                    )->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                DEREFERENCE_FILTER_CONNECTION(pConnection);
    
                pConnection->pReceiveCertIrp->IoStatus.Status = Status;
                pConnection->pReceiveCertIrp->IoStatus.Information = 0;

                pIrp = pConnection->pReceiveCertIrp;
                pConnection->pReceiveCertIrp = NULL;

                UlCompleteRequest(pIrp, g_UlPriorityBoost);
            }
#if DBG 
            else
            {
                UlTrace(FILTER, (
                    "http!UlReceiveClientCert: IoSetCancelRoutine to NULL after failed UlpCompleteAppReadIrp\n  pConn = %p returning %x\n",
                    pConnection,
                    Status
                    ));
            }
#endif // DBG

            //
            // Return STATUS_PENDING so the wrapper will not
            // try to complete the IRP again.
            //
            Status = STATUS_PENDING;
        }

    }

    RETURN(Status);

}



/***************************************************************************++

Routine Description:

    References a filter channel.

Arguments:

    pFilterChannel - the channel to ref

--***************************************************************************/
VOID
UlReferenceFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //
    ASSERT( IS_VALID_FILTER_CHANNEL(pFilterChannel) );

    refCount = InterlockedIncrement(&pFilterChannel->RefCount);

    WRITE_REF_TRACE_LOG(
        g_pFilterTraceLog,
        REF_ACTION_REFERENCE_FILTER,
        refCount,
        pFilterChannel,
        pFileName,
        LineNumber
        );
}


/***************************************************************************++

Routine Description:

    Derferences a filter channel. If the reference count hits zero, the
    object is cleaned up.

Arguments:

    pFilterChannel - the channel to deref

--***************************************************************************/
VOID
UlDereferenceFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;
    KIRQL oldIrql;
    
    //
    // Sanity check.
    //
    ASSERT( IS_VALID_FILTER_CHANNEL(pFilterChannel) );

    //
    // Grab the lock on the global list to prevent the refcount
    // from bouncing back up from zero.
    //
//    UlAcquireResourceExclusive(&g_pUlNonpagedData->FilterResource, TRUE);
    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    refCount = InterlockedDecrement(&pFilterChannel->RefCount);

    //
    // If the counter hits zero remove from the list.
    // Do the rest of the cleanup later, outside the lock.
    //
    if (refCount == 0)
    {
        RemoveEntryList(&pFilterChannel->ListEntry);
        pFilterChannel->ListEntry.Flink = NULL;
        pFilterChannel->ListEntry.Blink = NULL;
    }

//    UlReleaseResource(&g_pUlNonpagedData->FilterResource);
    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

    WRITE_REF_TRACE_LOG(
        g_pFilterTraceLog,
        REF_ACTION_DEREFERENCE_FILTER,
        refCount,
        pFilterChannel,
        pFileName,
        LineNumber
        );

    //
    // Clean up the object if it has no more references.
    //
    if (refCount == 0)
    {
        //
        // Do some sanity checking.
        //
        ASSERT( UlDbgSpinLockUnowned(&pFilterChannel->SpinLock) );
        ASSERT( IsListEmpty(&pFilterChannel->ProcessListHead) );

        //
        // BUGBUG: clean up queued connections.
        //

        //
        // Cleanup any security descriptor on the object.
        //
        UlDeassignSecurity( &pFilterChannel->pSecurityDescriptor );

        //
        // Free the memory.
        //
        UL_FREE_POOL_WITH_SIG(pFilterChannel, UL_FILTER_CHANNEL_POOL_TAG);
    }
}


/***************************************************************************++

Routine Description:

    This function is called when data arrives on a filtered connection.
    It passes the data up to the filter process.

Arguments:

    pFilterChannel - pointer to the filter channel
    pConnection - the connection that just got some data
    pBuffer - the buffer containing the data
    IndicatedLength - amount of data in the buffer
    UnreceivedLength- Bytes that the transport has, but aren't in pBuffer
    pTakenLength - receives the amount of data we consumed

--***************************************************************************/
NTSTATUS
UlFilterReceiveHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    ULONG TransportBytesNotTaken;

    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pBuffer);
    ASSERT(pTakenLength);

    //
    // Pass the data on to an accept IRP or a raw read IRP.
    //

    if (!pConnection->ConnectionDelivered)
    {
        //
        // Since this is the first receive on the connection,
        // we complete a FilterAccept call.
        //
        Status = UlDeliverConnectionToFilter(
                        pConnection,
                        pBuffer,
                        IndicatedLength,
                        pTakenLength
                        );
    }
    else
    {
        //
        // Filter the data.
        //
        Status = UxpProcessIndicatedData(
                        pConnection,
                        pBuffer,
                        IndicatedLength,
                        pTakenLength
                        );
        
    }

    //
    // Figure out how many bytes we didn't consume, including data
    // that TDI hasn't yet given us.
    //

    TransportBytesNotTaken = UnreceivedLength;

    if (NT_SUCCESS(Status))
    {
        TransportBytesNotTaken += (IndicatedLength - *pTakenLength);
    }

    //
    // If there is data we didn't take then TDI is going to stop
    // indications until we read that data with IRPs. If there
    // is some data we didn't take and we didn't encounter an
    // error, we should try to grab the data TDI stuck with.
    //

    if (NT_SUCCESS(Status) && TransportBytesNotTaken)
    {
        UxpSetBytesNotTaken(pConnection, TransportBytesNotTaken);
    }

    UlTrace(FILTER, (
                "http!UlpFilterReceiveHandler received %d bytes on pconn = %p\n"
                "        Status = %x, TransportBytesNotTaken = %lu\n",
                IndicatedLength,
                pConnection,
                Status,
                TransportBytesNotTaken
                ));

    return Status;
}


/***************************************************************************++

Routine Description:

    This function is called whenever an app writes data to a filtered
    connection. It forwards all the data to the connections filter channel.
    This call blocks until all the the data is accepted by the filter
    and does the completion inline.

Arguments:

    pConnection - the connection we're writing to
    pMdlChain - a chain of MDLs for the data
    Length - the total amount of data in the MDL chain
    pIrpContext - used to indicate completion to the caller

--***************************************************************************/
NTSTATUS
UlFilterSendHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_IRP_CONTEXT pIrpContext
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    PUL_FILTER_PROCESS pProcess;
    UL_MDL_CHAIN_COPY_TRACKER CopyTracker;
    
    UlTrace(FILTER, (
                "ul!UlFilterSendHandler processing %d bytes on pconn = %p\n",
                Length,
                pConnection
                ));


    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pMdlChain);
    ASSERT(pIrpContext);

    ASSERT(pConnection->ConnectionDelivered == TRUE);

    //
    // Get ready.
    //
    Status = STATUS_SUCCESS;
    CopyTracker.pMdl = pMdlChain;
    CopyTracker.Offset = 0;
    CopyTracker.Length = Length;
    CopyTracker.BytesCopied = 0;

    //
    // Wait until we're the active writer.
    //

    UlpStartAppToFiltWriter(pConnection);
    
    //
    // Write the data.
    //
    while (NT_SUCCESS(Status) &&
            (CopyTracker.BytesCopied < CopyTracker.Length))
    {
        BOOLEAN PartialWrite;
        ULONG_PTR bytesTaken;

        //
        // Do some writing.
        //

        PartialWrite = FALSE;
    
        UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

        if (pConnection->ConnState == UlFilterConnStateConnected)
        {
            ASSERT(pConnection->AppToFiltQueue.ReadIrps > 0);

            Status = UlpCompleteAppReadIrpWithData(
                            pConnection,
                            &CopyTracker
                            );

            if (NT_SUCCESS(Status) &&
                (CopyTracker.BytesCopied < CopyTracker.Length))
            {
                pConnection->AppToFiltQueue.BlockedPartialWrite = TRUE;
                PartialWrite = TRUE;
            }
        }
        else
        {
            //
            // We got disconnected, get out.
            //
            UlTrace(FILTER, (
                "ul!UlFilterSendHandler connection aborted, quit writing!\n"
                ));

            Status = STATUS_CONNECTION_DISCONNECTED;
        }

        if (PartialWrite)
        {
            WRITE_FILTQ_TRACE_LOG(
                FILTQ_ACTION_BLOCK_PARTIAL_WRITE,
                pConnection,
                NULL
                );
        }

        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

        //
        // If we wrote some of the data, wait on the special event
        // that wakes us up first when new buffers arrive.
        //
        if (PartialWrite)
        {
            ASSERT(NT_SUCCESS(Status));
        
            KeWaitForSingleObject(
                (PVOID)&pConnection->AppToFiltQueue.PartialWriteEvent,
                UserRequest,
                KernelMode,
                FALSE,
                NULL
                );

            PartialWrite = FALSE;
        }

    }

    //
    // Tell other writers that we're finished.
    //
    UlpFinishAppToFiltWriter(pConnection);

    //
    // Do a "completion".
    //
    (pIrpContext->pCompletionRoutine)(
        pIrpContext->pCompletionContext,
        Status,
        CopyTracker.BytesCopied
        );

    return STATUS_PENDING;
}


/***************************************************************************++

Routine Description:

    This function is called when the App issues a read to grab bytes that
    were previously queued on the connection. Note that the app should
    only issue a read if there were bytes queued. Therefore these read
    operations are always completed immediately and never queued and
    there should always be queued writes available.

Arguments:

    pConnection - the connection we're writing to
    pBuffer - a buffer to receive the data
    BufferLength - the total amount of data in the MDL chain
    pCompletionRoutine - used to indicate completion to the caller
    pCompletionContext - passed to the completion routine

--***************************************************************************/
NTSTATUS
UlFilterReadHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    OUT PBYTE pBuffer,
    IN ULONG BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    ULONG BytesCopied;
    
    UlTrace(FILTER, (
                "ul!UlpFilterReadHandler reading %d bytes on pconn = %p\n",
                BufferLength,
                pConnection
                ));


    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pBuffer);
    ASSERT(BufferLength);
    ASSERT(pCompletionRoutine);

    //
    // Read the data.
    //

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    if (pConnection->ConnState == UlFilterConnStateConnected)
    {
        ASSERT(pConnection->FiltToAppQueue.PendingWriteCount > 0);

        //
        // Grab data from the filter write queue.
        //

        Status = UxpCopyQueuedWriteData(
                            &pConnection->FiltToAppQueue,   // write queue
                            pBuffer,                        // output buffer
                            BufferLength,                   // output buffer len
                            &BytesCopied                    // pBytesCopied
                            );

        ASSERT(!NT_SUCCESS(Status) || BytesCopied);
        
        //
        // Call the completion routine.
        //

        Status = UlInvokeCompletionRoutine(
                        Status,
                        BytesCopied,
                        pCompletionRoutine,
                        pCompletionContext
                        );

    }
    else
    {
        //
        // We got disconnected, get out.
        //

        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    return Status;
}



/***************************************************************************++

Routine Description:

    Tells the filter channel to close an open connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUX_FILTER_CONNECTION_REQUEST handler.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterCloseHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    Status = UlpCompleteAppReadIrp(
                    pConnection,
                    HttpFilterBufferCloseConnection
                    );

    //
    // For our purpose, we are successful if the connection
    // is already closed.
    //
    if (Status == STATUS_CONNECTION_DISCONNECTED)
    {
        Status = STATUS_SUCCESS;
    }

    //
    // Tell the caller what happened.
    //

    return UlInvokeCompletionRoutine(
                Status,
                0,
                pCompletionRoutine,
                pCompletionContext
                );

}


/***************************************************************************++

Routine Description:

    Removes a connection from any filter channel lists it might be on.
    Cancels all IRPs attached to the connection.

Arguments:

    pConnection - the connection to unbind

--***************************************************************************/
VOID
UlUnbindConnectionFromFilter(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    KIRQL oldIrql;
    PUL_FILTER_CHANNEL pFilterChannel;
    BOOLEAN DerefConnection;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(IS_VALID_FILTER_CHANNEL(pConnection->pFilterChannel));

    UlTrace(FILTER, (
        "UlUnbindConnectionFromFilter(pConn = %p)\n",
        pConnection
        ));

    //
    // Clean up filter channel related stuff.
    //
    pFilterChannel = pConnection->pFilterChannel;
    DerefConnection = FALSE;

    UlAcquireSpinLock(&pFilterChannel->SpinLock, &oldIrql);
    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    if (pConnection->ConnState != UlFilterConnStateInactive)
    {

        if ((pConnection->ConnState == UlFilterConnStateQueued) ||
            (pConnection->ConnState == UlFilterConnStateConnected))
        {
            //
            // Remove from filter channel queue.
            //
            ASSERT( pConnection->ChannelEntry.Flink );

            //
            // Remember to remove the list's ref at the end.
            //
            DerefConnection = TRUE;

            //
            // Get off the list.
            //
            RemoveEntryList(&pConnection->ChannelEntry);
            pConnection->ChannelEntry.Flink = NULL;
            pConnection->ChannelEntry.Blink = NULL;

            pConnection->ConnState = UlFilterConnStateWillDisconnect;
        }

        //
        // Cancel RetrieveClientCert request
        // 
        if (pConnection->pReceiveCertIrp)
        {
            if (IoSetCancelRoutine( pConnection->pReceiveCertIrp, NULL ) != NULL)
            {
                PIRP pIrp;

                UlTrace(FILTER, (
                    "http!UlUnbindConnectionFromFilter: cleaning up pReceiveCertIrp\n  pConn = %p\n",
                    pConnection
                    ));
                    
                pConnection->pReceiveCertIrp->Cancel = TRUE; 

                IoGetCurrentIrpStackLocation(
                    pConnection->pReceiveCertIrp
                    )->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                DEREFERENCE_FILTER_CONNECTION(pConnection);
    
                pConnection->pReceiveCertIrp->IoStatus.Status = STATUS_CANCELLED;
                pConnection->pReceiveCertIrp->IoStatus.Information = 0;

                pIrp = pConnection->pReceiveCertIrp;
                pConnection->pReceiveCertIrp = NULL;

                UlCompleteRequest(pIrp, g_UlPriorityBoost);
            }
#if DBG 
            else
            {
                UlTrace(FILTER, (
                    "http!UlUnbindConnectionFromFilter: IoSetCancelRoutine already NULL while cleaning up pConn = %p\n",
                    pConnection
                    ));
            }
#endif // DBG
        }

        //
        // Cancel FilterRawRead IRPs.
        //

        UxpCancelAllQueuedRawReads(pConnection);

        //
        // Cancel FilterAppRead IRPs.
        //

        while (!IsListEmpty(&pConnection->AppToFiltQueue.ReadIrpListHead))
        {
            PLIST_ENTRY pEntry;
            PIRP pIrp;

            //
            // Pop it off the list.
            //

            pEntry = RemoveHeadList(&pConnection->AppToFiltQueue.ReadIrpListHead);
            pEntry->Blink = pEntry->Flink = NULL;

            pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
            ASSERT(IS_VALID_IRP(pIrp));

            //
            // Decrement the list counter.
            //
            ASSERT(pConnection->AppToFiltQueue.ReadIrps > 0);
            pConnection->AppToFiltQueue.ReadIrps--;

            //
            // pop the cancel routine
            //

            if (IoSetCancelRoutine(pIrp, NULL) == NULL)
            {
                //
                // IoCancelIrp pop'd it first
                //
                // ok to just ignore this irp, it's been pop'd off the queue
                // and will be completed in the cancel routine.
                //
                // keep looping
                //

                pIrp = NULL;

            }
            else
            {
                PUX_FILTER_CONNECTION pConn;

                //
                // cancel it.  even if pIrp->Cancel == TRUE we are supposed to
                // complete it, our cancel routine will never run.
                //

                pConn = (PUX_FILTER_CONNECTION)(
                            IoGetCurrentIrpStackLocation(pIrp)->
                                Parameters.DeviceIoControl.Type3InputBuffer
                            );

                ASSERT(pConn == pConnection);

                DEREFERENCE_FILTER_CONNECTION(pConnection);

                IoGetCurrentIrpStackLocation(pIrp)->
                    Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                pIrp->IoStatus.Status = STATUS_CANCELLED;
                pIrp->IoStatus.Information = 0;

                UlCompleteRequest(pIrp, g_UlPriorityBoost);
                pIrp = NULL;
            }
        }

        //
        // Wake up any waiting writers.
        //

        WRITE_FILTQ_TRACE_LOG(
            FILTQ_ACTION_WAKE_WRITE,
            pConnection,
            NULL
            );

        KeSetEvent(
            &pConnection->AppToFiltQueue.ReadIrpAvailableEvent,
            0,
            FALSE
            );

        WRITE_FILTQ_TRACE_LOG(
            FILTQ_ACTION_WAKE_PARTIAL_WRITE,
            pConnection,
            NULL
            );
            
        KeSetEvent(
            &pConnection->AppToFiltQueue.PartialWriteEvent,
            0,
            FALSE
            );

        //
        // Cancel all I/O on the FiltToApp write queue.
        //

        UxpCancelAllQueuedWrites(&pConnection->FiltToAppQueue);

    }

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterChannel->SpinLock, oldIrql);

    if (DerefConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }
    
}


/***************************************************************************++

Routine Description:

    Marks a filtered connection as closed so that we'll stop passing on
    data from UlFilterAppWrite to the upper layers. This guarantees that
    they won't receive any more data after we told them the connection
    was closed.

    Also removes the connection from any filter channel lists.

Arguments:

    pConnection - the connection that's going away.

--***************************************************************************/
VOID
UlDestroyFilterConnection(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    KIRQL oldIrql;
    BOOLEAN DerefConnection;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    UlAcquireSpinLock(&pConnection->pFilterChannel->SpinLock, &oldIrql);
    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    //
    // Make sure we remove ourselves from the filter channel's
    // list.
    //
    
    if ((pConnection->ConnState == UlFilterConnStateQueued) ||
        (pConnection->ConnState == UlFilterConnStateConnected))
    {
        //
        // Remove from filter channel queue.
        //
        ASSERT( pConnection->ChannelEntry.Flink );

        //
        // Remember to remove the list's ref at the end.
        //
        DerefConnection = TRUE;

        //
        // Get off the list.
        //
        RemoveEntryList(&pConnection->ChannelEntry);
        pConnection->ChannelEntry.Flink = NULL;
        pConnection->ChannelEntry.Blink = NULL;

    }
    else
    {
        ASSERT( pConnection->ChannelEntry.Flink == NULL );
    
        DerefConnection = FALSE;
    }

    //
    // Set the new connection state.
    //
    
    pConnection->ConnState = UlFilterConnStateDisconnected;

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pConnection->pFilterChannel->SpinLock, oldIrql);

    //
    // Deref if we were removed from a list.
    //
    
    if (DerefConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

}


/***************************************************************************++

Routine Description:

    Initializes a filter write queue. This queue contains filter read IRPs
    queued on a connection. When there are no read buffers available, it
    can block writers, and then wake them up when there is space for them
    to write.

Arguments:

    pWriteQueue - the queue to initialize.

--***************************************************************************/
VOID
UlInitializeFilterWriteQueue(
    IN PUL_FILTER_WRITE_QUEUE pWriteQueue
    )
{
    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(pWriteQueue);

    //
    // Set up the queue.
    //
    
    pWriteQueue->Writers = 0;
    pWriteQueue->ReadIrps = 0;
    pWriteQueue->WriterActive = FALSE;

    InitializeListHead(&pWriteQueue->ReadIrpListHead);

    KeInitializeEvent(
        &pWriteQueue->ReadIrpAvailableEvent,
        SynchronizationEvent,
        FALSE
        );

    pWriteQueue->BlockedPartialWrite = 0;

    KeInitializeEvent(
        &pWriteQueue->PartialWriteEvent,
        SynchronizationEvent,
        FALSE
        );

}


/***************************************************************************++

Routine Description:

    Copies SSL info from the connection into a buffer supplied by the
    caller. Can also be called with a NULL buffer to get the required
    length. If the buffer is too small to hold all the data, none
    will be copied.

Arguments:

    pConnection - the connection to query
    BufferSize - size of pBuffer in bytes
    pUserBuffer - optional pointer to user mode buffer
    pBuffer - optional output buffer
    pBytesCopied - if pBuffer is non-NULL and the function returns
        success, pBytesCopied returns the number of bytes copied
        into the buffer. If pBuffer is NULL it returns the number
        of bytes required for all the information.

--***************************************************************************/
NTSTATUS
UlGetSslInfo(
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG BufferSize,
    IN PUCHAR pUserBuffer OPTIONAL,
    OUT PUCHAR pBuffer OPTIONAL,
    OUT PULONG pBytesCopied OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    PHTTP_SSL_INFO pSslInfo;
    PUCHAR pKeBuffer;

    ULONG IssuerSize;
    ULONG SubjectSize;
    ULONG ClientCertSize;
    ULONG ClientCertBytesCopied;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Initialize locals.
    //
    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesNeeded = 0;
    ClientCertBytesCopied = 0;

    //
    // Figure out how big the buffer is
    // including client cert if it's there.
    //

    IssuerSize = ALIGN_UP(
                        pConnection->SslInfo.ServerCertIssuerSize + sizeof(CHAR),
                        sizeof(PVOID)
                        );

    SubjectSize = ALIGN_UP(
                        pConnection->SslInfo.ServerCertSubjectSize + sizeof(CHAR),
                        sizeof(PVOID)
                        );

    if (pConnection->SslInfoPresent)
    {
        BytesNeeded += sizeof(HTTP_SSL_INFO);
        BytesNeeded += IssuerSize;
        BytesNeeded += SubjectSize;

        if (pConnection->SslClientCertPresent)
        {
            Status = UlpGetSslClientCert(
                            pConnection,    // pConnection
                            NULL,           // pProcess
                            0,              // BufferLength
                            NULL,           // pUserBuffer
                            NULL,           // pBuffer
                            &ClientCertSize // pClientCertBytesCopied
                            );

            if (NT_SUCCESS(Status))
            {
                BytesNeeded += ClientCertSize;
            }
            else
            {
                goto exit;
            }
        }
        else
        {
            ClientCertSize = 0;
        }
    }


    //
    // Construct the HTTP_SSL_INFO in the callers buffer.
    //

    if (pBuffer && BytesNeeded && (BufferSize >= BytesNeeded))
    {
        //
        // Buffer must be properly aligned
        //
        ASSERT( 0 == (((size_t)pBuffer) % sizeof(PVOID)) );

        //
        // Copy the easy stuff.
        //
        ASSERT(NT_SUCCESS(Status));

        RtlZeroMemory(pBuffer, BytesNeeded);

        pSslInfo = (PHTTP_SSL_INFO) pBuffer;

        pSslInfo->ServerCertKeySize =
            pConnection->SslInfo.ServerCertKeySize;

        pSslInfo->ConnectionKeySize =
            pConnection->SslInfo.ConnectionKeySize;
            
        pSslInfo->ServerCertIssuerSize = 
            pConnection->SslInfo.ServerCertIssuerSize;

        pSslInfo->ServerCertSubjectSize = 
            pConnection->SslInfo.ServerCertSubjectSize;

        BytesCopied += sizeof(HTTP_SSL_INFO);
        
        //
        // Copy the server cert issuer.
        //

        pKeBuffer = pBuffer + sizeof(HTTP_SSL_INFO);

        pSslInfo->pServerCertIssuer = FIXUP_PTR(
                                            PSTR,
                                            pUserBuffer,
                                            pBuffer,
                                            pKeBuffer,
                                            BufferSize
                                            );
        RtlCopyMemory(
            pKeBuffer,
            pConnection->SslInfo.pServerCertIssuer,
            pSslInfo->ServerCertIssuerSize
            );

        BytesCopied += IssuerSize;

        //
        // Copy the server cert subject.
        //

        pKeBuffer += IssuerSize;

        pSslInfo->pServerCertSubject = FIXUP_PTR(
                                            PSTR,
                                            pUserBuffer,
                                            pBuffer,
                                            pKeBuffer,
                                            BufferSize
                                            );
        RtlCopyMemory(
            pKeBuffer,
            pConnection->SslInfo.pServerCertSubject,
            pSslInfo->ServerCertSubjectSize
            );

        BytesCopied += SubjectSize;

        //
        // Copy client certificate info.
        //
        
        pKeBuffer += SubjectSize;
        
        if (pConnection->SslClientCertPresent)
        {            
            Status = UlpGetSslClientCert(
                            pConnection,                // pConnection
                            PsGetCurrentProcess(),      // pProcess
                            (BufferSize - BytesCopied), // BufferSize
                            FIXUP_PTR(                  // pUserBuffer
                                PUCHAR,
                                pUserBuffer,
                                pBuffer,
                                pKeBuffer,
                                (BufferSize - BytesCopied)
                                ),
                            pKeBuffer,                  // pBuffer
                            &ClientCertBytesCopied      // pBytesCopied
                            );

            if (NT_SUCCESS(Status))
            {
                BytesCopied += ClientCertBytesCopied;
            }
            else
            {
                goto exit;
            }
        }
    }

    //
    // Tell the caller either how many bytes were copied, or
    // how many will be copied when they give us a buffer.
    //
    ASSERT(NT_SUCCESS(Status));
    
    if (pBytesCopied)
    {
        if (pBuffer)
        {
            //
            // We actually copied the data.
            //
            ASSERT(BytesCopied == BytesNeeded);
            *pBytesCopied = BytesCopied;
        }
        else
        {
            //
            // Just tell the caller how bug the buffer has to be.
            //
            *pBytesCopied = BytesNeeded;
        }
    }

exit:

    if (!NT_SUCCESS(Status))
    {
        //
        // Right now the only way for this function to fail
        // is if we are unable to duplicate a token associated
        // with the client certificate. If there were another
        // way to fail after duping the token, we would have
        // to close the handle here.
        //
        ASSERT(ClientCertBytesCopied == 0);
    }

    return Status;
}


/******************************************************************************

Routine Description:

    Takes a handle to a filter channel and returns a referenced pointer
    to the filter channel object.

Arguments:

    FilterHandle - the handle

    ppFilterChannel - returns the filter object

******************************************************************************/
NTSTATUS
UlGetFilterFromHandle(
    IN HANDLE FilterHandle,
    OUT PUL_FILTER_CHANNEL * ppFilterChannel
    )
{
    NTSTATUS        Status;
    PFILE_OBJECT    pFileObject = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppFilterChannel != NULL);

    Status = ObReferenceObjectByHandle(
                    FilterHandle,
                    0,                          // DesiredAccess
                    *IoFileObjectType,          // ObjectType
                    UserMode,                   // AccessMode
                    (void**)&pFileObject,       // Object
                    NULL                        // HandleInformation
                    );

    if (NT_SUCCESS(Status))
    {
        //
        // We've got some sort of object. Make sure it's a filter channel.
        //
        if (IS_FILTER_PROCESS(pFileObject) &&
            IS_VALID_FILTER_PROCESS(GET_FILTER_PROCESS(pFileObject)))
        {
            PUL_FILTER_CHANNEL pChannel;
            
            //
            // Looks good. Return it.
            //
            pChannel = GET_FILTER_PROCESS(pFileObject)->pFilterChannel;
            ASSERT(IS_VALID_FILTER_CHANNEL(pChannel));

            REFERENCE_FILTER_CHANNEL(pChannel);
            *ppFilterChannel = pChannel;
        }
        else
        {
            //
            // Sorry, wrong number.
            //
            Status = STATUS_INVALID_HANDLE;
        }
    }

    //
    // Done with the file object.
    //
    if (pFileObject != NULL)
    {
        ObDereferenceObject( pFileObject );
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Returns a referenced pointer to the UX_FILTER_CONNECTION referred to by
    ConnectionId.

Arguments:

    ConnectionId - Supplies the connection ID to retrieve.

Return Value:

    PUX_FILTER_CONNECTION - Returns the UX_FILTER_CONNECTION if successful,
        NULL otherwise.

--***************************************************************************/
PUX_FILTER_CONNECTION
UlGetRawConnectionFromId(
    IN HTTP_RAW_CONNECTION_ID ConnectionId
    )
{
    PUX_FILTER_CONNECTION pConn;

    pConn = (PUX_FILTER_CONNECTION)UlGetObjectFromOpaqueId(
                                  ConnectionId,
                                  UlOpaqueIdTypeRawConnection,
                                  UxReferenceConnection
                                  );

    return pConn;
}

//
// Private functions.
//


PUL_FILTER_CHANNEL
UlpFindFilterChannel(
    IN PWCHAR pName,
    IN ULONG NameLength
    )
{
    PLIST_ENTRY pEntry;
    PUL_FILTER_CHANNEL pChannel;

    pChannel = NULL;
    pEntry = g_FilterListHead.Flink;

    while (pEntry != &g_FilterListHead)
    {
        pChannel = CONTAINING_RECORD(
                        pEntry,
                        UL_FILTER_CHANNEL,
                        ListEntry
                        );

        if (pChannel->NameLength == NameLength &&
            _wcsnicmp(pChannel->pName, pName, NameLength/sizeof(WCHAR)) == 0)
        {
            //
            // match!
            //
            break;
        }
        else
        {
            pChannel = NULL;
        }

        pEntry = pEntry->Flink;
    }

    return pChannel;
}

/***************************************************************************++

Routine Description:

    Allocates and initializes a UL_FILTER_CHANNEL object.

Arguments:

    pName - name of the filter channel
    NameLength - length of the name in bytes
    pAccessState - security crap

--***************************************************************************/
NTSTATUS
UlpCreateFilterChannel(
    IN PWCHAR pName,
    IN ULONG NameLength,
    IN PACCESS_STATE pAccessState,
    OUT PUL_FILTER_CHANNEL *ppFilterChannel
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_FILTER_CHANNEL pChannel = NULL;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(pName);
    ASSERT(NameLength);
    ASSERT(pAccessState);

    pChannel = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_FILTER_CHANNEL,
                    NameLength + sizeof(WCHAR),
                    UL_FILTER_CHANNEL_POOL_TAG
                    );

    if (pChannel)
    {
        //
        // Init the simple fields.
        //
        RtlZeroMemory(
            pChannel,
            NameLength + sizeof(WCHAR) +
                sizeof(UL_FILTER_CHANNEL)
            );
    
        pChannel->Signature = UL_FILTER_CHANNEL_POOL_TAG;
        pChannel->RefCount = 1;

        UlInitializeSpinLock(&pChannel->SpinLock, "FilterChannelSpinLock");
        InitializeListHead(&pChannel->ProcessListHead);
        InitializeListHead(&pChannel->ConnectionListHead);
        
        pChannel->NameLength = NameLength;
        RtlCopyMemory(
            pChannel->pName,
            pName,
            NameLength+sizeof(WCHAR)
            );

        //
        // Assign security.
        //
        Status = UlAssignSecurity(
                        &pChannel->pSecurityDescriptor,
                        pAccessState
                        );
                        
    }
    else
    {
        //
        // Could not allocate the channel object.
        //
        Status = STATUS_NO_MEMORY;
    }


    if (NT_SUCCESS(Status))
    {
        //
        // Return the object.
        //
        *ppFilterChannel = pChannel;
    }
    else if (pChannel)
    {
        UL_FREE_POOL_WITH_SIG(pChannel, UL_FILTER_CHANNEL_POOL_TAG);
    }
    
    return Status;
}

/***************************************************************************++

Routine Description:

    Allocates and initializes a UL_FILTER_PROCESS object.

Arguments:

    pChannel - the filter channel to which this object belongs

--***************************************************************************/
PUL_FILTER_PROCESS
UlpCreateFilterProcess(
    IN PUL_FILTER_CHANNEL pChannel
    )
{
    PUL_FILTER_PROCESS pProcess;
    
    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT( IS_VALID_FILTER_CHANNEL(pChannel) );

    pProcess = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    UL_FILTER_PROCESS,
                    UL_FILTER_PROCESS_POOL_TAG
                    );

    if (pProcess)
    {
        RtlZeroMemory(pProcess, sizeof(UL_FILTER_PROCESS));

        pProcess->Signature = UL_FILTER_PROCESS_POOL_TAG;
        pProcess->pFilterChannel = pChannel;
        pProcess->pProcess = PsGetCurrentProcess();

        InitializeListHead(&pProcess->ConnectionHead);
        InitializeListHead(&pProcess->IrpHead);
    }
    
    return pProcess;
}


/***************************************************************************++

Routine Description:

    Checks a filtered connection and the associated filter channel process
    to make sure they are in a reasonable state to do filter reads and writes.

Arguments:

    pFilterProcess - the process attempting an operation
    pConnection - the connection specified in the call

--***************************************************************************/
NTSTATUS
UlpValidateFilterCall(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( UlDbgSpinLockOwned(&pFilterProcess->pFilterChannel->SpinLock) );
    ASSERT( UlDbgSpinLockOwned(&pConnection->FilterConnLock) );

    //
    // Make sure we're not cleaning up the process or the connection.
    //
    if (pFilterProcess->InCleanup || 
        (pConnection->ConnState != UlFilterConnStateConnected))
    {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Make sure this process is supposed to be filtering this connection.
    //
    if (pConnection->pFilterChannel != pFilterProcess->pFilterChannel)
    {
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Called on a raw close completion. Just completes the IRP.

Arguments:

    pContext - pointer to the FilterClose IRP
    Status - Status from UlpCloseRawConnection
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterClose(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;

    //
    // Complete the IRP.
    //
    pIrp = (PIRP) pContext;
    
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;
    
    UlTrace(FILTER, (
        "ul!UlpRestartFilterClose read %d bytes from %p. Status = %x\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status
        ));

    UlCompleteRequest(pIrp, g_UlPriorityBoost);    

}


/***************************************************************************++

Routine Description:

    Called on a raw read completion. Just completes the IRP.

Arguments:

    pContext - pointer to the FilterRawRead IRP
    Status - Status from UlpReceiveRawData
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterRawRead(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;

    //
    // Complete the IRP.
    //
    pIrp = (PIRP) pContext;
    
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;
    
    UlTrace(FILTER, (
        "ul!UlpRestartFilterRawRead read %d bytes from %p. Status = %x\n"
        "        pIrp->UserEvent = %p\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status,
        pIrp->UserEvent
        ));

    UlCompleteRequest(pIrp, g_UlPriorityBoost);    

}


/***************************************************************************++

Routine Description:

    Called on a raw write completion. Just completes the IRP.

Arguments:

    pContext - pointer to the FilterRawWrite IRP
    Status - Status from UlpSendRawData
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterRawWrite(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;

    //
    // Complete the IRP.
    //
    pIrp = (PIRP) pContext;
    
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;
    
    UlTrace(FILTER, (
        "ul!UlpRestartFilterRawWrite sent %d bytes from %p. Status = %x\n"
        "        pIrp->UserEvent = %p\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status,
        pIrp->UserEvent
        ));

    UlCompleteRequest(pIrp, g_UlPriorityBoost);    

}


/***************************************************************************++

Routine Description:

    Called on a queued app write completion. Just completes the IRP.

Arguments:

    pContext - pointer to the FilterRawWrite IRP
    Status - Status from UlpSendRawData
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterAppWrite(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp = (PIRP) pContext;

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;

    UlCompleteRequest(pIrp, g_UlPriorityBoost);
}


/***************************************************************************++

Routine Description:

    cancels the pending user mode irp which was to accept a connection.
    this routine ALWAYS results in the irp being completed.

    note: we queue off to cancel in order to process the cancellation at lower
    irql.

    CODEWORK: do we still need to do this?

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelFilterAccept(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // queue the cancel to a worker to ensure passive irql.
    //

    UL_CALL_PASSIVE(
        UL_WORK_ITEM_FROM_IRP( pIrp ),
        &UlpCancelFilterAcceptWorker
        );

}

/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem - the work item to process.

--***************************************************************************/
VOID
UlpCancelFilterAcceptWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_FILTER_CHANNEL  pFilterChannel;
    PIRP                pIrp;
    KIRQL               oldIrql;

    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    ASSERT(pWorkItem != NULL);

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // grab the filter channel off the irp
    //

    pFilterChannel = (PUL_FILTER_CHANNEL)(
                        IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer
                        );

    ASSERT(IS_VALID_FILTER_CHANNEL(pFilterChannel));

    //
    // grab the lock protecting the queue
    //

    UlAcquireSpinLock(&pFilterChannel->SpinLock, &oldIrql);

    //
    // does it need to be de-queue'd ?
    //

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        //
        // remove it
        //

        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    //
    // let the lock go
    //

    UlReleaseSpinLock(&pFilterChannel->SpinLock, oldIrql);

    //
    // let our reference go
    //

    IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_FILTER_CHANNEL(pFilterChannel);

    //
    // complete the irp
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

}   // UlpCancelFilterAccept


/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to read from a raw
    connection.
    
    This routine ALWAYS results in the IRP being completed.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelFilterRawRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PUX_FILTER_CONNECTION pConnection;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Grab the connection off the IRP.
    //
    pConnection = (PUX_FILTER_CONNECTION)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Lock the list.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    //
    // Remove ourselves.
    //
    if (pIrp->Tail.Overlay.ListEntry.Flink)
    {
        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    //
    // Release the list.
    //
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Let go of our reference.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

}



/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to read from the
    application.
    
    This routine ALWAYS results in the IRP being completed.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelFilterAppRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PUX_FILTER_CONNECTION pConnection;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Grab the connection off the IRP.
    //
    pConnection = (PUX_FILTER_CONNECTION)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Lock the list.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    //
    // Remove ourselves.
    //
    if (pIrp->Tail.Overlay.ListEntry.Flink)
    {
        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

        //
        // Update IRP counter.
        //
        ASSERT( pConnection->AppToFiltQueue.ReadIrps > 0 );        
        pConnection->AppToFiltQueue.ReadIrps--;

        WRITE_FILTQ_TRACE_LOG(
            FILTQ_ACTION_DEQUEUE_IRP,
            pConnection,
            pIrp
            );        
    }


    //
    // Release the list.
    //
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Let go of our reference.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

}


/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to write to the
    application.
    
    This routine ALWAYS results in the IRP being completed.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelFilterAppWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;
    PUX_FILTER_CONNECTION pConnection;
    PUX_FILTER_WRITE_QUEUE pWriteQueue;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;
    
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Grab the write tracker off the IRP.
    //
    pTracker = (PUX_FILTER_WRITE_TRACKER)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));

    pWriteQueue = pTracker->pWriteQueue;
    ASSERT(pWriteQueue);

    pConnection = pTracker->pConnection;
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Lock the list on which we might be queued.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);
    
    if (pTracker->ListEntry.Flink)
    {
        //
        // Remove ourselves.
        //
        
        RemoveEntryList(&pTracker->ListEntry);
    }

    //
    // Release the list.
    //
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Let go of our reference to the connection.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    DEREFERENCE_FILTER_CONNECTION(pConnection);
    
    //
    // Complete through the normal path so the tracker gets cleaned up.
    //

    pTracker->BytesCopied = 0;

    UxpCompleteQueuedWrite(
        STATUS_CANCELLED,
        pWriteQueue,
        pTracker
        );

}

/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to read a client
    certificate from the connection.
    
    This routine ALWAYS results in the IRP being completed.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelReceiveClientCert(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PUX_FILTER_CONNECTION pConnection;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Grab the connection off the IRP.
    //
    pConnection = (PUX_FILTER_CONNECTION)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Lock the connection.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    //
    // Remove ourselves.
    //

    if (pConnection->pReceiveCertIrp)
    {
        ASSERT( pConnection->pReceiveCertIrp == pIrp );
        pConnection->pReceiveCertIrp = NULL;
    }
    
    //
    // Release the connection.
    //
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Let go of our reference.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

}

/***************************************************************************++

Routine Description:

    Delivers a new connection (and the first data on the connection) to
    a filter channel, which can now complete an accept IRP.

Arguments:

    pFilterChannel - the channel that gets the connection
    pConnection - the new connection object
    pBuffer - buffer containing initial data
    IndicatedLength - number of bytes in the buffer
    pTakenLength - number of bytes we copy into the buffer.

--***************************************************************************/
NTSTATUS
UlDeliverConnectionToFilter(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    )
{
    KIRQL oldIrql;
    PIRP pIrp;
    PUL_FILTER_PROCESS pProcess;
    PUL_FILTER_CHANNEL pFilterChannel;


    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    pFilterChannel = pConnection->pFilterChannel;
    ASSERT(IS_VALID_FILTER_CHANNEL(pFilterChannel));
    ASSERT(pBuffer);
    ASSERT(pTakenLength);
    
    UlTrace(FILTER, (
        "ul!UlDeliverConnectionToFilter(pConnection = %p)\n",
        pConnection
        ));

    ASSERT(pConnection->ConnectionDelivered == FALSE);
    pConnection->ConnectionDelivered = TRUE;

    UlAcquireSpinLock(&pFilterChannel->SpinLock, &oldIrql);
    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    //
    // See if we have a pending accept IRP.
    //
    pIrp = UlpPopAcceptIrp(pFilterChannel, &pProcess);

    if (pIrp)
    {
        ASSERT( IS_VALID_FILTER_PROCESS(pProcess) );
    
        //
        // Attach the connection to the process, copy the data,
        // and complete the IRP.
        //

        ASSERT(pConnection->ConnState == UlFilterConnStateInactive);
        pConnection->ConnState = UlFilterConnStateConnected;

        InsertTailList(
            &pProcess->ConnectionHead,
            &pConnection->ChannelEntry
            );

        REFERENCE_FILTER_CONNECTION(pConnection);

        //
        // Do the irp completion stuff outside the spin lock.
        //

    }
    else
    {
        //
        // No IRPs available. Queue the connection on the filter
        // channel.
        //
        InsertTailList(
            &pFilterChannel->ConnectionListHead,
            &pConnection->ChannelEntry
            );

        ASSERT(pConnection->ConnState == UlFilterConnStateInactive);
        pConnection->ConnState = UlFilterConnStateQueued;

        REFERENCE_FILTER_CONNECTION(pConnection);

        *pTakenLength = 0;
    }

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterChannel->SpinLock, oldIrql);

    //
    // Now that we're outside the spin lock, we can complete
    // the IRP if we have one.
    //
    if (pIrp)
    {
        UlpCompleteAcceptIrp(
            pIrp,
            pConnection,
            pBuffer,
            IndicatedLength,
            pTakenLength
            );

    }

    UlTrace(FILTER, (
        "ul!UlDeliverConnectionToFilter pConn = %p\n"
        "    consumed %d of %d bytes indicated\n",
        pConnection,
        *pTakenLength,
        IndicatedLength
        ));

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    A helper function for UlFilterAppWrite. This function takes care
    of the case where the data written is HTTP stream data to be passed
    to the app.

    If the app is not ready for the data this function will take care
    of queuing the write and will return STATUS_PENDING.

    Must be called with the FilterConnLock held.

Arguments:

    pConnection - the connection owning the data
    pIrp - the IRP that provides the data
    pDataBuffer - output buffer from the IRP
    DataBufferSize - size of pDataBuffer in bytes
    pTakenLength - number of bytes we copied to the app.

Return Values:

    An NTSTATUS. STATUS_PENDING indicates that the IRP was queued and will
    be completed later. Any other status means that the caller should go
    ahead and complete the IRP.
    
--***************************************************************************/
NTSTATUS
UlpFilterAppWriteStream(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp,
    IN PUCHAR pDataBuffer,
    IN ULONG DataBufferSize,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    ULONG TakenLength = 0;
    PUX_FILTER_WRITE_TRACKER pTracker;

    //
    // If this is a secure connection, we must
    // have received the SslInitInfo already or
    // we cannot accept the data.
    //
    if (pConnection->SecureConnection &&
        !pConnection->SslInfoPresent)
    {
        Status = STATUS_INVALID_DEVICE_STATE;
        TakenLength = 0;
        goto end;
    }

    //
    // Make sure the connection can take the data. In
    // the Filter -> App case we just check to see if
    // any writes have been queued.
    //

    if (pConnection->FiltToAppQueue.PendingWriteCount == 0)
    {

        //
        // Pass the data to the application.
        //
        
        Status = (pConnection->pDummyTdiReceiveHandler)(
                    NULL,
                    pConnection->pConnectionContext,
                    pDataBuffer,
                    DataBufferSize,
                    0,
                    &TakenLength
                    );

        UlTrace(FILTER, (
            "http!UlpFilterAppWriteStream app took %lu of %lu bytes,"
            " pConnection = %p\n",
            TakenLength,
            DataBufferSize,
            pConnection
            ));

        ASSERT(TakenLength <= DataBufferSize);
    }
    else
    {
        //
        // There are queued writes, which means that the app
        // is not ready for our data. We have to queue it.
        //

        Status = STATUS_SUCCESS;
        TakenLength = 0;
    }

    //
    // Queue the write if necessary.
    //

    if (NT_SUCCESS(Status) && (TakenLength < DataBufferSize))
    {
        //
        // Since the app did not accept all of the data from
        // this IRP we have to queue it.
        //

        //
        // Allocate a generic write tracker object to put on the
        // queue and save a pointer to the IRP in there.
        //

        pTracker = UxpCreateFilterWriteTracker(
                        pIrp->MdlAddress,               // pMdlChain
                        TakenLength,                    // MdlOffset
                        DataBufferSize,                 // Length of data
                        TakenLength,                    // BytesCopied so far
                        pIrp                            // pContext
                        );

        if (!pTracker)
        {
            //
            // Doh! We couldn't create the tracker. Return to the
            // caller so they can complete the IRP.
            //
            Status = STATUS_NO_MEMORY;
            goto end;
        }


        //
        // Now stick it on the queue.
        //

        Status = UxpQueueFilterWrite(
                        pConnection,
                        &pConnection->FiltToAppQueue,
                        pTracker
                        );

        if (NT_SUCCESS(Status))
        {
            //
            // return pending so the caller knows not to complete
            // the IRP.
            //
            Status = STATUS_PENDING;
        }
        else
        {
            //
            // Kill the tracker. The caller will take care of
            // completing the IRP with the status we return.
            //
            
            UxpDeleteFilterWriteTracker(pTracker);
        }
    }

end:
    ASSERT(pTakenLength);
    *pTakenLength = TakenLength;

    return Status;
}

/***************************************************************************++

Routine Description:

    Does the magic incantation to queue an IRP on the filter connection.
    
Arguments:

    pTracker - the tracker we're queueing

--***************************************************************************/
NTSTATUS
UlpEnqueueFilterAppWrite(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    NTSTATUS Status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    PUX_FILTER_CONNECTION pConnection = pTracker->pConnection;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pTracker->pContext);

    //
    // Get the IRP out of the tracker.
    //

    pIrp = (PIRP)pTracker->pContext;

    //
    // Save away a pointer to the tracker in the IRP so we can
    // clean up if the cancel routine runs.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pTracker;

    //
    // Set the Cancel routine.
    //
    IoSetCancelRoutine(pIrp, &UlpCancelFilterAppWrite);

    //
    // See if the IRP has been cancelled already.
    //
    if (pIrp->Cancel)
    {
        //
        // darn it, need to make sure the irp get's completed
        //

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // We are in charge of completion. IoCancelIrp didn't
            // see our cancel routine (and won't). UlFilterAppWrite
            // will complete it.
            //

            pIrp->IoStatus.Information = 0;

            UlUnmarkIrpPending( pIrp );
            Status = STATUS_CANCELLED;
            goto end;
        }

        //
        // Our cancel routine will run and complete the irp.
        // Don't touch it.
        //

        //
        // STATUS_PENDING will cause the caller to
        // not complete (or touch in any way) the IRP.
        //

        Status = STATUS_PENDING;
        goto end;
    }

    //
    // All ready to queue!
    //

    Status = STATUS_SUCCESS;

end:

    return Status;
}

/***************************************************************************++

Routine Description:

    Removes the cancel routine from an IRP so we can use it.

Arguments:

    pTracker - the queued write that contains our IRP

    pConnection - the connection from which the tracker was removed

--***************************************************************************/
NTSTATUS
UlpDequeueFilterAppWrite(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    PIRP pIrp;
    PUX_FILTER_WRITE_QUEUE pWriteQueue;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));
    ASSERT(pTracker->pContext);

    pIrp = (PIRP)pTracker->pContext;
    pWriteQueue = pTracker->pWriteQueue;

    //
    // In the FiltToApp case we are dequeuing an IRP, so
    // we have to do the cancel routine dance before we
    // try to use it.
    //

    pIrp = (PIRP)pTracker->pContext;
    
    //
    // pop the cancel routine
    //

    if (IoSetCancelRoutine(pIrp, NULL) == NULL)
    {
        //
        // IoCancelIrp pop'd it first
        //
        // ok to just ignore this irp, it's been pop'd off the queue
        // and will be completed in the cancel routine.
        //
        // keep looking for a irp to use
        //

        pIrp = NULL;

    }
    else if (pIrp->Cancel)
    {
        PUX_FILTER_WRITE_TRACKER pTrack;
        PUX_FILTER_CONNECTION pConn;

        //
        // we pop'd it first. but the irp is being cancelled
        // and our cancel routine will never run. lets be
        // nice and complete the irp now (vs. using it
        // then completing it - which would also be legal).
        //
        pTrack = (PUX_FILTER_WRITE_TRACKER)(
                                IoGetCurrentIrpStackLocation(pIrp)->
                                    Parameters.DeviceIoControl.Type3InputBuffer
                                );

        ASSERT(pTrack == pTracker);
        ASSERT(IS_VALID_FILTER_CONNECTION(pTracker->pConnection));

        IoGetCurrentIrpStackLocation(pIrp)->
            Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        //
        // Complete throught the normal path so the tracker can be
        // cleaned up.
        //

        pTracker->BytesCopied = 0;
        
        UxpCompleteQueuedWrite(
            STATUS_CANCELLED,
            pWriteQueue,
            pTracker
            );

        pIrp = NULL;
    }
    else
    {
        PUX_FILTER_WRITE_TRACKER pTrack;
        PUX_FILTER_CONNECTION pConn;

        //
        // we are free to use this irp !
        //

        pTrack = (PUX_FILTER_WRITE_TRACKER)(
                                IoGetCurrentIrpStackLocation(pIrp)->
                                    Parameters.DeviceIoControl.Type3InputBuffer
                                );

        ASSERT(pTrack == pTracker);
        ASSERT(pTrack->pWriteQueue == pWriteQueue);

        pConn = pTrack->pConnection;
        ASSERT(IS_VALID_FILTER_CONNECTION(pConn));

        IoGetCurrentIrpStackLocation(pIrp)->
            Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    }

    //
    // If we didn't NULL out pIrp, it's ok to use it.
    //
    
    return !!pIrp;
}

/***************************************************************************++

Routine Description:

    Captures SSL connection information passed down in a UlFilterAppWrite
    call with a UlFilterBufferSslInitInfo type.
    
Arguments:

    pHttpSslInfo - the data passed to us by the filter process
    HttpSslInfoSize - size of the passed data
    pUlSslInfo - this is where we store what we capture
    pTakenLength - gets the number of bytes we read

--***************************************************************************/
NTSTATUS
UlpCaptureSslInfo(
    IN PHTTP_SSL_INFO pHttpSslInfo,
    IN ULONG HttpSslInfoSize,
    OUT PUL_SSL_INFORMATION pUlSslInfo,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;

    //
    // Sanity check.
    //
    ASSERT(pHttpSslInfo);
    ASSERT(pUlSslInfo);
    ASSERT(pTakenLength);

    //
    // Initialize locals.
    //

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesNeeded = 0;

    //
    // See if it's ok to capture.
    //
    
    if (HttpSslInfoSize < sizeof(HTTP_SSL_INFO))
    {
        //
        // Buffer isn't big enough to pass the required data.
        //
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Grab the easy stuff and figure out how much buffer
    // is required.
    //
    pUlSslInfo->ServerCertKeySize = pHttpSslInfo->ServerCertKeySize;
    pUlSslInfo->ConnectionKeySize = pHttpSslInfo->ConnectionKeySize;
    pUlSslInfo->ServerCertIssuerSize = pHttpSslInfo->ServerCertIssuerSize;
    pUlSslInfo->ServerCertSubjectSize = pHttpSslInfo->ServerCertSubjectSize;

    BytesNeeded += ALIGN_UP(pHttpSslInfo->ServerCertIssuerSize, sizeof(PVOID));
    BytesNeeded += sizeof(CHAR);
    BytesNeeded += ALIGN_UP(pHttpSslInfo->ServerCertSubjectSize, sizeof(PVOID));
    BytesNeeded += sizeof(CHAR);

    BytesCopied += HttpSslInfoSize;

    //
    // Allocate a buffer for the server cert info.
    // It might be nice to allocate the whole info structure dynamically.
    //
    pUlSslInfo->pServerCertData = (PUCHAR) UL_ALLOCATE_POOL(
                                                NonPagedPool,
                                                BytesNeeded,
                                                UL_SSL_CERT_DATA_POOL_TAG
                                                );

    if (pUlSslInfo->pServerCertData == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }
    
    RtlZeroMemory(pUlSslInfo->pServerCertData, BytesNeeded);

    //
    // Capture the server cert info.
    //
    __try
    {
        PUCHAR pKeBuffer;
        ULONG len;

        //
        // Copy the Issuer.
        // BUGBUG: alignment?
        //
        pKeBuffer = pUlSslInfo->pServerCertData;
        len = pHttpSslInfo->ServerCertIssuerSize;
    
        RtlCopyMemory(
            pKeBuffer,
            pHttpSslInfo->pServerCertIssuer,
            pHttpSslInfo->ServerCertIssuerSize
            );

        BytesCopied += pHttpSslInfo->ServerCertIssuerSize;

        pKeBuffer[len] = '\0';
        pUlSslInfo->pServerCertIssuer = pKeBuffer;

        //
        // Copy the subject.
        //
        pKeBuffer += len + 1;
        len = pHttpSslInfo->ServerCertSubjectSize;

        RtlCopyMemory(
            pKeBuffer,
            pHttpSslInfo->pServerCertSubject,
            pHttpSslInfo->ServerCertSubjectSize
            );

        BytesCopied += pHttpSslInfo->ServerCertSubjectSize;
        pKeBuffer[len] = '\0';

        pUlSslInfo->pServerCertSubject = pKeBuffer;
        
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = GetExceptionCode();
    }

    //
    // capture client cert info
    //

    if (pHttpSslInfo->pClientCertInfo)
    {
        ULONG CertBytesCopied;
        
        Status = UlpCaptureSslClientCert(
                    FALSE,                          // BUGBUG CertMapped
                    pHttpSslInfo->pClientCertInfo,
                    sizeof(HTTP_SSL_CLIENT_CERT_INFO),// BUGBUG
                    pUlSslInfo,
                    &CertBytesCopied
                    );
                    
    }
    
end:
    if (!NT_SUCCESS(Status))
    {
        if (pUlSslInfo->pServerCertData)
        {
            UL_FREE_POOL(
                pUlSslInfo->pServerCertData,
                UL_SSL_CERT_DATA_POOL_TAG
                );

            pUlSslInfo->pServerCertData = NULL;
        }
    }

    //
    // Return the number of bytes read.
    //
    *pTakenLength = BytesCopied;

    return Status;
}


/***************************************************************************++

Routine Description:

    Captures SSL client certificate passed down in a UlFilterAppWrite
    call with a UlFilterBufferSslClientCert type.

Arguments:

    CertMapped - true if we have to capture a mapped token
    pCertInfo - the cert data to capture
    SslCertInfoSize - size of the buffer passed to us
    pUlSslInfo - this is where we stick the info we get
    pTakenLength - gets the number of bytes we read

--***************************************************************************/
NTSTATUS
UlpCaptureSslClientCert(
    IN BOOLEAN CertMapped,
    IN PHTTP_SSL_CLIENT_CERT_INFO pCertInfo,
    IN ULONG SslCertInfoSize,
    OUT PUL_SSL_INFORMATION pUlSslInfo,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    HANDLE MappedToken;

    //
    // Sanity check.
    //
    ASSERT(pUlSslInfo);
    ASSERT(pCertInfo);
    ASSERT(pTakenLength);

    //
    // Initialize locals.
    //

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesNeeded = 0;
    MappedToken = NULL;

    //
    // See if it's ok to capture.
    //
    
    if (SslCertInfoSize < sizeof(HTTP_SSL_CLIENT_CERT_INFO))
    {
        //
        // Buffer isn't big enough to pass the required data.
        //
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Grab the easy stuff and figure out how much buffer
    // is required.
    //
    pUlSslInfo->CertEncodedSize = pCertInfo->CertEncodedSize;
    pUlSslInfo->pCertEncoded = NULL;
    pUlSslInfo->CertFlags = pCertInfo->CertFlags;
    pUlSslInfo->CertDeniedByMapper = pCertInfo->CertDeniedByMapper;

    if (pCertInfo->Token)
    {
        //
        // Dup the token into the System process so that
        // we can dup it into the worker process later.
        //
        ASSERT(g_pUlSystemProcess);
    
        Status = UlpDuplicateHandle(
                        PsGetCurrentProcess(),          // SourceProcess
                        pCertInfo->Token,               // SourceHandle
                        (PEPROCESS)g_pUlSystemProcess,  // TargetProcess
                        &MappedToken,                   // TargetHandle
                        TOKEN_ALL_ACCESS,               // DesiredAccess
                        0,                              // HandleAttributes
                        0,                              // Options
                        KernelMode                      // PreviousMode
                        );
        
        if (NT_SUCCESS(Status))
        {
            //
            // Save it away.
            //
            
            pUlSslInfo->Token = MappedToken;
        }
        else
        {
            //
            // Couldn't map the token into the system process, bail out.
            //
            goto end;
        }
    }
          

    //
    // Now grab the encoded certificate.
    //
    
    BytesNeeded += ALIGN_UP(pCertInfo->CertEncodedSize, sizeof(PVOID));
    BytesNeeded += sizeof(CHAR);

    BytesCopied += SslCertInfoSize;

    if (pCertInfo->CertEncodedSize)
    {
        //
        // Allocate a buffer for the client cert info.
        // It might be nice to allocate the whole info structure dynamically.
        //
        pUlSslInfo->pCertEncoded = (PUCHAR) UL_ALLOCATE_POOL(
                                        NonPagedPool,
                                        BytesNeeded,
                                        UL_SSL_CERT_DATA_POOL_TAG
                                        );

        if (pUlSslInfo->pCertEncoded == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }
        
        RtlZeroMemory(pUlSslInfo->pCertEncoded, BytesNeeded);

        //
        // Capture the client cert info.
        //
        __try
        {
            PUCHAR pKeBuffer;

            //
            // Copy the Issuer.
            //
            pKeBuffer = (PUCHAR) pUlSslInfo->pCertEncoded;
        
            RtlCopyMemory(
                pKeBuffer,
                pCertInfo->pCertEncoded,
                pCertInfo->CertEncodedSize
                );

            BytesCopied += pCertInfo->CertEncodedSize;

            pKeBuffer[pCertInfo->CertEncodedSize] = '\0';
            
        }
        __except( UL_EXCEPTION_FILTER() )
        {
            Status = GetExceptionCode();
        }
    }
    else
    {
    
        //
        // The cert renegotiation must have failed so we remember
        // that we tried, but complete any requests for a cert
        // with an error status.
        //
        ASSERT(NT_SUCCESS(Status));

        pUlSslInfo->SslRenegotiationFailed = 1;
    }

    
end:
    if (!NT_SUCCESS(Status))
    {
        if (pUlSslInfo->pCertEncoded)
        {
            UL_FREE_POOL(
                pUlSslInfo->pCertEncoded,
                UL_SSL_CERT_DATA_POOL_TAG
                );

            pUlSslInfo->pCertEncoded = NULL;
        }

        if (MappedToken)
        {
            KeAttachProcess( g_pUlSystemProcess );
            
            ZwClose(MappedToken);
            
            KeDetachProcess();
        }
    }

    //
    // Return the number of bytes read.
    //
    *pTakenLength = BytesCopied;

    return Status;
}


/***************************************************************************++

Routine Description:

    Attaches captured SSL information to a connection.

    Called with the pConnection->FilterConnLock held. The connection is
    assumed to be in the connected state.

Arguments:

    pConnection - the connection that gets the info
    pSslInfo - the info to attach

--***************************************************************************/
NTSTATUS
UlpAddSslInfoToConnection(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_SSL_INFORMATION pSslInfo
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pSslInfo);
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));
    ASSERT(pConnection->ConnState == UlFilterConnStateConnected);

    //
    // See if it's ok to add the data.
    //
    
    if (!pConnection->SslInfoPresent)
    {
        //
        // Grab all the data. Note that we're taking ownership
        // of some buffers inside of the pSslInfo.
        //

        RtlCopyMemory(&pConnection->SslInfo, pSslInfo, sizeof(*pSslInfo));
        pConnection->SslInfoPresent = 1;
        
        Status = STATUS_SUCCESS;

    }
    else
    {
        //
        // There is already stuff here. Don't capture more.
        //
        Status = STATUS_OBJECT_NAME_COLLISION;
    }
       
    return Status;
}

/***************************************************************************++

Routine Description:

    Attaches captured SSL client cert information to a connection.

    Completes the ReceiveClientCert IRP if there is one.

    Called with the pConnection->FilterConnLock held.

Arguments:

    pConnection - the connection that gets the info
    pSslInfo - the info to attach

--***************************************************************************/
NTSTATUS
UlpAddSslClientCertToConnection(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_SSL_INFORMATION pSslInfo
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pSslInfo);
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));
    ASSERT(pConnection->ConnState == UlFilterConnStateConnected);

    //
    // See if it's ok to add the data.
    //
    
    if (!pConnection->SslClientCertPresent)
    {
        //
        // Grab all the data. Note that we're taking ownership
        // of some buffers inside of the pSslInfo.
        //

        pConnection->SslInfo.CertEncodedSize = pSslInfo->CertEncodedSize;
        pConnection->SslInfo.pCertEncoded = pSslInfo->pCertEncoded;
        pConnection->SslInfo.CertFlags = pSslInfo->CertFlags;
        pConnection->SslInfo.CertDeniedByMapper = pSslInfo->CertDeniedByMapper;
        pConnection->SslInfo.Token = pSslInfo->Token;
        pConnection->SslInfo.SslRenegotiationFailed = pSslInfo->SslRenegotiationFailed;
        
        pConnection->SslClientCertPresent = 1;
        
        Status = STATUS_SUCCESS;

    }
    else
    {
        //
        // There is already stuff here. Don't capture more.
        //
        Status = STATUS_OBJECT_NAME_COLLISION;
    }

    //
    // If we added successfully and there is a ReceiveClientCert
    // IRP, then we complete it.
    //

    if (NT_SUCCESS(Status) && pConnection->pReceiveCertIrp)
    {
        PIRP pIrp;
    
        if (IoSetCancelRoutine(pConnection->pReceiveCertIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // no need to complete it
            //            
        }
        else if (pConnection->pReceiveCertIrp->Cancel)
        {
            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run.
            //

            IoGetCurrentIrpStackLocation(
                pConnection->pReceiveCertIrp
                )->Parameters.DeviceIoControl.Type3InputBuffer = NULL;


            DEREFERENCE_FILTER_CONNECTION(pConnection);
    
            pConnection->pReceiveCertIrp->IoStatus.Status = STATUS_CANCELLED;
            pConnection->pReceiveCertIrp->IoStatus.Information = 0;

            pIrp = pConnection->pReceiveCertIrp;
            pConnection->pReceiveCertIrp = NULL;

            UlCompleteRequest(pIrp, g_UlPriorityBoost);
        }
        else
        {
            //
            // The IRP is all ours. Go ahead and use it.
            //

            pIrp = pConnection->pReceiveCertIrp;
            pConnection->pReceiveCertIrp = NULL;

            //
            // Queue off a work item to do it. We don't want
            // to do this stuff inside the spinlock we're
            // holding, because part of the completion may
            // duplicate a handle, which we should do at
            // passive level.
            //
            UL_CALL_PASSIVE(
                UL_WORK_ITEM_FROM_IRP( pIrp ),
                &UlpAddSslClientCertToConnectionWorker
                );


        }
    }
       
    return Status;
}

/***************************************************************************++

Routine Description:

    Completes the ReceiveClientCert IRP.

Arguments:

    pWorkItem - a work item embedded in the IRP

--***************************************************************************/
VOID
UlpAddSslClientCertToConnectionWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;
    PUX_FILTER_CONNECTION   pConnection;
    PEPROCESS               pProcess;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Pull out the filter connection.
    //
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnection = (PUX_FILTER_CONNECTION)
                        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                        
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    //
    // Pull out the original process.
    //

    pProcess = (PEPROCESS)pIrp->Tail.Overlay.DriverContext[3];
    ASSERT(pProcess);

    //
    // Do the completion stuff.
    //
    UlpCompleteReceiveClientCertIrp(
        pConnection,
        pProcess,
        pIrp
        );

    DEREFERENCE_FILTER_CONNECTION(pConnection);
}


/***************************************************************************++

Routine Description:

    Copies SSL client certinfo from the connection into a buffer supplied
    by the caller. Can also be called with a NULL buffer to get the
    required length. If the buffer is too small to hold all the data, none
    will be copied.

Arguments:

    pConnection - the connection to query
    pProcess - the process into which client cert tokens should be duped
    BufferSize - size of pBuffer in bytes
    pUserBuffer - optional pointer to user mode buffer
    pBuffer - optional output buffer
    pBytesCopied - if pBuffer is not NULL, pBytesCopied returns
                    the number of bytes copied into the output buffer.
                    Otherwise it returns the number of bytes
                    required in the buffer.

--***************************************************************************/
NTSTATUS
UlpGetSslClientCert(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PEPROCESS pProcess,
    IN ULONG BufferSize,
    IN PUCHAR pUserBuffer OPTIONAL,
    OUT PUCHAR pBuffer OPTIONAL,
    OUT PULONG pBytesCopied OPTIONAL
    )
{
    NTSTATUS Status;
    HANDLE MappedToken;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    ULONG CertBufferSize;
    PHTTP_SSL_CLIENT_CERT_INFO pCertInfo;
    PUCHAR pKeBuffer;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pConnection->SslClientCertPresent);
    ASSERT(!BufferSize || pBuffer);
    ASSERT(!BufferSize || pProcess);

    //
    // Initialize locals.
    //
    Status = STATUS_SUCCESS;
    MappedToken = NULL;
    BytesCopied = 0;
    BytesNeeded = 0;

    //
    // Figure out how much space is required for the cert.
    //

    CertBufferSize = pConnection->SslInfo.CertEncodedSize;

    BytesNeeded += sizeof(HTTP_SSL_CLIENT_CERT_INFO);
    BytesNeeded += CertBufferSize;

    //
    // Construct the HTTP_SSL_CLIENT_CERT_INFO in the callers buffer.
    //

    if (pBuffer)
    {
        ASSERT(BytesNeeded);

        //
        // Make sure there's enough buffer.
        //
        if (BufferSize < BytesNeeded)
        {
            Status = STATUS_BUFFER_OVERFLOW;
            goto exit;
        }

        if (pConnection->SslInfo.Token)
        {
            //
            // Try to dup the mapped token into the callers process.
            //
            ASSERT(g_pUlSystemProcess);
            
            Status = UlpDuplicateHandle(
                            (PEPROCESS)g_pUlSystemProcess,
                            pConnection->SslInfo.Token,
                            pProcess,
                            &MappedToken,
                            TOKEN_ALL_ACCESS,
                            0,
                            0,
                            KernelMode
                            );
    
            if (!NT_SUCCESS(Status))
            {
                goto exit;
            }
        }
        
        //
        // Copy the easy stuff.
        //

        RtlZeroMemory(pBuffer, BytesNeeded);
        
        pCertInfo = (PHTTP_SSL_CLIENT_CERT_INFO) pBuffer;

        pCertInfo->CertEncodedSize = pConnection->SslInfo.CertEncodedSize;
        pCertInfo->CertFlags = pConnection->SslInfo.CertFlags;
        pCertInfo->CertDeniedByMapper = pConnection->SslInfo.CertDeniedByMapper;
        pCertInfo->Token = MappedToken;
        
        BytesCopied += sizeof(HTTP_SSL_CLIENT_CERT_INFO);
        
        //
        // Copy the certificate.
        //

        pKeBuffer = pBuffer + sizeof(HTTP_SSL_CLIENT_CERT_INFO);

        pCertInfo->pCertEncoded = (PUCHAR) FIXUP_PTR(
                                        PSTR,
                                        pUserBuffer,
                                        pBuffer,
                                        pKeBuffer,
                                        BufferSize
                                        );
        RtlCopyMemory(
            pKeBuffer,
            pConnection->SslInfo.pCertEncoded,
            pCertInfo->CertEncodedSize
            );

        BytesCopied += CertBufferSize;

    }

    //
    // Tell the caller how many bytes we copied (or the number
    // that we would if they gave an output buffer).
    //
    ASSERT(NT_SUCCESS(Status));
    
    if (pBytesCopied)
    {
        if (pBuffer)
        {
            ASSERT(BytesCopied == BytesNeeded);
            *pBytesCopied = BytesCopied;
        }
        else
        {
            *pBytesCopied = BytesNeeded;
        }
    }

exit:
    if (!NT_SUCCESS(Status))
    {
        if (MappedToken)
        {
            ZwClose(MappedToken);
        }
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Looks through the list of filter processes attached to a filter channel
    for an available FilterAccept IRP.

Arguments:

    pFilterChannel - the filter channel to search
    ppFilterProcess - receives the process whose IRP we found

Return values:

    pointer to an Accept IRP, or NULL.
    
--***************************************************************************/
PIRP
UlpPopAcceptIrp(
    IN PUL_FILTER_CHANNEL pFilterChannel,
    OUT PUL_FILTER_PROCESS * ppFilterProcess
    )
{
    PIRP pIrp;
    PUL_FILTER_PROCESS pProcess;
    PLIST_ENTRY pEntry;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CHANNEL(pFilterChannel));
    ASSERT(UlDbgSpinLockOwned(&pFilterChannel->SpinLock));
    ASSERT(ppFilterProcess);

    pIrp = NULL;

    pEntry = pFilterChannel->ProcessListHead.Flink;
    while (pEntry != &pFilterChannel->ProcessListHead)
    {
        pProcess = CONTAINING_RECORD(
                        pEntry,
                        UL_FILTER_PROCESS,
                        ListEntry
                        );

        ASSERT(IS_VALID_FILTER_PROCESS(pProcess));

        pIrp = UlpPopAcceptIrpFromProcess(pProcess);

        if (pIrp)
        {
            *ppFilterProcess = pProcess;
            break;
        }
        
        pEntry = pEntry->Flink;
    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Gets a queued accept IRP from a UL_FILTER_PROCESS.

Arguments:

    pProcess - the process from which to pop an IRP

Return values:

    pointer to an IRP or NULL if none are available

--***************************************************************************/
PIRP
UlpPopAcceptIrpFromProcess(
    IN PUL_FILTER_PROCESS pProcess
    )
{
    PIRP pIrp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_PROCESS(pProcess));

    pIrp = NULL;

    while (!IsListEmpty(&(pProcess->IrpHead)))
    {
        PUL_FILTER_CHANNEL pFilterChannel;
        PLIST_ENTRY        pEntry;

        //
        // Found a free irp !
        //

        pEntry = RemoveHeadList(&pProcess->IrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(
                    pEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }
        else if (pIrp->Cancel)
        {

            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run. lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //
            pFilterChannel = (PUL_FILTER_CHANNEL)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pFilterChannel == pProcess->pFilterChannel);

            DEREFERENCE_FILTER_CHANNEL(pFilterChannel);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, g_UlPriorityBoost);

            pIrp = NULL;
        }
        else
        {

            //
            // we are free to use this irp !
            //

            pFilterChannel = (PUL_FILTER_CHANNEL)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pFilterChannel == pProcess->pFilterChannel);

            DEREFERENCE_FILTER_CHANNEL(pFilterChannel);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            break;
        }
    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Completes a filter accept IRP, and copies data to it (if there is any).
    Filter accept is METHOD_OUT_DIRECT.

Arguments:

    pIrp - the accept IRP we're completing
    pConnection - the connection to accept
    pBuffer - optional initial data
    IndicatedLength - length of initial data
    pTakenLength - receives amount of data copied

--***************************************************************************/
VOID
UlpCompleteAcceptIrp(
    IN PIRP pIrp,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer OPTIONAL,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength OPTIONAL
    )
{
    PIO_STACK_LOCATION pIrpSp;
    ULONG BytesNeeded;
    ULONG InitialLength;
    ULONG BytesCopied;
    ULONG OutputBufferLength;

    //
    // Sanity check.
    //
    ASSERT(pIrp);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    BytesCopied = 0;
    OutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // First, get the amount of bytes required to fill out a 
    // HTTP_RAW_CONNECTION_INFO structure. This is different for client 
    // & server.
    //

    BytesNeeded = (pConnection->pComputeRawConnectionLengthHandler)(
                        pConnection->pConnectionContext
                        );

    if (OutputBufferLength > BytesNeeded)
    {
        InitialLength = OutputBufferLength - BytesNeeded;
    }
    else
    {
        InitialLength = 0;
    }

    InitialLength = MIN(InitialLength, IndicatedLength);

    UlTrace(FILTER, (
        "ul!UlpCompleteAcceptIrp\n"
        "    OutputBufferLength = %d, BytesNeeded = %d, InitialLength = %d\n",
        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
        BytesNeeded,
        InitialLength
        ));

    if (BytesNeeded <= OutputBufferLength)
    {
        PUCHAR                      pKernelBuffer;
        PVOID                       pUserBuffer;
        
        //
        // Plenty of room. Copy in the info.
        //

        pKernelBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            NormalPagePriority
                            );

        if (!pKernelBuffer)
        {
            pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            pIrp->IoStatus.Information = 0;

            goto complete;
        }

        pUserBuffer = MmGetMdlVirtualAddress( pIrp->MdlAddress );
        ASSERT( pUserBuffer != NULL );

        //
        // Clean up the memory.
        //
        RtlZeroMemory(pKernelBuffer, BytesNeeded);

        BytesCopied = BytesNeeded;

        //
        // Get The local & remote addresss.
        //
        BytesCopied += (pConnection->pGenerateRawConnectionInfoHandler)(
            pConnection->pConnectionContext,
            pKernelBuffer,
            pUserBuffer,
            OutputBufferLength,
            (PUCHAR) pBuffer,
            InitialLength
            );

        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = BytesCopied;
    }
    else
    {
        //
        // Doh! There is not enough space.
        //
        pIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
        pIrp->IoStatus.Information = 0;
    }

complete:

    UlTrace(FILTER, (
        "ul!UlpCompleteAcceptIrp copied %d bytes to %p. Status = %x\n",
        BytesCopied,
        pIrp,
        pIrp->IoStatus.Status
        ));

    if (pTakenLength)
    {
        *pTakenLength = InitialLength;
    }

    UlCompleteRequest(pIrp, g_UlPriorityBoost);    
}


/***************************************************************************++

Routine Description:

    Becomes the active writer and completes AppRead IRPs that don't
    contain data beyond the buffer type.

    AppRead is METHOD_OUT_DIRECT.

Arguments:

    pConnection - the connection with queued AppRead IRPs
    BufferType - the buffer type to write in the IRP

--***************************************************************************/
NTSTATUS
UlpCompleteAppReadIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN HTTP_FILTER_BUFFER_TYPE BufferType
    )
{
    PIRP pIrp;
    PUCHAR pIrpBuffer;
    PHTTP_FILTER_BUFFER pHeader;
    NTSTATUS Status;
    KIRQL oldIrql;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Set up.
    //
    Status = STATUS_SUCCESS;

    //
    // Become the active writer.
    //
    UlpStartAppToFiltWriter(pConnection);

    //
    // Make sure we're still connected.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);
    
    if (pConnection->ConnState == UlFilterConnStateConnected)
    {
        //
        // We're good. Grab an IRP.
        //
    
        ASSERT(pConnection->AppToFiltQueue.ReadIrps > 0);
        pIrp = UlpPopFilterIrp(pConnection, &pConnection->AppToFiltQueue);

        ASSERT(pIrp);

    }
    else
    {
        //
        // We woke up because the connection was already
        // disconnected.
        //
        pIrp = NULL;
    }
        

    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);    

    if (!pIrp)
    {
        Status = STATUS_CONNECTION_DISCONNECTED;
        goto exit;
    }

    //
    // Get the output buffer from the IRP.
    //
    pIrpBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                        pIrp->MdlAddress,
                        NormalPagePriority
                        );

    if (!pIrpBuffer)
    {
        //
        // Insufficient resources to map the IRP buffer.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Initialize the buffer header.
    // Note: The Ioctl routine has already checked the output buffer size.
    //
    RtlZeroMemory(pIrpBuffer, sizeof(HTTP_FILTER_BUFFER));

    //
    // Fill in header information.
    //
    pHeader = (PHTTP_FILTER_BUFFER)pIrpBuffer;
    pHeader->BufferType = BufferType;

    pHeader->pBuffer = NULL;
    pHeader->BufferSize = 0;

    //
    // Complete the IRP.
    //
    UlTrace(FILTER, (
        "ul!UlpCompleteAppReadIrp completing %p with type %d buffer.\n",
        pIrp,
        BufferType
        ));
    
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = sizeof(HTTP_FILTER_BUFFER);
    
    UlCompleteRequest(pIrp, g_UlPriorityBoost);
    pIrp = NULL;

exit:
    UlpFinishAppToFiltWriter(pConnection);

    return Status;

}

/***************************************************************************++

Routine Description:

    Completes AppRead IRPs, copying as much data in to them as possible.
    This is only for UlFilterBufferHttpStream since the other types
    of buffers have no data.

    This routine assumes you have become the active writer with a call
    to UlpStartAppToFiltWriter.

    AppRead is METHOD_OUT_DIRECT.

Arguments:

    pConnection - the connection with queued AppRead IRPs
    pCopyTracker - structure containing the state of the copy

--***************************************************************************/
NTSTATUS
UlpCompleteAppReadIrpWithData(
    IN PUX_FILTER_CONNECTION pConnection,
    IN OUT PUL_MDL_CHAIN_COPY_TRACKER pCopyTracker
    )
{
    ULONG TotalBytesToCopy;
    ULONG BytesInMdl;
    ULONG BytesInIrp;
    ULONG BytesToCopy;
    PIRP pIrp;
    PUCHAR pIrpBuffer;
    ULONG IrpOffset;
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pCopyTracker);
    ASSERT(pCopyTracker->pMdl);
    ASSERT(pCopyTracker->Length);
    ASSERT(pCopyTracker->BytesCopied < pCopyTracker->Length);

    //
    // Set up.
    //
    Status = STATUS_SUCCESS;
    TotalBytesToCopy = pCopyTracker->Length - pCopyTracker->BytesCopied;
    pIrp = UlpPopFilterIrp(pConnection, &pConnection->AppToFiltQueue);

    if (!pIrp)
    {
        //
        // Although there should be an IRP available at this point,
        // a cancel could cause UlpPopFilterIrp to return NULL.
        //

        Status = STATUS_CANCELLED;
        goto exit;
    }

    //
    // Get the output buffer from the IRP.
    //
    pIrpBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                        pIrp->MdlAddress,
                        NormalPagePriority
                        );

    if (!pIrpBuffer)
    {
        //
        // Insufficient resources to map the IRP buffer.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Skip over the buffer header section.
    //
    RtlZeroMemory(pIrpBuffer, sizeof(HTTP_FILTER_BUFFER));
    IrpOffset = sizeof(HTTP_FILTER_BUFFER);

    //
    // Copy till you puke.
    //
    while (pIrp && TotalBytesToCopy)
    {
        PIO_STACK_LOCATION pIrpSp;
        PUCHAR pSrcBuffer;

        //
        // Figure out how much to copy.
        //
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        ASSERT(NULL != pIrpSp);

        BytesInIrp = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        BytesInIrp -= IrpOffset;

        ASSERT(NULL != pCopyTracker->pMdl);
        
        BytesInMdl = MmGetMdlByteCount(pCopyTracker->pMdl);
        BytesInMdl -= pCopyTracker->Offset;

        BytesToCopy = MIN(BytesInIrp, BytesInMdl);

        //
        // Do the copy.
        //
        pSrcBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                    pCopyTracker->pMdl,
                                    NormalPagePriority
                                    );
        ASSERT(NULL != pSrcBuffer);

        if (NULL == pSrcBuffer)
        {
            //
            // Insufficient resources to map the CopyTracker
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }

        RtlCopyMemory(
            pIrpBuffer + IrpOffset,
            pSrcBuffer + pCopyTracker->Offset,
            BytesToCopy
            );

        //
        // Update tracker.
        //
        pCopyTracker->BytesCopied += BytesToCopy;
        TotalBytesToCopy -= BytesToCopy;

        if (BytesInMdl == BytesToCopy)
        {
            //
            // Advance to next MDL. We've copied everything in this one.
            //
            pCopyTracker->pMdl = pCopyTracker->pMdl->Next;
            pCopyTracker->Offset = 0;
        }
        else
        {
            //
            // Move up offset to get the rest of the data.
            //
            pCopyTracker->Offset += BytesToCopy;
        }

        //
        // Update IRP info.
        //

        IrpOffset += BytesToCopy;

        if ((BytesInIrp == BytesToCopy) || (TotalBytesToCopy == 0))
        {
            PHTTP_FILTER_BUFFER pHeader;
            
            //
            // IRP is full, or we're out of data.
            // Fill in header information.
            //
            pHeader = (PHTTP_FILTER_BUFFER)pIrpBuffer;
            pHeader->BufferType = HttpFilterBufferHttpStream;

            pHeader->pBuffer =
                FIXUP_PTR(
                    PUCHAR,
                    MmGetMdlVirtualAddress(pIrp->MdlAddress),   // user addr
                    pHeader,                                    // kernel addr
                    pHeader + 1,                                // offset ptr
                    BytesInIrp                                  // buffer size
                    );
                   
            pHeader->BufferSize = IrpOffset - sizeof(HTTP_FILTER_BUFFER);

            //
            // Complete the IRP.
            //
            UlTrace(FILTER, (
                "ul!UlpCompleteAppReadIrpWithData completing %p with %d buffer bytes. "
                "Information = %d.\n",
                pIrp,
                pHeader->BufferSize,
                IrpOffset
                ));
            
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = IrpOffset;
            
            UlCompleteRequest(pIrp, g_UlPriorityBoost);
            pIrp = NULL;

            if (TotalBytesToCopy)
            {
                //
                // Need a new IRP for the rest of the data.
                //
                pIrp = UlpPopFilterIrp(
                            pConnection,
                            &pConnection->AppToFiltQueue
                            );
                IrpOffset = 0;
            }
        }
        
    }

exit:

    return Status;

}

/***************************************************************************++

Routine Description:

    Completes ReceiveClientCert IRPs.

    ReceiveClientCert is METHOD_OUT_DIRECT.

Arguments:

    pConnection - the connection with queued ReceiveClientCert IRPs
    pProcess - the original caller's process
    pIrp - the actual IRP to be completed

--***************************************************************************/
NTSTATUS
UlpCompleteReceiveClientCertIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PEPROCESS pProcess,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    PUCHAR pIrpBuffer;
    ULONG BytesInIrp;
    PIO_STACK_LOCATION pIrpSp;
    

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pIrp);
    ASSERT(pConnection->SslClientCertPresent);

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    BytesInIrp = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // This routine is always going to complete the IRP
    // and return pending, even if there is an error.
    // Make sure that the IRP is marked.
    //

    IoMarkIrpPending(pIrp);

    //
    // See if there's enough space.
    //

    Status = UlpGetSslClientCert(
                    pConnection,
                    NULL,           // pProcess
                    0,              // BufferSize
                    NULL,           // pUserBuffer
                    NULL,           // pBuffer
                    &BytesNeeded
                    );

    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }

    pIrpBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                        pIrp->MdlAddress,
                        NormalPagePriority
                        );

    if (!pIrpBuffer)
    {
        //
        // Insufficient resources to map the IRP buffer.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    
    if (!pConnection->SslInfo.SslRenegotiationFailed)
    {
        //
        // We have a real cert. Try to complete the IRP.
        //

        if (BytesInIrp >= BytesNeeded)
        {
            Status = UlpGetSslClientCert(
                            pConnection,
                            pProcess,
                            BytesInIrp,
                            (PUCHAR) MmGetMdlVirtualAddress(pIrp->MdlAddress),
                            pIrpBuffer,
                            &BytesCopied
                            );
                                
        }
        else
        {
            PHTTP_SSL_CLIENT_CERT_INFO pCertInfo;
            
            //
            // There's not enough room in the buffer for the cert.
            // Tell them how big it is. (The IOCTL wrapper ensures
            // that the buffer is at least as big as a
            // HTTP_SSL_CLIENT_CERT_INFO.
            //
            ASSERT(BytesInIrp >= sizeof(HTTP_SSL_CLIENT_CERT_INFO));

            
            pCertInfo = (PHTTP_SSL_CLIENT_CERT_INFO) pIrpBuffer;
            pCertInfo->CertEncodedSize = pConnection->SslInfo.CertEncodedSize;
            pCertInfo->pCertEncoded = NULL;
            pCertInfo->CertFlags = 0;
            pCertInfo->CertDeniedByMapper = FALSE;
            pCertInfo->Token = NULL;

            BytesCopied = sizeof(HTTP_SSL_CLIENT_CERT_INFO);
            Status = STATUS_BUFFER_OVERFLOW;    
        }
    }
    else
    {
        //
        // We tried and failed to renegotiate a certificate.
        // Return an error status.
        //
        
        Status = STATUS_NOT_FOUND;
        BytesCopied = 0;
    }

exit:
    //
    // Complete the IRP.
    //
    
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = BytesCopied;
    UlCompleteRequest(pIrp, g_UlPriorityBoost);

    return STATUS_PENDING;
}


/***************************************************************************++

Routine Description:

    Given pointers to two processes and a handle, this function duplicates
    the handle from one process into the other.

Arguments:

    SourceProcess - the process where the original handle lives
    SourceHandle - the handle to dup
    TargetProcess - the process to dup the handle to
    pTargetHandle - receives the duped handle
    DesiredAccess - desired access to the duped handle
    HandleAttributes - attributes for the handle (eg inheritable)
    Options - duplication options (e.g. close source)

--***************************************************************************/
NTSTATUS
UlpDuplicateHandle(
    IN PEPROCESS SourceProcess,
    IN HANDLE SourceHandle,
    IN PEPROCESS TargetProcess,
    OUT PHANDLE pTargetHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    NTSTATUS Status;
    HANDLE SourceProcessHandle;
    HANDLE TargetProcessHandle;

    //
    // Sanity check.
    //
    ASSERT(SourceProcess);
    ASSERT(SourceHandle);
    ASSERT(TargetProcess);
    ASSERT(pTargetHandle);

    //
    // Init locals.
    //

    SourceProcessHandle = NULL;
    TargetProcessHandle = NULL;

    //
    // Get handles for the processes.
    //
    Status = ObOpenObjectByPointer(
                    SourceProcess,
                    0,
                    NULL,
                    PROCESS_ALL_ACCESS,
                    *PsProcessType,
                    KernelMode,
                    &SourceProcessHandle
                    );

    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }

    Status = ObOpenObjectByPointer(
                    TargetProcess,
                    0,
                    NULL,
                    PROCESS_ALL_ACCESS,
                    *PsProcessType,
                    KernelMode,
                    &TargetProcessHandle
                    );

    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }

    //
    // Dup the handle.
    //
    Status = ZwDuplicateObject(
                    SourceProcessHandle,
                    SourceHandle,
                    TargetProcessHandle,
                    pTargetHandle,
                    DesiredAccess,
                    HandleAttributes,
                    Options
                    );

exit:
    //
    // Clean up the handles.
    //
    if (SourceProcessHandle)
    {
        ZwClose(SourceProcessHandle);
    }

    if (TargetProcessHandle)
    {
        ZwClose(TargetProcessHandle);
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Queues a raw read IRP on a UX_FILTER_CONNECTION.

    Caller must hold the FilterConnLock.

Arguments:

    pConnection - the connection on which to queue an IRP
    pIrp - the IRP to queue

--***************************************************************************/
NTSTATUS
UxpQueueRawReadIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));

    //
    // Queue the IRP.
    //

    IoMarkIrpPending(pIrp);

    //
    // Give the irp a pointer to the connection.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

    REFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Set to these to null just in case the cancel routine runs.
    //

    pIrp->Tail.Overlay.ListEntry.Flink = NULL;
    pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    IoSetCancelRoutine(pIrp, &UlpCancelFilterRawRead);

    //
    // cancelled?
    //

    if (pIrp->Cancel)
    {
        //
        // darn it, need to make sure the irp get's completed
        //

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // we are in charge of completion, IoCancelIrp didn't
            // see our cancel routine (and won't).  ioctl wrapper
            // will complete it
            //
            DEREFERENCE_FILTER_CONNECTION(pConnection);

            pIrp->IoStatus.Information = 0;

            UlUnmarkIrpPending( pIrp );
            Status = STATUS_CANCELLED;
            goto end;
        }

        //
        // our cancel routine will run and complete the irp,
        // don't touch it
        //

        //
        // STATUS_PENDING will cause the ioctl wrapper to
        // not complete (or touch in any way) the irp
        //

        Status = STATUS_PENDING;
        goto end;
    }

    //
    // now we are safe to queue it
    //

    InsertTailList(
        &pConnection->RawReadIrpHead,
        &pIrp->Tail.Overlay.ListEntry
        );

    Status = STATUS_PENDING;

end:
    return Status;
}

/***************************************************************************++

Routine Description:

    Gets a queued raw read IRP from a UX_FILTER_CONNECTION.

    Caller must hold the FilterConnLock.

Arguments:

    pConnection - the connection from which to pop an IRP

Return values:

    pointer to an IRP or NULL if none are available

--***************************************************************************/
PIRP
UxpDequeueRawReadIrp(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    PIRP pIrp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));

    pIrp = NULL;

    while (!IsListEmpty(&pConnection->RawReadIrpHead))
    {
        PUX_FILTER_CONNECTION     pConn;
        PLIST_ENTRY        pEntry;

        //
        // Found a free irp !
        //

        pEntry = RemoveHeadList(&pConnection->RawReadIrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(
                    pEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }
        else if (pIrp->Cancel)
        {

            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run. lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //
            pConn = (PUX_FILTER_CONNECTION)(
                        IoGetCurrentIrpStackLocation(pIrp)->
                            Parameters.DeviceIoControl.Type3InputBuffer
                        );

            ASSERT(pConn == pConnection);

            DEREFERENCE_FILTER_CONNECTION(pConnection);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, g_UlPriorityBoost);

            pIrp = NULL;
        }
        else
        {

            //
            // we are free to use this irp !
            //

            pConn = (PUX_FILTER_CONNECTION)(
                        IoGetCurrentIrpStackLocation(pIrp)->
                            Parameters.DeviceIoControl.Type3InputBuffer
                        );

            ASSERT(pConn == pConnection);

            DEREFERENCE_FILTER_CONNECTION(pConnection);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                
            break;
        }
    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Removes all the queued raw read irps from a connection an cancels them.

Arguments:

    pConnection - the connection to clean up

--***************************************************************************/
VOID
UxpCancelAllQueuedRawReads(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    PIRP pIrp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    while (pIrp = UxpDequeueRawReadIrp(pConnection))
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;

        UlCompleteRequest(pIrp, g_UlPriorityBoost);
    }
}

/***************************************************************************++

Routine Description:

    Sets the count of bytes that have been buffered for us by the
    transport. When this number is non-zero, TDI will not indicate data
    to us, so we have to read it with IRPs.

    This function will trigger IRP reads if we have raw reads around in
    our queue.

Arguments:

    pConnection - the connection with queued data
    TransportBytesNotTaken - number of bytes to add to the total

--***************************************************************************/
VOID
UxpSetBytesNotTaken(
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG TransportBytesNotTaken
    )
{
    KIRQL oldIrql;

    UlTrace(FILTER, (
        "http!UxpSetBytesNotTaken(pConnection = %p, TransportBytesNotTaken = %lu)\n",
        pConnection,
        TransportBytesNotTaken
        ));

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    if (TransportBytesNotTaken)
    {
        UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);
        ASSERT(pConnection->TransportBytesNotTaken == 0);

        pConnection->TransportBytesNotTaken = TransportBytesNotTaken;

        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

        UxpProcessRawReadQueue(pConnection);
    }
}


/***************************************************************************++

Routine Description:

    Completes RawRead IRPs, copying as much data in to them as possible.

    RawRead is METHOD_OUT_DIRECT.

Arguments:

    pConnection - the connection with queued AppRead IRPs
    pBuffer - the buffer containing the data
    IndicatedLength - amount of data in the buffer
    pTakenLength - receives the amount of data we consumed

--***************************************************************************/
NTSTATUS
UxpProcessIndicatedData(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    ULONG BytesCopied;
    ULONG BytesToCopy;
    ULONG BytesInIrp;
    PUCHAR pSrcBuffer;
    PUCHAR pIrpBuffer;

    KIRQL oldIrql;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(IndicatedLength);
    ASSERT(pTakenLength);

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    pSrcBuffer = (PUCHAR) pBuffer;

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);
    
    pIrp = UxpDequeueRawReadIrp(pConnection);
    
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    while (pIrp && (BytesCopied < IndicatedLength))
    {
        UlTrace(FILTER, (
            "http!UxpProcessIndicatedData(pConn = %p)\n"
            "        dequeued IRP = %p, size %lu",
            pConnection,
            pIrp,
            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.OutputBufferLength
            ));

        //
        // Copy some data.
        //
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        BytesInIrp = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        BytesToCopy = MIN(BytesInIrp, (IndicatedLength - BytesCopied));

        pIrpBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            NormalPagePriority
                            );

        if (pIrpBuffer)
        {
            RtlCopyMemory(
                pIrpBuffer,
                pSrcBuffer + BytesCopied,
                BytesToCopy
                );

            BytesCopied += BytesToCopy;
            ASSERT(BytesCopied <= IndicatedLength);
        }
        else
        {
            //
            // Insufficient resources to map the IRP buffer.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
            BytesToCopy = 0;
        }
        
        //
        // Complete the IRP.
        //
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = BytesToCopy;
        UlCompleteRequest(pIrp, g_UlPriorityBoost);

        pIrp = NULL;

        //
        // Get a new IRP if there's more to do.
        //
        if (NT_SUCCESS(Status) && (BytesCopied < IndicatedLength))
        {
            UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);
            
            pIrp = UxpDequeueRawReadIrp(pConnection);

            UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);
        }
    }

    //
    // Return amount of copied data.
    //
    *pTakenLength = BytesCopied;

    UlTrace(FILTER, (
        "ul!UxpProcessIndicatedData pConn = %p, Status = %x\n"
        "    consumed %d of %d bytes indicated\n",
        pConnection,
        Status,
        *pTakenLength,
        IndicatedLength
        ));


    return Status;
}

/***************************************************************************++

Routine Description:

    If there is data for this connection buffered in TDI, and we have
    available raw read IRPs, this function issues reads to TDI to retrieve
    that data.

Arguments:

    pConnection - the connection with queued data

--***************************************************************************/
VOID
UxpProcessRawReadQueue(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    KIRQL oldIrql;
    BOOLEAN IssueRead;
    
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    IssueRead = FALSE;
    pIrp = NULL;

    //
    // If there are bytes to read and no one is reading them already...
    //
    if ((pConnection->TransportBytesNotTaken > 0) &&
        !pConnection->TdiReadPending)
    {
        //
        // and we have an IRP...
        //
        pIrp = UxpDequeueRawReadIrp(pConnection);

        if (pIrp)
        {
            //
            // Remember that we've started a read.
            //
            pConnection->TdiReadPending = TRUE;
        
            //
            // Issue a read once we get out of the spinlock.
            //
            IssueRead = TRUE;
        }
    }
    
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    UlTrace(FILTER, (
        "http!UxpProcessRawReadQueue(pConnection = %p)\n"
        "        TransportBytesNotTaken = %lu, TdiReadPending = %d, IssueRead = %d\n",
        pConnection,
        pConnection->TransportBytesNotTaken,
        pConnection->TdiReadPending,
        IssueRead
        ));

    if (IssueRead)
    {
        //
        // Stick a reference to the connection in the IRP.
        // This reference will get passed from IRP to IRP as we process
        // the queue. It will be released when we are through issuing
        // reads to TDI.
        //
        REFERENCE_FILTER_CONNECTION(pConnection);
        
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

        //
        // Call TDI from the worker routine.
        //
         
        UL_QUEUE_WORK_ITEM(
            UL_WORK_ITEM_FROM_IRP( pIrp ),
            &UxpProcessRawReadQueueWorker
            );        
    }
}


/***************************************************************************++

Routine Description:

    Worker routine for UxpProcessRawReadQueue. Issues a read to TDI.

Arguments:

    pWorkItem - work item embedded in a raw read IRP.

--***************************************************************************/
VOID
UxpProcessRawReadQueueWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    ULONG BufferSize;
    PVOID pBuffer;

    PUX_FILTER_CONNECTION pConnection;

    PAGED_CODE();

    //
    // Get the IRP and the connection.
    //
    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));
               
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnection = (PUX_FILTER_CONNECTION)
                        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Map the buffer and figure out how big it is.
    //
    pBuffer = MmGetSystemAddressForMdlSafe(
                    pIrp->MdlAddress,
                    NormalPagePriority
                    );

    if (pBuffer)
    {
        BufferSize = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        //
        // Issue the read.
        //
        
        Status = (pConnection->pReceiveDataHandler)(
                        pConnection->pConnectionContext,
                        pBuffer,
                        BufferSize,
                        &UxpRestartProcessRawReadQueue,
                        pIrp
                        );
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    UlTrace(FILTER, (
        "UxpProcessRawReadQueueWorker(pConn = %p, pIrp = %p)\n"
        "        Status = %x, BufferSize = %lu\n",
        pConnection,
        pIrp,
        Status,
        BufferSize
        ));

    //
    // Clean up if it didn't work.
    //
    
    if (!NT_SUCCESS(Status))
    {
        //
        // Complete the IRP we dequeued.
        //
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;

        UlCompleteRequest(pIrp, g_UlPriorityBoost);

        //
        // Close the connection in case the failure was not
        // a network error.
        //
    
        (pConnection->pCloseConnectionHandler)(
                    pConnection->pConnectionContext,
                    TRUE,           // AbortiveDisconnect
                    NULL,           // pCompletionRoutine
                    NULL            // pCompletionContext
                    );

        //
        // Release the reference we added in UxpProcessRawReadQueue since
        // no more reads will be issued.
        //
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

}

/***************************************************************************++

Routine Description:

    Completion routine for UxpProcessRawReadQueue.

Arguments:

    pContext - a raw read IRP
    Status - completion status
    Information - bytes read

--***************************************************************************/
VOID
UxpRestartProcessRawReadQueue(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    KIRQL oldIrql;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    
    PUX_FILTER_CONNECTION pConnection;

    BOOLEAN IssueRead;

    //
    // Get the IRP and the connection out.
    //
    pIrp = (PIRP)pContext;
    ASSERT(IS_VALID_IRP(pIrp));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnection = (PUX_FILTER_CONNECTION)
                        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Complete the raw read IRP.
    //
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;
    
    UlCompleteRequest(pIrp, g_UlPriorityBoost);

    //
    // Set up for the next round if there is one.
    //
    IssueRead = FALSE;
    
    pIrp = NULL;
    pIrpSp = NULL;

    //
    // If we were successful, either start another read or stop
    // issuing more reads.
    //
    if (NT_SUCCESS(Status))
    {
        //
        // It worked! Update the accounting and see if there's more
        // reading to do.
        //
        UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

        if (Information >= pConnection->TransportBytesNotTaken)
        {
            //
            // The read got everything. TDI will start indications again
            // after we return.
            //
            
            pConnection->TransportBytesNotTaken = 0;
            pConnection->TdiReadPending = FALSE;
        }
        else
        {
            //
            // There are still more bytes to read.
            //
            
            pConnection->TransportBytesNotTaken -= (ULONG)Information;

            //
            // Grab a new IRP.
            //
            
            pIrp = UxpDequeueRawReadIrp(pConnection);

            if (pIrp)
            {
                //
                // Issue a read once we get out here.
                //
                IssueRead = TRUE;
            }
            else
            {
                //
                // We want to keep reading, but we don't have
                // an IRP so we have to stop for now.
                //

                pConnection->TdiReadPending = FALSE;
            }
           
        }

        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);
    }
    else
    {
        //
        // The connection must have died. Just let the normal cleanup
        // path happen by itself.
        //
    }

    if (IssueRead)
    {
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // Issue the read. Note that we're calling UlQueueWorkItem
        // instead of UlCallPassive because otherwise we might get
        // into a recursive loop that blows the stack.
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;
                
        UL_QUEUE_WORK_ITEM(
            UL_WORK_ITEM_FROM_IRP( pIrp ),
            &UxpProcessRawReadQueueWorker
            );
    }
    else
    {
        ASSERT(pIrp == NULL);
    
        //
        // Since we are not going to issue another read, we can
        // release the reference we added in UxpProcessRawReadQueue.
        //
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }
}


/***************************************************************************++

Routine Description:

    Queues an IRP on a UL_FILTER_WRITE_QUEUE in a connection. Once the IRP
    is queued, we update the queue state and notify writers if necessary.

Arguments:

    pIrp - the accept IRP we're queueing
    pCancelRoutine - cancel routine for the IRP
    pConnection - the connection on which to queue it
    pWriterQueue - the actual queue

--***************************************************************************/
NTSTATUS
UlpQueueFilterIrp(
    IN PIRP pIrp,
    IN PDRIVER_CANCEL pCancelRoutine,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_FILTER_WRITE_QUEUE pWriteQueue
    )
{
    PIO_STACK_LOCATION pIrpSp;
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(pIrp);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));
    ASSERT(pWriteQueue);

    //
    // Mark it pending.
    //

    IoMarkIrpPending(pIrp);

    //
    // Give the irp a pointer to the connection.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

    REFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Set to these to null just in case the cancel routine runs.
    //

    pIrp->Tail.Overlay.ListEntry.Flink = NULL;
    pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    //
    // Set the cancel routine.
    //
    IoSetCancelRoutine(pIrp, pCancelRoutine);

    //
    // cancelled?
    //

    if (pIrp->Cancel)
    {
        //
        // darn it, need to make sure the irp get's completed
        //

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // we are in charge of completion, IoCancelIrp didn't
            // see our cancel routine (and won't).  ioctl wrapper
            // will complete it
            //

            DEREFERENCE_FILTER_CONNECTION(pConnection);

            pIrp->IoStatus.Information = 0;

            UlUnmarkIrpPending( pIrp );
            Status = STATUS_CANCELLED;
            goto end;
        }

        //
        // our cancel routine will run and complete the irp,
        // don't touch it
        //

        //
        // STATUS_PENDING will cause the ioctl wrapper to
        // not complete (or touch in any way) the IRP.
        //

        Status = STATUS_PENDING;
        goto end;
    }

    //
    // now we are safe to queue it
    //

    InsertTailList(
        &pWriteQueue->ReadIrpListHead,
        &pIrp->Tail.Overlay.ListEntry
        );

    Status = STATUS_PENDING;

    //
    // Now that we've succesfully added the IRP, we adjust the state
    // and wake up writers.
    //
    pWriteQueue->ReadIrps++;

    WRITE_FILTQ_TRACE_LOG(
        FILTQ_ACTION_QUEUE_IRP,
        pConnection,
        pIrp
        );

    
    if (pWriteQueue->ReadIrps == 1)
    {
        //
        // The IRP we just added is the only one on the list.
        // If there are any blocked writers, we should wake
        // one of them up. 
        //

        if (pWriteQueue->BlockedPartialWrite)
        {
            //
            // There's a partially completed writer. Wake
            // him up.
            //

            WRITE_FILTQ_TRACE_LOG(
                FILTQ_ACTION_WAKE_PARTIAL_WRITE,
                pConnection,
                pIrp
                );

            pWriteQueue->BlockedPartialWrite = FALSE;
            KeSetEvent(&pWriteQueue->PartialWriteEvent, 0, FALSE);
        }
        else if (!pWriteQueue->WriterActive && pWriteQueue->Writers > 0)
        {
            //
            // There are some writes waiting to go.
            //
            
            WRITE_FILTQ_TRACE_LOG(
                FILTQ_ACTION_WAKE_WRITE,
                pConnection,
                pIrp
                );

            //
            // Whoever we wake up is going to be the active writer.
            //
            pWriteQueue->WriterActive = TRUE;
                
            KeSetEvent(&pWriteQueue->ReadIrpAvailableEvent, 0, FALSE);
        }
    }

end:
    return Status;

}


/***************************************************************************++

Routine Description:

    Pops an IRP from a UL_FILTER_WRITE_QUEUE in a connection. Once the IRP
    is removed, we update the queue state.

Arguments:

    pConnection - the connection on which to queue it
    pWriterQueue - the actual queue

Return Values:

    Pointer to a useable IRP, or NULL if none are found.
--***************************************************************************/
PIRP
UlpPopFilterIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_FILTER_WRITE_QUEUE pWriteQueue
    )
{
    PIRP pIrp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));
    ASSERT(pWriteQueue);

    pIrp = NULL;

    while (!pIrp && pWriteQueue->ReadIrps)
    {
        PLIST_ENTRY        pEntry;

        ASSERT(!IsListEmpty(&pWriteQueue->ReadIrpListHead));

        //
        // Grab an IRP off the list.
        //

        pEntry = RemoveHeadList(&pWriteQueue->ReadIrpListHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(
                    pEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        //
        // Update IRP counter.
        //
        pWriteQueue->ReadIrps--;

        WRITE_FILTQ_TRACE_LOG(
            FILTQ_ACTION_DEQUEUE_IRP,
            pConnection,
            pIrp
            );

        //
        // See if we can use the IRP.
        //
        
        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }
        else if (pIrp->Cancel)
        {
            PUX_FILTER_CONNECTION pConn;

            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run. lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //
            pConn = (PUX_FILTER_CONNECTION)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pConn == pConnection);

            DEREFERENCE_FILTER_CONNECTION(pConnection);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, g_UlPriorityBoost);

            pIrp = NULL;
        }
        else
        {
            PUX_FILTER_CONNECTION pConn;

            //
            // we are free to use this irp !
            //

            pConn = (PUX_FILTER_CONNECTION)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pConn == pConnection);

            DEREFERENCE_FILTER_CONNECTION(pConnection);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        }
    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Waits until it is ok for the caller to start grabbing
    AppRead IRPs off the connection and complete them with data that
    it wants to write.

Arguments:

    pConnection - the connection on which the write occurs

--***************************************************************************/
VOID
UlpStartAppToFiltWriter(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    KIRQL oldIrql;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Wait until we're the active writer.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    pConnection->AppToFiltQueue.Writers++;

    WRITE_FILTQ_TRACE_LOG(
        FILTQ_ACTION_START_WRITE,
        pConnection,
        NULL
        );


    if ((pConnection->AppToFiltQueue.Writers > 1) ||
        (pConnection->AppToFiltQueue.ReadIrps == 0))
    {
        //
        // Someone else is ahead of us, or there
        // are no buffers available. Wait.
        //

        WRITE_FILTQ_TRACE_LOG(
            FILTQ_ACTION_BLOCK_WRITE,
            pConnection,
            NULL
            );

        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

        UlTrace(FILTER, (
            "UlpStartAppToFiltWriter(pConn = %p) waiting: Writers = %d, ReadIrps = %d\n",
            pConnection,
            pConnection->AppToFiltQueue.Writers,
            pConnection->AppToFiltQueue.ReadIrps
            ));
                
        KeWaitForSingleObject(
            (PVOID)&pConnection->AppToFiltQueue.ReadIrpAvailableEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
    }
    else
    {
        //
        // No one else is writing. We're ready to go.
        //

        pConnection->AppToFiltQueue.WriterActive = TRUE;
        
        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);
    }

}


/***************************************************************************++

Routine Description:

    Decrements the count of writers, and if necessary wakes up callers
    to UlpStartAppToFiltWriter.

Arguments:

    pConnection - the connection on which the write occurs

--***************************************************************************/
VOID
UlpFinishAppToFiltWriter(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    KIRQL oldIrql;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Wait until we're the active writer.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    ASSERT(pConnection->AppToFiltQueue.Writers > 0);

    pConnection->AppToFiltQueue.Writers--;

    WRITE_FILTQ_TRACE_LOG(
        FILTQ_ACTION_FINISH_WRITE,
        pConnection,
        NULL
        );

    if ((pConnection->AppToFiltQueue.Writers > 1) &&
        (pConnection->AppToFiltQueue.ReadIrps > 0))
    {
        ASSERT( pConnection->AppToFiltQueue.WriterActive );
    
        //
        // There are other writers waiting, and there are
        // IRPs available. Wake up a writer.
        //
        WRITE_FILTQ_TRACE_LOG(
            FILTQ_ACTION_WAKE_WRITE,
            pConnection,
            NULL
            );
            
        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

        UlTrace(FILTER, (
            "UlpFinishAppToFiltWriter(pConn = %p) wake writer: Writers = %d, ReadIrps = %d\n",
            pConnection,
            pConnection->AppToFiltQueue.Writers,
            pConnection->AppToFiltQueue.ReadIrps
            ));
        
        KeSetEvent(
            &pConnection->AppToFiltQueue.ReadIrpAvailableEvent,
            0,
            FALSE
            );
    }
    else
    {
        //
        // There are either no IRPs or no writers, so there
        // is no active writer.
        //

        ASSERT( pConnection->AppToFiltQueue.WriterActive ||
                pConnection->ConnState != UlFilterConnStateConnected );        
        
        pConnection->AppToFiltQueue.WriterActive = FALSE;
    
        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);
    }

}


/***************************************************************************++

Routine Description:

    Increments the reference count on the specified connection.

Arguments:

    pConnection - Supplies the connection to reference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

--***************************************************************************/
VOID
UxReferenceConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUX_FILTER_CONNECTION pConnection = (PUX_FILTER_CONNECTION) pObject;

    ASSERT( IS_VALID_FILTER_CONNECTION( pConnection ) );
    //
    // This filter connection object is owned by either the client or the
    // server connection objects. We have to propogate the ref to the right
    // context
    //

    REFERENCE_FILTER_CONNECTION(pConnection);

}

/***************************************************************************++

Routine Description:

    Initializes the UX_FILTER_CONNECTION structure

Arguments:

    pConnection            - Pointer to UX_FILTER_CONNECTION
    Secure                 - Secure connection
    pfnReferenceFunction   - Pointer to parent ReferenceFunction
                             (e.g. UlReferenceConnection)
    pfnDereferenceFunction - Pointer to parent DereferenceFunction
                             (e.g. UlDereferenceConnection)
    pfnConnectionClose     - Pointer to connection close handler

    pfnSendRawData         - Pointer to raw data send handler (UlpSendRawData)
    pfnReceiveData         - Pointer to data receive handler (UlpReceiveRawData)
    pfnDataReceiveHandler  - Pointer to client's data receive handler 
                             (UlHttpReceive)
    pListenContext         - Pointer to endpoint context
    pConnectionContext     - Pointer to parent context (e.g. UL_CONNECTION)
    pAddressBuffer         - Address Buffer

--***************************************************************************/

NTSTATUS
UxInitializeFilterConnection(
    IN PUX_FILTER_CONNECTION                    pConnection,
    IN PUL_FILTER_CHANNEL                       pFilterChannel,
    IN BOOLEAN                                  Secure,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE           pfnReferenceFunction,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE           pfnDereferenceFunction,
    IN PUX_FILTER_CLOSE_CONNECTION              pfnConnectionClose,
    IN PUX_FILTER_SEND_RAW_DATA                 pfnSendRawData,
    IN PUX_FILTER_RECEIVE_RAW_DATA              pfnReceiveData,
    IN PUL_DATA_RECEIVE                         pfnDummyTdiReceiveHandler,
    IN PUX_FILTER_COMPUTE_RAW_CONNECTION_LENGTH pfnRawConnLength,
    IN PUX_FILTER_GENERATE_RAW_CONNECTION_INFO  pfnGenerateRawConnInfo,
    IN PUX_FILTER_SERVER_CERT_INDICATE          pfnServerCertIndicate,
    IN PVOID                                    pListenContext,
    IN PVOID                                    pConnectionContext
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    pConnection->Signature               = UX_FILTER_CONNECTION_SIGNATURE;

    HTTP_SET_NULL_ID(&pConnection->ConnectionId);

    pConnection->pFilterChannel                     = pFilterChannel;
    pConnection->SecureConnection                   = Secure;
    pConnection->ChannelEntry.Flink                 = NULL;
    pConnection->ChannelEntry.Blink                 = NULL;
    pConnection->pReferenceHandler                  = pfnReferenceFunction;
    pConnection->pDereferenceHandler                = pfnDereferenceFunction;
    pConnection->pCloseConnectionHandler            = pfnConnectionClose;
    pConnection->pSendRawDataHandler                = pfnSendRawData;
    pConnection->pReceiveDataHandler                = pfnReceiveData;
    pConnection->pDummyTdiReceiveHandler            = pfnDummyTdiReceiveHandler;
    pConnection->pComputeRawConnectionLengthHandler = pfnRawConnLength;
    pConnection->pGenerateRawConnectionInfoHandler  = pfnGenerateRawConnInfo;
    pConnection->pServerCertIndicateHandler         = pfnServerCertIndicate;

    pConnection->ConnState               = UlFilterConnStateInactive;
    pConnection->TransportBytesNotTaken  = 0;
    pConnection->TdiReadPending          = FALSE;
    pConnection->ConnectionDelivered     = 0;
    pConnection->SslInfoPresent          = 0;
    pConnection->SslClientCertRequested  = 0;
    pConnection->SslClientCertPresent    = 0;
    pConnection->pReceiveCertIrp         = NULL;

    //
    // Store the context's
    //
    pConnection->pConnectionContext      = pConnectionContext;


    InitializeListHead(&pConnection->RawReadIrpHead);
    UlInitializeSpinLock(&pConnection->FilterConnLock, "FilterConnLock");
    UlInitializeFilterWriteQueue(&pConnection->AppToFiltQueue);
    UxpInitializeFilterWriteQueue(
        &pConnection->FiltToAppQueue,
        UlpEnqueueFilterAppWrite,
        UlpDequeueFilterAppWrite,
        UlpRestartFilterAppWrite
        );

    RtlZeroMemory(&pConnection->SslInfo, sizeof(UL_SSL_INFORMATION));

    if(pConnection->pFilterChannel)
    {
        //
        // Get an opaque ID for the connection.
        //

        status = UlAllocateOpaqueId(
                        &pConnection->ConnectionId,
                        UlOpaqueIdTypeRawConnection,
                        pConnection);

        if(NT_SUCCESS(status))
        {
            REFERENCE_FILTER_CONNECTION(pConnection);
        }
    }

    return status;
}


/***************************************************************************++

Routine Description:

    Initializes a filter write queue. This is a producer/consumer queue
    for moving data between the filter and app.

Arguments:

    pWriteQueue - the queue to initialize.

    pWriteCompletionRoutine - this routine is called whenever a queued write
        completes.

--***************************************************************************/
VOID
UxpInitializeFilterWriteQueue(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_ENQUEUE pWriteEnqueueRoutine,
    IN PUX_FILTER_WRITE_DEQUEUE pWriteDequeueRoutine,
    IN PUX_FILTER_WRITE_QUEUE_COMPLETION pWriteCompletionRoutine
    )
{
    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(pWriteQueue);

    //
    // Set up the queue.
    //
    
    pWriteQueue->PendingWriteCount = 0;
    pWriteQueue->PendingReadCount = 0;

    InitializeListHead(&pWriteQueue->WriteTrackerListHead);
    InitializeListHead(&pWriteQueue->ReadIrpListHead);

    pWriteQueue->pWriteEnqueueRoutine = pWriteEnqueueRoutine;
    pWriteQueue->pWriteDequeueRoutine = pWriteDequeueRoutine;
    pWriteQueue->pWriteCompletionRoutine = pWriteCompletionRoutine;
}


/***************************************************************************++

Routine Description:

    Queues a filter write. As new read IRPs arrive data from the write will
    be placed in the read buffers. When all the data is copied (or an error
    occurs) then the write will be completed.

    Must be called with the FilterConnLock held.

Arguments:

    pConnection - the connection on which were queueing

    pWriteQueue - the queue to put the write on
    
    pTracker - the write tracker to queue

--***************************************************************************/
NTSTATUS
UxpQueueFilterWrite(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(pConnection);
    ASSERT(pWriteQueue);
    ASSERT(pTracker);

    //
    // Store a pointer to the write queue in the tracker.
    // Also store a pointer to the connection.
    // If the queued write contains an IRP, and the write
    // gets cancelled, it will need these pointers to
    // complete the write.
    //
    // We need a reference on the filter connection to keep
    // it around. We'll release the ref when the write is
    // completed.
    //

    REFERENCE_FILTER_CONNECTION(pConnection);
    
    pTracker->pConnection = pConnection;
    pTracker->pWriteQueue = pWriteQueue;

    //
    // If the write queue has an enqueue routine, call
    // it now.
    //

    if (pWriteQueue->pWriteEnqueueRoutine)
    {
        Status = (pWriteQueue->pWriteEnqueueRoutine)(
                        pTracker
                        );
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Put the tracker in the queue.
        //

        InsertTailList(
            &pWriteQueue->WriteTrackerListHead,
            &pTracker->ListEntry
            );

        pWriteQueue->PendingWriteCount++;
    }
    else
    {
        //
        // If the write was not queued successfully, then
        // the completion won't run. Any tracker cleanup
        // that would have happened there must happen now.
        //

        //
        // Release our reference to the connection acquired
        // above.
        //
        
        DEREFERENCE_FILTER_CONNECTION(pTracker->pConnection);

        pTracker->pConnection = NULL;
        pTracker->pWriteQueue = NULL;
    }

    UlTrace(FILTER, (
        "http!UxpQueueFilterWrite status = %x, pTracker = %p, pContext = %p\n",
        Status,
        pTracker,
        pTracker->pContext
        ));


    return Status;
}

/***************************************************************************++

Routine Description:

    Requeues a filter write. We do this when we dequeue a write, but cannot
    copy all the data into the receiver's buffer. Since this write's buffers
    should be copied next, we insert at the head of the list.
    
    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the queue to put the write on

    pTracker - the write to requeue

--***************************************************************************/
NTSTATUS
UxpRequeueFilterWrite(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(pWriteQueue);
    ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));
    ASSERT(pTracker->pWriteQueue == pWriteQueue);

    //
    // If the write queue has an enqueue routine, call
    // it now.
    //

    if (pWriteQueue->pWriteEnqueueRoutine)
    {
        Status = (pWriteQueue->pWriteEnqueueRoutine)(
                        pTracker
                        );
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        InsertHeadList(
            &pWriteQueue->WriteTrackerListHead,
            &pTracker->ListEntry
            );

        pWriteQueue->PendingWriteCount++;
    }

    UlTrace(FILTER, (
        "http!UxpRequeueFilterWrite status = %x, pTracker = %p, pContext = %p\n",
        Status,
        pTracker,
        pTracker->pContext
        ));

    return Status;
}

/***************************************************************************++

Routine Description:

    Removes a queued write from the head of the list.
    
    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the queue to put the write on

Return Values:

    Returns the first queued write in the list or NULL of the queue is empty.

--***************************************************************************/
PUX_FILTER_WRITE_TRACKER
UxpDequeueFilterWrite(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    )
{
    PLIST_ENTRY pListEntry;
    PUX_FILTER_WRITE_TRACKER pTracker;
    NTSTATUS Status;

    //
    // Sanity check.
    //
    
    ASSERT(pWriteQueue);

    pTracker = NULL;

    //
    // Grab the first write off the queue.
    //

    while (!IsListEmpty(&pWriteQueue->WriteTrackerListHead))
    {
        //
        // Grab a tracker.
        //
        
        pListEntry = RemoveHeadList(&pWriteQueue->WriteTrackerListHead);

        pListEntry->Flink = NULL;
        pListEntry->Blink = NULL;
        
        pTracker = CONTAINING_RECORD(
                        pListEntry,
                        UX_FILTER_WRITE_TRACKER,
                        ListEntry
                        );

        ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));

        ASSERT(pWriteQueue->PendingWriteCount > 0);
        pWriteQueue->PendingWriteCount--;

        //
        // See if we're allowed to use the tracker.
        //

        if (pWriteQueue->pWriteDequeueRoutine)
        {
            Status = (pWriteQueue->pWriteDequeueRoutine)(
                            pTracker
                            );
                            
        }
        else
        {
            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(Status))
        {
            //
            // We got one.
            //
            
            UlTrace(FILTER, (
                "http!UxpDeueueFilterWrite pTracker = %p, pContext = %p\n",
                pTracker,
                pTracker->pContext
                ));
                
            break;
        }
        else
        {
            pTracker = NULL;
        }
    }


    return pTracker;
}


/***************************************************************************++

Routine Description:

    Copies data from a filter write queue into a memory buffer. As the
    queued writes are used up, this routine will complete them.

    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the queue from which to get the data

    pBuffer - the buffer where we write the data

    BufferLength - length of pBuffer in bytes

    pBytesCopied - returns the number of bytes copied

--***************************************************************************/
NTSTATUS
UxpCopyQueuedWriteData(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    OUT PBYTE pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pBytesCopied
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;
    ULONG BytesCopied;
    NTSTATUS Status;

    PBYTE pMdlBuffer;
    ULONG BytesInMdl;
    ULONG BytesInBuffer;
    ULONG BytesToCopy;

    //
    // Sanity check.
    //
    
    ASSERT(pWriteQueue);
    ASSERT(pBuffer);
    ASSERT(BufferLength);
    ASSERT(pBytesCopied);

    //
    // Copy 'till you puke.
    //

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesInBuffer = BufferLength;
    
    while (TRUE)
    {
        //
        // Grab a queued write.
        //
        
        pTracker = UxpDequeueFilterWrite(pWriteQueue);

        if (!pTracker)
        {
            //
            // We are all out of queued write data.
            // Bail out.
            //

            break;
        }

        //
        // Make sure we can get at the MDL buffer.
        //
        
        pMdlBuffer = (PBYTE) MmGetSystemAddressForMdlSafe(
                                    pTracker->pMdl,
                                    NormalPagePriority
                                    );

        if (!pMdlBuffer)
        {
            //
            // Big trouble, we couldn't get an address for the buffer
            // which means we are out of memory. We need to get out
            // of here! Complete the tracker now so it can clean up.
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
            pTracker->BytesCopied = 0;

            UxpCompleteQueuedWrite(
                Status,
                pWriteQueue,
                pTracker
                );
            
            break;
        }
    
        //
        // Figure out how much data to copy.
        //

        BytesInMdl = MmGetMdlByteCount(pTracker->pMdl);
        BytesToCopy = MIN((BytesInMdl - pTracker->Offset), BytesInBuffer);

        //
        // Copy the data
        //
        
        RtlCopyMemory(
            pBuffer + BytesCopied,
            pMdlBuffer + pTracker->Offset,
            BytesToCopy
            );

        //
        // Update our local stats.
        //

        BytesCopied += BytesToCopy;
        BytesInBuffer -= BytesToCopy;

        //
        // Update the write tracker.
        //
        pTracker->Offset += BytesToCopy;
        ASSERT(pTracker->Offset <= BytesInMdl);

        pTracker->BytesCopied += BytesToCopy;
        ASSERT(pTracker->BytesCopied <= pTracker->Length);

        if (pTracker->Offset == BytesInMdl)
        {
            //
            // We are done with this MDL. Move to the next one.
            //
        
            pTracker->pMdl = pTracker->pMdl->Next;
            pTracker->Offset = 0;

            if (pTracker->pMdl == NULL)
            {
                ASSERT(pTracker->BytesCopied == pTracker->Length);
                
                //
                // We are done with the whole write tracker.
                // Complete the queued write.
                //
            
                UxpCompleteQueuedWrite(
                    STATUS_SUCCESS,
                    pWriteQueue,
                    pTracker
                    );

                pTracker = NULL;
            }
        }

        //
        // If we're out of buffer space, requeue the tracker
        // and break out of the loop.
        //

        if (BytesInBuffer == 0)
        {
            if (pTracker)
            {
                Status = UxpRequeueFilterWrite(
                                pWriteQueue,
                                pTracker
                                );

                if (!NT_SUCCESS(Status))
                {
                    //
                    // Got an error putting the write back on the
                    // queue. Complete it and forget about any
                    // bytes we got out of it.
                    //

                    pTracker->BytesCopied = 0;
                    BytesCopied = 0;

                    UxpCompleteQueuedWrite(
                        Status,
                        pWriteQueue,
                        pTracker
                        );
                }
            }
        
            break;
        }
    }

    //
    // Done!
    //
    
    if (NT_SUCCESS(Status))
    {
        *pBytesCopied = BytesCopied;
    }
    else
    {
        *pBytesCopied = 0;
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Completes a queued write operation. Calls the appropriate completion
    routine for this type of write, and frees the write tracker.

Arguments:

    Status - Status for the completion
    pWriteQueue - the write queue that the write was on
    pTracker - the queued write to be completed

--***************************************************************************/
VOID
UxpCompleteQueuedWrite(
    IN NTSTATUS Status,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    //
    // Sanity check.
    //
    ASSERT(pWriteQueue);
    ASSERT(pTracker);

    ASSERT(!NT_SUCCESS(Status) || (pTracker->BytesCopied == pTracker->Length));

    UlTrace(FILTER, (
        "http!UxpCompleteQueuedWrite status = %x, pTracker = %p, pContext = %p\n",
        Status,
        pTracker,
        pTracker->pContext
        ));

    //
    // Call the completion routine.
    //

    if (pWriteQueue->pWriteCompletionRoutine)
    {
        (pWriteQueue->pWriteCompletionRoutine)(
            pTracker->pContext,
            Status,
            pTracker->BytesCopied
            );
    }

    //
    // Release our reference to the connection that we got
    // when the write was first queued.
    //

    DEREFERENCE_FILTER_CONNECTION(pTracker->pConnection);

    pTracker->pConnection = NULL;
    pTracker->pWriteQueue = NULL;

    //
    // Get rid of the tracker.
    //
    UxpDeleteFilterWriteTracker(pTracker);
}


/***************************************************************************++

Routine Description:

    Cleans up a write queue by dequeuing all the queued writes and
    completing them.

    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the write queue to clean

--***************************************************************************/
VOID
UxpCancelAllQueuedWrites(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;

    //
    // Sanity check.
    //
    ASSERT(pWriteQueue);

    while (pTracker = UxpDequeueFilterWrite(pWriteQueue))
    {
        UxpCompleteQueuedWrite(STATUS_CANCELLED, pWriteQueue, pTracker);
    }
}


/***************************************************************************++

Routine Description:

    Allocates and initializes a UX_FILTER_WRITE_TRACKER.

Arguments:

    pMdlChain   - chain of MDLs to be copied starting with the first MDL that
        has not been completely copied to a reader.
        
    MdlOffset   - an offset to the first byte in the current MDL that has not
        been copied to a reader.
        
    TotalBytes  - the total number of bytes in the MDL chain including those
        that have already been copied.
        
    BytesCopied - the total number of bytes copied so far.
    
    pContext    - a context pointer used when the write completes.

Return values:

    Returns a pointer to the tracker or NULL if it can't be allocated.

--***************************************************************************/
PUX_FILTER_WRITE_TRACKER
UxpCreateFilterWriteTracker(
    IN PMDL pMdlChain,
    IN ULONG MdlOffset,
    IN ULONG TotalBytes,
    IN ULONG BytesCopied,
    IN PVOID pContext
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;

    //
    // Allocate the tracker memory.
    //

    pTracker = (PUX_FILTER_WRITE_TRACKER)
                    PplAllocate(g_FilterWriteTrackerLookaside);

    //
    // Initialize the tracker data.
    //

    if (pTracker)
    {
        pTracker->Signature = UX_FILTER_WRITE_TRACKER_POOL_TAG;

        pTracker->ListEntry.Flink = NULL;
        pTracker->ListEntry.Blink = NULL;
        
        pTracker->pConnection = NULL;
        pTracker->pWriteQueue = NULL;
    
        pTracker->pMdl = pMdlChain;
        pTracker->Offset = MdlOffset;

        pTracker->Length = TotalBytes;
        pTracker->BytesCopied = BytesCopied;

        pTracker->pContext = pContext;
    }

    return pTracker;
}


/***************************************************************************++

Routine Description:

    Frees a UX_FILTER_WRITE_TRACKER structure.

Arguments:

    pTracker - Supplies the buffer to free.

--***************************************************************************/
VOID
UxpDeleteFilterWriteTracker(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    //
    // Sanity check.
    //
    
    ASSERT(pTracker);
    ASSERT(pTracker->Signature == UX_FILTER_WRITE_TRACKER_POOL_TAG);
    ASSERT(pTracker->pConnection == NULL);
    ASSERT(pTracker->pWriteQueue == NULL);

    pTracker->Signature = MAKE_FREE_SIGNATURE(
                                UX_FILTER_WRITE_TRACKER_POOL_TAG
                                );

    PplFree(g_FilterWriteTrackerLookaside, pTracker);
}

/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UX_FILTER_WRITE_TRACKER
    structure and initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UX_FILTER_WRITE_TRACKER) but is basically
        ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UX_FILTER_WRITE_TRACKER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UxpAllocateFilterWriteTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UX_FILTER_WRITE_TRACKER) );
    ASSERT( Tag == UX_FILTER_WRITE_TRACKER_POOL_TAG );

    //
    // Allocate the tracker buffer.
    //

    pTracker = (PUX_FILTER_WRITE_TRACKER)UL_ALLOCATE_POOL(
                                                NonPagedPool,
                                                sizeof(UX_FILTER_WRITE_TRACKER),
                                                UX_FILTER_WRITE_TRACKER_POOL_TAG
                                                );

    if (pTracker != NULL)
    {
        //
        // Initialize with the free signature to avoid confusing this
        // object with one that's actually in use.
        //
        
        pTracker->Signature =
            MAKE_FREE_SIGNATURE(UX_FILTER_WRITE_TRACKER_POOL_TAG);
    }

    return pTracker;
}


/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UX_FILTER_WRITE_TRACKER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UxpFreeFilterWriteTrackerPool(
    IN PVOID pBuffer
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker = (PUX_FILTER_WRITE_TRACKER)pBuffer;

    //
    // Sanity check
    //
    ASSERT(pTracker);
    ASSERT(pTracker->Signature ==
                MAKE_FREE_SIGNATURE(UX_FILTER_WRITE_TRACKER_POOL_TAG));


    UL_FREE_POOL(pTracker, UX_FILTER_WRITE_TRACKER_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    Retrieves the client filter Channel

Arguments:

    None    

--***************************************************************************/
PUL_FILTER_CHANNEL
UxRetrieveClientFilterChannel()
{
    KIRQL              oldIrql;
    PUL_FILTER_CHANNEL pFilterChannel;

    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    if(g_pSslClientFilterChannel != NULL)
    {
        REFERENCE_FILTER_CHANNEL(g_pSslClientFilterChannel);
        pFilterChannel = g_pSslClientFilterChannel;
    }
    else
    {
        pFilterChannel = NULL;
    }

    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

    return pFilterChannel;
}

/***************************************************************************++

Routine Description:

    Retrieves the Server filter Channel

Arguments:

    None    

--***************************************************************************/
PUL_FILTER_CHANNEL
UxRetrieveServerFilterChannel()
{
    KIRQL              oldIrql;
    PUL_FILTER_CHANNEL pFilterChannel;

    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    if(g_pSslServerFilterChannel != NULL)
    {
        REFERENCE_FILTER_CHANNEL(g_pSslServerFilterChannel);
        pFilterChannel = g_pSslServerFilterChannel;
    }
    else
    {
        pFilterChannel = NULL;
    }

    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

    return pFilterChannel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\hash.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    hash.cxx

Abstract:

    Contains the HTTP response cache hash table logic.

Author:

    Alex Chen (alexch)      28-Mar-2001

Revision History:

    George V. Reilly (GeorgeRe) 09-May-2001
        Cleaned up and tuned up

--*/

#include    "precomp.h"
#include    "hashp.h"

// Global Variables

ULONG   g_UlHashTableBits;
ULONG   g_UlHashTableSize;
ULONG   g_UlHashTableMask;
ULONG   g_UlHashIndexShift;

//
// Optimization: Use the space of (g_UlCacheLineSize - sizeof (HASHBUCKET))
// to store a few records (Hash, pUriCacheEntry) such that we can scan the
// records first before jumping to the single list for searching.
//
// g_UlNumOfHashUriKeys: The number of stored records in the space.
//

ULONG   g_UlNumOfHashUriKeys;

/***************************************************************************++

Routine Description:

    This routine determine the hash table size according to
    (1) user-define value (reading from registry) or
    (2) system memory size estimation, if (1) is not defined

Arguments:

    HashTableBits   - The number of buckets is (1 << HashTableBits)

--***************************************************************************/
VOID
UlpGetHashTableSize(
    IN LONG     HashTableBits
    )
{
    SYSTEM_BASIC_INFORMATION sbi;
    ULONG                    TotalPhysicalMemMB;
    NTSTATUS                 Status;

    Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &sbi,
                    sizeof(sbi),
                    NULL);
    ASSERT(NT_SUCCESS(Status));

    // Capture total physical memory, in terms of megabytes
    TotalPhysicalMemMB = PAGES_TO_MEGABYTES(sbi.NumberOfPhysicalPages);

    //
    // HashTableBits is equal to DEFAULT_HASH_TABLE_BITS
    // if it is not defined in the registry
    //

    if (HashTableBits != DEFAULT_HASH_TABLE_BITS)
    {
        // Use the registry value
        // BUGBUG: We must check for reasonable values, so that a
        // malicious or careless user doesn't cause us to eat up
        // all of (Non)PagedPool.

        g_UlHashTableBits = HashTableBits;
    }
    else
    {
        //
        // Registry value REGISTRY_HASH_TABLE_BITS is not defined,
        // use system memory size estimation instead
        //

        MM_SYSTEMSIZE SystemSize = MmQuerySystemSize();

        if (SystemSize == MmSmallSystem)
        {
            // Hash Table Size: 4K buckets

            g_UlHashTableBits = 12;
        }
        else if (SystemSize == MmMediumSystem)
        {
            // Hash Table Size: 16K buckets

            g_UlHashTableBits = 14;
        }
        else
        {
            // Hash Table Size: 64K buckets

            // BUGBUG: A 64KB server is considered an MmLargeSystem.
            // Tune g_UlHashTableBits according to physical memory

            g_UlHashTableBits = 16;
        }
    }

    g_UlHashIndexShift = g_UlCacheLineBits;

#ifdef HASH_TEST
    g_UlHashTableBits = 3;
#endif

    g_UlHashTableSize = (1 << g_UlHashTableBits);
    g_UlHashTableMask = g_UlHashTableSize - 1;
} // UlpGetHashTableSize



/***************************************************************************++

Routine Description:

    Validates that a locked HASHBUCKET is `compact'. If there are less than
    g_UlNumOfHashUriKeys entries in a bucket, they are clumped together at
    the beginning of the records array, and all the empty slots are at the
    end. All empty slots must have Hash == HASH_INVALID_SIGNATURE and
    pUriCacheEntry == NULL. Conversely, all the non-empty slots at the
    beginning of the array must have point to valid UL_URI_CACHE_ENTRYs
    and must have Hash == correct hash signature, which cannot be
    HASH_INVALID_SIGNATURE. If the single list pointer is non-NULL, then
    the records array must be full.

    If the HASHBUCKET is compact, then we can abort a search for a key as
    soon as we see HASH_INVALID_SIGNATURE. This invariant speeds up Find and
    Insert at the cost of making Delete and Flush a little more
    complex. Since we expect to do a lot more Finds than Deletes or Inserts,
    this is an acceptable tradeoff.

    Storing hash signatures means that we have a very fast test that
    eliminates almost all false positives. We very seldom find two keys
    that have matching hash signatures, but different strings.

Arguments:

    pBucket             - The hash bucket

--***************************************************************************/
BOOLEAN
UlpHashBucketIsCompact(
    IN const PHASHBUCKET pBucket)
{
    PUL_URI_CACHE_ENTRY pUriCacheEntry;
    PUL_URI_CACHE_ENTRY pPrevUriCacheEntry = NULL;
    PHASHURIKEY pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);
    ULONG i, j, Entries = 0;
    
    // First, validate the records array
    
    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        ULONG Hash = pHashUriKey[i].Hash;
        
        if (HASH_INVALID_SIGNATURE == Hash)
        {
            // There are no more valid entries in the records array
            // and no singly linked list
            ASSERT(NULL == pBucket->pUriCacheEntry);
            pPrevUriCacheEntry = NULL;

            for (j = i; j < g_UlNumOfHashUriKeys; j++)
            {
                ASSERT(NULL == pHashUriKey[j].pUriCacheEntry);
                ASSERT(HASH_INVALID_SIGNATURE == pHashUriKey[j].Hash);
            }
        }
        else
        {
            // non-empty slot
            ++Entries;
            pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

            ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry));
            ASSERT(pUriCacheEntry->Cached);
            ASSERT(Hash == pUriCacheEntry->UriKey.Hash);
            ASSERT(Hash == HashRandomizeBits(
                               HashStringNoCaseW(
                                   pUriCacheEntry->UriKey.pUri,
                                   0
                                   )));

            ASSERT(pPrevUriCacheEntry != pUriCacheEntry);
            pPrevUriCacheEntry = pUriCacheEntry;
        }
    }

    // Next, validate the singly linked list

    for (pUriCacheEntry = pBucket->pUriCacheEntry;
         NULL != pUriCacheEntry;
         pUriCacheEntry
             = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next)
    {
        ++Entries;

        ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry));
        ASSERT(pUriCacheEntry->Cached);

        ASSERT(pUriCacheEntry->UriKey.Hash
                    == HashRandomizeBits(
                               HashStringNoCaseW(
                                   pUriCacheEntry->UriKey.pUri,
                                   0
                                   )));

        ASSERT(pPrevUriCacheEntry != pUriCacheEntry);
        pPrevUriCacheEntry = pUriCacheEntry;
    }

    ASSERT(Entries == pBucket->Entries);
    
    return TRUE;
} // UlpHashBucketIsCompact



/***************************************************************************++

Routine Description:

    This routine initialize the hash table

Arguments:

    pHashTable      - The hash table
    PoolType        - Specifies the type of pool memory to allocate
    HashTableBits   - The number of buckets is (1 << HashTableBits)

Returns:
    NTSTATUS        - STATUS_SUCCESS or STATUS_NO_MEMORY
    
--***************************************************************************/
NTSTATUS
UlInitializeHashTable(
    IN OUT PHASHTABLE  pHashTable,
    IN     POOL_TYPE   PoolType,
    IN     LONG        HashTableBits
    )
{
    ULONG i;
    ULONG_PTR CacheLineMask, CacheLineSize = g_UlCacheLineSize;

    //
    // First, get the hash table size from the registry.
    // If not defined in the registry, determine the hash table
    // size by the system memory size
    //

    UlpGetHashTableSize(HashTableBits);

#ifdef HASH_TEST
    CacheLineSize = 64;
    g_UlHashIndexShift = 6;
#endif

    CacheLineMask = CacheLineSize - 1;

    ASSERT((CacheLineSize & CacheLineMask) == 0); // power of 2
    ASSERT(CacheLineSize == (1U << g_UlHashIndexShift));

    pHashTable->Signature = UL_HASH_TABLE_POOL_TAG;
    pHashTable->PoolType = PoolType;

    pHashTable->NumberOfBytes = g_UlHashTableSize * CacheLineSize;

    ASSERT(CacheLineSize > sizeof(HASHBUCKET));
    
    // number of keys stored in the initial clump
    g_UlNumOfHashUriKeys = (((ULONG) CacheLineSize - sizeof (HASHBUCKET))
                                / sizeof(HASHURIKEY));
    pHashTable->pBuckets = NULL;

#ifdef HASH_TEST
    g_UlNumOfHashUriKeys = 3;
#endif

    ASSERT((sizeof(HASHBUCKET)  +  g_UlNumOfHashUriKeys * sizeof(HASHURIKEY))
                <= (1U << g_UlHashIndexShift));

    // Allocate the memory

    pHashTable->pAllocMem
        = (PHASHBUCKET) UL_ALLOCATE_POOL(
                                PoolType,
                                pHashTable->NumberOfBytes + CacheLineMask,
                                UL_HASH_TABLE_POOL_TAG
                                );

    if (NULL == pHashTable->pAllocMem)
    {
        pHashTable->Signature = MAKE_FREE_TAG(UL_HASH_TABLE_POOL_TAG);
        return STATUS_NO_MEMORY;
    }

    // Align the memory the cache line size boundary

    pHashTable->pBuckets
        = (PHASHBUCKET)((((ULONG_PTR)(pHashTable->pAllocMem)) + CacheLineMask)
                            & ~CacheLineMask);

    // Initialize each bucket and padding array elements

    for (i=0; i < g_UlHashTableSize; i++)
    {
        PHASHBUCKET pBucket = UlpHashTableIndexedBucket(pHashTable, i);
        PHASHURIKEY pHashUriKey;
        ULONG       j;

        UlInitializeRWSpinLock(&pBucket->RWSpinLock);

        pBucket->pUriCacheEntry = NULL;

        pBucket->Entries = 0;

        pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

        for (j = 0; j < g_UlNumOfHashUriKeys ;j++)
        {
            pHashUriKey[j].Hash           = HASH_INVALID_SIGNATURE;
            pHashUriKey[j].pUriCacheEntry = NULL;
        }

        ASSERT(UlpHashBucketIsCompact(pBucket));
    }

    return STATUS_SUCCESS;
} // UlInitializeHashTable



/***************************************************************************++

Routine Description:

    This routine terminates the hash table
    (flush all entries and free the table).

Arguments:

    pHashTable      - The hash table

--***************************************************************************/
VOID
UlTerminateHashTable(
    IN PHASHTABLE  pHashTable
    )
{
    if ( pHashTable->pAllocMem != NULL )
    {
        ASSERT(IS_VALID_HASHTABLE(pHashTable));

        // Clear the hash table (delete all entries)

        UlClearHashTable(pHashTable);

        // Free the hash table buckets

        UL_FREE_POOL(pHashTable->pAllocMem, UL_HASH_TABLE_POOL_TAG);

        pHashTable->Signature = MAKE_FREE_TAG(UL_HASH_TABLE_POOL_TAG);
        pHashTable->pAllocMem = pHashTable->pBuckets = NULL;
    }
} // UlTerminateHashTable


/***************************************************************************++

Routine Description:

    This routine does a cache lookup on a hash table
    to see if there is a valid entry corresponding to the request key.
    Increment the reference counter of the entry by 1 inside the lock
    protection to ensure this entry will be still alive after returning
    this entry back.

Arguments:

    pHashTable          - The hash table
    pUriKey             - the search key

Returns:

    PUL_URI_CACHE_ENTRY - pointer to entry or NULL

--***************************************************************************/
PUL_URI_CACHE_ENTRY
UlGetFromHashTable(
    IN PHASHTABLE           pHashTable,
    IN PURI_KEY             pUriKey
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PHASHBUCKET             pBucket;
    PHASHURIKEY             pHashUriKey;
    ULONG                   i;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    pBucket = UlpHashTableBucketFromUriKey(pHashTable, pUriKey);

    UlAcquireRWSpinLockShared(&pBucket->RWSpinLock);

    ASSERT(UlpHashBucketIsCompact(pBucket));

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    // Scan the records array first

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        ULONG Hash = pHashUriKey[i].Hash;
        
        if (HASH_INVALID_SIGNATURE == Hash)
        {
            // There are no more valid entries in the bucket
            ASSERT(NULL == pBucket->pUriCacheEntry);
            ASSERT(NULL == pHashUriKey[i].pUriCacheEntry);

            pUriCacheEntry = NULL;
            goto unlock;
        }

        if (Hash == pUriKey->Hash)
        {
            pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

            ASSERT(NULL != pUriCacheEntry);

            if (UlpEqualUriKeys(&pUriCacheEntry->UriKey, pUriKey))
            {
                goto addref;
            }
        }
    }

    ASSERT(i == g_UlNumOfHashUriKeys);

    // Jump to the single list for searching

    for (pUriCacheEntry = pBucket->pUriCacheEntry;
         NULL != pUriCacheEntry;
         pUriCacheEntry
             = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next)
    {
        if (pUriCacheEntry->UriKey.Hash == pUriKey->Hash
            &&  UlpEqualUriKeys(&pUriCacheEntry->UriKey, pUriKey))
        {
            goto addref;
        }
        
    }

    // Not found

    ASSERT(NULL == pUriCacheEntry);

    goto unlock;

  addref:
    ASSERT(NULL != pUriCacheEntry);

    REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, CHECKOUT);

  unlock:
    ASSERT(UlpHashBucketIsCompact(pBucket));
    
    UlReleaseRWSpinLockShared(&pBucket->RWSpinLock);

    return pUriCacheEntry;

} // UlGetFromHashTable


/***************************************************************************++

Routine Description:

    This routine does a cache lookup on a hash table
    to see if there is a valid entry corresponding to the request URI,
    if found, delete this entry.  However, increment the reference counter
    of the entry by 1 insde the lock protection to ensure this entry will be
    still alive after returning this entry back.

Arguments:

    pHashTable          - The hash table
    pUriKey             - the search key

Returns:

    PUL_URI_CACHE_ENTRY - pointer to entry removed from table or NULL

--***************************************************************************/
PUL_URI_CACHE_ENTRY
UlDeleteFromHashTable(
    IN PHASHTABLE           pHashTable,
    IN PURI_KEY             pUriKey
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PUL_URI_CACHE_ENTRY     PrevUriCacheEntry;
    PHASHBUCKET             pBucket;
    PHASHURIKEY             pHashUriKey;
    ULONG                   i;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    pBucket = UlpHashTableBucketFromUriKey(pHashTable, pUriKey);

    UlAcquireRWSpinLockExclusive(&pBucket->RWSpinLock);

    ASSERT(UlpHashBucketIsCompact(pBucket));

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    // Scan the records array first

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        ULONG Hash = pHashUriKey[i].Hash;

        if (HASH_INVALID_SIGNATURE == Hash)
        {
            ASSERT(NULL == pBucket->pUriCacheEntry);
            ASSERT(NULL == pHashUriKey[i].pUriCacheEntry);

            pUriCacheEntry = NULL;
            goto unlock;
        }

        if (Hash == pUriKey->Hash)
        {
            pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

            ASSERT(NULL != pUriCacheEntry);

            if (UlpEqualUriKeys(&pUriCacheEntry->UriKey, pUriKey))
            {
                --pBucket->Entries;

                if (pBucket->pUriCacheEntry)
                {
                    // If there exists an entry in the single list,
                    // move it to the array

                    pHashUriKey[i].Hash
                        = pBucket->pUriCacheEntry->UriKey.Hash;

                    pHashUriKey[i].pUriCacheEntry = pBucket->pUriCacheEntry;

                    pBucket->pUriCacheEntry
                        = (PUL_URI_CACHE_ENTRY)
                                pBucket->pUriCacheEntry->BucketEntry.Next;
                }
                else
                {
                    // if this is not the last entry in the records array,
                    // move the last entry to this slot
                    ULONG j;

                    for (j = g_UlNumOfHashUriKeys; --j >= i; )
                    {
                        if (NULL != pHashUriKey[j].pUriCacheEntry)
                        {
                            ASSERT(HASH_INVALID_SIGNATURE
                                   != pHashUriKey[j].Hash);

                            ASSERT(j >= i);

                            pHashUriKey[i].Hash = pHashUriKey[j].Hash;
                            pHashUriKey[i].pUriCacheEntry
                                = pHashUriKey[j].pUriCacheEntry;

                            // Zap the last entry. Correct even if j == i
                            pHashUriKey[j].Hash = HASH_INVALID_SIGNATURE;
                            pHashUriKey[j].pUriCacheEntry = NULL;

                            goto unlock;
                        }
                        else
                        {
                            ASSERT(HASH_INVALID_SIGNATURE
                                   == pHashUriKey[j].Hash);
                        }
                    }

                    // We can't get here, since pHashUriKey[i] should
                    // have terminated the loop even if there wasn't
                    // any non-empty slot following it.
                    ASSERT(! "Overshot the deleted entry");
                }

                goto unlock;
            }
        }
    }

    ASSERT(i == g_UlNumOfHashUriKeys);
    
    // Jump to the single list for searching

    pUriCacheEntry = pBucket->pUriCacheEntry;

    PrevUriCacheEntry = NULL;

    while (NULL != pUriCacheEntry)
    {
        if (pUriCacheEntry->UriKey.Hash == pUriKey->Hash
            &&  UlpEqualUriKeys(&pUriCacheEntry->UriKey, pUriKey))
        {
            if (PrevUriCacheEntry == NULL)
            {
                // Delete First Entry
                
                pBucket->pUriCacheEntry
                    = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next;
                
            }
            else
            {
                PrevUriCacheEntry->BucketEntry.Next
                    = pUriCacheEntry->BucketEntry.Next;
            }
            
            --pBucket->Entries;

            goto unlock;
        }
        
        PrevUriCacheEntry = pUriCacheEntry;
        pUriCacheEntry
            = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next;
    }

    // Not found

    ASSERT(NULL == pUriCacheEntry);

  unlock:
    ASSERT((LONG) pBucket->Entries >= 0);
    ASSERT(UlpHashBucketIsCompact(pBucket));

    UlReleaseRWSpinLockExclusive(&pBucket->RWSpinLock);

    return pUriCacheEntry;

} // UlDeleteFromHashTable



/***************************************************************************++

Routine Description:

    This routine does a cache lookup on a hash table
    to see if a given entry exists, if not found, add this entry to the
    hash table. Increment the reference counter of the entry by 1 insde the
    lock protection.

Arguments:

    pHashTable          - The hash table
    pUriCacheEntry      - the given entry

Returns

    ULC_RETCODE         - ULC_SUCCESS or ULC_KEY_EXISTS

--***************************************************************************/
ULC_RETCODE
UlAddToHashTable(
    IN PHASHTABLE           pHashTable,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry
    )
{
    PUL_URI_CACHE_ENTRY     pTmpUriCacheEntry;
    PURI_KEY                pUriKey = &(pUriCacheEntry->UriKey);
    PHASHBUCKET             pBucket;
    PHASHURIKEY             pHashUriKey;
    LONG                    EmptySlot = INVALID_SLOT_INDEX;
    ULONG                   i;
    ULC_RETCODE             rc;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry));
    ASSERT(pUriCacheEntry->Cached);

    pBucket = UlpHashTableBucketFromUriKey(pHashTable, pUriKey);

    UlAcquireRWSpinLockExclusive(&pBucket->RWSpinLock);

    ASSERT(UlpHashBucketIsCompact(pBucket));

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    // Scan the records array first

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        ULONG Hash = pHashUriKey[i].Hash;

        if (HASH_INVALID_SIGNATURE == Hash)
        {
            ASSERT(NULL == pBucket->pUriCacheEntry);
            ASSERT(NULL == pHashUriKey[i].pUriCacheEntry);

            EmptySlot = (LONG) i;
            goto insert;
        }

        if (Hash == pUriKey->Hash)
        {
            pTmpUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

            ASSERT(NULL != pTmpUriCacheEntry);

            if (UlpEqualUriKeys(&pTmpUriCacheEntry->UriKey, pUriKey))
            {
                // duplicate key exists
                pUriCacheEntry->Cached = FALSE;
                rc = ULC_KEY_EXISTS;

                goto unlock;
            }
        }
    }

    ASSERT(i == g_UlNumOfHashUriKeys);
    ASSERT(EmptySlot == INVALID_SLOT_INDEX);

    // Jump to the single list for searching

    for (pTmpUriCacheEntry = pBucket->pUriCacheEntry;
         NULL != pTmpUriCacheEntry;
         pTmpUriCacheEntry
             = (PUL_URI_CACHE_ENTRY) pTmpUriCacheEntry->BucketEntry.Next)
    {
        if (pTmpUriCacheEntry->UriKey.Hash == pUriKey->Hash
            &&  UlpEqualUriKeys(&pTmpUriCacheEntry->UriKey, pUriKey))
        {
            // duplicate key exists
            pUriCacheEntry->Cached = FALSE;
            rc = ULC_KEY_EXISTS;

            goto unlock;
        }
    }

  insert:
    //
    // Not found, no duplicate key in hash table
    //

    if (EmptySlot != INVALID_SLOT_INDEX)
    {
        ASSERT(0 <= EmptySlot  &&  EmptySlot < (LONG) g_UlNumOfHashUriKeys);

        // First, try to add this entry to the array if there is an empty slot.

        pHashUriKey[EmptySlot].Hash           = pUriKey->Hash;
        pHashUriKey[EmptySlot].pUriCacheEntry = pUriCacheEntry;
    }
    else
    {
        // Otherwise, add this entry to the head of the single list

        pUriCacheEntry->BucketEntry.Next
            = (PSINGLE_LIST_ENTRY) pBucket->pUriCacheEntry;

        pBucket->pUriCacheEntry = pUriCacheEntry;
    }

    REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, ADD);

    ASSERT((LONG) pBucket->Entries >= 0);

    ++pBucket->Entries;
    rc = ULC_SUCCESS;

  unlock:
    ASSERT(UlpHashBucketIsCompact(pBucket));

    UlReleaseRWSpinLockExclusive(&pBucket->RWSpinLock);

    return rc;

} // UlAddToHashTable



/***************************************************************************++

Routine Description:

    Removes entries based on a caller-specified filter. The caller
    provides a predicate function which takes a cache entry as a
    parameter. The function will be called for each item in the cache.
    If the function returns ULC_DELETE, the item will be removed.
    Otherwise the item will remain in the cache.

    All removals are done on a hash table bucket.
    Walk through all the entries under this bucket.

    Assume bucket exclusive lock is held.

Arguments:

    pBucket         - The hash table bucket
    pFilterRoutine  - A pointer to the filter function
    pContext        - A parameter to the filter function
    pDeletedCount   - A pointer to the number of deleted entries on this bucket
    bStop           - A pointer to a boolean variable returned to caller
                          (TRUE if the filter function asks for action stop)
--***************************************************************************/
BOOLEAN
UlpFilterFlushHashBucket(
    IN PHASHBUCKET          pBucket,
    IN PUL_URI_FILTER       pFilterRoutine,
    IN PVOID                pContext,
    OUT PULONG              pDeletedCount
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PUL_URI_CACHE_ENTRY     pPrevUriCacheEntry;
    PUL_URI_CACHE_ENTRY     pTmpUriCacheEntry;
    UL_CACHE_PREDICATE      result;
    LONG                    ReferenceCount;
    PHASHURIKEY             pHashUriKey;
    ULONG                   i;
    LONG                    LastSlot;
    BOOLEAN                 bStop = FALSE;

    // Check if bucket exclusive lock is held

    ASSERT( UlIsLockedExclusive(&pBucket->RWSpinLock) );
    ASSERT(UlpHashBucketIsCompact(pBucket));

    // Scan the single list first

    pUriCacheEntry = pBucket->pUriCacheEntry;
    pPrevUriCacheEntry = NULL;

    while (NULL != pUriCacheEntry)
    {
        BOOLEAN bDelete = FALSE;

        result = (*pFilterRoutine)(pUriCacheEntry, pContext);

        switch (result)
        {
            case ULC_ABORT:
                bStop = TRUE;
                goto end;

            case ULC_NO_ACTION:
                // nothing to do
                break;

            case ULC_PERFORM:
            case ULC_PERFORM_STOP:
            case ULC_DELETE:
            case ULC_DELETE_STOP:
            {
                 // Delete this entry
                bDelete = TRUE;

                ASSERT(pBucket->Entries > 0);
                --pBucket->Entries;

                pTmpUriCacheEntry = pUriCacheEntry;

                if (NULL == pPrevUriCacheEntry)
                {
                    // Delete First Entry

                    pBucket->pUriCacheEntry
                        = (PUL_URI_CACHE_ENTRY)
                                pUriCacheEntry->BucketEntry.Next;

                    pUriCacheEntry = pBucket->pUriCacheEntry;

                }
                else
                {
                    pPrevUriCacheEntry->BucketEntry.Next
                        = pUriCacheEntry->BucketEntry.Next;

                    pUriCacheEntry
                        = (PUL_URI_CACHE_ENTRY)
                                pPrevUriCacheEntry->BucketEntry.Next;
                }

                ASSERT(UlpHashBucketIsCompact(pBucket));

                DEREFERENCE_URI_CACHE_ENTRY(pTmpUriCacheEntry, FILTER);

                ++(*pDeletedCount);

                if (result == ULC_PERFORM_STOP  ||  result == ULC_DELETE_STOP)
                {
                    bStop = TRUE;
                    goto end;
                }

                break;
            }

            default:
                break;
        }

        if (!bDelete)
        {
            pPrevUriCacheEntry = pUriCacheEntry;

            pUriCacheEntry
                = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next;
        }
    }

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    //
    // Now, scan the records array.
    //
    // Because we keep the records array compact, we need to keep
    // track of the last valid slot, so that we can move its contents
    // to the slot that's being deleted.
    //

    LastSlot = INVALID_SLOT_INDEX;

    if (NULL == pBucket->pUriCacheEntry)
    {
        for (i = g_UlNumOfHashUriKeys; i-- > 0; )
        {
            if (NULL != pHashUriKey[i].pUriCacheEntry)
            {
                ASSERT(HASH_INVALID_SIGNATURE != pHashUriKey[i].Hash);
                LastSlot = (LONG) i;
                break;
            }
            else
            {
                ASSERT(HASH_INVALID_SIGNATURE == pHashUriKey[i].Hash);
            }
        }

        // Is records array completely empty?
        if (LastSlot == INVALID_SLOT_INDEX)
            goto end;
    }
    else
    {
        // final slot cannot be empty
        ASSERT(HASH_INVALID_SIGNATURE
               != pHashUriKey[g_UlNumOfHashUriKeys-1].Hash);
    }

    // Walk through the records array

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

        if (NULL == pUriCacheEntry)
        {
            ASSERT(HASH_INVALID_SIGNATURE == pHashUriKey[i].Hash);
            goto end;
        }
        else
        {
            ASSERT(HASH_INVALID_SIGNATURE != pHashUriKey[i].Hash);
        }

        result = (*pFilterRoutine)(pUriCacheEntry, pContext);

        switch (result)
        {
            case ULC_ABORT:
                bStop = TRUE;
                goto end;

            case ULC_NO_ACTION:
                // nothing to do
                break;

            case ULC_PERFORM:
            case ULC_PERFORM_STOP:
            case ULC_DELETE:
            case ULC_DELETE_STOP:
            {
                // Delete this entry
                
                ASSERT(pBucket->Entries > 0);
                --pBucket->Entries;

                if (NULL != pBucket->pUriCacheEntry)
                {
                    // If there exists an entry in the single list,
                    // move it to the array

                    ASSERT(LastSlot == INVALID_SLOT_INDEX);

                    pHashUriKey[i].Hash
                        = pBucket->pUriCacheEntry->UriKey.Hash;

                    pHashUriKey[i].pUriCacheEntry = pBucket->pUriCacheEntry;

                    pBucket->pUriCacheEntry
                        = (PUL_URI_CACHE_ENTRY)
                                pBucket->pUriCacheEntry->BucketEntry.Next;

                    if (NULL == pBucket->pUriCacheEntry)
                    {
                        LastSlot = g_UlNumOfHashUriKeys - 1;

                        ASSERT(HASH_INVALID_SIGNATURE
                               != pHashUriKey[LastSlot].Hash);
                    }
                }
                else
                {
                    // Move the entry in the last slot to this position,
                    // zap the last slot, and move LastSlot backwards

                    if (LastSlot != INVALID_SLOT_INDEX
                        &&  (LONG) i < LastSlot)
                    {
                        ASSERT(HASH_INVALID_SIGNATURE
                               != pHashUriKey[LastSlot].Hash);

                        pHashUriKey[i].Hash = pHashUriKey[LastSlot].Hash;
                        pHashUriKey[i].pUriCacheEntry
                            = pHashUriKey[LastSlot].pUriCacheEntry;

                        pHashUriKey[LastSlot].Hash = HASH_INVALID_SIGNATURE;
                        pHashUriKey[LastSlot].pUriCacheEntry = NULL;

                        if (--LastSlot == i)
                            LastSlot = INVALID_SLOT_INDEX;
                        else
                            ASSERT(HASH_INVALID_SIGNATURE
                                   != pHashUriKey[LastSlot].Hash);
                    }
                    else
                    {
                        // Just reset this array element

                        pHashUriKey[i].Hash           = HASH_INVALID_SIGNATURE;
                        pHashUriKey[i].pUriCacheEntry = NULL;
                        LastSlot                      = INVALID_SLOT_INDEX;
                    }
                }

                ASSERT(UlpHashBucketIsCompact(pBucket));

                DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, FILTER);

                ++(*pDeletedCount);

                if (result == ULC_PERFORM_STOP  ||  result == ULC_DELETE_STOP)
                {
                    bStop = TRUE;
                    goto end;
                }

                break;
            }

            default:
                break;
        }
    }

  end:
    ASSERT(UlpHashBucketIsCompact(pBucket));

    return bStop;
} // UlpFilterFlushHashBucket



/***************************************************************************++

Routine Description:

    Removes entries based on a caller-specified filter. The caller
    provides a predicate function which takes a cache entry as a
    parameter. The function will be called with each item in the cache.
    If the function returns ULC_DELETE, the item will be removed.
    Otherwise the item will remain in the cache.

Arguments:

    pHashTable      - The hash table
    pFilterRoutine  - A pointer to the filter function
    pContext        - A parameter to the filter function
    pDeletedCount   - A pointer to the number of deleted entries

Returns:

    ULONG           - Number of entries flushed from the table

--***************************************************************************/
ULONG
UlFilterFlushHashTable(
    IN PHASHTABLE       pHashTable,
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pContext
    )
{
    ULONG   i;
    BOOLEAN bStop        = FALSE;
    ULONG   DeletedCount = 0;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    //
    // Scan and delete (if matching the filter) each bucket
    // of the cache table.
    //

    for (i = 0;  !bStop && i < g_UlHashTableSize;  i++)
    {
        PHASHBUCKET pBucket         = UlpHashTableIndexedBucket(pHashTable, i);
        ULONG       DeletedInBucket = 0;

        UlAcquireRWSpinLockExclusive(&pBucket->RWSpinLock);

        bStop = UlpFilterFlushHashBucket(
                    pBucket,
                    pFilterRoutine,
                    pContext,
                    &DeletedInBucket
                    );

        UlReleaseRWSpinLockExclusive(&pBucket->RWSpinLock);

        DeletedCount += DeletedInBucket;
    }

    return DeletedCount;
} // UlFilterFlushHashTable



/***************************************************************************++

Routine Description:

    Removes all entries on a bucket.

    Assume bucket exclusive lock is held.

Arguments:

    pBucket     - The hash table bucket

--***************************************************************************/
VOID
UlpClearHashBucket(
    IN PHASHBUCKET          pBucket
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PUL_URI_CACHE_ENTRY     pTmpUriCacheEntry;
    PHASHURIKEY             pHashUriKey;
    ULONG                   i;
    LONG                    ReferenceCount;

    // Check if bucket exclusive lock is held

    ASSERT( UlIsLockedExclusive(&pBucket->RWSpinLock) );
    ASSERT(UlpHashBucketIsCompact(pBucket));

    // Scan the single list first

    pUriCacheEntry = pBucket->pUriCacheEntry;

    while (NULL != pUriCacheEntry)
    {
        pTmpUriCacheEntry = pUriCacheEntry;

        pBucket->pUriCacheEntry
            = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next;

        pUriCacheEntry = pBucket->pUriCacheEntry;

        DEREFERENCE_URI_CACHE_ENTRY(pTmpUriCacheEntry, CLEAR);
    }

    ASSERT(NULL == pBucket->pUriCacheEntry);

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    // Scan the records array

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

        if (NULL == pUriCacheEntry)
        {
            ASSERT(HASH_INVALID_SIGNATURE == pHashUriKey[i].Hash);
            break;
        }
        else
        {
            ASSERT(HASH_INVALID_SIGNATURE != pHashUriKey[i].Hash);
        }

        DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, CLEAR);
    }

    pBucket->Entries = 0;

    ASSERT(UlpHashBucketIsCompact(pBucket));
    
} // UlpClearHashBucket



/***************************************************************************++

Routine Description:

    Removes all entries of the hash table.

Arguments:

    pHashTable      - The hash table

--***************************************************************************/
VOID
UlClearHashTable(
    IN PHASHTABLE       pHashTable
    )
{
    ULONG               i;
    PHASHBUCKET         pBucket;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    for (i = 0; i < g_UlHashTableSize ;i++)
    {
        pBucket = UlpHashTableIndexedBucket(pHashTable, i);

        UlAcquireRWSpinLockExclusive(&pBucket->RWSpinLock);

        UlpClearHashBucket(pBucket);

        UlReleaseRWSpinLockExclusive(&pBucket->RWSpinLock);
    }
} // UlClearHashTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\filtqtrace.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    filtqtrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging filter queues.

Author:

    Michael Courage (mcourage)  11-Nov-2000

Revision History:

--*/


#ifndef _FILTQTRACE_H_
#define _FILTQTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


//
// This defines the entry written to the trace log.
//

typedef struct _FILTQ_TRACE_LOG_ENTRY
{
    USHORT                  Action;
    USHORT                  Processor;
    PEPROCESS               pProcess;
    PETHREAD                pThread;

    PUX_FILTER_CONNECTION          pConnection;
    PIRP                    pIrp;

    ULONG                   ReadIrps;
    ULONG                   Writers;

    PVOID                   pFileName;
    USHORT                  LineNumber;

} FILTQ_TRACE_LOG_ENTRY, *PFILTQ_TRACE_LOG_ENTRY;


//
// Action codes.
//
// N.B. These codes must be contiguous, starting at zero. If you update
//      this list, you must also update the corresponding array in
//      ul\ulkd\filt.c.
//

#define FILTQ_ACTION_QUEUE_IRP                      0
#define FILTQ_ACTION_DEQUEUE_IRP                    1
#define FILTQ_ACTION_START_WRITE                    2
#define FILTQ_ACTION_FINISH_WRITE                   3
#define FILTQ_ACTION_BLOCK_WRITE                    4
#define FILTQ_ACTION_WAKE_WRITE                     5
#define FILTQ_ACTION_BLOCK_PARTIAL_WRITE            6
#define FILTQ_ACTION_WAKE_PARTIAL_WRITE             7

#define FILTQ_ACTION_COUNT                          8

#define FILTQ_TRACE_LOG_SIGNATURE   ((LONG)'gLqF')

//
// Manipulators.
//

PTRACE_LOG
CreateFiltqTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyFiltqTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
WriteFiltqTraceLog(
    IN PTRACE_LOG pLog,
    IN USHORT Action,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp,
    IN PVOID pFileName,
    IN USHORT LineNumber
    );


#if ENABLE_FILTQ_TRACE

#define CREATE_FILTQ_TRACE_LOG( ptr, size, extra )                          \
    (ptr) = CreateFiltqTraceLog( (size), (extra) )

#define DESTROY_FILTQ_TRACE_LOG( ptr )                                      \
    do                                                                      \
    {                                                                       \
        DestroyFiltqTraceLog( ptr );                                        \
        (ptr) = NULL;                                                       \
    } while (FALSE)

#define WRITE_FILTQ_TRACE_LOG( act, pcon, pirp )                            \
    WriteFiltqTraceLog(                                                     \
        g_pFilterQueueTraceLog,                                             \
        (act),                                                              \
        (pcon),                                                             \
        (pirp),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#else   // !ENABLE_FILTQ_TRACE

#define CREATE_FILTQ_TRACE_LOG( ptr, size, extra )
#define DESTROY_FILTQ_TRACE_LOG( ptr )
#define WRITE_FILTQ_TRACE_LOG( act, pcon, pirp )

#endif  // ENABLE_FILTQ_TRACE


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _FILTQTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\hash.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    The public definition of response cache hash table.

Author:

    Alex Chen (alexch)      28-Mar-2001

Revision History:

--*/


#ifndef _HASH_H_
#define _HASH_H_

#include "cachep.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Reader-Writer Spinlock definitions
//

#define RWSL_LOCKED   ((ULONG) (-1))
#define RWSL_FREE     (0)

typedef struct _RWSPINLOCK
{
    union
    {
        struct
        {
            // 0 == RWSL_FREE       => unowned
            // >0                   => count of readers (shared)
            // <0 == RWSL_LOCKED    => exclusively owned
            volatile LONG CurrentState; 

            // all writers, including the one that holds the lock
            // exclusively, if at all
            volatile LONG WritersWaiting;
        };

        ULONGLONG Alignment;
    };
} RWSPINLOCK, *PRWSPINLOCK;

//
// Hash Table definitions
//

typedef struct _HASH_BUCKET *PHASHBUCKET;

typedef struct _HASH_TABLE
{
    ULONG                   Signature; //UL_HASH_TABLE_POOL_TAG

    POOL_TYPE               PoolType;

    SIZE_T                  NumberOfBytes;

    PHASHBUCKET             pAllocMem;

    PHASHBUCKET             pBuckets;

} HASHTABLE, *PHASHTABLE;


#define IS_VALID_HASHTABLE(pHashTable)                      \
    (NULL != (pHashTable)                                   \
     &&  NULL != (pHashTable)->pAllocMem                    \
     &&  UL_HASH_TABLE_POOL_TAG == (pHashTable)->Signature)




/***************************************************************************++

Routine Description:

    Initialize the Reader-Writer lock.

Return Value:

--***************************************************************************/
__inline
VOID
UlInitializeRWSpinLock(
    PRWSPINLOCK pRWSpinLock
    )
{
    // pRWSpinLock->CurrentState: Number of Readers, RWSL_FREE: 0

    pRWSpinLock->CurrentState = RWSL_FREE;

    // pRWSpinLock->WritersWaiting: Number of Writers

    pRWSpinLock->WritersWaiting = 0;
} // UlInitializeRWSpinLock



/***************************************************************************++

Routine Description:

    Acquire the Reader lock.

Return Value:

--***************************************************************************/
__inline
VOID
UlAcquireRWSpinLockShared(
    PRWSPINLOCK pRWSpinLock
    )
{
    LONG CurrentState, WritersWaiting;

    while (1)
    {
        CurrentState   = pRWSpinLock->CurrentState;
        WritersWaiting = pRWSpinLock->WritersWaiting;

        //
        // If either (1) write lock is acquired (CurrentState == RWSL_LOCKED)
        // or (2) there is a writer waiting for the lock
        // then skip it this time and try in a tight loop
        //

        if ((CurrentState != RWSL_LOCKED) && (WritersWaiting == 0))
        {
            //
            // Check if number of readers is unchanged
            // increase it by 1
            //

            if (
                CurrentState ==
                (LONG) InterlockedCompareExchange(
                            (PLONG) &pRWSpinLock->CurrentState,
                            CurrentState + 1,
                            CurrentState)
                )
            {
                return;
            }
            else
            {
                // BUGBUG: This is bogus on a uniprocessor system.
                // We'll spin and spin and spin until this thread's
                // quantum is exhausted. We should yield immediately
                // so that the thread that holds the lock has a chance
                // to proceed and release the lock sooner.
                // That's assuming we're running at passive level. If
                // we're running at dispatch level and the owning thread
                // isn't running, we have a biiiig problem.

                // Busy loop
                PAUSE_PROCESSOR;
                continue;
            }
        }
    }
} // UlAcquireRWSpinLockShared



/***************************************************************************++

Routine Description:

    Release the Reader lock.

Return Value:

--***************************************************************************/
__inline
VOID
UlReleaseRWSpinLockShared(
    PRWSPINLOCK pRWSpinLock
    )
{
    // decrease number of readers by 1

    LONG NewState = InterlockedDecrement((PLONG) &pRWSpinLock->CurrentState);
    ASSERT(NewState >= 0);
} // UlReleaseRWSpinLockShared



/***************************************************************************++

Routine Description:

    Acquire the Writer lock.

Return Value:

--***************************************************************************/
__inline
VOID
UlAcquireRWSpinLockExclusive(
    PRWSPINLOCK pRWSpinLock
    )
{
    //
    // First, increment the number of writers by 1
    // such that block the readers
    // By doing so, writers have the priority over readers.
    //

    LONG WritersWaiting = InterlockedIncrement(
                                (PLONG) &pRWSpinLock->WritersWaiting);

    ASSERT(WritersWaiting > 0);
    
    //
    // Interlocked change the number of readers to -1 (RWSL_LOCKED)
    // loop until done
    //

    if (pRWSpinLock->CurrentState == RWSL_FREE)
    {
        if (
            RWSL_FREE ==
            InterlockedCompareExchange(
                (PLONG) &pRWSpinLock->CurrentState,
                RWSL_LOCKED,
                RWSL_FREE)
           )
        {
            return;
        }
    }

    while (1)
    {
        if (pRWSpinLock->CurrentState == RWSL_FREE)
        {
            if (
                RWSL_FREE ==
                InterlockedCompareExchange(
                    (PLONG) &pRWSpinLock->CurrentState,
                    RWSL_LOCKED,
                    RWSL_FREE)
                )
            {
                return;
            }
            else
            {
                // BUGBUG: see comments above about uniprocessor systems

                // Busy loop
                PAUSE_PROCESSOR;
                continue;
            }
        }
    }
} // UlAcquireRWSpinLockExclusive



/***************************************************************************++

Routine Description:

    Release the Writer lock.

Return Value:

--***************************************************************************/
__inline
void
UlReleaseRWSpinLockExclusive(
    PRWSPINLOCK pRWSpinLock
    )
{
    LONG OldState, NewWaiting;
    
    //
    // Update pRWSpinLock->CurrentState and pRWSpinLock->WritersWaiting back
    // in the reverse order of AcquireRWSpinLockExclusive()
    //

    OldState = InterlockedExchange(
                    (PLONG) &pRWSpinLock->CurrentState,
                    RWSL_FREE);

    ASSERT(OldState = RWSL_LOCKED);

    NewWaiting = InterlockedDecrement((PLONG) &pRWSpinLock->WritersWaiting);

    ASSERT(NewWaiting >= 0);
} // UlReleaseRWSpinLockExclusive



/***************************************************************************++

Routine Description:

    Check if the Reader lock is acquired.

Return Value:

    TRUE    - Acquired
    FALSE   - NOT Acquired

--***************************************************************************/
__inline
BOOLEAN
UlIsLockedShared(
    PRWSPINLOCK pRWSpinLock
    )
{
    // BUGBUG: this routine does not prove that THIS thread is one
    // of the shared holders of the lock, merely that at least one
    // thread holds the lock in a shared state. Perhaps some extra
    // instrumentation for debug builds?

    return (pRWSpinLock->CurrentState > 0);
} // UlIsLockedShared



/***************************************************************************++

Routine Description:

    Check if the Writer lock is acquired.

Return Value:

    TRUE    - Acquired
    FALSE   - NOT Acquired

--***************************************************************************/
__inline
BOOLEAN
UlIsLockedExclusive(
    PRWSPINLOCK pRWSpinLock
    )
{
    // BUGBUG: this routine does not prove that THIS thread holds the lock
    // exclusively, merely that someone does.

    BOOLEAN IsLocked = (pRWSpinLock->CurrentState == RWSL_LOCKED);

    // If it's locked, then we must have added ourselves to WritersWaiting
    ASSERT(!IsLocked || pRWSpinLock->WritersWaiting > 0);

    return IsLocked;
} // UlIsLockedExclusive



/***************************************************************************++

Routine Description:

    Wrapper around RtlEqualUnicodeString

Return Value:

    TRUE    - Equal
    FALSE   - NOT Equal

--***************************************************************************/
__inline
BOOLEAN
UlEqualUnicodeString(
    IN PWSTR pString1,
    IN PWSTR pString2,
    IN ULONG StringLength,
    IN BOOLEAN CaseInSensitive 
    )
{
    UNICODE_STRING UnicodeString1, UnicodeString2;

    UnicodeString1.Length           = (USHORT) StringLength;
    UnicodeString1.MaximumLength    = (USHORT) StringLength;
    UnicodeString1.Buffer           = pString1;
    
    UnicodeString2.Length           = (USHORT) StringLength;
    UnicodeString2.MaximumLength    = (USHORT) StringLength;
    UnicodeString2.Buffer           = pString2;

    return RtlEqualUnicodeString(
                &UnicodeString1,
                &UnicodeString2,
                CaseInSensitive
                );
} // UlEqualUnicodeString


NTSTATUS
UlInitializeHashTable(
    IN OUT PHASHTABLE  pHashTable,
    IN     POOL_TYPE   PoolType,
    IN     LONG        HashTableBits
    );

VOID
UlTerminateHashTable(
    IN PHASHTABLE      pHashTable
    );

PUL_URI_CACHE_ENTRY
UlGetFromHashTable(
    IN PHASHTABLE           pHashTable,
    IN PURI_KEY             pUriKey
    );

PUL_URI_CACHE_ENTRY
UlDeleteFromHashTable(
    IN PHASHTABLE           pHashTable,
    IN PURI_KEY             pUriKey
    );

ULC_RETCODE
UlAddToHashTable(
    IN PHASHTABLE           pHashTable,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry
    );

ULONG
UlFilterFlushHashTable(
    IN PHASHTABLE           pHashTable,
    IN PUL_URI_FILTER       pFilterRoutine,
    IN PVOID                pContext
    );

VOID
UlClearHashTable(
    IN PHASHTABLE           pHashTable
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _HASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\filtqtrace.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    filtqtrace.cxx

Abstract:

    This module implements a filter queue tracing facility.

Author:

    Michael Courage (mcourage)  11-Nov-2000

Revision History:

--*/


#include "precomp.h"


#if ENABLE_FILTQ_TRACE


/***************************************************************************++

Routine Description:

    Creates a new (empty) filter queue trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateFiltqTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
{
    return CreateTraceLog(
               FILTQ_TRACE_LOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(FILTQ_TRACE_LOG_ENTRY)
               );

}   // CreateFiltqTraceLog


/***************************************************************************++

Routine Description:

    Destroys a filter queue trace log buffer created with
    CreateFiltqTraceLog().

Arguments:

    pLog - Supplies the filter queue trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyFiltqTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog );

}   // DestroyFiltqTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified filter queue trace log.

Arguments:

    pLog - Supplies the log to write to.

    ConnectionId - the id of the connection we're tracing

    RequestId - the id of the request we're tracing

    Action - Supplies an action code for the new log entry.


--***************************************************************************/
VOID
WriteFiltqTraceLog(
    IN PTRACE_LOG pLog,
    IN USHORT Action,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp,
    IN PVOID pFileName,
    IN USHORT LineNumber
    )
{
    FILTQ_TRACE_LOG_ENTRY entry;

    //
    // Initialize the entry.
    //
    entry.Action = Action;
    entry.Processor = (USHORT)KeGetCurrentProcessorNumber();
    entry.pProcess = PsGetCurrentProcess();
    entry.pThread = PsGetCurrentThread();

    entry.pConnection = pConnection;
    entry.pIrp = pIrp;

    entry.ReadIrps = pConnection->AppToFiltQueue.ReadIrps;
    entry.Writers = pConnection->AppToFiltQueue.Writers;

    entry.pFileName = pFileName;
    entry.LineNumber = LineNumber;

    //
    // Write it to the logs.
    //

    WriteTraceLog( pLog, &entry );

}   // WriteFiltqTraceLog


#endif  // ENABLE_FILTQ_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\hashp.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    hashp.h

Abstract:

    The private definition of response cache hash table.

Author:

    Alex Chen (alexch)      28-Mar-2001

Revision History:

--*/


#ifndef _HASHP_H_
#define _HASHP_H_

#include "hash.h"

#ifdef __cplusplus
extern "C" {
#endif

// Global Variables

extern ULONG    g_UlHashTableBits;
extern ULONG    g_UlHashTableSize;
extern ULONG    g_UlHashTableMask;
extern ULONG    g_UlHashIndexShift;

extern ULONG    g_UlNumOfHashUriKeys;

// If we're using PagedPool for the hashtable, we must not access the
// hashtable at dispatch level. The ((void) 0) is because PAGED_CODE()
// expands to nothing in a free build and otherwise you get a compiler
// warning.

#define HASH_PAGED_CODE(pHashTable)                 \
    do {                                            \
        if ((pHashTable)->PoolType == PagedPool) {  \
            PAGED_CODE();                           \
            ((void) 0); /* for free build */        \
        }                                           \
    } while (0)

#undef HASH_TEST

//
// Hash Table Bucket Stored UriKey definitions
//

#define INVALID_SLOT_INDEX     ((LONG) (-1))

typedef struct _HASH_URIKEY
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;

    ULONG                   Hash;  // Hash signature

} HASHURIKEY, *PHASHURIKEY;


//
// Hash Table Bucket definitions
//

typedef struct _HASH_BUCKET
{
    RWSPINLOCK              RWSpinLock;

    PUL_URI_CACHE_ENTRY     pUriCacheEntry;

    ULONG_PTR               Entries;    // force alignment

    // followed immediately by HASHURIKEY HashUriKey[g_UlNumOfHashUriKeys];

} HASHBUCKET, *PHASHBUCKET;


/***************************************************************************++

Routine Description:

    Get the indexed bucket

Return Value:

--***************************************************************************/
__inline
PHASHBUCKET
UlpHashTableIndexedBucket(
    IN PHASHTABLE  pHashTable,
    IN ULONG       Index
    )
{
    ASSERT(Index < g_UlHashTableSize);
    ASSERT(NULL != pHashTable->pBuckets);

    PHASHBUCKET pBucket = (PHASHBUCKET) (((PBYTE) pHashTable->pBuckets)
                                              + (Index << g_UlHashIndexShift));

    ASSERT((PBYTE) pBucket
                < (PBYTE) pHashTable->pBuckets + pHashTable->NumberOfBytes);

    return pBucket;
} // UlpHashTableIndexedBucket


/***************************************************************************++

Routine Description:

    Retrieve the bucket associated with a URI_KEY

Return Value:

--***************************************************************************/
__inline
PHASHBUCKET
UlpHashTableBucketFromUriKey(
    IN PHASHTABLE  pHashTable,
    IN PURI_KEY    pUriKey
    )
{
    ASSERT(NULL != pUriKey);
    ASSERT(HASH_INVALID_SIGNATURE != pUriKey->Hash);

    return UlpHashTableIndexedBucket(
                pHashTable,
                pUriKey->Hash & g_UlHashTableMask
                );
} // UlpHashTableBucketFromUriKey



/***************************************************************************++

Routine Description:

    Get the address of the inline array of HASHURIKEYs at the end of
    the HASHBUCKET

Return Value:

--***************************************************************************/
__inline
PHASHURIKEY
UlpHashTableUriKeyFromBucket(
    IN PHASHBUCKET pBucket
    )
{
    return (PHASHURIKEY) ((PBYTE) pBucket + sizeof(HASHBUCKET));
}


/***************************************************************************++

Routine Description:

    Compare two URI_KEYS that have identical hashes to see if the
    URIs also match (case-insensitively).
    (Hashes must have been computed with HashStringNoCaseW or
    HashCharNoCaseW.)

Return Value:

--***************************************************************************/
__inline
BOOLEAN
UlpEqualUriKeys(
    IN PURI_KEY pUriKey1,
    IN PURI_KEY pUriKey2
    )
{
    ASSERT(pUriKey1->Hash == pUriKey2->Hash);

    return (pUriKey1->Length == pUriKey2->Length
            &&  UlEqualUnicodeString(
                        pUriKey1->pUri,
                        pUriKey2->pUri,
                        pUriKey1->Length,
                        TRUE
                        )
            );
}

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _HASHP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\hashfn.h ===
/*++

   Copyright    (c)    1998-2001    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

        Paul McDaniel (paulmcd)     Feb-05-1999     Trimmed for kernel mode
                                                    and C (not C++)

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__

#include <math.h>
#include <limits.h>

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

// __inline ULONG
// HashScramble(ULONG dwHash)
// {
//     // Here are 10 primes slightly greater than 10^9
//     //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
//     //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.
//
//     // default value for "scrambling constant"
//     const ULONG RANDOM_CONSTANT = 314159269UL;
//     // large prime number, also used for scrambling
//     const ULONG RANDOM_PRIME =   1000000007UL;
//
//     return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
// }
//
// Given M = A % B, A and B unsigned 32-bit integers greater than zero,
// there are no values of A or B which yield M = 2^32-1.  Why?  Because
// M must be less than B.
// #define HASH_INVALID_SIGNATURE ULONG_MAX


// No number in 0..2^31-1 maps to this number after it has been
// scrambled by HashRandomizeBits
#define HASH_INVALID_SIGNATURE 31678523

// Faster scrambling function suggested by Eric Jacobsen

__inline ULONG
HashRandomizeBits(ULONG dw)
{
	const ULONG dwLo = ((dw * 1103515245 + 12345) >> 16);
	const ULONG dwHi = ((dw * 69069 + 1) & 0xffff0000);
	const ULONG dw2  = dwHi | dwLo;

    ASSERT(dw2 != HASH_INVALID_SIGNATURE);

    return dw2;
}

// Small prime number used as a multiplier in the supplied hash functions
#define HASH_MULTIPLIER 101

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
// 127 = 2^7 - 1 is prime
# define HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif


// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKHash.

__inline ULONG
HashStringA(
    const char* psz,
    ULONG       dwHash)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

__inline ULONG
HashStringW(
    const wchar_t* pwsz,
    ULONG          dwHash)
{
    for (  ;  *pwsz != L'\0';  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}

__inline ULONG
HashCharW(
    WCHAR UnicodeChar,
    ULONG Hash
    )
{
    return HASH_MULTIPLY(Hash)  +  UnicodeChar;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKHash.
// Note: this is not really adequate for MBCS strings.

__inline ULONG
HashStringNoCaseA(
    const char* psz,
    ULONG       dwHash)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

__inline ULONG
HashStringNoCaseW(
    const wchar_t* pwsz,
    ULONG          dwHash)
{
    for (  ;  *pwsz != L'\0';  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  RtlUpcaseUnicodeChar(*pwsz);

    return dwHash;
}

__inline ULONG
HashCharNoCaseW(
    WCHAR UnicodeChar,
    ULONG Hash
    )
{
    return HASH_MULTIPLY(Hash)  +  RtlUpcaseUnicodeChar(UnicodeChar);
}


// HashBlob returns the hash of a blob of arbitrary binary data.
//
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
//
//     inline ULONG Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
//
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     ULONG Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           37 * Hash(rFoo.m_ch)  +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKHash.

__inline ULONG
HashBlob(
    PUCHAR      pb,
    ULONG       cb,
    ULONG       dwHash)
{
    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}


// ======= <snip>
//
//  paulmcd: a bunch snipped due to use of overloading, not allowed in C
//
// ======= <snip>

__inline ULONG HashDouble(double dbl)
{
    int nExponent;
    double dblMantissa;
    if (dbl == 0.0)
        return 0;
    dblMantissa = frexp(dbl, &nExponent);
    // 0.5 <= |mantissa| < 1.0
    return (ULONG) ((2.0 * fabs(dblMantissa)  -  1.0)  *  UINT_MAX);
}

__inline ULONG HashFloat(float f)
{ return HashDouble((double) f); }

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httpconn.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httpconn.h

Abstract:

    This module contains declarations for manipulation HTTP_CONNECTION
    objects.

Author:

    Keith Moore (keithmo)       08-Jul-1998

Revision History:

--*/

/*

there is a bit of refcount madness going on.  basically, these are the
object we have.

OPAQUE_ID_TABLE

    |
    |-->    UL_INTERNAL_REQUEST
    |
    |           o
    |           |
    |-->    UL_HTTP_CONNECTION
                    |
                    o
                o
                |
            UL_CONNECTION


there is a circular reference from UL_CONNECTION to UL_HTTP_CONNECTION.

the chain that brings down a connection starts with UlConnectionDestroyed
notifcation which releases the reference from the UL_CONNECTION.

at this time the opaque id's are also deleted, releasing their references.

when the http_connection refcount hits 0, it releases the reference on the
UL_CONNECTION and the HTTP_REQUEST's.

poof.  everyone is gone now.


CODEWORK:  think about making hardref's everywhere and adding "letgo"
terminate methods


*/

#ifndef _HTTPCONN_H_
#define _HTTPCONN_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Refcounted structure to hold the number of conn for each Site.
// Multiple connections may try to reach to the same entry thru the
// the corresponding ( means the last request's happening on the connection )
// cgroup. This entry get allocated when cgroup created with connection
// limit is enabled.
//

typedef struct _UL_CONNECTION_COUNT_ENTRY {

    //
    // Signature is UL_CONNECTION_COUNT_ENTRY_POOL_TAG
    //

    ULONG               Signature;

    //
    // Ref count for this Site Counter Entry
    //
    LONG                RefCount;

    //
    // Current number of connections
    //

    ULONG               CurConnections;

    //
    // Maximum allowed connections
    //

    ULONG               MaxConnections;

} UL_CONNECTION_COUNT_ENTRY, *PUL_CONNECTION_COUNT_ENTRY;

#define IS_VALID_CONNECTION_COUNT_ENTRY( entry )                            \
    ( (entry != NULL) && ((entry)->Signature == UL_CONNECTION_COUNT_ENTRY_POOL_TAG) )

VOID
UlDereferenceConnectionCountEntry(
    IN PUL_CONNECTION_COUNT_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    );
#define DEREFERENCE_CONNECTION_COUNT_ENTRY( pEntry )                        \
    UlDereferenceConnectionCountEntry(                                      \
    (pEntry)                                                                \
    REFERENCE_DEBUG_ACTUAL_PARAMS                                           \
    )

VOID
UlReferenceConnectionCountEntry(
    IN PUL_CONNECTION_COUNT_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    );
#define REFERENCE_CONNECTION_COUNT_ENTRY( pEntry )                          \
    UlReferenceConnectionCountEntry(                                        \
    (pEntry)                                                                \
    REFERENCE_DEBUG_ACTUAL_PARAMS                                           \
    )

NTSTATUS
UlCreateConnectionCountEntry(
      IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup,
      IN     ULONG                   MaxConnections
    );

ULONG
UlSetMaxConnections(
    IN OUT PULONG  pCurMaxConnection,
    IN     ULONG   NewMaxConnection
    );

VOID
UlSetGlobalConnectionLimit(
    IN ULONG Limit
    );

NTSTATUS
UlInitGlobalConnectionLimits(
    VOID
    );

BOOLEAN
UlAcceptConnection(
    IN     PULONG   pMaxConnection,
    IN OUT PULONG   pCurConnection
    );

LONG
UlDecrementConnections(
    IN OUT PULONG pCurConnection
    );

BOOLEAN
UlCheckSiteConnectionLimit(
    IN OUT PUL_HTTP_CONNECTION pConnection,
    IN OUT PUL_URL_CONFIG_GROUP_INFO pConfigInfo
    );

BOOLEAN
UlAcceptGlobalConnection(
    VOID
    );


//
// function prototypes
//

NTSTATUS
UlCreateHttpConnection(
    OUT PUL_HTTP_CONNECTION *ppHttpConnection,
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlCreateHttpConnectionId(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );

VOID
UlConnectionDestroyedWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlBindConnectionToProcess(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_APP_POOL_PROCESS pProcess
    );

PUL_APP_POOL_PROCESS
UlQueryProcessBinding(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool
    );

VOID
UlUnlinkHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlCleanupHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );

VOID
UlDeleteHttpConnection(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlReferenceHttpConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#if REFERENCE_DEBUG
#define UL_REFERENCE_HTTP_CONNECTION( pconn )                               \
    UlReferenceHttpConnection(                                              \
        (pconn)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define UL_DEREFERENCE_HTTP_CONNECTION( pconn )                             \
    UlDereferenceHttpConnection(                                            \
        (pconn)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )
#else
#define UL_REFERENCE_HTTP_CONNECTION( pconn )                               \
    InterlockedIncrement( &( pconn )->RefCount )

#define UL_DEREFERENCE_HTTP_CONNECTION( pconn )                             \
    if ( InterlockedDecrement( &( pconn )->RefCount ) == 0 )                \
    {                                                                       \
        UL_CALL_PASSIVE(                                                    \
            &( ( pconn )->WorkItem ),                                       \
            &UlDeleteHttpConnection                                         \
        );                                                                  \
    }
#endif

NTSTATUS
UlpCreateHttpRequest(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    OUT PUL_INTERNAL_REQUEST *ppRequest
    );

VOID
UlpFreeHttpRequest(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlReferenceHttpRequest(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#if REFERENCE_DEBUG
#define UL_REFERENCE_INTERNAL_REQUEST( preq )                               \
    UlReferenceHttpRequest(                                                 \
        (preq)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define UL_DEREFERENCE_INTERNAL_REQUEST( preq )                             \
    UlDereferenceHttpRequest(                                               \
        (preq)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )
#else
#define UL_REFERENCE_INTERNAL_REQUEST( preq )                               \
    InterlockedIncrement( &( preq )->RefCount )

#define UL_DEREFERENCE_INTERNAL_REQUEST( preq )                             \
    if ( InterlockedDecrement( &( preq )->RefCount ) == 0 )                 \
    {                                                                       \
        UL_CALL_PASSIVE(                                                    \
            &( ( preq )->WorkItem ),                                        \
            &UlpFreeHttpRequest                                             \
        );                                                                  \
    }
#endif

VOID
UlCancelRequestIo(
    IN PUL_INTERNAL_REQUEST pRequest
    );

PUL_REQUEST_BUFFER
UlCreateRequestBuffer(
    ULONG BufferSize,
    ULONG BufferNumber
    );

VOID
UlFreeRequestBuffer(
    PUL_REQUEST_BUFFER pBuffer
    );

#define UL_REFERENCE_REQUEST_BUFFER( pbuf )                                 \
    InterlockedIncrement( &( pbuf )->RefCount )

#define UL_DEREFERENCE_REQUEST_BUFFER( pbuf )                               \
    if ( InterlockedDecrement( &( pbuf )->RefCount ) == 0 )                 \
    {                                                                       \
        (pbuf)->Signature = MAKE_FREE_TAG(UL_REQUEST_BUFFER_POOL_TAG);      \
                                                                            \
        if ((pbuf)->AllocBytes > DEFAULT_MAX_REQUEST_BUFFER_SIZE)           \
        {                                                                   \
            UL_FREE_POOL_WITH_SIG((pbuf), UL_REQUEST_BUFFER_POOL_TAG);      \
        }                                                                   \
        else                                                                \
        {                                                                   \
            UlPplFreeRequestBuffer((pbuf));                                 \
        }                                                                   \
    }

__inline
PUL_HTTP_CONNECTION
FASTCALL
UlGetConnectionFromId(
    IN HTTP_CONNECTION_ID ConnectionId
    )
{
    return (PUL_HTTP_CONNECTION) UlGetObjectFromOpaqueId(
                                        ConnectionId,
                                        UlOpaqueIdTypeHttpConnection,
                                        UlReferenceHttpConnection
                                        );
}

#define REUSE_CONNECTION_OPAQUE_ID

#ifdef REUSE_CONNECTION_OPAQUE_ID
NTSTATUS
UlAllocateRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlFreeRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    );

PUL_INTERNAL_REQUEST
UlGetRequestFromId(
    IN HTTP_REQUEST_ID RequestId
    );
#else
__inline
NTSTATUS
UlAllocateRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    return UlAllocateOpaqueId(
                &pRequest->RequestId,
                UlOpaqueIdTypeHttpRequest,
                pRequest
                );
}

__inline
NTSTATUS
UlFreeRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    return UlFreeOpaqueId(
                &pRequest->RequestId,
                UlOpaqueIdTypeHttpRequest
                );
}

__inline
PUL_INTERNAL_REQUEST
FASTCALL
UlGetRequestFromId(
    IN HTTP_REQUEST_ID RequestId
    )
{
    return (PUL_INTERNAL_REQUEST) UlGetObjectFromOpaqueId(
                                        RequestId,
                                        UlOpaqueIdTypeHttpRequest,
                                        UlReferenceHttpRequest
                                        );
}
#endif


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _HTTPCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httpconn.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httpconn.cxx

Abstract:

    This module implements the HTTP_CONNECTION object.

Author:

    Keith Moore (keithmo)       08-Jul-1998

Revision History:

--*/


#include "precomp.h"
#include "httpconnp.h"


//
// Private globals.
//

//
// Global connection Limits stuff
//

ULONG   g_MaxConnections        = HTTP_LIMIT_INFINITE;
ULONG   g_CurrentConnections    = 0;
BOOLEAN g_InitGlobalConnections = FALSE;

#ifdef ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlBindConnectionToProcess
NOT PAGEABLE -- UlQueryProcessBinding
NOT PAGEABLE -- UlpCreateProcBinding
NOT PAGEABLE -- UlpFreeProcBinding
NOT PAGEABLE -- UlpFindProcBinding

NOT PAGEABLE -- UlCreateHttpConnection
NOT PAGEABLE -- UlReferenceHttpConnection
NOT PAGEABLE -- UlDereferenceHttpConnection

NOT PAGEABLE -- UlReferenceHttpRequest
NOT PAGEABLE -- UlDereferenceHttpRequest
NOT PAGEABLE -- UlpCreateHttpRequest
NOT PAGEABLE -- UlpFreeHttpRequest
#endif

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Creates a new HTTP_CONNECTION object.

Arguments:

    ppHttpConnection - Receives a pointer to the new HTTP_CONNECTION
        object if successful.

    pConnection - Supplies a pointer to the UL_CONNECTION to associate
        with the newly created HTTP_CONNECTION.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateHttpConnection(
    OUT PUL_HTTP_CONNECTION *ppHttpConnection,
    IN PUL_CONNECTION pConnection
    )
{
    PUL_HTTP_CONNECTION pHttpConnection;
    NTSTATUS Status;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    pHttpConnection = &pConnection->HttpConnection;

    if (pHttpConnection != NULL)
    {
        pHttpConnection->Signature      = UL_HTTP_CONNECTION_POOL_TAG;
        pHttpConnection->RefCount       = 1;
        pHttpConnection->pConnection    = pConnection;
        REFERENCE_CONNECTION( pConnection );
        pHttpConnection->SecureConnection = pConnection->FilterInfo.SecureConnection;

        HTTP_SET_NULL_ID(&pHttpConnection->ConnectionId);

        pHttpConnection->SendBufferedBytes  = 0;
        pHttpConnection->NextRecvNumber     = 0;
        pHttpConnection->NextBufferNumber   = 0;
        pHttpConnection->NextBufferToParse  = 0;
        pHttpConnection->pRequest           = NULL;
        pHttpConnection->pCurrentBuffer     = NULL;
        pHttpConnection->pConnectionCountEntry = NULL;
        pHttpConnection->pPrevSiteCounters = NULL;

        //
        // Init connection timeout info block; implicitly starts
        // ConnectionIdle timer.
        //

        UlInitializeConnectionTimerInfo( &pHttpConnection->TimeoutInfo );

        //
        // Initialize the disconnect management fields.
        //

        pHttpConnection->NeedMoreData       = 0;
        pHttpConnection->UlconnDestroyed    = 0;
        pHttpConnection->WaitingForResponse = 0;
        pHttpConnection->DisconnectFlag     = FALSE;

        UlInitializeNotifyHead(
            &pHttpConnection->WaitForDisconnectHead,
            NULL
            );

        //
        // Init our buffer list
        //

        InitializeListHead(&(pHttpConnection->BufferHead));

        //
        // Init QoS parameters on the connection
        //

        pHttpConnection->BandwidthThrottlingEnabled = 0;
        pHttpConnection->pFlow = NULL;
        pHttpConnection->pFilter = NULL;

        //
        // init app pool process binding list
        //

        InitializeListHead(&(pHttpConnection->BindingHead));

        UlInitializeSpinLock(
            &pHttpConnection->BindingSpinLock,
            "BindingSpinLock"
            );

        Status = UlInitializeResource(
                        &(pHttpConnection->Resource),
                        "UL_HTTP_CONNECTION[%p].Resource",
                        pHttpConnection,
                        UL_HTTP_CONNECTION_RESOURCE_TAG
                        );

        if (NT_SUCCESS(Status) == FALSE)
        {
            RETURN(Status);
        }

        //
        // Initialize BufferingInfo structure.
        //

        UlInitializeSpinLock(
            &pHttpConnection->BufferingInfo.BufferingSpinLock,
            "BufferingSpinLock"
            );

        pHttpConnection->BufferingInfo.BytesBuffered = 0;
        pHttpConnection->BufferingInfo.TransportBytesNotTaken = 0;
        pHttpConnection->BufferingInfo.DrainAfterDisconnect = FALSE;
        pHttpConnection->BufferingInfo.ReadIrpPending = FALSE;

        pHttpConnection->pRequestIdContext = NULL;

        UlInitializeSpinLock(
            &pHttpConnection->RequestIdSpinLock,
            "RequestIdSpinLock"
            );

        UlTrace(
            REFCOUNT, (
                "ul!UlCreateHttpConnection conn=%p refcount=%d\n",
                pHttpConnection,
                pHttpConnection->RefCount)
            );

        *ppHttpConnection = pHttpConnection;
        RETURN(STATUS_SUCCESS);
    }

    RETURN(STATUS_INSUFFICIENT_RESOURCES);

}   // UlCreateHttpConnection

NTSTATUS
UlCreateHttpConnectionId(
    IN PUL_HTTP_CONNECTION pHttpConnection
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Create an opaque id for the connection
    //

    Status = UlAllocateOpaqueId(
                    &pHttpConnection->ConnectionId, // pOpaqueId
                    UlOpaqueIdTypeHttpConnection,   // OpaqueIdType
                    pHttpConnection                 // pContext
                    );

    if (NT_SUCCESS(Status))
    {
        UL_REFERENCE_HTTP_CONNECTION(pHttpConnection);

        TRACE_TIME(
            pHttpConnection->ConnectionId,
            0,
            TIME_ACTION_CREATE_CONNECTION
            );
    }

    RETURN(Status);

}   // UlCreateHttpConnectionId

VOID
UlConnectionDestroyedWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_HTTP_CONNECTION pHttpConnection;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pHttpConnection = CONTAINING_RECORD(
                            pWorkItem,
                            UL_HTTP_CONNECTION,
                            WorkItem
                            );

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

    UlTrace(HTTP_IO, (
        "ul!UlConnectionDestroyedWorker: httpconn=%p\n",
        pHttpConnection
        ));


    UlAcquireResourceExclusive( &pHttpConnection->Resource, TRUE );
    //
    // kill the request if there is one
    //

    if (pHttpConnection->pRequest) {
        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pHttpConnection->pRequest));

        UlUnlinkHttpRequest(pHttpConnection->pRequest);
        pHttpConnection->pRequest = NULL;
    }

    //
    // make sure no one adds a new request now that we're done
    //
    pHttpConnection->UlconnDestroyed = 1;

    //
    // Decrement the global connection limit. Its safe to decrement for
    // global case because http object doesn't even allocated for global
    // rejection which happens as tcp refusal early when acepting the
    // connection request.
    //

    UlDecrementConnections( &g_CurrentConnections );

    //
    // Decrement the site connections and let our ref go away. If the
    // pConnectionCountEntry is not null, we have been accepted.
    //

    if (pHttpConnection->pConnectionCountEntry)
    {
        UlDecrementConnections(
            &pHttpConnection->pConnectionCountEntry->CurConnections );

        DEREFERENCE_CONNECTION_COUNT_ENTRY(pHttpConnection->pConnectionCountEntry);
        pHttpConnection->pConnectionCountEntry = NULL;
    }

    //
    // and now remove the connection's id
    //

    if (HTTP_IS_NULL_ID(&pHttpConnection->ConnectionId) == FALSE)
    {
        UlFreeOpaqueId(
            pHttpConnection->ConnectionId,
            UlOpaqueIdTypeHttpConnection
            );

        HTTP_SET_NULL_ID(&pHttpConnection->ConnectionId);

        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);
    }


    UlReleaseResource( &pHttpConnection->Resource );

    //
    // Complete all WaitForDisconnect IRPs
    //
    UlCompleteAllWaitForDisconnect(pHttpConnection);

    //
    // and remove the ULTDI reference from the HTTP_CONNECTION
    //

    UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);

}   // UlConnectionDestroyedWorker


/***************************************************************************++

Routine Description:

    Tries to establish a binding between a connection and an app pool
    process. You can query these bindings with UlQueryProcessBinding.

Arguments:

    pHttpConnection - the connection to bind
    pAppPool        - the app pool that owns the process (key for lookups)
    pProcess        - the process to bind to

--***************************************************************************/
NTSTATUS
UlBindConnectionToProcess(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_APOOL_PROC_BINDING pBinding = NULL;
    KIRQL OldIrql;

    //
    // Sanity check
    //
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );
    ASSERT( pAppPool->NumberActiveProcesses > 1 || pProcess == NULL );

    UlAcquireSpinLock(&pHttpConnection->BindingSpinLock, &OldIrql);

    //
    // see if there's already a binding object
    //
    pBinding = UlpFindProcBinding(pHttpConnection, pAppPool);
    if (pBinding) {
        if (pProcess) {
            //
            // modify the binding
            //
            pBinding->pProcess = pProcess;
        } else {
            //
            // we're supposed to kill this binding
            //
            RemoveEntryList(&pBinding->BindingEntry);
            UlpFreeProcBinding(pBinding);
        }
    } else {
        if (pProcess) {
            //
            // create a new entry
            //
            pBinding = UlpCreateProcBinding(pAppPool, pProcess);

            if (pBinding) {
                InsertHeadList(
                    &pHttpConnection->BindingHead,
                    &pBinding->BindingEntry
                    );
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    UlReleaseSpinLock(&pHttpConnection->BindingSpinLock, OldIrql);

    UlTrace(ROUTING, (
        "ul!UlBindConnectionToProcess(\n"
        "        pHttpConnection = %p (%I64x)\n"
        "        pAppPool        = %p\n"
        "        pProcess        = %p )\n"
        "    Status = 0x%x\n",
        pHttpConnection,
        pHttpConnection->ConnectionId,
        pAppPool,
        pProcess,
        Status
        ));

    return Status;
}


/***************************************************************************++

Routine Description:

    Removes an HTTP request from all lists and cleans up it's opaque id.

Arguments:

    pRequest - the request to be unlinked

--***************************************************************************/
VOID
UlCleanupHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    )
{
    PLIST_ENTRY pEntry;

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pHttpConnection->pRequest ) );
    ASSERT( pHttpConnection->WaitingForResponse );

    UlUnlinkHttpRequest( pHttpConnection->pRequest );

    pHttpConnection->pRequest = NULL;
    pHttpConnection->WaitingForResponse = 0;

    UlTrace( PARSER, (
        "***1 pConnection %p->WaitingForResponse = 0\n",
        pHttpConnection
        ));

    //
    // Free the old request's buffers
    //

    ASSERT( UL_IS_VALID_REQUEST_BUFFER( pHttpConnection->pCurrentBuffer ) );

    pEntry = pHttpConnection->BufferHead.Flink;
    while (pEntry != &pHttpConnection->BufferHead)
    {
        PUL_REQUEST_BUFFER pBuffer;

        //
        // Get the object
        //

        pBuffer = CONTAINING_RECORD(
                        pEntry,
                        UL_REQUEST_BUFFER,
                        ListEntry
                        );

        //
        // did we reach the end?
        //

        if (pBuffer == pHttpConnection->pCurrentBuffer) {
            break;
        }

        //
        // remember the next one
        //

        pEntry = pEntry->Flink;

        //
        // unlink it
        //

        UlFreeRequestBuffer(pBuffer);
    }
}


VOID
UlReferenceHttpConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    PUL_HTTP_CONNECTION pHttpConnection = (PUL_HTTP_CONNECTION) pObject;

    refCount = InterlockedIncrement( &pHttpConnection->RefCount );

    WRITE_REF_TRACE_LOG2(
        g_pHttpConnectionTraceLog,
        pHttpConnection->pTraceLog,
        REF_ACTION_REFERENCE_HTTP_CONNECTION,
        refCount,
        pHttpConnection,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT, (
            "ul!UlReferenceHttpConnection conn=%p refcount=%d\n",
            pHttpConnection,
            refCount)
        );

}   // UlReferenceHttpConnection


VOID
UlDereferenceHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    ASSERT( pHttpConnection );
    ASSERT( pHttpConnection->RefCount > 0 );

    WRITE_REF_TRACE_LOG2(
        g_pHttpConnectionTraceLog,
        pHttpConnection->pTraceLog,
        REF_ACTION_DEREFERENCE_HTTP_CONNECTION,
        pHttpConnection->RefCount - 1,
        pHttpConnection,
        pFileName,
        LineNumber
        );

    refCount = InterlockedDecrement( &pHttpConnection->RefCount );

    UlTrace(
        REFCOUNT, (
            "ul!UlDereferenceHttpConnection conn=%p refcount=%d\n",
            pHttpConnection,
            refCount)
        );

    if (refCount == 0)
    {
        //
        // now it's time to free the connection, we need to do
        // this at lower'd irql, let's check it out
        //

        UL_CALL_PASSIVE(
            &(pHttpConnection->WorkItem),
            &UlDeleteHttpConnection
            );
    }

}   // UlDereferenceHttpConnection


/***************************************************************************++

Routine Description:

    Frees all resources associated with the specified HTTP_CONNECTION.

Arguments:

    pWorkItem - Supplies the HTTP_CONNECTION to free.

--***************************************************************************/
VOID
UlDeleteHttpConnection(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS            Status;
    PLIST_ENTRY         pEntry;
    PUL_HTTP_CONNECTION pHttpConnection;
    KIRQL               OldIrql;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pHttpConnection = CONTAINING_RECORD(
                            pWorkItem,
                            UL_HTTP_CONNECTION,
                            WorkItem
                            );

    ASSERT( pHttpConnection != NULL &&
            pHttpConnection->Signature == UL_HTTP_CONNECTION_POOL_TAG );
    ASSERT(HTTP_IS_NULL_ID(&pHttpConnection->ConnectionId));
    ASSERT(pHttpConnection->SendBufferedBytes == 0);

    WRITE_REF_TRACE_LOG2(
        g_pHttpConnectionTraceLog,
        pHttpConnection->pTraceLog,
        REF_ACTION_DESTROY_HTTP_CONNECTION,
        0,
        pHttpConnection,
        __FILE__,
        __LINE__
        );

    //
    // The request is gone by now
    //

    ASSERT(pHttpConnection->pRequest == NULL);

    //
    // remove from Timeout Timer Wheel(c)
    //

    UlTimeoutRemoveTimerWheelEntry(
        &pHttpConnection->TimeoutInfo
        );

    //
    // delete the buffer list
    //

    pEntry = pHttpConnection->BufferHead.Flink;
    while (pEntry != &pHttpConnection->BufferHead)
    {
        PUL_REQUEST_BUFFER pBuffer;

        //
        // Get the object
        //

        pBuffer = CONTAINING_RECORD(
                        pEntry,
                        UL_REQUEST_BUFFER,
                        ListEntry
                        );

        //
        // remember the next one
        //

        pEntry = pEntry->Flink;

        //
        // unlink it
        //

        UlFreeRequestBuffer(pBuffer);
    }

    ASSERT(IsListEmpty(&pHttpConnection->BufferHead));

    //
    // get rid of any bindings we're keeping
    //
    while (!IsListEmpty(&pHttpConnection->BindingHead))
    {
        PUL_APOOL_PROC_BINDING pBinding;

        //
        // Get the object
        //
        pEntry = RemoveHeadList(&pHttpConnection->BindingHead);

        pBinding = CONTAINING_RECORD(
                        pEntry,
                        UL_APOOL_PROC_BINDING,
                        BindingEntry
                        );

        ASSERT( IS_VALID_PROC_BINDING(pBinding) );

        //
        // free it
        //

        UlpFreeProcBinding(pBinding);
    }

    //
    // get rid of our resource
    //
    Status = UlDeleteResource(&(pHttpConnection->Resource));
    ASSERT(NT_SUCCESS(Status));

    //
    // Attempt to remove any QoS filter on this connection,
    // if BWT is enabled.
    //

    if (pHttpConnection->BandwidthThrottlingEnabled)
    {
        UlTcDeleteFilter(pHttpConnection);
    }

    //
    // Remove final (previous) site counter entry reference 
    // (matches reference in UlSendCachedResponse/UlDeliverHttpRequest)
    // 
    if (pHttpConnection->pPrevSiteCounters)
    {
        UlDecSiteCounter(
            pHttpConnection->pPrevSiteCounters, 
            HttpSiteCounterCurrentConns
            );

        DEREFERENCE_SITE_COUNTER_ENTRY(pHttpConnection->pPrevSiteCounters);
        pHttpConnection->pPrevSiteCounters = NULL;
    }


    //
    // free the memory
    //

    pHttpConnection->Signature = MAKE_FREE_SIGNATURE(
                                        UL_HTTP_CONNECTION_POOL_TAG
                                        );

    //
    // let go the UL_CONNECTION
    //

    DEREFERENCE_CONNECTION( pHttpConnection->pConnection );

}   // UlDeleteHttpConnection


/***************************************************************************++

Routine Description:


Arguments:

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCreateHttpRequest(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    OUT PUL_INTERNAL_REQUEST *ppRequest
    )
{
    PUL_INTERNAL_REQUEST pRequest = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pRequest = UlPplAllocateInternalRequest();

    if (pRequest == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    ASSERT( pRequest->Signature == MAKE_FREE_TAG(UL_INTERNAL_REQUEST_POOL_TAG) );

    pRequest->Signature     = UL_INTERNAL_REQUEST_POOL_TAG;
    pRequest->RefCount      = 1;

    //
    // the verb comes first
    //

    pRequest->ParseState    = ParseVerbState;

    //
    // keep a reference to the connection.
    //

    UL_REFERENCE_HTTP_CONNECTION( pHttpConnection );

    pRequest->pHttpConn     = pHttpConnection;
    pRequest->ConnectionId  = pHttpConnection->ConnectionId;
    pRequest->Secure        = pHttpConnection->SecureConnection;

    //
    // init our LIST_ENTRY's
    //

    InitializeListHead( &pRequest->UnknownHeaderList );
    InitializeListHead( &pRequest->IrpHead );

    //
    // We start with no header buffers appended nor Irps pending.
    //

    pRequest->HeadersAppended = FALSE;
    pRequest->IrpsPending = FALSE;

    //
    // Reset the index to our default unknown header table to 0 as well as
    // the unknown header count.
    //

    pRequest->NextUnknownHeaderIndex = 0;
    pRequest->UnknownHeaderCount = 0;

    //
    // Create an opaque id for the request.
    //
    // We also make a copy of the id in case we need
    // to see what the id was after the real one
    // is freed and set to null.
    //

    HTTP_SET_NULL_ID(&pRequest->RequestId);

    pRequest->RequestIdCopy = pRequest->RequestId;

    //
    // Grab the raw connection id off the UL_CONNECTION.
    //

    pRequest->RawConnectionId = pHttpConnection->pConnection->FilterInfo.ConnectionId;

    //
    // Initialize the header index table.
    //

    pRequest->HeaderIndex[0] = HttpHeaderRequestMaximum;

    //
    // Initialize the referenced buffers arrary.
    //

    pRequest->AllocRefBuffers = 1;
    pRequest->UsedRefBuffers = 0;
    pRequest->pRefBuffers = pRequest->pInlineRefBuffers;

    //
    // Initialize the UL_URL_CONFIG_GROUP_INFO.
    //

    UlpInitializeUrlInfo(&pRequest->ConfigInfo);

    //
    // Zero the remaining fields.
    //

    RtlZeroMemory(
        (PUCHAR)pRequest + FIELD_OFFSET(UL_INTERNAL_REQUEST, HeaderValid),
        sizeof(*pRequest) - FIELD_OFFSET(UL_INTERNAL_REQUEST, HeaderValid)
        );

    CREATE_REF_TRACE_LOG( pRequest->pTraceLog, 32 - REF_TRACE_OVERHEAD, 0 );

    //
    // return it
    //

    *ppRequest = pRequest;

    UlTrace(REFCOUNT, (
        "ul!UlpCreateHttpRequest req=%p refcount=%d\n",
        pRequest,
        pRequest->RefCount
        ));

    return STATUS_SUCCESS;

}   // UlpCreateHttpRequest


VOID
UlReferenceHttpRequest(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    PUL_INTERNAL_REQUEST pRequest = (PUL_INTERNAL_REQUEST) pObject;

    refCount = InterlockedIncrement( &pRequest->RefCount );

    WRITE_REF_TRACE_LOG2(
        g_pHttpRequestTraceLog,
        pRequest->pTraceLog,
        REF_ACTION_REFERENCE_HTTP_REQUEST,
        refCount,
        pRequest,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT, (
            "ul!UlReferenceHttpRequest req=%p refcount=%d\n",
            pRequest,
            refCount)
        );

}   // UlReferenceHttpRequest

VOID
UlDereferenceHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    WRITE_REF_TRACE_LOG2(
        g_pHttpRequestTraceLog,
        pRequest->pTraceLog,
        REF_ACTION_DEREFERENCE_HTTP_REQUEST,
        pRequest->RefCount - 1,
        pRequest,
        pFileName,
        LineNumber
        );

    refCount = InterlockedDecrement( &pRequest->RefCount );

    UlTrace(
        REFCOUNT, (
            "ul!UlDereferenceHttpRequest req=%p refcount=%d\n",
            pRequest,
            refCount)
        );

    if (refCount == 0)
    {
        UL_CALL_PASSIVE(
            &pRequest->WorkItem,
            &UlpFreeHttpRequest
            );
    }

}   // UlDereferenceHttpRequest

/***************************************************************************++

Routine Description:

    Cancels all pending http io.

Arguments:

    pRequest - Supplies the HTTP_REQUEST.

--***************************************************************************/
VOID
UlCancelRequestIo(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // Mark the request as InCleanup, so additional IRPs
    // on the request will not be queued.
    //
    pRequest->InCleanup = 1;

    //
    // tank all pending io on this request
    //

    while (IsListEmpty(&pRequest->IrpHead) == FALSE)
    {
        PLIST_ENTRY pEntry;
        PIRP pIrp;

        //
        // Pop it off the list.
        //

        pEntry = RemoveHeadList(&pRequest->IrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looping
            //

            pIrp = NULL;
        }
        else
        {
            PUL_INTERNAL_REQUEST pIrpRequest;

            //
            // cancel it.  even if pIrp->Cancel == TRUE we are supposed to
            // complete it, our cancel routine will never run.
            //

            pIrpRequest = (PUL_INTERNAL_REQUEST)(
                                IoGetCurrentIrpStackLocation(pIrp)->
                                    Parameters.DeviceIoControl.Type3InputBuffer
                                );

            ASSERT(pIrpRequest == pRequest);

            UL_DEREFERENCE_INTERNAL_REQUEST(pIrpRequest);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, g_UlPriorityBoost);
            pIrp = NULL;
        }

    }   // while (IsListEmpty(&pRequest->IrpHead) == FALSE)

}   // UlCancelRequestIo


/***************************************************************************++

Routine Description:

    Frees all resources associated with the specified UL_INTERNAL_REQUEST.

Arguments:

    pRequest - Supplies the UL_INTERNAL_REQUEST to free.

--***************************************************************************/
VOID
UlpFreeHttpRequest(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_INTERNAL_REQUEST pRequest;
    PLIST_ENTRY pEntry;
    ULONG i;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pRequest = CONTAINING_RECORD(
                    pWorkItem,
                    UL_INTERNAL_REQUEST,
                    WorkItem
                    );

    //
    // our opaque id should already be free'd (UlDeleteOpaqueIds)
    //

    ASSERT(HTTP_IS_NULL_ID(&pRequest->RequestId));

    //
    // free any known header buffers allocated
    //

    if (pRequest->HeadersAppended)
    {
        for (i = 0; i < HttpHeaderRequestMaximum; i++)
        {
            HTTP_HEADER_ID HeaderId = (HTTP_HEADER_ID)pRequest->HeaderIndex[i];

            if (HeaderId == HttpHeaderRequestMaximum)
            {
                break;
            }

            ASSERT( pRequest->HeaderValid[HeaderId] );

            if (pRequest->Headers[HeaderId].OurBuffer == 1)
            {
                UL_FREE_POOL(
                    pRequest->Headers[HeaderId].pHeader,
                    HEADER_VALUE_POOL_TAG
                    );
            }
        }

        //
        // and any unknown header buffers allocated
        //

        while (IsListEmpty(&pRequest->UnknownHeaderList) == FALSE)
        {
            PUL_HTTP_UNKNOWN_HEADER pUnknownHeader;

            pEntry = RemoveHeadList(&pRequest->UnknownHeaderList);

            pUnknownHeader = CONTAINING_RECORD(
                                pEntry,
                                UL_HTTP_UNKNOWN_HEADER,
                                List
                                );

            if (pUnknownHeader->HeaderValue.OurBuffer == 1)
            {
                UL_FREE_POOL(
                    pUnknownHeader->HeaderValue.pHeader,
                    HEADER_VALUE_POOL_TAG
                    );
            }

            //
            // Free the header structure
            //

            if (pUnknownHeader->HeaderValue.ExternalAllocated == 1)
            {
                UL_FREE_POOL(
                    pUnknownHeader,
                    UL_HTTP_UNKNOWN_HEADER_POOL_TAG
                    );
            }
        }
    }

    //
    // there better not be any pending io, it would have been cancelled either
    // in UlDeleteHttpConnection or in UlDetachProcessFromAppPool .
    //

    ASSERT(IsListEmpty(&pRequest->IrpHead));

    //
    // dereferenc request buffers.
    //

    for (i = 0; i < pRequest->UsedRefBuffers; i++)
    {
        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pRequest->pRefBuffers[i]) );
        UL_DEREFERENCE_REQUEST_BUFFER(pRequest->pRefBuffers[i]);
    }

    if (pRequest->AllocRefBuffers > 1)
    {
        UL_FREE_POOL(
            pRequest->pRefBuffers,
            UL_REF_REQUEST_BUFFER_POOL_TAG
            );
    }

    //
    // free any url that was allocated
    //

    if (pRequest->CookedUrl.pUrl != NULL)
    {
        if (pRequest->CookedUrl.pUrl != pRequest->pUrlBuffer)
        {
            UL_FREE_POOL(pRequest->CookedUrl.pUrl, URL_POOL_TAG);
        }
    }

    //
    // free any config group info
    //

    ASSERT( IS_VALID_URL_CONFIG_GROUP_INFO(&pRequest->ConfigInfo) );
    ASSERT( pRequest->pHttpConn );

    //
    // Perf counters
    // NOTE: Assumes cache & non-cache paths both go through here
    // NOTE: If connection is refused the pConnectionCountEntry will be NULL
    //
    if (pRequest->ConfigInfo.pSiteCounters &&
        pRequest->pHttpConn->pConnectionCountEntry)
    {
        PUL_SITE_COUNTER_ENTRY pCtr = pRequest->ConfigInfo.pSiteCounters;

        UlAddSiteCounter64(
                pCtr,
                HttpSiteCounterBytesSent,
                pRequest->BytesSent
                );

        UlAddSiteCounter64(
                pCtr,
                HttpSiteCounterBytesReceived,
                pRequest->BytesReceived
                );

        UlAddSiteCounter64(
                pCtr,
                HttpSiteCounterBytesTransfered,
                (pRequest->BytesSent + pRequest->BytesReceived)
                );

    }

    //
    // Release all the references from the UL_URL_CONFIG_GROUP_INFO.
    //
    UlpConfigGroupInfoRelease(&pRequest->ConfigInfo);

    //
    // release our reference to the connection
    //
    UL_DEREFERENCE_HTTP_CONNECTION( pRequest->pHttpConn );

    //
    // Free the object buffer
    //
    ASSERT(pRequest->Signature == UL_INTERNAL_REQUEST_POOL_TAG);
    pRequest->Signature = MAKE_FREE_TAG(UL_INTERNAL_REQUEST_POOL_TAG);

    DESTROY_REF_TRACE_LOG( pRequest->pTraceLog );

    UlPplFreeInternalRequest( pRequest );
}


/***************************************************************************++

Routine Description:

    Allocates and initializes a new UL_REQUEST_BUFFER.

Arguments:

    BufferSize - size of the new buffer in bytes

--***************************************************************************/
PUL_REQUEST_BUFFER
UlCreateRequestBuffer(
    ULONG BufferSize,
    ULONG BufferNumber
    )
{
    PUL_REQUEST_BUFFER pBuffer;

    BufferSize = MAX(BufferSize, DEFAULT_MAX_REQUEST_BUFFER_SIZE);

    if (BufferSize > DEFAULT_MAX_REQUEST_BUFFER_SIZE)
    {
        BufferSize = (ULONG) MAX(
                                 BufferSize,
                                 PAGE_SIZE - ALIGN_UP(sizeof(UL_REQUEST_BUFFER),PVOID)
                                 );

        pBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_REQUEST_BUFFER,
                        BufferSize,
                        UL_REQUEST_BUFFER_POOL_TAG
                        );
    }
    else
    {
        pBuffer = UlPplAllocateRequestBuffer();
    }

    if (pBuffer == NULL)
    {
        return NULL;
    }

    RtlZeroMemory(
        (PCHAR)pBuffer + sizeof(SINGLE_LIST_ENTRY),
        sizeof(UL_REQUEST_BUFFER) - sizeof(SINGLE_LIST_ENTRY)
        );

    pBuffer->Signature = UL_REQUEST_BUFFER_POOL_TAG;

    UlTrace(HTTP_IO, (
                "ul!UlCreateRequestBuffer buff=%p num=%d size=%d\n",
                pBuffer,
                BufferNumber,
                BufferSize
                ));

    pBuffer->RefCount       = 1;
    pBuffer->AllocBytes     = BufferSize;
    pBuffer->BufferNumber   = BufferNumber;

    return pBuffer;
}


/***************************************************************************++

Routine Description:

    Removes a request buffer from the buffer list and destroys it.

Arguments:

    pBuffer - the buffer to be deleted

--***************************************************************************/
VOID
UlFreeRequestBuffer(
    PUL_REQUEST_BUFFER pBuffer
    )
{
    ASSERT( UL_IS_VALID_REQUEST_BUFFER( pBuffer ) );

    UlTrace(HTTP_IO, (
        "ul!UlFreeRequestBuffer(pBuffer = %p, Num = %d)\n",
        pBuffer,
        pBuffer->BufferNumber
        ));

    if (pBuffer->ListEntry.Flink != NULL) {
        RemoveEntryList(&pBuffer->ListEntry);
        pBuffer->ListEntry.Blink = pBuffer->ListEntry.Flink = NULL;
    }

    UL_DEREFERENCE_REQUEST_BUFFER(pBuffer);
}


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Retrieves a binding set with UlBindConnectionToProcess.

Arguments:

    pHttpConnection - the connection to query
    pAppPool        - the key to use for the lookup

Return Values:

    A pointer to the bound process if one was found. NULL otherwise.

--***************************************************************************/
PUL_APP_POOL_PROCESS
UlQueryProcessBinding(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool
    )
{
    PUL_APOOL_PROC_BINDING pBinding;
    PUL_APP_POOL_PROCESS pProcess = NULL;
    KIRQL OldIrql;

    //
    // Sanity check
    //
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );

    UlAcquireSpinLock(&pHttpConnection->BindingSpinLock, &OldIrql);

    pBinding = UlpFindProcBinding(pHttpConnection, pAppPool);

    if (pBinding) {
        pProcess = pBinding->pProcess;
    }

    UlReleaseSpinLock(&pHttpConnection->BindingSpinLock, OldIrql);

    return pProcess;
}


/***************************************************************************++

Routine Description:

    Allocates and builds a UL_APOOL_PROC_BINDING object.

Arguments:

    pAppPool - the lookup key
    pProcess - the binding

Return Values:

    a pointer to the allocated object, or NULL on failure

--***************************************************************************/
PUL_APOOL_PROC_BINDING
UlpCreateProcBinding(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_APOOL_PROC_BINDING pBinding;

    ASSERT( pAppPool->NumberActiveProcesses > 1 );

    //
    // CODEWORK: lookaside
    //

    pBinding = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    UL_APOOL_PROC_BINDING,
                    UL_APOOL_PROC_BINDING_POOL_TAG
                    );

    if (pBinding) {
        pBinding->Signature = UL_APOOL_PROC_BINDING_POOL_TAG;
        pBinding->pAppPool = pAppPool;
        pBinding->pProcess = pProcess;

        UlTrace(ROUTING, (
            "ul!UlpCreateProcBinding(\n"
            "        pAppPool = %p\n"
            "        pProcess = %p )\n"
            "    pBinding = %p\n",
            pAppPool,
            pProcess,
            pBinding
            ));
    }

    return pBinding;
}


/***************************************************************************++

Routine Description:

    Gets rid of a proc binding

Arguments:

    pBinding - the binding to get rid of

--***************************************************************************/
VOID
UlpFreeProcBinding(
    IN PUL_APOOL_PROC_BINDING pBinding
    )
{
    UL_FREE_POOL_WITH_SIG(pBinding, UL_APOOL_PROC_BINDING_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    Searches a connection's list of bindings for one that has the right
    app pool key

Arguments:

    pHttpConnection - the connection to search
    pAppPool        - the key

Return Values:

    The binding if found or NULL if not found.

--***************************************************************************/
PUL_APOOL_PROC_BINDING
UlpFindProcBinding(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool
    )
{
    PLIST_ENTRY pEntry;
    PUL_APOOL_PROC_BINDING pBinding = NULL;

    //
    // Sanity check
    //
    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConnection) );

    pEntry = pHttpConnection->BindingHead.Flink;
    while (pEntry != &pHttpConnection->BindingHead) {

        pBinding = CONTAINING_RECORD(
                        pEntry,
                        UL_APOOL_PROC_BINDING,
                        BindingEntry
                        );

        ASSERT( IS_VALID_PROC_BINDING(pBinding) );

        if (pBinding->pAppPool == pAppPool) {
            //
            // got it!
            //
            break;
        }

        pEntry = pEntry->Flink;
    }

    return pBinding;
}


/***************************************************************************++

Routine Description:

    Removes an HTTP request from all lists and cleans up it's opaque id.

Arguments:

    pRequest - the request to be unlinked

--***************************************************************************/
VOID
UlUnlinkHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    //
    // if we got far enough to deliver the request then
    // unlink it from the app pool. this needs to happen here because the
    // queue'd IRPs keep references to the UL_INTERNAL_REQUEST objects.
    // this kicks their references off and allows them to delete.
    //
    if (pRequest->ConfigInfo.pAppPool)
    {
        UlUnlinkRequestFromProcess(pRequest->ConfigInfo.pAppPool, pRequest);
    }

    //
    // cancel i/o
    //
    if (pRequest->IrpsPending)
    {
        UlCancelRequestIo(pRequest);
    }
    else
    {
        //
        // Mark the request as InCleanup, so additional IRPs
        // on the request will not be queued.
        //
        // Normally UlCancelRequestIo sets this flag, but we
        // have to do it here since we're optimizing that
        // call away.
        //
        pRequest->InCleanup = 1;
    }

    //
    // delete its opaque id
    //

    if (HTTP_IS_NULL_ID(&pRequest->RequestId) == FALSE)
    {
        UlFreeRequestId(pRequest);

        HTTP_SET_NULL_ID(&pRequest->RequestId);

        //
        // it is still referenced by this connection
        //

        ASSERT(pRequest->RefCount > 1);

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    //
    // deref it
    //

    UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
}


//
// Following code has been implemented for Global & Site specific connection
// limits feature. If enforced, incoming  connections get refused  when they
// exceed the existing limit. Control  channel & config group  (re)sets this
// values whereas httprcv and sendresponse  updates the limits  for incoming
// requests & connections. A seperate connection_count_entry structure keeps
// track  of the  limits per site. Global limits  are tracked by the  global
// variables g_MaxConnections &  g_CurrentConnections same API has been used
// for both purposes.
//

/***************************************************************************++

Routine Description:

    Allocates a connection count entry which will hold the site specific
    connection count info. Get called by cgroup when Config group is
    attempting to allocate a connection count entry.

Arguments:

    pConfigGroup - To receive the newly allocated count entry
    MaxConnections - The maximum allowed connections

--***************************************************************************/

NTSTATUS
UlCreateConnectionCountEntry(
      IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup,
      IN     ULONG                   MaxConnections
    )
{
    PUL_CONNECTION_COUNT_ENTRY       pEntry;

    // Sanity check.

    PAGED_CODE();
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    // Alloc new struct from Paged Pool

    pEntry = UL_ALLOCATE_STRUCT(
                PagedPool,
                UL_CONNECTION_COUNT_ENTRY,
                UL_CONNECTION_COUNT_ENTRY_POOL_TAG
                );
    if (!pEntry)
    {
        UlTrace(LIMITS,
          ("Http!UlCreateConnectionCountEntry: OutOfMemory pConfigGroup %p\n",
            pConfigGroup
            ));

        return STATUS_NO_MEMORY;
    }

    pEntry->Signature       = UL_CONNECTION_COUNT_ENTRY_POOL_TAG;
    pEntry->RefCount        = 1;
    pEntry->MaxConnections  = MaxConnections;
    pEntry->CurConnections  = 0;

    // Update cgroup pointer

    ASSERT( pConfigGroup->pConnectionCountEntry == NULL );
    pConfigGroup->pConnectionCountEntry = pEntry;

    UlTrace(LIMITS,
          ("Http!UlCreateConnectionCountEntry: pNewEntry %p, pConfigGroup %p, Max %d\n",
            pEntry,
            pConfigGroup,
            MaxConnections
            ));

    return STATUS_SUCCESS;

} // UlCreateConnectionCountEntry

/***************************************************************************++

Routine Description:

    increments the refcount for ConnectionCountEntry.

Arguments:

    pEntry - the object to increment.

--***************************************************************************/
VOID
UlReferenceConnectionCountEntry(
    IN PUL_CONNECTION_COUNT_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_CONNECTION_COUNT_ENTRY(pEntry) );

    refCount = InterlockedIncrement( &pEntry->RefCount );

    //
    // Tracing.
    //

    WRITE_REF_TRACE_LOG(
        g_pConnectionCountTraceLog,
        REF_ACTION_REFERENCE_CONNECTION_COUNT_ENTRY,
        refCount,
        pEntry,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("Http!UlReferenceConnectionCountEntry pEntry=%p refcount=%d\n",
         pEntry,
         refCount
         ));

}   // UlReferenceConnectionCountEntry

/***************************************************************************++

Routine Description:

    decrements the refcount.  if it hits 0, destruct's ConnectionCountEntry

Arguments:

    pEntry - the object to decrement.

--***************************************************************************/
VOID
UlDereferenceConnectionCountEntry(
    IN PUL_CONNECTION_COUNT_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_CONNECTION_COUNT_ENTRY(pEntry) );

    refCount = InterlockedDecrement( &pEntry->RefCount );

    //
    // Tracing.
    //
    WRITE_REF_TRACE_LOG(
        g_pConnectionCountTraceLog,
        REF_ACTION_DEREFERENCE_CONNECTION_COUNT_ENTRY,
        refCount,
        pEntry,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("Http!UlDereferenceConnectionCountEntry pEntry=%p refcount=%d\n",
         pEntry,
         refCount
         ));

    //
    // Cleanup the memory and do few checks !
    //

    if ( refCount == 0 )
    {
        // Make sure no connection on the site
        ASSERT( 0 == pEntry->CurConnections );

        UlTrace(
            LIMITS,
            ("Http!UlDereferenceConnectionCountEntry: Removing pEntry=%p\n",
             pEntry
             ));

        // Release memory
        UL_FREE_POOL_WITH_SIG(pEntry,UL_CONNECTION_COUNT_ENTRY_POOL_TAG);
    }

} // UlDereferenceConnectionCountEntry

/***************************************************************************++

Routine Description:

    This
    function set the maximum limit. Maximum allowed number of  connections
    at any time by the active control channel.

Arguments:

    MaxConnections - Maximum allowed number of connections

Return Value:

    Old Max Connection count

--***************************************************************************/

ULONG
UlSetMaxConnections(
    IN OUT PULONG  pCurMaxConnection,
    IN     ULONG   NewMaxConnection
    )
{
    ULONG  OldMaxConnection;

    UlTrace(LIMITS,
      ("Http!UlSetMaxConnections pCurMaxConnection=%p NewMaxConnection=%d\n",
        pCurMaxConnection,
        NewMaxConnection
        ));

    //
    // By setting this we are not forcing the existing connections  to
    // termination but this number will be effective for all newcoming
    // connections, as soon as the atomic operation completed.
    //

    OldMaxConnection = (ULONG) InterlockedExchange((LONG *) pCurMaxConnection,
                                                   (LONG)   NewMaxConnection
                                                            );
    return OldMaxConnection;

} // UlSetMaxConnections

/***************************************************************************++

Routine Description:

    Control channel uses this function to set or reset the global connection
    limits.

--***************************************************************************/

VOID
UlSetGlobalConnectionLimit(
    IN ULONG Limit
    )
{
    UlSetMaxConnections( &g_MaxConnections, Limit );
    UlTrace(LIMITS,("Http!UlSetGlobalConnectionLimit: To %d\n", Limit));

} // ULSetGlobalConnectionLimit

/***************************************************************************++

Routine Description:

    Control channel uses this function to initialize the global connection
    limits. Assuming the existince of one and only one active control channel
    this globals get set only once during init. But could be set again later
    because of a reconfig.

--***************************************************************************/

NTSTATUS
UlInitGlobalConnectionLimits(
    VOID
    )
{
    ASSERT(!g_InitGlobalConnections);

    if (!g_InitGlobalConnections)
    {
        g_MaxConnections        = HTTP_LIMIT_INFINITE;
        g_CurrentConnections    = 0;

        UlTrace(LIMITS,
            ("Http!UlInitGlobalConnectionLimits: Init g_MaxConnections %d,"
             "g_CurrentConnections %d\n",
              g_MaxConnections,
              g_CurrentConnections
              ));

        g_InitGlobalConnections = TRUE;
    }

    return STATUS_SUCCESS;

} // UlInitGlobalConnectionLimits

/***************************************************************************++

Routine Description:

    Wrapper around the Accept Connection for global connections

--***************************************************************************/
BOOLEAN
UlAcceptGlobalConnection(
    VOID
    )
{
    return UlAcceptConnection( &g_MaxConnections, &g_CurrentConnections );

} // UlAcceptGlobalConnection

/***************************************************************************++

Routine Description:

    This function checks if we are allowed to accept the incoming connection
    based on the number enforced by the control channel.

Return value:

    Decision for the newcoming connection either ACCEPT or REJECT as boolean

--***************************************************************************/

BOOLEAN
UlAcceptConnection(
    IN     PULONG   pMaxConnection,
    IN OUT PULONG   pCurConnection
    )
{
    ULONG    LocalCur;
    ULONG    LocalCurPlusOne;
    ULONG    LocalMax;

    do
    {
        //
        // Capture the Max & Cur. Do  the comparison. If in the  limit
        // attempt to increment the connection count by ensuring nobody
        // else did it before us.
        //

        LocalMax = *((volatile ULONG *) pMaxConnection);
        LocalCur = *((volatile ULONG *) pCurConnection);

        //
        // Its greater than or equal because Max may get updated  to
        // a smaller number on-the-fly and we end up having  current
        // connections greater than the maximum allowed.
        // NOTE: HTTP_LIMIT_INFINITE has been picked as (ULONG)-1 so
        // following comparison won't reject for the infinite case.
        //

        if ( LocalCur >= LocalMax )
        {
            //
            // We are already at the limit refuse it.
            //

            UlTrace(LIMITS,
                ("Http!UlAcceptConnection REFUSE pCurConnection=%p[%d]"
                 "pMaxConnection=%p[%d]\n",
                  pCurConnection,LocalCur,
                  pMaxConnection,LocalMax
                  ));

            return FALSE;
        }

        //
        // Either the limit was infinite or conn count was not exceeding
        // the limit. Lets attempt to increment the count and accept the
        // connection in the while statement.
        //

        LocalCurPlusOne  = LocalCur + 1;

    }
    while ( LocalCur != (ULONG) InterlockedCompareExchange(
                                        (LONG *) pCurConnection,
                                        (LONG) LocalCurPlusOne,
                                        (LONG) LocalCur
                                        ) );

    //
    // Successfully incremented the counter. Let it go with success.
    //

    UlTrace(LIMITS,
        ("Http!UlAcceptConnection ACCEPT pCurConnection=%p[%d]"
         "pMaxConnection=%p[%d]\n",
          pCurConnection,LocalCur,
          pMaxConnection,LocalMax
          ));

    return TRUE;

} // UlAcceptConnection


/***************************************************************************++

Routine Description:

    Everytime a disconnection happens we will decrement the count here.

Return Value:

    The newly decremented value

--***************************************************************************/

LONG
UlDecrementConnections(
    IN OUT PULONG pCurConnection
    )
{
    LONG NewConnectionCount;

    NewConnectionCount = InterlockedDecrement( (LONG *) pCurConnection );

    ASSERT( NewConnectionCount >= 0 );

    return NewConnectionCount;

} // UlDecrementConnections


/***************************************************************************++

Routine Description:

    For cache & non-cache hits this function get called. Connection  resource
    has assumed to be acquired at this time. The function decide to accept or
    reject the request by looking at the corresponding count entries.

Arguments:

    pConnection - For getting the previous site's connection count entry
    pConfigInfo - Holds a pointer to newly received request's site's
                  connection count entry.
Return Value:

    Shows reject or accept

--***************************************************************************/

BOOLEAN
UlCheckSiteConnectionLimit(
    IN OUT PUL_HTTP_CONNECTION pConnection,
    IN OUT PUL_URL_CONFIG_GROUP_INFO pConfigInfo
    )
{
    BOOLEAN Accept;
    PUL_CONNECTION_COUNT_ENTRY pConEntry;
    PUL_CONNECTION_COUNT_ENTRY pCIEntry;

    if (pConfigInfo->pMaxConnections == NULL || pConfigInfo->pConnectionCountEntry == NULL)
    {
        //
        // No connection count entry for the new request perhaps WAS never
        // set this before otherwise its a problem.
        //

        UlTrace(LIMITS,
          ("Http!UlCheckSiteConnectionLimit: NO LIMIT pConnection=%p pConfigInfo=%p\n",
            pConnection,
            pConfigInfo
            ));

        return TRUE;
    }

    ASSERT(IS_VALID_CONNECTION_COUNT_ENTRY(pConfigInfo->pConnectionCountEntry));

    pCIEntry  = pConfigInfo->pConnectionCountEntry;
    pConEntry = pConnection->pConnectionCountEntry;
    Accept    = FALSE;

    //
    // Make a check on the connection  limit of the site. Refuse the request
    // if the limit is exceded.
    //
    if (pConEntry)
    {
        ASSERT(IS_VALID_CONNECTION_COUNT_ENTRY(pConEntry));

        //
        // For consecutive requests we decrement the previous site's  connection count
        // before proceeding to the decision on the newcoming request,if the two sides
        // are not same.That means we assume this connection on site x until (if ever)
        // a request changes this to site y. Naturally until the first request arrives
        // and successfully parsed, the connection does not count to any specific site
        //

        if (pConEntry != pCIEntry)
        {
            UlDecrementConnections(&pConEntry->CurConnections);
            DEREFERENCE_CONNECTION_COUNT_ENTRY(pConEntry);

            //
            // We do not increment the connection here yet, since the AcceptConnection
            // will decide and do that.
            //

            REFERENCE_CONNECTION_COUNT_ENTRY(pCIEntry);
            pConnection->pConnectionCountEntry = pCIEntry;
        }
        else
        {
            //
            // There was an old entry, that means this connection already got through.
            // And the entry hasn't been changed with this new request.
            // No need to check again, our design is not forcing existing connections
            // to disconnect.
            //

            return TRUE;
        }
    }
    else
    {
        REFERENCE_CONNECTION_COUNT_ENTRY(pCIEntry);
        pConnection->pConnectionCountEntry = pCIEntry;
    }

    Accept = UlAcceptConnection(
                &pConnection->pConnectionCountEntry->MaxConnections,
                &pConnection->pConnectionCountEntry->CurConnections
                );

    if (Accept == FALSE)
    {
        // We are going to refuse. Let our  ref & refcount go  away
        // on the connection etry to prevent the possible incorrect
        // decrement in the UlConnectionDestroyedWorker. If refused
        // current connection hasn't been incremented in the accept
        // connection. Perf counters also depends on the fact  that
        // pConnectionCountEntry will be Null when con got  refused

        DEREFERENCE_CONNECTION_COUNT_ENTRY(pConnection->pConnectionCountEntry);
        pConnection->pConnectionCountEntry = NULL;
    }

    return Accept;

} // UlCheckSiteConnectionLimit


#ifdef REUSE_CONNECTION_OPAQUE_ID
/***************************************************************************++

Routine Description:

    Allocate a request opaque ID.

Return Value:

    NT_SUCCESS

--***************************************************************************/

NTSTATUS
UlAllocateRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    PUL_HTTP_CONNECTION pConnection;
    KIRQL OldIrql;

    PAGED_CODE();

    pConnection = pRequest->pHttpConn;

    UlAcquireSpinLock(&pConnection->RequestIdSpinLock, &OldIrql);
    pConnection->pRequestIdContext = pRequest;
    UlReleaseSpinLock(&pConnection->RequestIdSpinLock, OldIrql);

    pRequest->RequestId = pConnection->ConnectionId;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Free a request opaque ID.

Return Value:

    VOID

--***************************************************************************/

VOID
UlFreeRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    PUL_HTTP_CONNECTION pConnection;
    KIRQL OldIrql;

    PAGED_CODE();

    pConnection = pRequest->pHttpConn;

    UlAcquireSpinLock(&pConnection->RequestIdSpinLock, &OldIrql);
    pConnection->pRequestIdContext = NULL;
    UlReleaseSpinLock(&pConnection->RequestIdSpinLock, OldIrql);

    return;
}


/***************************************************************************++

Routine Description:

    Get a request from the connection opaque ID.

Return Value:

    PUL_INTERNAL_REQUEST

--***************************************************************************/

PUL_INTERNAL_REQUEST
UlGetRequestFromId(
    IN HTTP_REQUEST_ID RequestId
    )
{
    PUL_HTTP_CONNECTION pConnection;
    PUL_INTERNAL_REQUEST pRequest;
    KIRQL OldIrql;

    PAGED_CODE();

    pConnection = UlGetConnectionFromId(RequestId);

    if (pConnection != NULL)
    {
        UlAcquireSpinLock(&pConnection->RequestIdSpinLock, &OldIrql);

        pRequest = pConnection->pRequestIdContext;

        if (pRequest != NULL)
        {
            UL_REFERENCE_INTERNAL_REQUEST(pRequest);
        }

        UlReleaseSpinLock(&pConnection->RequestIdSpinLock, OldIrql);

        UL_DEREFERENCE_HTTP_CONNECTION(pConnection);

        return pRequest;
    }

    return NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httpconnp.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    httpconnp.h

Abstract:

    This module contains private declarations for manipulation of
    HTTP_CONNECTION objects.

Author:

    Eric Stenson (ericsten)       01-Nov-2000

Revision History:

--*/

#ifndef __HTTPCONNP_H__
#define __HTTPCONNP_H__

//
// private types
//

//
// for binding connections to app pool processes
//

#define IS_VALID_PROC_BINDING(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_APOOL_PROC_BINDING_POOL_TAG))

typedef struct _UL_APOOL_PROC_BINDING
{
    ULONG                   Signature;      // UL_APOOL_PROC_BINDING_POOL_TAG
    LIST_ENTRY              BindingEntry;

    PUL_APP_POOL_OBJECT     pAppPool;
    PUL_APP_POOL_PROCESS    pProcess;
} UL_APOOL_PROC_BINDING, *PUL_APOOL_PROC_BINDING;

#ifdef __cplusplus

extern "C" {
#endif // __cplusplus

//
// Private prototypes.
//

PUL_APOOL_PROC_BINDING
UlpCreateProcBinding(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_APP_POOL_PROCESS pProcess
    );

VOID
UlpFreeProcBinding(
    IN PUL_APOOL_PROC_BINDING pBinding
    );

PUL_APOOL_PROC_BINDING
UlpFindProcBinding(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool
    );

#ifdef __cplusplus

}; // extern "C"
#endif // __cplusplus

#endif // __HTTPCONNP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httprcv.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httprcv.h

Abstract:

    Contains public http receive declarations.

Author:

    Henry Sanders (henrysa)       10-Jun-1998

Revision History:

--*/

#ifndef _HTTPRCV_H_
#define _HTTPRCV_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOLEAN
UlConnectionRequest(
    IN PVOID pListeningContext,
    IN PUL_CONNECTION pConnection,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    OUT PVOID *ppConnectionContext
    );

VOID
UlConnectionComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    );

VOID
UlConnectionDisconnect(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    );

VOID
UlConnectionDisconnectComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

VOID
UlConnectionDestroyed(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

NTSTATUS
UlHttpReceive(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN PVOID pVoidBuffer,
    IN ULONG BufferLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pBytesTaken
    );

NTSTATUS
UlReceiveEntityBody(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP pIrp
    );

VOID
UlResumeParsing(
    IN PUL_HTTP_CONNECTION  pConnection
    );

NTSTATUS
UlGetCGroupForRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    );

NTSTATUS
UlInitializeHttpRcv();

VOID
UlTerminateHttpRcv();

VOID
UlSendErrorResponse(
    IN PUL_HTTP_CONNECTION pConnection
    );

ULONG
UlSendSimpleStatus(
    PUL_INTERNAL_REQUEST pRequest,
    UL_HTTP_SIMPLE_STATUS Response
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _HTTPRCV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httprcvp.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    httprcvp.h

Abstract:

    Contains private http receive declarations.

Author:

    Henry Sanders (henrysa)       10-Jun-1998

Revision History:

--*/

#ifndef _HTTPRCVP_H_
#define _HTTPRCVP_H_

#ifdef __cplusplus
extern "C" {
#endif


VOID
UlpHandleRequest(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpParseNextRequest(
    IN PUL_HTTP_CONNECTION pConnection
    );

NTSTATUS
UlpDeliverHttpRequest(
    IN PUL_HTTP_CONNECTION pConnection,
    OUT PBOOLEAN pResponseSent
    );

VOID
UlpInsertBuffer(
    IN PUL_HTTP_CONNECTION pConnection,
    IN PUL_REQUEST_BUFFER pRequestBuffer
    );

VOID
UlpMergeBuffers(
    IN PUL_REQUEST_BUFFER pDest,
    IN PUL_REQUEST_BUFFER pSrc
    );

NTSTATUS
UlpAdjustBuffers(
    IN PUL_HTTP_CONNECTION pConnection
    );

VOID
UlpProcessBufferQueue(
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlpCancelEntityBody(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelEntityBodyWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCompleteSendResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartSendSimpleStatus(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpSendSimpleCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpConsumeBytesFromConnection(
    IN PUL_HTTP_CONNECTION pConnection,
    IN ULONG ByteCount
    );

VOID
UlpRestartHttpReceive(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpDiscardBytesFromConnection(
    IN PUL_HTTP_CONNECTION pConnection
    );

VOID
UlConnectionDisconnectWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

#if DBG
BOOLEAN
UlpIsValidRequestBufferList(
    IN PUL_HTTP_CONNECTION pHttpConn
    );
#endif // DBG

#define ALLOC_REQUEST_BUFFER_INCREMENT  5

BOOLEAN
UlpReferenceBuffers(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_REQUEST_BUFFER pRequestBuffer
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _HTTPRCVP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httptdi.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    httptdi.cxx

Abstract:

    This module implements the TDI/MUX/SSL component that is common between
    ultdi and uctdi

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UxInitializeTdi )
#pragma alloc_text( PAGE, UxTerminateTdi )
#pragma alloc_text( PAGE, UxOpenTdiAddressObject )
#pragma alloc_text( PAGE, UxOpenTdiConnectionObject )
#pragma alloc_text( PAGE, UxpOpenTdiObjectHelper )
#pragma alloc_text( PAGE, UxSetEventHandler )

#endif

#if 0

NOT PAGEABLE - UxCreateDisconnectIrp
NOT PAGEABLE - UxInitializeDisconnectIrp

#endif

//
// Timeout for disconnects. This cannot be a stack-based local,
// so we make it a global.
//
BOOLEAN         g_UxTdiInitialized;
UNICODE_STRING  g_TransportDeviceName;  // global transport device name
LARGE_INTEGER   g_TdiDisconnectTimeout;

/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxInitializeTdi(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( !g_UxTdiInitialized );

    RtlInitUnicodeString(
        &g_TransportDeviceName,
        TCP_DEVICE_NAME // CODEWORK : Make this configurable ?
        );

    g_TdiDisconnectTimeout = RtlConvertLongToLargeInteger( -1 );

    g_UxTdiInitialized = TRUE;

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Performs global termination of this module.

--***************************************************************************/
VOID
UxTerminateTdi(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    if (g_UxTdiInitialized)
    {
    }

}   // UxTerminateTdi


/***************************************************************************++

Routine Description:

    Opens a TDI address object.

Arguments:

    pTransportDeviceName - Supplies the device name of the TDI transport
        to open.

    pLocalAddress - Supplies the local address to bind to.

    LocalAddressLength - Supplies the length of pLocalAddress.

    pTdiObject - Receives the file handle, referenced FILE_OBJECT
        pointer, and corresponding DEVICE_OBJECT pointer.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxOpenTdiAddressObject(
    IN PTRANSPORT_ADDRESS pLocalAddress,
    IN ULONG LocalAddressLength,
    OUT PUX_TDI_OBJECT pTdiObject
    )
{
    NTSTATUS status;
    PFILE_FULL_EA_INFORMATION pEaInfo;
    ULONG eaLength;
    UCHAR eaBuffer[MAX_ADDRESS_EA_BUFFER_LENGTH];

    //
    // Sanity check.
    //

    PAGED_CODE();

    eaLength = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
        TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
        LocalAddressLength;

    ASSERT( eaLength <= sizeof(eaBuffer) );
    ASSERT( LocalAddressLength == sizeof(TA_IP_ADDRESS) );
    ASSERT( pLocalAddress->TAAddressCount == 1 );
    ASSERT( pLocalAddress->Address[0].AddressLength == sizeof(TDI_ADDRESS_IP) );
    ASSERT( pLocalAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP );

    //
    // Initialize the EA buffer. See UxpOpenTdiObjectHelper() for the
    // gory details.
    //

    pEaInfo = (PFILE_FULL_EA_INFORMATION)eaBuffer;

    pEaInfo->NextEntryOffset = 0;
    pEaInfo->Flags = 0;
    pEaInfo->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    pEaInfo->EaValueLength = (USHORT)LocalAddressLength;

    RtlMoveMemory(
        pEaInfo->EaName,
        TdiTransportAddress,
        pEaInfo->EaNameLength + 1
        );

    RtlMoveMemory(
        &pEaInfo->EaName[pEaInfo->EaNameLength + 1],
        pLocalAddress,
        LocalAddressLength
        );

    //
    // Let the helper do the dirty work.
    //

    status = UxpOpenTdiObjectHelper(
                    &g_TransportDeviceName,
                    eaBuffer,
                    eaLength,
                    pTdiObject
                    );

    return status;

}   // UxpOpenTdiAddressObject


/***************************************************************************++

Routine Description:

    Opens a TDI connection object.

Arguments:

    pTransportDeviceName - Supplies the device name of the TDI transport
        to open.

    pConnectionContext - Supplies the context to associate with the
        new connection.

    pTdiObject - Receives the file handle, referenced FILE_OBJECT
        pointer, and corresponding DEVICE_OBJECT pointer.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxOpenTdiConnectionObject(
    IN CONNECTION_CONTEXT pConnectionContext,
    OUT PUX_TDI_OBJECT pTdiObject
    )
{
    NTSTATUS status;
    PFILE_FULL_EA_INFORMATION pEaInfo;
    ULONG eaLength;
    UCHAR eaBuffer[MAX_CONNECTION_EA_BUFFER_LENGTH];

    //
    // Sanity check.
    //

    PAGED_CODE();

    eaLength = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
        TDI_CONNECTION_CONTEXT_LENGTH + 1 +
        sizeof(pConnectionContext);

    ASSERT( eaLength <= sizeof(eaBuffer) );
    ASSERT( pConnectionContext != NULL );

    //
    // Initialize the EA buffer. See UxpOpenTdiObjectHelper() for the
    // gory details.
    //

    pEaInfo = (PFILE_FULL_EA_INFORMATION)eaBuffer;

    pEaInfo->NextEntryOffset = 0;
    pEaInfo->Flags = 0;
    pEaInfo->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    pEaInfo->EaValueLength = (USHORT)sizeof(CONNECTION_CONTEXT);

    RtlMoveMemory(
        pEaInfo->EaName,
        TdiConnectionContext,
        pEaInfo->EaNameLength + 1
        );

    RtlMoveMemory(
        &pEaInfo->EaName[pEaInfo->EaNameLength + 1],
        &pConnectionContext,
        sizeof(pConnectionContext)
        );

    //
    // Let the helper do the dirty work.
    //

    status = UxpOpenTdiObjectHelper(
                    &g_TransportDeviceName,
                    eaBuffer,
                    eaLength,
                    pTdiObject
                    );

    if (NT_SUCCESS(status))
    {
        //
        // Enable/disable Nagle's Algorithm as appropriate.
        //

        status = UlpSetNagling( pTdiObject, g_UlEnableNagling );

        if (!NT_SUCCESS(status))
        {
            UxCloseTdiObject( pTdiObject );
        }
    }

    return status;

}   // UxpOpenTdiConnectionObject


/***************************************************************************++

Routine Description:

    Helper routine for UxpOpenTdiAddressObject and
    UxpOpenTdiConnectionObject.

Arguments:

    pTransportDeviceName - Supplies the device name of the TDI transport
        to open.

    pEaBuffer - Supplies a pointer to the EA to use when opening
        the object. This buffer consists of a FILE_FULL_EA_INFORMATION
        structure, followed by the EA Name, followed by the EA Value.
        The EA Name and Value are use as follows:

            Address Object:
                Ea Name  = TdiTransportAddress ("TransportAddress")
                Ea Value = The local TRANSPORT_ADDRESS to bind to

            Connection Object:
                Ea Name  = TdiConnectionContext ("ConnectionContext")
                Ea Value = The connection context (basically a PVOID)

    EaLength - Supplies the length of pEaBuffer.

    pTdiObject - Receives the file handle, referenced FILE_OBJECT
        pointer, and corresponding DEVICE_OBJECT pointer.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxpOpenTdiObjectHelper(
    IN PUNICODE_STRING pTransportDeviceName,
    IN PVOID pEaBuffer,
    IN ULONG EaLength,
    OUT PUX_TDI_OBJECT pTdiObject
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Open the TDI object.
    //

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        pTransportDeviceName,                   // ObjectName
        OBJ_CASE_INSENSITIVE |                  // Attributes
            UL_KERNEL_HANDLE,
        NULL,                                   // RootHandle
        NULL                                    // SecurityDescriptor
        );

    UlAttachToSystemProcess();

    status = IoCreateFile(
                 &pTdiObject->Handle,           // FileHandle
                 GENERIC_READ |                 // DesiredAccess
                    GENERIC_WRITE |
                    SYNCHRONIZE,
                 &objectAttributes,             // ObjectAttributes
                 &ioStatusBlock,                // IoStatusBlock
                 NULL,                          // AllocationSize
                 0,                             // FileAttributes
                 0,                             // ShareAccess
                 0,                             // Disposition
                 0,                             // CreateOptions
                 pEaBuffer,                     // EaBuffer
                 EaLength,                      // EaLength
                 CreateFileTypeNone,            // CreateFileType
                 NULL,                          // ExtraCreateParameters
                 IO_NO_PARAMETER_CHECKING       // Options
                 );

    if (NT_SUCCESS(status))
    {
        //
        // Now that we have an open handle to the transport,
        // reference it so we can get the file & device object
        // pointers.
        //

        status = ObReferenceObjectByHandle(
                     pTdiObject->Handle,                // Handle
                     0,                                 // DesiredAccess
                     *IoFileObjectType,                 // ObjectType
                     KernelMode,                        // AccessMode
                     (PVOID *)&pTdiObject->pFileObject, // Object
                     NULL                               // HandleInformation
                     );

        if (NT_SUCCESS(status))
        {
            //
            // Chase down the appropriate device object for the file
            // object.
            //

            pTdiObject->pDeviceObject =
                IoGetRelatedDeviceObject( pTdiObject->pFileObject );

            UlDetachFromSystemProcess();

            return status;
        }

        //
        // The ObReferenceObjectByHandle() failed, so close the handle
        // we managed to open & fail the call.
        //

        ZwClose( pTdiObject->Handle );
    }

    UlDetachFromSystemProcess();

    RtlZeroMemory(
        pTdiObject,
        sizeof(*pTdiObject)
        );

    return status;

}   // UxpOpenTdiObjectHelper

/***************************************************************************++

Routine Description:

    Establishes a TDI event handler for the specified endpoint.

Arguments:

    pEndpoint - Supplies the endpoint for which to set the event handler.

    EventType - Supplies the type of event to set. This should be one
        of the TDI_EVENT_* values.

    pEventHandler - Supplies a pointer to the indication handler function
        to be invoked for the specified event type.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxSetEventHandler(
    IN PUX_TDI_OBJECT  pUlTdiObject,
    IN ULONG           EventType,
    IN PVOID           pEventHandler,
    IN PVOID           pEventContext

    )
{
    NTSTATUS                     status;
    TDI_REQUEST_KERNEL_SET_EVENT eventParams;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Build the parameter block.
    //

    eventParams.EventType    = EventType;
    eventParams.EventHandler = pEventHandler;
    eventParams.EventContext = pEventContext;

    //
    // Make the call.
    //

    status = UlIssueDeviceControl(
                    pUlTdiObject,               // pTdiObject
                    &eventParams,               // pIrpParameters
                    sizeof(eventParams),        // IrpParamtersLength
                    NULL,                       // pMdlBuffer
                    0,                          // MdlBufferLength
                    TDI_SET_EVENT_HANDLER       // MinorFunction
                    );

    return status;

}   // UxSetEventHandler

/***************************************************************************++

Routine Description:

    Allocates & initializes a new disconnect IRP.

Arguments:

    pConnection - Supplies the UC_CONNECTION to be disconnected.

    Flags - Supplies the TDI_DISCONNECT_* flags for the IRP.

    pCompletionRoutine - Supplies the completion routine for the IRP.

    pCompletionContext - Supplies an uninterpreted context for the
        completion routine.

Return Value:

    PIRP - Pointer to the IRP if successful, NULL otherwise.

--***************************************************************************/
PIRP
UxCreateDisconnectIrp(
    IN PUX_TDI_OBJECT         pTdiObject,
    IN ULONG_PTR              Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    PIRP pIrp;

    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    //
    // Allocate an IRP for the disconnect.
    //

    pIrp = UlAllocateIrp(
                pTdiObject->pDeviceObject->StackSize,   // StackSize
                FALSE                                   // ChargeQuota
                );

    if (pIrp != NULL)
    {
        UxInitializeDisconnectIrp(
            pIrp,
            pTdiObject,
            Flags,
            pCompletionRoutine,
            pCompletionContext
            );
    }

    return pIrp;

}   // UxCreateDisconnectIrp

/***************************************************************************++

Routine Description:

    Initializes a disconnect IRP.

Arguments:

    pIrp - Supplies the disconnect IRP.

    pConnection - Supplies the UC_CONNECTION to be disconnected.

    Flags - Supplies the TDI_DISCONNECT_* flags for the IRP.

    pCompletionRoutine - Supplies the completion routine for the IRP.

    pCompletionContext - Supplies an uninterpreted context for the
        completion routine.

Return Value:

    None

--***************************************************************************/
VOID
UxInitializeDisconnectIrp(
    IN PIRP                   pIrp,
    IN PUX_TDI_OBJECT         pTdiObject,
    IN ULONG_PTR              Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );
    ASSERT( pIrp != NULL );

    //
    // Initialize the IRP. Note that IRPs are always zero-initialized
    // when allocated. Therefore, we don't need to explicitly set
    // the zeroed fields.
    //

    pIrp->RequestorMode = KernelMode;

    pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
    pIrp->Tail.Overlay.OriginalFileObject = pTdiObject->pFileObject;

    TdiBuildDisconnect(
        pIrp,                               // Irp
        pTdiObject->pDeviceObject,          // DeviceObject
        pTdiObject->pFileObject,            // FileObject
        pCompletionRoutine,                 // CompletionRoutine
        pCompletionContext,                 // CompletionContext
        &g_TdiDisconnectTimeout,            // Timeout
        Flags,                              // Flags
        NULL,                               // RequestConnectionInfo
        NULL                                // ReturnConnectionInfo
        );

}   // UxInitializeDisconnectIrp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httptypes.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httptypes.h

Abstract:

    The definition of HTTP specific types

Author:

    Henry Sanders (henrysa)     July-1998 started

Revision History:

    Paul McDaniel (paulmcd)     3-March-1999 massive updates / rewrite

--*/


#ifndef _HTTPTYPES_H_
#define _HTTPTYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Forwarders.
//

typedef struct _UL_CONNECTION *PUL_CONNECTION;
typedef struct _UL_URI_CACHE_ENTRY *PUL_URI_CACHE_ENTRY;
typedef struct _UL_FULL_TRACKER *PUL_FULL_TRACKER;


#define VERSION_SIZE            (sizeof("HTTP/1.1") - 1)

//
// the largest name that can fit as an knownheader (3 ULONGLONG's)
//
#define MAX_KNOWN_HEADER_SIZE   24

#define CR          0x0D
#define LF          0x0A
#define SP          0x20
#define HT          0x09

#define CRLF_SIZE   2
#define CRLF        0x0A0D          // Reversed for endian switch
#define LFLF        0x0A0A

#define UPCASE_CHAR(c)  ((c) & 0xdf)
#define LOCASE_CHAR(c)  ((c) | ~0xdf)

#define MAX_PORT_LENGTH     5  // 2^16 = 65536 = 5 chars = 5 bytes

//
//                         255  .  255  .  255  .  255  :   port
//
#define MAX_ADDRESS_LENGTH  (3 + 1 + 3 + 1 + 3 + 1 + 3 + 1 + MAX_PORT_LENGTH)

#define HTTP_DATE_COUNT 29

//
// Response constants
//


//
// parser error returns, these need to match the order of
// UL_HTTP_ERROR_ENTRY ErrorTable[] in httprcv.cxx
//

typedef enum _UL_HTTP_ERROR
{
    UlError,
    UlErrorVerb,
    UlErrorUrl,
    UlErrorHeader,
    UlErrorHost,
    UlErrorCRLF,
    UlErrorNum,
    UlErrorFieldLength,
    UlErrorUrlLength,
    UlErrorRequestLength,
    UlErrorVersion,
    UlErrorUnavailable,
    UlErrorContentLength,
    UlErrorEntityTooLarge,
    UlErrorConnectionLimit,
    UlErrorNotImplemented,
    UlErrorInternalServer,
    UlErrorPreconditionFailed,
    UlErrorForbiddenUrl,

} UL_HTTP_ERROR;

//
// HTTP responses which do not have a Content-Length and are
// terminated by the first empty line after the header fields.
// [RFC 2616, sec 4.4]
// NOTE: these need to match the order of
// UL_HTTP_SIMPLE_STATUS_ENTRY StatusTable[] in httprcv.c
//

typedef enum _UL_HTTP_SIMPLE_STATUS
{
    UlStatusContinue = 0,   // 100 Continue
    UlStatusNoContent,      // 204 No Content
    UlStatusNotModified,    // 304 Not Modified

    UlStatusMaxStatus

} UL_HTTP_SIMPLE_STATUS;


//
// The enum type for our parse state.
//
// note:  the order of the enum values are important as code
// uses < and > operators for comparison. keep the order the exact
// order the parse moves through.
//

typedef enum _PARSE_STATE
{
    ParseVerbState = 1,
    ParseUrlState = 2,
    ParseVersionState = 3,
    ParseHeadersState = 4,
    ParseCookState = 5,
    ParseEntityBodyState = 6,
    ParseTrailerState = 7,

    ParseDoneState = 8,
    ParseErrorState = 9

} PARSE_STATE, *PPARSE_STATE;

//
// An enum type for tracking the app pool queue state of requests
//
typedef enum _QUEUE_STATE
{
    QueueUnroutedState,         // request has not yet been routed to an app pool
    QueueDeliveredState,        // request is waiting at app pool for an IRP
    QueueCopiedState,           // request has been copied to user mode
    QueueUnlinkedState          // request has been unlinked from app pool

} QUEUE_STATE, *PQUEUE_STATE;

//
// The enum type of connection timers in a UL_TIMEOUT_INFO_ENTRY.
//
// NOTE: must be kept in sync with g_aTimeoutTimerNames
//
typedef enum _CONNECTION_TIMEOUT_TIMER
{
    TimerConnectionIdle = 0,    // Server Listen timeout
    TimerHeaderWait,            // Header Wait timeout
    TimerMinKBSec,              // Minimum Bandwidth not met (as timer value)
    TimerEntityBody,            // Entity Body receive
    TimerResponse,              // Response processing (user-mode)

    TimerMaximumTimer

} CONNECTION_TIMEOUT_TIMER;

#define IS_VALID_TIMEOUT_TIMER(a) \
    (((a) >= TimerConnectionIdle) && ((a) < TimerMaximumTimer))

//
// Contained structure.  Not allocated on its own; therefore does not have
// a Signature or ref count.  No allocation or freeing functions provided,
// however, there is an UlInitalizeTimeoutInfo() function.
//

typedef struct _UL_TIMEOUT_INFO_ENTRY {

    UL_SPIN_LOCK    Lock;

    //
    // Wheel state
    //

    LIST_ENTRY      QueueEntry;

    LIST_ENTRY      ZombieEntry;

    ULONG           SlotEntry;						// Timer Wheel Slot


    //
    // Timer state
    //

    ULONG           Timers[ TimerMaximumTimer ];	// Timer Wheel Ticks

    CONNECTION_TIMEOUT_TIMER  CurrentTimer;

    ULONG           CurrentExpiry;				    // Timer Wheel Ticks

    LONGLONG        MinKBSecSystemTime;			    // SystemTime


    //
    // Per-site ConnectionTimeout value
    //

    LONGLONG     ConnectionTimeoutValue;

} UL_TIMEOUT_INFO_ENTRY, *PUL_TIMEOUT_INFO_ENTRY;


//
// Structure we use for tracking headers from incoming requests. The pointer
// points into a buffer we received from the transport, unless the OurBuffer
// flag is set, which indicates we had to allocate a buffer and copy the header
// due to multiple occurences of the header or a continuation line.
//
typedef struct _UL_HTTP_HEADER
{
    PUCHAR      pHeader;

    ULONG       HeaderLength;

    ULONG       OurBuffer:1;
    ULONG       ExternalAllocated:1;

} UL_HTTP_HEADER, *PUL_HTTP_HEADER;

//
// Structure we use for tracking unknown headers. These structures are
// dyanmically allocated when we see an unknown header.
//
typedef struct _UL_HTTP_UNKNOWN_HEADER
{
    LIST_ENTRY      List;
    ULONG           HeaderNameLength;
    PUCHAR          pHeaderName;
    UL_HTTP_HEADER  HeaderValue;

} UL_HTTP_UNKNOWN_HEADER, *PUL_HTTP_UNKNOWN_HEADER;

//
// forward delcarations
//

typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_HTTP_CONNECTION *PUL_HTTP_CONNECTION;
typedef struct _UL_CONNECTION_COUNT_ENTRY *PUL_CONNECTION_COUNT_ENTRY;
typedef struct _UL_APP_POOL_PROCESS *PUL_APP_POOL_PROCESS;

typedef struct _UL_TCI_FLOW *PUL_TCI_FLOW;
typedef struct _UL_TCI_FILTER *PUL_TCI_FILTER;

//
// Structure we use for a copy of the data from the transport's buffer.
//

#define UL_IS_VALID_REQUEST_BUFFER(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_REQUEST_BUFFER_POOL_TAG))

#define GET_REQUEST_BUFFER_POS(pRequestBuffer) \
    (pRequestBuffer->pBuffer + pRequestBuffer->ParsedBytes)

#define UNPARSED_BUFFER_BYTES(pRequestBuffer) \
    (pRequestBuffer->UsedBytes - pRequestBuffer->ParsedBytes)

typedef struct _UL_REQUEST_BUFFER
{
    //
    // NonPagedPool
    //

    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SINGLE_LIST_ENTRY   LookasideEntry;

    //
    // UL_REQUEST_BUFFER_POOL_TAG
    //
    ULONG               Signature;

    //
    // References of the request buffer, mainly used for logging purpose.
    //
    LONG                RefCount;

    //
    // for linking on the pConnection->BufferHead
    //
    LIST_ENTRY          ListEntry;

    //
    // the connection
    //
    PUL_HTTP_CONNECTION pConnection;

    //
    // for queue'ing
    //
    UL_WORK_ITEM        WorkItem;

    //
    // how many bytes are stored
    //
    ULONG               UsedBytes;

    //
    // how many bytes are allocated from the pool
    //
    ULONG               AllocBytes;

    //
    // how many bytes have been consumed by the parser
    //
    ULONG               ParsedBytes;

    //
    // the sequence number
    //
    ULONG               BufferNumber;

    //
    // whether or not this was specially allocated (for large requests)
    //
    ULONG               JumboBuffer : 1;

    //
    // the actual buffer space (inline)
    //
    UCHAR               pBuffer[0];

} UL_REQUEST_BUFFER, *PUL_REQUEST_BUFFER;

//
// Structure used for tracking an HTTP connection, which may represent
// either a real TCP connection or a virtual MUX connection.
//

#define UL_IS_VALID_HTTP_CONNECTION(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_HTTP_CONNECTION_POOL_TAG) && ((pObject)->RefCount > 0))

typedef struct _UL_HTTP_CONNECTION
{
    //
    // NonPagedPool
    //

    //
    // UL_HTTP_CONNECTION_POOL_TAG
    //
    ULONG               Signature;

    //
    // Opaque ID for this connection.
    //
    HTTP_CONNECTION_ID  ConnectionId;

    //
    // to perform the destructor at lower irql
    //
    UL_WORK_ITEM        WorkItem;

    //
    // A work item, used to process disconnect notification
    //
    UL_WORK_ITEM        DisconnectWorkItem;

    //
    // Reference count of this connection.
    //
    LONG                RefCount;

    //
    // Total SendBufferedBytes for this connection; modeled after SO_SNDBUF
    // option of WinSocket.
    //
    LONG                SendBufferedBytes;

    //
    // sequence number for the next UL_INTERNAL_REQUEST that comes in.
    //
    ULONG               NextRecvNumber;

    //
    // sequence number for the next buffer received from TDI
    //
    ULONG               NextBufferNumber;

    //
    // sequence number for the next buffer to parse
    //
    ULONG               NextBufferToParse;

    //
    // Associated TDI connection
    //
    PUL_CONNECTION      pConnection;

    //
    // Secure connection flag.
    //
    BOOLEAN             SecureConnection;

    //
    // The current request being parsed
    //
    PUL_INTERNAL_REQUEST    pRequest;

    //
    // to synchro UlpHandleRequest
    //
    UL_ERESOURCE        Resource;

    //
    // links all buffered transport packets
    //
    LIST_ENTRY          BufferHead;

    //
    // links to app pool process binding structures
    //
    LIST_ENTRY          BindingHead;

    //
    // protects the above list
    //
    UL_SPIN_LOCK        BindingSpinLock;

    //
    // Connection Timeout Information block
    //
    UL_TIMEOUT_INFO_ENTRY TimeoutInfo;

    //
    // the current buffer (from BufferHead) that we are parsing
    //
    PUL_REQUEST_BUFFER  pCurrentBuffer;

    //
    // Connection remembers the last visited site's connection count
    // using this pointer.
    //
    PUL_CONNECTION_COUNT_ENTRY pConnectionCountEntry;

    //
    // previous Site Counter block (ref counted); so we can detect
    // when we transition across sites & set the active connection 
    // count apropriately
    //
    PUL_SITE_COUNTER_ENTRY pPrevSiteCounters;

    //
    // If BWT is enabled on site that we receive a request
    // we will keep pointers to corresponding flow & filters
    // as well as a bit field to show that. Once the BWT is
    // enabled we will keep this state until connection drops
    //
    PUL_TCI_FLOW        pFlow;

    PUL_TCI_FILTER      pFilter;

    // First time we install a flow we set this
    //
    ULONG               BandwidthThrottlingEnabled : 1;

    //
    // set if a protocol token span buffers
    //
    ULONG               NeedMoreData : 1;

    //
    // set if the ul connection has been destroyed
    //
    ULONG               UlconnDestroyed : 1;

    //
    // set if we have dispatched a request and
    // are now waiting for the response
    //
    ULONG               WaitingForResponse : 1;

    //
    // List of pending "wait for disconnect" IRPs.
    // Note: This list and the DisconnectFlag are synchronized by
    // g_pUlNonpagedData->DisconnectResource.
    //
    UL_NOTIFY_HEAD WaitForDisconnectHead;

    //
    // Flag set after the underlying network connection has been
    // disconnected.
    //

    BOOLEAN DisconnectFlag;

    //
    // Data for tracking buffered entity data which we use to
    // decide when to stop and restart TDI indications.
    //
    struct {

        //
        // Synchronizes the structure which is accessed from UlHttpReceive
        // at DPC and when we copy some entity to user mode.
        //

        UL_SPIN_LOCK    BufferingSpinLock;

        //
        // Count of bytes we have buffered on the connection.
        //

        ULONG           BytesBuffered;

        //
        // Count of bytes indicated to us by TDI but not buffered on
        // the connection.
        //

        ULONG           TransportBytesNotTaken;

        //
        // Flag indicating that we have a Read IRP pending which may
        // restart the flow of transport data.
        //

        BOOLEAN         ReadIrpPending;

        //
        // Once a connection get disconnected gracefuly and if there is
        // still unreceived data on it. We mark this state and start
        // draining the unreceived data. Otherwise transport won't give us
        // the disconnect indication which we depend on for cleaning up the
        // connection.
        //

        BOOLEAN         DrainAfterDisconnect;

    } BufferingInfo;

    //
    // The request ID context and the lock that protects the context.
    //

    PUL_INTERNAL_REQUEST    pRequestIdContext;
    UL_SPIN_LOCK            RequestIdSpinLock;

#if REFERENCE_DEBUG
    //
    // Reference trace log.
    //

    PTRACE_LOG          pTraceLog;
#endif

} UL_HTTP_CONNECTION, *PUL_HTTP_CONNECTION;


//
// forward decl for cgroup.h which is not included yet
//

#define UL_IS_VALID_INTERNAL_REQUEST(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == UL_INTERNAL_REQUEST_POOL_TAG) && ((pObject)->RefCount > 0))

//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_INTERNAL_REQUEST
{
    //
    // NonPagedPool
    //

    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //
    SINGLE_LIST_ENTRY   LookasideEntry;

    //
    // UL_INTERNAL_REQUEST_POOL_TAG
    //
    ULONG               Signature;

    //
    // Reference count
    //
    LONG                RefCount;

    //
    // Opaque ID for this object.
    // Has a reference.
    //
    HTTP_REQUEST_ID     RequestId;

    //
    // Opaque ID for the connection.
    // No reference.
    //
    HTTP_CONNECTION_ID  ConnectionId;

    //
    // Copy of opaque id for the request.
    // No reference.
    //
    HTTP_REQUEST_ID     RequestIdCopy;

    //
    // Copy of opaque id for the raw connection. May be UL_NULL_ID.
    // No reference.
    //
    HTTP_RAW_CONNECTION_ID  RawConnectionId;

    //
    // The connection
    //
    PUL_HTTP_CONNECTION pHttpConn;

    //
    // Result of call to UlCheckCachePreconditions.
    //
    BOOLEAN             CachePreconditions;

    //
    // Secure connection flag
    //
    BOOLEAN             Secure;

    //
    // Headers appened flag.  Set if AppendHeaderValue called.
    //
    BOOLEAN             HeadersAppended;

    //
    // Irp appened flag.  Set if IrpHead below ever gets changed.
    //
    BOOLEAN             IrpsPending;

    //
    // Local copy of unknown headers buffer.
    //
    UCHAR                   NextUnknownHeaderIndex;
    UL_HTTP_UNKNOWN_HEADER  UnknownHeaders[DEFAULT_MAX_UNKNOWN_HEADERS];

    //
    // Current state of our parsing effort.
    //
    PARSE_STATE         ParseState;

    //
    // a list of IRP(s) trying to read entity body
    //
    LIST_ENTRY          IrpHead;

    //
    // List of headers we don't know about.
    //
    LIST_ENTRY          UnknownHeaderList;

    //
    // Local copy of Url buffer for raw URL.  Allocated inline.
    //
    PWSTR               pUrlBuffer;

    //
    // The pre-allocated cache/fast tracker for a single full response.
    //
    PUL_FULL_TRACKER    pTracker;

    //
    // Array of indexes of valid known headers.
    //
    UCHAR               HeaderIndex[HttpHeaderRequestMaximum];

    //
    // Array of known headers.
    //
    UL_HTTP_HEADER      Headers[HttpHeaderRequestMaximum];

    //
    // A work item, used to queue processing.
    //
    UL_WORK_ITEM        WorkItem;

    //
    // Points to the cgroup info (OPTIONAL).
    //
    UL_URL_CONFIG_GROUP_INFO    ConfigInfo;

    //
    // Number of allocated referenced request buffers (default is 1).
    //
    USHORT              AllocRefBuffers;
    
    //
    // Number of used referenced request buffers.
    //
    USHORT              UsedRefBuffers;

    //
    // An array of referenced request buffers.
    //
    PUL_REQUEST_BUFFER  *pRefBuffers;

    //
    // A default array of referenced request buffers.
    //
    PUL_REQUEST_BUFFER  pInlineRefBuffers[1];

    //
    // The pre-allocated log data.
    //
    UL_LOG_DATA_BUFFER  LogData;

    //
    // WARNING: RtlZeroMemory is only called for fields below this line.
    // All fields above should be explicitly initialized in CreateHttpRequest.
    //

    //
    // Array of valid bit for known headers.
    //
    BOOLEAN             HeaderValid[HttpHeaderRequestMaximum];

    //
    // Application pool queuing information.
    // These members should only be accessed by apool code.
    //
    struct {
        //
        // Shows where this request lives in the app pool queues.
        //
        QUEUE_STATE             QueueState;

        //
        // the process on which this request is queued. null
        // if the request is not on the process request list.
        //
        PUL_APP_POOL_PROCESS    pProcess;

        //
        // to queue it on the app pool
        //
        LIST_ENTRY              AppPoolEntry;
    } AppPool;

    //
    // this request's sequence number on the connection
    //
    ULONG               RecvNumber;

    //
    // If there was an error parsing the code is put here.
    // ParseState is set to ParseErrorState
    //
    UL_HTTP_ERROR       ErrorCode;

    //
    // Total bytes needed for this request, includes string terminators
    //
    ULONG               TotalRequestSize;

    //
    // Number of 'unknown' headers we have.
    //
    ULONG               UnknownHeaderCount;

    //
    // Verb of this request.
    //
    HTTP_VERB           Verb;

    //
    // Pointer to raw verb, valid if Verb == UnknownVerb.
    //
    PUCHAR              pRawVerb;

    //
    // byte length of pRawVerb.
    //
    ULONG               RawVerbLength;

    struct
    {

        //
        // The raw URL.
        //
        PUCHAR          pUrl;

        //
        // the below 2 pointers point into RawUrl.pUrl
        //

        //
        // host part (OPTIONAL)
        //
        PUCHAR          pHost;
        //
        // points to the abs_path part
        //
        PUCHAR          pAbsPath;

        //
        //
        //

        //
        // The byte length of the RawUrl.pUrl.
        //
        ULONG           Length;

    } RawUrl;

    struct
    {

        //
        // The canonicalized, fully qualified URL.
        //
        PWSTR           pUrl;

        //
        // the below 3 pointers point into CookedUrl.pUrl
        //

        //
        // points to the host part
        //
        PWSTR           pHost;
        //
        // points to the abs_path part
        //
        PWSTR           pAbsPath;
        //
        // points to the query string (OPTIONAL)
        //
        PWSTR           pQueryString;

        //
        //
        //

        //
        // the byte length of CookedUrl.pUrl
        //
        ULONG           Length;
        //
        // the hash of CookedUrl.pUrl
        //
        ULONG           Hash;

    } CookedUrl;

    //
    // HTTP Version of current request.
    //
    HTTP_VERSION        Version;

    //
    // Number of known headers.
    //
    ULONG               HeaderCount;

    //
    // The reason the driver didn't serve the response (CacheMiss?)
    //
    HTTP_REQUEST_REASON Reason;

    //
    // the content length (OPTIONAL)
    //
    ULONGLONG           ContentLength;

    //
    // How many bytes are left to parse in the current chunk
    // (probably in pCurrentBuffer)
    //
    ULONGLONG           ChunkBytesToParse;

    //
    // How many bytes TOTAL were parsed
    //
    ULONGLONG           ChunkBytesParsed;

    //
    // How many bytes are left in pChunkBuffer (the current chunk)
    // for reading by user mode
    //
    ULONGLONG           ChunkBytesToRead;

    //
    // How many TOTAL bytes have been read by user mode
    //
    ULONGLONG           ChunkBytesRead;

    //
    // Statistical information for Logging and
    // possibly perfcounters. BytesReceived get updated
    // by Parser, whereas BytesSend is updated by sendresponse.
    //
    ULONGLONG           BytesSent;

    ULONGLONG           BytesReceived;

    //
    // To calculate the response time for this request
    //
    LARGE_INTEGER       TimeStamp;

    //
    // does the accept header of the this request has */* wild card?
    //

    ULONG               AcceptWildcard:1;

    //
    // is this chunk-encoded?
    //
    ULONG               Chunked:1;

    //
    // parsed the first chunk?
    //
    ULONG               ParsedFirstChunk:1;

    //
    // Has a "100 continue" been sent?
    //
    ULONG               SentContinue:1;

    //
    // Are we cleaning up the request?
    //
    ULONG               InCleanup:1;

    //
    // has a response has been sent
    //
    ULONG               SentResponse;

    //
    // has the last send call been made
    //
    ULONG               SentLast;

    //
    // points to the buffer where protocol header data started.
    //
    PUL_REQUEST_BUFFER  pHeaderBuffer;

    //
    // the last buffer containing header data
    //
    PUL_REQUEST_BUFFER  pLastHeaderBuffer;

    //
    // points to the buffer where we are reading/parsing body chunk(s)
    //
    PUL_REQUEST_BUFFER  pChunkBuffer;

    //
    // the current location we are reading body chunk from, points into
    // pChunkBuffer
    //
    PUCHAR              pChunkLocation;

#if REFERENCE_DEBUG
    //
    // Reference trace log.
    //

    PTRACE_LOG          pTraceLog;
#endif

} UL_INTERNAL_REQUEST, *PUL_INTERNAL_REQUEST;


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _HTTPTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httprcv.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httprcv.cxx

Abstract:

    Contains core HTTP receive code.

Author:

    Henry Sanders (henrysa)       10-Jun-1998

Revision History:

    Paul McDaniel (paulmcd)       01-Mar-1999

        massively rewrote it to handle request spanning tdi packets.
        moved all http parsing to PASSIVE irql (from DISPATCH).
        also merged tditest into this module.

    Eric Stenson (EricSten)       11-Sep-2000

        Added support for sending "100 Continue" responses to PUT
        and POST requests.  Added #pragma's for PAGED -vs- Non-PAGED
        functions.

--*/

#include    "precomp.h"
#include    "httprcvp.h"


//
// Declare pageable and non-pageable functions
//

#ifdef ALLOC_PRAGMA
// Init
#pragma alloc_text( INIT, UlInitializeHttpRcv )
#pragma alloc_text( PAGE, UlTerminateHttpRcv )

// Public
#pragma alloc_text( PAGE, UlResumeParsing )
#pragma alloc_text( PAGE, UlGetCGroupForRequest )
#pragma alloc_text( PAGE, UlSendSimpleStatus )
#pragma alloc_text( PAGE, UlSendErrorResponse )

// Private
#pragma alloc_text( PAGE, UlpDeliverHttpRequest )
#pragma alloc_text( PAGE, UlpProcessBufferQueue )
#pragma alloc_text( PAGE, UlpCancelEntityBodyWorker )

#if DBG
#pragma alloc_text( PAGE, UlpIsValidRequestBufferList )
#endif // DBG

#endif // ALLOC_PRAGMA

#if 0   // Non-Pageable Functions
// Public
NOT PAGEABLE -- UlHttpReceive
NOT PAGEABLE -- UlConnectionRequest
NOT PAGEABLE -- UlConnectionComplete
NOT PAGEABLE -- UlConnectionDisconnect
NOT PAGEABLE -- UlConnectionDestroyed
NOT PAGEABLE -- UlReceiveEntityBody

// Private
NOT PAGEABLE -- UlpHandleRequest
NOT PAGEABLE -- UlpParseNextRequest
NOT PAGEABLE -- UlpInsertBuffer
NOT PAGEABLE -- UlpMergeBuffers
NOT PAGEABLE -- UlpAdjustBuffers
NOT PAGEABLE -- UlpConsumeBytesFromConnection
NOT PAGEABLE -- UlpCancelEntityBody
NOT PAGEABLE -- UlpCompleteSendResponse
NOT PAGEABLE -- UlpRestartSendSimpleResponse
NOT PAGEABLE -- UlpSendSimpleCleanupWorker

#endif  // Non-Pageable Functions


/*++

    Paul McDaniel (paulmcd)         26-May-1999

here is a brief description of the data structures used by this module:

the connection keeps track of all buffers received by TDI into a list anchored
by HTTP_CONNECTION::BufferHead.  this list is sequenced and sorted.  the
buffers are refcounted.

HTTP_REQUEST(s) keep pointers into these buffers for the parts they consume.
HTTP_REQUEST::pHeaderBuffer and HTTP_REQUEST::pChunkBuffer.

the buffers fall off the list as they are no longer needed.  the connection
only keeps a reference at HTTP_CONNECTION::pCurrentBuffer.  so as it completes
the processing of a buffer, if no other objects kept that buffer, it will be
released.

here is a brief description of the functions in this module, and how they
are used:


UlHttpReceive - the TDI data indication handler.  copies buffers and queues to
    UlpHandleRequest.

UlpHandleRequest - the main processing function for connections.

    UlCreateHttpConnectionId - creates the connections opaque id.

    UlpInsertBuffer - inserts the buffer into pConnection->BufferHead - sorted.

    UlpAdjustBuffers - determines where in BufferHead the current connection
        should be parsing.  handle buffer merging and copying if a protocol
        token spans buffers

    UlParseHttp - the main http parser. expects that no protocol tokens span
        a buffer.  will return a status code if it does.

    UlpProcessBufferQueue - handles entity body buffer processing.
        synchronizes access to BufferHead at pRequest->pChunkBuffer with
        UlReceiveEntityBody.

UlConnectionRequest - called when a new connection comes in.  allocates a new
    HTTP_CONNECTION.  does not create the opaque id.

UlConnectionComplete - called if the client is happy with our accept.
    closes the connection if error status.

UlConnectionDisconnect - called when the client disconnects.  it calls tdi to
    close the server end.  always a graceful close.

UlConnectionDestroyed - called when the connection is dropped. both sides have
    closed it.  deletes all opaque ids .  removes the tdi reference on the
    HTTP_CONNECTION (and hopefully vice versa) .

UlReceiveEntityBody - called by user mode to read entity body.  pends the irp
    to pRequest->IrpHead and calls UlpProcessBufferQueue .


--*/


/*++

Routine Description:

    The main http receive routine.

Arguments:

    pHttpConn       - Pointer to HTTP connection on which data was received.
    pBuffer         - Pointer to data received.
    BufferLength    - Length of data pointed to by pBuffer.
    UnreceivedLength- Bytes that the transport has, but aren't in pBuffer
    pBytesTaken     - Pointer to where to return bytes taken.

Return Value:

    Status of receive.

--*/
NTSTATUS
UlHttpReceive(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN PVOID pVoidBuffer,
    IN ULONG BufferLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pBytesTaken
    )
{
    PUL_REQUEST_BUFFER  pRequestBuffer;
    PUL_HTTP_CONNECTION pConnection;
    BOOLEAN             DrainAfterDisconnect = FALSE;
    ULONG               SpaceAvailable;
    KIRQL               OldIrql;

    ASSERT(BufferLength != 0);
    ASSERT(pConnectionContext != NULL);

    pConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    //
    // Make sure we are not buffering too much data.
    // Need to adjust the BufferLength to be no more
    // than the number of bytes we can accept at this time.
    //

    //
    // PerfBug: need to get rid of this lock
    //

    UlAcquireSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        &OldIrql
        );

    DrainAfterDisconnect = pConnection->BufferingInfo.DrainAfterDisconnect;

    if (DrainAfterDisconnect)
    {
        pConnection->BufferingInfo.TransportBytesNotTaken += UnreceivedLength;
    }
    else
    {
        if ((pConnection->BufferingInfo.BytesBuffered + BufferLength) > g_UlMaxBufferedBytes)
        {
            SpaceAvailable = g_UlMaxBufferedBytes - pConnection->BufferingInfo.BytesBuffered;
            pConnection->BufferingInfo.TransportBytesNotTaken += (BufferLength - SpaceAvailable);
            BufferLength = SpaceAvailable;
        }

        pConnection->BufferingInfo.BytesBuffered          += BufferLength;
        pConnection->BufferingInfo.TransportBytesNotTaken += UnreceivedLength;
    }

    UlReleaseSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        OldIrql
        );

    if (BufferLength && DrainAfterDisconnect == FALSE)
    {

        //
        // get a new request buffer
        //

        pRequestBuffer = UlCreateRequestBuffer(
                                BufferLength,
                                pConnection->NextBufferNumber
                                );

        if (pRequestBuffer == NULL)
        {
            return STATUS_NO_MEMORY;
        }

        //
        // increment our buffer number counter
        //

        pConnection->NextBufferNumber += 1;

        //
        // copy the tdi buffer
        //

        RtlCopyMemory(pRequestBuffer->pBuffer, pVoidBuffer, BufferLength);

        pRequestBuffer->UsedBytes = BufferLength;

        //
        // Add backpointer to connection.
        //
        pRequestBuffer->pConnection = pConnection;

        UlTrace( PARSER, (
            "*** Request Buffer %p has connection %p\n",
            pRequestBuffer,
            pConnection
            ));

        IF_DEBUG2(HTTP_IO, VERBOSE)
        {
            UlTraceVerbose( HTTP_IO, (
                "<<<< Request(%p), "
                "RequestBuffer[%d] %p, %d bytes, "
                "Conn %p.\n",
                pConnection->pRequest,
                pRequestBuffer->BufferNumber, pRequestBuffer, BufferLength,
                pConnection
                ));

            UlDbgPrettyPrintBuffer(pRequestBuffer->pBuffer, BufferLength);

            UlTraceVerbose( HTTP_IO, (">>>>\n"));
        }

        //
        // Queue a work item to handle the data.
        //
        // Reference the connection so it doesn't go
        // away while we're waiting for our work item
        // to run. UlpHandleRequest will release the ref.
        //

        UL_REFERENCE_HTTP_CONNECTION(pConnection);

        UL_QUEUE_WORK_ITEM(
            &(pRequestBuffer->WorkItem),
            &UlpHandleRequest
            );
    }
    else if ( DrainAfterDisconnect && UnreceivedLength != 0 )
    {
        // Handle the case where we are in drain state and there's
        // unreceived data indicated but not available by the tdi.

        UlpDiscardBytesFromConnection( pConnection );
    }

    //
    // Tell the caller how many bytes we consumed.
    //

    *pBytesTaken = BufferLength;

    return STATUS_SUCCESS;

}   // UlHttpReceive


/***************************************************************************++

Routine Description:

    links the buffer into the connection and processes the list.

    starts http request parsing.

Arguments:

    pWorkItem - points to a UL_REQUEST_BUFFER

--***************************************************************************/
VOID
UlpHandleRequest(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS                    Status;
    PUL_REQUEST_BUFFER          pRequestBuffer;
    PUL_HTTP_CONNECTION         pConnection;
    KIRQL                       OldIrql;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pRequestBuffer = CONTAINING_RECORD(
                            pWorkItem,
                            UL_REQUEST_BUFFER,
                            WorkItem
                            );

    ASSERT( UL_IS_VALID_REQUEST_BUFFER(pRequestBuffer) );

    pConnection = pRequestBuffer->pConnection;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    //
    // grab the lock
    //

    UlAcquireResourceExclusive(&(pConnection->Resource), TRUE);

    //
    // if the connection is going down, just bail out.
    //

    if (pConnection->UlconnDestroyed) {
        UlFreeRequestBuffer(pRequestBuffer);
        Status = STATUS_SUCCESS;
        goto end;
    }

    //
    // stop the Connection Timeout timer
    // and start the Header Wait timer
    //

    UlLockTimeoutInfo(
        &pConnection->TimeoutInfo,
        &OldIrql
        );

    UlResetConnectionTimer(
        &pConnection->TimeoutInfo,
        TimerConnectionIdle
        );

    UlSetConnectionTimer(
        &pConnection->TimeoutInfo,
        TimerHeaderWait
        );

    UlUnlockTimeoutInfo(
        &pConnection->TimeoutInfo,
        OldIrql
        );

    UlEvaluateTimerState(
        &pConnection->TimeoutInfo
        );


    //
    // Make sure it has an id already created.
    //
    // This is done here because the opaqueid stuff likes to run
    // at PASSIVE_LEVEL.
    //

    if (HTTP_IS_NULL_ID(&(pConnection->ConnectionId)))
    {
        Status = UlCreateHttpConnectionId(pConnection);

        if (!NT_SUCCESS(Status))
        {
            UlFreeRequestBuffer(pRequestBuffer);
            goto end;
        }
    }

    //
    // insert it into the list
    //

    ASSERT( 0 != pRequestBuffer->UsedBytes );

    UlTraceVerbose( PARSER, (
        "http!UlpHandleRequest: conn = %p, Req = %p: "
        "about to insert buffer %p\n",
        pConnection,
        pConnection->pRequest,
        pRequestBuffer
        ));

    UlpInsertBuffer(pConnection, pRequestBuffer);

    //
    // Kick off the parser
    //

    UlTraceVerbose( PARSER, (
        "http!UlpHandleRequest: conn = %p, Req = %p: "
        "about to parse next request\n",
        pConnection,
        pConnection->pRequest
        ));

    Status = UlpParseNextRequest(pConnection);

end:

    UlTraceVerbose( PARSER, (
        "http!UlpHandleRequest: status %08lx, pConnection %p, pRequest %p\n",
        Status,
        pConnection,
        pConnection->pRequest
        ));

    if (!NT_SUCCESS(Status) && pConnection->pRequest != NULL)
    {
        UlTrace( PARSER, (
            "*** status %08lx, pConnection %p, pRequest %p\n",
            Status,
            pConnection,
            pConnection->pRequest
            ));

        //
        // An error happened, most propably during parsing.
        // Send an error back if user hasn't send one yet.
        // E.g. We have received a request,then delivered
        // it to the WP, therefore WaitingForResponse is
        // set. And then encountered an error when dealing
        // with entity body.
        //
        
        UlSendErrorResponse( pConnection );
    }

    //
    // done with the lock
    //

    UlReleaseResource(&(pConnection->Resource));

    //
    // and release the connection
    //

    UL_DEREFERENCE_HTTP_CONNECTION(pConnection);

    CHECK_STATUS(Status);

}   // UlpHandleRequest


/***************************************************************************++

Routine Description:

    When we finish sending a response we call into this function to
    kick the parser back into action.

Arguments:

    pConnection - the connection on which to resume

--***************************************************************************/
VOID
UlResumeParsing(
    IN PUL_HTTP_CONNECTION pConnection
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PLIST_ENTRY pEntry;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pConnection ) );

    UlTrace(HTTP_IO, (
                "http!UlResumeParsing(pHttpConn = %p)\n",
                pConnection
                ));

    //
    // grab the lock
    //

    UlAcquireResourceExclusive(&(pConnection->Resource), TRUE);

    //
    // if the connection is going down, just bail out.
    //
    if (!pConnection->UlconnDestroyed)
    {
        //
        // Forget about the old request.
        //
        UlCleanupHttpConnection( pConnection );

        //
        // Kick off the parser
        //
        Status = UlpParseNextRequest(pConnection);

        if (!NT_SUCCESS(Status) && pConnection->pRequest != NULL)
        {
            //
            // Uh oh, something bad happened, send back an error
            //

            UlSendErrorResponse( pConnection );
        }
    }


    //
    // done with the lock
    //

    UlReleaseResource(&(pConnection->Resource));

    CHECK_STATUS(Status);
} // UlResumeParsing



/***************************************************************************++

Routine Description:

    Tries to parse data attached to the connection into a request. If
    a complete request header is parsed, the request will be dispatched
    to an Application Pool.

    This function assumes the caller is holding the connection resource!

Arguments:

    pConnection - the HTTP_CONNECTION with data to parse.

--***************************************************************************/
NTSTATUS
UlpParseNextRequest(
    IN PUL_HTTP_CONNECTION pConnection
    )
{
    NTSTATUS                    Status;
    PUL_INTERNAL_REQUEST        pRequest = NULL;
    ULONG                       BytesTaken;
    ULONG                       BufferLength;
    BOOLEAN                     ResponseSent;
    KIRQL                       OldIrql;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pConnection ) );

    Status = STATUS_SUCCESS;

    UlTrace(HTTP_IO, ("http!UlpParseNextRequest(httpconn = %p)\n", pConnection));

    //
    // Only parse the next request if
    //
    //  We haven't dispatched the current request yet
    //      OR
    //  The current request has unparsed entity body or trailers.
    //

    if ((pConnection->pRequest == NULL)
        || ( !pConnection->WaitingForResponse )
        || (pConnection->pRequest->ParseState == ParseEntityBodyState)
        || (pConnection->pRequest->ParseState == ParseTrailerState))
    {

        //
        // loop consuming the buffer, we will make multiple iterations
        // if a single request spans multiple buffers.
        //

        for (;;)
        {
            ASSERT( UlpIsValidRequestBufferList( pConnection ) );
            Status = UlpAdjustBuffers(pConnection);

            if (!NT_SUCCESS(Status))
            {
                if (Status == STATUS_MORE_PROCESSING_REQUIRED)
                {
                    Status = STATUS_SUCCESS;
                }

                break;
            }

            //
            // Since BufferLength is a ULONG, it can never be negative.
            // So, if UsedBytes is greater than ParsedBytes, BufferLength
            // will be very large, and non-zero.
            //

            ASSERT( pConnection->pCurrentBuffer->UsedBytes >
                    pConnection->pCurrentBuffer->ParsedBytes );

            BufferLength = pConnection->pCurrentBuffer->UsedBytes -
                           pConnection->pCurrentBuffer->ParsedBytes;

            //
            // do we need to create a request object?
            //

            if (pConnection->pRequest == NULL)
            {
                //
                // First shot at reading a request, allocate a request object
                //

                Status = UlpCreateHttpRequest(pConnection, &pConnection->pRequest);
                if (NT_SUCCESS(Status) == FALSE)
                    goto end;

                ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pConnection->pRequest));

                UlTrace(HTTP_IO, (
                            "http!UlpParseNextRequest created pRequest = %p for httpconn = %p\n",
                            pConnection->pRequest,
                            pConnection
                            ));

                //
                // To be exact precise about the life-time of this
                // request, copy the starting TIMESTAMP from connection
                // pointer. But that won't work since we may get hit by
                // multiple requests to the same connection. So we won't
                // be that much precise.
                //

                KeQuerySystemTime( &(pConnection->pRequest->TimeStamp) );

                TRACE_TIME(
                    pConnection->ConnectionId,
                    pConnection->pRequest->RequestId,
                    TIME_ACTION_CREATE_REQUEST
                    );

                WRITE_REF_TRACE_LOG2(
                    g_pHttpConnectionTraceLog,
                    pConnection->pTraceLog,
                    REF_ACTION_INSERT_REQUEST,
                    pConnection->RefCount,
                    pConnection->pRequest,
                    __FILE__,
                    __LINE__
                    );
            }

            UlTrace( PARSER, (
                "*** pConn %p, pReq %p, ParseState %lu\n",
                pConnection,
                pConnection->pRequest,
                pConnection->pRequest->ParseState
                ));

            PARSE_STATE OldState = pConnection->pRequest->ParseState;

            switch (pConnection->pRequest->ParseState)
            {

            case ParseVerbState:
            case ParseUrlState:
            case ParseVersionState:
            case ParseHeadersState:
            case ParseCookState:

                pRequest = pConnection->pRequest;
                ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

                //
                // parse it !
                //

                Status = UlParseHttp(
                                pRequest,
                                GET_REQUEST_BUFFER_POS(pConnection->pCurrentBuffer),
                                BufferLength,
                                &BytesTaken
                                );

                ASSERT(BytesTaken <= BufferLength);

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest = %p) "
                    "UlParseHttp: states (Vb/U/Ver/Hd/Ck) "
                    "%d -> %d, %d bytes taken\n",
                    pRequest, OldState, pConnection->pRequest->ParseState,
                    BytesTaken
                    ));

                pConnection->pCurrentBuffer->ParsedBytes += BytesTaken;
                BufferLength -= BytesTaken;

                //
                // Need some accounting for Logging
                //
                pRequest->BytesReceived += BytesTaken;

                //
                // did we consume any of the data?  if so, give the request
                // a pointer to the buffer
                //

                if (BytesTaken > 0)
                {
                    if (pRequest->pHeaderBuffer == NULL)
                    {
                        //
                        // store its location, for later release
                        //
                        pRequest->pHeaderBuffer = pConnection->pCurrentBuffer;
                    }

                    pRequest->pLastHeaderBuffer = pConnection->pCurrentBuffer;

                    if (!UlpReferenceBuffers(
                            pRequest,
                            pConnection->pCurrentBuffer
                            ))
                    {
                        Status = STATUS_NO_MEMORY;
                        goto end;
                    }

                    //
                    // Tell the connection how many bytes we consumed.
                    // HTTP header bytes are "consumed" as soon as we
                    // parse them.
                    //

                    UlpConsumeBytesFromConnection(
                        pConnection,
                        BytesTaken
                        );

                }

                //
                // did everything work out ok?
                //

                if (!NT_SUCCESS(Status))
                {
                    if (Status == STATUS_MORE_PROCESSING_REQUIRED)
                    {
                        ULONG FullBytesReceived;

                        FullBytesReceived = (ULONG)(
                            (pRequest->BytesReceived + BufferLength));

                        if (FullBytesReceived < g_UlMaxRequestBytes)
                        {
                            //
                            // we need more transport data
                            //

                            pConnection->NeedMoreData = 1;

                            Status = STATUS_SUCCESS;

                            continue;
                        }
                        else
                        {
                            //
                            // The request has grown too large. Send back
                            // an error.
                            //

                            if (pRequest->ParseState == ParseUrlState)
                            {
                                pRequest->ErrorCode = UlErrorUrlLength;

                                UlTrace(PARSER, (
                                    "UlpParseNextRequest(pRequest = %p)"
                                    " ERROR: URL is too big\n",
                                    pRequest
                                    ));
                            }
                            else
                            {
                                pRequest->ErrorCode = UlErrorRequestLength;

                                UlTrace(PARSER, (
                                    "UlpParseNextRequest(pRequest = %p)"
                                    " ERROR: request is too big\n",
                                    pRequest
                                    ));
                            }

                            pRequest->ParseState = ParseErrorState;
                            Status = STATUS_SECTION_TOO_BIG;

                            goto end;
                        }
                    }
                    else
                    {
                        //
                        // some other bad error!
                        //

                        goto end;
                    }
                }

                //
                // if we're not done parsing the request, we need more data.
                // it's not bad enough to set NeedMoreData as nothing important
                // spanned buffer boundaries (header values, etc..) .  it was
                // a clean split.  no buffer merging is necessary.  simply skip
                // to the next buffer.
                //

                if (pRequest->ParseState <= ParseCookState)
                {
                    continue;
                }

                //
                // all done, mark the sequence number on this request
                //

                pRequest->RecvNumber = pConnection->NextRecvNumber;
                pConnection->NextRecvNumber += 1;

                UlTrace(HTTP_IO, (
                    "http!UlpParseNextRequest(httpconn = %p) built request %p\n",
                    pConnection,
                    pRequest
                    ));

                //
                // Stop the Header Wait timer
                //

                UlLockTimeoutInfo(
                    &pConnection->TimeoutInfo,
                    &OldIrql
                    );

                UlResetConnectionTimer(
                    &pConnection->TimeoutInfo,
                    TimerHeaderWait
                    );

                UlUnlockTimeoutInfo(
                    &pConnection->TimeoutInfo,
                    OldIrql
                    );

                UlEvaluateTimerState(
                    &pConnection->TimeoutInfo
                    );
                
                //
                // check protocol compliance
                //

                Status = UlCheckProtocolCompliance(pConnection, pRequest);
                if (!NT_SUCCESS(Status))
                {
                    //
                    // This request is bad. Send a 400.
                    //

                    pRequest->ParseState = ParseErrorState;

                    goto end;

                }

                Status = UlpDeliverHttpRequest( pConnection, &ResponseSent );
                if (!NT_SUCCESS(Status)) {
                    goto end;
                }

                if (ResponseSent)
                {
                    //
                    // We have hit the cache entry and sent the response.
                    // There is no more use for the request anymore so
                    // unlink it from the connection and try parsing the
                    // next request immediately.
                    //

                    UlCleanupHttpConnection(pConnection);
                    continue;
                }

                //
                // if we're done parsing the request break out
                // of the loop. Otherwise keep going around
                // so we can pick up the entity body.
                //

                if (pRequest->ParseState == ParseDoneState)
                {
                    goto end;
                }

                //
                // done with protocol parsing.  keep looping.
                //

                break;

            case ParseEntityBodyState:
            case ParseTrailerState:

                pRequest = pConnection->pRequest;
                ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

                //
                // is there anything for us to parse?
                //

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest=%p, httpconn=%p): "
                    "ChunkBytesToParse = %d.\n",
                    pRequest, pConnection, pRequest->ChunkBytesToParse
                    ));

                if (pRequest->ChunkBytesToParse > 0)
                {
                    ULONG BytesToSkip;

                    //
                    // Set/bump the Entity Body Receive timer
                    //

                    UlLockTimeoutInfo(
                        &pConnection->TimeoutInfo,
                        &OldIrql
                        );

                    UlSetConnectionTimer(
                        &pConnection->TimeoutInfo,
                        TimerEntityBody
                        );

                    UlUnlockTimeoutInfo(
                        &pConnection->TimeoutInfo,
                        OldIrql
                        );

                    UlEvaluateTimerState(
                        &pConnection->TimeoutInfo
                        );

                    //
                    // is this the first chunk we've parsed?
                    //

                    if (pRequest->pChunkBuffer == NULL)
                    {
                        //
                        // store its location, this is where to start reading
                        //

                        pRequest->pChunkBuffer = pConnection->pCurrentBuffer;
                        pRequest->pChunkLocation = GET_REQUEST_BUFFER_POS(
                                                        pConnection->pCurrentBuffer
                                                        );
                    }

                    //
                    // how much should we parse?
                    //

                    BytesToSkip = (ULONG)(
                                        MIN(
                                            pRequest->ChunkBytesToParse,
                                            BufferLength
                                            )
                                        );

                    //
                    // update that we parsed this piece
                    //

                    pRequest->ChunkBytesToParse -= BytesToSkip;
                    pRequest->ChunkBytesParsed += BytesToSkip;

                    pConnection->pCurrentBuffer->ParsedBytes += BytesToSkip;
                    BufferLength -= BytesToSkip;

                    //
                    // Need some accounting info for Logging
                    // ??? I'm not sure about this well enough
                    //
                    pRequest->BytesReceived += BytesToSkip;
                }

                //
                // process any irp's waiting for entity body
                //

                //
                // CODEWORK.  this doesn't need to be called after each chunk.
                //

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest=%p, httpconn=%p): "
                    "about to process buffer queue\n",
                    pRequest, pConnection
                    ));

                UlpProcessBufferQueue(pRequest);

                //
                // check to see there is another chunk
                //

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest=%p, httpconn=%p): "
                    "checking to see if another chunk.\n",
                    pRequest, pConnection
                    ));

                Status = UlParseHttp(
                                pRequest,
                                GET_REQUEST_BUFFER_POS(pConnection->pCurrentBuffer),
                                BufferLength,
                                &BytesTaken
                                );

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest = %p)"
                    " UlParseHttp: states (EB/T) %d -> %d, %d bytes taken\n",
                    pRequest, OldState, pConnection->pRequest->ParseState,
                    BytesTaken
                    ));

                pConnection->pCurrentBuffer->ParsedBytes += BytesTaken;
                BufferLength -= BytesTaken;

                //
                // Need some accounting info for Logging
                //
                pRequest->BytesReceived += BytesTaken;

                //
                // was there enough in the buffer to please?
                //

                if (NT_SUCCESS(Status) == FALSE)
                {
                    if (Status == STATUS_MORE_PROCESSING_REQUIRED)
                    {
                        //
                        // we need more transport data
                        //

                        pConnection->NeedMoreData = 1;

                        Status = STATUS_SUCCESS;

                        continue;
                    }
                    else
                    {
                        //
                        // some other bad error !
                        //

                        goto end;
                    }
                }

                //
                // are we all done parsing it ?
                //

                if (pRequest->ParseState == ParseDoneState)
                {
                    ASSERT( pConnection->WaitingForResponse == 1 );

                    //
                    // Once more, with feeling. Check to see if there
                    // are any remaining buffers to be processed or irps
                    // to be completed (e.g., catch a solo zero-length
                    // chunk)
                    //

                    UlpProcessBufferQueue(pRequest);

                    //
                    // Stop entity body receive timer
                    //

                    UlLockTimeoutInfo(
                        &pConnection->TimeoutInfo,
                        &OldIrql
                        );

                    UlResetConnectionTimer(
                        &pConnection->TimeoutInfo,
                        TimerEntityBody
                        );

                    UlUnlockTimeoutInfo(
                        &pConnection->TimeoutInfo,
                        OldIrql
                        );

                    UlEvaluateTimerState(
                        &pConnection->TimeoutInfo
                        );

                    UlTraceVerbose(PARSER, (
                        "UlpParseNextRequest(pRequest = %p) all done\n",
                        pRequest
                        ));

                    goto end;
                }

                //
                // keep looping.
                //

                break;

            case ParseErrorState:

                //
                // ignore this buffer
                //

                Status = STATUS_SUCCESS;
                goto end;

            case ParseDoneState:
            default:
                //
                // this should never happen
                //
                Status = STATUS_INVALID_DEVICE_STATE;
                goto end;

            }   // switch (pConnection->pRequest->ParseState)

        }   // for(;;)
    }

end:
    return Status;
} // UlpParseNextRequest



/***************************************************************************++

Routine Description:

   DeliverHttpRequest may want to get the cgroup info for the request if it's
   not a cache hit. Similarly sendresponse may want to get this info - later-
   even if it's cache hit, when logging is enabled on the hit. Therefore we
   have created a new function for this to easily maintain the functionality.

Arguments:

   pConnection - The connection whose request we are to deliver.

--***************************************************************************/

NTSTATUS
UlGetCGroupForRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS            Status;
    BOOLEAN             OptionsStar;

    //
    // Sanity check
    //

    PAGED_CODE();
    Status = STATUS_SUCCESS;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // Lookup the config group information for this url .
    //
    // don't include the query string in the lookup.
    // route OPTIONS * as though it were OPTIONS /
    //

    if (pRequest->CookedUrl.pQueryString != NULL)
    {
        pRequest->CookedUrl.pQueryString[0] = UNICODE_NULL;
    }

    if ((pRequest->Verb == HttpVerbOPTIONS)
        && (pRequest->CookedUrl.pAbsPath[0] == '*')
        && (pRequest->CookedUrl.pAbsPath[1] == UNICODE_NULL))
    {
        pRequest->CookedUrl.pAbsPath[0] = '/';
        OptionsStar = TRUE;
    } else {
        OptionsStar = FALSE;
    }

    //
    // Get the Url Config Info
    //
    Status = UlGetConfigGroupInfoForUrl(
                    pRequest->CookedUrl.pUrl,
                    pRequest->pHttpConn,
                    &pRequest->ConfigInfo
                    );

    if (pRequest->CookedUrl.pQueryString != NULL)
    {
        pRequest->CookedUrl.pQueryString[0] = L'?';
    }

    //
    // restore the * in the path
    //
    if (OptionsStar) {
        pRequest->CookedUrl.pAbsPath[0] = '*';
    }

    return Status;
} // UlGetCGroupForRequest



/***************************************************************************++

Routine Description:

    Takes a parsed http request and tries to deliver it to something
    that can send a response.

    First we try the cache. If there is no cache entry we try to route
    to an app pool.

    We send back an auto response if the control channel
    or config group is inactive. If we can't do any of those things we
    set an error code in the HTTP_REQUEST and return a failure status.
    The caller will take care of sending the error.

Arguments:

    pConnection - The connection whose request we are to deliver.

--***************************************************************************/
NTSTATUS
UlpDeliverHttpRequest(
    IN PUL_HTTP_CONNECTION pConnection,
    OUT PBOOLEAN pResponseSent
    )
{
    NTSTATUS Status;
    PUL_INTERNAL_REQUEST pRequest;
    BOOLEAN ServedFromCache;
    BOOLEAN OptionsStar;
    BOOLEAN ConnectionRefused;
    HTTP_ENABLED_STATE CurrentState;
    PUL_INTERNAL_RESPONSE pAutoResponse;
    ULONG Connections;
    PUL_SITE_COUNTER_ENTRY pCtr;
    PUL_CONFIG_GROUP_OBJECT pMaxBandwidth;

    //
    // Sanity check
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pConnection->pRequest));

    pRequest = pConnection->pRequest;

    *pResponseSent = FALSE;
    ConnectionRefused = FALSE;
    pMaxBandwidth  = NULL;

    //
    // Do we have a cache hit?
    // Set WaitingForResponse to 1 before calling UlSendCachedResponse
    // because the send may be completed before we return.
    //

    pConnection->WaitingForResponse = 1;

    UlTrace( PARSER, (
        "***3 pConnection %p->WaitingForResponse = 1\n",
        pConnection
        ));

    pRequest->CachePreconditions = UlCheckCachePreconditions(
                                        pRequest,
                                        pConnection
                                        );

    if (pRequest->CachePreconditions)
    {
        Status = UlSendCachedResponse(
                    pConnection,
                    &ServedFromCache,
                    &ConnectionRefused
                    );

        if (NT_SUCCESS(Status) && ServedFromCache && !ConnectionRefused)
        {
            //
            // All done with this request. Wait for response
            // before going on.
            //

            *pResponseSent = TRUE;

            goto end;
        }
        
        //
        // If a cache precondition failed during SendCacheResponse,
        // then bail out.
        //

        if ( UlErrorPreconditionFailed == pRequest->ErrorCode )
        {
            ASSERT( STATUS_INVALID_DEVICE_STATE == Status );
            
            pConnection->WaitingForResponse = 0;

            UlTrace( PARSER, (
                "***3 pConnection %p->WaitingForResponse = 0\n",
                pConnection
                ));
                
            goto end;
        }
    }

    //
    // We didn't do a send from the cache, so we are not
    // yet WaitingForResponse.
    //

    pConnection->WaitingForResponse = 0;

    UlTrace( PARSER, (
        "***3 pConnection %p->WaitingForResponse = 0\n",
        pConnection
        ));

    //
    // If connection refused during SendCacheResponse because of a connection
    // limit then refuse the request.
    //

    if (ConnectionRefused)
    {
        pRequest->ParseState = ParseErrorState;
        pRequest->ErrorCode  = UlErrorConnectionLimit;

        Status = STATUS_INVALID_DEVICE_STATE;
        goto end;
    }

    //
    // Allocate request ID here since we didn't do it in UlCreateHttpRequest.
    //

    Status = UlAllocateRequestId(pRequest);

    if (!NT_SUCCESS(Status))
    {
        pRequest->ParseState = ParseErrorState;
        pRequest->ErrorCode  = UlErrorInternalServer;

        goto end;
    }

    UL_REFERENCE_INTERNAL_REQUEST( pRequest );

    pRequest->RequestIdCopy = pRequest->RequestId;

    //
    // Previous code fragment here to get the cgroup info
    // has been moved to a seperate function, as logging
    // related code in sendresponse requires this info
    // as well.
    //

    Status = UlGetCGroupForRequest( pRequest );

    //
    // CODEWORK+BUGBUG: need to check the port's actually matched
    //

    //
    // check that the config group tree lookup matched
    //

    if (!NT_SUCCESS(Status) || pRequest->ConfigInfo.pAppPool == NULL)
    {
        //
        // Could not route to a listening url, send
        // back an http error. Always return error 400
        // to show that host not found. This will also
        // make us to be compliant with HTTP1.1 / 5.2
        //

        // REVIEW: What do we do about the site counter(s)
        // REVIEW: when we can't route to a site? i.e., Connection Attempts?

        pRequest->ParseState = ParseErrorState;
        pRequest->ErrorCode  = UlErrorHost;

        Status = STATUS_INVALID_DEVICE_STATE;
        goto end;
    }

    //
    // Check to see if there's a connection timeout value override
    //

    if (0L != pRequest->ConfigInfo.ConnectionTimeout)
    {
        UlSetPerSiteConnectionTimeoutValue(
            &pRequest->pHttpConn->TimeoutInfo,
            pRequest->ConfigInfo.ConnectionTimeout
            );
    }

    //
    // Check the connection limit of the site.
    //
    if (UlCheckSiteConnectionLimit(pConnection, &pRequest->ConfigInfo) == FALSE)
    {
        // If exceeding the site limit, send back 403 error and disconnect.
        // NOTE: This code depend on the fact that UlSendErrorResponse always
        // NOTE: disconnect. Otherwise we need a force disconnect here.

        pRequest->ParseState = ParseErrorState;
        pRequest->ErrorCode  = UlErrorConnectionLimit;

        Status = STATUS_INVALID_DEVICE_STATE;
        goto end;
    }

    //
    // Perf Counters (non-cached)
    //
    pCtr = pRequest->ConfigInfo.pSiteCounters;
    if (pCtr)
    {
        // NOTE: pCtr may be NULL if the SiteId was never set on the root-level
        // NOTE: Config Group for the site.  BVTs may need to be updated.

        ASSERT(IS_VALID_SITE_COUNTER_ENTRY(pCtr));

        UlIncSiteNonCriticalCounterUlong(pCtr, HttpSiteCounterConnAttempts);

        UlIncSiteNonCriticalCounterUlong(pCtr, HttpSiteCounterAllReqs);

        if (pCtr != pConnection->pPrevSiteCounters)
        {
            if (pConnection->pPrevSiteCounters)
            {
                // Decrement old site's counters & release ref count 
                
                UlDecSiteCounter(
                    pConnection->pPrevSiteCounters, 
                    HttpSiteCounterCurrentConns
                    );
                DEREFERENCE_SITE_COUNTER_ENTRY(pConnection->pPrevSiteCounters);
            }
            
            Connections = (ULONG) UlIncSiteCounter(pCtr, HttpSiteCounterCurrentConns);
            UlMaxSiteCounter(
                    pCtr,
                    HttpSiteCounterMaxConnections,
                    Connections
                    );

            // add ref for new site counters
            REFERENCE_SITE_COUNTER_ENTRY(pCtr);
            pConnection->pPrevSiteCounters = pCtr;
            
        }
    }

    // Try to get the corresponding cgroup for the bw settings
    pMaxBandwidth = pRequest->ConfigInfo.pMaxBandwidth;

    //
    // Install a filter if BWT is enabled for this request's site.
    //
    if (pMaxBandwidth != NULL &&
        pMaxBandwidth->MaxBandwidth.Flags.Present != 0 &&
        pMaxBandwidth->MaxBandwidth.MaxBandwidth  != HTTP_LIMIT_INFINITE)
    {
        // Call TCI to do the filter addition
        UlTcAddFilter( pConnection, pMaxBandwidth );
    }
    else
    {
        // Attempt to add the filter to the global flow
        if (UlTcGlobalThrottlingEnabled())
        {
            UlTcAddFilter( pConnection, NULL );
        }
    }

    //
    // the routing matched, let's check and see if we are active.
    //

    //
    // first check the control channel.
    //

    if (pRequest->ConfigInfo.pControlChannel->State != HttpEnabledStateActive)
    {
        UlTrace(HTTP_IO, ("http!UlpDeliverHttpRequest Control Channel is inactive\n"));

        CurrentState = HttpEnabledStateInactive;

        pAutoResponse =
            pRequest->ConfigInfo.pControlChannel->pAutoResponse;
    }
    // now check the cgroup
    else if (pRequest->ConfigInfo.CurrentState != HttpEnabledStateActive)
    {
        UlTrace(HTTP_IO, ("http!UlpDeliverHttpRequest Config Group is inactive\n"));

        CurrentState = HttpEnabledStateInactive;
        pAutoResponse = pRequest->ConfigInfo.pAutoResponse;
    }
    else
    {
        CurrentState = HttpEnabledStateActive;
        pAutoResponse = NULL;
    }


    //
    // well, are we active?
    //
    if (CurrentState == HttpEnabledStateActive)
    {

        //
        // it's a normal request. Deliver to
        // app pool (aka client)
        //
        Status = UlDeliverRequestToProcess(
                        pRequest->ConfigInfo.pAppPool,
                        pRequest
                        );

        if (NT_SUCCESS(Status)) {

            //
            // All done with this request. Wait for response
            // before going on.
            //

            pConnection->WaitingForResponse = 1;

            UlTrace( PARSER, (
                "***4 pConnection %p->WaitingForResponse = 1\n",
                pConnection
                ));
        }

    } else {
        //
        // we are not active. Send an autoresponse if we have one.
        //
        if (pAutoResponse != NULL)
        {
            //
            // send it and return
            //
            Status = UlSendHttpResponse(
                            pRequest,
                            pAutoResponse,
                            0,
                            NULL,
                            NULL
                            );

        }
        else
        {
            //
            // We have to fall back to a hardcoded response
            //

            pRequest->ParseState = ParseErrorState;
            pRequest->ErrorCode = UlErrorUnavailable;

            Status = STATUS_INVALID_DEVICE_STATE;
        }
    }


end:
    return Status;
} // UlpDeliverHttpRequest



/***************************************************************************++

Routine Description:

    links the buffer into the sorted connection list.

Arguments:

    pConnection - the connection to insert into

    pRequestBuffer - the buffer to link in

--***************************************************************************/
VOID
UlpInsertBuffer(
    PUL_HTTP_CONNECTION pConnection,
    PUL_REQUEST_BUFFER pRequestBuffer
    )
{
    PLIST_ENTRY         pEntry;
    PUL_REQUEST_BUFFER  pListBuffer = NULL;

    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pConnection) );
    ASSERT( UlDbgResourceOwnedExclusive( &pConnection->Resource ) );
    ASSERT( UL_IS_VALID_REQUEST_BUFFER(pRequestBuffer) );
    ASSERT( pRequestBuffer->UsedBytes != 0 );

    //
    // figure out where to insert the buffer into our
    // sorted queue (we need to enforce FIFO by number -
    // head is the first in).  optimize for ordered inserts by
    // searching tail to head.
    //

    pEntry = pConnection->BufferHead.Blink;
    while (pEntry != &(pConnection->BufferHead))
    {
        pListBuffer = CONTAINING_RECORD(
                            pEntry,
                            UL_REQUEST_BUFFER,
                            ListEntry
                            );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pListBuffer) );

        //
        // if the number is less than, put it here, we are
        // searching in reverse sort order
        //

        if (pListBuffer->BufferNumber < pRequestBuffer->BufferNumber)
        {
            break;
        }

        //
        // go on to the next one
        //

        pEntry = pEntry->Blink;
    }

    UlTrace(
        HTTP_IO, (
            "http!UlpInsertBuffer(conn=%p): inserting %p(%d) after %p(%d)\n",
            pConnection,
            pRequestBuffer,
            pRequestBuffer->BufferNumber,
            pListBuffer,
            (pEntry == &(pConnection->BufferHead)) ?
                -1 : pListBuffer->BufferNumber
            )
        );

    //
    // and insert it
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    InsertHeadList(
        pEntry,
        &(pRequestBuffer->ListEntry)
        );

    WRITE_REF_TRACE_LOG2(
        g_pHttpConnectionTraceLog,
        pConnection->pTraceLog,
        REF_ACTION_INSERT_BUFFER,
        pConnection->RefCount,
        pRequestBuffer,
        __FILE__,
        __LINE__
        );

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

}   // UlpInsertBuffer




/***************************************************************************++

Routine Description:

    Merges the unparsed bytes on a source buffer to a destination buffer.
    Assumes that there is space in the buffer.

Arguments:

    pDest - the buffer the gets the bytes
    pSrc  - the buffer that gives the bytes

--***************************************************************************/
VOID
UlpMergeBuffers(
    PUL_REQUEST_BUFFER pDest,
    PUL_REQUEST_BUFFER pSrc
    )
{
    ASSERT( UL_IS_VALID_REQUEST_BUFFER( pDest ) );
    ASSERT( UL_IS_VALID_REQUEST_BUFFER( pSrc ) );
    ASSERT( pDest->AllocBytes - pDest->UsedBytes >= UNPARSED_BUFFER_BYTES( pSrc ) );
    ASSERT( UlpIsValidRequestBufferList( pSrc->pConnection ) );

    UlTrace(HTTP_IO, (
        "http!UlpMergeBuffers(pDest = %p(#%d), pSrc = %p(#%d))\n"
        "   Copying %d bytes from pSrc.\n"
        "   pDest->AllocBytes (%d) - pDest->UsedBytes(%d) = %d available\n",
        pDest,
        pDest->BufferNumber,
        pSrc,
        pSrc->BufferNumber,
        UNPARSED_BUFFER_BYTES( pSrc ),
        pDest->AllocBytes,
        pDest->UsedBytes,
        pDest->AllocBytes - pDest->UsedBytes
        ));

    //
    // copy the unparsed bytes
    //
    RtlCopyMemory(
        pDest->pBuffer + pDest->UsedBytes,
        GET_REQUEST_BUFFER_POS( pSrc ),
        UNPARSED_BUFFER_BYTES( pSrc )
        );

    //
    // adjust buffer byte counters to match the transfer
    //
    pDest->UsedBytes += UNPARSED_BUFFER_BYTES( pSrc );
    pSrc->UsedBytes = pSrc->ParsedBytes;

    ASSERT( pDest->UsedBytes != 0 );
    ASSERT( pDest->UsedBytes <= pDest->AllocBytes );
} // UlpMergeBuffers



/***************************************************************************++

Routine Description:

    sets up pCurrentBuffer to the proper location, merging any blocks
    as needed.

Arguments:

    pConnection - the connection to adjust buffers for

--***************************************************************************/
NTSTATUS
UlpAdjustBuffers(
    PUL_HTTP_CONNECTION pConnection
    )
{
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(UlDbgResourceOwnedExclusive(&pConnection->Resource));

    //
    // do we have a starting buffer?
    //

    if (pConnection->pCurrentBuffer == NULL)
    {
        //
        // the list can't be empty, this is the FIRST time in
        // pCurrentBuffer is NULL
        //

        ASSERT(IsListEmpty(&(pConnection->BufferHead)) == FALSE);
        ASSERT(pConnection->NextBufferToParse == 0);

        //
        // pop from the head
        //

        pConnection->pCurrentBuffer = CONTAINING_RECORD(
                                            pConnection->BufferHead.Flink,
                                            UL_REQUEST_BUFFER,
                                            ListEntry
                                            );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pConnection->pCurrentBuffer) );

        //
        // is this the right number?
        //

        if (pConnection->pCurrentBuffer->BufferNumber !=
            pConnection->NextBufferToParse)
        {
            pConnection->pCurrentBuffer = NULL;
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        pConnection->NextBufferToParse += 1;

        pConnection->NeedMoreData = 0;
    }

    //
    // did we need more transport data?
    //

    if (pConnection->NeedMoreData == 1)
    {
        PUL_REQUEST_BUFFER pNextBuffer;

        UlTrace(HTTP_IO, (
            "http!UlpAdjustBuffers(pHttpConn %p) NeedMoreData == 1\n",
            pConnection
            ));

        //
        // is it there?
        //

        if (pConnection->pCurrentBuffer->ListEntry.Flink ==
            &(pConnection->BufferHead))
        {
            //
            // need to wait for more
            //

            UlTrace(HTTP_IO, (
                "http!UlpAdjustBuffers(pHttpConn %p) NeedMoreData == 1\n"
                "    No new buffer available yet\n",
                pConnection
                ));

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        pNextBuffer = CONTAINING_RECORD(
                            pConnection->pCurrentBuffer->ListEntry.Flink,
                            UL_REQUEST_BUFFER,
                            ListEntry
                            );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pNextBuffer) );

        //
        // is the next buffer really the 'next' buffer?
        //

        if (pNextBuffer->BufferNumber != pConnection->NextBufferToParse)
        {
            UlTrace(HTTP_IO, (
                "http!UlpAdjustBuffers(pHttpConn %p) NeedMoreData == 1\n"
                "    Buffer %d available, but we're waiting for %d\n",
                pConnection,
                pNextBuffer->BufferNumber,
                pConnection->NextBufferToParse
                ));

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        //
        // is there space to merge the blocks?
        //

        if (pNextBuffer->UsedBytes <
            (pConnection->pCurrentBuffer->AllocBytes -
                pConnection->pCurrentBuffer->UsedBytes))
        {
            //
            // merge 'em .. copy the next buffer into this buffer
            //

            UlpMergeBuffers(
                pConnection->pCurrentBuffer,    // dest
                pNextBuffer                     // src
                );

            //
            // remove the next (now empty) buffer
            //

            ASSERT( pNextBuffer->UsedBytes == 0 );
            UlFreeRequestBuffer(pNextBuffer);

            ASSERT( UlpIsValidRequestBufferList( pConnection ) );

            //
            // skip the buffer sequence number as we deleted that next buffer
            // placing the data in the current buffer.  the "new" next buffer
            // will have a 1 higher sequence number.
            //

            pConnection->NextBufferToParse += 1;

            //
            // reset the signal for more data needed
            //

            pConnection->NeedMoreData = 0;

        }
        else
        {
            PUL_REQUEST_BUFFER pNewBuffer;

            //
            // allocate a new buffer with space for the remaining stuff
            // from the old buffer, and everything in the new buffer.
            //
            // this new buffer is replacing pNextBuffer so gets its
            // BufferNumber.
            //

            pNewBuffer = UlCreateRequestBuffer(
                                (pConnection->pCurrentBuffer->UsedBytes -
                                    pConnection->pCurrentBuffer->ParsedBytes) +
                                    pNextBuffer->UsedBytes,
                                pNextBuffer->BufferNumber
                                );

            if (pNewBuffer == NULL)
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            pNewBuffer->pConnection = pConnection;

            UlTrace( PARSER, (
                "*** Request Buffer %p has connection %p\n",
                pNewBuffer,
                pConnection
                ));

            //
            // copy the unused portion into the start of this
            // buffer
            //

            UlpMergeBuffers(
                pNewBuffer,                     // dest
                pConnection->pCurrentBuffer     // src
                );

            if ( 0 == pConnection->pCurrentBuffer->UsedBytes )
            {
                //
                // Whoops!  Accidently ate everything...zap this buffer!
                // This happens when we're ahead of the parser and there
                // are 0 ParsedBytes.
                //

                ASSERT( 0 == pConnection->pCurrentBuffer->ParsedBytes );

                UlTrace(HTTP_IO, (
                        "http!UlpAdjustBuffers: Zapping pConnection->pCurrentBuffer (%p)\n",
                        pConnection->pCurrentBuffer
                        ));

                UlFreeRequestBuffer( pConnection->pCurrentBuffer );
                pConnection->pCurrentBuffer = NULL;
            }

            //
            // merge the next block into this one
            //

            UlpMergeBuffers(
                pNewBuffer,     // dest
                pNextBuffer     // src
                );


            //
            // Dispose of the now empty next buffer
            //

            ASSERT(pNextBuffer->UsedBytes == 0);
            UlFreeRequestBuffer(pNextBuffer);
            pNextBuffer = NULL;

            //
            // link in the new buffer
            //

            ASSERT(pNewBuffer->UsedBytes != 0 );
            UlpInsertBuffer(pConnection, pNewBuffer);

            ASSERT( UlpIsValidRequestBufferList( pConnection ) );

            //
            // this newly created (larger) buffer is still the next
            // buffer to parse
            //

            ASSERT(pNewBuffer->BufferNumber == pConnection->NextBufferToParse);

            //
            // so make it the current buffer now
            //

            pConnection->pCurrentBuffer = pNewBuffer;

            //
            // and advance the sequence checker
            //

            pConnection->NextBufferToParse += 1;

            //
            // now reset the signal for more data needed
            //

            pConnection->NeedMoreData = 0;
        }

    }
    else
    {

        //
        // is this buffer drained?
        //

        if (pConnection->pCurrentBuffer->UsedBytes ==
            pConnection->pCurrentBuffer->ParsedBytes)
        {
            PUL_REQUEST_BUFFER pOldBuffer;

            //
            // are there any more buffers?
            //

            if (pConnection->pCurrentBuffer->ListEntry.Flink ==
                &(pConnection->BufferHead))
            {

                //
                // need to wait for more.
                //
                // we leave this empty buffer around refcount'd
                // in pCurrentBuffer until a new buffer shows up,
                // or the connection is dropped.
                //
                // this is so we don't lose our place
                // and have to search the sorted queue
                //

                UlTrace(HTTP_IO, (
                    "http!UlpAdjustBuffers(pHttpConn = %p) NeedMoreData == 0\n"
                    "    buffer %p(%d) is drained, more required\n",
                    pConnection,
                    pConnection->pCurrentBuffer,
                    pConnection->pCurrentBuffer->BufferNumber
                    ));


                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            // else

            //
            // grab the next buffer
            //

            pOldBuffer = pConnection->pCurrentBuffer;

            pConnection->
                pCurrentBuffer = CONTAINING_RECORD(
                                        pConnection->
                                            pCurrentBuffer->ListEntry.Flink,
                                        UL_REQUEST_BUFFER,
                                        ListEntry
                                        );

            ASSERT( UL_IS_VALID_REQUEST_BUFFER(pConnection->pCurrentBuffer) );

            //
            // is it the 'next' buffer?
            //

            if (pConnection->pCurrentBuffer->BufferNumber !=
                pConnection->NextBufferToParse)
            {

                UlTrace(HTTP_IO, (
                    "http!UlpAdjustBuffers(pHttpConn %p) NeedMoreData == 0\n"
                    "    Buffer %d available, but we're waiting for %d\n",
                    pConnection,
                    pConnection->pCurrentBuffer->BufferNumber,
                    pConnection->NextBufferToParse
                    ));

                pConnection->pCurrentBuffer = pOldBuffer;

                return STATUS_MORE_PROCESSING_REQUIRED;

            }

            //
            // bump up the buffer number
            //

            pConnection->NextBufferToParse += 1;

            pConnection->NeedMoreData = 0;
        }
    }

    return STATUS_SUCCESS;

}   // UlpAdjustBuffers



/***************************************************************************++

Routine Description:

    Routine invoked after an incoming TCP/MUX connection has been
    received (but not yet accepted).

Arguments:

    pListeningContext - Supplies an uninterpreted context value as
        passed to the UlCreateListeningEndpoint() API.

    pConnection - Supplies the connection being established.

    pRemoteAddress - Supplies the remote (client-side) address
        requesting the connection.

    RemoteAddressLength - Supplies the total byte length of the
        pRemoteAddress structure.

    ppConnectionContext - Receives a pointer to an uninterpreted
        context value to be associated with the new connection if
        accepted. If the new connection is not accepted, this
        parameter is ignored.

Return Value:

    BOOLEAN - TRUE if the connection was accepted, FALSE if not.

--***************************************************************************/
BOOLEAN
UlConnectionRequest(
    IN PVOID pListeningContext,
    IN PUL_CONNECTION pConnection,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    OUT PVOID *ppConnectionContext
    )
{
    PUL_HTTP_CONNECTION pHttpConnection;
    NTSTATUS status;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(HTTP_IO,("UlConnectionRequest: conn %p\n",pConnection));

    //
    // Check the global connection limit. If it's reached then
    // enforce it by refusing the connection request. The TDI will
    // return STATUS_CONNECTION_REFUSED when we return FALSE here
    //

    if (UlAcceptGlobalConnection() == FALSE)
    {
        UlTrace(LIMITS,
            ("UlConnectionRequest: conn %p refused global limit is reached.\n",
              pConnection
              ));

        return FALSE;
    }

    //
    // Create a new HTTP connection.
    //

    status = UlCreateHttpConnection( &pHttpConnection, pConnection );
    if (NT_SUCCESS(status))
    {
        //
        // We the HTTP_CONNECTION pointer as our connection context,
        // ULTDI now owns a reference (from the create).
        //

        *ppConnectionContext = pHttpConnection;

        return TRUE;
    }

    //
    // Failed to create new connection.
    //

    UlTrace(HTTP_IO,
        ("UlpTestConnectionRequest: cannot create new conn, error %08lx\n",
          status
          ));

    return FALSE;

}   // UlConnectionRequest


/***************************************************************************++

Routine Description:

    Routine invoked after an incoming TCP/MUX connection has been
    fully accepted.

    This routine is also invoked if an incoming connection was not
    accepted *after* PUL_CONNECTION_REQUEST returned TRUE. In other
    words, if PUL_CONNECTION_REQUEST indicated that the connection
    should be accepted but a fatal error occurred later, then
    PUL_CONNECTION_COMPLETE is invoked.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

    Status - Supplies the completion status. If this value is
        STATUS_SUCCESS, then the connection is now fully accepted.
        Otherwise, the connection has been aborted.

--***************************************************************************/
VOID
UlConnectionComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    )
{
    PUL_CONNECTION pConnection;
    PUL_HTTP_CONNECTION pHttpConnection;

    //
    // Sanity check.
    //

    pHttpConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(HTTP_IO,("UlConnectionComplete: http %p conn %p status %08lx\n",
            pHttpConnection,
            pConnection,
            Status
            ));

    //
    // Blow away our HTTP connection if the connect failed.
    //

    if (!NT_SUCCESS(Status))
    {
        UL_DEREFERENCE_HTTP_CONNECTION( pHttpConnection );
    }

}   // UlConnectionComplete

/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    disconnected by the remote (client) side.

    This indication is now obsolete no longer get called from TDI.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

    Status - Supplies the termination status.

--***************************************************************************/
VOID
UlConnectionDisconnect(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    )
{
    PUL_CONNECTION pConnection;
    PUL_HTTP_CONNECTION pHttpConnection;

    //
    // Sanity check.
    //

    pHttpConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(HTTP_IO,("UlConnectionDisconnect: http %p conn %p\n",
            pHttpConnection,
            pConnection
            ));

    //
    // We are responsible for closing the server side of the tcp connection.
    // No reason to do an abortive disconnect.  this indication is that the
    // client has ALREADY disconnected.
    //

    Status = UlCloseConnection(pConnection, FALSE, NULL, NULL);

#if DBG
    if (!NT_SUCCESS(Status))
    {
        DbgPrint(
            "UlConnectionDisconnect: cannot close, error %08lx\n",
            Status
            );
    }
#endif

}   // UlConnectionDisconnect

/***************************************************************************++

Routine Description:

    Worker function to do cleanup work that shouldn't happen above DPC level.

Arguments:

    pWorkItem -- a pointer to a UL_WORK_ITEM DisconnectWorkItem

--***************************************************************************/

VOID
UlConnectionDisconnectCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_HTTP_CONNECTION pConnection;

    PAGED_CODE();

    ASSERT(pWorkItem);

    pConnection = CONTAINING_RECORD(
                pWorkItem,
                UL_HTTP_CONNECTION,
                DisconnectWorkItem
                );

    UlTrace(HTTP_IO, (
        "http!UlConnectionDisconnectCompleteWorker (%p) pConnection (%p)\n",
         pWorkItem,
         pConnection
         ));

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    //
    // If connection is already get destroyed just bail out !
    //

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pConnection->pTraceLog,
        REF_ACTION_DRAIN_UL_CONNECTION_DISCONNECT_COMPLETE,
        pConnection->pConnection->ReferenceCount,
        pConnection->pConnection,
        __FILE__,
        __LINE__
        );

    //
    // Check to see if we have to draine out or not.
    //

    UlpDiscardBytesFromConnection( pConnection );

    //
    // Deref the http connection
    //

    UL_DEREFERENCE_HTTP_CONNECTION( pConnection );

} // UlConnectionDisconnectCompleteWorker

/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    disconnected by us (server side) we make a final check here to see
    if we have to drain the connection or not.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

--***************************************************************************/
VOID
UlConnectionDisconnectComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    )
{
    PUL_HTTP_CONNECTION pConnection;

    //
    // Sanity check.
    //

    pConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    UlTrace( HTTP_IO,("UlConnectionDisconnectComplete: pConnection %p \n",
             pConnection
             ));

    UL_REFERENCE_HTTP_CONNECTION( pConnection );

    UL_QUEUE_WORK_ITEM(
            &pConnection->DisconnectWorkItem,
            &UlConnectionDisconnectCompleteWorker
            );

}   // UlConnectionDisconnectComplete

/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    destroyed.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

--***************************************************************************/
VOID
UlConnectionDestroyed(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    )
{
    PUL_CONNECTION pConnection;
    PUL_HTTP_CONNECTION pHttpConnection;
    NTSTATUS status;

    //
    // Sanity check.
    //

    pHttpConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(
        HTTP_IO, (
            "http!UlConnectionDestroyed: http %p conn %p\n",
            pHttpConnection,
            pConnection
            )
        );

    //
    // Remove the CONNECTION and REQUEST opaque id entries and the ULTDI
    // reference
    //

    UL_QUEUE_WORK_ITEM(
        &pHttpConnection->WorkItem,
        UlConnectionDestroyedWorker
        );

}   // UlConnectionDestroyed



/***************************************************************************++

Routine Description:

    handles retrieving entity body from the http request and placing into
    user mode buffers.

Arguments:

    pRequest - the request to receive from.

    pIrp - the user irp to copy it into.  this will be pended, always.

--***************************************************************************/
NTSTATUS
UlReceiveEntityBody(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP pIrp
    )
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpSp;

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));

    //
    // get the current stack location (a macro)
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    UlTraceVerbose(HTTP_IO, (
        "http!UlReceiveEntityBody: process=%p, req=%p, irp=%p, irpsp=%p\n",
        pProcess, pRequest, pIrp, pIrpSp
        ));

    //
    // is there any recv buffer?
    //

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength == 0)
    {
        //
        // nope, shortcircuit this
        //

        Status = STATUS_PENDING;
        pIrp->IoStatus.Information = 0;
        goto end;
    }

    //
    // grab our lock
    //

    UlAcquireResourceExclusive(&(pRequest->pHttpConn->Resource), TRUE);

    //
    // Make sure we're not cleaning up the request before queuing an
    // IRP on it.
    //

    if (pRequest->InCleanup)
    {

        Status = STATUS_CONNECTION_DISCONNECTED;

        UlReleaseResource(&(pRequest->pHttpConn->Resource));

        UlTraceVerbose(HTTP_IO, (
            "http!UlReceiveEntityBody(%p): Cleaning up request, status=0x%x\n",
            pRequest, Status
            ));

        goto end;
    }

    //
    // is there any data to read? either
    //
    //      1) there were no entity chunks OR
    //
    //      2) there were and :
    //
    //          2b) we've are done parsing all of them AND
    //
    //          2c) we've read all we parsed
    //
    //      3) we have encountered an error when parsing
    //         the entity body. Therefore parser was in the
    //         error state.
    //

    if ((pRequest->ContentLength == 0 && pRequest->Chunked == 0) ||
        (pRequest->ParseState > ParseEntityBodyState &&
            pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed) ||
        (pRequest->ParseState == ParseErrorState)
        )
    {
        if ( pRequest->ParseState == ParseErrorState )
        {
            //
            // Do not route up the entity body if we have
            // encountered an error when parsing it.
            //

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
        else
        {
            //
            // nope, complete right away
            //

            Status = STATUS_END_OF_FILE;
        }

        UlReleaseResource(&(pRequest->pHttpConn->Resource));

        UlTraceVerbose(HTTP_IO, (
            "http!UlReceiveEntityBody(%p): No data to read, status=0x%x\n",
            pRequest, Status
            ));

        goto end;
    }

    //
    // queue the irp
    //

    IoMarkIrpPending(pIrp);

    //
    // handle 100 continue message reponses
    //

    if ( HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 1, 1) )
    {
        //
        // if this is a HTTP/1.1 PUT or POST request,
        // send "100 Continue" response.
        //

        if ( (HttpVerbPUT  == pRequest->Verb) ||
             (HttpVerbPOST == pRequest->Verb) )
        {
            //
            // Only send continue once...
            //

            if ( (0 == pRequest->SentContinue) &&
                 (0 == pRequest->SentResponse) )
            {
                ULONG BytesSent;

                BytesSent = UlSendSimpleStatus(pRequest, UlStatusContinue);
                pRequest->SentContinue = 1;

                // Update the server to client bytes sent.
                // The logging & perf counters will use it.

                pRequest->BytesSent += BytesSent;

                UlTraceVerbose(HTTP_IO, (
                    "http!UlReceiveEntityBody(%p): sent \"100 Continue\", "
                    "bytes sent = %d\n",
                    pRequest, pRequest->BytesSent
                    ));
            }
        }
    }

    //
    // give it a pointer to the request object
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pRequest;

    UL_REFERENCE_INTERNAL_REQUEST(pRequest);

    //
    // set to these to null just in case the cancel routine runs
    //

    pIrp->Tail.Overlay.ListEntry.Flink = NULL;
    pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    IoSetCancelRoutine(pIrp, &UlpCancelEntityBody);

    //
    // cancelled?
    //

    if (pIrp->Cancel)
    {
        //
        // darn it, need to make sure the irp get's completed
        //

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // we are in charge of completion, IoCancelIrp didn't
            // see our cancel routine (and won't).  ioctl wrapper
            // will complete it
            //

            UlReleaseResource(&(pRequest->pHttpConn->Resource));

            //
            // let go of the request reference
            //

            UL_DEREFERENCE_INTERNAL_REQUEST(
                (PUL_INTERNAL_REQUEST)(pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer)
                );

            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Information = 0;

            UlUnmarkIrpPending( pIrp );
            Status = STATUS_CANCELLED;
            goto end;
        }

        //
        // our cancel routine will run and complete the irp,
        // don't touch it
        //

        //
        // STATUS_PENDING will cause the ioctl wrapper to
        // not complete (or touch in any way) the irp
        //

        Status = STATUS_PENDING;

        UlReleaseResource(&(pRequest->pHttpConn->Resource));
        goto end;
    }

    //
    // now we are safe to queue it
    //

    //
    // queue the irp on the request
    //

    InsertHeadList(&(pRequest->IrpHead), &(pIrp->Tail.Overlay.ListEntry));

    //
    // Remember IrpHead has been touched so we need to call UlCancelRequestIo.
    //

    pRequest->IrpsPending = TRUE;

    //
    // all done
    //

    Status = STATUS_PENDING;

    //
    // Process the buffer queue (which might process the irp we just queued)
    //

    ASSERT( UlpIsValidRequestBufferList( pRequest->pHttpConn ) );
    UlpProcessBufferQueue(pRequest);

    UlReleaseResource(&(pRequest->pHttpConn->Resource));

    //
    // all done
    //

end:
    UlTraceVerbose(HTTP_IO, (
        "http!UlReceiveEntityBody(%p): returning status=0x%x\n",
        pRequest, Status
        ));

    RETURN(Status);

}   // UlReceiveEntityBody



/***************************************************************************++

Routine Description:

    processes the pending irp queue and buffered body. copying data from the
    buffers into the irps, releasing the buffers and completing the irps

    you must already have the resource locked exclusive on the request prior
    to calling this procedure.

Arguments:

    pRequest - the request which we should process.

--***************************************************************************/
VOID
UlpProcessBufferQueue(
    PUL_INTERNAL_REQUEST pRequest
    )
{
    ULONG                   OutputBufferLength;
    PUCHAR                  pOutputBuffer;
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;
    PLIST_ENTRY             pEntry;
    ULONG                   BytesToCopy;
    ULONG                   BufferLength;
    ULONG                   TotalBytesConsumed;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    ASSERT(UlDbgResourceOwnedExclusive(&pRequest->pHttpConn->Resource));

    //
    // now let's pop some buffers off the list
    //

    OutputBufferLength = 0;
    TotalBytesConsumed = 0;
    pIrp = NULL;

    while (TRUE)
    {
        //
        // is there any more entity body to read?
        //

        UlTraceVerbose(HTTP_IO, (
            "http!UlpProcessBufferQueue(req=%p): "
            "ParseState=%d, ChunkBytesRead=%d, ChunkBytesParsed=%d, "
            "ChunkBuffer=%p\n",
            pRequest, pRequest->ParseState,
            pRequest->ChunkBytesRead, pRequest->ChunkBytesParsed,
            pRequest->pChunkBuffer
            ));

        if (pRequest->ParseState > ParseEntityBodyState &&
            pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed)
        {
            //
            // nope, let's loop through all of the irp's, completing 'em
            //

            UlTraceVerbose(HTTP_IO, (
                "http!UlpProcessBufferQueue(req=%p): no more EntityBody\n",
                pRequest
                ));

            BufferLength = 0;
        }

        //
        // Do we have data ready to be read ?
        //
        // we have not recieved the first chunk from the parser? OR
        // the parser has not parsed any more data, we've read it all so far
        //

        else if (pRequest->pChunkBuffer == NULL ||
                 pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed)
        {
            //
            // Wait for the parser .... UlpParseNextRequest will call
            // this function when it has seen more .
            //

            UlTraceVerbose(HTTP_IO, (
                "http!UlpProcessBufferQueue(req=%p): pChunkBuffer=%p, "
                "ChunkBytesRead=0x%I64x, ChunkBytesParsed=0x%I64x.\n",
                pRequest, pRequest->pChunkBuffer,
                pRequest->ChunkBytesRead, pRequest->ChunkBytesParsed
                ));

            break;
        }

        //
        // We are ready to process !
        //

        else
        {
            BufferLength = pRequest->pChunkBuffer->UsedBytes -
                            DIFF(pRequest->pChunkLocation -
                                pRequest->pChunkBuffer->pBuffer);

            UlTraceVerbose(HTTP_IO, (
                "http!UlpProcessBufferQueue(req=%p): BufferLength=0x%x\n",
                pRequest, BufferLength
                ));
        }

        //
        // do we need a fresh irp?
        //

        if (OutputBufferLength == 0)
        {

            //
            // need to complete the current in-used irp first
            //

            if (pIrp != NULL)
            {
                //
                // let go of the request reference
                //

                UL_DEREFERENCE_INTERNAL_REQUEST(
                    (PUL_INTERNAL_REQUEST)pIrpSp->Parameters.
                                        DeviceIoControl.Type3InputBuffer
                    );

                pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                //
                // complete the used irp
                //

                UlTraceVerbose(HTTP_IO, (
                    "http!UlpProcessBufferQueue(req=%p): "
                    "completing Irp %p, Status=0x%x\n",
                    pRequest, pIrp,
                    pIrp->IoStatus.Status
                ));

                UlCompleteRequest(pIrp, g_UlPriorityBoost);

                pIrp = NULL;

            }

            //
            // dequeue an irp
            //

            while (IsListEmpty(&(pRequest->IrpHead)) == FALSE)
            {
                pEntry = RemoveTailList(&(pRequest->IrpHead));
                pEntry->Blink = pEntry->Flink = NULL;

                pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
                pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

                //
                // pop the cancel routine
                //

                if (IoSetCancelRoutine(pIrp, NULL) == NULL)
                {
                    //
                    // IoCancelIrp pop'd it first
                    //
                    // ok to just ignore this irp, it's been pop'd off the
                    // queue and will be completed in the cancel routine.
                    //
                    // keep looking for a irp to use
                    //

                }
                else if (pIrp->Cancel)
                {
                    //
                    // we pop'd it first. but the irp is being cancelled
                    // and our cancel routine will never run. lets be
                    // nice and complete the irp now (vs. using it
                    // then completing it - which would also be legal).
                    //

                    //
                    // let go of the request reference
                    //

                    UL_DEREFERENCE_INTERNAL_REQUEST(
                        (PUL_INTERNAL_REQUEST)pIrpSp->Parameters.
                                        DeviceIoControl.Type3InputBuffer
                        );

                    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                    //
                    // complete the irp
                    //

                    pIrp->IoStatus.Status = STATUS_CANCELLED;
                    pIrp->IoStatus.Information = 0;

                    UlTraceVerbose(HTTP_IO, (
                        "http!UlpProcessBufferQueue(req=%p): "
                        "completing cancelled Irp %p, Status=0x%x\n",
                        pRequest, pIrp,
                        pIrp->IoStatus.Status
                        ));

                    UlCompleteRequest(pIrp, g_UlPriorityBoost);

                    pIrp = NULL;
                }
                else
                {

                    //
                    // we are free to use this irp !
                    //

                    break;
                }

            }   // while (IsListEmpty(&(pRequest->IrpHead)) == FALSE)

            //
            // did we get an irp?
            //

            if (pIrp == NULL)
            {
                //
                // stop looping
                //

                break;
            }

            UlTraceVerbose(HTTP_IO, (
                "http!UlpProcessBufferQueue(req=%p): found Irp %p\n",
                pRequest, pIrp
                ));

            //
            // CODEWORK: we could release the request now.
            //

            OutputBufferLength =
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

            pOutputBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                pIrp->MdlAddress,
                                NormalPagePriority
                                );

            if ( pOutputBuffer == NULL )
            {
                pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                pIrp->IoStatus.Information = 0;

                break;
            }

            //
            // fill in the IO_STATUS_BLOCK
            //

            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = 0;

        } // if (OutputBufferLength == 0)


        UlTrace(
            HTTP_IO, (
                "http!UlpProcessBufferQueue(req=%p): pChunkBuffer=%p(%d)\n",
                pRequest,
                pRequest->pChunkBuffer,
                pRequest->pChunkBuffer == NULL ?
                    -1 :
                    pRequest->pChunkBuffer->BufferNumber
                )
            );

        //
        // how much of it can we copy?  min of both buffer sizes
        // and the chunk size
        //

        BytesToCopy = MIN(BufferLength, OutputBufferLength);
        BytesToCopy = (ULONG)(MIN(
                            (ULONGLONG)(BytesToCopy),
                            pRequest->ChunkBytesToRead
                            ));

        if (BytesToCopy > 0)
        {
            ASSERT(pRequest->pChunkBuffer != NULL) ;

            //
            // copy the buffer
            //

            RtlCopyMemory(
                pOutputBuffer,
                pRequest->pChunkLocation,
                BytesToCopy
                );

            IF_DEBUG2(HTTP_IO, VERBOSE)
            {
                UlTraceVerbose( HTTP_IO, (
                    ">>>> http!UlpProcessBufferQueue(req=%p): %d bytes\n",
                    pRequest, BytesToCopy
                ));

                UlDbgPrettyPrintBuffer(pOutputBuffer, BytesToCopy);

                UlTraceVerbose( HTTP_IO, ("<<<<\n"));
            }

            pRequest->pChunkLocation += BytesToCopy;
            BufferLength -= BytesToCopy;

            pRequest->ChunkBytesToRead -= BytesToCopy;
            pRequest->ChunkBytesRead += BytesToCopy;

            pOutputBuffer += BytesToCopy;
            OutputBufferLength -= BytesToCopy;

            pIrp->IoStatus.Information += BytesToCopy;

            TotalBytesConsumed += BytesToCopy;

        }
        else
        {
            UlTraceVerbose(HTTP_IO, (
                "http!UlpProcessBufferQueue(req=%p): BytesToCopy=0\n",
                pRequest
                ));
        }


        //
        // are we all done with body?

        //
        // when the parser is all done, and we caught up with the parser
        // we are all done.
        //

        UlTraceVerbose(HTTP_IO, (
            "http!UlpProcessBufferQueue(req=%p): "
            "ParseState=%d, ChunkBytesRead=%d, BytesParsed=%d, "
            "BytesToRead=%d, BufferLength=%d\n",
            pRequest, pRequest->ParseState,
            pRequest->ChunkBytesRead, pRequest->ChunkBytesParsed,
            pRequest->ChunkBytesToRead, BufferLength
            ));

        if (pRequest->ParseState > ParseEntityBodyState &&
            pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed)
        {
            //
            // we are done buffering, mark this irp's return status
            // if we didn't copy any data into it
            //

            if (pIrp->IoStatus.Information == 0)
            {
                pIrp->IoStatus.Status = STATUS_END_OF_FILE;
            }

            //
            // force it to complete at the top of the loop
            //

            OutputBufferLength = 0;

            UlTraceVerbose(HTTP_IO, (
                "http!UlpProcessBufferQueue(req=%p): "
                "set Irp %p status to EOF\n",
                pRequest, pIrp
                ));
        }

        //
        // need to do buffer management? three cases to worry about:
        //
        //  1) consumed the buffer, but more chunk bytes exist
        //
        //  2) consumed the buffer, and no more chunk bytes exist
        //
        //  3) did not consume the buffer, but no more chunk bytes exist
        //

        else if (BufferLength == 0)
        {
            PUL_REQUEST_BUFFER pNewBuffer;
            PLIST_ENTRY pNextEntry;

            //
            // consumed the buffer, has the parser already seen another?
            //

            //
            // end of the list?
            //

            if (pRequest->pChunkBuffer->ListEntry.Flink !=
                &(pRequest->pHttpConn->BufferHead))
            {
                pNewBuffer = CONTAINING_RECORD(
                                    pRequest->pChunkBuffer->ListEntry.Flink,
                                    UL_REQUEST_BUFFER,
                                    ListEntry
                                    );

                ASSERT( UL_IS_VALID_REQUEST_BUFFER(pNewBuffer) );

                //
                // There had better be some bytes in this buffer
                //
                ASSERT( 0 != pNewBuffer->UsedBytes );

            }
            else
            {
                pNewBuffer = NULL;
            }

            UlTraceVerbose(HTTP_IO, (
                "http!UlpProcessBufferQueue(req=%p): "
                "pNewBuffer = %p, %d parsed bytes\n",
                pRequest, pNewBuffer, (pNewBuffer ? pNewBuffer->ParsedBytes : 0)
                ));

            //
            // the flink buffer is a "next buffer" (the list is circular)
            // AND that buffer has been consumed by the parser,
            //
            // then we too can move on to it and start consuming.
            //

            if (pNewBuffer != NULL && pNewBuffer->ParsedBytes > 0)
            {
                PUL_REQUEST_BUFFER pOldBuffer;

                //
                // remember the old buffer
                //

                pOldBuffer = pRequest->pChunkBuffer;

                ASSERT(pNewBuffer->BufferNumber > pOldBuffer->BufferNumber);

                //
                // use it the new one
                //

                pRequest->pChunkBuffer = pNewBuffer;
                ASSERT( UL_IS_VALID_REQUEST_BUFFER(pRequest->pChunkBuffer) );

                //
                // update our current location in the buffer and record
                // its length
                //

                pRequest->pChunkLocation = pRequest->pChunkBuffer->pBuffer;

                BufferLength = pRequest->pChunkBuffer->UsedBytes;

                //
                // did the chunk end on that buffer boundary and there are
                // more chunks ?
                //

                if (pRequest->ChunkBytesToRead == 0)
                {
                    NTSTATUS    Status;
                    ULONG       BytesTaken = 0L;

                    //
                    // we know there are more chunk buffers,
                    // thus we must be chunk encoded
                    //

                    ASSERT(pRequest->Chunked == 1);

                    //
                    // the chunk length is not allowed to span buffers,
                    // let's parse it
                    //

                    Status = UlParseChunkLength(
                                    pRequest,
                                    pRequest->pChunkLocation,
                                    BufferLength,
                                    &BytesTaken,
                                    &(pRequest->ChunkBytesToRead)
                                    );

                    UlTraceVerbose(HTTP_IO, (
                        "http!UlpProcessBufferQueue(pReq=%p): Status=0x%x. "
                        "Chunk length (a): %d bytes taken, "
                        "0x%I64x bytes to read.\n",
                        pRequest, Status,
                        BytesTaken, pRequest->ChunkBytesToRead
                        ));

                    //
                    // this can't fail, the only failure case from
                    // ParseChunkLength spanning buffers, which the parser
                    // would have fixed in HandleRequest
                    //

                    ASSERT(NT_SUCCESS(Status) && BytesTaken > 0);
                    ASSERT(pRequest->ChunkBytesToRead > 0);

                    ASSERT(BytesTaken <= BufferLength);

                    pRequest->pChunkLocation += BytesTaken;
                    BufferLength -= BytesTaken;

                }   // if (pRequest->ChunkBytesToRead == 0)

                UlTrace(HTTP_IO, (
                    "http!UlpProcessBufferQueue(pRequest = %p)\n"
                    "    finished with pOldBuffer = %p(%d)\n"
                    "    moved on to pChunkBuffer = %p(%d)\n"
                    "    pConn(%p)->pCurrentBuffer = %p(%d)\n"
                    "    pRequest->pLastHeaderBuffer = %p(%d)\n",
                    pRequest,
                    pOldBuffer,
                    pOldBuffer->BufferNumber,
                    pRequest->pChunkBuffer,
                    pRequest->pChunkBuffer ? pRequest->pChunkBuffer->BufferNumber : -1,
                    pRequest->pHttpConn,
                    pRequest->pHttpConn->pCurrentBuffer,
                    pRequest->pHttpConn->pCurrentBuffer->BufferNumber,
                    pRequest->pLastHeaderBuffer,
                    pRequest->pLastHeaderBuffer->BufferNumber
                    ));

                //
                // let the old buffer go if it doesn't contain any header
                // data. We're done with it.
                //

                if (pOldBuffer != pRequest->pLastHeaderBuffer)
                {
                    //
                    // the connection should be all done using this, the only
                    // way we get here is if the parser has seen this buffer
                    // thus pCurrentBuffer points at least to pNewBuffer.
                    //

                    ASSERT(pRequest->pHttpConn->pCurrentBuffer != pOldBuffer);

                    UlFreeRequestBuffer(pOldBuffer);
                    pOldBuffer = NULL;
                }

            } // if (pNewBuffer != NULL && pNewBuffer->ParsedBytes > 0)

        }   // else if (BufferLength == 0)

        //
        // ok, there's more bytes in the buffer, but how about the chunk?
        //

        //
        // Have we taken all of the current chunk?
        //

        else if (pRequest->ChunkBytesToRead == 0)
        {

            //
            // Are we are still behind the parser?
            //

            if (pRequest->ChunkBytesRead < pRequest->ChunkBytesParsed)
            {
                NTSTATUS    Status;
                ULONG       BytesTaken;

                ASSERT(pRequest->Chunked == 1);

                //
                // the chunk length is not allowed to span buffers,
                // let's parse it
                //

                Status = UlParseChunkLength(
                                pRequest,
                                pRequest->pChunkLocation,
                                BufferLength,
                                &BytesTaken,
                                &(pRequest->ChunkBytesToRead)
                                );

                UlTraceVerbose(HTTP_IO, (
                    "http!UlpProcessBufferQueue(pRequest=%p): Status=0x%x. "
                    "chunk length (b): %d bytes taken, "
                    "0x%I64x bytes to read.\n",
                    pRequest, Status,
                    BytesTaken, pRequest->ChunkBytesToRead
                    ));

                //
                // this can't fail, the only failure case from
                // ParseChunkLength spanning buffers, which the parser
                // would have fixed in HandleRequest
                //

                ASSERT(NT_SUCCESS(Status) && BytesTaken > 0);
                ASSERT(pRequest->ChunkBytesToRead > 0);

                ASSERT(BytesTaken <= BufferLength);

                pRequest->pChunkLocation += BytesTaken;
                BufferLength -= BytesTaken;

            }
            else
            {
                //
                // Need to wait for the parser to parse more
                //

                UlTraceVerbose(HTTP_IO, (
                    "http!UlpProcessBufferQueue(pRequest = %p): "
                    "need to parse more\n",
                    pRequest
                    ));

                break;
            }
        } // else if (pRequest->ChunkBytesToRead == 0)


        //
        // next irp or buffer
        //

    }   // while (TRUE)

    //
    // complete the irp we put partial data in
    //

    if (pIrp != NULL)
    {

        //
        // let go of the request reference
        //

        UL_DEREFERENCE_INTERNAL_REQUEST(
            (PUL_INTERNAL_REQUEST)pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer
            );

        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        //
        // complete the used irp
        //

        UlTraceVerbose(HTTP_IO, (
            "http!UlpProcessBufferQueue(req=%p): "
            "completing used Irp %p, Status=0x%x\n",
            pRequest,
            pIrp, pIrp->IoStatus.Status
            ));

        UlCompleteRequest(pIrp, g_UlPriorityBoost);

        pIrp = NULL;
    }
    else
    {
        UlTraceVerbose(HTTP_IO, (
            "http!UlpProcessBufferQueue(req=%p): no irp with partial data\n",
            pRequest
            ));
    }

    //
    // Tell the connection how many bytes we consumed. This
    // may allow us to restart receive indications.
    //

    UlTraceVerbose(HTTP_IO, (
        "http!UlpProcessBufferQueue(req=%p, httpconn=%p): "
        "%u bytes consumed\n",
        pRequest, pRequest->pHttpConn, TotalBytesConsumed
        ));

    if (TotalBytesConsumed)
    {
        UlpConsumeBytesFromConnection(
            pRequest->pHttpConn,
            TotalBytesConsumed
            );
    }

    //
    // all done
    //

}   // UlpProcessBufferQueue


/***************************************************************************++

Routine Description:

    This function subtracts from the total number of bytes currently buffered
    on the UL_HTTP_CONNECTION object. If there are bytes from the transport
    that we previously refused, this function may issue a receive to restart
    the flow of data from TCP.

Arguments:

    pConnection - the connection on which the bytes came in
    BytesCount - the number of bytes consumed

--***************************************************************************/
VOID
UlpConsumeBytesFromConnection(
    IN PUL_HTTP_CONNECTION pConnection,
    IN ULONG ByteCount
    )
{
    KIRQL oldIrql;
    ULONG SpaceAvailable;
    ULONG BytesToRead;
    BOOLEAN IssueReadIrp;

    //
    // Sanity check.
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(ByteCount != 0);

    //
    // Set up locals.
    //

    BytesToRead = 0;
    IssueReadIrp = FALSE;


    //
    // Consume the bytes.
    //

    UlAcquireSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        &oldIrql
        );

    ASSERT(ByteCount <= pConnection->BufferingInfo.BytesBuffered);
    if (ByteCount > pConnection->BufferingInfo.BytesBuffered)
    {
        //
        // This should never happen, but if it does then make sure
        // we don't subtract more BufferedBytes than we have.
        //
        ByteCount = pConnection->BufferingInfo.BytesBuffered;
    }

    //
    // Compute the new number of buffered bytes.
    //

    pConnection->BufferingInfo.BytesBuffered -= ByteCount;

    //
    // Trace.
    //
    if (g_UlMaxBufferedBytes > pConnection->BufferingInfo.BytesBuffered)
    {
        SpaceAvailable = g_UlMaxBufferedBytes
                            - pConnection->BufferingInfo.BytesBuffered;
    }
    else
    {
        SpaceAvailable = 0;
    }

    UlTrace(HTTP_IO, (
        "UlpConsumeBytesFromConnection(pconn = %p, bytes = %ld)\n"
        "        Space = %ld, buffered %ld, not taken = %ld\n",
        pConnection,
        ByteCount,
        SpaceAvailable,
        pConnection->BufferingInfo.BytesBuffered,
        pConnection->BufferingInfo.TransportBytesNotTaken
        ));


    //
    // See if we need to issue a receive to restart the flow of data.
    //

    if ((SpaceAvailable > 0) &&
        (pConnection->BufferingInfo.TransportBytesNotTaken > 0) &&
        (!pConnection->BufferingInfo.ReadIrpPending))
    {


        //
        // Remember that we issued an IRP.
        //

        pConnection->BufferingInfo.ReadIrpPending = TRUE;

        //
        // Issue the Read IRP outside the spinlock.
        //

        IssueReadIrp = TRUE;
        BytesToRead = pConnection->BufferingInfo.TransportBytesNotTaken;

        //
        // Don't read more bytes than we want to buffer.
        //

        BytesToRead = MIN(BytesToRead, SpaceAvailable);
    }

    UlReleaseSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        oldIrql
        );

    if (IssueReadIrp)
    {
        NTSTATUS Status;
        PUL_REQUEST_BUFFER pRequestBuffer;

        //
        // get a new request buffer, but initialize it
        // with a bogus number. We have to allocate it now,
        // but we want to set the number when the data
        // arrives in the completion routine (like UlHttpReceive
        // does) to avoid synchronization trouble.
        //

        pRequestBuffer = UlCreateRequestBuffer(
                                BytesToRead,
                                (ULONG)-1       // BufferNumber
                                );


        if (pRequestBuffer)
        {

            //
            // Add a backpointer to the connection.
            //

            pRequestBuffer->pConnection = pConnection;

            //
            // We've got the buffer. Issue the receive.
            // Reference the connection so it doesn't
            // go away while we're waiting. The reference
            // will be removed after the completion.
            //

            UL_REFERENCE_HTTP_CONNECTION( pConnection );

            Status = UlReceiveData(
                            pConnection->pConnection,
                            pRequestBuffer->pBuffer,
                            BytesToRead,
                            &UlpRestartHttpReceive,
                            pRequestBuffer
                            );

        }
        else
        {
            //
            // We're out of memory. Nothing we can do.
            //
            Status = STATUS_NO_MEMORY;

        }


        if (!NT_SUCCESS(Status))
        {
            //
            // Couldn't issue the read. Close the connection.
            //

            UlCloseConnection(
                pConnection->pConnection,
                TRUE,                       // AbortiveDisconnect
                NULL,                       // pCompletionRoutine
                NULL                        // pCompletionContext
                );

        }

    }
} // UlpConsumeBytesFromConnection

/***************************************************************************++

Routine Description:

    Once a connection get disconnected gracefully and there's still unreceived
    data on it. We have to drain this extra bytes to expect the tdi disconnect
    indication. We have to drain this data because we need the disconnect indi
    cation to clean up the connection. And we cannot simply abort it. If we do
    not do this we will leak this connection object  and finally it will cause
    shutdown failures.

Arguments:

    pConnection - stuck connection we have to drain out to complete the
                  gracefull disconnect.

--***************************************************************************/

VOID
UlpDiscardBytesFromConnection(
    IN PUL_HTTP_CONNECTION pConnection
    )
{
    NTSTATUS Status;
    PUL_REQUEST_BUFFER pRequestBuffer;
    KIRQL OldIrql;
    ULONG BytesToRead;

    //
    // Sanity check and init
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    Status         = STATUS_SUCCESS;
    BytesToRead    = 0;
    pRequestBuffer = NULL;

    //
    // Mark the drain state and restart receive if necessary.
    //

    UlAcquireSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        &OldIrql
        );

    pConnection->BufferingInfo.DrainAfterDisconnect = TRUE;

    //
    // Even if ReadIrp is pending, it does not matter as we will just  discard
    // the indications from now on. We indicate this by marking the above flag
    //

    if ( pConnection->BufferingInfo.ReadIrpPending ||
         pConnection->BufferingInfo.TransportBytesNotTaken == 0
         )
    {
        UlReleaseSpinLock(
            &pConnection->BufferingInfo.BufferingSpinLock,
            OldIrql
            );

        return;
    }

    //
    // As soon as we enter this "DrainAfterDisconnect" state we will not be
    // processing and inserting request buffers anymore. For any new receive
    // indications, we will just mark the whole available data as taken and
    // don't do nothing about it.
    //

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pConnection->pTraceLog,
        REF_ACTION_DRAIN_UL_CONNECTION_START,
        pConnection->pConnection->ReferenceCount,
        pConnection->pConnection,
        __FILE__,
        __LINE__
        );

    //
    // We need to issue a receive to restart the flow of data again. Therefore
    // we can drain.
    //

    pConnection->BufferingInfo.ReadIrpPending = TRUE;

    BytesToRead = pConnection->BufferingInfo.TransportBytesNotTaken;

    UlReleaseSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        OldIrql
        );

    //
    // Do not try to drain more than g_UlMaxBufferedBytes. If necessary we will
    // issue another receive later.
    //

    BytesToRead = MIN( BytesToRead, g_UlMaxBufferedBytes );

    UlTrace(HTTP_IO,(
        "UlpDiscardBytesFromConnection: pConnection (%p) consuming %d\n",
         pConnection,
         BytesToRead
         ));

    //
    // Issue the Read IRP outside the spinlock. Issue the receive.  Reference
    // the connection so it doesn't go away while we're waiting. The reference
    // will be removed after the completion.
    //

    pRequestBuffer = UlCreateRequestBuffer( BytesToRead,
                                            (ULONG)-1
                                            );
    if (pRequestBuffer)
    {
        //
        // We won't use this buffer but simply discard it when completion happens.
        // Lets still set the pConnection so that completion function doesn't
        // complain
        //

        pRequestBuffer->pConnection = pConnection;

        UL_REFERENCE_HTTP_CONNECTION( pConnection );

        Status = UlReceiveData(pConnection->pConnection,
                               pRequestBuffer->pBuffer,
                               BytesToRead,
                              &UlpRestartHttpReceive,
                               pRequestBuffer
                               );
    }
    else
    {
        //
        // We're out of memory. Nothing we can do.
        //

        Status = STATUS_NO_MEMORY;
    }

    if ( !NT_SUCCESS(Status) )
    {
        //
        // Couldn't issue the receive. ABORT the connection.
        //
        // CODEWORK: We need a real abort here. If connection is
        // previously gracefully disconnected and a fatal failure
        // happened during drain after disconnect. This abort will
        // be discarded by the Close handler. We have to provide a
        // way to do a forceful abort here.
        //

        UlCloseConnection(
                pConnection->pConnection,
                TRUE,                       // Abortive
                NULL,                       // pCompletionRoutine
                NULL                        // pCompletionContext
                );
    }

} // UlpDiscardBytesFromConnection


/***************************************************************************++

Routine Description:

    Called on a read completion. This happens when we had stopped
    data indications for some reason and then restarted them. This
    function mirrors UlHttpReceive.

Arguments:

    pContext - pointer to the FilterRawRead IRP
    Status - Status from UlReceiveData
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartHttpReceive(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_HTTP_CONNECTION pConnection;
    PUL_REQUEST_BUFFER pRequestBuffer;
    KIRQL oldIrql;
    ULONG TransportBytesNotTaken;

    pRequestBuffer = (PUL_REQUEST_BUFFER)pContext;
    ASSERT(UL_IS_VALID_REQUEST_BUFFER(pRequestBuffer));

    pConnection = pRequestBuffer->pConnection;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    if (NT_SUCCESS(Status))
    {
        //
        // update our stats
        //
        UlAcquireSpinLock(
            &pConnection->BufferingInfo.BufferingSpinLock,
            &oldIrql
            );

        ASSERT(Information <= pConnection->BufferingInfo.TransportBytesNotTaken);

        //
        // We've now read they bytes from the transport and
        // buffered them.
        //
        pConnection->BufferingInfo.TransportBytesNotTaken -= (ULONG)Information;
        pConnection->BufferingInfo.BytesBuffered += (ULONG)Information;

        pConnection->BufferingInfo.ReadIrpPending = FALSE;

        if ( pConnection->BufferingInfo.DrainAfterDisconnect )
        {
            //
            // Just free the memory and restart the receive if necessary.
            //

            TransportBytesNotTaken = pConnection->BufferingInfo.TransportBytesNotTaken;

            UlReleaseSpinLock(
                &pConnection->BufferingInfo.BufferingSpinLock,
                oldIrql
                );

            WRITE_REF_TRACE_LOG2(
                g_pTdiTraceLog,
                pConnection->pConnection->pTraceLog,
                REF_ACTION_DRAIN_UL_CONNECTION_RESTART,
                pConnection->pConnection->ReferenceCount,
                pConnection->pConnection,
                __FILE__,
                __LINE__
                );

            if ( TransportBytesNotTaken )
            {
                //
                // Keep draining ...
                //

                UlpDiscardBytesFromConnection( pConnection );
            }

            UlTrace(HTTP_IO,(
               "UlpRestartHttpReceive(d): pConnection (%p) drained %d remaining %d\n",
                pConnection,
                Information,
                TransportBytesNotTaken
                ));

            //
            // Free the request buffer. And release our reference.
            //

            UlFreeRequestBuffer( pRequestBuffer );
            UL_DEREFERENCE_HTTP_CONNECTION( pConnection );

            return;
        }

        //
        // Get the request buffer ready to be inserted.
        //
        pRequestBuffer->UsedBytes = (ULONG) Information;
        ASSERT( 0 != pRequestBuffer->UsedBytes );

        pRequestBuffer->BufferNumber = pConnection->NextBufferNumber;
        pConnection->NextBufferNumber++;

        UlReleaseSpinLock(
            &pConnection->BufferingInfo.BufferingSpinLock,
            oldIrql
            );

        UlTrace(HTTP_IO, (
            "UlpRestartHttpReceive(pconn = %p, %x, %ld)\n"
            "        buffered = %ld, not taken = %ld\n",
            pConnection,
            Status,
            (ULONG)Information,
            pConnection->BufferingInfo.BytesBuffered,
            pConnection->BufferingInfo.TransportBytesNotTaken
            ));

        //
        // queue it off
        //

        UlTrace( PARSER, (
            "*** Request Buffer %p has connection %p\n",
            pRequestBuffer,
            pConnection
            ));

        UL_QUEUE_WORK_ITEM(
            &(pRequestBuffer->WorkItem),
            &UlpHandleRequest
            );

    }
    else
    {

        UlCloseConnection(
            pConnection->pConnection,
            TRUE,
            NULL,
            NULL
            );

        //
        // Release the reference we added to the connection
        // before issuing the read. Normally this ref would
        // be released in UlpHandleRequest.
        //
        UL_DEREFERENCE_HTTP_CONNECTION(pConnection);

        //
        // free the request buffer.
        //

        UlFreeRequestBuffer(pRequestBuffer);
    }
} // UlpRestartHttpReceive



/***************************************************************************++

Routine Description:

    cancels the pending user mode irp which was to receive entity body.  this
    routine ALWAYS results in the irp being completed.

    note: we queue off to cancel in order to process the cancellation at lower
    irql.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelEntityBody(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // queue the cancel to a worker to ensure passive irql.
    //

    UL_CALL_PASSIVE(
        UL_WORK_ITEM_FROM_IRP( pIrp ),
        &UlpCancelEntityBodyWorker
        );

} // UlpCancelEntityBody



/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem - the work item to process.

--***************************************************************************/
VOID
UlpCancelEntityBodyWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PIRP                    pIrp;
    PUL_INTERNAL_REQUEST    pRequest;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // grab the request off the irp
    //

    pRequest = (PUL_INTERNAL_REQUEST)(
                    IoGetCurrentIrpStackLocation(pIrp)->
                        Parameters.DeviceIoControl.Type3InputBuffer
                    );

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // grab the lock protecting the queue'd irp
    //

    UlAcquireResourceExclusive(&(pRequest->pHttpConn->Resource), TRUE);

    //
    // does it need to be dequeue'd ?
    //

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        //
        // remove it
        //

        RemoveEntryList(&(pIrp->Tail.Overlay.ListEntry));

        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    }

    //
    // let the lock go
    //

    UlReleaseResource(&(pRequest->pHttpConn->Resource));

    //
    // let our reference go
    //

    IoGetCurrentIrpStackLocation(pIrp)->
        Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

    //
    // complete the irp
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlTrace(HTTP_IO, (
        "UlpCancelEntityBodyWorker(pIrp=%p): Status=0x%x.\n",
        pIrp, pIrp->IoStatus.Status
        ));

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

} // UlpCancelEntityBodyWorker


//
// types and functions for sending error responses
//

typedef struct _UL_HTTP_ERROR_ENTRY
{
    USHORT StatusCode;
    ULONG  ReasonLength;
    PSTR   pReason;
    ULONG  BodyLength;
    PSTR   pBody;
} UL_HTTP_ERROR_ENTRY, PUL_HTTP_ERROR_ENTRY;

#define HTTP_ERROR_ENTRY(StatusCode, pReason, pBody)    \
    {                                                   \
        (StatusCode),                                   \
        sizeof((pReason))-sizeof(CHAR),                 \
        (pReason),                                      \
        sizeof((pBody))-sizeof(CHAR),                   \
        (pBody)                                         \
    }

//
// ErrorTable[] must match the order of the UL_HTTP_ERROR enum
// in httptypes.h
//

const
UL_HTTP_ERROR_ENTRY ErrorTable[] =
{
    //
    // UlError
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request</H1>"),
    //
    // UlErrorVerb
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request (invalid verb)</H1>"),
    //
    // UlErrorUrl
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request (invalid url)</H1>"),
    //
    // UlErrorHeader
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request (invalid header name)</H1>"),
    //
    // UlErrorHost
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request (invalid hostname)</H1>"),
    //
    // UlErrorCRLF
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request (invalid CR or LF)</H1>"),
    //
    // UlErrorNum
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request (invalid number)</H1>"),
    //
    // UlErrorFieldLength
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request (Header Field Too Long)</H1>"),
    //
    // UlErrorUrlLength
    //
    HTTP_ERROR_ENTRY(414, "Bad Request", "<H1>Url Too Long</H1>"),
    //
    // UlErrorRequestLength
    //
    HTTP_ERROR_ENTRY(400, "Bad Request", "<H1>Bad Request (Request Header Too Long)</H1>"),
    //
    // UlErrorVersion
    //
    HTTP_ERROR_ENTRY(505, "HTTP Version not supported", "<H1>HTTP Version not supported</H1>"),
    //
    // UlErrorUnavailable
    //
    HTTP_ERROR_ENTRY(503, "Service Unavailable", "<H1>Service Unavailable</H1>"),
    //
    // UlErrorContentLength
    //
    HTTP_ERROR_ENTRY(411, "Length required", "<H1>Length required</H1>"),
    //
    // UlErrorEntityTooLarge
    //
    HTTP_ERROR_ENTRY(413, "Request Entity Too Large", "<H1>Request Entity Too Large</H1>"),
    //
    // UlErrorConnectionLimit
    //
    HTTP_ERROR_ENTRY(403, "Forbidden", "<H1>Forbidden - Too many users</H1>"),
    //
    // UlErrorNotImplemented
    //
    HTTP_ERROR_ENTRY(501, "Not Implemented", "<H1>Not Implemented</H1>"),

    // UlErrorInternalServer
    //
    HTTP_ERROR_ENTRY(500, "Internal Server Error", "<H1>Internal Server Error</H1>"),
    //
    // UlErrorPreconditionFailed
    //
    HTTP_ERROR_ENTRY(412, "Precondition Failed", "<H1>Precondition Failed</H1>"),
    //
    // UlErrorForbiddenUrl
    //
    HTTP_ERROR_ENTRY(403, "Forbidden", "<H1>Forbidden (Invalid URL)</H1>"),

}; // ErrorTable[]



/***************************************************************************++

Routine Description:

    You should hold the connection Resource before calling this
    function.

Arguments:

    self explanatory

--***************************************************************************/

VOID
UlSendErrorResponse(
    PUL_HTTP_CONNECTION pConnection
    )
{
    NTSTATUS                    Status;
    PUL_INTERNAL_REQUEST        pRequest;
    HTTP_RESPONSE               Response;
    HTTP_DATA_CHUNK             DataChunk;
    PUL_INTERNAL_RESPONSE       pKeResponse = NULL;
    CHAR                        ContentType[] = "text/html";
    USHORT                      ContentTypeLength = sizeof(ContentType) - sizeof(CHAR);

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(UlDbgResourceOwnedExclusive(&pConnection->Resource));

    pRequest = pConnection->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // To prevent sending back double responses. We will
    // check if user (WP) has already sent one.
    //

    pConnection->WaitingForResponse = 1;

    UlTrace( PARSER, (
            "*** pConnection %p->WaitingForResponse = 1\n",
            pConnection
            ));

    //
    // We will send a response back. won't we ?
    // An error response.
    //

    if (1 == InterlockedCompareExchange(
                (PLONG)&pRequest->SentResponse,
                1,
                0
                ))
    {
        UlTrace( PARSER, (
            "*** pConnection %p, pRequest %p, skipping SendError.\n",
            pConnection,
            pRequest
            ));

        return;
    }

    //
    // Proceed with constructing and sending the error
    // back to the client
    //

    RtlZeroMemory(&Response, sizeof(Response));

    if (pRequest->ErrorCode >= DIMENSION(ErrorTable))
    {
        pRequest->ErrorCode = UlError;
    }

    Response.StatusCode = ErrorTable[pRequest->ErrorCode].StatusCode;
    Response.ReasonLength = ErrorTable[pRequest->ErrorCode].ReasonLength;
    Response.pReason = ErrorTable[pRequest->ErrorCode].pReason;

    Response.Headers.pKnownHeaders[HttpHeaderContentType].RawValueLength =
        ContentTypeLength;
    Response.Headers.pKnownHeaders[HttpHeaderContentType].pRawValue =
        ContentType;

    //
    // generate a body
    //
    DataChunk.DataChunkType = HttpDataChunkFromMemory;
    DataChunk.FromMemory.pBuffer = ErrorTable[pRequest->ErrorCode].pBody;
    DataChunk.FromMemory.BufferLength = ErrorTable[pRequest->ErrorCode].BodyLength;

    Status = UlCaptureHttpResponse(
                    &Response,
                    pRequest,
                    pRequest->Version,
                    pRequest->Verb,
                    1,
                    &DataChunk,
                    UlCaptureCopyDataInKernelMode,
                    FALSE,
                    NULL,
                    &pKeResponse
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    Status = UlPrepareHttpResponse(
                    pRequest->Version,
                    &Response,
                    pKeResponse
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    Status = UlSendHttpResponse(
                    pRequest,
                    pKeResponse,
                    HTTP_SEND_RESPONSE_FLAG_DISCONNECT,
                    &UlpCompleteSendResponse,
                    pKeResponse
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    ASSERT(Status == STATUS_PENDING);

end:
    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pKeResponse != NULL)
        {
            UL_DEREFERENCE_INTERNAL_RESPONSE(pKeResponse);
        }

        //
        // Abort the connection
        //

        UlTrace(HTTP_IO, (
            "http!UlSendErrorResponse(%p): Failed to send error response\n",
            pConnection
            ));

        //
        // cancel any pending io
        //
        UlCancelRequestIo(pRequest);

        //
        // abort the connection this request is associated with
        //

        UlCloseConnection(
            pRequest->pHttpConn->pConnection,
            TRUE,
            NULL,
            NULL
            );

    }

} // UlSendErrorResponse



VOID
UlpCompleteSendResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{

    //
    // release the response
    //

    if (pCompletionContext != NULL)
    {
        UL_DEREFERENCE_INTERNAL_RESPONSE(
            (PUL_INTERNAL_RESPONSE)(pCompletionContext)
            );
    }
} // UlpCompleteSendResponse


//
// Types and functions for sending simple status responses
//
// REVIEW: Does this status code need to be localized?
// REVIEW: Do we need to load this as a localized resource?
//

typedef struct _UL_SIMPLE_STATUS_ITEM
{
    UL_WORK_ITEM WorkItem;

    ULONG   Length;
    PCHAR   pMessage;
    PMDL    pMdl;

    PUL_HTTP_CONNECTION  pHttpConn;

} UL_SIMPLE_STATUS_ITEM, *PUL_SIMPLE_STATUS_ITEM;

typedef struct _UL_HTTP_SIMPLE_STATUS_ENTRY
{
    USHORT StatusCode;      // HTTP Status
    ULONG  Length;          // size (bytes) of response in pResponse, minus trailing NULL
    PSTR   pResponse;       // header line only with trailing <CRLF><CRLF>
    PMDL   pMdl;            // MDL allocated at startup

} UL_HTTP_SIMPLE_STATUS_ENTRY, *PUL_HTTP_SIMPLE_STATUS_ENTRY;


#define HTTP_SIMPLE_STATUS_ENTRY(StatusCode, pResp)   \
    {                                                 \
        (StatusCode),                                 \
        sizeof((pResp))-sizeof(CHAR),                 \
        (pResp),                                      \
        NULL                                          \
    }

//
// This must match the order of UL_HTTP_SIMPLE_STATUS in httptypes.h
//
UL_HTTP_SIMPLE_STATUS_ENTRY g_SimpleStatusTable[] =
{
    //
    // UlStatusContinue
    //
    HTTP_SIMPLE_STATUS_ENTRY( 100, "HTTP/1.1 100 Continue\r\n\r\n" ),

    //
    // UlStatusNoContent
    //
    HTTP_SIMPLE_STATUS_ENTRY( 204, "HTTP/1.1 204 No Content\r\n\r\n" ),

    //
    // UlStatusNotModified (must add Date:)
    //
    HTTP_SIMPLE_STATUS_ENTRY( 304, "HTTP/1.1 304 Not Modified\r\nDate:" ),

};



/***************************************************************************++

Routine Description:

    Sends a "Simple" status response: one which does not have a body and is
    terminated by the first empty line after the header field(s).
    See RFC 2616, Section 4.4 for more info.

Notes:

    According to RFC 2616, Section 8.2.3 [Use of the 100 (Continue)
    Status], "An origin server that sends a 100 (Continue) response
    MUST ultimately send a final status code, once the request body is
    received and processed, unless it terminates the transport
    connection prematurely."

    The connection will not be closed after the response is sent.  Caller
    is responsible for cleanup.

Arguments:

    pRequest        a valid pointer to an internal request object

    Response        the status code for the simple response to send

Return

    ULONG           the number of bytes sent for this simple response
                    if not successfull returns zero

--***************************************************************************/

ULONG
UlSendSimpleStatus(
    PUL_INTERNAL_REQUEST pRequest,
    UL_HTTP_SIMPLE_STATUS Response
    )
{
    NTSTATUS    Status;
    ULONG       BytesSent;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));

    ASSERT( (Response >= 0) && (Response < UlStatusMaxStatus) );

    BytesSent = 0;

    if ( UlStatusNotModified == Response )
    {
        PUL_SIMPLE_STATUS_ITEM  pItem;
        ULONG                   Length;
        PCHAR                   pTemp;
        CHAR                    DateBuffer[DATE_HDR_LENGTH + 1];
        LARGE_INTEGER           liNow;

        // 304 MUST include a "Date:" header, which is
        // present on the cached item.

        // TODO: Add the ETag as well.

        // Calc size of buffer to send
        Length = g_SimpleStatusTable[Response].Length + // Pre-formed message
            1 +                 // space
            DATE_HDR_LENGTH +   // size of date field
            (2 * CRLF_SIZE) +   // size of two <CRLF> sequences
            1 ;                 // trailing NULL (for nifty debug printing)


        // Alloc some non-page buffer for the response
        pItem = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_SIMPLE_STATUS_ITEM,
                        Length,
                        UL_SIMPLE_STATUS_ITEM_TAG
                        );
        if (!pItem)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        // We need to hold a ref to the connection while we send.
        UL_REFERENCE_HTTP_CONNECTION(pRequest->pHttpConn);
        pItem->pHttpConn = pRequest->pHttpConn;

        pItem->Length   = Length - 1; // Don't include the NULL in the outbound message
        pItem->pMessage = (PCHAR) (pItem + 1);

        // Get date buffer
        GenerateDateHeader(
            (PUCHAR) DateBuffer,
            &liNow
            );

        // Copy the chunks into the Message buffer
        pTemp = UlStrPrintStr(
                    pItem->pMessage,
                    g_SimpleStatusTable[Response].pResponse,
                    ' '
                    );

        pTemp = UlStrPrintStr(
                    pTemp,
                    DateBuffer,
                    '\r'        // this is a Nifty Trick(tm) to get a "\r\n\r\n"
                    );          // sequence at the end of the buffer.

        pTemp = UlStrPrintStr(
                    pTemp,
                    "\n\r\n",
                    '\0'
                    );

        UlTrace(HTTP_IO, (
            "http!SendSimpleStatus: %s\n",
            pItem->pMessage
            ));

        // Construct MDL for buffer
        pItem->pMdl = UlAllocateMdl(
                        pItem->pMessage,
                        pItem->Length,
                        FALSE,
                        FALSE,
                        NULL
                        );

        MmBuildMdlForNonPagedPool(pItem->pMdl);

        BytesSent = pItem->Length;
        
        //
        // Call UlSendData, passing pMdl as the completion context
        // (so the completion routine can release it...)
        //
        Status = UlSendData(
            pRequest->pHttpConn->pConnection,
            pItem->pMdl,
            pItem->Length,
            UlpRestartSendSimpleStatus,
            pItem,  // Completion Context
            NULL,   // Own IRP
            NULL,   // Own IRP Context
            FALSE   // Initiate Disconnect
            );

    }
    else
    {
        //
        // Proceed with constructing and sending the simple response
        // back to the client.  Assumes caller will deref both the
        // UL_INTERNAL_REQUEST and the UL_HTTP_CONNECTION
        //

        Status = UlSendData(
            pRequest->pHttpConn->pConnection,
            g_SimpleStatusTable[Response].pMdl,
            g_SimpleStatusTable[Response].Length,
            UlpRestartSendSimpleStatus,
            NULL,   // Completion Context
            NULL,   // Own IRP
            NULL,   // Own IRP Context
            FALSE   // Initiate Disconnect
            );

        BytesSent = g_SimpleStatusTable[Response].Length;
    }

 end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        //
        // Abort the connection
        //

        UlTrace(HTTP_IO, (
            "http!SendSimpleStatus(%p, %d): aborting request\n",
            pRequest,
            Response
            ));

        //
        // cancel any pending io
        //
        UlCancelRequestIo(pRequest);

        //
        // abort the connection this request is associated with
        //

        UlCloseConnection(
            pRequest->pHttpConn->pConnection,
            TRUE,
            NULL,
            NULL
            );

        return 0;
    }
    else
    {
        return BytesSent;
    }
} // UlSendSimpleStatus



/***************************************************************************++

Routine Description:

    Callback for when UlSendData completes sending a UL_SIMPLE_STATUS message

Arguments:

    pCompletionContext (OPTIONAL) -- If non-NULL, a pointer to a
       UL_SIMPLE_STATUS_ITEM.

   Status -- Ignored.

   Information -- Ignored.

--***************************************************************************/

VOID
UlpRestartSendSimpleStatus(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_SIMPLE_STATUS_ITEM  pItem;

    UlTrace(HTTP_IO, (
            "http!SendSimpleStatusCompletionRoutine: \n"
            "    pCompletionContext: %p\n"
            "    Status: 0x%08X\n"
            "    Information: %p\n",
            pCompletionContext,
            Status,
            Information
            ));

    if ( pCompletionContext )
    {
        pItem = (PUL_SIMPLE_STATUS_ITEM) pCompletionContext;

        // Queue up work item for passive level
        UL_QUEUE_WORK_ITEM(
            &pItem->WorkItem,
            &UlpSendSimpleCleanupWorker
            );

    }

} // UlpRestartSendSimpleStatus



/***************************************************************************++

Routine Description:

    Worker function to do cleanup work that shouldn't happen above DPC level.

Arguments:

    pWorkItem -- If non-NULL, a pointer to a UL_WORK_ITEM
         contained within a UL_SIMPLE_STATUS_ITEM.

--***************************************************************************/

VOID
UlpSendSimpleCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    KIRQL OldIrql;

    PAGED_CODE();
    ASSERT(pWorkItem);

    PUL_SIMPLE_STATUS_ITEM  pItem;

    pItem = CONTAINING_RECORD(
                pWorkItem,
                UL_SIMPLE_STATUS_ITEM,
                WorkItem
                );

    UlTrace(HTTP_IO, (
        "http!SendSimpleStatusCleanupWorker (%p) \n",
        pWorkItem
        ));

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pItem->pHttpConn));

    //
    // start the Connection Timeout timer
    //
    UlLockTimeoutInfo(
        &(pItem->pHttpConn->TimeoutInfo),
        &OldIrql
        );

    UlSetConnectionTimer(
        &(pItem->pHttpConn->TimeoutInfo),
        TimerConnectionIdle
        );

    UlUnlockTimeoutInfo(
        &(pItem->pHttpConn->TimeoutInfo),
        OldIrql
        );

    UlEvaluateTimerState(
        &(pItem->pHttpConn->TimeoutInfo)
        );

    //
    // deref http connection
    //
    UL_DEREFERENCE_HTTP_CONNECTION( pItem->pHttpConn );

    // if the pCompletionContext is non-NULL< it's a struct which holds the MDL
    // and the memory allocated for the 304 (Not Modified) response.  Release both.
    UlFreeMdl( pItem->pMdl );
    UL_FREE_POOL( pItem, UL_SIMPLE_STATUS_ITEM_TAG );

} // UlpSendSimpleCleanupWorker



/***************************************************************************++

Routine Description:

    Alloc & Init the MDL used by the UlpSendContinue function.

--***************************************************************************/

NTSTATUS
UlInitializeHttpRcv()
{
    NTSTATUS        Status;
    PUL_HTTP_SIMPLE_STATUS_ENTRY pSE;
    int             i;

    for ( i = 0; i < UlStatusMaxStatus; i++ )
    {
        pSE = &g_SimpleStatusTable[i];

        // Create a MDL for the response header
        pSE->pMdl = UlAllocateMdl(
                        pSE->pResponse,
                        pSE->Length,
                        FALSE,
                        FALSE,
                        NULL
                        );

        if (!pSE->pMdl)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        MmBuildMdlForNonPagedPool(pSE->pMdl);

    }

    Status = STATUS_SUCCESS;

 end:

    if ( STATUS_SUCCESS != Status )
    {
        //
        // FAILED: cleanup any allocated MDLs
        //
        for ( i = 0; i < UlStatusMaxStatus; i++ )
        {
            pSE = &g_SimpleStatusTable[i];

            if (pSE->pMdl)
            {
                UlFreeMdl( pSE->pMdl );
                pSE->pMdl = NULL;
            }
        }
    }

    return Status;
} // UlInitializeHttpRcv



/***************************************************************************++

Routine Description:

   Free the MDL used by the UlpSendContinue function.

--***************************************************************************/

VOID
UlTerminateHttpRcv()
{
    NTSTATUS        Status;
    PUL_HTTP_SIMPLE_STATUS_ENTRY pSE;
    int             i;

    for ( i = 0; i < UlStatusMaxStatus; i++ )
    {
        pSE = &g_SimpleStatusTable[i];

        if (pSE->pMdl)
        {
            ASSERT(0 == ((pSE->pMdl->MdlFlags) & MDL_PAGES_LOCKED));
            UlFreeMdl( pSE->pMdl );
        }
    }

} // UlTerminateHttpRcv


#if DBG
/***************************************************************************++

Routine Description:

   Invasive assert predicate.  DEBUG ONLY!!!  Use this only inside an
   ASSERT() macro.

--***************************************************************************/

BOOLEAN
UlpIsValidRequestBufferList(
    PUL_HTTP_CONNECTION pHttpConn
    )
{
    PLIST_ENTRY         pEntry;
    PUL_REQUEST_BUFFER  pReqBuf;
    ULONG               LastSeqNum = 0;
    BOOLEAN             fRet = TRUE;


    PAGED_CODE();
    ASSERT( pHttpConn );

    //
    // pop from the head
    //

    pEntry = pHttpConn->BufferHead.Flink;
    while ( pEntry != &(pHttpConn->BufferHead) )
    {
        pReqBuf = CONTAINING_RECORD( pEntry,
                                     UL_REQUEST_BUFFER,
                                     ListEntry
                                     );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pReqBuf) );
        ASSERT( pReqBuf->UsedBytes != 0 );

        if ( 0 == pReqBuf->UsedBytes )
        {
            fRet = FALSE;
        }

        //
        // ignore case when BufferNumber is zero (0).
        //
        if ( pReqBuf->BufferNumber && (LastSeqNum >= pReqBuf->BufferNumber) )
        {
            fRet = FALSE;
        }

        LastSeqNum = pReqBuf->BufferNumber;
        pEntry = pEntry->Flink;

    }

    return fRet;

}
#endif // DBG


/***************************************************************************++

Routine Description:

   Add a reference of the request buffer in the internal request.

--***************************************************************************/

BOOLEAN
UlpReferenceBuffers(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_REQUEST_BUFFER pRequestBuffer
    )
{
    PUL_REQUEST_BUFFER * pNewRefBuffers;

    if (pRequest->UsedRefBuffers >= pRequest->AllocRefBuffers)
    {
        ASSERT( pRequest->UsedRefBuffers == pRequest->AllocRefBuffers );

        pNewRefBuffers = UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            PUL_REQUEST_BUFFER,
                            pRequest->AllocRefBuffers + ALLOC_REQUEST_BUFFER_INCREMENT,
                            UL_REF_REQUEST_BUFFER_POOL_TAG
                            );

        if (!pNewRefBuffers)
        {
            return FALSE;
        }

        RtlCopyMemory(
            pNewRefBuffers,
            pRequest->pRefBuffers, 
            pRequest->UsedRefBuffers * sizeof(PUL_REQUEST_BUFFER)
            );

        if (pRequest->AllocRefBuffers > 1)
        {
            UL_FREE_POOL(
                pRequest->pRefBuffers,
                UL_REF_REQUEST_BUFFER_POOL_TAG
                );
        }

        pRequest->AllocRefBuffers += ALLOC_REQUEST_BUFFER_INCREMENT;
        pRequest->pRefBuffers = pNewRefBuffers;
    }

    pRequest->pRefBuffers[pRequest->UsedRefBuffers] = pRequestBuffer;
    pRequest->UsedRefBuffers++;
    UL_REFERENCE_REQUEST_BUFFER(pRequestBuffer);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\httptdi.h ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    httptdi.h

Abstract:

    Declarations for the TDI/MUX/SSL component that is common between
    ultdi and uctdi

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/

#ifndef _HTTPTDI_H
#define _HTTPTDI_H

#ifdef __cplusplus
extern "C" {
#endif

#define IS_VALID_TDI_OBJECT( pobj )                                         \
    ( ( (pobj)->Handle != NULL ) &&                                         \
      ( (pobj)->pFileObject != NULL ) &&                                    \
      ( (pobj)->pDeviceObject != NULL ) )

#define UxCloseTdiObject( pTdiObject )                                     \
    do                                                                      \
    {                                                                       \
        if ((pTdiObject)->pFileObject != NULL)                              \
        {                                                                   \
            ObDereferenceObject( (pTdiObject)->pFileObject );               \
            (pTdiObject)->pFileObject = NULL;                               \
        }                                                                   \
                                                                            \
        if ((pTdiObject)->Handle != NULL)                                   \
        {                                                                   \
            UlCloseSystemHandle( (pTdiObject)->Handle );                    \
            (pTdiObject)->Handle = NULL;                                    \
        }                                                                   \
    } while (FALSE)


//
// A wrapper around a TDI object handle, with a pre-referenced
// FILE_OBJECT pointer and the corresponding DEVICE_OBJECT pointer.
//

typedef struct _UX_TDI_OBJECT
{
    HANDLE Handle;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;

} UX_TDI_OBJECT, *PUX_TDI_OBJECT;

NTSTATUS
UxInitializeTdi(
    VOID
    );

VOID
UxTerminateTdi(
    VOID
    );

NTSTATUS
UxOpenTdiAddressObject(
    IN PTRANSPORT_ADDRESS pLocalAddress,
    IN ULONG LocalAddressLength,
    OUT PUX_TDI_OBJECT pTdiObject
    );

NTSTATUS
UxOpenTdiConnectionObject(
    IN CONNECTION_CONTEXT pConnectionContext,
    OUT PUX_TDI_OBJECT pTdiObject
    );

NTSTATUS
UxpOpenTdiObjectHelper(
    IN PUNICODE_STRING pTransportDeviceName,
    IN PVOID pEaBuffer,
    IN ULONG EaLength,
    OUT PUX_TDI_OBJECT pTdiObject
    );


NTSTATUS
UxSetEventHandler(
    IN PUX_TDI_OBJECT  pUlTdiObject,
    IN ULONG           EventType,
    IN PVOID           pEventHandler,
    IN PVOID           pEventContext
    );

PIRP
UxCreateDisconnectIrp(
    IN PUX_TDI_OBJECT pTdiObject,
    IN ULONG_PTR Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

VOID
UxInitializeDisconnectIrp(
    IN PIRP pIrp,
    IN PUX_TDI_OBJECT pTdiObject,
    IN ULONG_PTR Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _HTTPTDI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\init.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    init.cxx

Abstract:

    This module performs initialization for the UL device driver.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

#define DEFAULT_THREAD_AFFINITY_MASK ((1ui64 << KeNumberProcessors) - 1)



//
// Private types.
//


typedef struct _SID_MASK_PAIR
{
    PSID pSid;
    ACCESS_MASK AccessMask;

} SID_MASK_PAIR, *PSID_MASK_PAIR;


#ifdef __cplusplus

extern "C" {
#endif // __cplusplus

//
// Private prototypes.
//


NTSTATUS
UlpApplySecurityToDeviceObjects(
    VOID
    );

NTSTATUS
UlpCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSID_MASK_PAIR pSidMaskPairs,
    IN ULONG NumSidMaskPairs
    );

VOID
UlpCleanupSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

NTSTATUS
UlpSetDeviceObjectSecurity(
    IN PDEVICE_OBJECT pDeviceObject,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

VOID
UlpReadRegistry (
    IN PUL_CONFIG pConfig
    );

VOID
UlpTerminateModules(
    VOID
    );

#if ALLOW_UNLOAD
VOID
UlpUnload (
    IN PDRIVER_OBJECT DriverObject
    );
#endif  // ALLOW_UNLOAD

#ifdef __cplusplus

}; // extern "C"
#endif // __cplusplus

//
// Private globals.
//

#if DBG
ULONG g_UlpForceInitFailure = 0;
#endif  // DBG


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( INIT, UlpApplySecurityToDeviceObjects )
#pragma alloc_text( INIT, UlpCreateSecurityDescriptor )
#pragma alloc_text( INIT, UlpCleanupSecurityDescriptor )
#pragma alloc_text( INIT, UlpSetDeviceObjectSecurity )
#pragma alloc_text( INIT, UlpReadRegistry )
#if ALLOW_UNLOAD
#pragma alloc_text( PAGE, UlpUnload )
#pragma alloc_text( PAGE, UlpTerminateModules )
#endif  // ALLOW_UNLOAD

//
// Note that UlpTerminateModules() must be "page" if driver unloading
// is enabled (it's called from UlpUnload), but can be "init" otherwise
// (it's only called after initialization failure).
//
#if ALLOW_UNLOAD
#pragma alloc_text( PAGE, UlpTerminateModules )
#else
#pragma alloc_text( INIT, UlpTerminateModules )
#endif  // ALLOW_UNLOAD
#endif  // ALLOC_PRAGMA


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the initialization routine for the UL device driver.

Arguments:

    DriverObject - Supplies a pointer to driver object created by the
        system.

    RegistryPath - Supplies the name of the driver's configuration
        registry tree.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    CLONG i;
    UL_CONFIG config;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Grab the number of processors in the system.
    //

    g_UlNumberOfProcessors = KeNumberProcessors;
    g_UlThreadAffinityMask = DEFAULT_THREAD_AFFINITY_MASK;

    //
    // Grab the largest cache line size in the system
    //

    g_UlCacheLineSize = KeGetRecommendedSharedDataAlignment();

    for (g_UlCacheLineBits = 0;
         (1U << g_UlCacheLineBits) < g_UlCacheLineSize;
         ++g_UlCacheLineBits)
    {}

    ASSERT(g_UlCacheLineSize <= (1U << g_UlCacheLineBits));

    //
    // Snag a pointer to the system process.
    //

    g_pUlSystemProcess = (PKPROCESS)IoGetCurrentProcess();

    //
    // Read registry information.
    //

    UlpReadRegistry( &config );

#if DBG
    //
    // Give anyone using the kernel debugger a chance to abort
    // initialization.
    //

    if (g_UlpForceInitFailure != 0)
    {
        status = STATUS_UNSUCCESSFUL;
        goto fatal;
    }
#endif  // DBG

    //
    // Initialize the global trace logs.
    //

    UlInitializeOwnerRefTraceLog();

    CREATE_REF_TRACE_LOG( g_pMondoGlobalTraceLog, 16384 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pTdiTraceLog, 32768 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pHttpRequestTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pHttpConnectionTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pHttpResponseTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pAppPoolTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pConfigGroupTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pThreadTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pMdlTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pFilterTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_IRP_TRACE_LOG( g_pIrpTraceLog, 32768 - REF_TRACE_OVERHEAD, 0 );
    CREATE_TIME_TRACE_LOG( g_pTimeTraceLog, 32768 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REPLENISH_TRACE_LOG( g_pReplenishTraceLog, 32768 - REF_TRACE_OVERHEAD, 0 );
    CREATE_FILTQ_TRACE_LOG( g_pFilterQueueTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pSiteCounterTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pConnectionCountTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pConfigGroupInfoTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pChunkTrackerTraceLog, 2048 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( g_pWorkItemTraceLog, 32768 - REF_TRACE_OVERHEAD, 0 );

    //
    // Create an object directory to contain our device objects.
    //

    RtlInitUnicodeString( &deviceName, HTTP_DIRECTORY_NAME );

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        &deviceName,                            // ObjectName
        OBJ_CASE_INSENSITIVE |                  // Attributes
            UL_KERNEL_HANDLE,
        NULL,                                   // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    UlAttachToSystemProcess();

    status = ZwCreateDirectoryObject(
                    &g_UlDirectoryObject,       // DirectoryHandle
                    DIRECTORY_ALL_ACCESS,       // AccessMask
                    &objectAttributes           // ObjectAttributes
                    );

    UlDetachFromSystemProcess();

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Create the control channel device object.
    //

    RtlInitUnicodeString( &deviceName, HTTP_CONTROL_DEVICE_NAME );

    status = IoCreateDevice(
                    DriverObject,               // DriverObject
                    0,                          // DeviceExtension
                    &deviceName,                // DeviceName
                    FILE_DEVICE_NETWORK,        // DeviceType
                    0,                          // DeviceCharacteristics
                    TRUE,                       // Exclusive
                    &g_pUlControlDeviceObject   // DeviceObject
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Create the filter device object.
    //

    RtlInitUnicodeString( &deviceName, HTTP_FILTER_DEVICE_NAME );

    status = IoCreateDevice(
                    DriverObject,               // DriverObject
                    0,                          // DeviceExtension
                    &deviceName,                // DeviceName
                    FILE_DEVICE_NETWORK,        // DeviceType
                    0,                          // DeviceCharacteristics
                    FALSE,                      // Exclusive
                    &g_pUlFilterDeviceObject    // DeviceObject
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    g_pUlFilterDeviceObject->StackSize = g_UlIrpStackSize;

    //
    // Create the app pool device object.
    //

    RtlInitUnicodeString( &deviceName, HTTP_APP_POOL_DEVICE_NAME );

    status = IoCreateDevice(
                    DriverObject,               // DriverObject
                    0,                          // DeviceExtension
                    &deviceName,                // DeviceName
                    FILE_DEVICE_NETWORK,        // DeviceType
                    0,                          // DeviceCharacteristics
                    FALSE,                      // Exclusive
                    &g_pUlAppPoolDeviceObject   // DeviceObject
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    g_pUlAppPoolDeviceObject->StackSize = g_UlIrpStackSize;


    //
    // If so requested, apply security to the device objects.
    //
    // CODEWORK: REMOVE THIS CONFIGURATION PARAMETER!
    //

    if (config.EnableSecurity)
    {
        status = UlpApplySecurityToDeviceObjects();

        if (!NT_SUCCESS(status))
        {
            goto fatal;
        }
    }
    else
    {
        KdPrint(( "UL: security disabled\n" ));
    }

    //
    // Initialize the driver object with this driver's entrypoints.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = &UlCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = &UlClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = &UlCleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &UlDeviceControl;
    DriverObject->FastIoDispatch = &UlFastIoDispatch;
    DriverObject->DriverUnload = NULL;

#if ALLOW_UNLOAD
    if( config.EnableUnload )
    {
        KdPrint(( "UL: DriverUnload enabled\n" ));
        DriverObject->DriverUnload = &UlpUnload;
    }
#endif  // ALLOW_UNLOAD

    //
    // Initialize global data.
    //

    status = UlInitializeData(&config);

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Create the thread pool.
    //

    status = UlInitializeThreadPool(config.ThreadsPerCpu);

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize common TDI.
    //

    status = UxInitializeTdi();

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize server connection code.
    //

    status = UlInitializeTdi();

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize temporary test code.
    //
//    status = UlInitializeTdiTest();
//    if (!NT_SUCCESS(status))
//    {
//        goto fatal;
//    }

    //
    // Initialize George.
    //

    status = UlLargeMemInitialize(&config);
    ASSERT( NT_SUCCESS(status) );

    //
    // Initialize Keith.
    //

    status = UlInitializeControlChannel();
    ASSERT( NT_SUCCESS(status) );

    //
    // Initialize Henry.
    //

    status = InitializeHttpUtil();
    ASSERT( NT_SUCCESS(status) );

    status = InitializeParser();
    ASSERT( NT_SUCCESS(status) );

    status = UlInitializeOpaqueIdTable();
    ASSERT( NT_SUCCESS(status) );

    status = InitializeFileCache();
    ASSERT( NT_SUCCESS(status) );

    //
    // Initialize Michael.
    //
    status = UlInitializeFilterChannel();
    ASSERT( NT_SUCCESS(status) );

    //
    // Initialize Alex.
    //
    status = UlInitializeUriCache(&config);
    if ( !NT_SUCCESS(status) )
    {
        goto fatal;
    }

    status = UlInitializeDateCache();
    ASSERT( NT_SUCCESS(status) );

    //
    // Initialize Paul.
    //

    status = UlInitializeCG();
    ASSERT( NT_SUCCESS(status) );
    status = UlInitializeAP();
    ASSERT( NT_SUCCESS(status) );

    //
    // Initialize Ali
    //

    status = UlInitializeLogs();
    ASSERT( NT_SUCCESS(status) );

    // TC Init may fail if PSched
    // is not installed.
    UlTcInitialize();
#if 0
    status = UlTcInitialize();
    ASSERT( NT_SUCCESS(status));
#endif

    status = UlInitGlobalConnectionLimits();
    ASSERT( NT_SUCCESS(status) );

    //
    // Initialize Eric.
    //

    status = UlInitializeHttpRcv();
    ASSERT( NT_SUCCESS(status) );

    status = UlInitializeCounters();
    ASSERT( NT_SUCCESS(status) );

    UlInitializeTimeoutMonitor();

#if DBG
    //
    // Give anyone using the kernel debugger one final chance to abort
    // initialization.
    //

    if (g_UlpForceInitFailure != 0)
    {
        status = STATUS_UNSUCCESSFUL;
        goto fatal;
    }
#endif  // DBG

    return STATUS_SUCCESS;

    //
    // Fatal error handlers.
    //

fatal:

    UlpTerminateModules();

    ASSERT( !NT_SUCCESS(status) );
    return status;

}   // DriverEntry


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Applies the appropriate security descriptors to the global device
    objects created at initialization time.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpApplySecurityToDeviceObjects(
    VOID
    )
{
    NTSTATUS status;
    SECURITY_DESCRIPTOR securityDescriptor;
    PGENERIC_MAPPING pFileObjectGenericMapping;
    ACCESS_MASK fileRead;
    ACCESS_MASK fileAll;
    HANDLE handle;
    SID_MASK_PAIR sidMaskPairs[3];

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_DEVICE_OBJECT( g_pUlControlDeviceObject ) );
    ASSERT( IS_VALID_DEVICE_OBJECT( g_pUlFilterDeviceObject ) );
    ASSERT( IS_VALID_DEVICE_OBJECT( g_pUlAppPoolDeviceObject ) );

    //
    // Gain access to the predefined SIDs and other security-related
    // goodies exported by the kernel.
    //

    //SeEnableAccessToExports();

    //
    // Map a couple of generic file access types to their corresponding
    // object-specific rights.
    //

    pFileObjectGenericMapping = IoGetFileObjectGenericMapping();
    ASSERT( pFileObjectGenericMapping != NULL );

    fileRead = GENERIC_READ;

    RtlMapGenericMask(
        &fileRead,
        pFileObjectGenericMapping
        );

    fileAll = GENERIC_ALL;

    RtlMapGenericMask(
        &fileAll,
        pFileObjectGenericMapping
        );

    //
    // Build a restrictive security descriptor for the control device
    // object:
    //
    //      Full access for NT AUTHORITY\SYSTEM
    //      Full access for BUILTIN\Administrators
    //

    sidMaskPairs[0].pSid = SeExports->SeLocalSystemSid;
    sidMaskPairs[0].AccessMask = fileAll;

    sidMaskPairs[1].pSid = SeExports->SeAliasAdminsSid;
    sidMaskPairs[1].AccessMask = fileAll;

    status = UlpCreateSecurityDescriptor(
                    &securityDescriptor,            // pSecurityDescriptor
                    &sidMaskPairs[0],               // pSidMaskPairs
                    2                               // NumSidMaskPairs
                    );

    if (!NT_SUCCESS(status))
    {
        goto complete;
    }

    status = UlpSetDeviceObjectSecurity(
                    g_pUlControlDeviceObject,
                    DACL_SECURITY_INFORMATION,
                    &securityDescriptor
                    );

    UlpCleanupSecurityDescriptor( &securityDescriptor );

    if (!NT_SUCCESS(status))
    {
        goto complete;
    }

    //
    // Build a restrictive security descriptor for the filter device
    // object:
    //
    //      Full access for NT AUTHORITY\SYSTEM
    //      Full access for BUILTIN\Administrators
    //

    sidMaskPairs[0].pSid = SeExports->SeLocalSystemSid;
    sidMaskPairs[0].AccessMask = fileAll;

    sidMaskPairs[1].pSid = SeExports->SeAliasAdminsSid;
    sidMaskPairs[1].AccessMask = fileAll;

    status = UlpCreateSecurityDescriptor(
                    &securityDescriptor,            // pSecurityDescriptor
                    &sidMaskPairs[0],               // pSidMaskPairs
                    2                               // NumSidMaskPairs
                    );

    if (!NT_SUCCESS(status))
    {
        goto complete;
    }

    status = UlpSetDeviceObjectSecurity(
                    g_pUlFilterDeviceObject,
                    DACL_SECURITY_INFORMATION,
                    &securityDescriptor
                    );

    UlpCleanupSecurityDescriptor( &securityDescriptor );

    if (!NT_SUCCESS(status))
    {
        goto complete;
    }

    //
    // Build a slightly less restrictive security descriptor for the
    // app pool device object:
    //
    //      Full access for NT AUTHORITY\SYSTEM
    //      Full access for BUILTIN\Administrators
    //      Read access for Everyone
    //

    sidMaskPairs[0].pSid = SeExports->SeLocalSystemSid;
    sidMaskPairs[0].AccessMask = fileAll;

    sidMaskPairs[1].pSid = SeExports->SeAliasAdminsSid;
    sidMaskPairs[1].AccessMask = fileAll;

    sidMaskPairs[2].pSid = SeExports->SeWorldSid;
    sidMaskPairs[2].AccessMask = fileRead;

    status = UlpCreateSecurityDescriptor(
                    &securityDescriptor,            // pSecurityDescriptor
                    &sidMaskPairs[0],               // pSidMaskPairs
                    3                               // NumSidMaskPairs
                    );

    if (!NT_SUCCESS(status))
    {
        goto complete;
    }

    status = UlpSetDeviceObjectSecurity(
                    g_pUlAppPoolDeviceObject,
                    DACL_SECURITY_INFORMATION,
                    &securityDescriptor
                    );

    UlpCleanupSecurityDescriptor( &securityDescriptor );

    if (!NT_SUCCESS(status))
    {
        goto complete;
    }

complete:

    return status;

}   // UlpApplySecurityToDeviceObjects


/***************************************************************************++

Routine Description:

    Allocates and initializes a security descriptor with the specified
    attributes.

Arguments:

    pSecurityDescriptor - Supplies a pointer to the security descriptor
        to initialize.

    pSidMaskPairs - Supplies an array of SID/ACCESS_MASK pairs.

    NumSidMaskPairs - Supplies the number of SID/ACESS_MASK pairs.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSID_MASK_PAIR pSidMaskPairs,
    IN ULONG NumSidMaskPairs
    )
{
    NTSTATUS status;
    PACL pDacl;
    ULONG daclLength;
    ULONG i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pSecurityDescriptor != NULL );
    ASSERT( pSidMaskPairs != NULL );
    ASSERT( NumSidMaskPairs > 0 );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    pDacl = NULL;

    //
    // Initialize the security descriptor.
    //

    status = RtlCreateSecurityDescriptor(
                    pSecurityDescriptor,            // SecurityDescriptor
                    SECURITY_DESCRIPTOR_REVISION    // Revision
                    );

    if (!NT_SUCCESS(status))
    {
        goto cleanup;
    }

    //
    // Calculate the DACL length.
    //

    daclLength = sizeof(ACL);

    for (i = 0 ; i < NumSidMaskPairs ; i++)
    {
        daclLength += sizeof(ACCESS_ALLOWED_ACE);
        daclLength += RtlLengthSid( pSidMaskPairs[i].pSid );
    }

    //
    // Allocate & initialize the DACL.
    //

    pDacl = (PACL) UL_ALLOCATE_POOL(
                PagedPool,
                daclLength,
                UL_SECURITY_DATA_POOL_TAG
                );

    if (pDacl == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = RtlCreateAcl(
                    pDacl,                          // Acl
                    daclLength,                     // AclLength
                    ACL_REVISION                    // AclRevision
                    );

    if (!NT_SUCCESS(status))
    {
        goto cleanup;
    }

    //
    // Add the necessary access-allowed ACEs to the DACL.
    //

    for (i = 0 ; i < NumSidMaskPairs ; i++)
    {
        status = RtlAddAccessAllowedAce(
                        pDacl,                          // Acl
                        ACL_REVISION,                   // AceRevision
                        pSidMaskPairs[i].AccessMask,    // AccessMask
                        pSidMaskPairs[i].pSid           // Sid
                        );

        if (!NT_SUCCESS(status))
        {
            goto cleanup;
        }
    }

    //
    // Attach the DACL to the security descriptor.
    //

    status = RtlSetDaclSecurityDescriptor(
                    pSecurityDescriptor,                // SecurityDescriptor
                    TRUE,                               // DaclPresent
                    pDacl,                              // Dacl
                    FALSE                               // DaclDefaulted
                    );

    if (!NT_SUCCESS(status))
    {
        goto cleanup;
    }

    //
    // Success!
    //

    ASSERT( NT_SUCCESS(status) );
    return STATUS_SUCCESS;

cleanup:

    ASSERT( !NT_SUCCESS(status) );

    if (pDacl != NULL)
    {
        UL_FREE_POOL(
            pDacl,
            UL_SECURITY_DATA_POOL_TAG
            );
    }

    return status;

}   // UlpCreateSecurityDescriptor


/***************************************************************************++

Routine Description:

    Frees any resources associated with the security descriptor created
    by UlpCreateSecurityDescriptor().

Arguments:

    pSecurityDescriptor - Supplies the security descriptor to cleanup.

--***************************************************************************/
VOID
UlpCleanupSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    NTSTATUS status;
    PACL pDacl;
    BOOLEAN daclPresent;
    BOOLEAN daclDefaulted;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( RtlValidSecurityDescriptor( pSecurityDescriptor ) );

    //
    // Try to retrieve the DACL from the security descriptor.
    //

    status = RtlGetDaclSecurityDescriptor(
                    pSecurityDescriptor,            // SecurityDescriptor
                    &daclPresent,                   // DaclPresent
                    &pDacl,                         // Dacl
                    &daclDefaulted                  // DaclDefaulted
                    );

    if (NT_SUCCESS(status))
    {
        if (daclPresent && (pDacl != NULL))
        {
            UL_FREE_POOL(
                pDacl,
                UL_SECURITY_DATA_POOL_TAG
                );
        }
    }

}   // UlpCleanupSecurityDescriptor


/***************************************************************************++

Routine Description:

    Applies the specified security descriptor to the specified device
    object.

Arguments:

    pDeviceObject - Supplies the device object to manipulate.

    SecurityInformation - Supplies the level of information to change.

    pSecurityDescriptor - Supplies the new security descriptor for the
        device object.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetDeviceObjectSecurity(
    IN PDEVICE_OBJECT pDeviceObject,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    NTSTATUS status;
    HANDLE handle;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_DEVICE_OBJECT( pDeviceObject ) );
    ASSERT( RtlValidSecurityDescriptor( pSecurityDescriptor ) );

    //
    // Open a handle to the device object.
    //

    UlAttachToSystemProcess();

    status = ObOpenObjectByPointer(
                    pDeviceObject,                  // Object
                    OBJ_CASE_INSENSITIVE |          // HandleAttributes
                        UL_KERNEL_HANDLE,
                    NULL,                           // PassedAccessState
                    MAXIMUM_ALLOWED,                // DesiredAccess
                    NULL,                           // ObjectType
                    KernelMode,                     // AccessMode
                    &handle                         // Handle
                    );

    if (NT_SUCCESS(status))
    {
        status = NtSetSecurityObject(
                        handle,                     // Handle
                        SecurityInformation,        // SecurityInformation
                        pSecurityDescriptor         // SecurityDescriptor
                        );

        ZwClose( handle );
    }

    UlDetachFromSystemProcess();

    return status;

}   // UlpSetDeviceObjectSecurity


/***************************************************************************++

Routine Description:

    Reads the UL section of the registry. Any values contained in the
    registry override defaults.

Arguments:

    pConfig - Supplies a pointer to a UL_CONFIG structure that receives
        init-time configuration parameters. These are basically
        parameters that do not need to persist in the driver once
        initialization is complete.

--***************************************************************************/
VOID
UlpReadRegistry(
    IN PUL_CONFIG pConfig
    )
{
    HANDLE parametersHandle;
    NTSTATUS status;
    LONG tmp;
    LONGLONG tmp64;
    UNICODE_STRING registryPath;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Establish defaults.
    //

    pConfig->ThreadsPerCpu = DEFAULT_THREADS_PER_CPU;
    pConfig->IrpContextLookasideDepth = DEFAULT_IRP_CONTEXT_LOOKASIDE_DEPTH;
    pConfig->ReceiveBufferLookasideDepth = DEFAULT_RCV_BUFFER_LOOKASIDE_DEPTH;
    pConfig->ResourceLookasideDepth = DEFAULT_RESOURCE_LOOKASIDE_DEPTH;
    pConfig->RequestBufferLookasideDepth = DEFAULT_REQ_BUFFER_LOOKASIDE_DEPTH;
    pConfig->InternalRequestLookasideDepth = DEFAULT_INT_REQUEST_LOOKASIDE_DEPTH;
    pConfig->ResponseBufferLookasideDepth = DEFAULT_RESP_BUFFER_LOOKASIDE_DEPTH;
    pConfig->SendTrackerLookasideDepth = DEFAULT_SEND_TRACKER_LOOKASIDE_DEPTH;
    pConfig->LogBufferLookasideDepth = DEFAULT_LOG_BUFFER_LOOKASIDE_DEPTH;
    pConfig->EnableUnload = DEFAULT_ENABLE_UNLOAD;
    pConfig->EnableSecurity = DEFAULT_ENABLE_SECURITY;

    pConfig->UriConfig.EnableCache = DEFAULT_CACHE_ENABLED;
    pConfig->UriConfig.MaxCacheUriCount = DEFAULT_MAX_CACHE_URI_COUNT;
    pConfig->UriConfig.MaxCacheMegabyteCount = DEFAULT_MAX_CACHE_MEGABYTE_COUNT;
    pConfig->UriConfig.MaxUriBytes = DEFAULT_MAX_URI_BYTES;
    pConfig->UriConfig.ScavengerPeriod = DEFAULT_CACHE_SCAVENGER_PERIOD;
    pConfig->LargeMemMegabytes = DEFAULT_LARGE_MEM_MEGABYTES;

    //
    // Open the registry.
    //

    RtlInitUnicodeString( &registryPath, REGISTRY_UL_INFORMATION );

    status = UlOpenRegistry( &registryPath, &parametersHandle );

    if (status != STATUS_SUCCESS)
    {
        return;
    }

#if DBG
    //
    // Read the debug flags.
    //

    g_UlDebug = (ULONG)UlReadLongParameter(
                            parametersHandle,
                            REGISTRY_DEBUG_FLAGS,
                            g_UlDebug
                            );

    //
    // Force a breakpoint if so requested.
    //

    if (UlReadLongParameter(
            parametersHandle,
            REGISTRY_BREAK_ON_STARTUP,
            DEFAULT_BREAK_ON_STARTUP) != 0 )
    {
        DbgBreakPoint();
    }

    //
    // Read the break-on-error flags.
    //

    g_UlBreakOnError = (ULONG)UlReadLongParameter(
                                    parametersHandle,
                                    REGISTRY_BREAK_ON_ERROR,
                                    g_UlBreakOnError
                                    );

    g_UlVerboseErrors = (ULONG)UlReadLongParameter(
                                    parametersHandle,
                                    REGISTRY_VERBOSE_ERRORS,
                                    g_UlVerboseErrors
                                    );

    //
    // Break-on-error implies verbose-errors.
    //

    if (g_UlBreakOnError)
    {
        g_UlVerboseErrors = TRUE;
    }
#endif  // DBG

#if ALLOW_UNLOAD
    //
    // Enable driver unload if requested.
    //

    pConfig->EnableUnload = UlReadLongParameter(
                                parametersHandle,
                                REGISTRY_ENABLE_UNLOAD,
                                (LONG)pConfig->EnableUnload
                                ) != 0;
#endif  // ALLOW_UNLOAD

    //
    // Enable driver security if requested.
    //

    pConfig->EnableSecurity = UlReadLongParameter(
                                    parametersHandle,
                                    REGISTRY_ENABLE_SECURITY,
                                    (LONG)pConfig->EnableSecurity
                                    ) != 0;

    //
    // Read the stack size and priority boost values from the registry.
    //

    tmp = UlReadLongParameter(
              parametersHandle,
              REGISTRY_IRP_STACK_SIZE,
              (LONG)g_UlIrpStackSize
              );

    //
    // Enforce reasonable minimum/maximum values for the IRP stack size.
    //

    if (tmp < 2)
    {
        tmp = 2;
    }
    else if (tmp > 64)
    {
        tmp = 64;
    }

    g_UlIrpStackSize = (CCHAR)tmp;

    tmp = UlReadLongParameter(
              parametersHandle,
              REGISTRY_PRIORITY_BOOST,
              (LONG)g_UlPriorityBoost
              );

    if (tmp > 16 || tmp <= 0)
    {
        tmp = DEFAULT_PRIORITY_BOOST;
    }

    g_UlPriorityBoost = (CCHAR)tmp;

    //
    // Read the thread pool parameters.
    //

    tmp = UlReadLongParameter(
            parametersHandle,
            REGISTRY_THREADS_PER_CPU,
            (LONG)pConfig->ThreadsPerCpu
            );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_THREADS_PER_CPU;
    }

    pConfig->ThreadsPerCpu = (USHORT)tmp;

    //
    // Other configuration parameters.
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MIN_IDLE_CONNECTIONS,
                (LONG)g_UlMinIdleConnections
                );

    if (tmp > 0xFFFF || tmp <= 1)
    {
        tmp = DEFAULT_MIN_IDLE_CONNECTIONS;
    }

    g_UlMinIdleConnections = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_IDLE_CONNECTIONS,
                (LONG)g_UlMaxIdleConnections
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_MAX_IDLE_CONNECTIONS;
    }

    g_UlMaxIdleConnections = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_IRP_CONTEXT_LOOKASIDE_DEPTH,
                (LONG)pConfig->IrpContextLookasideDepth
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_IRP_CONTEXT_LOOKASIDE_DEPTH;
    }

    pConfig->IrpContextLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RCV_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->ReceiveBufferLookasideDepth
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_RCV_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->ReceiveBufferLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_REQ_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->RequestBufferLookasideDepth
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_REQ_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->RequestBufferLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_INT_REQUEST_LOOKASIDE_DEPTH,
                (LONG)pConfig->InternalRequestLookasideDepth
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_INT_REQUEST_LOOKASIDE_DEPTH;
    }

    pConfig->InternalRequestLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RESP_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->ResponseBufferLookasideDepth
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_RESP_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->ResponseBufferLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_SEND_TRACKER_LOOKASIDE_DEPTH,
                (LONG)pConfig->SendTrackerLookasideDepth
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_SEND_TRACKER_LOOKASIDE_DEPTH;
    }

    pConfig->SendTrackerLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_LOG_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->LogBufferLookasideDepth
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_LOG_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->LogBufferLookasideDepth = (USHORT)tmp;

    g_UlEnableConnectionReuse = UlReadLongParameter(
                                    parametersHandle,
                                    REGISTRY_ENABLE_CONNECTION_REUSE,
                                    (LONG)g_UlEnableConnectionReuse
                                    ) != 0;

    g_UlEnableNagling = UlReadLongParameter(
                            parametersHandle,
                            REGISTRY_ENABLE_NAGLING,
                            (LONG)g_UlEnableNagling
                            ) != 0;

    g_UlEnableThreadAffinity = UlReadLongParameter(
                                    parametersHandle,
                                    REGISTRY_ENABLE_THREAD_AFFINITY,
                                    (LONG)g_UlEnableThreadAffinity
                                    ) != 0;

    tmp64 = UlReadLongLongParameter(
                parametersHandle,
                REGISTRY_THREAD_AFFINITY_MASK,
                g_UlThreadAffinityMask
                );

    if ((ULONGLONG)tmp64 > DEFAULT_THREAD_AFFINITY_MASK
        || (ULONGLONG)tmp64 == 0)
    {
        tmp64 = DEFAULT_THREAD_AFFINITY_MASK;
    }

    g_UlThreadAffinityMask = (ULONGLONG)tmp64;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_WORK_QUEUE_DEPTH,
                (LONG)g_UlMaxWorkQueueDepth
                );

    if (tmp > 0xFFFF || tmp < 0)
    {
        tmp = DEFAULT_MAX_WORK_QUEUE_DEPTH;
    }

    g_UlMaxWorkQueueDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MIN_WORK_DEQUEUE_DEPTH,
                (LONG)g_UlMinWorkDequeueDepth
                );

    if (tmp > 0xFFFF || tmp < 0)
    {
        tmp = DEFAULT_MIN_WORK_DEQUEUE_DEPTH;
    }

    g_UlMinWorkDequeueDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_OPAQUE_ID_TABLE_SIZE,
                (LONG)g_UlOpaqueIdTableSize
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_OPAQUE_ID_TABLE_SIZE;
    }

    g_UlOpaqueIdTableSize = tmp;

    //
    // MAX url setting
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_URL_LENGTH,
                (LONG)g_UlMaxUrlLength
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_MAX_URL_LENGTH;
    }

    g_UlMaxUrlLength = (USHORT)tmp;

    //
    // MAX allowed field length in HTTP requests
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_FIELD_LENGTH,
                (LONG)g_UlMaxFieldLength
                );

    if (tmp > 0xFFFFFF || tmp <= 0)
    {
        tmp = DEFAULT_MAX_FIELD_LENGTH;
    }

    g_UlMaxFieldLength = tmp;

    //
    // If defined this will overwrite the default
    // log timer cycle period of 1 hour and make
    // the testing of the log recycling easier.
    // The value is interpreted in seconds.
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_DEBUG_LOGTIMER_CYCLE,
                (LONG)g_UlDebugLogTimerCycle
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_DEBUG_LOGTIMER_CYCLE;
    }

    g_UlDebugLogTimerCycle = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_DEBUG_LOG_BUFFER_PERIOD,
                (LONG)g_UlDebugLogBufferPeriod
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_DEBUG_LOG_BUFFER_PERIOD;
    }

    g_UlDebugLogBufferPeriod = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_LOG_BUFFER_SIZE,
                (LONG)g_UlLogBufferSize
                );

    if (tmp >  MAXIMUM_ALLOWED_LOG_BUFFER_SIZE
        || tmp <  MINIMUM_ALLOWED_LOG_BUFFER_SIZE )
    {
        // Basically this value will be discarted by the logging code
        // instead systems granularity size (64K) will be used.
        tmp = DEFAULT_LOG_BUFFER_SIZE;
    }

    tmp -= tmp % 4096;  // Align down to 4k

    g_UlLogBufferSize = (ULONG) tmp;

    //
    // read the resource lookaside config
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RESOURCE_LOOKASIDE_DEPTH,
                (LONG)pConfig->ResourceLookasideDepth
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_RESOURCE_LOOKASIDE_DEPTH;
    }

    pConfig->ResourceLookasideDepth = (USHORT)tmp;


    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_REQUEST_BYTES,
                g_UlMaxRequestBytes
                );

    if (tmp > 0xFFFFFF || tmp <= 0)
    {
        tmp = DEFAULT_MAX_REQUEST_BYTES;
    }

    g_UlMaxRequestBytes = ALIGN_DOWN( tmp, PVOID );

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RCV_BUFFER_SIZE,
                g_UlReceiveBufferSize
                );

    if (tmp > 0xFFFFFF || tmp <= 0)
    {
        tmp = DEFAULT_RCV_BUFFER_SIZE;
    }

    g_UlReceiveBufferSize = ALIGN_DOWN( tmp, PVOID );

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RESP_BUFFER_SIZE,
                g_UlResponseBufferSize
                );

    if (tmp > 0xFFFFFF || tmp <= 0)
    {
        tmp = DEFAULT_RESP_BUFFER_SIZE;
    }

    g_UlResponseBufferSize = ALIGN_DOWN( tmp, PVOID );

    //
    // Read URL processing parameters.
    // BUGBUG: read legacy IIS value?
    //

    g_UlEnableNonUTF8 = UlReadLongParameter(
                        parametersHandle,
                        REGISTRY_ENABLE_NON_UTF8_URL,
                        DEFAULT_ENABLE_NON_UTF8_URL
                        ) != 0;

    if (g_UlEnableNonUTF8)
    {
        g_UlEnableDBCS = UlReadLongParameter(
                            parametersHandle,
                            REGISTRY_ENABLE_DBCS_URL,
                            DEFAULT_ENABLE_DBCS_URL
                            ) != 0;
    }
    else
    {
        //
        // We can't do DBCS if we only accept UTF-8.
        //
        g_UlEnableDBCS = FALSE;
    }

    if (g_UlEnableDBCS)
    {
        g_UlFavorDBCS = UlReadLongParameter(
                            parametersHandle,
                            REGISTRY_FAVOR_DBCS_URL,
                            DEFAULT_FAVOR_DBCS_URL
                            ) != 0;
    }
    else
    {
        //
        // We can't favor DBCS if we don't allow DBCS.
        //
        g_UlFavorDBCS = FALSE;
    }

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_INTERNAL_URL_LENGTH,
                g_UlMaxInternalUrlLength
                );

    if (tmp > 0xFFFFFF || tmp <= 0)
    {
        tmp = DEFAULT_MAX_INTERNAL_URL_LENGTH;
    }

    g_UlMaxInternalUrlLength = (USHORT)tmp;

    //
    // Read URI Cache parameters
    //

    pConfig->UriConfig.EnableCache = UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_CACHE_ENABLED,
                                            DEFAULT_CACHE_ENABLED
                                            ) != 0;

    pConfig->UriConfig.MaxCacheUriCount = UlReadLongParameter(
                                                parametersHandle,
                                                REGISTRY_MAX_CACHE_URI_COUNT,
                                                DEFAULT_MAX_CACHE_URI_COUNT
                                                );

    pConfig->UriConfig.MaxCacheMegabyteCount = UlReadLongParameter(
                                                parametersHandle,
                                                REGISTRY_MAX_CACHE_MEGABYTE_COUNT,
                                                DEFAULT_MAX_CACHE_MEGABYTE_COUNT
                                                );

    pConfig->UriConfig.MaxUriBytes = UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_MAX_URI_BYTES,
                                            DEFAULT_MAX_URI_BYTES
                                            );

    pConfig->UriConfig.ScavengerPeriod = UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_CACHE_SCAVENGER_PERIOD,
                                            DEFAULT_CACHE_SCAVENGER_PERIOD
                                            );

    pConfig->UriConfig.HashTableBits = UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_HASH_TABLE_BITS,
                                            DEFAULT_HASH_TABLE_BITS
                                            );

    pConfig->LargeMemMegabytes = UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_LARGE_MEM_MEGABYTES,
                                            DEFAULT_LARGE_MEM_MEGABYTES
                                            );

    //
    // Make sure we can always buffer enough bytes for an entire request
    // header.
    //

    g_UlMaxBufferedBytes = MAX(g_UlMaxBufferedBytes, g_UlMaxRequestBytes);

    //
    // Dump configuration on checked builds.
    //

#if DBG
    DbgPrint( "UL Configuration:\n" );
#if DBG
    DbgPrint( "    g_UlDebug                    = %08lx\n", g_UlDebug );
    DbgPrint( "    g_UlBreakOnError             = %lu\n", g_UlBreakOnError );
    DbgPrint( "    g_UlVerboseErrors            = %lu\n", g_UlVerboseErrors );
#endif  // DBG
    DbgPrint( "    g_UlIrpStackSize             = %lu\n", g_UlIrpStackSize );
    DbgPrint( "    g_UlPriorityBoost            = %lu\n", g_UlPriorityBoost );
    DbgPrint( "    g_UlMinIdleConnections       = %lu\n", g_UlMinIdleConnections );
    DbgPrint( "    g_UlMaxIdleConnections       = %lu\n", g_UlMaxIdleConnections );
    DbgPrint( "    g_UlEnableConnectionReuse    = %lu\n", g_UlEnableConnectionReuse );
    DbgPrint( "    g_UlEnableNagling            = %lu\n", g_UlEnableNagling );
    DbgPrint( "    g_UlEnableThreadAffinity     = %lu\n", g_UlEnableThreadAffinity );
    DbgPrint( "    g_UlThreadAffinityMask       = %I64x\n", g_UlThreadAffinityMask );
    DbgPrint( "    g_UlMaxWorkQueueDepth        = %lu\n", g_UlMaxWorkQueueDepth );
    DbgPrint( "    g_UlMinWorkDequeueDepth      = %lu\n", g_UlMinWorkDequeueDepth );
    DbgPrint( "    g_UlOpaqueIdTableSize        = %lu\n", g_UlOpaqueIdTableSize );
    DbgPrint( "    g_UlMaxRequestBytes          = %lu\n", g_UlMaxRequestBytes );
    DbgPrint( "    g_UlReceiveBufferSize        = %lu\n", g_UlReceiveBufferSize );
    DbgPrint( "    g_UlResponseBufferSize       = %lu\n", g_UlResponseBufferSize );
    DbgPrint( "    g_UlMaxUrlLength             = %lu\n", g_UlMaxUrlLength );
    DbgPrint( "    g_UlMaxFieldLength           = %lu\n", g_UlMaxFieldLength );
    DbgPrint( "    g_UlDebugLogTimerCycle       = %lu\n", g_UlDebugLogTimerCycle );
    DbgPrint( "    g_UlDebugLogBufferPeriod     = %lu\n", g_UlDebugLogBufferPeriod );
    DbgPrint( "    g_UlLogBufferSize            = %lu\n", g_UlLogBufferSize );

    DbgPrint( "    g_UlEnableNonUTF8            = %lu\n", g_UlEnableNonUTF8 );
    DbgPrint( "    g_UlEnableDBCS               = %lu\n", g_UlEnableDBCS );
    DbgPrint( "    g_UlFavorDBCS                = %lu\n", g_UlFavorDBCS );

    DbgPrint( "    g_UlMaxInternalUrlLength     = %lu\n", g_UlMaxInternalUrlLength );

#if ALLOW_UNLOAD
    DbgPrint( "    EnableUnload                 = %lu\n", pConfig->EnableUnload );
#endif  // ALLOW_UNLOAD
    DbgPrint( "    EnableSecurity               = %lu\n", pConfig->EnableSecurity );
    DbgPrint( "    ThreadsPerCpu                = %lx\n", pConfig->ThreadsPerCpu );
    DbgPrint( "    IrpContextLookasideDepth     = %lu\n", pConfig->IrpContextLookasideDepth );
    DbgPrint( "    ReceiveBufferLookasideDepth  = %lu\n", pConfig->ReceiveBufferLookasideDepth );
    DbgPrint( "    ResourceLookasideDepth       = %lu\n", pConfig->ResourceLookasideDepth );
    DbgPrint( "    RequestBufferLookasideDepth  = %lu\n", pConfig->RequestBufferLookasideDepth );
    DbgPrint( "    IntlRequestLookasideDepth    = %lu\n", pConfig->InternalRequestLookasideDepth );
    DbgPrint( "    ResponseBufferLookasideDepth = %lu\n", pConfig->ResponseBufferLookasideDepth );
    DbgPrint( "    SendTrackerLookasideDepth    = %lu\n", pConfig->SendTrackerLookasideDepth );
    DbgPrint( "    LogBufferLookasideDepth      = %lu\n", pConfig->LogBufferLookasideDepth );
    DbgPrint( "    EnableCache                  = %lu\n", pConfig->UriConfig.EnableCache );
    DbgPrint( "    MaxCacheUriCount             = %lu\n", pConfig->UriConfig.MaxCacheUriCount );
    DbgPrint( "    MaxCacheMegabyteCount        = %lu\n", pConfig->UriConfig.MaxCacheMegabyteCount );
    DbgPrint( "    ScavengerPeriod              = %lu\n", pConfig->UriConfig.ScavengerPeriod );
    DbgPrint( "    HashTableBits                = %ld\n", pConfig->UriConfig.HashTableBits);
    DbgPrint( "    MaxUriBytes                  = %lu\n", pConfig->UriConfig.MaxUriBytes );
    DbgPrint( "    LargeMemMegabytes            = %ld\n", pConfig->LargeMemMegabytes );
#endif  // DBG

    //
    // Cleanup.
    //

    UlCloseSystemHandle( parametersHandle );

}   // UlpReadRegistry


#if ALLOW_UNLOAD

/***************************************************************************++

Routine Description:

    Unload routine called by the IO subsystem when UL is getting
    unloaded.

--***************************************************************************/
VOID
UlpUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{

    //
    // Sanity check.
    //

    PAGED_CODE();
    UL_ENTER_DRIVER("UlpUnload", NULL);

#if DBG
    KdPrint(( "UlpUnload called.\n" ));
#endif // DBG

    //
    // Terminate the UL modules.
    //

    UlpTerminateModules();

    UL_LEAVE_DRIVER("UlpUnload");

 #if DBG
    //
    // Terminate any debug-specific data after UL_LEAVE_DRIVER
    //

    UlDbgTerminateDebugData( );
#endif  // DBG


}   // UlpUnload

#endif // ALLOW_UNLOAD


/***************************************************************************++

Routine Description:

    Terminates the various UL modules in the correct order.

--***************************************************************************/
VOID
UlpTerminateModules(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Wait for endpoints to go away, so we're sure all I/O is done.
    //
    UlWaitForEndpointDrain();

    //
    // Kill Michael.
    //

    UlTerminateDateCache();
    UlTerminateUriCache();
    UlTerminateFilterChannel();

    //
    // Kill Henry.
    //

    TerminateFileCache();

    //
    // Kill Paul.
    //

    UlTerminateCG();
    UlTerminateAP();

    //
    // Kill Keith.
    //

    UlTerminateControlChannel();

    //
    // TerminateLogs Blocks until all Io To Be Complete
    //
    // Note:CG should be terminated before Logs.
    //      Otherwise we won't stop issuing the buffer writes.
    //      ThreadPool should be terminated after Logs.
    //      Otherwise our Completion APCs won't be completed back.
    //

    //
    // Kill Ali
    //

    UlTerminateLogs();
    UlTcTerminate();

    //
    // Kill Eric.
    //

    UlTerminateHttpRcv();
    UlTerminateCounters();
    UlTerminateTimeoutMonitor();

    //
    // Kill George.
    //

    UlLargeMemTerminate();

    //
    // Kill TDI.
    //

    UxTerminateTdi();
    UlTerminateTdi();

    //
    // Kill the thread pool.
    //

    UlTerminateThreadPool();


    //
    // Kill the opaque Ids
    //

    UlTerminateOpaqueIdTable();


    //
    // Kill any global data.
    //

    UlTerminateData();


    //
    // Delete our device objects.
    //

    if (g_pUlAppPoolDeviceObject != NULL)
    {
        IoDeleteDevice( g_pUlAppPoolDeviceObject );
    }

    if (g_pUlFilterDeviceObject != NULL)
    {
        IoDeleteDevice( g_pUlFilterDeviceObject );
    }

    if (g_pUlControlDeviceObject != NULL)
    {
        IoDeleteDevice( g_pUlControlDeviceObject );
    }

    //
    // Delete the directory container.
    //

    if (g_UlDirectoryObject != NULL)
    {
        UlCloseSystemHandle( g_UlDirectoryObject );
    }

    //
    // Delete the global trace logs.
    //

    DESTROY_REF_TRACE_LOG( g_pTdiTraceLog );
    DESTROY_REF_TRACE_LOG( g_pHttpRequestTraceLog );
    DESTROY_REF_TRACE_LOG( g_pHttpConnectionTraceLog );
    DESTROY_REF_TRACE_LOG( g_pHttpResponseTraceLog );
    DESTROY_REF_TRACE_LOG( g_pAppPoolTraceLog );
    DESTROY_REF_TRACE_LOG( g_pConfigGroupTraceLog );
    DESTROY_REF_TRACE_LOG( g_pThreadTraceLog );
    DESTROY_REF_TRACE_LOG( g_pMdlTraceLog );
    DESTROY_REF_TRACE_LOG( g_pFilterTraceLog );
    DESTROY_REF_TRACE_LOG( g_pMondoGlobalTraceLog );
    DESTROY_IRP_TRACE_LOG( g_pIrpTraceLog );
    DESTROY_TIME_TRACE_LOG( g_pTimeTraceLog );
    DESTROY_REPLENISH_TRACE_LOG( g_pReplenishTraceLog );
    DESTROY_FILTQ_TRACE_LOG( g_pFilterQueueTraceLog );
    DESTROY_REF_TRACE_LOG( g_pSiteCounterTraceLog );
    DESTROY_REF_TRACE_LOG( g_pConnectionCountTraceLog );
    DESTROY_REF_TRACE_LOG( g_pConfigGroupInfoTraceLog );
    DESTROY_REF_TRACE_LOG( g_pChunkTrackerTraceLog );
    DESTROY_REF_TRACE_LOG( g_pWorkItemTraceLog );

    UlTerminateOwnerRefTraceLog();
}   // UlpTerminateModules
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ioctl.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    This module contains declarations for various IOCTL handlers.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _IOCTL_H_
#define _IOCTL_H_

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
UlQueryControlChannelIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSetControlChannelIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlCreateConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlDeleteConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlQueryConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSetConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlAddUrlToConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlRemoveUrlFromConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlRemoveAllUrlsFromConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlConfigGroupControlIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlQueryAppPoolInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSetAppPoolInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlReceiveHttpRequestIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlReceiveEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSendHttpResponseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSendEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSendCachedResponseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFlushResponseCacheIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlWaitForDemandStartIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlWaitForDisconnectIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlAddTransientUrlIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlRemoveTransientUrlIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterAcceptIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterCloseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterRawReadIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterRawWriteIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterAppReadIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterAppWriteIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlReceiveClientCertIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlGetCountersIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _IOCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ioctl.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    ioctl.cxx

Abstract:

    This module implements various IOCTL handlers.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

    Paul McDaniel (paulmcd)     15-Mar-1999     Modified SendResponse

--*/


#include "precomp.h"


#define VALIDATE_OFFSET( off, input )   ((off) < (input))
#define VALIDATE_LENGTH( len, input )   ((len) < (input))

#define VALIDATE_OFFSET_LENGTH_PAIR( off, len, input )                      \
    ( VALIDATE_OFFSET( off, input ) &&                                      \
      VALIDATE_LENGTH( len, input ) &&                                      \
      (((off) + (len)) < (input)) )


VOID
UlpRestartSendHttpResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlQueryControlChannelIoctl )
#pragma alloc_text( PAGE, UlSetControlChannelIoctl )
#pragma alloc_text( PAGE, UlCreateConfigGroupIoctl )
#pragma alloc_text( PAGE, UlDeleteConfigGroupIoctl )
#pragma alloc_text( PAGE, UlQueryConfigGroupIoctl )
#pragma alloc_text( PAGE, UlSetConfigGroupIoctl )
#pragma alloc_text( PAGE, UlAddUrlToConfigGroupIoctl )
#pragma alloc_text( PAGE, UlRemoveUrlFromConfigGroupIoctl )
#pragma alloc_text( PAGE, UlRemoveAllUrlsFromConfigGroupIoctl )
#pragma alloc_text( PAGE, UlConfigGroupControlIoctl )
#pragma alloc_text( PAGE, UlQueryAppPoolInformationIoctl )
#pragma alloc_text( PAGE, UlSetAppPoolInformationIoctl )
#pragma alloc_text( PAGE, UlReceiveHttpRequestIoctl )
#pragma alloc_text( PAGE, UlReceiveEntityBodyIoctl )
#pragma alloc_text( PAGE, UlSendHttpResponseIoctl )
#pragma alloc_text( PAGE, UlSendEntityBodyIoctl )
#pragma alloc_text( PAGE, UlFlushResponseCacheIoctl )
#pragma alloc_text( PAGE, UlWaitForDemandStartIoctl )
#pragma alloc_text( PAGE, UlWaitForDisconnectIoctl )
#pragma alloc_text( PAGE, UlAddTransientUrlIoctl )
#pragma alloc_text( PAGE, UlRemoveTransientUrlIoctl )
#pragma alloc_text( PAGE, UlFilterAcceptIoctl )
#pragma alloc_text( PAGE, UlFilterCloseIoctl )
#pragma alloc_text( PAGE, UlFilterRawReadIoctl )
#pragma alloc_text( PAGE, UlFilterRawWriteIoctl )
#pragma alloc_text( PAGE, UlFilterAppReadIoctl )
#pragma alloc_text( PAGE, UlFilterAppWriteIoctl )
#pragma alloc_text( PAGE, UlReceiveClientCertIoctl )
#pragma alloc_text( PAGE, UlGetCountersIoctl )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlpRestartSendHttpResponse
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This routine queries information associated with a control channel.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQueryControlChannelIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONTROL_CHANNEL_INFO  pInfo = NULL;
    PUL_CONTROL_CHANNEL         pControlChannel;
    PVOID                       pMdlBuffer;
    ULONG                       length;
    PVOID pMdlVa;

    //
    // sanity check.
    //

    PAGED_CODE();

    //
    // better be a control channel
    //

    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not a control channel.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    pControlChannel = GET_CONTROL_CHANNEL(pIrpSp->FileObject);
    if (IS_VALID_CONTROL_CHANNEL(pControlChannel) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Ensure the input buffer looks good
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_CONTROL_CHANNEL_INFO))
    {
        //
        // input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // fetch it
    //

    pInfo = (PHTTP_CONTROL_CHANNEL_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    __try
    {
        switch (pInfo->InformationClass)
        {
        case HttpControlChannelStateInformation:
        case HttpControlChannelBandwidthInformation:
        case HttpControlChannelConnectionInformation:
        case HttpControlChannelAutoResponseInformation:

            // if no outbut buffer pass down in the Irp
            // that means app is asking for the required
            // field length

            if (!pIrp->MdlAddress)
            {
                pMdlBuffer = NULL;
            }
            else
            {
                pMdlBuffer = MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            LowPagePriority
                            );

                if (pMdlBuffer == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    __leave;
                }

                // Also make sure that user buffer was good

                pMdlVa = MmGetMdlVirtualAddress(pIrp->MdlAddress);
                ProbeForWrite( pMdlVa,
                           pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                           sizeof(UCHAR) );
            }

            Status = UlGetControlChannelInformation(
                            pControlChannel,
                            pInfo->InformationClass,
                            pMdlBuffer,
                            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            &length
                            );

            if (!NT_SUCCESS(Status))
            {
                __leave;
            }

            pIrp->IoStatus.Information = (ULONG_PTR)length;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            __leave;
            break;
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

end:
    //
    // complete the request.
    //

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlQueryControlChannelIoctl

/***************************************************************************++

Routine Description:

    This routine sets information associated with a control channel.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetControlChannelIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONTROL_CHANNEL_INFO  pInfo;
    PUL_CONTROL_CHANNEL         pControlChannel;
    PVOID                       pMdlBuffer;

    //
    // sanity check.
    //

    PAGED_CODE();

    //
    // better be a control channel
    //

    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not a control channel.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    pControlChannel = GET_CONTROL_CHANNEL(pIrpSp->FileObject);
    if (IS_VALID_CONTROL_CHANNEL(pControlChannel) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Ensure the input buffer looks good
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_CONTROL_CHANNEL_INFO))
    {
        //
        // input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    //
    // Ensure the output buffer looks good
    //

    if (!pIrp->MdlAddress)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    // fetch it
    //

    pInfo = (PHTTP_CONTROL_CHANNEL_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    switch (pInfo->InformationClass)
    {

    case HttpControlChannelStateInformation:
    case HttpControlChannelBandwidthInformation:
    case HttpControlChannelConnectionInformation:
    case HttpControlChannelAutoResponseInformation:
    case HttpControlChannelFilterInformation:
    case HttpControlChannelTimeoutInformation:
    case HttpControlChannelUTF8Logging:

        //
        // call the function
        //

        pMdlBuffer = MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            LowPagePriority
                            );

        if (pMdlBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = UlSetControlChannelInformation(
                            pControlChannel,
                            pInfo->InformationClass,
                            pMdlBuffer,
                            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength
                            );
        }

        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        break;


    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

end:

    //
    // complete the request.
    //

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlSetControlChannelIoctl

/***************************************************************************++

Routine Description:

    This routine creates a new configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_INFO     pInfo = NULL;

    //
    // sanity check.
    //

    PAGED_CODE();

    // better be a control channel
    //
    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        // Not a control channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    // Ensure the output buffer is large enough.
    //
    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(HTTP_CONFIG_GROUP_INFO))
    {
        // output buffer too small.
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    // Fetch out the output buffer
    //
    pInfo = (PHTTP_CONFIG_GROUP_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    // it's pure output, wipe it to be sure
    //
    RtlZeroMemory(pInfo, sizeof(HTTP_CONFIG_GROUP_INFO));

    // Call the internal worker func
    //
    Status = UlCreateConfigGroup(
                    GET_CONTROL_CHANNEL(pIrpSp->FileObject),
                    &pInfo->ConfigGroupId
                    );
    if (NT_SUCCESS(Status) == FALSE)
        goto end;


end:
    // complete the request.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        //  how much output should we return?
        //
        pIrp->IoStatus.Information = sizeof(HTTP_CONFIG_GROUP_INFO);

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlCreateConfigGroupIoctl

/***************************************************************************++

Routine Description:

    This routine deletes an existing configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDeleteConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_INFO     pInfo = NULL;

    //
    // sanity check.
    //

    PAGED_CODE();

    // better be a control channel
    //
    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        // Not a control channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    // Ensure the input buffer is large enough.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_CONFIG_GROUP_INFO))
    {
        // output buffer too small.
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    // fetch out the input buffer
    //
    pInfo = (PHTTP_CONFIG_GROUP_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);


    // Call the internal worker func
    //
    __try
    {
        HTTP_CONFIG_GROUP_ID ConfigGroupId = pInfo->ConfigGroupId;

        Status = UlDeleteConfigGroup(ConfigGroupId);
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

end:
    // complete the request.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlDeleteConfigGroupIoctl

/***************************************************************************++

Routine Description:

    This routine queries information associated with a configuration group.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQueryConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_INFO     pInfo = NULL;
    PVOID                       pMdlBuffer;
    ULONG length = 0L;

    //
    // sanity check.
    //

    PAGED_CODE();

    //
    // Going to access the url string from user mode memory
    //

    __try
    {

        //
        // better be a control channel
        //

        if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
        {
            //
            // Not a control channel.
            //

            Status = STATUS_INVALID_DEVICE_REQUEST;
            __leave;
        }

        //
        // Ensure the input buffer looks good
        //

        if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(HTTP_CONFIG_GROUP_INFO))
        {
            //
            // input buffer too small.
            //

            Status = STATUS_BUFFER_TOO_SMALL;
            __leave;
        }

        //
        // fetch it
        //

        pInfo = (PHTTP_CONFIG_GROUP_INFO)pIrp->AssociatedIrp.SystemBuffer;
        ASSERT(pInfo != NULL);

        switch (pInfo->InformationClass)
        {
#if DBG
        case HttpConfigGroupGetUrlInfo:
        {
            PHTTP_CONFIG_GROUP_DBG_URL_INFO pUrlInfo;
            PUL_URL_CONFIG_GROUP_INFO     pUrlCGInfo;

            // check the output buffer
            //
            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(HTTP_CONFIG_GROUP_DBG_URL_INFO))
            {
                // output buffer too small.
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            // grab the buffer
            //
            pUrlInfo = (PHTTP_CONFIG_GROUP_DBG_URL_INFO)
                MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            NormalPagePriority
                            );

            if (pUrlInfo == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;
            }

            pUrlCGInfo = (PUL_URL_CONFIG_GROUP_INFO)UL_ALLOCATE_POOL(
                                NonPagedPool,
                                sizeof(UL_URL_CONFIG_GROUP_INFO),
                                UL_CG_URL_INFO_POOL_TAG
                                );

            if (pUrlCGInfo == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;
            }

            // grab the url
            //
            if (pUrlInfo->Url.Length == 0 ||
                pUrlInfo->Url.MaximumLength > pUrlInfo->Url.Length ||
                pUrlInfo->Url.Buffer == NULL)

            {
                // output buffer too small.
                Status = STATUS_INVALID_PARAMETER;
                __leave;
            }

            // good memory?
            //
            ProbeTestForRead(pUrlInfo->Url.Buffer,
                             pUrlInfo->Url.Length + sizeof(WCHAR),
                             sizeof(WCHAR));

            // must be null terminated
            //
            if (pUrlInfo->Url.Buffer[pUrlInfo->Url.Length/sizeof(WCHAR)] != UNICODE_NULL)
            {
                Status = STATUS_INVALID_PARAMETER;
                __leave;
            }

            // CODEWORK: validate the incoming url.
            //

            // call the function
            //
            Status = UlGetConfigGroupInfoForUrl(
                            pUrlInfo->Url.Buffer,
                            NULL,   // PUL_HTTP_CONNECTION
                            pUrlCGInfo);
            if (NT_SUCCESS(Status) == FALSE)
                __leave;

            // copy it over
            //

            //pUrlInfo->Url;

            pUrlInfo->MaxBandwidth      = -1;
            if (pUrlCGInfo->pMaxBandwidth != NULL)
            {
                pUrlInfo->MaxBandwidth =
                    pUrlCGInfo->pMaxBandwidth->MaxBandwidth.MaxBandwidth;
            }

            pUrlInfo->MaxConnections    = -1;
            if (pUrlCGInfo->pMaxConnections != NULL)
            {
                pUrlInfo->MaxConnections =
                    pUrlCGInfo->pMaxConnections->MaxConnections.MaxConnections;
            }

            pUrlInfo->CurrentState      = pUrlCGInfo->CurrentState;
            pUrlInfo->UrlContext        = pUrlCGInfo->UrlContext;
            pUrlInfo->pReserved         = pUrlCGInfo;

            // update the output length
            //
            pIrp->IoStatus.Information = sizeof(HTTP_CONFIG_GROUP_DBG_URL_INFO);

        }
            break;

        case HttpConfigGroupFreeUrlInfo:
        {
            PHTTP_CONFIG_GROUP_DBG_URL_INFO pUrlInfo;

            // check the output buffer
            //
            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(HTTP_CONFIG_GROUP_DBG_URL_INFO))
            {
                // output buffer too small.
                Status = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            // grab the buffer
            //
            pUrlInfo = (PHTTP_CONFIG_GROUP_DBG_URL_INFO)
                MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            NormalPagePriority
                            );

            if (pUrlInfo == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;
            }

            // call the function
            //
            UlpConfigGroupInfoRelease(
                            (PUL_URL_CONFIG_GROUP_INFO)(pUrlInfo->pReserved)
                            );

            UL_FREE_POOL(
                (PUL_URL_CONFIG_GROUP_INFO)(pUrlInfo->pReserved),
                UL_CG_URL_INFO_POOL_TAG
                );

            // update the output length
            //
            pIrp->IoStatus.Information = 0;

        }
            break;

        case HttpConfigGroupUrlStaleTest:
        {
            Status = STATUS_NOT_SUPPORTED;
        }
            break;

#endif // DBG

        case HttpConfigGroupBandwidthInformation:
        case HttpConfigGroupConnectionInformation:
        case HttpConfigGroupStateInformation:
        case HttpConfigGroupConnectionTimeoutInformation:

            //
            // call the function
            //

            pMdlBuffer = MmGetSystemAddressForMdlSafe(
                                pIrp->MdlAddress,
                                LowPagePriority
                                );

            if (pMdlBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                Status = UlQueryConfigGroupInformation(
                                pInfo->ConfigGroupId,
                                pInfo->InformationClass,
                                pMdlBuffer,
                                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                &length
                                );
            }

            if (!NT_SUCCESS(Status))
            {
                __leave;
            }

            pIrp->IoStatus.Information = (ULONG_PTR)length;
            break;


        case HttpConfigGroupAutoResponseInformation:
        case HttpConfigGroupAppPoolInformation:
        case HttpConfigGroupSecurityInformation:
        default:
            Status = STATUS_INVALID_PARAMETER;
            __leave;
        }

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    //
    // complete the request.
    //

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlQueryConfigGroupIoctl

/***************************************************************************++

Routine Description:

    This routine sets information associated with a configuration group.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_INFO     pInfo = NULL;
    PVOID                       pMdlBuffer;
    PVOID                       pMdlVa;
    ULONG                       OutputLength;

    //
    // sanity check.
    //

    PAGED_CODE();

    //
    // better be a control channel
    //

    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not a control channel.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer looks good
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_CONFIG_GROUP_INFO))
    {
        //
        // input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // fetch it
    //

    pInfo = (PHTTP_CONFIG_GROUP_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    OutputLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    switch (pInfo->InformationClass)
    {

        case HttpConfigGroupLogInformation:
        {

          __try
          {
            // if no outbut buffer pass down in the Irp
            // that probably means WAS is asking us to
            // remove the logging for this config_group
            // we will handle this case later...CODEWORK

            if (!pIrp->MdlAddress)
            {
                pMdlBuffer = NULL;
            }
            else
            {
                pMdlBuffer = MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            LowPagePriority
                            );

                if (pMdlBuffer == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    __leave;
                }

                // Also make sure that user buffer was good

                pMdlVa = MmGetMdlVirtualAddress(pIrp->MdlAddress);
                ProbeTestForRead( pMdlVa,
                                  OutputLength,
                                  sizeof(UCHAR) );
            }

            UlTrace(IOCTL,
                    ("UlSetConfigGroupIoctl: CGroupId=%I64x, "
                     "LogInformation, pMdlBuffer=%p, length=%d\n",
                     pInfo->ConfigGroupId,
                     pMdlBuffer,
                     OutputLength
                     ));
            
            Status = UlSetConfigGroupInformation(
                            pInfo->ConfigGroupId,
                            pInfo->InformationClass,
                            pMdlBuffer,
                            OutputLength
                            );          
        }    
        __except( UL_EXCEPTION_FILTER() )
        {
            Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        }

        if (NT_SUCCESS(Status) == FALSE)
            goto end;
    }
    break;

    case HttpConfigGroupAutoResponseInformation:
    case HttpConfigGroupAppPoolInformation:
    case HttpConfigGroupBandwidthInformation:
    case HttpConfigGroupConnectionInformation:
    case HttpConfigGroupStateInformation:
    case HttpConfigGroupSecurityInformation:
    case HttpConfigGroupSiteInformation:
    case HttpConfigGroupConnectionTimeoutInformation:

        //
        // call the function
        //

        pMdlBuffer = MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            LowPagePriority
                            );

        if (pMdlBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            UlTrace(IOCTL,
                    ("UlSetConfigGroupIoctl: CGroupId=%I64x, "
                     "InfoClass=%d, pMdlBuffer=%p, length=%d\n",
                     pInfo->ConfigGroupId,
                     pInfo->InformationClass,
                     pMdlBuffer,
                     OutputLength
                     ));
            
            Status = UlSetConfigGroupInformation(
                            pInfo->ConfigGroupId,
                            pInfo->InformationClass,
                            pMdlBuffer,
                            OutputLength
                            );
        }

        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        break;


    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
        break;
    }

end:
    //
    // complete the request.
    //

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlSetConfigGroupIoctl

/***************************************************************************++

Routine Description:

    This routine adds a new URL prefix to a configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAddUrlToConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_URL_INFO pInfo = NULL;

    //
    // sanity check.
    //

    PAGED_CODE();

    // better be a control channel
    //
    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        // Not a control channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    // Ensure the input buffer is large enough.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_CONFIG_GROUP_URL_INFO))
    {
        // bad buffer
        //
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    // Fetch out the input buffer
    //
    pInfo = (PHTTP_CONFIG_GROUP_URL_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    // does it look appropriate?
    //
    if (pInfo->FullyQualifiedUrl.MaximumLength < pInfo->FullyQualifiedUrl.Length ||
        pInfo->FullyQualifiedUrl.Length == 0 ||
        (pInfo->FullyQualifiedUrl.Length % sizeof(WCHAR)) != 0 ||
        pInfo->FullyQualifiedUrl.Buffer == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    // Going to access the url string from user mode memory
    //
    __try
    {
        // good memory?
        //
        ProbeTestForRead(pInfo->FullyQualifiedUrl.Buffer,
                         pInfo->FullyQualifiedUrl.Length + sizeof(WCHAR),
                         sizeof(WCHAR));

        // must be null terminated
        //
        if (pInfo->FullyQualifiedUrl.Buffer[pInfo->FullyQualifiedUrl.Length/sizeof(WCHAR)] != UNICODE_NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // CODEWORK: validate the incoming url.
        //

        // Call the internal worker func
        //
        Status = UlAddUrlToConfigGroup(pInfo->ConfigGroupId, &pInfo->FullyQualifiedUrl, pInfo->UrlContext);
        if (NT_SUCCESS(Status) == FALSE)
            __leave;

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

end:
    // complete the request.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlAddUrlToConfigGroupIoctl

/***************************************************************************++

Routine Description:

    This routine removes a URL prefix from a configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveUrlFromConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_URL_INFO pInfo = NULL;

    //
    // sanity check.
    //

    PAGED_CODE();

    // better be a control channel
    //
    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        // Not a control channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    // Ensure the input buffer is large enough.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_CONFIG_GROUP_URL_INFO))
    {
        // bad buffer
        //
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    // Fetch out the input buffer
    //
    pInfo = (PHTTP_CONFIG_GROUP_URL_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    // does it look appropriate?
    //
    if (pInfo->FullyQualifiedUrl.MaximumLength < pInfo->FullyQualifiedUrl.Length ||
        pInfo->FullyQualifiedUrl.Length == 0 ||
        (pInfo->FullyQualifiedUrl.Length % sizeof(WCHAR)) != 0 ||
        pInfo->FullyQualifiedUrl.Buffer == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    // Going to access the url string from user mode memory
    //
    __try
    {
        // good memory?
        //
        ProbeTestForRead(pInfo->FullyQualifiedUrl.Buffer,
                         pInfo->FullyQualifiedUrl.Length + sizeof(WCHAR),
                         sizeof(WCHAR));

        // must be null terminated
        //
        if (pInfo->FullyQualifiedUrl.Buffer[pInfo->FullyQualifiedUrl.Length/sizeof(WCHAR)] != UNICODE_NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // CODEWORK: validate the incoming url.
        //

        // Call the internal worker func
        //
        Status = UlRemoveUrlFromConfigGroup(pInfo->ConfigGroupId, &pInfo->FullyQualifiedUrl);
        if (NT_SUCCESS(Status) == FALSE)
            __leave;

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

end:
    // complete the request.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlRemoveUrlFromConfigGroupIoctl

/***************************************************************************++

Routine Description:

    This routine removes all URLs from a configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveAllUrlsFromConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS status;
    PHTTP_REMOVE_ALL_URLS_INFO pInfo = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure it's a control channel.
    //

    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(*pInfo))
    {
        status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Fetch out the input buffer.
    //

    pInfo = (PHTTP_REMOVE_ALL_URLS_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    //
    // Call the internal worker function.
    //

    status = UlRemoveAllUrlsFromConfigGroup( pInfo->ConfigGroupId );
    goto end;

end:
    //
    // Complete the request.
    //

    if (status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = status;
        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( status );

}   // UlRemoveAllUrlsFromConfigGroupIoctl


/***************************************************************************++

Routine Description:

    This routine queries information associated with an application pool.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQueryAppPoolInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS            Status;
    PHTTP_APP_POOL_INFO pInfo = NULL;
    PVOID               pMdlBuffer;
    ULONG  length;
    PVOID  pMdlVa;

    //
    // sanity check.
    //

    PAGED_CODE();

    //
    // better be an application pool
    //

    if (!IS_APP_POOL(pIrpSp->FileObject))
    {
        //
        // Not an application pool.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer looks good
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_APP_POOL_INFO))
    {
        //
        // input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    pInfo = (PHTTP_APP_POOL_INFO) pIrp->AssociatedIrp.SystemBuffer;

    ASSERT(pInfo != NULL);

    __try
    {
        switch (pInfo->InformationClass)
        {
        case HttpAppPoolDemandStartInformation:
        case HttpAppPoolDemandStartFlagInformation:
        case HttpAppPoolQueueLengthInformation:
        case HttpAppPoolStateInformation:

            // if no outbut buffer passed down in the Irp
            // that means app is asking for the required 
            // field length

            if (!pIrp->MdlAddress)
            {
                pMdlBuffer = NULL;
            }
            else
            {
                pMdlBuffer = MmGetSystemAddressForMdlSafe(
                                    pIrp->MdlAddress,
                                    LowPagePriority
                                    );

                if (pMdlBuffer == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    __leave;
                }

                // Probe the user memory to make sure that it's good.
                
                pMdlVa = MmGetMdlVirtualAddress(pIrp->MdlAddress);

                ProbeForWrite( pMdlVa,
                        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength, 
                        sizeof(UCHAR) );
            }

            Status = UlQueryAppPoolInformation(
                            GET_APP_POOL_PROCESS(pIrpSp->FileObject),
                            pInfo->InformationClass,
                            pMdlBuffer,
                            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            &length
                            );

            if (!NT_SUCCESS(Status))
            {
                __leave;
            }

            pIrp->IoStatus.Information = (ULONG_PTR)length;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            __leave;
            break;
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

end:
    //
    // complete the request.
    //

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlQueryAppPoolInformationIoctl



/***************************************************************************++

Routine Description:

    This routine sets information associated with an application pool.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetAppPoolInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS            Status;
    PHTTP_APP_POOL_INFO pInfo;
    PVOID               pMdlBuffer;

    //
    // Sanity check
    //
    PAGED_CODE();

    //
    // better be an application pool
    //

    if (!IS_APP_POOL(pIrpSp->FileObject))
    {
        //
        // Not an application pool.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer looks good
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_APP_POOL_INFO))
    {
        //
        // input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Check that the input buffer is valid
    //

    if (NULL == pIrp->MdlAddress)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }
    
    __try
    {
        pInfo = (PHTTP_APP_POOL_INFO) pIrp->AssociatedIrp.SystemBuffer;

        switch (pInfo->InformationClass)
        {
        case HttpAppPoolDemandStartInformation:
        case HttpAppPoolDemandStartFlagInformation:
        case HttpAppPoolQueueLengthInformation:
        case HttpAppPoolStateInformation:

            //
            // call the function
            //

            pMdlBuffer = MmGetSystemAddressForMdlSafe(
                                pIrp->MdlAddress,
                                LowPagePriority
                                );

            if (pMdlBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                Status = UlSetAppPoolInformation(
                                GET_APP_POOL_PROCESS(pIrpSp->FileObject),
                                pInfo->InformationClass,
                                pMdlBuffer,
                                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength
                                );
            }

            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        goto end;
    }

end:
    //
    // complete the request.
    //

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );
}   // UlSetAppPoolInformationIoctl


/***************************************************************************++

Routine Description:

    This routine receives an HTTP request.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveHttpRequestIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_RECEIVE_REQUEST_INFO  pInfo = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure this is really an app pool, not a control channel.
    //

    if (IS_APP_POOL(pIrpSp->FileObject))
    {
        //
        // Grab the input buffer
        //

        pInfo = (PHTTP_RECEIVE_REQUEST_INFO) pIrp->AssociatedIrp.SystemBuffer;

        if (NULL == pInfo)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // first make sure the output buffer is at least
        // minimum size.  this is important as we require
        // at least this much space later
        //

        UlTrace(ROUTING, (
            "UlReceiveHttpRequestIoctl(outbuf=%d, inbuf=%d)\n",
            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
            pIrpSp->Parameters.DeviceIoControl.InputBufferLength
            ));
        
        if ((pIrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                sizeof(HTTP_REQUEST)) &&
            (pIrpSp->Parameters.DeviceIoControl.InputBufferLength ==
                sizeof(HTTP_RECEIVE_REQUEST_INFO)))
        {
            Status = UlReceiveHttpRequest(
                            pInfo->RequestId,
                            pInfo->Flags,
                            GET_APP_POOL_PROCESS(pIrpSp->FileObject),
                            pIrp
                            );
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            // Add some padding
            pIrp->IoStatus.Information  = 3 * sizeof(HTTP_REQUEST) / 2;
        }

        UlTrace(ROUTING, (
            "UlReceiveHttpRequestIoctl: BytesNeeded=%d, status=0x%x\n",
            pIrp->IoStatus.Information, Status
            ));
        
    }
    else
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

end:
    //
    // Complete the request.
    //

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlReceiveHttpRequestIoctl

/***************************************************************************++

Routine Description:

    This routine receives entity body data from an HTTP request.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status;
    PHTTP_RECEIVE_REQUEST_INFO pInfo;
    PUL_INTERNAL_REQUEST pRequest = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure this is really an app pool, not a control channel.
    //

    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(HTTP_RECEIVE_REQUEST_INFO))
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Map the incoming connection ID to the corresponding
    // PUL_HTTP_CONNECTION object.
    //

    pInfo = (PHTTP_RECEIVE_REQUEST_INFO)(pIrp->AssociatedIrp.SystemBuffer);

    //
    // Now get the request from the request id.
    // This gets us a reference to the request.
    //

    pRequest = UlGetRequestFromId(pInfo->RequestId);
    if (UL_IS_VALID_INTERNAL_REQUEST(pRequest) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // OK, now call the function
    //

    Status = UlReceiveEntityBody(
                    GET_APP_POOL_PROCESS(pIrpSp->FileObject),
                    pRequest,
                    pIrp
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

end:
    if (pRequest != NULL)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        pRequest = NULL;
    }

    //
    // Complete the request.
    //

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlReceiveEntityBodyIoctl

/***************************************************************************++

Routine Description:

    This routine sends an HTTP response.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendHttpResponseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                        Status = STATUS_SUCCESS;
    PHTTP_SEND_HTTP_RESPONSE_INFO   pSendInfo = NULL;
    PUL_INTERNAL_RESPONSE           pResponse = NULL;
    PHTTP_RESPONSE                  pHttpResponse = NULL;
    ULONG                           Flags;
    PUL_INTERNAL_REQUEST            pRequest = NULL;
    BOOLEAN                         ServedFromCache = FALSE;
    BOOLEAN                         CaptureCache;
    BOOLEAN                         ConnectionClosed = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure this is really an app pool, not a control channel.
    //

    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not an app pool.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*pSendInfo))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    pSendInfo = (PHTTP_SEND_HTTP_RESPONSE_INFO)pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // Probe pSendInfo since we use NEITHER_IO.
    //

    __try
    {
        ProbeTestForRead(
            pSendInfo,
            sizeof(*pSendInfo),
            sizeof(PVOID)
            );

        ProbeTestForRead(
            pSendInfo->pEntityChunks,
            sizeof(HTTP_DATA_CHUNK) * pSendInfo->EntityChunkCount,
            sizeof(PVOID)
            );

        UlTrace(SEND_RESPONSE, (
            "UL!UlSendHttpResponseIoctl - Flags = %X\n",
            pSendInfo->Flags
            ));

        //
        // UlSendHttpResponse() *must* take a PHTTP_RESPONSE. This will
        // protect us from those whackos that attempt to build their own
        // raw response headers.
        //

        pHttpResponse = pSendInfo->pHttpResponse;
        
        if (pHttpResponse == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // Now get the request from the request id.
        // This gives us a reference to the request.
        //

        pRequest = UlGetRequestFromId(pSendInfo->RequestId);

        if (pRequest == NULL)
        {
            //
            // Couldn't map the HTTP_REQUEST_ID.
            //

            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
        ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));

        //
        // Make sure only one response header goes back. We can test this
        // without acquiring the request resource, since the flag is only set
        // (never reset).
        //

        if (1 == InterlockedCompareExchange(
                    (PLONG)&pRequest->SentResponse,
                    1,
                    0
                    ))
        {
            //
            // already sent a response.  bad.
            //

            Status = STATUS_INVALID_DEVICE_STATE;

            UlTrace(SEND_RESPONSE, (
                "ul!UlSendHttpResponseIoctl(pRequest = %p (%I64x)) %x\n"
                "        Tried to send a second response!\n",
                pRequest,
                pRequest->RequestId,
                Status
                ));

            goto end;
        }

        //
        // Also ensure that all previous calls to SendHttpResponse
        // and SendEntityBody had the MORE_DATA flag set.
        //

        if ((pSendInfo->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0)
        {
            //
            // Remember if the more data flag is not set.
            //

            if (1 == InterlockedCompareExchange(
                        (PLONG)&pRequest->SentLast,
                        1,
                        0
                        ))
            {
                Status = STATUS_INVALID_DEVICE_STATE;
                goto end;
            }
        }
        else
        if (pRequest->SentLast == 1)
        {
            Status = STATUS_INVALID_DEVICE_STATE;

            UlTrace(SEND_RESPONSE, (
                "ul!UlSendHttpResponseIoctl(pRequest = %p (%I64x)) %x\n"
                "        Tried to send again after last send!\n",
                pRequest,
                pRequest->RequestId,
                Status
                ));

            goto end;
        }

        //
        // OK, we have the connection. Now capture the incoming
        // HTTP_RESPONSE structure and map it to our internal
        // format.
        //

        if (pSendInfo->CachePolicy.Policy != HttpCachePolicyNocache)
        {
            CaptureCache = pRequest->CachePreconditions;
        }
        else
        {
            CaptureCache = FALSE;
        }

        //
        // Take the fast path if this is a single memory chunk that needs no
        // retransmission (<= 64k).
        //

        if (CaptureCache == FALSE
            && pSendInfo->EntityChunkCount == 1
            && pSendInfo->pEntityChunks->DataChunkType
                    == HttpDataChunkFromMemory
            && pSendInfo->pEntityChunks->FromMemory.BufferLength
                    <= MAX_BYTES_BUFFERED
            )
        {
            Status = UlpFastSendHttpResponse(
                            pSendInfo->pHttpResponse,
                            pSendInfo->pLogData,
                            pSendInfo->pEntityChunks,
                            1,
                            pSendInfo->Flags,
                            pRequest,
                            pIrp,
                            NULL
                            );

            goto end;
        }
        
        Status = UlCaptureHttpResponse(
                        pSendInfo->pHttpResponse,
                        pRequest,
                        pRequest->Version,
                        pRequest->Verb,
                        pSendInfo->EntityChunkCount,
                        pSendInfo->pEntityChunks,
                        UlCaptureNothing,
                        CaptureCache,
                        pSendInfo->pLogData,
                        &pResponse
                        );
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Save the captured response in the IRP so we can
    // dereference it after the IRP completes.
    //
    
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pResponse;
    
    //
    // Prepare the response (open files, etc).
    //

    Status = UlPrepareHttpResponse(
                    pRequest->Version,
                    pHttpResponse,
                    pResponse
                    );

    if (NT_SUCCESS(Status))
    {
        //
        // At this point, we'll definitely be initiating the
        // send. Go ahead and mark the IRP as pending, then
        // guarantee that we'll only return pending from
        // this point on.
        //
        
        IoMarkIrpPending( pIrp );

        pIrp->IoStatus.Status = STATUS_PENDING;
        
        //
        // Try capture to cache and send
        //

        if (CaptureCache)
        {
            Status = UlCacheAndSendResponse(
                            pRequest,
                            pResponse,
                            GET_APP_POOL_PROCESS( pIrpSp->FileObject ),
                            pSendInfo->Flags,
                            pSendInfo->CachePolicy,
                            &UlpRestartSendHttpResponse,
                            pIrp,
                            &ServedFromCache
                            );

            if (NT_SUCCESS(Status) && !ServedFromCache)
            {
                //
                // Send the non-cached response
                //

                Status = UlSendHttpResponse(
                                pRequest,
                                pResponse,
                                pSendInfo->Flags,
                                &UlpRestartSendHttpResponse,
                                pIrp
                                );
            }
        }
        else
        {
            //
            // Non-cacheable request/response, send response directly.
            //

            Status = UlSendHttpResponse(
                            pRequest,
                            pResponse,
                            pSendInfo->Flags,
                            &UlpRestartSendHttpResponse,
                            pIrp
                            );
        }
    }
    else
    {
        //
        // BUGBUG: Do custom error thang here.
        //
        NTSTATUS CloseStatus;

        pIrp->IoStatus.Status = Status;

        CloseStatus = UlCloseConnection(
                            pRequest->pHttpConn->pConnection,
                            TRUE,
                            &UlpRestartSendHttpResponse,
                            pIrp
                            );

        ASSERT( CloseStatus == STATUS_PENDING );

        ConnectionClosed = TRUE;

        // UlCloseConnection always returns STATUS_PENDING
        // but we want to return the a proper error code here.
        // E.G. If the supplied file - as filename data chunk -
        // not found we will return STATUS_OBJECT_NAME_INVALID
        // as its returned by UlPrepareHttpResponse.
    }

    // paulmcd: is this the right time to deref?
    //
    // DEREFERENCE_HTTP_CONNECTION( pHttpConnection );

    if (Status != STATUS_PENDING  &&  !ConnectionClosed)
    {
        //
        // UlSendHttpResponse either completed in-line
        // (extremely unlikely) or failed (much more
        // likely). Fake a completion to the completion
        // routine so that the IRP will get completed
        // properly, then map the return code to
        // STATUS_PENDING, since we've already marked
        // the IRP as such.
        //

        UlpRestartSendHttpResponse(
            pIrp,
            Status,
            0
            );

        Status = STATUS_PENDING;
    }

end:

    if (pRequest != NULL)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        pRequest = NULL;
    }

    //
    // Complete the request.
    //

    if (Status != STATUS_PENDING  &&  !ConnectionClosed)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlSendHttpResponseIoctl


/***************************************************************************++

Routine Description:

    This routine sends an HTTP entity body.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                        Status;
    PHTTP_SEND_HTTP_RESPONSE_INFO   pSendInfo;
    PUL_INTERNAL_RESPONSE           pResponse;
    ULONG                           Flags;
    PUL_INTERNAL_REQUEST            pRequest = NULL;
    BOOLEAN                         ConnectionClosed = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure this is really an app pool, not a control channel.
    //

    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not an app pool.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*pSendInfo))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    pSendInfo = (PHTTP_SEND_HTTP_RESPONSE_INFO)pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // Probe pSendInfo since we use NEITHER_IO.
    //

    __try
    {
        ProbeTestForRead(
            pSendInfo,
            sizeof(*pSendInfo),
            sizeof(PVOID)
            );
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        goto end;
    }


    UlTrace(SEND_RESPONSE, (
        "UL!UlSendEntityBodyIoctl - Flags = %X\n",
        pSendInfo->Flags
        ));

    //
    // Now get the request from the request id.
    // This gives us a reference to the request.
    //

    pRequest = UlGetRequestFromId(pSendInfo->RequestId);

    if (pRequest == NULL)
    {
        //
        // Couldn't map the HTTP_REQUEST_ID.
        //

        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));

    //
    // Ensure a response has already been sent. We can test this without
    // acquiring the request resource, since the flag is only set (never
    // reset).
    //

    if (pRequest->SentResponse == 0)
    {
        //
        // The application is sending entity without first having
        // send a response header. This is generally an error, however
        // we allow the application to override this by passing
        // the HTTP_SEND_RESPONSE_FLAG_RAW_HEADER flag.
        //

        if (pSendInfo->Flags & HTTP_SEND_RESPONSE_FLAG_RAW_HEADER)
        {
            UlTrace(SEND_RESPONSE, (
                "ul!UlSendEntityBodyIoctl(pRequest = %p (%I64x))\n"
                "        Intentionally sending raw header!\n",
                pRequest,
                pRequest->RequestId
                ));

            if (1 == InterlockedCompareExchange(
                        (PLONG)&pRequest->SentResponse,
                        1,
                        0
                        ))
            {
                Status = STATUS_INVALID_DEVICE_STATE;
                goto end;
            }
        }
        else
        {
            Status = STATUS_INVALID_DEVICE_STATE;

            UlTrace(SEND_RESPONSE, (
                "ul!UlSendEntityBodyIoctl(pRequest = %p (%I64x)) %x\n"
                "        No response yet!\n",
                pRequest,
                pRequest->RequestId,
                Status
                ));

            goto end;
        }
    }

    //
    // Also ensure that all previous calls to SendHttpResponse
    // and SendEntityBody had the MORE_DATA flag set.
    //

    if ((pSendInfo->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0)
    {
        //
        // Remember that this was the last send. We shouldn't
        // get any more data after this.
        //

        if (1 == InterlockedCompareExchange(
                    (PLONG)&pRequest->SentLast,
                    1,
                    0
                    ))
        {
            Status = STATUS_INVALID_DEVICE_STATE;
            goto end;
        }
    }
    else
    if (pRequest->SentLast == 1)
    {
        Status = STATUS_INVALID_DEVICE_STATE;

        UlTrace(SEND_RESPONSE, (
            "ul!UlSendEntityBodyIoctl(pRequest = %p (%I64x)) %x\n"
            "        Tried to send again after last send!\n",
            pRequest,
            pRequest->RequestId,
            Status
            ));

        goto end;
    }

    ASSERT(pSendInfo->pHttpResponse == NULL);

    __try
    {
        //
        // Take the fast path if this is a single memory chunk that needs no
        // retransmission (<= 64k).
        //

        if (pSendInfo->EntityChunkCount == 1
            && pSendInfo->pEntityChunks->DataChunkType
                    == HttpDataChunkFromMemory
            && pSendInfo->pEntityChunks->FromMemory.BufferLength
                    <= MAX_BYTES_BUFFERED
            )
        {
            Status = UlpFastSendHttpResponse(
                            NULL,
                            pSendInfo->pLogData,
                            pSendInfo->pEntityChunks,
                            1,
                            pSendInfo->Flags,
                            pRequest,
                            pIrp,
                            NULL
                            );
            
            goto end;
        }
        
        //
        // OK, we have the connection. Now capture the incoming
        // HTTP_RESPONSE structure and map it to our internal
        // format.
        //
        
        Status = UlCaptureHttpResponse(
                        NULL,
                        pRequest,
                        pRequest->Version,
                        pRequest->Verb,
                        pSendInfo->EntityChunkCount,
                        pSendInfo->pEntityChunks,
                        UlCaptureNothing,
                        FALSE,
                        pSendInfo->pLogData,
                        &pResponse
                        );
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Save the captured response in the IRP so we can
    // dereference it after the IRP completes.
    //
    
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pResponse;
        
    //
    // Prepare the response (open files, etc).
    //

    Status = UlPrepareHttpResponse(
                    pRequest->Version,
                    NULL,
                    pResponse
                    );

    if (NT_SUCCESS(Status))
    {
        //
        // At this point, we'll definitely be initiating the
        // send. Go ahead and mark the IRP as pending, then
        // guarantee that we'll only return pending from
        // this point on.
        //
        
        IoMarkIrpPending( pIrp );
        
        pIrp->IoStatus.Status = STATUS_PENDING;
        //
        // Send the response
        //

        Status = UlSendHttpResponse(
                        pRequest,
                        pResponse,
                        pSendInfo->Flags,
                        &UlpRestartSendHttpResponse,
                        pIrp
                        );
    }
    else
    {
        //
        // BUGBUG: Do custom error thang here.
        //

        NTSTATUS CloseStatus;

        pIrp->IoStatus.Status = Status;

        CloseStatus = UlCloseConnection(
                            pRequest->pHttpConn->pConnection,
                            TRUE,
                            &UlpRestartSendHttpResponse,
                            pIrp
                            );

        ASSERT( CloseStatus == STATUS_PENDING );

        ConnectionClosed = TRUE;
    }

    // paulmcd: is this the right time to deref?
    //
    // DEREFERENCE_HTTP_CONNECTION( pHttpConnection );

    if (Status != STATUS_PENDING  &&  !ConnectionClosed)
    {
        //
        // UlSendHttpResponse either completed in-line
        // (extremely unlikely) or failed (much more
        // likely). Fake a completion to the completion
        // routine so that the IRP will get completed
        // properly, then map the return code to
        // STATUS_PENDING, since we've already marked
        // the IRP as such.
        //

        UlpRestartSendHttpResponse(
            pIrp,
            Status,
            0
            );

        Status = STATUS_PENDING;
    }

end:

    if (pRequest != NULL)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        pRequest = NULL;
    }

    //
    // Complete the request.
    //

    if (Status != STATUS_PENDING  &&  !ConnectionClosed)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlSendEntityBodyIoctl

/***************************************************************************++

Routine Description:

    This routine flushes a URL or URL tree from the response cache.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFlushResponseCacheIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                        Status;
    PHTTP_FLUSH_RESPONSE_CACHE_INFO pInfo = NULL;

    //
    // sanity check.
    //

    PAGED_CODE();

    // better be an app pool
    //
    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        // 
        // Not an app pool.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    // Ensure the input buffer is large enough.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_FLUSH_RESPONSE_CACHE_INFO))
    {
        // bad buffer
        //
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    // Fetch out the input buffer
    //
    pInfo = (PHTTP_FLUSH_RESPONSE_CACHE_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    // does it look appropriate?
    //
    if (pInfo->FullyQualifiedUrl.MaximumLength < pInfo->FullyQualifiedUrl.Length ||
        pInfo->FullyQualifiedUrl.Length == 0 ||
        (pInfo->FullyQualifiedUrl.Length % sizeof(WCHAR)) != 0 ||
        pInfo->FullyQualifiedUrl.Buffer == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    // Going to access the url string from user mode memory
    //
    __try
    {
        // good memory?
        //
        ProbeTestForRead(pInfo->FullyQualifiedUrl.Buffer,
                         pInfo->FullyQualifiedUrl.Length + sizeof(WCHAR),
                         sizeof(WCHAR));

        // must be null terminated
        //
        if (pInfo->FullyQualifiedUrl.Buffer[pInfo->FullyQualifiedUrl.Length/sizeof(WCHAR)] != UNICODE_NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // check the flags
        //
        if (pInfo->Flags != (pInfo->Flags & HTTP_FLUSH_RESPONSE_FLAG_VALID)) {
            Status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // Call the internal worker func
        //

        UlFlushCacheByUri(
            pInfo->FullyQualifiedUrl.Buffer,
            pInfo->FullyQualifiedUrl.Length,
            pInfo->Flags,
            GET_APP_POOL_PROCESS( pIrpSp->FileObject )
            );

        Status = STATUS_SUCCESS;
        if (NT_SUCCESS(Status) == FALSE)
            __leave;

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

end:
    // complete the request.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlFlushResponseCacheIoctl

/***************************************************************************++

Routine Description:

    This routine waits for demand start notifications.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlWaitForDemandStartIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS            Status;

    //
    // sanity check.
    //

    PAGED_CODE();

    //
    // This had better be an app pool.
    //
    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not an app pool.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // make the call
    //

    UlTrace(IOCTL,
            ("UlWaitForDemandStartIoctl: pAppPoolProcess=%p, pIrp=%p\n",
             GET_APP_POOL_PROCESS(pIrpSp->FileObject),
             pIrp
             ));
            
    Status = UlWaitForDemandStart(
                    GET_APP_POOL_PROCESS(pIrpSp->FileObject),
                    pIrp
                    );

end:

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlWaitForDemandStartIoctl


/***************************************************************************++

Routine Description:

    This routine waits for the client to initiate a disconnect.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlWaitForDisconnectIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS status;
    PHTTP_WAIT_FOR_DISCONNECT_INFO pInfo;
    PUL_HTTP_CONNECTION pHttpConn;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // This had better be an app pool.
    //

    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not an app pool.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Validate the input buffer.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*pInfo))
    {
        status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    pInfo = (PHTTP_WAIT_FOR_DISCONNECT_INFO)pIrp->AssociatedIrp.SystemBuffer;

    //
    // Chase down the connection.
    //

    pHttpConn = UlGetConnectionFromId( pInfo->ConnectionId );

    if (!UL_IS_VALID_HTTP_CONNECTION(pHttpConn))
    {
        status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Do it.
    //

    status = UlWaitForDisconnect(
                    GET_APP_POOL_PROCESS(pIrpSp->FileObject),
                    pHttpConn,
                    pIrp
                    );

end:

    //
    // Complete the request?
    //

    if (status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( status );

}   // UlWaitForDisconnectIoctl


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Completion routine for UlSendHttpResponse().

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API. In this case, it's
        actually a pointer to the user's IRP.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

--***************************************************************************/
VOID
UlpRestartSendHttpResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    PUL_INTERNAL_RESPONSE pResponse;

    //
    // Snag the IRP from the completion context, fill in the completion
    // status, then complete the IRP.
    //

    pIrp = (PIRP)pCompletionContext;
    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    pResponse = (PUL_INTERNAL_RESPONSE)(
                    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer
                    );

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    UL_DEREFERENCE_INTERNAL_RESPONSE( pResponse );

    //
    // Only overwrite the status field if it hasn't already been set
    // to an error
    //

    if (NT_SUCCESS(pIrp->IoStatus.Status))
        pIrp->IoStatus.Status = Status;

    pIrp->IoStatus.Information = Information;

    UlCompleteRequest( pIrp, g_UlPriorityBoost );

}   // UlpRestartSendHttpResponse


/***************************************************************************++

Routine Description:

    This routine adds a new transient URL prefix.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAddTransientUrlIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_TRANSIENT_URL_INFO    pInfo = NULL;

    //
    // sanity check.
    //

    PAGED_CODE();

    // better be an application pool
    //
    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not an app pool.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    // Ensure the input buffer is large enough.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_TRANSIENT_URL_INFO))
    {
        // bad buffer
        //
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    // Fetch out the input buffer
    //
    pInfo = (PHTTP_TRANSIENT_URL_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    // does it look appropriate?
    //
    if (pInfo->FullyQualifiedUrl.MaximumLength < pInfo->FullyQualifiedUrl.Length ||
        pInfo->FullyQualifiedUrl.Length == 0 ||
        (pInfo->FullyQualifiedUrl.Length % sizeof(WCHAR)) != 0 ||
        pInfo->FullyQualifiedUrl.Buffer == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    // Going to access the url string from user mode memory
    //
    __try
    {
        // good memory?
        //
        ProbeTestForRead(pInfo->FullyQualifiedUrl.Buffer,
                         pInfo->FullyQualifiedUrl.Length + sizeof(WCHAR),
                         sizeof(WCHAR));

        // must be null terminated
        //
        if (pInfo->FullyQualifiedUrl.Buffer[pInfo->FullyQualifiedUrl.Length/sizeof(WCHAR)] != UNICODE_NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // CODEWORK: validate the incoming url.
        //

        // Call the internal worker func
        //
        Status = UlAddTransientUrl(
                        UlAppPoolObjectFromProcess(
                            GET_APP_POOL_PROCESS(pIrpSp->FileObject)
                            ),
                        &pInfo->FullyQualifiedUrl
                        );

        if (!NT_SUCCESS(Status))
            __leave;

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }


end:
    // complete the request.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );
}   // UlAddTransientUrlIoctl


/***************************************************************************++

Routine Description:

    This routine removes a transient URL prefix.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveTransientUrlIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_TRANSIENT_URL_INFO    pInfo = NULL;

    //
    // sanity check.
    //

    PAGED_CODE();

    // better be an application pool
    //
    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not an app pool.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    // Ensure the input buffer is large enough.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(HTTP_TRANSIENT_URL_INFO))
    {
        // bad buffer
        //
        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    // Fetch out the input buffer
    //
    pInfo = (PHTTP_TRANSIENT_URL_INFO)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pInfo != NULL);

    // does it look appropriate?
    //
    if (pInfo->FullyQualifiedUrl.MaximumLength < pInfo->FullyQualifiedUrl.Length ||
        pInfo->FullyQualifiedUrl.Length == 0 ||
        (pInfo->FullyQualifiedUrl.Length % sizeof(WCHAR)) != 0 ||
        pInfo->FullyQualifiedUrl.Buffer == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    // Going to access the url string from user mode memory
    //
    __try
    {
        // good memory?
        //
        ProbeTestForRead(pInfo->FullyQualifiedUrl.Buffer,
                         pInfo->FullyQualifiedUrl.Length + sizeof(WCHAR),
                         sizeof(WCHAR));

        // must be null terminated
        //
        if (pInfo->FullyQualifiedUrl.Buffer[pInfo->FullyQualifiedUrl.Length/sizeof(WCHAR)] != UNICODE_NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // CODEWORK: validate the incoming url.
        //

        // Call the internal worker func
        //
        Status = UlRemoveTransientUrl(
                        UlAppPoolObjectFromProcess(
                            GET_APP_POOL_PROCESS(pIrpSp->FileObject)
                            ),
                        &pInfo->FullyQualifiedUrl
                        );

        if (!NT_SUCCESS(Status))
            __leave;

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }


end:
    // complete the request.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );
}   // UlRemoveTransientUrlIoctl

/***************************************************************************++

Routine Description:

    This routine accepts a raw connection.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterAcceptIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS            Status;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // This had better be a filter channel.
    //
    if (!IS_FILTER_PROCESS(pIrpSp->FileObject))
    {
        //
        // Not a filter channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // make the call
    //

    Status = UlFilterAccept(
                    GET_FILTER_PROCESS(pIrpSp->FileObject),
                    pIrp
                    );

end:

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlFilterAcceptIoctl

/***************************************************************************++

Routine Description:

    This routine closes a raw connection.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterCloseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status;
    HTTP_RAW_CONNECTION_ID ConnectionId;
    PUX_FILTER_CONNECTION pConnection;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Set up locals so we know how to clean up on exit.
    //
    pConnection = NULL;

    //
    // This had better be a filter channel.
    //
    if (!IS_FILTER_PROCESS(pIrpSp->FileObject))
    {
        //
        // Not a filter channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ConnectionId))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Map the incoming connection ID to the corresponding
    // UX_FILTER_CONNECTION object.
    //

    ConnectionId = *((PHTTP_RAW_CONNECTION_ID)pIrp->AssociatedIrp.SystemBuffer);

    pConnection = UlGetRawConnectionFromId(ConnectionId);

    if (!pConnection)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }


    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // make the call
    //

    Status = UlFilterClose(
                    GET_FILTER_PROCESS(pIrpSp->FileObject),
                    pConnection,
                    pIrp
                    );

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlFilterCloseIoctl

/***************************************************************************++

Routine Description:

    This routine reads data from a raw connection.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterRawReadIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status;
    HTTP_RAW_CONNECTION_ID ConnectionId;
    PUX_FILTER_CONNECTION pConnection;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Set up locals so we know how to clean up on exit.
    //
    pConnection = NULL;

    //
    // This had better be a filter channel.
    //
    if (!IS_FILTER_PROCESS(pIrpSp->FileObject))
    {
        //
        // Not a filter channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ConnectionId))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Map the incoming connection ID to the corresponding
    // UX_FILTER_CONNECTION object.
    //

    ConnectionId = *((PHTTP_RAW_CONNECTION_ID)pIrp->AssociatedIrp.SystemBuffer);

    pConnection = UlGetRawConnectionFromId(ConnectionId);

    if (!pConnection)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }


    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // make the call
    //

    Status = UlFilterRawRead(
                    GET_FILTER_PROCESS(pIrpSp->FileObject),
                    pConnection,
                    pIrp
                    );

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlFilterRawReadIoctl

/***************************************************************************++

Routine Description:

    This routine writes data to a raw connection.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterRawWriteIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status;
    HTTP_RAW_CONNECTION_ID ConnectionId;
    PUX_FILTER_CONNECTION pConnection;
    BOOLEAN MarkedPending;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Set up locals so we know how to clean up on exit.
    //
    pConnection = NULL;
    MarkedPending = FALSE;

    //
    // This had better be a filter channel.
    //
    if (!IS_FILTER_PROCESS(pIrpSp->FileObject))
    {
        //
        // Not a filter channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ConnectionId))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Ensure that there's an output buffer.
    //
    if (!pIrp->MdlAddress)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Map the incoming connection ID to the corresponding
    // UX_FILTER_CONNECTION object.
    //

    ConnectionId = *((PHTTP_RAW_CONNECTION_ID)pIrp->AssociatedIrp.SystemBuffer);

    pConnection = UlGetRawConnectionFromId(ConnectionId);

    if (!pConnection)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }


    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // make the call
    //
    IoMarkIrpPending(pIrp);
    MarkedPending = TRUE;

    Status = UlFilterRawWrite(
                    GET_FILTER_PROCESS(pIrpSp->FileObject),
                    pConnection,
                    pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                    pIrp
                    );

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest( pIrp, g_UlPriorityBoost );

        if (MarkedPending)
        {
            //
            // Since we marked the IRP pending, we should return pending.
            //
            Status = STATUS_PENDING;
        }

    }
    else
    {
        //
        // If we're returning pending, the IRP better be marked pending.
        //
        ASSERT(MarkedPending);
    }

    RETURN( Status );

}   // UlFilterRawWriteIoctl

/***************************************************************************++

Routine Description:

    This routine reads data from an http application.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterAppReadIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status;
    HTTP_RAW_CONNECTION_ID ConnectionId;
    PUX_FILTER_CONNECTION pConnection;
    PHTTP_FILTER_BUFFER pFiltBuffer;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Set up locals so we know how to clean up on exit.
    //
    pConnection = NULL;

    //
    // This had better be a filter channel.
    //
    if (!IS_FILTER_PROCESS(pIrpSp->FileObject))
    {
        //
        // Not a filter channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(HTTP_FILTER_BUFFER))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Ensure the output buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(HTTP_FILTER_BUFFER))
    {
        //
        // Output buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Grab the filter buffer object.
    //

    pFiltBuffer = (PHTTP_FILTER_BUFFER) pIrp->AssociatedIrp.SystemBuffer;

    //
    // Map the incoming connection ID to the corresponding
    // UX_FILTER_CONNECTION object.
    //

    ConnectionId = pFiltBuffer->Reserved;

    pConnection = UlGetRawConnectionFromId(ConnectionId);

    if (!pConnection)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }


    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // make the call
    //

    Status = UlFilterAppRead(
                    GET_FILTER_PROCESS(pIrpSp->FileObject),
                    pConnection,
                    pIrp
                    );

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlFilterAppReadIoctl



/***************************************************************************++

Routine Description:

    This routine writes data to an http application.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterAppWriteIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status;
    HTTP_RAW_CONNECTION_ID ConnectionId;
    PUX_FILTER_CONNECTION pConnection;
    BOOLEAN MarkedPending;
    PHTTP_FILTER_BUFFER pFiltBuffer;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Set up locals so we know how to clean up on exit.
    //
    pConnection = NULL;
    MarkedPending = FALSE;

    //
    // This had better be a filter channel.
    //
    if (!IS_FILTER_PROCESS(pIrpSp->FileObject))
    {
        //
        // Not a filter channel.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(HTTP_FILTER_BUFFER))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Grab the filter buffer object.
    //

    pFiltBuffer = (PHTTP_FILTER_BUFFER) pIrp->AssociatedIrp.SystemBuffer;

    //
    // Map the incoming connection ID to the corresponding
    // UX_FILTER_CONNECTION object.
    //

    ConnectionId = pFiltBuffer->Reserved;

    pConnection = UlGetRawConnectionFromId(ConnectionId);

    if (!pConnection)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }


    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // make the call
    //
    IoMarkIrpPending(pIrp);
    MarkedPending = TRUE;

    Status = UlFilterAppWrite(
                    GET_FILTER_PROCESS(pIrpSp->FileObject),
                    pConnection,
                    pIrp
                    );

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest( pIrp, g_UlPriorityBoost );

        if (MarkedPending)
        {
            //
            // Since we marked the IRP pending, we should return pending.
            //
            Status = STATUS_PENDING;
        }

    }
    else
    {
        //
        // If we're returning pending, the IRP better be marked pending.
        //
        ASSERT(MarkedPending);
    }

    RETURN( Status );

}   // UlFilterAppWriteIoctl



/***************************************************************************++

Routine Description:

    This routine asks the SSL helper for a client certificate.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveClientCertIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status;
    PHTTP_FILTER_RECEIVE_CLIENT_CERT_INFO pReceiveCertInfo;
    HTTP_RAW_CONNECTION_ID ConnectionId;
    PUL_HTTP_CONNECTION pHttpConn;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Set up locals so we know how to clean up on exit.
    //
    pHttpConn = NULL;

    //
    // This had better be an app pool.
    //
    if (IS_APP_POOL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not an app pool.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Ensure the input buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(HTTP_FILTER_RECEIVE_CLIENT_CERT_INFO))
    {
        //
        // Input buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Ensure the output buffer is large enough.
    //

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(HTTP_SSL_CLIENT_CERT_INFO))
    {
        //
        // Output buffer too small.
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    //
    // Grab the cert receive object.
    //
    pReceiveCertInfo = (PHTTP_FILTER_RECEIVE_CLIENT_CERT_INFO)
                            pIrp->AssociatedIrp.SystemBuffer;

    //
    // Map the incoming connection ID to the corresponding
    // HTTP_CONNECTION object.
    //

    ConnectionId = pReceiveCertInfo->ConnectionId;

    pHttpConn = UlGetConnectionFromId(ConnectionId);

    if (!pHttpConn)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }


    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));

    //
    // make the call
    //

    Status = UlReceiveClientCert(
                    GET_APP_POOL_PROCESS(pIrpSp->FileObject),
                    &pHttpConn->pConnection->FilterInfo,
                    pReceiveCertInfo->Flags,
                    pIrp
                    );

end:
    if (pHttpConn)
    {
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);
    }

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );

}   // UlFilterReceiveClientCertIoctl


/***************************************************************************++

Routine Description:

    This routine returns the perfmon counter data for this driver

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetCountersIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status;
    PUL_CONTROL_CHANNEL     pControlChannel;
    ULONG                   Length;
    PVOID                   pMdlBuffer;
    PVOID                   pMdlVa;
    HTTP_COUNTER_GROUP      CounterGroup;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Set up locals so we know how to clean up on exit.
    //
    Status = STATUS_SUCCESS;
    Length = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // better be a control channel
    //

    if (IS_CONTROL_CHANNEL(pIrpSp->FileObject) == FALSE)
    {
        //
        // Not a control channel.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto End;
    }

    pControlChannel = GET_CONTROL_CHANNEL(pIrpSp->FileObject);
    if (IS_VALID_CONTROL_CHANNEL(pControlChannel) == FALSE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto End;
    }

    //
    // Find out which type of counters are requested
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(HTTP_COUNTER_GROUP))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto End;
    }

    CounterGroup = *((HTTP_COUNTER_GROUP *) pIrp->AssociatedIrp.SystemBuffer);

    // Crack IRP and get MDL contianing user's buffer
    // Crack MDL to get user's buffer

    __try
    {
        // if no outbut buffer pass down in the Irp
        // that means app is asking for the required
        // field length

        if (!pIrp->MdlAddress)
        {
            pMdlVa = NULL;
        }
        else
        {
            pMdlBuffer = MmGetSystemAddressForMdlSafe(
                pIrp->MdlAddress,
                LowPagePriority
                );

            if (pMdlBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;
            }

            // Also make sure that user buffer was good

            pMdlVa = MmGetMdlVirtualAddress(pIrp->MdlAddress);
            ProbeForWrite( pMdlVa,
                           Length,
                           sizeof(UCHAR) );
        }

        //
        // Call support function to gather apropriate counter blocks
        // and place in user's buffer.
        //

        if ( HttpCounterGroupGlobal == CounterGroup )
        {
            Status = UlGetGlobalCounters(
                        pMdlVa,
                        Length,
                        &Length
                        );
        }
        else if ( HttpCounterGroupSite == CounterGroup )
        {
            ULONG   Blocks;
            Status = UlGetSiteCounters(
                        pMdlVa,
                        Length,
                        &Length,
                        &Blocks
                        );
        }
        else
        {
            Status = STATUS_NOT_IMPLEMENTED;
            __leave;
        }

        if (!NT_SUCCESS(Status))
        {
            //
            // If not returning STATUS_SUCCESS,
            // IoStatus.Information *must* be 0.
            //
            pIrp->IoStatus.Information = 0;
            __leave;
        }
        else
        {
            pIrp->IoStatus.Information = (ULONG_PTR)Length;
        }

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        pIrp->IoStatus.Information = 0;
    }

 End:
    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;

        UlCompleteRequest( pIrp, g_UlPriorityBoost );
    }

    RETURN( Status );
} // UlGetCountersIoctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\irptrace.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    irptrace.cxx

Abstract:

    This module implements an IRP tracing facility.

Author:

    Keith Moore (keithmo)       10-Aug-1999

Revision History:

--*/


#include "precomp.h"


#if ENABLE_IRP_TRACE


/***************************************************************************++

Routine Description:

    Creates a new (empty) IRP trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateIrpTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
{
    return CreateTraceLog(
               IRP_TRACE_LOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(IRP_TRACE_LOG_ENTRY)
               );

}   // CreateIrpTraceLog


/***************************************************************************++

Routine Description:

    Destroys an IRP trace log buffer created with CreateIrpTraceLog().

Arguments:

    pLog - Supplies the IRP trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyIrpTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog );

}   // DestroyIrpTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified IRP trace log.

Arguments:

    pLog - Supplies the log to write to.

    Action - Supplies an action code for the new log entry.

    pIrp - Supplies the IRP for the log entry.

    pFileName - Supplies the filename of the routine writing the log entry.

    LineNumber - Supplies he line number of the routine writing the log
        entry.

--***************************************************************************/
VOID
WriteIrpTraceLog(
    IN PTRACE_LOG pLog,
    IN UCHAR Action,
    IN PIRP pIrp,
    IN PVOID pFileName,
    IN USHORT LineNumber
    )
{
    IRP_TRACE_LOG_ENTRY entry;
    USHORT irpSize;

    //
    // Initialize the entry.
    //

    RtlGetCallersAddress( &entry.pCaller, &entry.pCallersCaller );

    entry.Action = Action;
    entry.pIrp = pIrp;

    entry.pFileName = pFileName;
    entry.LineNumber = LineNumber;
    entry.Processor = (UCHAR)KeGetCurrentProcessorNumber();
    entry.pProcess = PsGetCurrentProcess();
    entry.pThread = PsGetCurrentThread();

#if ENABLE_IRP_CAPTURE
    irpSize = pIrp->Size;
    if (irpSize > sizeof(entry.CapturedIrp))
    {
        irpSize = sizeof(entry.CapturedIrp);
    }

    RtlCopyMemory( entry.CapturedIrp, pIrp, irpSize );
#endif

    //
    // Write it to the logs.
    //

    WriteTraceLog( pLog, &entry );

}   // WriteIrpTraceLog


#endif  // ENABLE_IRP_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\irptrace.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    irptrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging IRP problems. This module uses the generic TRACE_LOG
    facility in tracelog.h.

Author:

    Keith Moore (keithmo)       10-Aug-1999

Revision History:

--*/


#ifndef _IRPTRACE_H_
#define _IRPTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


//
// This defines the entry written to the trace log.
//

#define ENABLE_IRP_CAPTURE  1

#define MAX_CAPTURED_IRP_SIZE                                           \
    (sizeof(IRP) + (DEFAULT_IRP_STACK_SIZE * sizeof(IO_STACK_LOCATION)))

typedef struct _IRP_TRACE_LOG_ENTRY
{
    PIRP pIrp;
    PVOID pFileName;
    PEPROCESS pProcess;
    PETHREAD pThread;
    PVOID pCaller;
    PVOID pCallersCaller;
    USHORT LineNumber;
    UCHAR Action;
    UCHAR Processor;
#if ENABLE_IRP_CAPTURE
    ULONG CapturedIrp[MAX_CAPTURED_IRP_SIZE / sizeof(ULONG)];
#endif

} IRP_TRACE_LOG_ENTRY, *PIRP_TRACE_LOG_ENTRY;


//
// Action codes.
//
// N.B. These codes must be contiguous, starting at zero. If you update
//      this list, you must also update the corresponding array in
//      ul\ulkd\irp.c.
//

#define IRP_ACTION_INCOMING_IRP                     0
#define IRP_ACTION_ALLOCATE_IRP                     1
#define IRP_ACTION_FREE_IRP                         2
#define IRP_ACTION_CALL_DRIVER                      3
#define IRP_ACTION_COMPLETE_IRP                     4

#define IRP_ACTION_COUNT                            5

#define IRP_TRACE_LOG_SIGNATURE   ((LONG)'gLrI')

//
// Manipulators.
//

PTRACE_LOG
CreateIrpTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyIrpTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
WriteIrpTraceLog(
    IN PTRACE_LOG pLog,
    IN UCHAR Action,
    IN PIRP pIrp,
    IN PVOID pFileName,
    IN USHORT LineNumber
    );


#if ENABLE_IRP_TRACE

#define CREATE_IRP_TRACE_LOG( ptr, size, extra )                            \
    (ptr) = CreateIrpTraceLog( (size), (extra) )

#define DESTROY_IRP_TRACE_LOG( ptr )                                        \
    do                                                                      \
    {                                                                       \
        DestroyIrpTraceLog( ptr );                                          \
        (ptr) = NULL;                                                       \
    } while (FALSE)

#define WRITE_IRP_TRACE_LOG( plog, act, pirp, pfile, line )                 \
    WriteIrpTraceLog(                                                       \
        (plog),                                                             \
        (act),                                                              \
        (pirp),                                                             \
        (pfile),                                                            \
        (line)                                                              \
        )

#else   // !ENABLE_IRP_TRACE

#define CREATE_IRP_TRACE_LOG( ptr, size, extra )
#define DESTROY_IRP_TRACE_LOG( ptr )
#define WRITE_IRP_TRACE_LOG( plog, act, ref, pfile, line )

#endif  // ENABLE_IRP_TRACE

#define TRACE_IRP( act, pirp )                                              \
    WRITE_IRP_TRACE_LOG(                                                    \
        g_pIrpTraceLog,                                                     \
        (act),                                                              \
        (pirp),                                                             \
        (PVOID)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _IRPTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\largemem.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    largemem.cxx

Abstract:

    The implementation of large memory allocator interfaces.

Author:

    George V. Reilly (GeorgeRe)    10-Nov-2000

Revision History:

--*/

#include "precomp.h"
#include "largemem.h"

#define LOWEST_USABLE_PHYSICAL_ADDRESS    (16 * 1024 * 1024)

// Periodically snapshot some perf counters so that we can tune
// memory consumption
typedef struct _PERF_SNAPSHOT
{
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;   // for perf counter deltas
    LARGE_INTEGER   PerfInfoTime;   // to calculate rates
    ULONG           AvailMemMB;     // Currently available memory, in MB
} PERF_SNAPSHOT, *PPERF_SNAPSHOT;

#define DEFAULT_TUNING_PERIOD 60 // seconds


//
// Globals
//

LONG           g_LargeMemInitialized;
ULONG          g_TotalPhysicalMemMB;        // total physical memory (MB)
LONG           g_LargeMemMegabytes;         // how many MB to use for allocs
ULONG          g_LargeMemPagesHardLimit;    //  "   "  pages   "   "    "
volatile ULONG g_LargeMemPagesMaxLimit;     //  "   "  pages   "   "    "
volatile ULONG g_LargeMemPagesCurrent;      // #pages currently used
volatile ULONG g_LargeMemPagesMaxEverUsed;  // max #pages ever used


//
// Periodic memory tuner
//

UL_SPIN_LOCK   g_LargeMemUsageSpinLock;
KDPC           g_LargeMemUsageDpc;
KTIMER         g_LargeMemUsageTimer;
KEVENT         g_LargeMemUsageTerminationEvent;
UL_WORK_ITEM   g_LargeMemUsageWorkItem;
PERF_SNAPSHOT  g_LargeMemPerfSnapshot;      // previous value, for deltas

#ifdef __cplusplus

extern "C" {
#endif // __cplusplus

//
// Private prototypes.
//

NTSTATUS
UlpReadPerfSnapshot(
    OUT PPERF_SNAPSHOT pPerfSnapshot);

VOID
UlpLargeMemTuneUsageWorker(
    IN PUL_WORK_ITEM pWorkItem);



#ifdef __cplusplus

}; // extern "C"
#endif // __cplusplus


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlLargeMemInitialize )
#pragma alloc_text( PAGE, UlpReadPerfSnapshot )
#pragma alloc_text( PAGE, UlpLargeMemTuneUsageWorker )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlLargeMemTerminate
NOT PAGEABLE -- UlpSetLargeMemTuneUsageTimer
NOT PAGEABLE -- UlpLargeMemTuneUsageDpcRoutine
NOT PAGEABLE -- UlLargeMemUsagePercentage
#endif



/***************************************************************************++

Routine Description:

    Read a snapshot of some system performance counters. Used by
    periodic memory usage tuner

Arguments:

    pPerfSnapshot - where to place the snapshot

--***************************************************************************/
NTSTATUS
UlpReadPerfSnapshot(
    OUT PPERF_SNAPSHOT pPerfSnapshot)
{
    NTSTATUS Status;

    ASSERT(NULL != pPerfSnapshot);

    // NtQuerySystemInformation must be called at passive level
    PAGED_CODE();

    Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &pPerfSnapshot->PerfInfo,
                    sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                    NULL);
    ASSERT(NT_SUCCESS(Status));

    if (NT_SUCCESS(Status))
    {
        KeQuerySystemTime(&pPerfSnapshot->PerfInfoTime);

        pPerfSnapshot->AvailMemMB =
            PAGES_TO_MEGABYTES(pPerfSnapshot->PerfInfo.AvailablePages);
    }

    return Status;
} // UlpReadPerfSnapshot



/***************************************************************************++

Routine Description:

    Set the timer for memory tuning

Arguments:

    TunePeriod - interval until next tuner (in seconds)

--***************************************************************************/
VOID
UlpSetLargeMemTuneUsageTimer(
    IN UINT TunePeriod
    )
{
    LARGE_INTEGER Interval;
    KIRQL oldIrql;

    UlAcquireSpinLock(&g_LargeMemUsageSpinLock, &oldIrql);

    UlTrace(LARGE_MEM, (
                "Http!UlpSetLargeMemTuneUsageTimer: %d seconds\n",
                TunePeriod
                ));

    //
    // Don't want to execute this more often than every couple of seconds.
    // In particular, do not want to execute this every 0 seconds, as the
    // machine will become completely unresponsive.
    //

    TunePeriod = max(TunePeriod, 2);

    //
    // convert seconds to 100 nanosecond intervals (x * 10^7)
    // negative numbers mean relative time
    //

    Interval.QuadPart = TunePeriod * -C_NS_TICKS_PER_SEC;

    UlTrace(LARGE_MEM, (
                "Http!UlpSetLargeMemTuneUsageTimer: "
                "%d seconds = %I64d 100ns ticks\n",
                TunePeriod, Interval.QuadPart
                ));

    if (g_LargeMemInitialized)
    {
        KeSetTimer(
            &g_LargeMemUsageTimer,
            Interval,
            &g_LargeMemUsageDpc
            );
    }
    else
    {
        // Shutdown may have started between the time the timer DPC was
        // called, queuing UlpLargeMemTuneUsageWorker, and the time this
        // routine was actually started, so set the event and quit immediately.
        KeSetEvent(
            &g_LargeMemUsageTerminationEvent,
            0,
            FALSE
            );
    }


    UlReleaseSpinLock(&g_LargeMemUsageSpinLock, oldIrql);

} // UlpSetLargeMemTuneUsageTimer



/***************************************************************************++

Routine Description:

    Periodically adjust g_LargeMemPagesMaxLimit in response to
    memory pressure. Called at passive level.

Arguments:

    pWorkItem - ignored

--***************************************************************************/
VOID
UlpLargeMemTuneUsageWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PERF_SNAPSHOT PerfSnapshot;
    UINT TunePeriod = DEFAULT_TUNING_PERIOD;
    ULONG PagesLimit = g_LargeMemPagesMaxLimit;

    PAGED_CODE();

    if (! g_LargeMemInitialized)
    {
        // Shutdown may have started between the time the timer DPC was
        // called, queuing this routine, and the time this routine was
        // actually started, so set the event and quit immediately.
        KeSetEvent(
            &g_LargeMemUsageTerminationEvent,
            0,
            FALSE
            );

        return;
    }

    NTSTATUS Status = UlpReadPerfSnapshot(&PerfSnapshot);

    ASSERT(NT_SUCCESS(Status));

    if (NT_SUCCESS(Status))
    {
#if 0
        // Needed for rate calculations
        LONGLONG DeltaT = (PerfSnapshot.PerfInfoTime.QuadPart
                           - g_LargeMemPerfSnapshot.PerfInfoTime.QuadPart);

        // DeltaT can be negative if the system clock has moved backwards;
        // e.g., synchronizing with the domain controller.
        // Disable for now, since it's currently unused and we're hitting
        // this assertion.
        ASSERT(DeltaT > 0);
        DeltaT /= C_NS_TICKS_PER_SEC; // convert to seconds

        // CODEWORK: look at other metrics, such as pagefault rate:
        // (PerfSnapshot.PageFaultCount - g_PerfInfo.PageFaultCount) / DeltaT
#endif

        //
        // Adjust g_LargeMemPagesMaxLimit
        //

        // Is available memory really low?
        if (PerfSnapshot.AvailMemMB <= 8 /* megabytes */)
        {
            // reduce by one-eighth, but don't let go below 4MB
            PagesLimit -= PagesLimit / 8;
            PagesLimit =  max(PagesLimit, MEGABYTES_TO_PAGES(4));

            TunePeriod /= 4;   // reschedule quickly

            UlTrace(LARGE_MEM,
                    ("Http!UlpLargeMemTuneUsageWorker: "
                     "avail mem=%dMB, total=%dMB: "
                     "reducing from %d pages (%dMB) to %d pages (%dMB)\n",
                     PerfSnapshot.AvailMemMB, g_TotalPhysicalMemMB,
                     g_LargeMemPagesMaxLimit,
                     PAGES_TO_MEGABYTES(g_LargeMemPagesMaxLimit),
                     PagesLimit,
                     PAGES_TO_MEGABYTES(PagesLimit)
                     ));
        }

        // is at least one-quarter of physical memory available?
        else if (PerfSnapshot.AvailMemMB >= (g_TotalPhysicalMemMB >> 2))
        {
            // raise the limit by one-eighth; clamp at g_LargeMemPagesHardLimit
            PagesLimit += PagesLimit / 8;
            PagesLimit =  min(PagesLimit, g_LargeMemPagesHardLimit);

            UlTrace(LARGE_MEM,
                    ("Http!UlpLargeMemTuneUsageWorker: "
                     "avail mem=%dMB, total=%dMB: "
                     "increasing from %d pages (%dMB) to %d pages (%dMB)\n",
                     PerfSnapshot.AvailMemMB, g_TotalPhysicalMemMB,
                     g_LargeMemPagesMaxLimit,
                     PAGES_TO_MEGABYTES(g_LargeMemPagesMaxLimit),
                     PagesLimit,
                     PAGES_TO_MEGABYTES(PagesLimit)
                     ));
        }

        g_LargeMemPagesMaxLimit = PagesLimit;

        UlTrace(LARGE_MEM,
                ("Http!UlpLargeMemTuneUsageWorker: "
                 "%d%% of cache memory used: "
                 "%d pages (%dMB) / %d pages (%dMB)\n",
                 UlLargeMemUsagePercentage(),
                 g_LargeMemPagesCurrent,
                 PAGES_TO_MEGABYTES(g_LargeMemPagesCurrent),
                 g_LargeMemPagesMaxLimit,
                 PAGES_TO_MEGABYTES(g_LargeMemPagesMaxLimit)
                 ));

        // save g_LargeMemPerfSnapshot for next round
        g_LargeMemPerfSnapshot = PerfSnapshot;
    }

    // Restart the timer.
    UlpSetLargeMemTuneUsageTimer(TunePeriod);

} // UlpLargeMemTuneUsageWorker



/***************************************************************************++

Routine Description:

    Timer callback to do memory tuning

Arguments:

    ignored

--***************************************************************************/
VOID
UlpLargeMemTuneUsageDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    UlAcquireSpinLockAtDpcLevel(&g_LargeMemUsageSpinLock);

    if (! g_LargeMemInitialized)
    {
        // We're shutting down, so signal the termination event.

        KeSetEvent(
            &g_LargeMemUsageTerminationEvent,
            0,
            FALSE
            );
    }
    else
    {
        // Do the work at passive level

        UL_QUEUE_WORK_ITEM(
            &g_LargeMemUsageWorkItem,
            &UlpLargeMemTuneUsageWorker
            );
    }

    UlReleaseSpinLockFromDpcLevel(&g_LargeMemUsageSpinLock);

} // UlpLargeMemTuneUsageDpcRoutine



/***************************************************************************++

Routine Description:

    Initialize global state for LargeMem

Arguments:

    pConfig - default configuration from registry

--***************************************************************************/
NTSTATUS
UlLargeMemInitialize(
    IN PUL_CONFIG pConfig
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    g_LargeMemMegabytes        = 0;
    g_LargeMemPagesHardLimit   = 0;
    g_LargeMemPagesMaxLimit    = 0;
    g_LargeMemPagesCurrent     = 0;
    g_LargeMemPagesMaxEverUsed = 0;

    UlpReadPerfSnapshot(&g_LargeMemPerfSnapshot);

    g_LargeMemMegabytes = pConfig->LargeMemMegabytes;

    SYSTEM_BASIC_INFORMATION sbi;

    Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &sbi,
                    sizeof(sbi),
                    NULL);
    ASSERT(NT_SUCCESS(Status));

    // Capture total physical memory
    g_TotalPhysicalMemMB = PAGES_TO_MEGABYTES(sbi.NumberOfPhysicalPages);

    if (DEFAULT_LARGE_MEM_MEGABYTES == g_LargeMemMegabytes)
    {
        if (g_TotalPhysicalMemMB <= 256)
        {
            // <=256MB: set to quarter of physical memory
            g_LargeMemMegabytes = (g_TotalPhysicalMemMB >> 2);
        }
        else if (g_TotalPhysicalMemMB <= 512)
        {
            // 256-512MB: set to half of physical memory
            g_LargeMemMegabytes = (g_TotalPhysicalMemMB >> 1);
        }
        else if (g_TotalPhysicalMemMB <= 2048)
        {
            // 512MB-2GB: set to three-quarters of physical memory
            g_LargeMemMegabytes =
                g_TotalPhysicalMemMB - (g_TotalPhysicalMemMB >> 2);
        }
        else
        {
            //  >2GB: set to seven-eighths of physical memory
            g_LargeMemMegabytes =
                g_TotalPhysicalMemMB - (g_TotalPhysicalMemMB >> 3);
        }
    }

    // Should we clamp this now?
    g_LargeMemMegabytes = min(g_LargeMemMegabytes,
                              (LONG)(g_LargeMemPerfSnapshot.AvailMemMB));

    // We will use at most this many pages of memory
    g_LargeMemPagesHardLimit = MEGABYTES_TO_PAGES(g_LargeMemMegabytes);

    // g_LargeMemPagesMaxLimit is adjusted in response to memory pressure
    g_LargeMemPagesMaxLimit  = g_LargeMemPagesHardLimit;

    UlTraceVerbose(LARGE_MEM,
            ("Http!UlLargeMemInitialize: "
             "g_TotalPhysicalMemMB=%dMB, "
             "AvailMem=%dMB\n"
             "\tg_LargeMemMegabytes=%dMB, g_LargeMemPagesHardLimit=%d.\n",
             g_TotalPhysicalMemMB, g_LargeMemPerfSnapshot.AvailMemMB,
             g_LargeMemMegabytes, g_LargeMemPagesHardLimit));

    UlInitializeSpinLock(&g_LargeMemUsageSpinLock, "g_LargeMemUsageSpinLock");

    KeInitializeDpc(
        &g_LargeMemUsageDpc,
        &UlpLargeMemTuneUsageDpcRoutine,
        NULL
        );

    KeInitializeTimer(&g_LargeMemUsageTimer);

    KeInitializeEvent(
        &g_LargeMemUsageTerminationEvent,
        NotificationEvent,
        FALSE
        );

    g_LargeMemInitialized = TRUE;

    UlpSetLargeMemTuneUsageTimer(DEFAULT_TUNING_PERIOD);

    return Status;
} // UlLargeMemInitialize



/***************************************************************************++

Routine Description:

    Cleanup global state for LargeMem

--***************************************************************************/
VOID
UlLargeMemTerminate(
    VOID
    )
{
    PAGED_CODE();

    ASSERT(0 == g_LargeMemPagesCurrent);

    if (g_LargeMemInitialized)
    {
        //
        // Clear the "initialized" flag. If the memory tuner runs soon,
        // it will see this flag, set the termination event, and exit
        // quickly.
        //
        KIRQL oldIrql;

        UlAcquireSpinLock(&g_LargeMemUsageSpinLock, &oldIrql);
        g_LargeMemInitialized = FALSE;
        UlReleaseSpinLock(&g_LargeMemUsageSpinLock, oldIrql);

        //
        // Cancel the memory tuner timer. If the cancel fails, then the
        // memory tuner is either running or scheduled to run soon. In
        // either case, wait for it to terminate.
        //

        if (! KeCancelTimer(&g_LargeMemUsageTimer))
        {
            KeWaitForSingleObject(
                &g_LargeMemUsageTerminationEvent,
                UserRequest,
                KernelMode,
                FALSE,
                NULL
                );
        }
    }

    UlTraceVerbose(LARGE_MEM,
            ("Http!UlLargeMemTerminate: Memory used: "
             "Current = %d pages = %dMB; MaxEver = %d pages = %dMB.\n",
             g_LargeMemPagesCurrent,
             PAGES_TO_MEGABYTES(g_LargeMemPagesCurrent),
             g_LargeMemPagesMaxEverUsed,
             PAGES_TO_MEGABYTES(g_LargeMemPagesMaxEverUsed)
             ));
} // UlLargeMemTerminate



/***************************************************************************++

Routine Description:

    Return the percentage of available cache memory that is in use.

Return Value:

    0 < result <= 95:   okay
    95 < result <= 100: free up some memory soon
    > 100:              free up some memory immediately

--***************************************************************************/
UINT
UlLargeMemUsagePercentage(
    VOID
    )
{
    UINT Percentage = (UINT)((((ULONGLONG) g_LargeMemPagesCurrent * 100)
                            / g_LargeMemPagesMaxLimit));

    return Percentage;
} // UlLargeMemUsagePercentage



/***************************************************************************++

Routine Description:

    Allocate a MDL from PAE memory

--***************************************************************************/
PMDL
UlLargeMemAllocate(
    IN ULONG Length,
    OUT PBOOLEAN pLongTermCacheable
    )
{
    PMDL pMdl;

    // CODEWORK: cap the size of individual allocations

    LONG RoundUpBytes = (LONG) ROUND_TO_PAGES(Length);
    LONG NewPages = RoundUpBytes >> PAGE_SHIFT;

    if (g_LargeMemPagesCurrent + NewPages > g_LargeMemPagesMaxLimit)
    {
        UlTrace(LARGE_MEM,
                ("http!UlLargeMemAllocate: about to overshoot "
                 "g_LargeMemPagesMaxLimit=%d pages. Not allocating %d pages\n",
                 g_LargeMemPagesMaxLimit, NewPages
                 ));
    }

    PHYSICAL_ADDRESS LowAddress, HighAddress, SkipBytes;

    LowAddress.QuadPart  = LOWEST_USABLE_PHYSICAL_ADDRESS;
    HighAddress.QuadPart = 0xfffffffff; // 64GB
    SkipBytes.QuadPart   = 0;

    pMdl = MmAllocatePagesForMdl(
                LowAddress,
                HighAddress,
                SkipBytes,
                RoundUpBytes
                );

    // Completely failed to allocate memory
    if (pMdl == NULL)
    {
        UlTrace(LARGE_MEM,
                ("http!UlLargeMemAllocate: "
                 "Completely failed to allocate %d bytes.\n",
                 RoundUpBytes
                ));

        return NULL;
    }

    // Couldn't allocate all the memory we asked for. We need all the pages
    // we asked for, so we have to set the state of `this' to invalid.
    // Memory is probably really tight.
    if (MmGetMdlByteCount(pMdl) < Length)
    {
        UlTrace(LARGE_MEM,
                ("http!UlLargeMemAllocate: Failed to allocate %d bytes. "
                 "Got %d instead.\n",
                 RoundUpBytes, MmGetMdlByteCount(pMdl)
                ));

        // Free MDL but don't adjust g_LargeMemPagesCurrent downwards
        MmFreePagesFromMdl(pMdl);
        ExFreePool(pMdl);

        return NULL;
    }

    UlTrace(LARGE_MEM,
            ("http!UlLargeMemAllocate: %u->%u, mdl=%p, %d pages.\n",
             Length, pMdl->ByteCount, pMdl, NewPages
            ));

    LONG PrevPagesUsed =
        InterlockedExchangeAdd((PLONG) &g_LargeMemPagesCurrent, NewPages);

    if (PrevPagesUsed + NewPages > (LONG)g_LargeMemPagesMaxLimit)
    {
        // overshot g_LargeMemPagesMaxLimit
        UlTrace(LARGE_MEM,
                ("http!UlLargeMemAllocate: "
                 "overshot g_LargeMemPagesMaxLimit=%d pages. "
                 "Releasing %d pages\n",
                 g_LargeMemPagesMaxLimit, NewPages
                 ));

        // Don't free up memory. Return the allocated memory to the
        // caller, who is responsible for checking to see if it can be
        // cached for long-term usage, or if it should be freed ASAP.

        // CODEWORK: This implies that the MRU entries in the cache will
        // be not be cached, which probably leads to poor cache locality.
        // Really ought to free up some LRU cache entries instead.

        *pLongTermCacheable = FALSE;
    }
    else
    {
        *pLongTermCacheable = TRUE;
    }

    ASSERT(pMdl->MdlFlags & MDL_PAGES_LOCKED);

    // Hurrah! a successful allocation
    //
    // update g_LargeMemPagesMaxEverUsed in a threadsafe manner
    // using interlocked instructions

    LONG NewMaxUsed;

    do
    {
        LONG CurrentPages = g_LargeMemPagesCurrent;
        LONG MaxEver      = g_LargeMemPagesMaxEverUsed;

        NewMaxUsed = max(MaxEver, CurrentPages);

        if (NewMaxUsed > MaxEver)
        {
            InterlockedCompareExchange(
                (PLONG) &g_LargeMemPagesMaxEverUsed,
                NewMaxUsed,
                MaxEver
                );
        }
    } while (NewMaxUsed < (LONG)g_LargeMemPagesCurrent);

    UlTrace(LARGE_MEM,
            ("http!UlLargeMemAllocate: "
             "g_LargeMemPagesCurrent=%d pages. "
             "g_LargeMemPagesMaxEverUsed=%d pages.\n",
             g_LargeMemPagesCurrent, NewMaxUsed
             ));

    WRITE_REF_TRACE_LOG(
        g_pMdlTraceLog,
            REF_ACTION_ALLOCATE_MDL,
        PtrToLong(pMdl->Next),      // bugbug64
        pMdl,
        __FILE__,
        __LINE__
        );

    return pMdl;
} // UlLargeMemAllocate



/***************************************************************************++

Routine Description:

    Free a MDL to PAE memory

--***************************************************************************/
VOID
UlLargeMemFree(
    IN PMDL pMdl
    )
{
    LONG Pages;
    LONG PrevPagesUsed;

    ASSERT(ROUND_TO_PAGES(pMdl->ByteCount) == pMdl->ByteCount);

    Pages = pMdl->ByteCount >> PAGE_SHIFT;

    MmFreePagesFromMdl(pMdl);
    ExFreePool(pMdl);

    PrevPagesUsed
        = InterlockedExchangeAdd(
                    (PLONG) &g_LargeMemPagesCurrent,
                    - Pages);

    ASSERT(PrevPagesUsed >= Pages);
} // UlLargeMemFree



/***************************************************************************++

Routine Description:

    Copy a buffer to the specified MDL starting from Offset.

--***************************************************************************/
BOOLEAN
UlLargeMemSetData(
    IN PMDL pMdl,
    IN PUCHAR pBuffer,
    IN ULONG Length,
    IN ULONG Offset
    )
{
    PUCHAR pSysAddr;
    BOOLEAN Result;

    ASSERT(Offset <= pMdl->ByteCount);
    ASSERT(Length <= (pMdl->ByteCount - Offset));
    ASSERT(pMdl->MdlFlags & MDL_PAGES_LOCKED);

    pSysAddr = (PUCHAR) MmMapLockedPagesSpecifyCache (
                            pMdl,               // MemoryDescriptorList,
                            KernelMode,         // AccessMode,
                            MmCached,           // CacheType,
                            NULL,               // BaseAddress,
                            FALSE,              // BugCheckOnFailure,
                            NormalPagePriority  // Priority
                            );

    if (pSysAddr != NULL)
    {
        RtlCopyMemory(
            pSysAddr + Offset,
            pBuffer,
            Length
            );

        MmUnmapLockedPages(pSysAddr, pMdl);
        return TRUE;
    }

    return FALSE;
} // UlLargeMemSetData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\largemem.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    largemem.h

Abstract:

    The public definition of large memory allocator interfaces.

Author:

    George V. Reilly (GeorgeRe)    10-Nov-2000

Revision History:

--*/

#ifndef _LARGEMEM_H_
#define _LARGEMEM_H_

#ifdef __cplusplus
extern "C" {
#endif


NTSTATUS
UlLargeMemInitialize(
    IN PUL_CONFIG pConfig
    );

VOID
UlLargeMemTerminate(
    VOID
    );

UINT
UlLargeMemUsagePercentage(
    VOID
    );

PMDL
UlLargeMemAllocate(
    IN ULONG Length,
    OUT PBOOLEAN pLongTermCacheable
    );

VOID
UlLargeMemFree(
    IN PMDL pMdl
    );

BOOLEAN
UlLargeMemSetData(
    IN PMDL pMdl,
    IN PUCHAR pBuffer,
    IN ULONG Length,
    IN ULONG Offset
    );


// 2^20 = 1MB
#define MEGABYTE_SHIFT 20
C_ASSERT(PAGE_SHIFT < MEGABYTE_SHIFT);

#define PAGES_TO_MEGABYTES(P)  ((P) >> (MEGABYTE_SHIFT - PAGE_SHIFT))
#define MEGABYTES_TO_PAGES(M)  ((M) << (MEGABYTE_SHIFT - PAGE_SHIFT))


#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

#endif // _LARGEMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\mdlutil.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    mdlutil.h

Abstract:

    This module contains general MDL utilities.

Author:

    Keith Moore (keithmo)       25-Aug-1998

Revision History:

--*/


#ifndef _MDLUTIL_H_
#define _MDLUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif


ULONG
UlGetMdlChainByteCount(
    IN PMDL pMdlChain
    );

PMDL
UlCloneMdl(
    IN PMDL pMdl
    );

PMDL
UlFindLastMdlInChain(
    IN PMDL pMdlChain
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _MDLUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\mdlutil.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    mdlutil.cxx

Abstract:

    This module implements general MDL utilities.

Author:

    Keith Moore (keithmo)       25-Aug-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlGetMdlChainByteCount
NOT PAGEABLE -- UlCloneMdl
NOT PAGEABLE -- UlFindLastMdlInChain
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Calculates the total byte length of the specified MDL chain.

Arguments:

    pMdlChain - Supplies the head of the MDL chain to scan.

Return Value:

    ULONG_PTR - The total byte length of the chain.

--***************************************************************************/
ULONG
UlGetMdlChainByteCount(
    IN PMDL pMdlChain
    )
{
    ULONG totalLength;

    //
    // Simply scan through the MDL chain and sum the lengths.
    //

    totalLength = 0;

    do
    {
        totalLength += (ULONG)MmGetMdlByteCount( pMdlChain );
        pMdlChain = pMdlChain->Next;

    } while (pMdlChain != NULL);

    return totalLength;

}   // UlGetMdlChainByteCount


/***************************************************************************++

Routine Description:

    Clones the specified MDL, resulting in a new MDL that describes
    the exact same memory (pages, etc) as the original MDL.

Arguments:

    pMdl - Supplies the MDL to clone.

Return Value:

    PMDL - The newly cloned MDL if successful, NULL otherwise.

--***************************************************************************/
PMDL
UlCloneMdl(
    IN PMDL pMdl
    )
{
    PMDL pMdlClone;
    ULONG mdlLength;
    PVOID pMdlAddress;

    //
    // Ensure the incoming MDL is of the type we expect (either nonpaged
    // or already mapped into system space).
    //

    ASSERT( (pMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |
                    MDL_SOURCE_IS_NONPAGED_POOL)) != 0);

    //
    // Snag the length & virtual address from the MDL.
    //

    mdlLength = MmGetMdlByteCount( pMdl );
    ASSERT( mdlLength > 0 );

    pMdlAddress = MmGetMdlVirtualAddress( pMdl );
    ASSERT( pMdlAddress != NULL );

    //
    // Allocate a new MDL, then initialize it with the incoming MDL.
    //

    pMdlClone = UlAllocateMdl(
                    pMdlAddress,            // VirtualAddress
                    mdlLength,              // Length
                    FALSE,                  // SecondaryBuffer
                    FALSE,                  // ChargeQuota
                    NULL                    // Irp
                    );

    if (pMdlClone != NULL)
    {
        IoBuildPartialMdl(
            pMdl,                           // SourceMdl
            pMdlClone,                      // TargetMdl
            pMdlAddress,                    // VirtualAddress
            mdlLength                       // Length
            );
    }

    return pMdlClone;

}   // UlCloneMdl


/***************************************************************************++

Routine Description:

    Finds the last MDL in the specified MDL chain.

Arguments:

    pMdlChain - Supplies the MDL chain to scan.

Return Value:

    PMDL - Pointer to the last MDL in the MDL chain.

--***************************************************************************/
PMDL
UlFindLastMdlInChain(
    IN PMDL pMdlChain
    )
{
    while (pMdlChain->Next != NULL)
    {
        pMdlChain = pMdlChain->Next;
    }

    return pMdlChain;

}   // UlFindLastMdlInChain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\misc.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    misc.h

Abstract:

    This module contains miscellaneous constants & declarations.

Author:

    Keith Moore (keithmo)       10-Jun-1998
    Henry Sanders (henrysa)     17-Jun-1998 Merge with old httputil.h
    Paul McDaniel (paulmcd)     30-Mar-1999 added refcounted eresource

Revision History:

--*/



#ifndef _MISC_H_
#define _MISC_H_

#ifdef __cplusplus
extern "C" {
#endif


extern  ULONG   HttpChars[256];
extern  USHORT  FastPopChars[256];
extern  USHORT  DummyPopChars[256];

#define HTTP_CHAR           0x001
#define HTTP_UPCASE         0x002
#define HTTP_LOCASE         0x004
#define HTTP_ALPHA          (HTTP_UPCASE | HTTP_LOCASE)
#define HTTP_DIGIT          0x008
#define HTTP_CTL            0x010
#define HTTP_LWS            0x020
#define HTTP_HEX            0x040
#define HTTP_SEPERATOR      0x080
#define HTTP_TOKEN          0x100

#define URL_LEGAL           0x200
#define URL_TOKEN           (HTTP_ALPHA | HTTP_DIGIT | URL_LEGAL)

#define IS_HTTP_UPCASE(c)       (HttpChars[(UCHAR)(c)] & HTTP_UPCASE)
#define IS_HTTP_LOCASE(c)       (HttpChars[(UCHAR)(c)] & HTTP_UPCASE)
#define IS_HTTP_ALPHA(c)        (HttpChars[(UCHAR)(c)] & HTTP_ALPHA)
#define IS_HTTP_DIGIT(c)        (HttpChars[(UCHAR)(c)] & HTTP_DIGIT)
#define IS_HTTP_HEX(c)          (HttpChars[(UCHAR)(c)] & HTTP_HEX)
#define IS_HTTP_CTL(c)          (HttpChars[(UCHAR)(c)] & HTTP_CTL)
#define IS_HTTP_LWS(c)          (HttpChars[(UCHAR)(c)] & HTTP_LWS)
#define IS_HTTP_SEPERATOR(c)    (HttpChars[(UCHAR)(c)] & HTTP_SEPERATOR)
#define IS_HTTP_TOKEN(c)        (HttpChars[(UCHAR)(c)] & HTTP_TOKEN)
#define IS_URL_TOKEN(c)         (HttpChars[(UCHAR)(c)] & URL_TOKEN)

//
//  Constant Declarations for UTF8 Encoding
//

#define ASCII                 0x007f

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 =2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

NTSTATUS
InitializeHttpUtil(
    VOID
    );


//
// Our presumed cache-line size.
//

#define CACHE_LINE_SIZE UL_CACHE_LINE


//
// # of 100ns ticks per second ( 1ns = (1 / (10^9))s )
//

#define C_NS_TICKS_PER_SEC  ((LONGLONG) (10 * 1000 * 1000))


//
// Alignment macros.
//

#define ROUND_UP( val, pow2 )                                               \
    ( ( (ULONG_PTR)(val) + (pow2) - 1 ) & ~( (pow2) - 1 ) )


//
// Calculate the dimension of an array.
//

#define DIMENSION(x) ( sizeof(x) / sizeof(x[0]) )

//
// nice MIN/MAX macros
//

#define MIN(a,b) ( ((a) > (b)) ? (b) : (a) )
#define MAX(a,b) ( ((a) > (b)) ? (a) : (b) )

//
// Macros for swapping the bytes in a long and a short.
//

#define SWAP_LONG   RtlUlongByteSwap
#define SWAP_SHORT  RtlUshortByteSwap

//
// Context values stored in PFILE_OBJECT->FsContext2 to identify a handle
// as a control channel, filter channel or an app pool.
//

#define UL_CONTROL_CHANNEL_CONTEXT      ((PVOID)'LRTC')
#define UL_CONTROL_CHANNEL_CONTEXT_X    ((PVOID)'rtcX')
#define UL_FILTER_CHANNEL_CONTEXT       ((PVOID)'RTLF')
#define UL_FILTER_CHANNEL_CONTEXT_X     ((PVOID)'tlfX')
#define UL_APP_POOL_CONTEXT             ((PVOID)'PPPA')
#define UL_APP_POOL_CONTEXT_X           ((PVOID)'ppaX')

#define IS_CONTROL_CHANNEL( pFileObject )                                   \
    ( (pFileObject)->FsContext2 == UL_CONTROL_CHANNEL_CONTEXT )

#define MARK_VALID_CONTROL_CHANNEL( pFileObject )                           \
    ( (pFileObject)->FsContext2 = UL_CONTROL_CHANNEL_CONTEXT )

#define MARK_INVALID_CONTROL_CHANNEL( pFileObject )                         \
    ( (pFileObject)->FsContext2 = UL_CONTROL_CHANNEL_CONTEXT_X )

#define GET_CONTROL_CHANNEL( pFileObject )                                  \
    ((PUL_CONTROL_CHANNEL)((pFileObject)->FsContext))

#define GET_PP_CONTROL_CHANNEL( pFileObject )                               \
    ((PUL_CONTROL_CHANNEL *)&((pFileObject)->FsContext))

#define IS_FILTER_PROCESS( pFileObject )                                    \
    ( (pFileObject)->FsContext2 == UL_FILTER_CHANNEL_CONTEXT )

#define IS_EX_FILTER_PROCESS( pFileObject )                                 \
    ( (pFileObject)->FsContext2 == UL_FILTER_CHANNEL_CONTEXT_X )

#define MARK_VALID_FILTER_CHANNEL( pFileObject )                            \
    ( (pFileObject)->FsContext2 = UL_FILTER_CHANNEL_CONTEXT )

#define MARK_INVALID_FILTER_CHANNEL( pFileObject )                          \
    ( (pFileObject)->FsContext2 = UL_FILTER_CHANNEL_CONTEXT_X )

#define GET_FILTER_PROCESS( pFileObject )                                   \
    ((PUL_FILTER_PROCESS)((pFileObject)->FsContext))

#define GET_PP_FILTER_PROCESS( pFileObject )                                \
    ((PUL_FILTER_PROCESS *)&((pFileObject)->FsContext))

#define IS_APP_POOL( pFileObject )                                          \
    ( (pFileObject)->FsContext2 == UL_APP_POOL_CONTEXT )

#define IS_EX_APP_POOL( pFileObject )                                       \
    ( (pFileObject)->FsContext2 == UL_APP_POOL_CONTEXT_X )

#define MARK_VALID_APP_POOL( pFileObject )                                  \
    ( (pFileObject)->FsContext2 = UL_APP_POOL_CONTEXT )

#define MARK_INVALID_APP_POOL( pFileObject )                                \
    ( (pFileObject)->FsContext2 = UL_APP_POOL_CONTEXT_X )

#define GET_APP_POOL_PROCESS( pFileObject )                                 \
    ((PUL_APP_POOL_PROCESS)((pFileObject)->FsContext))

#define GET_PP_APP_POOL_PROCESS( pFileObject )                              \
    ((PUL_APP_POOL_PROCESS *)&((pFileObject)->FsContext))

#define IS_VALID_UL_NONPAGED_RESOURCE(pResource)                            \
    (((pResource) != NULL) &&                                               \
     ((pResource)->Signature == UL_NONPAGED_RESOURCE_SIGNATURE) &&          \
     ((pResource)->RefCount > 0))

typedef struct _UL_NONPAGED_RESOURCE
{
    //
    // NonPagedPool
    //

    SINGLE_LIST_ENTRY   LookasideEntry;     // must be first, links
                                            // into the lookaside list

    ULONG               Signature;          // UL_NONPAGED_RESOURCE_SIGNATURE

    LONG                RefCount;           // the reference count

    UL_ERESOURCE        Resource;           // the actual resource

} UL_NONPAGED_RESOURCE, * PUL_NONPAGED_RESOURCE;

#define UL_NONPAGED_RESOURCE_SIGNATURE      ((ULONG)'RNLU')
#define UL_NONPAGED_RESOURCE_SIGNATURE_X    MAKE_FREE_SIGNATURE(UL_NONPAGED_RESOURCE_SIGNATURE)


PUL_NONPAGED_RESOURCE
UlResourceNew(
    ULONG OwnerTag
    );

VOID
UlReferenceResource(
    PUL_NONPAGED_RESOURCE pResource
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceResource(
    PUL_NONPAGED_RESOURCE pResource
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_RESOURCE( pres )                                          \
    UlReferenceResource(                                                    \
        (pres)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define DEREFERENCE_RESOURCE( pres )                                        \
    UlDereferenceResource(                                                  \
        (pres)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

PVOID
UlResourceAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlResourceFreePool(
    IN PVOID pBuffer
    );


//
// Miscellaneous validators, etc.
//

#define IS_VALID_DEVICE_OBJECT( pDeviceObject )                             \
    ( ((pDeviceObject) != NULL) &&                                          \
      ((pDeviceObject)->Type == IO_TYPE_DEVICE) &&                          \
      ((pDeviceObject)->Size == sizeof(DEVICE_OBJECT)) )

#define IS_VALID_FILE_OBJECT( pFileObject )                                 \
    ( ((pFileObject) != NULL) &&                                            \
      ((pFileObject)->Type == IO_TYPE_FILE) &&                              \
      ((pFileObject)->Size == sizeof(FILE_OBJECT)) )

#define IS_VALID_IRP( pIrp )                                                \
    ( ((pIrp) != NULL) &&                                                   \
      ((pIrp)->Type == IO_TYPE_IRP) &&                                      \
      ((pIrp)->Size >= IoSizeOfIrp((pIrp)->StackCount)) )

// 2^32-1 + '\0'
#define MAX_ULONG_STR sizeof("4294967295")
// 2^64-1 + '\0'
#define MAX_ULONGLONG_STR sizeof("18446744073709551615")

#define MAX_IPV4_STRING_LENGTH  sizeof("255.255.255.255")

NTSTATUS
TimeFieldsToHttpDate(
    IN  PTIME_FIELDS pTime,
    OUT PWSTR pBuffer,
    IN  ULONG BufferLength
    );

BOOLEAN
StringTimeToSystemTime(
    IN  const PSTR pszTime,
    OUT LARGE_INTEGER * pliTime
    );

ULONG
HttpUnicodeToUTF8(
    IN  PCWSTR  lpSrcStr,
    IN  LONG    cchSrc,
    OUT LPSTR   lpDestStr,
    IN  LONG    cchDest
    );

BOOLEAN
FindInETagList(
    IN PUCHAR    pLocalETag,
    IN PUCHAR    pETagList,
    IN BOOLEAN   fWeakCompare
    );

ULONG
HostAddressAndPortToStringW(
    IN OUT PWCHAR  IpAddressStringW,
    IN ULONG  IpAddress,
    IN USHORT IpPortNum
    );

/***************************************************************************++

Routine Description:

    Stores the decimal representation of an unsigned 32-bit
    number in a character buffer, followed by a terminator
    character. Returns a pointer to the next position in the
    output buffer, to make appending strings easy; i.e., you
    can use the result of UlStrPrintUlong as the argument to the
    next call to UlStrPrintUlong. Note: the string is >not<
    zero-terminated unless you passed in '\0' as chTerminator

Arguments:

    psz - output buffer; assumed to be large enough to hold the number.

    n - the number to print into psz, a 32-bit unsigned integer

    chTerminator - character to append after the decimal representation of n

Return Value:

    pointer to end of string

History:

     GeorgeRe       19-Sep-2000

--***************************************************************************/
__inline
PCHAR
FASTCALL
UlStrPrintUlong(
    OUT PCHAR psz,
    IN  ULONG n,
    IN  CHAR  chTerminator)
{
    CHAR digits[MAX_ULONG_STR];
    int i = 0;

    ASSERT(psz != NULL);

    digits[i++] = chTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (CHAR) (n % 10) + '0';
        n /= 10;
    } while (n != 0);

    while (--i >= 0)
        *psz++ = digits[i];

    // Back up to the nul terminator, if present
    if (chTerminator == '\0')
    {
        --psz;
        ASSERT(*psz == '\0');
    }

    return psz;
}

/***************************************************************************++

Routine Description:

    Identical to the above function except it writes to a WCHAR buffer and
    it pads zeros to the beginning of the number.

--***************************************************************************/
__inline
PWCHAR
FASTCALL
UlStrPrintUlongW(
    OUT PWCHAR pwsz,
    IN  ULONG  n,
    IN  LONG   padding,
    IN  WCHAR  wchTerminator)
{
    WCHAR digits[MAX_ULONG_STR];
    int i = 0;

    ASSERT(pwsz != NULL);

    digits[i++] = wchTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (WCHAR) (n % 10) + L'0';
        n /= 10;
    } while (n != 0);

    // Padd Zeros to the beginning
    while( padding && --padding >= (i-1))
        *pwsz++ = L'0';

    // Reverse back
    while (--i >= 0)
        *pwsz++ = digits[i];

    // Back up to the nul terminator, if present
    if (wchTerminator == L'\0')
    {
        --pwsz;
        ASSERT(*pwsz == L'\0');
    }

    return pwsz;
}

__inline
PCHAR
FASTCALL
UlStrPrintUlongPad(
    OUT PCHAR  psz,
    IN  ULONG  n,
    IN  LONG   padding,
    IN  CHAR   chTerminator)
{
    CHAR digits[MAX_ULONG_STR];
    int  i = 0;

    ASSERT(psz != NULL);

    digits[i++] = chTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (CHAR) (n % 10) + '0';
        n /= 10;
    } while (n != 0);

    // Padd Zeros to the beginning
    while( padding && --padding >= (i-1))
        *psz++ = '0';

    // Reverse back
    while (--i >= 0)
        *psz++ = digits[i];

    // Back up to the nul terminator, if present
    if (chTerminator == '\0')
    {
        --psz;
        ASSERT(*psz == '\0');
    }

    return psz;
}

/***************************************************************************++

Routine Description:

    Stores the decimal representation of an unsigned 64-bit
    number in a character buffer, followed by a terminator
    character. Returns a pointer to the next position in the
    output buffer, to make appending strings easy; i.e., you
    can use the result of UlStrPrintUlonglong as the argument to the
    next call to UlStrPrintUlonglong. Note: the string is >not<
    zero-terminated unless you passed in '\0' as chTerminator

Arguments:

    psz - output buffer; assumed to be large enough to hold the number.

    n - the number to print into psz, a 64-bit unsigned integer

    chTerminator - character to append after the decimal representation of n

Return Value:

    pointer to end of string

History:

     GeorgeRe       19-Sep-2000

--***************************************************************************/
__inline
PCHAR
FASTCALL
UlStrPrintUlonglong(
    OUT PCHAR       psz,
    IN  ULONGLONG   n,
    IN  CHAR        chTerminator)
{
    CHAR digits[MAX_ULONGLONG_STR];
    int i;

    if (n <= ULONG_MAX)
    {
        return UlStrPrintUlong(psz, (ULONG)n, chTerminator);
    }

    ASSERT(psz != NULL);

    i = 0;
    digits[i++] = chTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (CHAR) (n % 10) + '0';
        n /= 10;
    } while (n != 0);

    while (--i >= 0)
        *psz++ = digits[i];

    // Back up to the nul terminator, if present
    if (chTerminator == '\0')
    {
        --psz;
        ASSERT(*psz == '\0');
    }

    return psz;
}

/* Wide Char version */
__inline
PWCHAR
FASTCALL
UlStrPrintUlonglongW(
    OUT PWCHAR      pwsz,
    IN  ULONGLONG   n,
    IN  WCHAR       wchTerminator)
{
    WCHAR digits[MAX_ULONGLONG_STR];
    int i;

    if (n <= ULONG_MAX)
    {
        return UlStrPrintUlongW(pwsz, (ULONG)n, 0, wchTerminator);
    }

    ASSERT(pwsz != NULL);

    i = 0;
    digits[i++] = wchTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (WCHAR) (n % 10) + L'0';
        n /= 10;
    } while (n != 0);

    while (--i >= 0)
        *pwsz++ = digits[i];

    // Back up to the nul terminator, if present
    if (wchTerminator == L'\0')
    {
        --pwsz;
        ASSERT(*pwsz == L'\0');
    }

    return pwsz;
}

/***************************************************************************++

Routine Description:

    Stores a string in a character buffer, followed by a
    terminator character. Returns a pointer to the next position
    in the output buffer, to make appending strings easy; i.e.,
    you can use the result of UlStrPrintStr as the argument to the
    next call to UlStrPrintStr. Note: the string is >not<
    zero-terminated unless you passed in '\0' as chTerminator

Arguments:

    pszOutput - output buffer; assumed to be large enough to hold the number.

    pszInput - input string

    chTerminator - character to append after the input string

Return Value:

    pointer to end of string

History:

     GeorgeRe       19-Sep-2000

--***************************************************************************/
__inline
PCHAR
FASTCALL
UlStrPrintStr(
    OUT PCHAR       pszOutput,
    IN  const CHAR* pszInput,
    IN  CHAR        chTerminator)
{
    ASSERT(pszOutput != NULL);
    ASSERT(pszInput != NULL);

    // copy the input string
    while (*pszInput != '\0')
        *pszOutput++ = *pszInput++;

    *pszOutput = chTerminator;

    // Move past the terminator character unless it's a nul
    if (chTerminator != '\0')
        ++pszOutput;

    return pszOutput;
}

/* Wide Char version */
__inline
PWCHAR
FASTCALL
UlStrPrintStrW(
    OUT PWCHAR       pwszOutput,
    IN  const WCHAR* pwszInput,
    IN  WCHAR        wchTerminator)
{
    ASSERT(pwszOutput != NULL);
    ASSERT(pwszInput  != NULL);

    // copy the input string
    while (*pwszInput != L'\0')
        *pwszOutput++ = *pwszInput++;

    *pwszOutput = wchTerminator;

    // Move past the terminator character unless it's a nul
    if (wchTerminator != L'\0')
        ++pwszOutput;

    return pwszOutput;
}

/* This version also does SpaceToPlus Conversion */
__inline
PCHAR
FASTCALL
UlStrPrintStrC(
    OUT PCHAR       pszOutput,
    IN  const CHAR* pszInput,
    IN  CHAR        chTerminator)
{
    ASSERT(pszOutput != NULL);
    ASSERT(pszInput != NULL);

    // copy the input string
    while (*pszInput != '\0')
    {
        if (*pszInput == ' ')
        {
            *pszOutput++ = '+'; pszInput++;
        }
        else
        {
            *pszOutput++ = *pszInput++;
        }
    }

    *pszOutput = chTerminator;

    // Move past the terminator character unless it's a nul
    if (chTerminator != '\0')
        ++pszOutput;

    return pszOutput;
}

/***************************************************************************++

Routine Description:

    Assumes that no information has been saved in the high byte of the WCHAR
    this function simply unpads the ansi string from wchar buffer back to
    a char buffer.

    If bReplaceSpaces is TRUE, it replaces the spaces in the source string
    with '+' sign, not including the terminator.

--***************************************************************************/
__inline
LONG
FASTCALL
UlStrPrintStrUnPad(
    OUT PCHAR        pszOutput,
    IN  ULONG        OutputSize,
    IN  const WCHAR* pwszInput,
    IN  CHAR         chTerminator,
    IN  BOOLEAN      bReplaceSpaces)
{
    ULONG Copied = 0;

    ASSERT(pszOutput != NULL);
    ASSERT(pwszInput != NULL);

    //
    // copy the input string discard the wchar's high byte
    // by explicitly casting it to char
    //

    if (bReplaceSpaces)
    {
        while (*pwszInput != L'\0' && Copied < OutputSize)
        {
            if (*pwszInput == L' ')
            {
                *pszOutput++ = (CHAR) '+'; pwszInput++, Copied++;
            }
            else
            {
                *pszOutput++ = (CHAR) *pwszInput++, Copied++;
            }
        }
    }
    else
    {
        while (*pwszInput != L'\0' && Copied < OutputSize)
            *pszOutput++ = (CHAR) *pwszInput++, Copied++;
    }

    //
    // return -1 if we couldn't copy
    // the whole Input string
    //
    if (*pwszInput != L'\0')
        return -1;

    //
    // Copy the seperator if there's
    // a space for that too
    //
    if (Copied < OutputSize)
        *pszOutput = chTerminator;

    // Count the terminator character unless it's a nul
    if (chTerminator != '\0')
        ++Copied;

    //
    // return how many chars we have copied
    //
    return (LONG) Copied;
}

/***************************************************************************++

Routine Description:

    W/o storing any information to the high bytes of the WCHAR this function
    simply converts the ansi string to wchar buffer by padding zeros.

--***************************************************************************/
__inline
PWCHAR
FASTCALL
UlStrPrintStrPad(
    OUT PWCHAR       pwszOutput,
    IN  const CHAR*  pszInput,
    IN  WCHAR        wchTerminator)
{
    ULONG Copied = 0;

    ASSERT(pwszOutput != NULL);
    ASSERT(pszInput   != NULL);

    // copy the input string
    while (*pszInput != '\0')
        *pwszOutput++ = (WCHAR) *pszInput++;

    // copy the separator
    *pwszOutput = wchTerminator;

    // Move past the terminator character unless it's a nul
    if (wchTerminator != L'\0')
        ++pwszOutput;

    return pwszOutput;
}

/***************************************************************************++

Routine Description:

    Converts an V4 Ip address to string in the provided buffer.

Arguments:

    psz             - Pointer to the buffer
    RawAddress      - IP address structure from TDI / UL_CONNECTION
    chTerminator    - The terminator char will be appended to the end

Return:

    The number of bytes copied to destination buffer.
    
--***************************************************************************/

__inline
PCHAR
FASTCALL
UlStrPrintIP(
    OUT PCHAR  psz,
    IN  IPAddr IpAddress,
    IN  CHAR   chTerminator
    )
{
    psz = UlStrPrintUlong(psz, (IpAddress >> 24) & 0xFF, '.' );
    psz = UlStrPrintUlong(psz, (IpAddress >> 16) & 0xFF, '.' );
    psz = UlStrPrintUlong(psz, (IpAddress >>  8) & 0xFF, '.' );
    psz = UlStrPrintUlong(psz, (IpAddress >>  0) & 0xFF, chTerminator);

    return psz;
}

__inline
PCHAR
FASTCALL
UlStrPrintProtocolStatus(
    OUT PCHAR  psz,
    IN  USHORT StatusCode,
    IN  CHAR   chTerminator
    )
{
    ASSERT(StatusCode <= 999);
        
    *psz++ = '0' + ((StatusCode / 100) % 10);
    *psz++ = '0' + ((StatusCode / 10)  % 10);
    *psz++ = '0' + ((StatusCode / 1)   % 10);
    *psz++ = chTerminator;

    return psz;    
}


__inline
VOID
ProbeTestForRead (
    IN const void* Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for read accessibility and ensures
    correct alignment of the structure. If the structure is not accessible
    or has incorrect alignment, then an exception is raised.

    Adapted from \nt\base\ntos\ex\probe.c's version of ProbeForWrite.
    The regular ProbeForRead does not dereference any of the memory
    in the buffer.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{

    ULONG_PTR StartAddress = (ULONG_PTR)Address;
    ULONG_PTR EndAddress = StartAddress + Length - 1;

    // Do the regular ProbeForRead checks for misalignment or
    // out-of-bounds addresses. This will raise exceptions, if needed.
    ProbeForRead(Address, Length, Alignment);
    
    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility or alignment.
    //

    if (Length == 0)
        return;

    //
    // The preceding checks should guarantee us a valid address range
    //

    ASSERT(StartAddress <= EndAddress);

    //
    // N.B. Only the contents of the buffer may be probed.
    //      Therefore the starting byte is probed for the
    //      first page, and then the first byte in the page
    //      for each succeeding page.
    //

    // First byte of last page in range
    
    EndAddress = (EndAddress & ~(PAGE_SIZE - 1)) + PAGE_SIZE;

    do {
        *(volatile CHAR *)StartAddress;
        
        StartAddress = (StartAddress & ~(PAGE_SIZE - 1)) + PAGE_SIZE;
    } while (StartAddress != EndAddress);
} // ProbeTestForRead 



//
// 64-bit interlocked routines
//

#ifdef _WIN64
#define UlInterlockedIncrement64    InterlockedIncrement64
#define UlInterlockedDecrement64    InterlockedDecrement64
#define UlInterlockedAdd64          InterlockedAdd64
#define UlInterlockedExchange64     InterlockedExchange64
#else

__inline
LONGLONG
FASTCALL
UlInterlockedIncrement64 (
    IN OUT PLONGLONG Addend
    )
{
    LONGLONG localAddend;
    LONGLONG addendPlusOne;
    LONGLONG originalAddend;

    do {

        localAddend = *((volatile LONGLONG *) Addend);
        addendPlusOne = localAddend + 1;

        originalAddend = InterlockedCompareExchange64( Addend,
                                                       addendPlusOne,
                                                       localAddend );

    } while (originalAddend != localAddend);

    return addendPlusOne;
}

__inline
LONGLONG
FASTCALL
UlInterlockedDecrement64 (
    IN OUT PLONGLONG Addend
    )
{
    LONGLONG localAddend;
    LONGLONG addendMinusOne;
    LONGLONG originalAddend;

    do {

        localAddend = *((volatile LONGLONG *) Addend);
        addendMinusOne = localAddend - 1;

        originalAddend = InterlockedCompareExchange64( Addend,
                                                       addendMinusOne,
                                                       localAddend );

    } while (originalAddend != localAddend);

    return addendMinusOne;
}

__inline
LONGLONG
FASTCALL
UlInterlockedAdd64 (
    IN OUT PLONGLONG Addend,
    IN     LONGLONG  Value
    )
{
    LONGLONG localAddend;
    LONGLONG addendPlusValue;
    LONGLONG originalAddend;

    do {

        localAddend = *((volatile LONGLONG *) Addend);
        addendPlusValue = localAddend + Value;

        originalAddend = InterlockedCompareExchange64( Addend,
                                                       addendPlusValue,
                                                       localAddend );

    } while (originalAddend != localAddend);

    return addendPlusValue;
}

__inline
LONGLONG
FASTCALL
UlInterlockedExchange64 (
    IN OUT PLONGLONG Addend,
    IN     LONGLONG  newValue
    )
{
    LONGLONG localAddend;
    LONGLONG originalAddend;

    do {

        localAddend = *((volatile LONGLONG *) Addend);

        originalAddend = InterlockedCompareExchange64( Addend,
                                                       newValue,
                                                       localAddend );

    } while (originalAddend != localAddend);

    return originalAddend;
}
#endif

//
// Barrier support for read-mostly operations
// Note that the AMD64 and IA32 barrier relies on program ordering
// and does not generate a hardware barrier
//

#if defined(_M_IA64)
    #define UL_READMOSTLY_READ_BARRIER() __mf()
    #define UL_READMOSTLY_WRITE_BARRIER() __mf()
    #define UL_READMOSTLY_MEMORY_BARRIER() __mf()
#elif defined(_AMD64_) || defined(_X86_)
    extern "C" void _ReadWriteBarrier();
    extern "C" void _WriteBarrier();
    #pragma intrinsic(_ReadWriteBarrier)
    #pragma intrinsic(_WriteBarrier)
    #define UL_READMOSTLY_READ_BARRIER() _ReadWriteBarrier()
    #define UL_READMOSTLY_WRITE_BARRIER() _WriteBarrier()
    #define UL_READMOSTLY_MEMORY_BARRIER() _ReadWriteBarrier()
#else
    #error Cannot generate memory barriers for this architecture
#endif

__inline
PVOID
UlpFixup(
    IN PUCHAR pUserPtr,
    IN PUCHAR pKernelPtr,
    IN PUCHAR pOffsetPtr,
    IN ULONG BufferLength
    )
{
    ASSERT( pOffsetPtr >= pKernelPtr );
    ASSERT( DIFF(pOffsetPtr - pKernelPtr) <= BufferLength );

    return pUserPtr + DIFF(pOffsetPtr - pKernelPtr);

}   // UlpFixup

#define FIXUP_PTR( Type, pUserPtr, pKernelPtr, pOffsetPtr, BufferLength )   \
    (Type)UlpFixup(                                                         \
                (PUCHAR)(pUserPtr),                                         \
                (PUCHAR)(pKernelPtr),                                       \
                (PUCHAR)(pOffsetPtr),                                       \
                (BufferLength)                                              \
                )

//
// Time utility to calculate the TimeZone Bias Daylight/standart 
// and returns one of the following values. 
// It's taken from base\client\timedate.c.
// Once this two functions are exposed in the kernel we can get rid of
// this two functions.
//

#define UL_TIME_ZONE_ID_INVALID    0xFFFFFFFF
#define UL_TIME_ZONE_ID_UNKNOWN    0
#define UL_TIME_ZONE_ID_STANDARD   1
#define UL_TIME_ZONE_ID_DAYLIGHT   2

BOOLEAN
UlCutoverTimeToSystemTime(
    PTIME_FIELDS    CutoverTime,
    PLARGE_INTEGER  SystemTime,
    PLARGE_INTEGER  CurrentSystemTime
    );

ULONG 
UlCalcTimeZoneIdAndBias(
     IN  RTL_TIME_ZONE_INFORMATION *ptzi,
     OUT PLONG pBias
     );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\misc.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    misc.cxx

Abstract:

    This module contains the miscellaneous UL routines.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


ULONG   HttpChars[256];
USHORT  FastPopChars[256];
USHORT  DummyPopChars[256];


//
// Private prototypes.
//

NTSTATUS
UlpRestartDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlOpenRegistry )
#pragma alloc_text( PAGE, UlReadLongParameter )
#pragma alloc_text( PAGE, UlReadLongLongParameter )
#pragma alloc_text( PAGE, UlReadGenericParameter )
#pragma alloc_text( PAGE, UlIssueDeviceControl )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlBuildDeviceControlIrp
NOT PAGEABLE -- UlULongLongToAscii
NOT PAGEABLE -- UlpRestartDeviceControl
NOT PAGEABLE -- UlAllocateReceiveBufferPool
NOT PAGEABLE -- UlFreeReceiveBufferPool
NOT PAGEABLE -- UlAllocateIrpContextPool
NOT PAGEABLE -- UlFreeIrpContextPool
NOT PAGEABLE -- UlAllocateRequestBufferPool
NOT PAGEABLE -- UlFreeRequestBufferPool
NOT PAGEABLE -- UlAllocateInternalRequestPool
NOT PAGEABLE -- UlFreeInternalRequestPool
NOT PAGEABLE -- UlAllocateChunkTrackerPool
NOT PAGEABLE -- UlFreeChunkTrackerPool
NOT PAGEABLE -- UlAllocateFullTrackerPool
NOT PAGEABLE -- UlFreeFullTrackerPool
NOT PAGEABLE -- UlAllocateResponseBufferPool
NOT PAGEABLE -- UlFreeResponseBufferPool
NOT PAGEABLE -- UlAllocateLogBufferPool
NOT PAGEABLE -- UlFreeLogBufferPool
NOT PAGEABLE -- UlInvokeCompletionRoutine
NOT PAGEABLE -- UlUlInterlockedIncrement64
NOT PAGEABLE -- UlUlInterlockedDecrement64
NOT PAGEABLE -- UlUlInterlockedAdd64
NOT PAGEABLE -- UlUlInterlockedExchange64

NOT PAGEABLE -- TwoDigitsToUnicode
NOT PAGEABLE -- TimeFieldsToHttpDate
NOT PAGEABLE -- AsciiToShort
NOT PAGEABLE -- TwoAsciisToShort
NOT PAGEABLE -- NumericToAsciiMonth
NOT PAGEABLE -- StringTimeToSystemTime
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Opens a handle to the UL's Parameters registry key.

Arguments:

    BaseName - Supplies the name of the parent registry key containing
        the Parameters key.

    ParametersHandle - Returns a handle to the Parameters key.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    )
{
    HANDLE configHandle;
    NTSTATUS status;
    PWSTR parametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING parametersKeyName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        BaseName,                               // ObjectName
        OBJ_CASE_INSENSITIVE |                  // Attributes
            UL_KERNEL_HANDLE,
        NULL,                                   // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    UlAttachToSystemProcess();

    status = ZwOpenKey( &configHandle, KEY_READ, &objectAttributes );

    if (!NT_SUCCESS(status))
    {
        UlDetachFromSystemProcess();
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString( &parametersKeyName, parametersString );

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        &parametersKeyName,                     // ObjectName
        OBJ_CASE_INSENSITIVE,                   // Attributes
        configHandle,                           // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    status = ZwOpenKey( ParametersHandle, KEY_READ, &objectAttributes );

    if (!NT_SUCCESS(status))
    {
        ZwClose( configHandle );
        UlDetachFromSystemProcess();
        return status;
    }

    //
    // All keys successfully opened or created.
    //

    ZwClose( configHandle );
    UlDetachFromSystemProcess();

    return STATUS_SUCCESS;

}   // UlOpenRegistry


/***************************************************************************++

Routine Description:

    Reads a single (LONG/ULONG) value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to read.

    DefaultValue - Supplies the default value.

Return Value:

    LONG - The value read from the registry or the default if the
        registry data was unavailable or incorrect.

--***************************************************************************/
LONG
UlReadLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )
{

    PKEY_VALUE_PARTIAL_INFORMATION information;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(LONG)];

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, read it from the registry.
    //

    RtlInitUnicodeString(
        &valueKeyName,
        ValueName
        );

    information = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValuePartialInformation,
                 (PVOID)information,
                 sizeof(buffer),
                 &informationLength
                 );

    //
    // If the read succeeded, the type is DWORD and the length is
    // sane, use it. Otherwise, use the default.
    //

    if (status == STATUS_SUCCESS &&
        information->Type == REG_DWORD &&
        information->DataLength == sizeof(returnValue))
    {
        RtlMoveMemory( &returnValue, information->Data, sizeof(returnValue) );
    } else {
        returnValue = DefaultValue;
    }

    return returnValue;

}   // UlReadLongParameter


/***************************************************************************++

Routine Description:

    Reads a single (LONGLONG/ULONGLONG) value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to read.

    DefaultValue - Supplies the default value.

Return Value:

    LONGLONG - The value read from the registry or the default if the
        registry data was unavailable or incorrect.

--***************************************************************************/
LONGLONG
UlReadLongLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONGLONG DefaultValue
    )
{

    PKEY_VALUE_PARTIAL_INFORMATION information;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONGLONG returnValue;
    NTSTATUS status;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(LONGLONG)];

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, read it from the registry.
    //

    RtlInitUnicodeString(
        &valueKeyName,
        ValueName
        );

    information = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValuePartialInformation,
                 (PVOID)information,
                 sizeof(buffer),
                 &informationLength
                 );

    //
    // If the read succeeded, the type is DWORD and the length is
    // sane, use it. Otherwise, use the default.
    //

    if (status == STATUS_SUCCESS &&
        information->Type == REG_QWORD &&
        information->DataLength == sizeof(returnValue))
    {
        RtlMoveMemory( &returnValue, information->Data, sizeof(returnValue) );
    } else {
        returnValue = DefaultValue;
    }

    return returnValue;

}   // UlReadLongLongParameter


/***************************************************************************++

Routine Description:

    Reads a single free-form value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to read.

    Value - Receives the value read from the registry.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReadGenericParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION * Value
    )
{

    KEY_VALUE_PARTIAL_INFORMATION partialInfo;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION newValue;
    ULONG dataLength;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, then perform an initial read. The read
    // should fail with buffer overflow, but that's OK. We just want
    // to get the length of the data.
    //

    RtlInitUnicodeString( &valueKeyName, ValueName );

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValuePartialInformation,
                 (PVOID)&partialInfo,
                 sizeof(partialInfo),
                 &informationLength
                 );

    if (NT_ERROR(status))
    {
        return status;
    }

    //
    // Determine the data length. Ensure that strings and multi-sz get
    // properly terminated.
    //

    dataLength = partialInfo.DataLength - 1;

    if (partialInfo.Type == REG_SZ || partialInfo.Type == REG_EXPAND_SZ)
    {
        dataLength += 1;
    }

    if (partialInfo.Type == REG_MULTI_SZ)
    {
        dataLength += 2;
    }

    //
    // Allocate the buffer.
    //

    newValue = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    KEY_VALUE_PARTIAL_INFORMATION,
                    dataLength,
                    UL_REGISTRY_DATA_POOL_TAG
                   );

    if (newValue == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // update the actually allocated length for later use
    //

    dataLength += sizeof(KEY_VALUE_PARTIAL_INFORMATION);

    RtlZeroMemory( newValue, dataLength );

    //
    // Perform the actual read.
    //

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValuePartialInformation,
                 (PVOID)(newValue),
                 dataLength,
                 &informationLength
                 );

    if (NT_SUCCESS(status))
    {
        *Value = newValue;
    }
    else
    {
        UL_FREE_POOL( newValue, UL_REGISTRY_DATA_POOL_TAG );
    }

    return status;

}   // UlReadGenericParameter


/***************************************************************************++

Routine Description:

    Builds a properly formatted device control IRP.

Arguments:

    Irp - Supplies the IRP to format.

    IoControlCode - Supplies the device IO control code.

    InputBuffer - Supplies the input buffer.

    InputBufferLength - Supplies the length of InputBuffer.

    OutputBuffer - Supplies the output buffer.

    OutputBufferLength - Supplies the length of OutputBuffer.

    MdlAddress - Supplies a MDL to attach to the IRP. This is assumed to
        be a non-paged MDL.

    FileObject - Supplies the file object for the target driver.

    DeviceObject - Supplies the correct device object for the target
        driver.

    IoStatusBlock - Receives the final completion status of the request.

    CompletionRoutine - Supplies a pointer to a completion routine to
        call after the request completes. This will only be called if
        this routine returns STATUS_PENDING.

    CompletionContext - Supplies an uninterpreted context value passed
        to the completion routine.

    TargetThread - Optionally supplies a target thread for the IRP. If
        this value is NULL, then the current thread is used.

--***************************************************************************/
VOID
UlBuildDeviceControlIrp(
    IN OUT PIRP Irp,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PMDL MdlAddress,
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext,
    IN PETHREAD TargetThread OPTIONAL
    )
{
    PIO_STACK_LOCATION irpSp;

    //
    // Sanity check.
    //

    ASSERT( Irp != NULL );
    ASSERT( FileObject != NULL );
    ASSERT( DeviceObject != NULL );

    //
    // Fill in the service independent parameters in the IRP.
    //

    Irp->Flags = 0;
    Irp->RequestorMode = KernelMode;
    Irp->PendingReturned = FALSE;

    Irp->UserIosb = IoStatusBlock;
    Irp->UserEvent = NULL;

    Irp->AssociatedIrp.SystemBuffer = InputBuffer ? InputBuffer : OutputBuffer;
    Irp->UserBuffer = OutputBuffer;
    Irp->MdlAddress = MdlAddress;

    Irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    Irp->Tail.Overlay.Thread = TargetThread ? TargetThread : PsGetCurrentThread();
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    //
    // Put the file object pointer in the stack location.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = DeviceObject;

    //
    // Fill in the service dependent parameters in the IRP stack.
    //

    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->MinorFunction = 0;

    //
    // Set the completion routine appropriately.
    //

    if (CompletionRoutine == NULL)
    {
        IoSetCompletionRoutine(
            Irp,
            NULL,
            NULL,
            FALSE,
            FALSE,
            FALSE
            );
    }
    else
    {
        IoSetCompletionRoutine(
            Irp,
            CompletionRoutine,
            CompletionContext,
            TRUE,
            TRUE,
            TRUE
            );
    }

}   // UlBuildDeviceControlIrp


/***************************************************************************++

Routine Description:

    Converts the given ULONGLLONG to an ASCII representation and stores it
    in the given string.

Arguments:

    String - Receives the ASCII representation of the ULONGLONG.

    Value - Supplies the ULONGLONG to convert.

Return Value:

    PSTR - Pointer to the next character in String *after* the converted
        ULONGLONG.

--***************************************************************************/
PSTR
UlULongLongToAscii(
    IN PSTR String,
    IN ULONGLONG Value
    )
{
    PSTR p1;
    PSTR p2;
    CHAR ch;
    ULONG digit;

    //
    // Special case 0 to make the rest of the routine simpler.
    //

    if (Value == 0)
    {
        *String++ = '0';
    }
    else
    {
        //
        // Convert the ULONG. Note that this will result in the string
        // being backwards in memory.
        //

        p1 = String;
        p2 = String;

        while (Value != 0)
        {
            digit = (ULONG)( Value % 10 );
            Value = Value / 10;
            *p1++ = '0' + (CHAR)digit;
        }

        //
        // Reverse the string.
        //

        String = p1;
        p1--;

        while (p1 > p2)
        {
            ch = *p1;
            *p1 = *p2;
            *p2 = ch;

            p2++;
            p1--;
        }
    }

    *String = '\0';
    return String;

}   // UlULongLongToAscii

NTSTATUS
_RtlIntegerToUnicode(
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG BufferLength,
    OUT PWSTR String
    )
{
    PWSTR p1;
    PWSTR p2;
    WCHAR ch;
    ULONG digit;

    //
    // Special case 0 to make the rest of the routine simpler.
    //

    if (Value == 0)
    {
        *String++ = L'0';
    }
    else
    {
        //
        // Convert the ULONG. Note that this will result in the string
        // being backwards in memory.
        //

        p1 = String;
        p2 = String;

        while (Value != 0)
        {
            digit = (ULONG)( Value % 10 );
            Value = Value / 10;
            *p1++ = L'0' + (WCHAR)digit;
        }

        //
        // Reverse the string.
        //

        String = p1;
        p1--;

        while (p1 > p2)
        {
            ch = *p1;
            *p1 = *p2;
            *p2 = ch;

            p2++;
            p1--;
        }
    }

    *String = L'\0';

    return STATUS_SUCCESS;

}   // _RtlIntegerToUnicode

/***************************************************************************++

Routine Description:

    Converts an ansi string to an integer.  fails if any non-digit characters
    appears in the string.  fails on negative numbers, and assumes no preceding
    spaces.

Arguments:

    PUCHAR  pString             the string to convert
    ULONG   Base                the base, must be 10 or 16
    PULONG  pValue              the return value of the converted integer

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAnsiToULongLong(
    PUCHAR      pString,
    ULONG       Base,
    PULONGLONG  pValue
    )
{
    ULONGLONG   Value;
    ULONGLONG   NewValue;

    if (Base != 10 && Base != 16)
        RETURN(STATUS_INVALID_PARAMETER);

    //
    // No preceding space, we already skipped it
    //

    ASSERT(IS_HTTP_LWS(pString[0]) == FALSE);

    Value = 0;

    while (pString[0] != ANSI_NULL)
    {
        if (
            (Base == 10 && IS_HTTP_DIGIT(pString[0]) == FALSE) ||
               (Base == 16 && IS_HTTP_HEX(pString[0]) == FALSE)
            )
        {
            //
            // Not valid , bad!
            //

            RETURN(STATUS_INVALID_PARAMETER);
        }

        if (Base == 16)
        {
            if (IS_HTTP_ALPHA(pString[0]))
            {
                NewValue = 16 * Value + (UPCASE_CHAR(pString[0]) - 'A' + 10);
            }
            else
            {
                NewValue = 16 * Value + (pString[0] - '0');
            }
        }
        else
        {
            NewValue = 10 * Value + (pString[0] - '0');
        }

        if (NewValue < Value)
        {
            //
            // Very bad... we overflew
            //

            RETURN(STATUS_SECTION_TOO_BIG);
        }

        Value = NewValue;

        pString += 1;
    }

    *pValue = Value;

    return STATUS_SUCCESS;

}   // UlAnsiToULongLong


/***************************************************************************++

Routine Description:

    Converts a unicode string to an integer.  fails if any non-digit characters
    appear in the string.  fails on negative numbers, and assumes no preceding
    spaces.

Arguments:

    PWCHAR  pString             the string to convert
    ULONG   Base                the base, must be 10 or 16
    PULONG  pValue              the return value of the converted integer

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlUnicodeToULongLong(
    PWCHAR      pString,
    ULONG       Base,
    PULONGLONG  pValue
    )
{
    ULONGLONG   Value;
    ULONGLONG   NewValue;

    if (Base != 10 && Base != 16)
        RETURN(STATUS_INVALID_PARAMETER);

    //
    // No preceding space, we already skipped it
    //

    ASSERT(pString[0] < 128 && IS_HTTP_LWS(pString[0]) == FALSE);

    Value = 0;

    while (pString[0] != UNICODE_NULL)
    {
        if ((Base == 10 &&
                (pString[0] >= 128 || IS_HTTP_DIGIT(pString[0]) == FALSE)) ||
            (Base == 16 &&
                (pString[0] >= 128 || IS_HTTP_HEX(pString[0]) == FALSE)))
        {
            //
            // Not valid , bad!
            //

            RETURN(STATUS_INVALID_PARAMETER);
        }

        if (Base == 16)
        {
            if (IS_HTTP_ALPHA(pString[0]))
            {
                NewValue = 16 * Value + (pString[0] - L'A' + 10);
            }
            else
            {
                NewValue = 16 * Value + (pString[0] - L'0');
            }
        }
        else
        {
            NewValue = 10 * Value + (pString[0] - L'0');
        }

        if (NewValue < Value)
        {
            //
            // Very bad... we overflew
            //

            RETURN(STATUS_INVALID_PARAMETER);
        }

        Value = NewValue;

        pString += 1;
    }

    *pValue = Value;

    return STATUS_SUCCESS;

}   // UlUnicodeToULongLong


/***************************************************************************++

Routine Description:

    Synchronously issues a device control request to the TDI provider.

Arguments:

    pTdiObject - Supplies a pointer to the TDI object.

    pIrpParameters - Supplies a pointer to the IRP parameters.

    IrpParametersLength - Supplies the length of pIrpParameters.

    pMdlBuffer - Optionally supplies a pointer to a buffer to be mapped
        into a MDL and placed in the MdlAddress field of the IRP.

    MdlBufferLength - Optionally supplies the length of pMdlBuffer.

    MinorFunction - Supplies the minor function code of the request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlIssueDeviceControl(
    IN PUX_TDI_OBJECT pTdiObject,
    IN PVOID pIrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID pMdlBuffer OPTIONAL,
    IN ULONG MdlBufferLength OPTIONAL,
    IN UCHAR MinorFunction
    )
{
    NTSTATUS status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    UL_STATUS_BLOCK ulStatus;
    PMDL pMdl;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Initialize the event that will signal I/O completion.
    //

    UlInitializeStatusBlock( &ulStatus );

    //
    // Set the file object event to the non-signaled state.
    //

    KeResetEvent( &pTdiObject->pFileObject->Event );

    //
    // Allocate an IRP for the request.
    //

    pIrp = UlAllocateIrp(
                pTdiObject->pDeviceObject->StackSize,   // StackSize
                FALSE                                   // ChargeQuota
                );

    if (pIrp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Establish the service independent parameters.
    //

    pIrp->Flags = IRP_SYNCHRONOUS_API;
    pIrp->RequestorMode = KernelMode;
    pIrp->PendingReturned = FALSE;

    pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
    pIrp->Tail.Overlay.OriginalFileObject = pTdiObject->pFileObject;

    //
    // If we have a MDL buffer, allocate a new MDL and map the
    // buffer into it.
    //

    if (pMdlBuffer != NULL)
    {
        pMdl = UlAllocateMdl(
                    pMdlBuffer,                 // VirtualAddress
                    MdlBufferLength,            // Length
                    FALSE,                      // SecondaryBuffer
                    FALSE,                      // ChargeQuota
                    pIrp                        // Irp
                    );

        if (pMdl == NULL)
        {
            UlFreeIrp( pIrp );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( pMdl );
    }
    else
    {
        pIrp->MdlAddress = NULL;
    }

    //
    // Initialize the IRP stack location.
    //

    pIrpSp = IoGetNextIrpStackLocation( pIrp );

    pIrpSp->FileObject = pTdiObject->pFileObject;
    pIrpSp->DeviceObject = pTdiObject->pDeviceObject;

    ASSERT( IrpParametersLength <= sizeof(pIrpSp->Parameters) );
    RtlCopyMemory(
        &pIrpSp->Parameters,
        pIrpParameters,
        IrpParametersLength
        );

    pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pIrpSp->MinorFunction = MinorFunction;

    //
    // Reference the file object.
    //

    ObReferenceObject( pTdiObject->pFileObject );

    //
    // Establish a completion routine to free the MDL and dereference
    // the FILE_OBJECT.
    //

    IoSetCompletionRoutine(
        pIrp,                                   // Irp
        &UlpRestartDeviceControl,               // CompletionRoutine
        &ulStatus,                              // Context
        TRUE,                                   // InvokeOnSuccess
        TRUE,                                   // InvokeOnError
        TRUE                                    // InvokeOnCancel
        );

    //
    // Issue the request.
    //

    status = UlCallDriver( pTdiObject->pDeviceObject, pIrp );

    //
    // If necessary, wait for the request to complete and snag the
    // final completion status.
    //

    if (status == STATUS_PENDING)
    {
        UlWaitForStatusBlockEvent( &ulStatus );
        status = ulStatus.IoStatus.Status;
    }

    return status;

}   // UlIssueDeviceControl


/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_RECEIVE_BUFFER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UL_RECEIVE_BUFFER), but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_RCV_BUFFER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateReceiveBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_RECEIVE_BUFFER pBuffer;
    SIZE_T irpLength;
    SIZE_T mdlLength;
    SIZE_T ExtraLength;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_RECEIVE_BUFFER) );
    ASSERT( Tag == UL_RCV_BUFFER_POOL_TAG );

    //
    // Calculate the required length of the buffer & allocate it.
    //

    irpLength = IoSizeOfIrp( g_UlIrpStackSize );
    irpLength = ALIGN_UP( irpLength, PVOID );

    mdlLength = MmSizeOfMdl( (PVOID)(PAGE_SIZE - 1), g_UlReceiveBufferSize );
    mdlLength = ALIGN_UP( mdlLength, PVOID );

    ExtraLength = irpLength + (mdlLength*2) + g_UlReceiveBufferSize;

    ASSERT( ( ExtraLength & (sizeof(PVOID) - 1) ) == 0 );

    pBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_RECEIVE_BUFFER,
                    ExtraLength,
                    UL_RCV_BUFFER_POOL_TAG
                    );

    if (pBuffer != NULL)
    {
        PUCHAR pRawBuffer = (PUCHAR)(pBuffer);

        //
        // Initialize the IRP, MDL, and data pointers within the buffer.
        //
        // CODEWORK: the signature should be set in invalid here, but
        // there's no wrapper around the PplAllocate/Free functions
        // for this structure, so set it to the valid sig for now.
        //

        pBuffer->Signature = UL_RECEIVE_BUFFER_SIGNATURE;
        pRawBuffer += ALIGN_UP( sizeof(UL_RECEIVE_BUFFER), PVOID );
        pBuffer->pIrp = (PIRP)pRawBuffer;
        pRawBuffer += irpLength;
        pBuffer->pMdl = (PMDL)pRawBuffer;
        pRawBuffer += mdlLength;
        pBuffer->pPartialMdl = (PMDL)pRawBuffer;
        pRawBuffer += mdlLength;
        pBuffer->pDataArea = (PVOID)pRawBuffer;
        pBuffer->UnreadDataLength = 0;

        //
        // Initialize the IRP.
        //

        IoInitializeIrp(
            pBuffer->pIrp,                      // Irp
            (USHORT)irpLength,                  // PacketSize
            g_UlIrpStackSize                    // StackSize
            );

        //
        // Initialize the primary MDL.
        //

        MmInitializeMdl(
            pBuffer->pMdl,                      // MemoryDescriptorList
            pBuffer->pDataArea,                 // BaseVa
            g_UlReceiveBufferSize               // Length
            );

        MmBuildMdlForNonPagedPool( pBuffer->pMdl );
    }

    return (PVOID)pBuffer;

}   // UlAllocateReceiveBufferPool

/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_RECEIVE_BUFFER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeReceiveBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_RECEIVE_BUFFER pReceiveBuffer;
    //
    // Sanity check.
    //

    pReceiveBuffer = (PUL_RECEIVE_BUFFER)pBuffer;

    //
    // Kill the signature, then free it.
    //

    pReceiveBuffer->Signature = UL_RECEIVE_BUFFER_SIGNATURE_X;
    UL_FREE_POOL( pReceiveBuffer, UL_RCV_BUFFER_POOL_TAG );

}   // UlFreeReceiveBufferPool


/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_IRP_CONTEXT structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UL_IRP_CONTEXT), but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_IRP_CONTEXT_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateIrpContextPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_IRP_CONTEXT pIrpContext;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_IRP_CONTEXT) );
    ASSERT( Tag == UL_IRP_CONTEXT_POOL_TAG );

    //
    // Allocate the IRP context.
    //

    pIrpContext = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UL_IRP_CONTEXT,
                        UL_IRP_CONTEXT_POOL_TAG
                        );

    if (pIrpContext != NULL)
    {
        //
        // Initialize it.
        //

        //
        // CODEWORK: It's bogus for us to set the valid signature
        // here. It should only be valid once the object is really
        // in use.
        //
        pIrpContext->Signature = UL_IRP_CONTEXT_SIGNATURE;

#if DBG
        pIrpContext->pCompletionRoutine = &UlDbgInvalidCompletionRoutine;
#endif

        ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );
    }

    return (PVOID)pIrpContext;

}   // UlAllocateIrpContextPool

/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_IRP_CONTEXT structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeIrpContextPool(
    IN PVOID pBuffer
    )
{
    PUL_IRP_CONTEXT pIrpContext;

    //
    // Sanity check.
    //

    pIrpContext = (PUL_IRP_CONTEXT)pBuffer;
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    //
    // Kill the signature, then free it.
    //

    pIrpContext->Signature = UL_IRP_CONTEXT_SIGNATURE_X;
    UL_FREE_POOL( pIrpContext, UL_IRP_CONTEXT_POOL_TAG );

}   // UlFreeIrpContextPool


/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_REQUEST_BUFFER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be DEFAULT_MAX_REQUEST_BUFFER_SIZE but is basically
        ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_REQUEST_BUFFER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateRequestBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_REQUEST_BUFFER pRequestBuffer;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == DEFAULT_MAX_REQUEST_BUFFER_SIZE );
    ASSERT( Tag == UL_REQUEST_BUFFER_POOL_TAG );

    //
    // Allocate the request buffer.
    //

    pRequestBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_REQUEST_BUFFER,
                        DEFAULT_MAX_REQUEST_BUFFER_SIZE,
                        UL_REQUEST_BUFFER_POOL_TAG
                        );

    if (pRequestBuffer != NULL)
    {
        //
        // Initialize it.
        //

        pRequestBuffer->Signature = MAKE_FREE_TAG(UL_REQUEST_BUFFER_POOL_TAG);
    }

    return (PVOID)pRequestBuffer;

}   // UlAllocateRequestBufferPool


/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_REQUEST_BUFFER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeRequestBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_REQUEST_BUFFER pRequestBuffer;

    //
    // Sanity check.
    //

    pRequestBuffer = (PUL_REQUEST_BUFFER)pBuffer;

    //
    // Kill the signature, then free it.
    //

    UL_FREE_POOL_WITH_SIG(pRequestBuffer, UL_REQUEST_BUFFER_POOL_TAG);

}   // UlFreeRequestBufferPool


/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_INTERNAL_REQUEST structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UL_INTERNAL_REQUEST) but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_INTERNAL_REQUEST_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateInternalRequestPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_INTERNAL_REQUEST pRequest;
    PUL_FULL_TRACKER pTracker;
    ULONG SpaceLength;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_INTERNAL_REQUEST) );
    ASSERT( Tag == UL_INTERNAL_REQUEST_POOL_TAG );

    //
    // Allocate the request buffer plus the default cooked URL buffer and
    // the full tracker plus the auxiliary buffer.
    //

    SpaceLength =
        g_UlFullTrackerSize +
        (g_UlMaxInternalUrlLength/sizeof(WCHAR) + 1) * sizeof(WCHAR);

    pRequest = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_INTERNAL_REQUEST,
                        SpaceLength,
                        UL_INTERNAL_REQUEST_POOL_TAG
                        );

    if (pRequest != NULL)
    {
        //
        // Initialize it.
        //

        pRequest->Signature = MAKE_FREE_TAG(UL_INTERNAL_REQUEST_POOL_TAG);

        pRequest->pTracker =
            (PUL_FULL_TRACKER)((PCHAR)pRequest +
                ALIGN_UP(sizeof(UL_INTERNAL_REQUEST), PVOID));

        pRequest->pUrlBuffer =
            (PWSTR)((PCHAR)pRequest->pTracker + g_UlFullTrackerSize);

        //
        // Initialize the fast/cache tracker.
        //

        pTracker = pRequest->pTracker;

        pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
        pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
        pTracker->IsFromLookaside = FALSE;
        pTracker->IsFromRequest = TRUE;
        pTracker->AuxilaryBufferLength =
            g_UlMaxFixedHeaderSize +
            g_UlMaxVariableHeaderSize +
            g_UlMaxCopyThreshold;

        UlInitializeFullTrackerPool( pTracker, DEFAULT_MAX_IRP_STACK_SIZE );
    }

    return (PVOID)pRequest;

}   // UlAllocateInternalRequestPool


/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_INTERNAL_REQUEST structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeInternalRequestPool(
    IN PVOID pBuffer
    )
{
    PUL_INTERNAL_REQUEST pRequest;

    //
    // Sanity check.
    //

    pRequest = (PUL_INTERNAL_REQUEST)pBuffer;

    //
    // Free the resource.
    //

    ASSERT( pRequest->Signature == MAKE_FREE_TAG(UL_INTERNAL_REQUEST_POOL_TAG));

    //
    // Kill the signature, then free it.
    //

    UL_FREE_POOL_WITH_SIG( pRequest, UL_INTERNAL_REQUEST_POOL_TAG );

}   // UlFreeInternalRequestPool


/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_CHUNK_TRACKER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be g_UlChunkTrackerSize but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_CHUNK_TRACKER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateChunkTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_CHUNK_TRACKER pTracker;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == g_UlChunkTrackerSize );
    ASSERT( Tag == UL_CHUNK_TRACKER_POOL_TAG );

    //
    // Allocate the tracker buffer.
    //

    pTracker = (PUL_CHUNK_TRACKER)UL_ALLOCATE_POOL(
                                    NonPagedPool,
                                    g_UlChunkTrackerSize,
                                    UL_CHUNK_TRACKER_POOL_TAG
                                    );

    if (pTracker != NULL)
    {
        pTracker->Signature = MAKE_FREE_TAG(UL_CHUNK_TRACKER_POOL_TAG);
        pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
        pTracker->IsFromLookaside = TRUE;

        //
        // Set up the IRP.
        //

        pTracker->pReadIrp =
            (PIRP)((PCHAR)pTracker +
                ALIGN_UP(sizeof(UL_CHUNK_TRACKER), PVOID));

        IoInitializeIrp(
            pTracker->pReadIrp,
            IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE),
            DEFAULT_MAX_IRP_STACK_SIZE
            );

        pTracker->pSendIrp =
            (PIRP)((PCHAR)pTracker->pReadIrp +
                ALIGN_UP(IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE), PVOID));

        IoInitializeIrp(
            pTracker->pSendIrp,
            IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE),
            DEFAULT_MAX_IRP_STACK_SIZE
            );

        //
        // Set up the variable header pointer.
        //

        pTracker->pVariableHeader =
            (PUCHAR)((PCHAR)pTracker->pSendIrp +
                ALIGN_UP(IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE), PVOID));
    }

    return pTracker;

}   // UlAllocateChunkTrackerPool


/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_CHUNK_TRACKER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeChunkTrackerPool(
    IN PVOID pBuffer
    )
{
    PUL_CHUNK_TRACKER pTracker = (PUL_CHUNK_TRACKER)pBuffer;

    UL_FREE_POOL_WITH_SIG( pTracker, UL_CHUNK_TRACKER_POOL_TAG );

}   // UlFreeChunkTrackerPool


/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_FULL_TRACKER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be g_UlFullTrackerSize but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_FULL_TRACKER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateFullTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_FULL_TRACKER pTracker;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == g_UlFullTrackerSize );
    ASSERT( Tag == UL_FULL_TRACKER_POOL_TAG );

    //
    // Allocate the tracker buffer.
    //

    pTracker = (PUL_FULL_TRACKER)UL_ALLOCATE_POOL(
                                    NonPagedPool,
                                    g_UlFullTrackerSize,
                                    UL_FULL_TRACKER_POOL_TAG
                                    );

    if (pTracker != NULL)
    {
        pTracker->Signature = MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG);
        pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
        pTracker->IsFromLookaside = TRUE;
        pTracker->IsFromRequest = FALSE;
        pTracker->AuxilaryBufferLength =
            g_UlMaxFixedHeaderSize +
            g_UlMaxVariableHeaderSize +
            g_UlMaxCopyThreshold;

        UlInitializeFullTrackerPool( pTracker, DEFAULT_MAX_IRP_STACK_SIZE );
    }

    return pTracker;

}   // UlAllocateFullTrackerPool


/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_FULL_TRACKER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeFullTrackerPool(
    IN PVOID pBuffer
    )
{
    PUL_FULL_TRACKER pTracker = (PUL_FULL_TRACKER)pBuffer;

    UL_FREE_POOL_WITH_SIG( pTracker, UL_FULL_TRACKER_POOL_TAG );

}   // UlFreeFullTrackerPool


/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_INTERNAL_RESPONSE structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be g_UlResponseBufferSize but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_INTERNAL_RESPONSE_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateResponseBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == g_UlResponseBufferSize );
    ASSERT( Tag == UL_INTERNAL_RESPONSE_POOL_TAG );

    //
    // Allocate the default internal response buffer.
    //

    return UL_ALLOCATE_POOL(
                NonPagedPool,
                g_UlResponseBufferSize,
                UL_INTERNAL_RESPONSE_POOL_TAG
                );

}   // UlAllocateResponseBufferPool


/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_INTERNAL_RESPONSE structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeResponseBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_INTERNAL_RESPONSE pResponseBuffer;

    pResponseBuffer = (PUL_INTERNAL_RESPONSE)pBuffer;

    UL_FREE_POOL_WITH_SIG( pResponseBuffer, UL_INTERNAL_RESPONSE_POOL_TAG );

}   // UlFreeResponseBufferPool


/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_FILE_LOG_BUFFER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be PagedPool.

    Byt