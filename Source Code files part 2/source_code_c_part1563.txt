f ((m_pPvcInfo->m_dwVci<MIN_VCI) || (m_pPvcInfo->m_dwVci>MAX_VCI))
    {
        // we pop up a message box and set focus to the vpi edit box
        NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_VCI,
                                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(GetDlgItem(IDC_EDT_PVC_VCI));
        return 0;
    }

    // make sure calling and called atm addresses are correct in format
    int i, nId;

    if (m_pPvcInfo->m_strCallingAddr != c_szEmpty)
    {
        if (!FIsValidAtmAddress((PWSTR)m_pPvcInfo->m_strCallingAddr.c_str(), &i, &nId))
        {
            // we pop up a message box and set focus to the calling address edit box
            NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_Calling_Address,
                                    MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            ::SetFocus(GetDlgItem(IDC_EDT_PVC_AnswerAddr));
            return 0;
        }
    }

    if (m_pPvcInfo->m_strCalledAddr != c_szEmpty)
    {
        if (!FIsValidAtmAddress((PWSTR)m_pPvcInfo->m_strCalledAddr.c_str(), &i, &nId))
        {
            // we pop up a message box and set focus to the calling address edit box
            NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_Called_Address,
                                    MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            ::SetFocus(GetDlgItem(IDC_EDT_PVC_CallAddr));
            return 0;
        }
    }

    // set the modified bit
    if (!m_fDialogModified)
    {
        if ((m_pPvcInfo->m_dwVpi != m_pPvcInfo->m_dwOldVpi) ||
            (m_pPvcInfo->m_dwVci != m_pPvcInfo->m_dwOldVci) ||
            (m_pPvcInfo->m_dwAAL != m_pPvcInfo->m_dwOldAAL) ||
            (m_pPvcInfo->m_strCallingAddr != m_pPvcInfo->m_strCallingAddr) ||
            (m_pPvcInfo->m_strCalledAddr  != m_pPvcInfo->m_strOldCalledAddr)
           )
        {
            m_fDialogModified = TRUE;
        }
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CPVCMainDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CPVCMainDialog::OnType(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    // $REVIEW(tongl 2/27/98): confirmed this behaviour with ArvindM
    // When type changes, we reset all the type related defaults
    // to match the new type ...

    // get the new selection
    int idx = SendDlgItemMessage(IDC_CMB_PVC_Type, CB_GETCURSEL, (LPARAM)(0), 0);
    if (idx != CB_ERR)
    {
        if (idx != m_CurType-1) // type has changed
        {
            UpdateInfo();
            m_CurType = (PVCType)(idx+1);
            m_pPvcInfo->SetTypeDefaults(m_CurType);

            // update the UI
            SetInfo();
        }
    }
    return 0;
}

LRESULT CPVCMainDialog::OnSpecifyCallAddr(WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    if (IsDlgButtonChecked(IDC_CHK_PVC_CallAddr))
    {
        // enable the calling address control
        ::EnableWindow(GetDlgItem(IDC_EDT_PVC_CallAddr), TRUE);
    }
    else
    {
        // disable the control
        ::EnableWindow(GetDlgItem(IDC_EDT_PVC_CallAddr), FALSE);
    }

    return 0;
}

LRESULT CPVCMainDialog::OnSpecifyAnswerAddr(WORD wNotifyCode, WORD wID,
                                            HWND hWndCtl, BOOL& fHandled)
{
    if (IsDlgButtonChecked(IDC_CHK_PVC_AnswerAddr))
    {
        // enable the calling address control
        ::EnableWindow(GetDlgItem(IDC_EDT_PVC_AnswerAddr), TRUE);
    }
    else
    {
        // disable the control
        ::EnableWindow(GetDlgItem(IDC_EDT_PVC_AnswerAddr), FALSE);
    }

    return 0;
}

LRESULT CPVCMainDialog::OnAdvanced(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        // Make a copy of the current PVC info and pass to the
        // advanced property sheet pages

        // get what's in the main UI to in memory structure
        UpdateInfo();

        CPvcInfo * pPvcInfoDlg = new CPvcInfo(m_pPvcInfo->m_strPvcId.c_str());

        if (pPvcInfoDlg)
        {
			*pPvcInfoDlg = *m_pPvcInfo;

			// Bring up the advanced PVC property sheet
			HRESULT hr = HrDoPvcPropertySheet(pPvcInfoDlg);
			if (S_OK == hr)
			{
				if (m_fPropShtOk && m_fPropShtModified)
				{
					// Something changed, so mark the page as modified
					m_fDialogModified = TRUE;

					// Reset values
					m_fPropShtOk = FALSE;
					m_fPropShtModified = FALSE;

					// Update second memory info structure
					*m_pPvcInfo = *pPvcInfoDlg;
				}
			}

			delete pPvcInfoDlg;
        }
        break;
    }

    return 0;
}

HRESULT CPVCMainDialog::HrDoPvcPropertySheet(CPvcInfo * pPvcInfoDlg)
{
    Assert(pPvcInfoDlg);
    HRESULT hr = S_OK;

    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    // Create property pages
    hr = HrSetupPropPages(pPvcInfoDlg, &ahpsp, &cPages);
    if (SUCCEEDED(hr))
    {
        // Show the property sheet
        PROPSHEETHEADER psh = {0};

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_NOAPPLYNOW;
        psh.hwndParent = ::GetActiveWindow();
        psh.hInstance = _Module.GetModuleInstance();
        psh.pszIcon = NULL;
        psh.pszCaption = (PWSTR)SzLoadIds(IDS_ADV_PVC_HEADER);
        psh.nPages = cPages;
        psh.phpage = ahpsp;

        int iRet = PropertySheet(&psh);
        if (-1 == iRet)
        {
            hr = HrFromLastWin32Error();
        }

        CoTaskMemFree(ahpsp);
    }

    TraceError("CPVCMainDialog::DoPropertySheet", hr);
    return hr;
}

HRESULT CPVCMainDialog::HrSetupPropPages( CPvcInfo * pPvcInfoDlg,
                                          HPROPSHEETPAGE ** pahpsp,
                                          INT * pcPages)
{
    HRESULT hr = S_OK;

    *pahpsp = NULL;
    *pcPages = 0;

    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    delete (m_pQosPage);
    m_pQosPage    = NULL;

    delete (m_pLocalPage);
    m_pLocalPage  = NULL;

    delete (m_pDestPage);
    m_pDestPage   = NULL;

    // Set up the property pages
    m_pQosPage = new CPvcQosPage(this, pPvcInfoDlg, g_aHelpIDs_IDD_PVC_Traffic);
    if (!m_pQosPage)
    {
        return E_OUTOFMEMORY;
    }

    cPages = 1;

    if (m_pPvcInfo->m_dwPVCType == PVC_CUSTOM)
    {
        m_pLocalPage  = new CPvcLocalPage(this, pPvcInfoDlg, g_aHelpIDs_IDD_PVC_Local);
        if (!m_pLocalPage)
        {
            return E_OUTOFMEMORY;
        }

        m_pDestPage   = new CPvcDestPage(this, pPvcInfoDlg, g_aHelpIDs_IDD_PVC_Dest);
        if (!m_pDestPage)
        {
            return E_OUTOFMEMORY;
        }

        cPages = 3;
    }

    // Allocate a buffer large enough to hold the handles to all of our
    // property pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)* cPages);
    if (!ahpsp)
    {
        return E_OUTOFMEMORY;
    }

    cPages =0;

    ahpsp[cPages++] = m_pQosPage->CreatePage(IDD_PVC_Traffic, 0);

    if (m_pPvcInfo->m_dwPVCType == PVC_CUSTOM)
    {
        ahpsp[cPages++] = m_pLocalPage->CreatePage(IDD_PVC_Local, 0);
        ahpsp[cPages++] = m_pDestPage->CreatePage(IDD_PVC_Dest, 0);
    }

    *pahpsp = ahpsp;
    *pcPages = cPages;

    return hr;
}

void CPVCMainDialog::InitInfo()
{
    // set limits & selections to the controls

    // PVC name
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_Name), EM_SETLIMITTEXT, MAX_PATH, 0);

    // VPI
    // length limit
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_VPI), EM_SETLIMITTEXT, MAX_VPI_LENGTH, 0);

    // VCI
    // length limit
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_VCI), EM_SETLIMITTEXT, MAX_VCI_LENGTH, 0);

    // AAL TYpe
    // $REVIEW(tongl 2/24/98): per ArvindM, only AAL5 is supported in NT5
    SendDlgItemMessage(IDC_CMB_PVC_AAL,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_AAL5)));

    // PVC_TYPE
    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_ATMARP)));

    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_PPP_ATM_CLIENT)));

    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_PPP_ATM_SERVER)));

    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_CUSTOM)));
}

void CPVCMainDialog::SetInfo()
{
    // Name
    SetDlgItemText(IDC_EDT_PVC_Name, m_pPvcInfo->m_strName.c_str());

    // VPI
    WCHAR szVpi[MAX_VPI_LENGTH+1];
    wsprintfW(szVpi, c_szItoa, m_pPvcInfo->m_dwVpi);
    SetDlgItemText(IDC_EDT_PVC_VPI, szVpi);

    // VCI
    if (FIELD_UNSET != m_pPvcInfo->m_dwVci)
    {
        WCHAR szVci[MAX_VCI_LENGTH+1];
        wsprintfW(szVci, c_szItoa, m_pPvcInfo->m_dwVci);
        SetDlgItemText(IDC_EDT_PVC_VCI, szVci);
    }

    // AAL TYpe
    SendDlgItemMessage(IDC_CMB_PVC_AAL,
                       CB_SETCURSEL, (LPARAM)(0), 0);

    // PVC_TYPE
    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_SETCURSEL, (LPARAM)(m_pPvcInfo->m_dwPVCType-1), 0);

    // calling addresses
    BOOL fAddrSpecified = (m_pPvcInfo->m_strCalledAddr != c_szEmpty);

    ::EnableWindow(GetDlgItem(IDC_CHK_PVC_CallAddr), TRUE);
    CheckDlgButton(IDC_CHK_PVC_CallAddr, fAddrSpecified);

    ::EnableWindow(GetDlgItem(IDC_EDT_PVC_CallAddr), fAddrSpecified);

    if (fAddrSpecified)
    {
        SetDlgItemText(IDC_EDT_PVC_CallAddr, m_pPvcInfo->m_strCalledAddr.c_str());
    }

    // answering address
    fAddrSpecified = (m_pPvcInfo->m_strCallingAddr != c_szEmpty);

    ::EnableWindow(GetDlgItem(IDC_CHK_PVC_AnswerAddr), TRUE);
    CheckDlgButton(IDC_CHK_PVC_AnswerAddr, fAddrSpecified);

    ::EnableWindow(GetDlgItem(IDC_EDT_PVC_AnswerAddr), fAddrSpecified);

    if (fAddrSpecified)
    {
        SetDlgItemText(IDC_EDT_PVC_AnswerAddr, m_pPvcInfo->m_strCallingAddr.c_str());
    }

    // disable the calling address\answer address controls if the type is ATMARP
    // Bug #179335
    if (m_pPvcInfo->m_dwPVCType == PVC_ATMARP)
    {
        // disable all controls on this doalog
        static const int nrgIdc[] = {IDC_CHK_PVC_CallAddr,
                                     IDC_EDT_PVC_CallAddr,
                                     IDC_CHK_PVC_AnswerAddr,
                                     IDC_EDT_PVC_AnswerAddr};

        EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);
    }
}

// Update the in memory structure with what's in the dialog
void CPVCMainDialog::UpdateInfo()
{
    WCHAR szBuf[MAX_PATH];

    // Name
    GetDlgItemText(IDC_EDT_PVC_Name, szBuf, MAX_PATH);
    m_pPvcInfo->m_strName = szBuf;

    // VPI
    GetDlgItemText(IDC_EDT_PVC_VPI, szBuf, MAX_VPI_LENGTH+1);
    m_pPvcInfo->m_dwVpi = _wtoi(szBuf);

    // VCI
    GetDlgItemText(IDC_EDT_PVC_VCI, szBuf, MAX_VCI_LENGTH+1);
    if (*szBuf ==0) // empty string
    {
        m_pPvcInfo->m_dwVci = FIELD_UNSET;
    }
    else
    {
        m_pPvcInfo->m_dwVci = _wtoi(szBuf);
    }

    // current selection
    int idx = SendDlgItemMessage(IDC_CMB_PVC_Type, CB_GETCURSEL, (LPARAM)(0), 0);
    if (idx != CB_ERR)
    {
        m_pPvcInfo->m_dwPVCType = (PVCType)(idx+1);
    }

    // calling addresses
    if (!IsDlgButtonChecked(IDC_CHK_PVC_CallAddr))
    {
        m_pPvcInfo->m_strCalledAddr = c_szEmpty;
    }
    else
    {
        GetDlgItemText(IDC_EDT_PVC_CallAddr, szBuf, MAX_ATM_ADDRESS_LENGTH+1);
        m_pPvcInfo->m_strCalledAddr = szBuf;
    }

    // answering address
    if (!IsDlgButtonChecked(IDC_CHK_PVC_AnswerAddr))
    {
        m_pPvcInfo->m_strCallingAddr = c_szEmpty;
    }
    else
    {
        GetDlgItemText(IDC_EDT_PVC_AnswerAddr, szBuf, MAX_ATM_ADDRESS_LENGTH+1);
        m_pPvcInfo->m_strCallingAddr = szBuf;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\resource.h ===
#include "ncres.h"

#define IDS_DESC_COMOBJ_AUNICFG         IDS_NC_ATMCFG + 0
#define IDS_DESC_COMOBJ_ARPSCFG         IDS_NC_ATMCFG + 1
#define IDS_DESC_COMOBJ_RWANCFG         IDS_NC_ATMCFG + 2
#define IDS_MSFT_ARPS_TEXT              IDS_NC_ATMCFG + 3
#define IDS_ARPS_NO_BOUND_CARDS         IDS_NC_ATMCFG + 4
#define IDS_IPADDRESS_FROM              IDS_NC_ATMCFG + 5
#define IDS_IPADDRESS_TO                IDS_NC_ATMCFG + 6
#define IDS_NO_ITEM_SELECTED            IDS_NC_ATMCFG + 7
#define IDS_INVALID_ATM_ADDRESS         IDS_NC_ATMCFG + 8
#define IDS_INCORRECT_IPRANGE           IDS_NC_ATMCFG + 9

#define IDS_MSFT_UNI_TEXT               IDS_NC_ATMCFG + 10
#define IDS_UNI_NO_BOUND_CARDS          IDS_NC_ATMCFG + 11
#define IDS_PVC_UNSPECIFIED_NAME        IDS_NC_ATMCFG + 12
#define IDS_PVC_AAL5                    IDS_NC_ATMCFG + 13
#define IDS_PVC_ATMARP                  IDS_NC_ATMCFG + 14
#define IDS_PVC_PPP_ATM_CLIENT          IDS_NC_ATMCFG + 15
#define IDS_PVC_PPP_ATM_SERVER          IDS_NC_ATMCFG + 16
#define IDS_PVC_CUSTOM                  IDS_NC_ATMCFG + 17

#define IDS_DUPLICATE_REG_ADDR          IDS_NC_ATMCFG + 18
#define IDS_OVERLAP_MUL_ADDR            IDS_NC_ATMCFG + 19

#define IDS_PVC_NAME                    IDS_NC_ATMCFG + 20
#define IDS_PVC_VPI                     IDS_NC_ATMCFG + 21
#define IDS_PVC_VCI                     IDS_NC_ATMCFG + 22
#define IDS_INVALID_VPI                 IDS_NC_ATMCFG + 23
#define IDS_INVALID_VCI                 IDS_NC_ATMCFG + 24
#define IDS_INVALID_Calling_Address     IDS_NC_ATMCFG + 25
#define IDS_INVALID_Called_Address      IDS_NC_ATMCFG + 26
#define IDS_ADV_PVC_HEADER              IDS_NC_ATMCFG + 27

#define IDS_PVC_Layer2_1                IDS_NC_ATMCFG + 31
#define IDS_PVC_Layer2_2                IDS_NC_ATMCFG + 32
#define IDS_PVC_Layer2_6                IDS_NC_ATMCFG + 33
#define IDS_PVC_Layer2_7                IDS_NC_ATMCFG + 34
#define IDS_PVC_Layer2_8                IDS_NC_ATMCFG + 35
#define IDS_PVC_Layer2_9                IDS_NC_ATMCFG + 36
#define IDS_PVC_Layer2_10               IDS_NC_ATMCFG + 37
#define IDS_PVC_Layer2_11               IDS_NC_ATMCFG + 38
#define IDS_PVC_Layer2_12               IDS_NC_ATMCFG + 39
#define IDS_PVC_Layer2_13               IDS_NC_ATMCFG + 40
#define IDS_PVC_Layer2_14               IDS_NC_ATMCFG + 41
#define IDS_PVC_Layer2_16               IDS_NC_ATMCFG + 42
#define IDS_PVC_Layer2_17               IDS_NC_ATMCFG + 43

#define IDS_PVC_Layer3_6                IDS_NC_ATMCFG + 44
#define IDS_PVC_Layer3_7                IDS_NC_ATMCFG + 45
#define IDS_PVC_Layer3_8                IDS_NC_ATMCFG + 46
#define IDS_PVC_Layer3_9                IDS_NC_ATMCFG + 47
#define IDS_PVC_Layer3_10               IDS_NC_ATMCFG + 48
#define IDS_PVC_Layer3_11               IDS_NC_ATMCFG + 49
#define IDS_PVC_Layer3_16               IDS_NC_ATMCFG + 50
     
#define IDS_PVC_HighLayer_0             IDS_NC_ATMCFG + 51
#define IDS_PVC_HighLayer_1             IDS_NC_ATMCFG + 52
#define IDS_PVC_HighLayer_3             IDS_NC_ATMCFG + 53

#define IDS_PVC_Any                     IDS_NC_ATMCFG + 54
#define IDS_PVC_Absent                  IDS_NC_ATMCFG + 55

#define IDS_PVC_CBR                     IDS_NC_ATMCFG + 56
#define IDS_PVC_VBR                     IDS_NC_ATMCFG + 57
#define IDS_PVC_UBR                     IDS_NC_ATMCFG + 58
#define IDS_PVC_ABR                     IDS_NC_ATMCFG + 59

#define IDS_INVALID_Layer2_Protocol     IDS_NC_ATMCFG + 60
#define IDS_INVALID_Layer2_UserSpec     IDS_NC_ATMCFG + 61
#define IDS_INVALID_Layer3_Protocol     IDS_NC_ATMCFG + 62
#define IDS_INVALID_Layer3_UserSpec     IDS_NC_ATMCFG + 63
#define IDS_INVALID_Layer3_IPI          IDS_NC_ATMCFG + 64
#define IDS_INVALID_Highlayer_Type      IDS_NC_ATMCFG + 65
#define IDS_INVALID_SnapId              IDS_NC_ATMCFG + 66
#define IDS_INVALID_HighLayerValue      IDS_NC_ATMCFG + 67

#define IDS_INVALID_QOS_VALUE           IDS_NC_ATMCFG + 68

#define IDS_DUPLICATE_PVC               IDS_NC_ATMCFG + 70

#define IDD_ARPS_PROP                   1000
#define IDD_ARPS_REG_ADDR               1001
#define IDD_ARPS_MUL_ADDR               1002
#define IDD_UNI_PROP                    1003
#define IDD_PVC_Main                    1004
#define IDD_PVC_Traffic                 1005
#define IDD_PVC_Local                   1006
#define IDD_PVC_Dest                    1007

// ARP server property page
#define IDC_LVW_ARPS_REG_ADDR           210
#define IDC_PSH_ARPS_REG_ADD            211
#define IDC_PSH_ARPS_REG_EDT            212
#define IDC_PSH_ARPS_REG_RMV            213
#define IDC_LVW_ARPS_MUL_ADDR           214
#define IDC_PSH_ARPS_MUL_ADD            215
#define IDC_PSH_ARPS_MUL_EDT            216
#define IDC_PSH_ARPS_MUL_RMV            217
#define IDC_EDT_ARPS_REG_Address        218
#define IDC_ARPS_MUL_LOWER_IP           219
#define IDC_ARPS_MUL_UPPER_IP           220

// UNI property page
#define IDC_LVW_PVC_LIST                230
#define IDC_PBN_PVC_Add                 231
#define IDC_PBN_PVC_Remove              232
#define IDC_PBN_PVC_Properties          233

// PVC Main page
#define IDC_EDT_PVC_Name                235
#define IDC_EDT_PVC_VPI                 236
#define IDC_EDT_PVC_VCI                 237
#define IDC_CMB_PVC_AAL                 238

#define IDC_CMB_PVC_Type                239
#define IDC_CHK_PVC_CallAddr            240
#define IDC_EDT_PVC_CallAddr            241
#define IDC_CHK_PVC_AnswerAddr          242
#define IDC_EDT_PVC_AnswerAddr          243

#define IDC_PBN_PVC_Advanced            244

// PVC Advanced page: Traffic Page
#define IDC_EDT_PVC_TRANS_PEAK          250
#define IDC_EDT_PVC_TRANS_AVG           251
#define IDC_EDT_PVC_TRANS_BURST         252
#define IDC_EDT_PVC_TRANS_MAX_SIZE      253
#define IDC_CMB_PVC_TRANS_SERVICE       254

#define IDC_EDT_PVC_RECEIVE_PEAK        255
#define IDC_EDT_PVC_RECEIVE_AVG         256
#define IDC_EDT_PVC_RECEIVE_BURST       257
#define IDC_EDT_PVC_RECEIVE_MAX_SIZE    258
#define IDC_CMB_PVC_RECEIVE_SERVICE     259

// PVC Advanced page: Local & Dest BLLI & BHLI
#define IDC_CMB_PVC_Layer2              260                    
#define IDC_EDT_PVC_User_Layer2         261
#define IDC_CMB_PVC_Layer3              262
#define IDC_EDT_PVC_User_Layer3         263
#define IDC_EDT_PVC_Layer3_IPI          264
#define IDC_EDT_PVC_SNAP_ID             265

#define IDC_CMB_PVC_High_Type           266
#define IDC_CMB_PVC_High_Value          267
#define IDC_TXT_PVC_Value               268
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\auniobj.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I O B J . H
//
//  Contents:   CAtmUniCfg interface declaration
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"
#include "atmutil.h"
#include "pvcdata.h"

// Constants
static const WCHAR c_szPVC[] = L"PVC";

// Reg key value names ( non-configurable parameters )
static const WCHAR c_szMaxActiveSVCs[]          = L"MaxActiveSVCs";
static const WCHAR c_szMaxSVCsInProgress[]      = L"MaxSVCsInProgress";
static const WCHAR c_szMaxPMPSVCs[]             = L"MaxPMPSVCs";
static const WCHAR c_szMaxActiveParties[]       = L"MaxActiveParties";
static const WCHAR c_szMaxPartiesInProgress[]   = L"MaxPartiesInProgress";

// Default Reg key values ( non-configurable parameters )
static const c_dwWksMaxActiveSVCs = 256;
static const c_dwSrvMaxActiveSVCs = 1024;

static const c_dwWksMaxSVCsInProgress = 8;
static const c_dwSrvMaxSVCsInProgress = 32;

static const c_dwWksMaxPMPSVCs = 32;
static const c_dwSrvMaxPMPSVCs = 64;

static const c_dwWksMaxActiveParties = 64;
static const c_dwSrvMaxActiveParties = 512;

static const c_dwWksMaxPartiesInProgress = 8;
static const c_dwSrvMaxPartiesInProgress = 32;

// number of property sheet pages
static const INT c_cUniPages = 1;

/////////////////////////////////////////////////////////////////////////////
// CAtmUniCfg

class ATL_NO_VTABLE CAtmUniCfg :
    public CComObjectRoot,
    public CComCoClass<CAtmUniCfg, &CLSID_CAtmUniCfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentPropertyUi
{
public:
    CAtmUniCfg();
    ~CAtmUniCfg();

    BEGIN_COM_MAP(CAtmUniCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CAtmUniCfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_AUNICFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)         (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)         (DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo );
    STDMETHOD (ReadAnswerFile)  (PCWSTR pszAnswerFile,
                                 PCWSTR pszAnswerSection);
    STDMETHOD (Removing)();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk);
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// help functions
    CUniAdapterInfo * GetSecondMemoryAdapterInfo()
    {
        return m_pSecondMemoryAdapterInfo;
    }

    void SetSecondMemoryModified()
    {
        m_fSecondMemoryModified = TRUE;
    }

private:
    // Place to keep the INetCfg pointer
    INetCfg * m_pnc;

    // Place to keep corresponding component object
    INetCfgComponent *  m_pnccUni;
    INetCfgComponent *  m_pnccRwan;

    // Place to keep the pointer to UI context
    IUnknown * m_pUnkContext;

    // (STL) List of adapter info structures
    UNI_ADAPTER_LIST    m_listAdapters;

    // Guid of the current connection
    tstring m_strGuidConn;

    // Second memory adapter info structures
    CUniAdapterInfo *   m_pSecondMemoryAdapterInfo;

    // Do we need to update registry on Apply
    BOOL    m_fSaveRegistry;
    BOOL    m_fUIParamChanged;

    BOOL    m_fSecondMemoryModified;

    // property page
    class CUniPage * m_uniPage;

    // Load parameters from registry
    HRESULT HrLoadSettings();

    // Save parameters to registry
    HRESULT HrSaveSettings();

    // Add/Remove adapters from first memory state
    HRESULT HrAddAdapter(INetCfgComponent * pncc);
    HRESULT HrRemoveAdapter(INetCfgComponent * pncc);

    HRESULT HrBindAdapter(INetCfgComponent * pnccAdapter);
    HRESULT HrUnBindAdapter(INetCfgComponent * pnccAdapter);

    // Set defaults for statis parameters
    HRESULT HrSaveDefaultSVCParam(HKEY hkey);

    // Check if a card guid string is on m_listAdapters
    BOOL fIsAdapterOnList(PCWSTR pszBindName, CUniAdapterInfo ** ppAdapterInfo);

    HRESULT HrSetConnectionContext();

    HRESULT HrSetupPropSheets(HPROPSHEETPAGE ** pahpsp, INT * pcPages);

    // Have we already load PVC info into memory
    BOOL    m_fPVCInfoLoaded;

    // load and save adapter PVC info to first memory
    HRESULT HrLoadPVCRegistry();
    HRESULT HrLoadAdapterPVCRegistry(HKEY hkeyAdapterParam, CUniAdapterInfo * pAdapterInfo);
    HRESULT HrSaveAdapterPVCRegistry(HKEY hkeyAdapterParam, CUniAdapterInfo * pAdapterInfo);

    // load and save adapter parameters to second memory
    HRESULT HrLoadAdapterPVCInfo();
    HRESULT HrSaveAdapterPVCInfo();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\qosdlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      Q O S D L G . C P P
//
//  Contents:  PVC Qos property pages message handler implementation
//
//  Notes:
//
//  Author:     tongl   1 Mar, 1998
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "auniobj.h"
#include "atmutil.h"
#include "aunidlg.h"
//#include "atmcommon.h"

#include "ncatlui.h"
#include "ncstl.h"
//#include "ncui.h"

const int MAX_QOS_SPEED = 6;
const int MAX_QOS_SIZE  = 5;
const int MAX_DATA = 65535;

//
// CPvcQosPage
//

CPvcQosPage::CPvcQosPage(CPVCMainDialog * pParentDlg,
                         CPvcInfo * pPvcInfo, const DWORD * adwHelpIDs )
{
    Assert(pPvcInfo);
    Assert(pParentDlg);

    m_pParentDlg = pParentDlg;
    m_pPvcInfo = pPvcInfo;
    m_adwHelpIDs = adwHelpIDs;
}

CPvcQosPage::~CPvcQosPage()
{
}

// Command handlers
LRESULT CPvcQosPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& bHandled)
{
    // set length limit

    ::SendMessage(GetDlgItem(IDC_EDT_PVC_TRANS_PEAK), EM_SETLIMITTEXT, MAX_QOS_SPEED, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_TRANS_AVG), EM_SETLIMITTEXT, MAX_QOS_SPEED, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_RECEIVE_PEAK), EM_SETLIMITTEXT, MAX_QOS_SPEED, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_RECEIVE_AVG), EM_SETLIMITTEXT, MAX_QOS_SPEED, 0);

    ::SendMessage(GetDlgItem(IDC_EDT_PVC_TRANS_BURST), EM_SETLIMITTEXT, MAX_QOS_SIZE, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_TRANS_MAX_SIZE), EM_SETLIMITTEXT, MAX_QOS_SIZE, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_RECEIVE_BURST), EM_SETLIMITTEXT, MAX_QOS_SIZE, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_RECEIVE_MAX_SIZE), EM_SETLIMITTEXT, MAX_QOS_SIZE, 0);

    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwTransmitPeakCellRate,       IDC_EDT_PVC_TRANS_PEAK);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwTransmitAvgCellRate,        IDC_EDT_PVC_TRANS_AVG);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwTransmitByteBurstLength,    IDC_EDT_PVC_TRANS_BURST);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwTransmitMaxSduSize,         IDC_EDT_PVC_TRANS_MAX_SIZE);

    SetQosServiceCategory(m_pPvcInfo->m_dwTransmitServiceCategory, IDC_CMB_PVC_TRANS_SERVICE);

    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwReceivePeakCellRate,        IDC_EDT_PVC_RECEIVE_PEAK);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwReceiveAvgCellRate,         IDC_EDT_PVC_RECEIVE_AVG);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwReceiveByteBurstLength,     IDC_EDT_PVC_RECEIVE_BURST);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwReceiveMaxSduSize,          IDC_EDT_PVC_RECEIVE_MAX_SIZE);

    SetQosServiceCategory(m_pPvcInfo->m_dwReceiveServiceCategory, IDC_CMB_PVC_RECEIVE_SERVICE);

    // reset the "old" value so we know if anythign has changed
    m_pPvcInfo->m_dwOldTransmitPeakCellRate     = m_pPvcInfo->m_dwTransmitPeakCellRate;
    m_pPvcInfo->m_dwOldTransmitAvgCellRate      = m_pPvcInfo->m_dwTransmitAvgCellRate;
    m_pPvcInfo->m_dwOldTransmitByteBurstLength  = m_pPvcInfo->m_dwTransmitByteBurstLength;
    m_pPvcInfo->m_dwOldTransmitMaxSduSize       = m_pPvcInfo->m_dwTransmitMaxSduSize;
    m_pPvcInfo->m_dwOldTransmitServiceCategory  = m_pPvcInfo->m_dwTransmitServiceCategory;

    m_pPvcInfo->m_dwOldReceivePeakCellRate      = m_pPvcInfo->m_dwReceivePeakCellRate;
    m_pPvcInfo->m_dwOldReceiveAvgCellRate       = m_pPvcInfo->m_dwReceiveAvgCellRate;
    m_pPvcInfo->m_dwOldReceiveByteBurstLength   = m_pPvcInfo->m_dwReceiveByteBurstLength;
    m_pPvcInfo->m_dwOldReceiveMaxSduSize        = m_pPvcInfo->m_dwReceiveMaxSduSize;
    m_pPvcInfo->m_dwOldReceiveServiceCategory   = m_pPvcInfo->m_dwReceiveServiceCategory;

    return 0;
}

void CPvcQosPage::SetQosServiceCategory(ATM_SERVICE_CATEGORY dwServiceType, int nIDDlgItem)
{
    // insert the selections
    SendDlgItemMessage(nIDDlgItem,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_CBR)));

    SendDlgItemMessage(nIDDlgItem,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_VBR)));

    SendDlgItemMessage(nIDDlgItem,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_UBR)));

    SendDlgItemMessage(nIDDlgItem,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_ABR)));

    // set the current selection
    int idx =0;

    switch(dwServiceType)
    {
    case ATM_SERVICE_CATEGORY_CBR:
        idx =0;
        break;

    case ATM_SERVICE_CATEGORY_VBR:
        idx =1;
        break;

    case ATM_SERVICE_CATEGORY_UBR:
        idx =2;
        break;

    case ATM_SERVICE_CATEGORY_ABR:
        idx =3;
        break;
    }

    SendDlgItemMessage(nIDDlgItem, CB_SETCURSEL, (LPARAM)(idx), 0);
}

LRESULT CPvcQosPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CPvcQosPage::OnHelp(UINT uMsg, WPARAM wParam,
                            LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CPvcQosPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwTransmitPeakCellRate),       IDC_EDT_PVC_TRANS_PEAK);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwTransmitAvgCellRate),        IDC_EDT_PVC_TRANS_AVG);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwTransmitByteBurstLength),    IDC_EDT_PVC_TRANS_BURST);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwTransmitMaxSduSize),         IDC_EDT_PVC_TRANS_MAX_SIZE);

    GetQosServiceCategory(&(m_pPvcInfo->m_dwTransmitServiceCategory), IDC_CMB_PVC_TRANS_SERVICE);

    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwReceivePeakCellRate),        IDC_EDT_PVC_RECEIVE_PEAK);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwReceiveAvgCellRate),         IDC_EDT_PVC_RECEIVE_AVG);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwReceiveByteBurstLength),     IDC_EDT_PVC_RECEIVE_BURST);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwReceiveMaxSduSize),          IDC_EDT_PVC_RECEIVE_MAX_SIZE);

    GetQosServiceCategory(&(m_pPvcInfo->m_dwReceiveServiceCategory), IDC_CMB_PVC_RECEIVE_SERVICE);

    m_pParentDlg->m_fPropShtOk = TRUE;

    // did any qos field change ?
    if ((m_pPvcInfo->m_dwTransmitPeakCellRate   != m_pPvcInfo->m_dwOldTransmitPeakCellRate) ||
        (m_pPvcInfo->m_dwTransmitAvgCellRate    != m_pPvcInfo->m_dwOldTransmitAvgCellRate) ||
        (m_pPvcInfo->m_dwTransmitByteBurstLength!= m_pPvcInfo->m_dwOldTransmitByteBurstLength) ||
        (m_pPvcInfo->m_dwTransmitMaxSduSize     != m_pPvcInfo->m_dwOldTransmitMaxSduSize) ||
        (m_pPvcInfo->m_dwTransmitServiceCategory!= m_pPvcInfo->m_dwOldTransmitServiceCategory) ||

        (m_pPvcInfo->m_dwReceivePeakCellRate != m_pPvcInfo->m_dwOldReceivePeakCellRate) ||
        (m_pPvcInfo->m_dwReceiveAvgCellRate != m_pPvcInfo->m_dwOldReceiveAvgCellRate) ||
        (m_pPvcInfo->m_dwReceiveByteBurstLength != m_pPvcInfo->m_dwOldReceiveByteBurstLength) ||
        (m_pPvcInfo->m_dwReceiveMaxSduSize != m_pPvcInfo->m_dwOldReceiveMaxSduSize) ||
        (m_pPvcInfo->m_dwReceiveServiceCategory != m_pPvcInfo->m_dwOldReceiveServiceCategory)
       )
        m_pParentDlg->m_fPropShtModified = TRUE;

    return 0;
}

void CPvcQosPage::GetQosServiceCategory(ATM_SERVICE_CATEGORY * pdwServiceType, int nIDDlgItem)
{
    // set the current selection
    int idx = SendDlgItemMessage(nIDDlgItem, CB_GETCURSEL, (LPARAM)(0), 0);

    if (idx != CB_ERR)
    {
        switch(idx)
        {
        case 0:
            *pdwServiceType = ATM_SERVICE_CATEGORY_CBR;
            break;

        case 1:
            *pdwServiceType = ATM_SERVICE_CATEGORY_VBR;
            break;

        case 2:
            *pdwServiceType = ATM_SERVICE_CATEGORY_UBR;
            break;

        case 3:
            *pdwServiceType = ATM_SERVICE_CATEGORY_ABR;
            break;
        }
    }
}

LRESULT CPvcQosPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL err = FALSE; // Allow page to lose active status

    // (#293160): Max Burst lengths and Max Data Sizes are limited to 65535
    // disable all buttons on this dialog
    static const int nrgIdc[] = {IDC_EDT_PVC_TRANS_BURST,
                                 IDC_EDT_PVC_TRANS_MAX_SIZE,
                                 IDC_EDT_PVC_RECEIVE_BURST,
                                 IDC_EDT_PVC_RECEIVE_MAX_SIZE
                                };
    int ccid = celems(nrgIdc);
    const INT* pId=nrgIdc;

    DWORD dwData;

    while (ccid--)
    {
        GetDwordEdtField(m_hWnd, &dwData, *pId);
        if ((dwData != FIELD_UNSET) && (dwData > MAX_DATA))
        {
            // we pop up a message box and set focus to the edit box
            NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_QOS_VALUE,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            ::SetFocus(GetDlgItem(*pId));
            err = TRUE;
            break;
        }
        pId++;
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CPvcQosPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CPvcQosPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

void SetDwordEdtField(HWND hDlg, DWORD dwData, int nIDDlgItem)
{
    if (dwData != FIELD_UNSET)
    {
        WCHAR szBuf[MAX_PATH];
        wsprintfW(szBuf, c_szItoa, dwData);
        SetDlgItemText(hDlg, nIDDlgItem, szBuf);
    }
}

void GetDwordEdtField(HWND hDlg, DWORD * pdwData, int nIDDlgItem)
{
    WCHAR szBuf[MAX_PATH];

    GetDlgItemText(hDlg, nIDDlgItem, szBuf, MAX_PATH);
    if (*szBuf ==0) // empty string
    {
        *pdwData = FIELD_UNSET;
    }
    else
    {
        *pdwData = _wtoi(szBuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\pvcdata.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P V C D A T A. H
//
//  Contents:   PVC parameters
//
//  Notes:
//
//  Author:     tongl   20 Feb, 1998
//
//-----------------------------------------------------------------------
#pragma once

#define FIELD_ANY           ((ULONG)0xffffffff)
#define FIELD_ABSENT        ((ULONG)0xfffffffe)

#define FIELD_UNSET         ((ULONG)0xfffffffd)

const int c_iCellSize = 48;
const int c_iKbSize = 1000;

const DWORD c_dwDefTransmitByteBurstLength = 9188;
const DWORD c_dwDefTransmitMaxSduSize = 9188;

static const WCHAR c_szDefaultCallingAtmAddr[] =
            L"0000000000000000000000000000000000000001";
static const WCHAR c_szDefaultCalledAtmAddr[] =
            L"0000000000000000000000000000000000000000";

const int MAX_VPI = 255;
const int MIN_VCI = 32;
const int MAX_VCI = 1023;

const int c_nSnapIdMaxBytes = 5;
const int c_nHighLayerInfoMaxBytes = 8;

enum PVCType
{
    PVC_ATMARP =1,
    PVC_PPP_ATM_CLIENT =2,
    PVC_PPP_ATM_SERVER =3,
    PVC_CUSTOM =4
};

enum AALType
{
    // AAL_TYPE_AAL0= 1,
    // AAL_TYPE_AAL1= 2,
    // AAL_TYPE_AAL34= 4,
    AAL_TYPE_AAL5= 8
};

// ATM Service Category
enum ATM_SERVICE_CATEGORY
{
    ATM_SERVICE_CATEGORY_CBR = 1,   // Constant Bit Rate
    ATM_SERVICE_CATEGORY_VBR = 2,   // Variable Bit Rate
    ATM_SERVICE_CATEGORY_UBR = 4,   // Unspecified Bit Rate
    ATM_SERVICE_CATEGORY_ABR = 8    // Available Bit Rate
};

void SetPvcDwordParam(HKEY hkeyAdapterPVCId,
                      PCWSTR pszParamName,
                      DWORD dwParam);

class CPvcInfo
{
public:
    CPvcInfo(PCWSTR pszPvcId);
    ~CPvcInfo();

    CPvcInfo &  operator=(const CPvcInfo & PvcInfo);  // copy operator
    void SetDefaults(PVCType type);
    void SetTypeDefaults(PVCType type);

    void SetDefaultsForAtmArp();
    void SetDefaultsForPPPOut();
    void SetDefaultsForPPPIn();
    void SetDefaultsForCustom();

    void ResetOldValues();

    // the registry key where this PVC is stored
    tstring m_strPvcId;

    // this PVC has been deleted
    BOOL m_fDeleted;

    // PVC_TYPE
    PVCType   m_dwPVCType;
    PVCType   m_dwOldPVCType;

    // Required Attributes
    tstring m_strName;      // PVC display name
    tstring m_strOldName;

    DWORD   m_dwVpi;
    DWORD   m_dwOldVpi;

    DWORD   m_dwVci;
    DWORD   m_dwOldVci;

    AALType   m_dwAAL;
    AALType   m_dwOldAAL;

    // Matching creteria
    tstring m_strCallingAddr;
    tstring m_strOldCallingAddr;

    tstring m_strCalledAddr;
    tstring m_strOldCalledAddr;

    // Flags
    DWORD   m_dwFlags;

    // Quality Info
    DWORD m_dwTransmitPeakCellRate;
    DWORD m_dwOldTransmitPeakCellRate;

    DWORD m_dwTransmitAvgCellRate;
    DWORD m_dwOldTransmitAvgCellRate;

    DWORD m_dwTransmitByteBurstLength;
    DWORD m_dwOldTransmitByteBurstLength;

    DWORD m_dwTransmitMaxSduSize;
    DWORD m_dwOldTransmitMaxSduSize;

    ATM_SERVICE_CATEGORY m_dwTransmitServiceCategory;
    ATM_SERVICE_CATEGORY m_dwOldTransmitServiceCategory;

    DWORD m_dwReceivePeakCellRate;
    DWORD m_dwOldReceivePeakCellRate;

    DWORD m_dwReceiveAvgCellRate;
    DWORD m_dwOldReceiveAvgCellRate;

    DWORD m_dwReceiveByteBurstLength;
    DWORD m_dwOldReceiveByteBurstLength;

    DWORD m_dwReceiveMaxSduSize;
    DWORD m_dwOldReceiveMaxSduSize;

    ATM_SERVICE_CATEGORY m_dwReceiveServiceCategory;
    ATM_SERVICE_CATEGORY m_dwOldReceiveServiceCategory;

    // Local BLLI and BHLI info
    DWORD m_dwLocalLayer2Protocol;
    DWORD m_dwOldLocalLayer2Protocol;

    DWORD m_dwLocalUserSpecLayer2;
    DWORD m_dwOldLocalUserSpecLayer2;

    DWORD m_dwLocalLayer3Protocol;
    DWORD m_dwOldLocalLayer3Protocol;

    DWORD m_dwLocalUserSpecLayer3;
    DWORD m_dwOldLocalUserSpecLayer3;

    DWORD m_dwLocalLayer3IPI;
    DWORD m_dwOldLocalLayer3IPI;

    tstring m_strLocalSnapId;
    tstring m_strOldLocalSnapId;

    DWORD m_dwLocalHighLayerInfoType;
    DWORD m_dwOldLocalHighLayerInfoType;

    tstring m_strLocalHighLayerInfo;
    tstring m_strOldLocalHighLayerInfo;

    // Destination BLLI and BHLI info
    DWORD m_dwDestnLayer2Protocol;
    DWORD m_dwOldDestnLayer2Protocol;

    DWORD m_dwDestnUserSpecLayer2;
    DWORD m_dwOldDestnUserSpecLayer2;

    DWORD m_dwDestnLayer3Protocol;
    DWORD m_dwOldDestnLayer3Protocol;

    DWORD m_dwDestnUserSpecLayer3;
    DWORD m_dwOldDestnUserSpecLayer3;

    DWORD m_dwDestnLayer3IPI;
    DWORD m_dwOldDestnLayer3IPI;

    tstring m_strDestnSnapId;
    tstring m_strOldDestnSnapId;

    DWORD m_dwDestnHighLayerInfoType;
    DWORD m_dwOldDestnHighLayerInfoType;

    tstring m_strDestnHighLayerInfo;
    tstring m_strOldDestnHighLayerInfo;
};

typedef list<CPvcInfo*>  PVC_INFO_LIST;

//
// ATMUNI Call Manager Property structure
// holds adapter specific PVC parameters (configurable ) and state
//

class CUniAdapterInfo
{
public:
    CUniAdapterInfo(){};
    ~CUniAdapterInfo(){};

    CUniAdapterInfo &  operator=(const CUniAdapterInfo & AdapterInfo);  // copy operator
    void SetDefaults(PCWSTR pszBindName);

    // the adapter's binding state
    AdapterBindingState    m_BindingState;

    // Instance Guid of net card
    tstring m_strBindName;

    PVC_INFO_LIST   m_listPVCs;

    // flags
    BOOL    m_fDeleted;
};

typedef list<CUniAdapterInfo*> UNI_ADAPTER_LIST;

// Constants
// Registry key names

static const WCHAR c_szPVCType[] = L"PVCType";
static const WCHAR c_szPVCName[] = L"PVCName";

// main page
static const WCHAR c_szVpi[]            = L"Vpi";
static const WCHAR c_szVci[]            = L"Vci";
static const WCHAR c_szAALType[]        = L"AALType";
static const WCHAR c_szCallingParty[]   = L"CallingParty";
static const WCHAR c_szCalledParty[]    = L"CalledParty";

// flags
static const WCHAR c_szFlags[] = L"Flags";

// qos
static const WCHAR c_szTransmitPeakCellRate[]       = L"TransmitPeakCellRate";
static const WCHAR c_szTransmitAvgCellRate[]        = L"TransmitAvgCellRate";
static const WCHAR c_szTransmitByteBurstLength[]    = L"TransmitByteBurstLength";
static const WCHAR c_szTransmitMaxSduSize[]         = L"TransmitMaxSduSize";
static const WCHAR c_szTransmitServiceCategory[]    = L"TransmitServiceCategory";

static const WCHAR c_szReceivePeakCellRate[]        = L"ReceivePeakCellRate";
static const WCHAR c_szReceiveAvgCellRate[]         = L"ReceiveAvgCellRate";
static const WCHAR c_szReceiveByteBurstLength[]     = L"ReceiveByteBurstLength";
static const WCHAR c_szReceiveMaxSduSize[]          = L"ReceiveMaxSduSize";
static const WCHAR c_szReceiveServiceCategory[]     = L"ReceiveServiceCategory";

// BLLI & BHLI
static const WCHAR c_szLocalLayer2Protocol[]        = L"LocalLayer2Protocol";
static const WCHAR c_szLocalUserSpecLayer2[]        = L"LocalUserSpecLayer2";
static const WCHAR c_szLocalLayer3Protocol[]        = L"LocalLayer3Protocol";
static const WCHAR c_szLocalUserSpecLayer3[]        = L"LocalUserSpecLayer3";
static const WCHAR c_szLocalLayer3IPI[]             = L"LocalLayer3IPI";
static const WCHAR c_szLocalSnapId[]                = L"LocalSnapId";

static const WCHAR c_szLocalHighLayerInfoType[]     = L"LocalHighLayerInfoType";
static const WCHAR c_szLocalHighLayerInfo[]         = L"LocalHighLayerInfo";

static const WCHAR c_szDestnLayer2Protocol[]        = L"DestnLayer2Protocol";
static const WCHAR c_szDestnUserSpecLayer2[]        = L"DestnUserSpecLayer2";
static const WCHAR c_szDestnLayer3Protocol[]        = L"DestnLayer3Protocol";
static const WCHAR c_szDestnUserSpecLayer3[]        = L"DestnUserSpecLayer3";
static const WCHAR c_szDestnLayer3IPI[]             = L"DestnLayer3IPI";
static const WCHAR c_szDestnSnapId[]                = L"DestnSnapId";

static const WCHAR c_szDestnHighLayerInfoType[]     = L"DestnHighLayerInfoType";
static const WCHAR c_szDestnHighLayerInfo[]         = L"DestnHighLayerInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\brdgcfg\resource.h ===
//#include <ncres.h>

#pragma once

#define IDR_REG_BRIDGECFG         40002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\brdgcfg\brdgobj.cpp ===
#include "pch.h"
#pragma hdrstop

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <netcfgx.h>

#include "brdgobj.h"
#include "trace.h"
#include "ncbase.h"
#include "ncmem.h"
#include "ncreg.h"

// =================================================================
// string constants
//
const WCHAR c_szSBridgeNOParams[]           = L"System\\CurrentControlSet\\Services\\BridgeMP";
const WCHAR c_szSBridgeDeviceValueName[]    = L"Device";
const WCHAR c_szSBridgeDevicePrefix[]       = L"\\Device\\";
const WCHAR c_szSBrigeMPID[]                = L"ms_bridgemp";

// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::CBridgeNO
//
// Purpose:   constructor for class CBridgeNO
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CBridgeNO::CBridgeNO(VOID) :
        m_pncc(NULL),
        m_pnc(NULL),
        m_eApplyAction(eBrdgActUnknown)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::CBridgeNO()" );
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::~CBridgeNO
//
// Purpose:   destructor for class CBridgeNO
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CBridgeNO::~CBridgeNO(VOID)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::~CBridgeNO()" );

    // release interfaces if acquired
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);
}

// =================================================================
// INetCfgNotify
//
// The following functions provide the INetCfgNotify interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
STDMETHODIMP CBridgeNO::Initialize(INetCfgComponent* pnccItem,
        INetCfg* pnc, BOOL fInstalling)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::Initialize()" );

    // save INetCfg & INetCfgComponent and add refcount
    m_pncc = pnccItem;
    m_pnc = pnc;

    AddRefObj( m_pncc );
    AddRefObj( m_pnc );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure the bridge
//
// Arguments:
//    pszAnswerFile    [in]  name of AnswerFile
//    pszAnswerSection [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CBridgeNO::ReadAnswerFile(PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::ReadAnswerFile()" );
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CBridgeNO::Install(DWORD dw)
{
    //
    // Remember that we're installing. If the user doesn't cancel, we'll actually perform
    // our work in ApplyRegistryChanges().
    //
    TraceTag( ttidBrdgCfg, "CBridgeNO::Install()" );
    m_eApplyAction = eBrdgActInstall;
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
STDMETHODIMP CBridgeNO::Removing(VOID)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::Removing()" );
    m_eApplyAction = eBrdgActRemove;
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::CancelChanges
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::CancelChanges(VOID)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::CancelChanges()" );
    m_eApplyAction = eBrdgActUnknown;
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
//
STDMETHODIMP CBridgeNO::ApplyRegistryChanges(VOID)
{
    HRESULT             hr = S_OK;

    TraceTag( ttidBrdgCfg, "CBridgeNO::ApplyRegistryChanges()" );

    //
    // We only do work on install
    //
    if( m_eApplyAction == eBrdgActInstall )
    {
        INetCfgComponent    *pNetCfgComp;

        TraceTag( ttidBrdgCfg, "Attempting to write device name in CBridgeNO::ApplyRegistryChanges()" );
        hr = m_pnc->FindComponent( c_szSBrigeMPID, &pNetCfgComp );

        if( SUCCEEDED ( hr) )
        {
            LPWSTR          wszBindName;

            hr = pNetCfgComp->GetBindName(&wszBindName);

            if( SUCCEEDED(hr) )
            {
                UINT        BindNameLen, PrefixLen;
                LPWSTR      wszDeviceName;

                // Get enough memory to build a string with the device prefix and the bind name
                // concatenated
                BindNameLen = wcslen(wszBindName);
                PrefixLen = wcslen(c_szSBridgeDevicePrefix);
                wszDeviceName = (WCHAR*)malloc( sizeof(WCHAR) * (BindNameLen + PrefixLen + 1) );

                if( wszDeviceName != NULL )
                {
                    HKEY        hkeyServiceParams;

                    // Create the concatenated string
                    wcscpy( wszDeviceName, c_szSBridgeDevicePrefix );
                    wcscat( wszDeviceName, wszBindName );

                    // Create the reg key where we need to stash the device name
                    hr = HrRegCreateKeyEx( HKEY_LOCAL_MACHINE, c_szSBridgeNOParams, REG_OPTION_NON_VOLATILE,
                                           KEY_ALL_ACCESS, NULL, &hkeyServiceParams, NULL );

                    if( SUCCEEDED(hr)  )
                    {
                        // Write out the device name
                        hr = HrRegSetSz( hkeyServiceParams, c_szSBridgeDeviceValueName, wszDeviceName );

                        if( FAILED(hr)  )
                        {
                            TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "HrRegSetSz failed in CBridgeNO::ApplyRegistryChanges()");
                        }

                        RegCloseKey( hkeyServiceParams );
                    }
                    else
                    {
                        TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "HrRegCreateKeyEx failed in CBridgeNO::ApplyRegistryChanges()");
                    }

                    free( wszDeviceName );
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "malloc failed in CBridgeNO::ApplyRegistryChanges()");
                }

                CoTaskMemFree( wszBindName );
            }
            else
            {
                TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "pNetCfgComp->GetBindName failed in CBridgeNO::ApplyRegistryChanges()");
            }

            pNetCfgComp->Release();
        }
        else
        {
            TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "m_pnc->FindComponent failed in CBridgeNO::ApplyRegistryChanges()");
        }
    }

    // Paranoia
    m_eApplyAction = eBrdgActUnknown;

    return hr;
}

STDMETHODIMP
CBridgeNO::ApplyPnpChanges(
    IN INetCfgPnpReconfigCallback* pICallback)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::ApplyPnpChanges()" );
    return S_OK;
}

// =================================================================
// INetCfgSystemNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::GetSupportedNotifications
//
// Purpose:   Tell the system which notifications we are interested in
//
// Arguments:
//    pdwNotificationFlag [out]  pointer to NotificationFlag
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::GetSupportedNotifications(
        OUT DWORD* pdwNotificationFlag)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::GetSupportedNotifications()" );
    *pdwNotificationFlag = NCN_ADD | NCN_ENABLE | NCN_UPDATE | NCN_BINDING_PATH;
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::SysQueryBindingPath
//
// Purpose:   Allow or veto formation of a binding path
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::SysQueryBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    HRESULT         hr = S_OK;
    BOOLEAN         bReject = FALSE;

    TraceTag( ttidBrdgCfg, "CBridgeNO::SysQueryBindingPath()" );
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::SysNotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbpItem    [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::SysNotifyBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::SysNotifyBindingPath()" );
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::SysNotifyComponent
//
// Purpose:   System tells us by calling this function which
//            component has undergone a change (installed/removed)
//
// Arguments:
//    dwChangeFlag [in]  type of system change
//    pncc         [in]  pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::SysNotifyComponent(DWORD dwChangeFlag,
        INetCfgComponent* pncc)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::SysNotifyComponent()" );
    return S_OK;
}

// =================================================================
// INetCfgBindNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::QueryBindingPath
//
// Purpose:   Allow or veto a binding path involving us
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbi        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::QueryBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::QueryBindingPath()" );

    // The bridge protocol should never be enabled by default; it
    // should only be enabled programatically by the implementation
    // of our UI code which allows the activation of the bridge.
    return NETCFG_S_DISABLE_QUERY;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::NotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path involving us has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::NotifyBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::NotifyBindingPath()" );
    return S_OK;
}

// ------------ END OF NOTIFY OBJECT FUNCTIONS --------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dhcpscfg\resource.h ===
#include <ncres.h>

// String resources
#define IDS_DESC_COMOBJ_DHCPSCFG            IDS_NC_DHCPCFG + 0
#define IDS_DHCP_OPTION_006_NAME            IDS_NC_DHCPCFG + 1
#define IDS_DHCP_OPTION_006_COMMENT         IDS_NC_DHCPCFG + 2
#define IDS_DHCP_OPTION_015_NAME            IDS_NC_DHCPCFG + 3
#define IDS_DHCP_OPTION_015_COMMENT         IDS_NC_DHCPCFG + 4
#define IDS_DHCP_SUBNET_NAME                IDS_NC_DHCPCFG + 5
#define IDS_DHCP_SUBNET_COMMENT             IDS_NC_DHCPCFG + 6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dhcpscfg\dhcpsobj.h ===
//
// D H C P S O B J . H
//
// Declaration of CDHCPServer and helper functions
//

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include <ncsetup.h>
#include "resource.h"


/////////////////////////////////////////////////////////////////////////////
// DHCPServer

class ATL_NO_VTABLE CDHCPServer :
    public CComObjectRoot,
    public CComCoClass<CDHCPServer, &CLSID_CDHCPServer>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
public:
    CDHCPServer();
    ~CDHCPServer();

    BEGIN_COM_MAP(CDHCPServer)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CDHCPServer)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_DHCPSCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Removing)            ();

    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};

// Private state info
private:
    INSTALLACTION       m_eInstallAction;
    BOOL                m_fUnattend;        // Are we installed unattended?
    INetCfgComponent *  m_pncc;             // Place to keep my component
    INetCfg *           m_pnc;              // Place to keep my component
    BOOL                m_fUpgrade;         // TRUE if we are upgrading with
                                            // an answer file

    tstring             m_strParamsRestoreFile;
    tstring             m_strConfigRestoreFile;

    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection);
    HRESULT HrProcessDhcpServerSolutionsParams(CSetupInfFile  * pcsif, PCWSTR pszAnswerSection);
    HRESULT HrWriteDhcpOptionInfo(HKEY hkeyDhcpCfg);
    HRESULT HrWriteDhcpSubnets(HKEY hkeyDhcpCfg, PCWSTR szSubnet, PCWSTR szStartIp,
                               DWORD dwEndIp, DWORD dwSubnetMask, DWORD dwLeaseDuration,
                               DWORD dwDnsServer, PCWSTR szDomainName);
    HRESULT HrRestoreRegistry(VOID);
    HRESULT HrWriteUnattendedKeys();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\brdgcfg\brdgobj.h ===
#pragma once

#include <ncxclsid.h>
#include <notifval.h>
#include "resource.h"

// What type of config change the user/system is performing
enum BridgeConfigAction {eBrdgActUnknown, eBrdgActInstall, eBrdgActRemove, eBrdgActPropertyUI};

class CBridgeNO :
    public CComObjectRoot,
    public CComCoClass<CBridgeNO, &CLSID_CBridgeObj>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentNotifyGlobal
{
public:
    CBridgeNO(VOID);
    ~CBridgeNO(VOID);

    BEGIN_COM_MAP(CBridgeNO)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_BRIDGECFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR szAnswerFile,
                                     PCWSTR szAnswerSections);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

private:
    INetCfgComponent*   m_pncc;
    INetCfg*            m_pnc;
    BridgeConfigAction  m_eApplyAction;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dhcpscfg\dhcpsdef.h ===
// Only allow single inclusion of this file.
#pragma once

#define DHCP_ADMIN_MSC_NAME     L"dhcpadmn.msc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Configuration Objects"
#define VER_INTERNALNAME_STR            "netcfgx.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dll\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   Entry points for netcfgx.dll
//
//  Notes:
//
//  Author:     shaunco   23 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncxbase.h"

// Include support for all of the COM objects
#include "..\alanecfg\alaneobj.h"
#include "..\atlkcfg\atlkobj.h"
#include "..\atmcfg\arpsobj.h"
#include "..\atmcfg\auniobj.h"
#include "..\brdgcfg\brdgobj.h"
#include "..\dhcpscfg\dhcpsobj.h"
#include "..\msclicfg\mscliobj.h"
#include "..\nbfcfg\nbfobj.h"
#include "..\engine\inetcfg.h"
#include "..\nwclicfg\nwcliobj.h"
#include "..\nwlnkcfg\nwlnkipx.h"
#include "..\nwlnkcfg\nwlnknb.h"
#include "..\rascfg\rasobj.h"
#include "..\sapcfg\sapobj.h"
#include "..\srvrcfg\srvrobj.h"
#include "..\tcpipcfg\tcpipobj.h"
#include "..\wlbscfg\wlbs.h"

// Network class installer
#include "..\engine\dihook.h"

// Net class prop page providers
#include "netpages.h"

#define INITGUID
#include "ncxclsid.h"


// Global
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CALaneCfg,   CALaneCfg)
    OBJECT_ENTRY(CLSID_CATlkObj,    CATlkObj)
    OBJECT_ENTRY(CLSID_CArpsCfg,    CArpsCfg)
    OBJECT_ENTRY(CLSID_CAtmUniCfg,  CAtmUniCfg)
    OBJECT_ENTRY(CLSID_CBridgeObj,  CBridgeNO)
    OBJECT_ENTRY(CLSID_CDHCPServer, CDHCPServer)
    OBJECT_ENTRY(CLSID_CL2tp,       CL2tp)
    OBJECT_ENTRY(CLSID_CMSClient,   CMSClient)
    OBJECT_ENTRY(CLSID_CNWClient,   CNWClient)
    OBJECT_ENTRY(CLSID_CNbfObj,     CNbfObj)
    OBJECT_ENTRY(CLSID_CNdisWan,    CNdisWan)
    OBJECT_ENTRY(CLSID_CNetCfg,     CImplINetCfg)
    OBJECT_ENTRY(CLSID_CNwlnkIPX,   CNwlnkIPX)
    OBJECT_ENTRY(CLSID_CNwlnkNB,    CNwlnkNB)
    OBJECT_ENTRY(CLSID_CPppoe,      CPppoe)
    OBJECT_ENTRY(CLSID_CPptp,       CPptp)
    OBJECT_ENTRY(CLSID_CRasCli,     CRasCli)
    OBJECT_ENTRY(CLSID_CRasSrv,     CRasSrv)
    OBJECT_ENTRY(CLSID_CSAPCfg,     CSAPCfg)
    OBJECT_ENTRY(CLSID_CSrvrcfg,    CSrvrcfg)
    OBJECT_ENTRY(CLSID_CSteelhead,  CSteelhead)
    OBJECT_ENTRY(CLSID_CTcpipcfg,   CTcpipcfg)
    OBJECT_ENTRY(CLSID_CWLBS,       CWLBS)
END_OBJECT_MAP()


//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID   /* lpReserved */)
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        DisableThreadLibraryCalls (hInstance);
        InitializeDebugging();
        _Module.Init (ObjectMap, hInstance);
    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        DbgCheckPrematureDllUnload ("netcfgx.dll", _Module.GetLockCount());
        _Module.Term ();
        UnInitializeDebugging();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(VOID)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   // The check is to works around an ATL problem where AtlModuleGetClassObject will AV
    // if _Module.m_pObjMap == NULL
    if (_Module.m_pObjMap) 
    {
        return _Module.GetClassObject(rclsid, riid, ppv);
    }
    else
    {
        return E_FAIL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(VOID)
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = NcAtlModuleRegisterServer (&_Module);

        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "netcfgx!DllRegisterServer");
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(VOID)
{
    _Module.UnregisterServer();

    return S_OK;
}

#if DBG

const char * SzDifToString(DI_FUNCTION dif)
{
    switch(dif) 
    {
    case DIF_SELECTDEVICE: return "DIF_SELECTDEVICE";
    case DIF_INSTALLDEVICE: return "DIF_INSTALLDEVICE";
    case DIF_ASSIGNRESOURCES: return "DIF_ASSIGNRESOURCES";
    case DIF_PROPERTIES: return "DIF_PROPERTIES";
    case DIF_REMOVE: return "DIF_REMOVE";
    case DIF_FIRSTTIMESETUP: return "DIF_FIRSTTIMESETUP";
    case DIF_FOUNDDEVICE: return "DIF_FOUNDDEVICE";
    case DIF_SELECTCLASSDRIVERS: return "DIF_SELECTCLASSDRIVERS";
    case DIF_VALIDATECLASSDRIVERS: return "DIF_VALIDATECLASSDRIVERS";
    case DIF_INSTALLCLASSDRIVERS: return "DIF_INSTALLCLASSDRIVERS";
    case DIF_CALCDISKSPACE: return "DIF_CALCDISKSPACE";
    case DIF_DESTROYPRIVATEDATA: return "DIF_DESTROYPRIVATEDATA";
    case DIF_VALIDATEDRIVER: return "DIF_VALIDATEDRIVER";
    case DIF_MOVEDEVICE: return "DIF_MOVEDEVICE";
    case DIF_DETECT: return "DIF_DETECT";
    case DIF_INSTALLWIZARD: return "DIF_INSTALLWIZARD";
    case DIF_DESTROYWIZARDDATA: return "DIF_DESTROYWIZARDDATA";
    case DIF_PROPERTYCHANGE: return "DIF_PROPERTYCHANGE";
    case DIF_ENABLECLASS: return "DIF_ENABLECLASS";
    case DIF_DETECTVERIFY: return "DIF_DETECTVERIFY";
    case DIF_INSTALLDEVICEFILES: return "DIF_INSTALLDEVICEFILES";
    case DIF_UNREMOVE: return "DIF_UNREMOVE";
    case DIF_SELECTBESTCOMPATDRV: return "DIF_SELECTBESTCOMPATDRV";
    case DIF_ALLOW_INSTALL: return "DIF_ALLOW_INSTALL";
    case DIF_REGISTERDEVICE: return "DIF_REGISTERDEVICE";
    case DIF_NEWDEVICEWIZARD_PRESELECT: return "DIF_NEWDEVICEWIZARD_PRESELECT";
    case DIF_NEWDEVICEWIZARD_SELECT: return "DIF_NEWDEVICEWIZARD_SELECT";
    case DIF_NEWDEVICEWIZARD_PREANALYZE: return "DIF_NEWDEVICEWIZARD_PREANALYZE";
    case DIF_NEWDEVICEWIZARD_POSTANALYZE: return "DIF_NEWDEVICEWIZARD_POSTANALYZE";
    case DIF_NEWDEVICEWIZARD_FINISHINSTALL: return "DIF_NEWDEVICEWIZARD_FINISHINSTALL";
    case DIF_UNUSED1: return "DIF_UNUSED1";
    case DIF_INSTALLINTERFACES: return "DIF_INSTALLINTERFACES";
    case DIF_DETECTCANCEL: return "DIF_DETECTCANCEL";
    case DIF_REGISTER_COINSTALLERS: return "DIF_REGISTER_COINSTALLERS";
    case DIF_ADDPROPERTYPAGE_ADVANCED: return "DIF_ADDPROPERTYPAGE_ADVANCED";
    case DIF_ADDPROPERTYPAGE_BASIC: return "DIF_ADDPROPERTYPAGE_BASIC";
    case DIF_RESERVED1: return "DIF_RESERVED1";
    case DIF_TROUBLESHOOTER: return "DIF_TROUBLESHOOTER";
    case DIF_POWERMESSAGEWAKE: return "DIF_POWERMESSAGEWAKE";
    case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED: return "DIF_ADDREMOTEPROPERTYPAGE_ADVANCED";
    default: return "Unknown DI_FUNCTION - update SzDifToString()";
    }
}

#endif // DBG

//+--------------------------------------------------------------------------
//
//  Function:   NetClassInstaller
//
//  Purpose:    This function is called by SetupApi for a variety of
//              functions defined by dif.
//              See SetupDiCallClassInstaller in the SetupApi documentation
//              for more information.
//
//  Arguments:
//      dif   [in] See Device Installer documentation
//      hdi   [in]
//      pdeid [in] if dif == DIF_INSTALLDEVICE, this parameter is not
//                      optional.
//
//
//  Returns:    Win32/Device Installer error code
//
//  Author:     BillBe   24 Nov 1996
//
//  Notes:
//
EXTERN_C
DWORD
__stdcall
NetClassInstaller (
    DI_FUNCTION         dif,
    HDEVINFO            hdi,
    PSP_DEVINFO_DATA    pdeid)
{
#if DBG
    TraceTag(ttidNetcfgBase, "NetClassInstaller: dif=0x%08X (%s)", dif, SzDifToString(dif));
#endif

    DWORD dwRet = ERROR_DI_DO_DEFAULT;
    NC_TRY
    {
        HRESULT hr = _HrNetClassInstaller (dif, hdi, pdeid);

        // Convert errors that can be converted otherwise
        // leave error as is and Device Installer Api will treat is as
        // a generic failure
        //
        if (FAILED(hr))
        {
            DWORD dwFac = HRESULT_FACILITY(hr);
            if ((FACILITY_SETUPAPI == dwFac) || (FACILITY_WIN32 == dwFac))
            {
                dwRet = DwWin32ErrorFromHr (hr);
            }
            else
            {
                dwRet = ERROR_GEN_FAILURE;
            }
        }
        else
        {
            dwRet = NO_ERROR;
        }

    }
    NC_CATCH_ALL
    {
        dwRet = ERROR_GEN_FAILURE;
    }
    TraceTag(ttidNetcfgBase, "NetClassInstaller Exiting. Result %X", dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ModemClassCoInstaller
//
//  Purpose:    Implements the co-installer for modem devices.
//
//  Arguments:
//      dif         [in]        See Device Installer Api documentation.
//      hdi         [in]
//      pdeid       [in]
//      pContext    [inout]
//
//  Returns:    See Device Installer Api documentation.
//
//  Author:     shaunco   6 May 1997
//
//  Notes:
//
EXTERN_C
DWORD
__stdcall
ModemClassCoInstaller (
    DI_FUNCTION                 dif,
    HDEVINFO                    hdi,
    PSP_DEVINFO_DATA            pdeid,
    PCOINSTALLER_CONTEXT_DATA   pContext)
{
    AssertSz (pContext, "ModemClassCoInstaller: Hey! How about some context "
                        "data?");

    TraceTag (ttidRasCfg, "ModemClassCoInstaller: dif=0x%08X %s",
              dif,
              (pContext->PostProcessing) ? "(post processing)" : "");


    // If we're post processing for anything and the install result from
    // the class installer indicates an error, propagate this error and
    // take no action.
    //
    if (pContext->PostProcessing && (NO_ERROR != pContext->InstallResult))
    {
        TraceTag (ttidRasCfg, "ModemClassCoInstaller: taking no action. "
                "propagating pContext->InstallResult = 0x%08X",
                pContext->InstallResult);
        return pContext->InstallResult;
    }

    DWORD dwRet = NO_ERROR;
    if (!FInSystemSetup())
    {
        NC_TRY
        {
            HRESULT hr = HrModemClassCoInstaller (dif, hdi, pdeid, pContext);

            // Convert errors that can be converted otherwise
            // return generic faliure.
            //
            if (FAILED(hr))
            {
                DWORD dwFac = HRESULT_FACILITY(hr);
                if ((FACILITY_SETUPAPI == dwFac) || (FACILITY_WIN32 == dwFac))
                {
                    dwRet = DwWin32ErrorFromHr (hr);
                }
                else
                {
                    dwRet = ERROR_GEN_FAILURE;
                }
            }
        }
        NC_CATCH_ALL
        {
            dwRet = ERROR_GEN_FAILURE;
        }
    }
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   NetPropPageProvider
//
//  Purpose:
//
//  Arguments:
//      ppspr   [in]   See Win32 ExtensionPropSheetPageProc fcn for info
//      lpfn    [in]
//      lParama [in]
//
//  Returns:    See Win32ExtensionPropSheetPageProc
//
//  Author:     billbe 24 June 1997
//
//  Notes:
//
EXTERN_C
BOOL
__stdcall
NetPropPageProvider(
    PSP_PROPSHEETPAGE_REQUEST   ppspr,
    LPFNADDPROPSHEETPAGE        lpfnAddPage,
    LPARAM                      lParam)
{
    Assert(ppspr);
    Assert(lpfnAddPage);

    TraceTag(ttidNetcfgBase, "NetPropPageProvider called");
    // Assume we can't handle the request
    BOOL            bSuccess = FALSE;
    HPROPSHEETPAGE  hpspAdvanced = NULL;
    HPROPSHEETPAGE  hpspIsdn = NULL;

    // Only supply the property page if we there is a specific device
    // in other words, don't do it if properties on the general Net class
    // is being requested.
    // Also, we only respond to the advanced device properties request

    HRESULT hr = S_OK;

    if ((ppspr->DeviceInfoData) &&
            (SPPSR_ENUM_ADV_DEVICE_PROPERTIES == ppspr->PageRequested))
    {
        // Get the advanced page ready for hand off to the requestor
        hr = HrGetAdvancedPage(ppspr->DeviceInfoSet, ppspr->DeviceInfoData,
                &hpspAdvanced);

        if (SUCCEEDED(hr))
        {
            if (lpfnAddPage(hpspAdvanced, lParam))
            {
                // We successfully made the hand off to the requestor
                // Now we reset our handle so we don't try to free it
                hpspAdvanced = NULL;
                bSuccess = TRUE;
            }

            // clean up if needed
            if (hpspAdvanced)
            {
                DestroyPropertySheetPage(hpspAdvanced);
            }
        }

        // Get the isdn page ready for hand off to the requestor
        //

        // We don't need to save the hr value from the last so we can reuse
        hr = HrGetIsdnPage(ppspr->DeviceInfoSet, ppspr->DeviceInfoData,
                &hpspIsdn);

        if (SUCCEEDED(hr))
        {
            if (lpfnAddPage(hpspIsdn, lParam))
            {
                // We successfully made the hand off to the requestor
                // Now we reset our handle so we don't try to free it
                hpspIsdn = NULL;
                bSuccess = TRUE;
            }

            // clean up if needed
            if (hpspIsdn)
            {
                DestroyPropertySheetPage(hpspIsdn);
            }
        }

    }

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dhcpscfg\dhcpsobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D H C P S O B J . C P P
//
//  Contents:   Implementation of the CDHCPServer notify object
//
//  Notes:
//
//  Author:     jeffspr   31 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "dhcpsobj.h"
#include "ncerror.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncnetcfg.h"
#include "ncipaddr.h"
#include <dhcpapi.h>

extern const WCHAR c_szInfId_MS_DHCPServer[];
extern const WCHAR c_szAfDhcpServerConfiguration[];
extern const WCHAR c_szAfDhcpServerParameters[];


//---[ Constants ]------------------------------------------------------------

static const WCHAR c_szDHCPServerServicePath[]  = L"System\\CurrentControlSet\\Services\\DHCPServer";
static const WCHAR c_szDHCPServerParamPath[]    = L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters";
static const WCHAR c_szDHCPServerConfigPath[]   = L"System\\CurrentControlSet\\Services\\DHCPServer\\Configuration";
static const WCHAR c_szOptionInfo[]             = L"OptionInfo";
static const WCHAR c_szSubnets[]                = L"Subnets";
static const WCHAR c_szIpRanges[]               = L"IpRanges";
static const WCHAR c_szSubnetOptions[]          = L"SubnetOptions";

static const WCHAR c_szDHCPServerUnattendRegSection[]   = L"DHCPServer_Unattend";

const WCHAR c_szStartIp[]       = L"StartIp";
const WCHAR c_szEndIp[]         = L"EndIp";
const WCHAR c_szSubnetMask[]    = L"SubnetMask";
const WCHAR c_szLeaseDuration[] = L"LeaseDuration";
const WCHAR c_szDnsServer[]     = L"DnsServer";
const WCHAR c_szDomainName[]    = L"DomainName";



// Destructor
//

CDHCPServer::CDHCPServer()
{
    // Initialize member variables.
    m_pnc            = NULL;
    m_pncc           = NULL;
    m_eInstallAction = eActUnknown;
    m_fUpgrade       = FALSE;
    m_fUnattend      = FALSE;
}

CDHCPServer::~CDHCPServer()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);

    // Release KEY handles here.
}

//
// INetCfgNotify
//

STDMETHODIMP CDHCPServer::Initialize(   INetCfgComponent *  pnccItem,
                                        INetCfg *           pnc,
                                        BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "m_pncc NULL in CDHCPServer::Initialize");
    AssertSz(m_pnc, "m_pnc NULL in CDHCPServer::Initialize");

    // Addref the config objects
    //
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  HrRestoreRegistrySz
//
// Purpose:   Restore a subkey from the specified file
//
// Arguments:
//    hkeyBase   [in]  handle of basekey
//    pszSubKey  [in]  subkey to restore
//    pszRegFile [in]  name of file to restore from
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 16-September-98
//
// Notes:     This should be moved to common code
//
HRESULT
HrRestoreRegistrySz (
    IN HKEY   hkeyBase,
    IN PCWSTR pszSubKey,
    IN PCWSTR pszRegFile)
{
    Assert(hkeyBase);
    AssertValidReadPtr(pszSubKey);
    AssertValidReadPtr(pszRegFile);

    HRESULT hr;
    HKEY hkey = NULL;
    DWORD dwDisp;

    TraceTag(ttidDHCPServer, "restoring subkey '%S' from file '%S'",
             pszSubKey, pszRegFile);

    hr = HrEnablePrivilege (SE_RESTORE_NAME);
    if (S_OK == hr)
    {
        // Ensure key is there by creating it
        //
        hr = HrRegCreateKeyEx (hkeyBase, pszSubKey, REG_OPTION_NON_VOLATILE,
                KEY_READ_WRITE_DELETE, NULL, &hkey, &dwDisp);
        if (S_OK == hr)
        {
            // Restore the old settings
            //
            hr = HrRegRestoreKey (hkey, pszRegFile, 0);

            RegCloseKey (hkey);
        }
    }

    TraceError ("HrRestoreRegistrySz", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrRestoreRegistry
//
//  Purpose:    Restores the contents of the registry for this component
//
//  Arguments:
//      (none)
//
//  Returns:    Win32 error if failed, otherwise S_OK
//
//  Author:     jeffspr   13 Aug 1997
//
//  Notes:
//
HRESULT CDHCPServer::HrRestoreRegistry()
{
    HRESULT hr = S_OK;

    TraceTag(ttidDHCPServer, "CDHCPServer::HrRestoreRegistry()");

    // If we have a "configuration" key restore file
    //
    if (!m_strConfigRestoreFile.empty())
    {
        // We always want to continue, so ignore the return code
        //
        (void) HrRestoreRegistrySz(HKEY_LOCAL_MACHINE,
                                   c_szDHCPServerConfigPath,
                                   m_strConfigRestoreFile.c_str());
    }
    else
    {
        TraceTag(ttidDHCPServer, "DHCP Server Params restore file doesn't exist");
    }

    // If we have a params restore file
    //
    if (!m_strParamsRestoreFile.empty())
    {
        // We always want to continue, so ignore the return code
        //
        (void) HrRestoreRegistrySz(HKEY_LOCAL_MACHINE,
                                   c_szDHCPServerParamPath,
                                   m_strParamsRestoreFile.c_str());
    }
    else
    {
        TraceTag(ttidDHCPServer, "DHCP Server Params restore file doesn't exist");
    }

    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrRestoreRegistry");
    return hr;
}

HRESULT CDHCPServer::HrWriteUnattendedKeys()
{
    HRESULT                 hr          = S_OK;
    HKEY                    hkeyService = NULL;
    const COMPONENT_INFO *  pci         = NULL;

    Assert(m_fUnattend);

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        c_szDHCPServerServicePath,
                        KEY_READ_WRITE_DELETE,
                        &hkeyService);
    if (SUCCEEDED(hr))
    {
        Assert(hkeyService);

        pci = PComponentInfoFromComponentId(c_szInfId_MS_DHCPServer);
        if (pci)
        {
            CSetupInfFile   csif;

            // Open the answer file.
            hr = csif.HrOpen(pci->pszInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
            if (SUCCEEDED(hr))
            {
                // Install the unattend params
                //
                hr = HrSetupInstallFromInfSection (
                    NULL,
                    csif.Hinf(),
                    c_szDHCPServerUnattendRegSection,
                    SPINST_REGISTRY,
                    hkeyService,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
            }
        }
        RegCloseKey(hkeyService);
    }

    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrWriteUnattendedKeys");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrWriteDhcpOptionInfo
//
//  Purpose:    Write to the registry the Dhcp OptionInfo data.
//
//  Arguments:
//              hkeyConfig
//
//  Returns:    S_OK if successful, Reg API error otherwise.
//
//  Notes:
//
HRESULT CDHCPServer::HrWriteDhcpOptionInfo(HKEY hkeyConfig)
{
    HRESULT hr;
    DWORD   dwDisposition;
    HKEY    hkeyOptionInfo = NULL;

    typedef struct
    {
        const WCHAR * pcszOptionKeyName;
        const WCHAR * pcszOptionName;
        const WCHAR * pcszOptionComment;
        DWORD         dwOptionType;
        DWORD         dwOptionId;
        DWORD         cbBinData;
        DWORD       * pdwBinData;
    } OIDATA;

    OIDATA OiData[2];

    DWORD BinData006[] = {0x14, 0x4, 0x1, 0x0, 0x0};
    DWORD BinData015[] = {0x18, 0x5, 0x1, 0x0, 0x2, 0x0};

    OiData[0].pcszOptionKeyName = L"006";
    OiData[0].pcszOptionName    = SzLoadIds(IDS_DHCP_OPTION_006_NAME);    // DNS Servers
    OiData[0].pcszOptionComment = SzLoadIds(IDS_DHCP_OPTION_006_COMMENT); // Array of DNS Servers, by preference
    OiData[0].dwOptionType      = 0x1;
    OiData[0].dwOptionId        = 0x6;
    OiData[0].cbBinData         = celems(BinData006) * sizeof(BinData006[0]);
    OiData[0].pdwBinData        = BinData006;
    OiData[1].pcszOptionKeyName = L"015";
    OiData[1].pcszOptionName    = SzLoadIds(IDS_DHCP_OPTION_015_NAME);    // DNS Domain Name
    OiData[1].pcszOptionComment = SzLoadIds(IDS_DHCP_OPTION_015_COMMENT); // Domainname for client resolutions
    OiData[1].dwOptionType      = 0x0;
    OiData[1].dwOptionId        = 0xf;
    OiData[1].cbBinData         = celems(BinData015) * sizeof(BinData015[0]);
    OiData[1].pdwBinData        = BinData015;

    hr = ::HrRegCreateKeyEx(hkeyConfig, c_szOptionInfo,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ, NULL,
                            &hkeyOptionInfo, &dwDisposition);
    if (SUCCEEDED(hr))
    {
        for (UINT idx=0;
             (idx<celems(OiData)) && SUCCEEDED(hr);
             idx++)
        {
            HKEY hkey = NULL;

            hr = ::HrRegCreateKeyEx(hkeyOptionInfo, OiData[idx].pcszOptionKeyName,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ_WRITE, NULL,
                                    &hkey, &dwDisposition);
            if (SUCCEEDED(hr))
            {
                (VOID)::HrRegSetString(hkey, L"OptionName",
                                       OiData[idx].pcszOptionName);
                (VOID)::HrRegSetString(hkey, L"OptionComment",
                                       OiData[idx].pcszOptionComment);
                (VOID)::HrRegSetDword(hkey, L"OptionType",
                                      OiData[idx].dwOptionType);
                (VOID)::HrRegSetDword(hkey, L"OptionId",
                                      OiData[idx].dwOptionId);
                (VOID)::HrRegSetBinary(hkey, L"OptionValue",
                                      (const BYTE *)OiData[idx].pdwBinData,
                                      OiData[idx].cbBinData);

                RegCloseKey(hkey);
            }
        }

        RegCloseKey(hkeyOptionInfo);
    }

    TraceError("HrWriteDhcpOptionInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrWriteDhcpSubnets
//
//  Purpose:    Write to the registry the Dhcp Subnet data.
//
//  Arguments:
//      hkeyDhcpCfg
//      pszSubnet
//      pszStartIp
//      dwEndIp
//      dwSubnetMask
//      dwLeaseDuration
//      dwDnsServer
//      pszDomainName
//
//  Returns:    S_OK if successful, Reg API error otherwise.
//
//  Notes:
//
HRESULT
CDHCPServer::HrWriteDhcpSubnets (
    HKEY   hkeyDhcpCfg,
    PCWSTR pszSubnet,
    PCWSTR pszStartIp,
    DWORD  dwEndIp,
    DWORD  dwSubnetMask,
    DWORD  dwLeaseDuration,
    DWORD  dwDnsServer,
    PCWSTR pszDomainName)
{
    DWORD   dwDisposition;
    HRESULT hr;
    HKEY    hkeySubnets = NULL;

    hr = HrRegCreateKeyEx(hkeyDhcpCfg, c_szSubnets, REG_OPTION_NON_VOLATILE,
            KEY_READ, NULL, &hkeySubnets, &dwDisposition);

    if (S_OK == hr)
    {
        HKEY hkey10Dot = NULL;
        hr = HrRegCreateKeyEx(hkeySubnets, pszSubnet, REG_OPTION_NON_VOLATILE,
                KEY_READ_WRITE, NULL, &hkey10Dot, &dwDisposition);
        if (S_OK == hr)
        {
            HKEY hkeySubnetOptions = NULL;
            HKEY hkeyIpRanges = NULL;

            (VOID)HrRegSetString(hkey10Dot, L"SubnetName",
                                   SzLoadIds(IDS_DHCP_SUBNET_NAME));    // DHCP Server Scope
            (VOID)HrRegSetString(hkey10Dot, L"SubnetComment",
                                   SzLoadIds(IDS_DHCP_SUBNET_COMMENT)); // Scope used to offer clients address
            (VOID)HrRegSetDword(hkey10Dot, L"SubnetState", 0x0);
            (VOID)HrRegSetDword(hkey10Dot, L"SubnetAddress",
                                  IpPszToHostAddr(pszSubnet));
            (VOID)HrRegSetDword(hkey10Dot, L"SubnetMask", dwSubnetMask);

            hr = HrRegCreateKeyEx(hkey10Dot, c_szIpRanges,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ, NULL,
                                    &hkeyIpRanges, &dwDisposition);
            if (S_OK == hr)
            {
                HKEY hkeyStartIp = NULL;
                hr = HrRegCreateKeyEx(hkeyIpRanges, pszStartIp,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE, NULL,
                                        &hkeyStartIp, &dwDisposition);
                if (S_OK == hr)
                {
                    (VOID)HrRegSetDword(hkeyStartIp, L"RangeFlags", 0x1);
                    (VOID)HrRegSetDword(hkeyStartIp, L"StartAddress",
                                          IpPszToHostAddr(pszStartIp));
                    (VOID)HrRegSetDword(hkeyStartIp, L"EndAddress",
                                          dwEndIp);

                    RegCloseKey(hkeyStartIp);
                }

                RegCloseKey(hkeyIpRanges);
            }

            // Create subnets options key
            //
            hr = HrRegCreateKeyEx(hkey10Dot, c_szSubnetOptions,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ_WRITE, NULL,
                                    &hkeySubnetOptions, &dwDisposition);
            if (S_OK == hr)
            {
                HKEY hkey051 = NULL;
                hr = HrRegCreateKeyEx(hkeySubnetOptions, L"051",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE, NULL,
                                        &hkey051, &dwDisposition);
                if (S_OK == hr)
                {
                    (VOID)HrRegSetDword(hkey051, L"OptionId", 0x33);

                    DWORD rgdwLease[] = {0x14, 0x2, 0x1, 0x0, 0x0};
                    rgdwLease[celems(rgdwLease) - 1] = dwLeaseDuration;
                    (VOID)HrRegSetBinary(hkey051,
                                          L"OptionValue",
                                          (const BYTE *)rgdwLease,
                                          sizeof(rgdwLease));

                    RegCloseKey(hkey051);
                }

                HKEY hkey006 = NULL;
                hr = HrRegCreateKeyEx(hkeySubnetOptions, L"006",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE, NULL,
                                        &hkey006, &dwDisposition);
                if (S_OK == hr)
                {
                    (VOID)HrRegSetDword(hkey006, L"OptionId", 0x6);

                    DWORD rgdwDnsServer[] = {0x14, 0x4, 0x1, 0x0, 0x0};
                    rgdwDnsServer[celems(rgdwDnsServer) - 1] = dwDnsServer;
                    (VOID)::HrRegSetBinary(hkey006,
                                          L"OptionValue",
                                          (const BYTE *)rgdwDnsServer,
                                          sizeof(rgdwDnsServer));

                    RegCloseKey(hkey006);
                }

                HKEY hkey015 = NULL;
                hr = HrRegCreateKeyEx(hkeySubnetOptions, L"015",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE, NULL,
                                        &hkey015, &dwDisposition);
                if (S_OK == hr)
                {
                    (VOID)HrRegSetDword(hkey015, L"OptionId", 0xf);

                    UINT uLen = 0x18 + 2 * lstrlenW(pszDomainName);
                    LPBYTE pb = (LPBYTE)MemAlloc(uLen);
                    if (pb)
                    {
                        ZeroMemory(pb, uLen);

                        DWORD *pdw = (DWORD *)pb;
                        pdw[0] = uLen;
                        pdw[1] = 0x5;
                        pdw[2] = 0x1;
                        pdw[3] = 0x0;
                        pdw[4] = 2 * (1 + lstrlenW(pszDomainName));

                        lstrcpyW((PWSTR)&pdw[5], pszDomainName);

                        (VOID)::HrRegSetBinary(hkey015, L"OptionValue",
                                               (const BYTE *)pb, uLen);
                        MemFree(pb);
                    }

                    RegCloseKey(hkey015);
                }

                RegCloseKey(hkeySubnetOptions);
            }

            RegCloseKey(hkey10Dot);
        }

        RegCloseKey(hkeySubnets);
    }

    TraceError("HrWriteDhcpSubnets", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrProcessDhcpServerSolutionsParams
//
//  Purpose:    Handles necessary processing of contents of the answer file.
//
//  Arguments:
//      pcsif              [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Answerfile section in the
//                                    file appropriate to this component.
//
//  Returns:    S_OK if successful, setup API error otherwise.
//
//  Notes:
//
HRESULT
CDHCPServer::HrProcessDhcpServerSolutionsParams (
    IN CSetupInfFile * pcsif,
    IN PCWSTR pszAnswerSection)
{
    HRESULT hr;
    tstring str;
    tstring strStartIp;
    tstring strSubnet;

    hr = pcsif->HrGetString(pszAnswerSection, c_szSubnets, &strSubnet);
    if (SUCCEEDED(hr))
    {
        hr = pcsif->HrGetString(pszAnswerSection, c_szStartIp, &strStartIp);
        if (SUCCEEDED(hr))
        {
            hr = pcsif->HrGetString(pszAnswerSection, c_szEndIp, &str);
            if (SUCCEEDED(hr))
            {
                DWORD dwEndIp = IpPszToHostAddr(str.c_str());

                hr = pcsif->HrGetString(pszAnswerSection, c_szSubnetMask, &str);
                if (SUCCEEDED(hr))
                {
                    DWORD dwSubnetMask = IpPszToHostAddr(str.c_str());

                    hr = pcsif->HrGetString(pszAnswerSection, c_szDnsServer, &str);
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwLeaseDuration;
                        DWORD dwDnsServer = IpPszToHostAddr(str.c_str());

                        hr = pcsif->HrGetDword(pszAnswerSection, c_szLeaseDuration,
                                               &dwLeaseDuration);
                        if (SUCCEEDED(hr))
                        {
                            hr =  pcsif->HrGetString(pszAnswerSection,
                                                     c_szDomainName, &str);
                            if (SUCCEEDED(hr) && lstrlenW(str.c_str()))
                            {
                                HKEY  hkeyDhcpCfg = NULL;
                                DWORD dwDisposition;

                                // Write the registry data
                                //
                                hr = ::HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                                        c_szDHCPServerConfigPath,
                                                        REG_OPTION_NON_VOLATILE,
                                                        KEY_READ_WRITE, NULL,
                                                        &hkeyDhcpCfg, &dwDisposition);
                                if (SUCCEEDED(hr))
                                {
                                    hr = HrWriteDhcpOptionInfo(hkeyDhcpCfg);
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = HrWriteDhcpSubnets(hkeyDhcpCfg,
                                                                strSubnet.c_str(),
                                                                strStartIp.c_str(),
                                                                dwEndIp,
                                                                dwSubnetMask,
                                                                dwLeaseDuration,
                                                                dwDnsServer,
                                                                str.c_str());
                                    }

                                    RegCloseKey(hkeyDhcpCfg);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // If there are any params missing, so be it
    //
    if ((SPAPI_E_SECTION_NOT_FOUND == hr) ||
        (SPAPI_E_LINE_NOT_FOUND == hr) ||
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr))
    {
        hr = S_OK;
    }

    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessDhcpServerSolutionsParams");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrProcessAnswerFile
//
//  Purpose:    Handles necessary processing of contents of the answer file.
//
//  Arguments:
//      pszAnswerFile      [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Answer file section in the
//                                  file appropriate to this component.
//
//  Returns:    S_OK if successful, setup API error otherwise.
//
//  Author:     jeffspr   8 May 1997
//
//  Notes:
//
HRESULT
CDHCPServer::HrProcessAnswerFile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSection)
{
    HRESULT         hr          = S_OK;

    CSetupInfFile   csif;

    TraceTag(ttidDHCPServer, "CDHCPServer::HrProcessAnswerFile()");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessAnswerFile -- HrOpen failed()");

        hr = S_OK;
        goto Exit;
    }

    // Restore portions of the registry based on file names from the answer
    // file

    // Get restore file for "Parameters" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfDhcpServerParameters,
                          &m_strParamsRestoreFile);
    if (FAILED(hr))
    {
        TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessAnswerFile - Error restoring "
                   "Parameters key");

        // oh well, just continue
        hr = S_OK;
    }

    // Get restore file for "Configuration" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfDhcpServerConfiguration,
                          &m_strConfigRestoreFile);
    if (FAILED(hr))
    {
        TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessAnswerFile - Error restoring "
                   "Config key");

        // oh well, just continue
        hr = S_OK;
    }

    // Server Solutions has some parameters that need to be plumbed into the registry
    // for their unattended install scenarios
    //
    hr = HrProcessDhcpServerSolutionsParams(&csif, pszAnswerSection);

Exit:
    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessAnswerFile");
    return hr;
}

STDMETHODIMP CDHCPServer::ReadAnswerFile(
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSection)
{
    HRESULT     hr = S_OK;

    TraceTag(ttidDHCPServer, "CDHCPServer::ReadAnswerFile()");

    // don't call Validate_INetCfgNotify_ReadAnswerFile here, as the netoc
    // installer for this will intentionally call it with NULL params. The
    // Validate macro actually causes a return E_INVALIDARG in this case.

    // We're being installed unattended
    //
    m_fUnattend = TRUE;

    TraceTag(ttidDHCPServer, "Answerfile: %S",
        pszAnswerFile ? pszAnswerFile : L"<none>");
    TraceTag(ttidDHCPServer, "Answersection: %S",
        pszAnswerSection ? pszAnswerSection : L"<none>");

    // If we're not already installed, do the work.
    //
    if (pszAnswerFile && pszAnswerSection)
    {
        // Process the actual answer file (read our sections)
        //
        hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
        if (FAILED(hr))
        {
            TraceHr(ttidDHCPServer, FAL, NETSETUP_E_ANS_FILE_ERROR, FALSE,
                "CDHCPServer::ReadAnswerFile - Answer file has errors. Defaulting "
                "all information as if answer file did not exist.");
            hr = S_OK;
        }

    }

    Validate_INetCfgNotify_ReadAnswerFile_Return(hr);

    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::ReadAnswerFile");
    return hr;
}

STDMETHODIMP CDHCPServer::Install(DWORD dwSetupFlags)
{
    TraceTag(ttidDHCPServer, "CDHCPServer::Install()");

    Validate_INetCfgNotify_Install(dwSetupFlags);

    m_eInstallAction = eActInstall;

    TraceTag(ttidDHCPServer, "dwSetupFlags = %d", dwSetupFlags);
    TraceTag(ttidDHCPServer, "NSF_WINNT_WKS_UPGRADE = %x", NSF_WINNT_WKS_UPGRADE);
    TraceTag(ttidDHCPServer, "NSF_WINNT_SVR_UPGRADE = %x", NSF_WINNT_SVR_UPGRADE);

    if ((NSF_WINNT_WKS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SBS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SVR_UPGRADE & dwSetupFlags))
    {
        TraceTag(ttidDHCPServer, "This is indeed an upgrade");
        m_fUpgrade = TRUE;
    }
    else
    {
        TraceTag(ttidDHCPServer, "This is NOT an upgrade");
    }

    return S_OK;
}

STDMETHODIMP CDHCPServer::Removing()
{
    m_eInstallAction = eActRemove;

    return S_OK;
}

STDMETHODIMP CDHCPServer::Validate()
{
    return S_OK;
}

STDMETHODIMP CDHCPServer::CancelChanges()
{
    return S_OK;
}

STDMETHODIMP CDHCPServer::ApplyRegistryChanges()
{
    HRESULT     hr = S_OK;

    TraceTag(ttidDHCPServer, "CDHCPServer::ApplyRegistryChanges()");

    TraceTag(ttidDHCPServer, "ApplyRegistryChanges -- Unattend: %d", m_fUnattend);
    TraceTag(ttidDHCPServer, "ApplyRegistryChanges -- Upgrade: %d", m_fUpgrade);

    if (m_eInstallAction == eActInstall)
    {
        TraceTag(ttidDHCPServer, "ApplyRegistryChanges -- Installing");
        // We used to only do this on upgrade, now we'll do it all the time.
        // If there's no answerfile info for the restore files, then we
        // won't do anything, and life will still be fine.
        //
        hr = HrRestoreRegistry();
        if (FAILED(hr))
        {
            TraceHr(ttidDHCPServer, FAL, hr, FALSE,
                "CDHCPServer::ApplyRegistryChanges - HrRestoreRegistry non-fatal error");
            hr = S_OK;
        }

        if (m_fUnattend && !m_fUpgrade)
        {

// I'm if 0'ing this out for now. All of this work was done to appease Ram Cherala
// and whoever asked him to do the same for SP4. Now we're hearing from Ye Gu that
// we don't even want this code on normal NT4/NT5. Who knows what the desire will
// be in the future.
//
#if 0
            hr = HrWriteUnattendedKeys();
            if (FAILED(hr))
            {
                TraceHr(ttidDHCPServer, FAL, hr, FALSE,
                    "CDHCPServer::ApplyRegistryChanges - HrWriteUnattendedKeys non-fatal error");
                hr = S_OK;
            }
#endif
        }

        // Bug #153298: Mark as upgrade so DS info is upgraded
        if (m_fUpgrade)
        {
            DHCP_MARKUPG_ROUTINE    pfnDhcpMarkUpgrade;
            HMODULE                 hmod;

            hr = HrLoadLibAndGetProc(L"dhcpssvc.dll",
                                     "DhcpMarkUpgrade",
                                     &hmod,
                                     (FARPROC *)&pfnDhcpMarkUpgrade);
            if (SUCCEEDED(hr))
            {
                TraceTag(ttidDHCPServer, "Upgrading DS info...");
                pfnDhcpMarkUpgrade();
                FreeLibrary(hmod);
            }
            else
            {
                TraceHr(ttidDHCPServer, FAL, hr, FALSE,
                    "CDHCPServer::ApplyRegistryChanges - Failed to upgrade DS info. Non-fatal");
                hr = S_OK;
            }
        }
    }
    else if (m_eInstallAction == eActRemove)
    {
        TraceTag(ttidDHCPServer, "ApplyRegistryChanges -- removing");

        // RAID #154380: Clean up DS before uninstalling
        {
           DHCP_CLEAR_DS_ROUTINE    pfnDhcpDsClearHostServerEntries;
           HMODULE                  hmod;

           hr = HrLoadLibAndGetProc(L"dhcpsapi.dll",
                                    "DhcpDsClearHostServerEntries",
                                    &hmod,
                                    (FARPROC *)&pfnDhcpDsClearHostServerEntries);
           if (SUCCEEDED(hr))
           {
               TraceTag(ttidDHCPServer, "Removing DS info...");
               pfnDhcpDsClearHostServerEntries();
               FreeLibrary(hmod);
           }
           else
           {
               TraceHr(ttidDHCPServer, FAL, hr, FALSE,
                   "CDHCPServer::ApplyRegistryChanges - Failed to remove DS info. Non-fatal");
               hr = S_OK;
           }
        }
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceHr(ttidDHCPServer, FAL, hr, (hr == S_FALSE), "CDHCPServer::ApplyRegistryChanges");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dll\exports.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E X P O R T S . C P P
//
//  Contents:   Exported functions from NETCFG.DLL
//
//  Notes:
//
//  Author:     danielwe   5 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"

#define REGSTR_PATH_SVCHOST     L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"

HRESULT
HrPrepareForSvchostEnum (
    IN     PCWSTR                   pszService,
    IN OUT CServiceManager*         pscm,
    IN OUT CService*                psvc,
    OUT    LPQUERY_SERVICE_CONFIG*  ppOriginalConfig,
    OUT    HKEY*                    phkeySvchost,
    OUT    PWSTR*                   ppszValueNameBuffer,
    OUT    DWORD*                   pcchValueNameBuffer,
    OUT    PWSTR*                   ppmszValueBuffer,
    OUT    DWORD*                   pcbValueBuffer)
{
    // Initialize the output parameters.
    //
    *ppOriginalConfig    = NULL;
    *phkeySvchost        = NULL;
    *ppszValueNameBuffer = NULL;
    *pcchValueNameBuffer = 0;
    *ppmszValueBuffer    = NULL;
    *pcbValueBuffer      = 0;

    const DWORD dwScmAccess = STANDARD_RIGHTS_REQUIRED |
                              SC_MANAGER_CONNECT       |
                              SC_MANAGER_LOCK;

    const DWORD dwSvcAccess = STANDARD_RIGHTS_REQUIRED |
                              SERVICE_QUERY_CONFIG     |
                              SERVICE_CHANGE_CONFIG;

    // Open the service and lock the service database so we can change
    // the service's configuration.
    //
    HRESULT hr = pscm->HrOpenService (
                        psvc,
                        pszService,
                        WITH_LOCK,
                        dwScmAccess,
                        dwSvcAccess);
    if (SUCCEEDED(hr))
    {
        // Query the service's current configuration in the event we
        // need to revert what we set.
        //
        LPQUERY_SERVICE_CONFIG pOriginalConfig;
        hr = psvc->HrQueryServiceConfig (&pOriginalConfig);
        if (SUCCEEDED(hr))
        {
            // Open the svchost software key and query information
            // about it like the length of the longest value name
            // and longest value.
            //
            HKEY hkeySvchost;
            hr = HrRegOpenKeyEx (
                    HKEY_LOCAL_MACHINE, REGSTR_PATH_SVCHOST,
                    KEY_READ | KEY_SET_VALUE,
                    &hkeySvchost);

            if (SUCCEEDED(hr))
            {
                DWORD cchMaxValueNameLen;
                DWORD cbMaxValueLen;

                LONG lr = RegQueryInfoKeyW (hkeySvchost,
                            NULL,   // lpClass
                            NULL,   // lpcbClass
                            NULL,   // lpReserved
                            NULL,   // lpcSubKeys
                            NULL,   // lpcbMaxSubKeyLen
                            NULL,   // lpcbMaxClassLen
                            NULL,   // lpcValues
                            &cchMaxValueNameLen,
                            &cbMaxValueLen,
                            NULL,   // lpcbSecurityDescriptor
                            NULL    // lpftLastWriteTime
                            );
                hr = HRESULT_FROM_WIN32 (lr);
                if (SUCCEEDED(hr))
                {
                    // Make sure the name buffer length (in bytes) is a
                    // multiple of sizeof(WCHAR).  This is because we expect
                    // to use RegEnumValue which accepts and returns buffer
                    // size in characters.  We tell it the the buffer
                    // capacity (in characters) is count of bytes divided
                    // by sizeof(WCHAR).  So, to avoid any round off
                    // error (which would not occur in our favor) we make
                    // sure that the buffer size is a multiple of
                    // sizeof(WCHAR).
                    //
                    INT cbFraction = cbMaxValueLen % sizeof(WCHAR);
                    if (cbFraction)
                    {
                        cbMaxValueLen += sizeof(WCHAR) - cbFraction;
                    }

                    // Need room for the null terminator as RegQueryInfoKey
                    // doesn't return it.
                    //
                    cchMaxValueNameLen++;

                    // Allocate buffers for the longest value name and value
                    // data for our caller to use.
                    //
                    PWSTR pszValueNameBuffer = (PWSTR)
                                MemAlloc (cchMaxValueNameLen * sizeof(WCHAR));

                    PWSTR pmszValueBuffer = (PWSTR) MemAlloc (cbMaxValueLen);

                    if ((pszValueNameBuffer != NULL) && 
						(pmszValueBuffer != NULL))
                    {
                        *ppOriginalConfig    = pOriginalConfig;
                        *phkeySvchost        = hkeySvchost;

                        *ppszValueNameBuffer = pszValueNameBuffer;
                        *pcchValueNameBuffer = cchMaxValueNameLen;

                        *ppmszValueBuffer    = pmszValueBuffer;
                        *pcbValueBuffer      = cbMaxValueLen;

                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (FAILED(hr))
                {
                    RegCloseKey (hkeySvchost);
                }
            }

            if (FAILED(hr))
            {
                MemFree (pOriginalConfig);
            }
        }
    }
    TraceError ("HrPrepareForSvchostEnum", hr);
    return hr;
}

STDAPI
SvchostChangeSvchostGroup (
    PCWSTR pszService,
    PCWSTR pszNewGroup
    )
{
    Assert (pszService);
    Assert (pszNewGroup);

    static const WCHAR c_pszBasePath [] =
        L"%SystemRoot%\\System32\\svchost.exe -k ";

    // Validate the new group name by making sure it doesn't exceed
    // MAX_PATH when combined with the base path.
    //
    if (!pszService  || !pszNewGroup  ||
        !*pszService || !*pszNewGroup ||
        (lstrlenW (c_pszBasePath) + lstrlenW (pszNewGroup) > MAX_PATH))
    {
        return E_INVALIDARG;
    }

    // Form the new image path based on the base path and the new group
    // name.
    //
    WCHAR pszImagePath [MAX_PATH + 1];
    lstrcpyW (pszImagePath, c_pszBasePath);
    lstrcatW (pszImagePath, pszNewGroup);

    // Need to change the ImagePath of the service as well as the
    // Svchost Group values.  The implementation tries to ensure that
    // both of these changes are made or neither of them are made.
    //

    // Prepare for the enumeration by setting up a few pieces of information
    // first.  HrPrepareForSvchostEnum sets up all of these variables.
    //
    // SCM is opened and locked, pszService is opened for config change.
    //
    CServiceManager         scm;
    CService                svc;

    // pszService's current configration is obtained in the event we
    // need to rollback, we'll use this info to reset the ImagePath.
    //
    LPQUERY_SERVICE_CONFIG  pOriginalConfig;

    // hkeySvcHost is opened at REGSTR_PATH_SVCHOST and is used to
    // enumerate the values under it.
    //
    HKEY                    hkeySvcHost;

    // These buffers are allocated so that RegEnumValue will have a place
    // to store what was enumerated.
    //
    PWSTR  pszValueNameBuffer;
    DWORD   cchValueNameBuffer;
    PWSTR  pmszValueBuffer;
    DWORD   cbValueBuffer;

    HRESULT hr = HrPrepareForSvchostEnum (
                    pszService,
                    &scm,
                    &svc,
                    &pOriginalConfig,
                    &hkeySvcHost,
                    &pszValueNameBuffer,
                    &cchValueNameBuffer,
                    &pmszValueBuffer,
                    &cbValueBuffer);
    if (SUCCEEDED(hr))
    {
        // Set the new image path of the service.
        //
        hr = svc.HrSetImagePath (pszImagePath);
        if (SUCCEEDED(hr))
        {
            // fAddNewValue will be set to FALSE if we've found an existing
            // group name value.
            //
            BOOL fAddNewValue = TRUE;
            BOOL fChanged;

            // Now perform the enumeration.  For each value enumerated,
            // make sure the service name is included in the multi-sz
            // for the valuename that matches the new group name.  For all
            // other values, make sure the service name is not included
            // in the multi-sz.
            //
            DWORD dwIndex = 0;
            do
            {
                DWORD dwType;
                DWORD cchValueName = cchValueNameBuffer;
                DWORD cbValue      = cbValueBuffer;

                hr = HrRegEnumValue (hkeySvcHost, dwIndex,
                        pszValueNameBuffer, &cchValueName,
                        &dwType,
                        (LPBYTE)pmszValueBuffer, &cbValue);

                if (SUCCEEDED(hr) && (REG_MULTI_SZ == dwType))
                {
                    // If we find a value that matches the group name,
                    // make sure the service is a part of the mutli-sz
                    // value.
                    //
                    if (0 == lstrcmpiW (pszNewGroup, pszValueNameBuffer))
                    {
                        // Since we found an existing group name, we don't
                        // need to add a new one.
                        //
                        fAddNewValue = FALSE;

                        PWSTR pmszNewValue;

                        hr = HrAddSzToMultiSz (pszService,
                                pmszValueBuffer,
                                STRING_FLAG_DONT_MODIFY_IF_PRESENT |
                                STRING_FLAG_ENSURE_AT_END,
                                0,
                                &pmszNewValue,
                                &fChanged);

                        if (SUCCEEDED(hr) && fChanged)
                        {
                            hr = HrRegSetMultiSz (hkeySvcHost,
                                    pszNewGroup,
                                    pmszNewValue);

                            MemFree (pmszNewValue);
                        }
                    }

                    // Otherwise, since the value does not match the group
                    // name, make sure the service is NOT part of the
                    // mutli-sz value.
                    //
                    else
                    {
                        RemoveSzFromMultiSz (pszService,
                            pmszValueBuffer, STRING_FLAG_REMOVE_ALL,
                            &fChanged);

                        if (fChanged)
                        {
                            hr = HrRegSetMultiSz (hkeySvcHost,
                                    pszValueNameBuffer,
                                    pmszValueBuffer);
                        }
                    }
                }
                else if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                    break;
                }

                dwIndex++;
            }
            while (S_OK == hr);

            // If we need to add a new group name, do so.
            //
            if (SUCCEEDED(hr) && fAddNewValue)
            {
                // Add pszService to a empty multi-sz.  This has the effect
                // of creating a multi-sz from a single string.
                //
                PWSTR pmszNewValue;

                hr = HrAddSzToMultiSz (pszService,
                        NULL,
                        STRING_FLAG_ENSURE_AT_END, 0,
                        &pmszNewValue, &fChanged);
                if (S_OK == hr)
                {
                    // We know that it should have been added, so assert
                    // that the multi-sz "changed".
                    //
                    Assert (fChanged);

                    // Add the new value by setting the multi-sz in the
                    // registry.
                    //
                    hr = HrRegSetMultiSz (hkeySvcHost,
                            pszNewGroup,
                            pmszNewValue);

                    MemFree (pmszNewValue);
                }
            }
        }

        RegCloseKey (hkeySvcHost);

        MemFree (pmszValueBuffer);
        MemFree (pszValueNameBuffer);
        MemFree (pOriginalConfig);
    }
    TraceError ("SvchostChangeSvchostGroup", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dll\implinc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       I M P L I N C . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   25 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncxbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\bindings.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       B I N D I N G S . C P P
//
//  Contents:   The basic datatypes for binding objects.  Bindpaths are
//              ordered collections of component pointers.  Bindsets
//              are a collection of bindpaths.  This module implements
//              the operations that are valid on binpaths and bindsets.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "bindings.h"
#include "complist.h"
#include "diagctx.h"
#include "nceh.h"

//+---------------------------------------------------------------------------
// CBindPath -
//

bool
CBindPath::operator< (
    const CBindPath& OtherPath) const
{
    TraceFileFunc(ttidNetCfgBind);
    
    const_iterator iterThis;
    const_iterator iterOther;
    NETCLASS Class;
    NETCLASS OtherClass;

    for (iterThis = begin(), iterOther = OtherPath.begin();
         (iterThis != end()) && (iterOther != OtherPath.end());
         iterThis++, iterOther++)
    {
        Class = (*iterThis)->Class();
        OtherClass = (*iterOther)->Class();

        if (Class > OtherClass)
        {
            return TRUE;
        }
        else if (Class < OtherClass)
        {
            return FALSE;
        }
    }

    return size() > OtherPath.size();
}

bool
CBindPath::operator> (
    const CBindPath& OtherPath) const
{
    TraceFileFunc(ttidNetCfgBind);
    const_iterator iterThis;
    const_iterator iterOther;
    NETCLASS Class;
    NETCLASS OtherClass;

    for (iterThis = begin(), iterOther = OtherPath.begin();
         (iterThis != end()) && (iterOther != OtherPath.end());
         iterThis++, iterOther++)
    {
        Class = (*iterThis)->Class();
        OtherClass = (*iterOther)->Class();

        if (Class < OtherClass)
        {
            return TRUE;
        }
        else if (Class > OtherClass)
        {
            return FALSE;
        }
    }

    return size() < OtherPath.size();
}

BOOL
CBindPath::FAllComponentsLoadedOkayIfLoadedAtAll () const
{
    TraceFileFunc(ttidNetCfgBind);
    CBindPath::const_iterator iter;
    const CComponent* pComponent;

    Assert (this);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pComponent->Ext.FLoadedOkayIfLoadedAtAll())
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
CBindPath::FGetPathToken (
    OUT PWSTR pszToken,
    IN OUT ULONG* pcchToken) const
{
    TraceFileFunc(ttidNetCfgBind);
    const_iterator iter;
    const CComponent* pComponent;
    ULONG cchIn;
    ULONG cch;
    BOOL fFirstTime;

    Assert (this);
    Assert (pcchToken);

    if (pszToken)
    {
        *pszToken = 0;
    }
    cchIn = *pcchToken;
    cch = 0;

    for (iter = begin(), fFirstTime = TRUE; iter != end(); iter++)
    {
        if (!fFirstTime)
        {
            cch += 2;
            if (pszToken && (cch <= cchIn))
            {
                wcscat (pszToken, L"->");
            }
        }
        else
        {
            fFirstTime = FALSE;
        }

        pComponent = *iter;
        Assert (pComponent);

        cch += wcslen (pComponent->PszGetPnpIdOrInfId());
        if (pszToken && (cch <= cchIn))
        {
            wcscat (pszToken, pComponent->PszGetPnpIdOrInfId());
        }
    }

    *pcchToken = cch;
    return cch <= cchIn;
}

BOOL
CBindPath::FIsSameBindPathAs (
    IN const CBindPath* pOtherPath) const
{
    TraceFileFunc(ttidNetCfgBind);
    UINT unThisSize;
    UINT unOtherSize;
    UINT cb;

    Assert (this);
    Assert (pOtherPath);

    unThisSize = this->size();
    unOtherSize = pOtherPath->size();

    if ((0 == unThisSize) || (0 == unOtherSize) || (unThisSize != unOtherSize))
    {
        return FALSE;
    }

    // Sizes are non-zero and equal.  Compare the data.
    //
    cb = (UINT)((BYTE*)(end()) - (BYTE*)(begin()));
    Assert (cb == unThisSize * sizeof(CComponent*));

    return (0 == memcmp (
                    (BYTE*)(this->begin()),
                    (BYTE*)(pOtherPath->begin()),
                    cb));
}

BOOL
CBindPath::FIsSubPathOf (
    IN const CBindPath* pOtherPath) const
{
    TraceFileFunc(ttidNetCfgBind);
    UINT unThisSize;
    UINT unOtherSize;
    UINT unSkipComponents;
    UINT cb;

    Assert (this);
    Assert (pOtherPath);

    unThisSize = this->size();
    unOtherSize = pOtherPath->size();

    if ((0 == unThisSize) || (0 == unOtherSize) || (unThisSize >= unOtherSize))
    {
        return FALSE;
    }

    // This size is less than other.  Compare the data starting at the
    // component pointer in the other path that will have the same depth
    // as this path.
    //
    cb = (UINT)((BYTE*)(end()) - (BYTE*)(begin()));

    // The component pointer in the other path that we start comparing at
    // is at an offset equal to the difference in path sizes.
    //
    // e.g. other path: a->b->c->d->e  size=5
    //       this path:       c->d->e  size=3
    // start comparing after skipping 5-3=2 components of the other path
    //
    Assert (unOtherSize > unThisSize);
    unSkipComponents = unOtherSize - unThisSize;

    return (0 == memcmp (
                    (BYTE*)(this->begin()),
                    (BYTE*)(pOtherPath->begin() + unSkipComponents),
                    cb));
}

HRESULT
CBindPath::HrAppendBindPath (
    IN const CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pBindPath);

    NC_TRY
    {
        insert (end(), pBindPath->begin(), pBindPath->end());
        DbgVerifyBindpath ();
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindPath::HrAppendBindPath");
    return hr;
}

HRESULT
CBindPath::HrAppendComponent (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pComponent);
    Assert (!FContainsComponent (pComponent));

    NC_TRY
    {
        push_back (const_cast<CComponent*>(pComponent));
        DbgVerifyBindpath ();
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindPath::HrAppendComponent");
    return hr;
}

HRESULT
CBindPath::HrGetComponentsInBindPath (
    IN OUT CComponentList* pComponents) const
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;
    CBindPath::const_iterator iter;
    const CComponent* pComponent;

    Assert (this);
    Assert (pComponents);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        hr = pComponents->HrInsertComponent (pComponent,
                INS_IGNORE_IF_DUP | INS_SORTED);

        if (S_OK != hr)
        {
            TraceHr (ttidError, FAL, hr, FALSE,
                "CBindPath::HrGetComponentsInBindPath");
            return hr;
        }
    }
    return S_OK;
}

HRESULT
CBindPath::HrInsertComponent (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pComponent);
    Assert (!FContainsComponent (pComponent));

    NC_TRY
    {
        insert (begin(), const_cast<CComponent*>(pComponent));
        DbgVerifyBindpath ();
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindPath::HrInsertComponent");
    return hr;
}

HRESULT
CBindPath::HrReserveRoomForComponents (
    IN UINT cComponents)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    NC_TRY
    {
        reserve (cComponents);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CBindPath::HrReserveRoomForComponents");
    return hr;
}

#if DBG
VOID
CBindPath::DbgVerifyBindpath ()
{
    TraceFileFunc(ttidNetCfgBind);
    const_iterator iter;
    const_iterator iterOther;
    const CComponent* pComponent;
    const CComponent* pOtherComponent;

    Assert (this);

    // Make sure the bindpath does not contain any duplicate component
    // pointers.
    //
    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        for (iterOther = begin(); iterOther != end(); iterOther++)
        {
            pOtherComponent = *iterOther;
            Assert (pOtherComponent);

            if (iter == iterOther)
            {
                continue;
            }

            Assert (pComponent != pOtherComponent);
        }
    }
}
#endif


//+---------------------------------------------------------------------------
// CBindingSet -
//

VOID
CBindingSet::Printf (
    TRACETAGID ttid,
    PCSTR pszPrefixLine) const
{
    TraceFileFunc(ttidNetCfgBind);
    WCHAR  pszBuf [1024];
    WCHAR* pch;
    ULONG  cch;

    Assert (this);

    if (pszPrefixLine)
    {
        g_pDiagCtx->Printf (ttid, pszPrefixLine);
    }

    const CBindPath* pBindPath;
    INT nIndex = 1;

    for (pBindPath = begin(); pBindPath != end(); pBindPath++, nIndex++)
    {
        pch = pszBuf + wsprintfW (pszBuf, L"%2i: ", nIndex);

        cch = celems(pszBuf) - wcslen(pszBuf) - 1;
        if (pBindPath->FGetPathToken (pch, &cch))
        {
            g_pDiagCtx->Printf (ttid, "%S\n", pszBuf);
        }
    }
}

BOOL
CBindingSet::FContainsBindPath (
    IN const CBindPath* pBindPathToCheckFor) const
{
    TraceFileFunc(ttidNetCfgBind);
    const CBindPath* pBindPath;

    Assert (this);
    Assert (pBindPathToCheckFor);

    for (pBindPath = begin(); pBindPath != end(); pBindPath++)
    {
        if (pBindPath->FIsSameBindPathAs (pBindPathToCheckFor))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
CBindingSet::FContainsComponent (
    IN const CComponent* pComponent) const
{
    TraceFileFunc(ttidNetCfgBind);
    const CBindPath* pBindPath;

    Assert (this);
    Assert (pComponent);

    for (pBindPath = begin(); pBindPath != end(); pBindPath++)
    {
        if (pBindPath->FContainsComponent (pComponent))
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
CBindingSet::HrAppendBindingSet (
    IN const CBindingSet* pBindSet)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;
    const CBindPath* pSrcPath;

    Assert (this);
    Assert (pBindSet);

    hr = S_OK;

    NC_TRY
    {
        for (pSrcPath = pBindSet->begin();
             pSrcPath != pBindSet->end();
             pSrcPath++)
        {
            if (!FContainsBindPath (pSrcPath))
            {
                insert (end(), *pSrcPath);
            }
        }
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindingSet::HrAppendBindingSet");
    return hr;
}

HRESULT
CBindingSet::HrAddBindPath (
    IN const CBindPath* pBindPath,
    IN DWORD dwFlags)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pBindPath);
    Assert (!pBindPath->FIsEmpty());
    Assert ((dwFlags & INS_ASSERT_IF_DUP) || (dwFlags & INS_IGNORE_IF_DUP));
    Assert ((dwFlags & INS_APPEND) || (dwFlags & INS_INSERT));
    Assert (!(INS_SORTED & dwFlags) && !(INS_NON_SORTED & dwFlags));

    if (FContainsBindPath (pBindPath))
    {
        // If the caller didn't tell us to ignore duplicates, we assert
        // if there is one because it is bad, bad, bad to have duplicate
        // bindpaths in the set.
        //
        // If we have a dup, we want the caller to be aware that it
        // is possible, and pass us the flag telling us to ignore it.
        // Otherwise, we assert to let them know. (And we still ignore
        // it.)
        Assert (dwFlags & INS_IGNORE_IF_DUP);

        return S_OK;
    }

    NC_TRY
    {
        // Either insert the bindpath or append it.
        //
        iterator iter = begin();

        if (dwFlags & INS_APPEND)
        {
            iter = end();
        }

        insert (iter, *pBindPath);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindingSet::HrAddBindPath");
    return hr;
}

HRESULT
CBindingSet::HrAddBindPathsInSet1ButNotInSet2 (
    IN const CBindingSet* pSet1,
    IN const CBindingSet* pSet2)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;
    const CBindPath* pBindPath;

    Assert (this);
    Assert (pSet1);
    Assert (pSet2);
    Assert ((this != pSet1) && (this != pSet2));

    hr = S_OK;

    for (pBindPath  = pSet1->begin();
         pBindPath != pSet1->end();
         pBindPath++)
    {
        if (pSet2->FContainsBindPath (pBindPath))
        {
            continue;
        }

        hr = HrAddBindPath (pBindPath, INS_IGNORE_IF_DUP | INS_APPEND);
        if (S_OK != hr)
        {
            break;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CBindingSet::HrAddBindPathsInSet1ButNotInSet2");
    return hr;
}

HRESULT
CBindingSet::HrCopyBindingSet (
    IN const CBindingSet* pSourceSet)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pSourceSet);

    NC_TRY
    {
        *this = *pSourceSet;
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindingSet::HrCopyBindingSet");
    return hr;
}

HRESULT
CBindingSet::HrGetAffectedComponentsInBindingSet (
    IN OUT CComponentList* pComponents) const
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;
    const CBindPath* pBindPath;

    Assert (this);
    Assert (pComponents);

    hr = S_OK;

    for (pBindPath = begin(); pBindPath != end(); pBindPath++)
    {
        hr = pComponents->HrInsertComponent (pBindPath->POwner(),
                INS_IGNORE_IF_DUP | INS_SORTED);

        if (S_OK != hr)
        {
            break;
        }

        // For bindpaths from a protocol to an adpater, we want to
        // add the adapter to the component list because it will need
        // to have its upper bind changed.
        //
        if (pBindPath->CountComponents() == 2)
        {
            const CComponent* pAdapter;

            pAdapter = pBindPath->PLastComponent();
            if (FIsEnumerated (pAdapter->Class()))
            {
                hr = pComponents->HrInsertComponent (pAdapter,
                        INS_IGNORE_IF_DUP | INS_SORTED);

                if (S_OK != hr)
                {
                    break;
                }
            }
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CBindingSet::HrGetAffectedComponentsInBindingSet");
    return hr;
}

HRESULT
CBindingSet::HrReserveRoomForBindPaths (
    IN UINT cBindPaths)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    NC_TRY
    {
        reserve (cBindPaths);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CBindingSet::HrReserveRoomForBindPaths");
    return hr;
}

VOID
CBindingSet::RemoveBindPath (
    IN const CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetCfgBind);
    CBindPath* pScan;

    for (pScan = begin(); pScan != end(); pScan++)
    {
        if (pScan->FIsSameBindPathAs (pBindPath))
        {
            erase (pScan);
            return;
        }
    }
}

VOID
CBindingSet::RemoveBindPathsWithComponent (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetCfgBind);
    CBindPath* pBindPath;

    Assert (this);
    Assert (pComponent);

    pBindPath = begin();
    while (pBindPath != end())
    {
        if (pBindPath->FContainsComponent(pComponent))
        {
            erase (pBindPath);
        }
        else
        {
            pBindPath++;
        }
    }
}

VOID
CBindingSet::RemoveSubpaths ()
{
    TraceFileFunc(ttidNetCfgBind);
    CBindPath* pCandidate;
    CBindPath* pBindPath;

    Assert (this);

    for (pBindPath = begin(); pBindPath != end(); pBindPath++)
    {
        pCandidate = begin();

        while (pCandidate != end())
        {
            if (pCandidate->FIsSubPathOf (pBindPath))
            {
                // FIsSubPathOf returns FALSE when asked if a bindpath
                // is a subpath of itself.  (Set-theorectially, this is
                // incorrect, but having it return FALSE for this case
                // prevents us from having to make another check.
                //
                Assert (pCandidate != pBindPath);

                erase (pCandidate);

                // If erasing a bindpath that occurs before the current
                // outer loop enumerator, we need to back it up because
                // the erase would move everything up by one, but we still
                // want to finish the inner loop for this current outer
                // bindpath.
                //
                if (pCandidate < pBindPath)
                {
                    pBindPath--;
                }
            }
            else
            {
                pCandidate++;
            }
        }
    }
}

VOID
CBindingSet::SortForPnpBind ()
{
    TraceFileFunc(ttidNetCfgBind);
    // Sort where bindpaths closes to the adapters come first.
    //
    sort<iterator> (begin(), end(), greater<CBindPath>());
}

VOID
CBindingSet::SortForPnpUnbind ()
{
    TraceFileFunc(ttidNetCfgBind);
    // Sort where bindpaths furthest from the adapters come first.
    //
    sort<iterator> (begin(), end(), less<CBindPath>());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\adapter.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       A D A P T E R. C P P
//
//  Contents:   Class installer functions for eumerated devices.
//
//  Notes:
//
//  Author:     billbe   11 Nov 1996
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "adapter.h"
#include "benchmrk.h"
#include "classinst.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "netcomm.h"


VOID
CiSetFriendlyNameIfNeeded(IN const COMPONENT_INSTALL_INFO &cii);

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetBusInfoFromInf
//
//  Purpose:    Finds an adapter's bus information as listed in its inf
//                  file.
//
//  Arguments:
//      hinfFile        [in] A handle to the component's inf file
//      szSectionName   [in] The inf section to search in
//      peBusType       [out] The bus type of the adapter
//      pulAdapterId    [out] The AdapterId of the adapter (Eisa and Mca)
//      pulAdapterMask  [out] The AdapterMask of the adapter (Eisa)
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   14 Jun 1997
//
//  Notes:
//
HRESULT
HrCiGetBusInfoFromInf (HINF hinfFile, COMPONENT_INSTALL_INFO* pcii)
{
    HRESULT hr = S_OK;
    if (InterfaceTypeUndefined == pcii->BusType)
    {
        // Find the inf line that contains BusType and retrieve it
        DWORD dwBusType;
        hr = HrSetupGetFirstDword(hinfFile, pcii->pszSectionName,
                L"BusType", &dwBusType);

        if (S_OK == hr)
        {
            pcii->BusType = EInterfaceTypeFromDword(dwBusType);
        }
        else
        {
            TraceTag (ttidError, "Inf missing BusType field.");
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetBusInfoFromInf");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallEnumeratedComponent
//
//  Purpose:    This function completes the install of an enumerated
//                      device.
//
//  Arguments:
//      hinf          [in] SetupApi handle to an inf file
//      hkeyInstance  [in] The registry instance key of the adapter
//                          during inf processing.
//      pcai           [in] A structure containing the component information
//                            See compinst.h for definition
//      hwndParent    [in] The handle to the parent, for displaying UI
//      hdi           [in] See Device Installer Api for more info
//      pdeid         [in] See Device Installer Api for more info
//
//  Returns:    HRESULT. S_OK if successful and no restart required,
//                          NETCFG_S_REBOOT if a reboot is required,
//                          or error code otherwise
//
//  Author:     billbe   28 Apr 1997
//
//  Notes:
//
HRESULT
HrCiInstallEnumeratedComponent (
    IN HINF hinf,
    IN HKEY hkeyInstance,
    IN const COMPONENT_INSTALL_INFO& cii)
{
    Assert (IsValidHandle (hinf));
    Assert (hkeyInstance);
    Assert (IsValidHandle (cii.hdi));
    Assert (cii.pdeid);

    HRESULT hr;

    // Because adapters can share descriptions, we may need to append
    // instance info so the user and other apps can differentiate.
    //
    // If the following fcn fails, we can still go on and
    // install the adapter.
    CiSetFriendlyNameIfNeeded (cii);

    // Is this a PCI multiport adapter where each port has the same
    // PnP Id? This is indicated by the inf value Port1DeviceNumber or
    // Port1FunctionNumber in the main section.
    //
    if (PCIBus == cii.BusType)
    {
        INFCONTEXT ctx;
        DWORD dwPortNumber;
        BOOL fUseDeviceNumber;
        DWORD dwFirstPort;

        hr = HrSetupGetFirstDword (hinf, cii.pszSectionName,
                L"Port1DeviceNumber", &dwFirstPort);

        if (S_OK == hr)
        {
            // The port number is based on the device number.
            fUseDeviceNumber = TRUE;
        }
        else
        {
            hr = HrSetupGetFirstDword (hinf, cii.pszSectionName,
                    L"Port1FunctionNumber", &dwFirstPort);

            if (S_OK == hr)
            {
                // The port number is based on the function number.
                fUseDeviceNumber = FALSE;
            }
        }

        if (S_OK == hr)
        {
            // We have a mapping so now we need to get the address of the
            // device (device and function number).
            //

            DWORD dwAddress;
            hr = HrSetupDiGetDeviceRegistryProperty(cii.hdi, cii.pdeid,
                    SPDRP_ADDRESS, NULL, (BYTE*)&dwAddress, sizeof(dwAddress),
                    NULL);

            if (S_OK == hr)
            {
                // Use our mapping to get the correct port number.
                //
                DWORD dwPortLocation;

                dwPortLocation = fUseDeviceNumber ?
                        HIWORD(dwAddress) : LOWORD(dwAddress);

                // Make sure the port location (either device or
                // function number) is greater than or equal to the first
                // port number, otherwise we will get a bogus port number.
                //
                if (dwPortLocation >= dwFirstPort)
                {
                    dwPortNumber = dwPortLocation - dwFirstPort + 1;

                    // Now store the port number in the device key for internal
                    // consumption.
                    HKEY hkeyDev;
                    hr = HrSetupDiCreateDevRegKey (cii.hdi, cii.pdeid,
                            DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL, &hkeyDev);

                    if (S_OK == hr)
                    {
                        (VOID) HrRegSetDword (hkeyDev, L"Port", dwPortNumber);

                        RegCloseKey (hkeyDev);
                    }

                    // Store the port in the driver key for public
                    // consumption.
                    //
                    (VOID) HrRegSetDword (hkeyInstance, L"Port",
                            dwPortNumber);
                }
            }
        }
        else
        {
            // No mapping available, so we won't display port number.
            hr = S_OK;
        }
    }

    // Update any advanced parameters that do not have a current value
    // with a default.
    UpdateAdvancedParametersIfNeeded (cii.hdi, cii.pdeid);

    // On fresh installs, INetCfg will be starting this adapter,
    // so we have to make sure we don't.
    //
    if (!cii.fPreviouslyInstalled)
    {
        (VOID) HrSetupDiSetDeipFlags (cii.hdi, cii.pdeid, DI_DONOTCALLCONFIGMG,
                SDDFT_FLAGS, SDFBO_OR);
    }

    // Now finish the install of the adapter.
    //

    TraceTag(ttidClassInst, "Calling SetupDiInstallDevice");
#ifdef ENABLETRACE
    CBenchmark bmrk;
    bmrk.Start("SetupDiInstallDevice");
#endif //ENABLETRACE

    hr = HrSetupDiInstallDevice (cii.hdi, cii.pdeid);

#ifdef ENABLETRACE
    bmrk.Stop();
    TraceTag(ttidBenchmark, "%s : %s seconds",
    bmrk.SznDescription(), bmrk.SznBenchmarkSeconds (2));
#endif //ENABLETRACE

    if (!cii.fPreviouslyInstalled)
    {
        (VOID) HrSetupDiSetDeipFlags (cii.hdi, cii.pdeid, DI_DONOTCALLCONFIGMG,
                SDDFT_FLAGS, SDFBO_XOR);
    }

    TraceHr (ttidError, FAL, hr, HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr,
        "HrCiInstallEnumeratedComponent");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiRegOpenKeyFromEnumDevs
//
//  Purpose:    Enumerates through each device in an HDEVINFO and returns an
//              hkey to its driver key.
//
//  Arguments:
//      hdi        [in]     See Device Installer Api
//      dwIndex    [inout] The index of the device to retrieve
//      samDesired [in]     The access level of the hkey
//      phkey      [out]    The device's driver key
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise
//
//  Author:     billbe   13 Jun 1997
//
//  Notes:
//
HRESULT
HrCiRegOpenKeyFromEnumDevs(HDEVINFO hdi, DWORD* pIndex, REGSAM samDesired,
                           HKEY* phkey)
{
    Assert(IsValidHandle(hdi));
    Assert (phkey);

    // Initialize output parameter.
    *phkey = NULL;

    SP_DEVINFO_DATA deid;
    HRESULT         hr;

    // enumerate through the devices
    while ((S_OK == (hr = HrSetupDiEnumDeviceInfo(hdi, *pIndex, &deid))))
    {
        // open the adapter's instance key
        HRESULT hrT;

        hrT = HrSetupDiOpenDevRegKey(hdi, &deid, DICS_FLAG_GLOBAL,
                    0, DIREG_DRV, samDesired, phkey);
        if (S_OK == hrT)
        {
            break;
        }
        else
        {
            // If the key does not exists this is a phantom device,
            // (or if this device is hosed, we want to ignore it too)
            // move on to the next one and delete this one from
            // our list
            (*pIndex)++;
            (VOID)SetupDiDeleteDeviceInfo(hdi, &deid);
        }
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr,
            "HrCiRegOpenKeyFromEnumDevs");
    return hr;
}

///////////////Legacy NT4 app support///////////////////////////////////

VOID
AddOrRemoveLegacyNt4AdapterKey (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN const GUID* pInstanceGuid,
    IN PCWSTR pszDescription,
    IN LEGACY_NT4_KEY_OP Op)
{
    Assert (IsValidHandle (hdi));
    Assert (pdeid);
    Assert (FImplies ((LEGACY_NT4_KEY_ADD == Op), pInstanceGuid));
    Assert (FImplies ((LEGACY_NT4_KEY_ADD == Op), pszDescription));

    extern const WCHAR c_szRegKeyNt4Adapters[];
    const WCHAR c_szRegValDescription[] = L"Description";
    const WCHAR c_szRegValServiceName[] = L"ServiceName";

    PWSTR pszDriver;
    HRESULT hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc (
            hdi, pdeid, SPDRP_DRIVER, NULL, (BYTE**)&pszDriver);

    if (S_OK == hr)
    {
        PWSTR pszNumber = wcsrchr (pszDriver, L'\\');
        if (pszNumber && *(++pszNumber))
        {
            PWSTR pszStopString;
            ULONG Instance = 0;
            HKEY hkeyAdapters;

            Instance = wcstoul (pszNumber, &pszStopString, c_nBase10);

            // The NT4 key was one based so increment the instance number.
            Instance++;

            DWORD Disp;
            hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyNt4Adapters,
                    0, KEY_WRITE, NULL, &hkeyAdapters, &Disp);

            if (S_OK == hr)
            {
                WCHAR szInstanceNumber [12];
                _snwprintf (szInstanceNumber, celems(szInstanceNumber) - 1,
                        L"%d", Instance);

                HKEY hkeyInstance;

                if (LEGACY_NT4_KEY_ADD == Op)
                {
                    hr = HrRegCreateKeyEx (hkeyAdapters, szInstanceNumber, 0,
                            KEY_WRITE, NULL, &hkeyInstance, NULL);

                    if (S_OK == hr)
                    {
                        WCHAR szGuid[c_cchGuidWithTerm];
                        StringFromGUID2 (*pInstanceGuid, szGuid,
                                         c_cchGuidWithTerm);
                        hr = HrRegSetValueEx (hkeyInstance,
                                c_szRegValServiceName, REG_SZ,
                                (const BYTE*)szGuid, sizeof (szGuid));
                        TraceHr (ttidError, FAL, hr, FALSE,
                                 "AddAdapterToNt4Key: Setting Service Name "
                                 "in legacy registry");

                        hr = HrRegSetValueEx (hkeyInstance,
                                c_szRegValDescription, REG_SZ,
                                (const BYTE*)pszDescription,
                                CbOfSzAndTerm (pszDescription));
                        TraceHr (ttidError, FAL, hr, FALSE,
                                 "AddAdapterToNt4Key: Setting Description in "
                                 "legacy registry");

                        RegCloseKey (hkeyInstance);
                    }
                }
                else
                {
                    hr = HrRegDeleteKey (hkeyAdapters, szInstanceNumber);

                }

                RegCloseKey (hkeyAdapters);
            }
        }

        delete [] pszDriver;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\adapter.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       A D A P T E R . H
//
//  Contents:   Net class installer functions for eumerated devices.
//
//  Notes:
//
//  Author:     billbe   11 Nov 1996
//
//---------------------------------------------------------------------------

#pragma once

#include "compdefs.h"
#include "ncsetup.h"

struct COMPONENT_INSTALL_INFO;

HRESULT
HrCiGetBusInfoFromInf (
    IN HINF hinfFile,
    OUT COMPONENT_INSTALL_INFO* pcii);

struct ADAPTER_OUT_PARAMS
{
    OUT GUID    InstanceGuid;
    OUT DWORD   dwCharacter;
};

struct ADAPTER_REMOVE_PARAMS
{
    IN BOOL     fBadDevInst;
    IN BOOL     fNotifyINetCfg;
};


//+--------------------------------------------------------------------------
//
//  Function:   EInterfaceTypeFromDword
//
//  Purpose:    Safely converts a dword to the enumerated type INTERFACE_TYPE
//
//  Arguments:
//      dwBusType [in] The bus type of the adapter
//
//  Returns:    INTERFACE_TYPE. See ntioapi.h for more info.
//
//  Author:     billbe   28 Jun 1997
//
//  Notes:
//
inline INTERFACE_TYPE
EInterfaceTypeFromDword(DWORD dwBusType)
{
    INTERFACE_TYPE eBusType;

    if (dwBusType < MaximumInterfaceType)
    {
        // Since dwBusType is less than MaximumInterfaceType, we can safely
        // cast dwBusType to the enumerated value.
        //
        eBusType = static_cast<INTERFACE_TYPE>(dwBusType);
    }
    else
    {
        eBusType = InterfaceTypeUndefined;
    }

    return eBusType;
}

HRESULT
HrCiInstallEnumeratedComponent(HINF hinf, HKEY hkeyInstance,
                               IN const COMPONENT_INSTALL_INFO& cii);

inline void
CiSetReservedField(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                   const VOID* pvInfo)
{
    AssertH(IsValidHandle(hdi));

    SP_DEVINSTALL_PARAMS deip;
    (void) HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
    deip.ClassInstallReserved = reinterpret_cast<ULONG_PTR>(pvInfo);
    (void) HrSetupDiSetDeviceInstallParams(hdi, pdeid, &deip);
}

inline void
CiClearReservedField(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    AssertH(IsValidHandle(hdi));

    SP_DEVINSTALL_PARAMS deip;
    (void) HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
    deip.ClassInstallReserved = NULL;
    (void) HrSetupDiSetDeviceInstallParams(hdi, pdeid, &deip);
}

HRESULT
HrCiRemoveEnumeratedComponent(IN const COMPONENT_INSTALL_INFO cii);

HRESULT
HrCiRegOpenKeyFromEnumDevs(HDEVINFO hdi, DWORD* pIndex, REGSAM samDesired,
                           HKEY* phkey);

inline HRESULT
HrCiFilterOutPhantomDevs(HDEVINFO hdi)
{
    DWORD   dwIndex = 0;
    HRESULT hr;
    HKEY    hkey;

    // This call eliminates phantom devices
    while (SUCCEEDED(hr = HrCiRegOpenKeyFromEnumDevs(hdi, &dwIndex, KEY_READ,
            &hkey)))
    {
        // We don't need the hkey; we just wanted the phantoms removed
        RegCloseKey (hkey);
        // on to the next
        dwIndex++;
    }

    // No more items is not really an error
    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    return hr;
}


// Device friendly name functions and types.
//

enum DM_OP
{
    DM_ADD,
    DM_DELETE,
};

HRESULT
HrCiUpdateDescriptionIndexList(NETCLASS Class, PCWSTR pszDescription,
        DM_OP eOp, ULONG* pulIndex);


//////////////Legacy NT4 App support//////////////////////////

enum LEGACY_NT4_KEY_OP
{
    LEGACY_NT4_KEY_ADD,
    LEGACY_NT4_KEY_REMOVE,
};

VOID
AddOrRemoveLegacyNt4AdapterKey (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN const GUID* pInstanceGuid,
    IN PCWSTR pszDescription,
    IN LEGACY_NT4_KEY_OP Op);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\classinst.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C L A S S I N S T . H
//
//  Contents:   Defines the interface between the binding engine and the
//              network class installer.
//
//  Notes:
//
//  Author:     billbe   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"
#include "install.h"
#include "ncsetup.h"
#include <ntioapi.h>

struct COMPONENT_INSTALL_INFO
{
    NETCLASS                            Class;
    PCWSTR                              pszInfId;
    PCWSTR                              pszInfFile;
    HWND                                hwndParent;
    GUID                                InstanceGuid;
    BOOL                                fPreviouslyInstalled;
    DWORD                               dwCharacter;
    PCWSTR                              pszSectionName;
    PCWSTR                              pszDescription;
    PCWSTR                              pszPnpId;
    HDEVINFO                            hdi;
    PSP_DEVINFO_DATA                    pdeid;
    INTERFACE_TYPE                      BusType;
    BOOL                                fRemoteBoot;
};

HRESULT
HrCiGetClassAndInfFileOfInfId (
    IN PCWSTR pszInfId,
    OUT NETCLASS* pClass,
    OUT PWSTR pszInfFile);   // Must be _MAX_PATH long

HRESULT
HrCiIsInstalledComponent(
    IN COMPONENT_INSTALL_INFO* pcii,
    OUT HKEY* phkey);

HRESULT
HrCiInstallComponent (
    IN const COMPONENT_INSTALL_PARAMS& Params,
    OUT CComponent** ppComponent,
    OUT DWORD* pdwNewCharacter);

HRESULT
HrCiInstallFilterDevice (
    IN HDEVINFO hdi,
    IN PCWSTR pszInfId,
    IN CComponent* pAdapter,
    IN CComponent* pFilter,
    IN class CFilterDevice** ppFilterDevice);

HRESULT
HrCiInstallFromInfSection(
    IN HINF hinfFile,
    IN PCWSTR pszInfSectionName,
    IN HKEY hkeyRelative,
    IN HWND hwndParent,
    IN DWORD dwInstallFlags);

HRESULT
HrCiRemoveComponent (
    IN const CComponent* pComponent,
    OUT tstring* pstrRemoveSection OPTIONAL);

HRESULT
HrCiRemoveFilterDevice (
    IN HDEVINFO hdi,
    IN SP_DEVINFO_DATA* pdeid);


HRESULT
HrCiPrepareSelectDeviceDialog(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid);

HRESULT
HrCiRemoveNonEnumeratedComponent (
    IN HINF hinf,
    IN HKEY hkeyInstance,
    IN NETCLASS eClass,
    IN const GUID& InstanceGuid);


HRESULT
HrCiGetDriverInfo (
    IN     HDEVINFO hdi,
    IN OUT PSP_DEVINFO_DATA pdeid,
    IN     const GUID& guidClass,
    IN     PCWSTR pszInfId,
    IN     PCWSTR pszInfFile OPTIONAL);

HRESULT
HrCiGetDriverDetail(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PSP_DRVINFO_DATA pdrid,
    OUT PSP_DRVINFO_DETAIL_DATA* ppdridd);


HRESULT
HrCiSelectComponent(
    IN NETCLASS Class,
    IN HWND hwndParent,
    IN const CI_FILTER_INFO* pcfi,
    OUT COMPONENT_INSTALL_PARAMS** ppParams);

HRESULT
HrCiInstallComponentInternal(
    IN OUT COMPONENT_INSTALL_INFO* pcii);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\classinst.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C L A S S I N S T . C P P
//
//  Contents:   Defines the interface between the binding engine and the
//              network class installer.
//
//  Notes:
//
//  Author:     billbe   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "adapter.h"
#include "benchmrk.h"
#include "classinst.h"
#include "filtdev.h"
#include "netcfg.h"
#include "iatl.h"
#include "lockdown.h"
#include "ncatl.h"
#include "ncoc.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"
#include "ncwins.h"
#include "persist.h"
#include "provider.h"
#include "resource.h"
#include "util.h"


// HrRegisterNotificationDll functions
enum ciRegisterDllFunction {CIRDF_REGISTER, CIRDF_UNREGISTER};

//+--------------------------------------------------------------------------
//
//  Function:   HrCiRegDeleteComponentNetworkKey
//
//  Purpose:    This function deletes the component key strInstanceGuid
//                  (and its subkeys) under the Network\<guidClass> tree.
//
//  Arguments:
//      Class            [in] The class of the component
//      pszInstanceGuid  [in] The instance guid of the component
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   27 Apr 1997
//
//  Notes:
//
HRESULT
HrCiRegDeleteComponentNetworkKey (
    IN NETCLASS Class,
    IN PCWSTR pszInstanceGuid)
{
    HRESULT hr = S_OK;
    HKEY    hkeyClass = NULL;

    PCWSTR pszNetworkSubtreePath = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];

    // Open the proper class key in the Network tree
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, pszNetworkSubtreePath,
            KEY_WRITE, &hkeyClass);

    // Delete the instance key tree
    //
    if (S_OK == hr)
    {
        hr = HrRegDeleteKeyTree(hkeyClass, pszInstanceGuid);
        RegSafeCloseKey(hkeyClass);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRegDeleteComponentKey");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiRegisterNotificationDll
//
//  Purpose:    Registers or Unregisters a component's notification dll with
//                  COM
//
//  Arguments:
//      hkeyInstance [in] The handle to the instance key for the component
//      crdf         [in] CIRDF_REGISTER if we are registering,
//                              CIRDF_UNREGISTER if we are unregistering
//
//  Returns:    HRESULT. S_OK on if dll is successfully registered,
//                          S_FALSE, if the component has no dll to
//                          register, error code otherwise
//
//  Author:     billbe   23 Mar 1997
//
//  Notes:
//
HRESULT
HrCiRegisterNotificationDll(
    IN HKEY hkeyInstance,
    IN ciRegisterDllFunction crdf)
{
    Assert(hkeyInstance);

    HKEY hkeyNdi;
    HRESULT hr;

    // Open the ndi key in the component's instance key so we can get the
    // Dll path.
    hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);
    if (S_OK == hr)
    {
        // Get the notification dll path
        tstring strDllPath;
        hr = HrRegQueryString (hkeyNdi, L"ComponentDLL", &strDllPath);

        if (S_OK == hr)
        {
            TraceTag (ttidClassInst,
                    "Attempting to (un)register notification dll '%S'",
                    strDllPath.c_str());
            hr = (CIRDF_REGISTER == crdf) ?
                    HrRegisterComObject (strDllPath.c_str()) :
                        HrUnregisterComObject (strDllPath.c_str());
        }
        else
        {
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                // The presence of the value is optional, so return
                // S_OK if it was not found
                hr = S_OK;
            }
        }
        RegCloseKey (hkeyNdi);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRegisterNotificationDll");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallServices
//
//  Purpose:    Processes any Inf service sections using strInfSection as a
//                  base name
//
//  Arguments:
//      hinfFile      [in] A handle to the inf file
//      pszInfSection [in] The base section name
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   2 Apr 1997
//
//  Notes: See SetupInstallServicesFromInfSection in SetupApi for more
//          info.
//
HRESULT
HrCiInstallServices(
    IN HINF hinfFile,
    IN PCWSTR pszInfSection)
{
    Assert (IsValidHandle(hinfFile));
    Assert (pszInfSection && *pszInfSection);

    BOOL fSuccess;
    WCHAR szServiceSection[_MAX_PATH];

    // append .Services to the section name
    //
    swprintf (szServiceSection, L"%s.%s", pszInfSection,
            INFSTR_SUBKEY_SERVICES);

    // Process the Services section
    fSuccess = SetupInstallServicesFromInfSection (hinfFile,
                    szServiceSection, 0);
    if (!fSuccess)
    {
        // Since the section is optional, we can ignore
        // ERROR_SECTION_NOT_FOUND
        if (ERROR_SECTION_NOT_FOUND == GetLastError())
        {
            fSuccess = TRUE;
        }
    }

    // Any errors must be converted
    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrCiInstallServices (%S)", szServiceSection);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallFromInfSection
//
//  Purpose:    A wrapper function for SetupInstallFromInfSection. This
//              function handles setting up the copy files process for
//              SetupInstallFromInfSection as well.
//
//  Arguments:
//      hinfFile            [in] A handle to the inf file to install from
//      pszInfSectionName   [in] The section to install
//      hkeyRelative        [in] The key that will be used as the section's
//                                  HKR
//      hwndParent          [in] The HWND to the parent window, used for UI
//      dwInstallFlags      [in] See SetupInstallFromInfSection for info on
//                               these flags
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   4 Apr 1997
//
//  Notes: See SetupApi documentation for more info on
//              SetupInstallFromInfSection and
//              SetupInstallFilesFromInfSection
//
HRESULT
HrCiInstallFromInfSection(
    IN HINF hinfFile,
    IN PCWSTR pszInfSectionName,
    IN HKEY hkeyRelative,
    IN HWND hwndParent,
    IN DWORD dwInstallFlags)
{
    Assert (IsValidHandle (hinfFile));
    Assert (pszInfSectionName && *pszInfSectionName);

    HRESULT hr = S_OK;

    if (dwInstallFlags & SPINST_FILES)
    {
        // The next three variables are used for SetupApi's copy files process
        PSP_FILE_CALLBACK pfc;
        PVOID pvCtx;
        HSPFILEQ hfq;

        // If the inf file has a layout entry in its version section
        // we need to append its information for proper locations
        // of any files we need to copy.  If the call fails we can
        // still install, it just means the prompt for files will not
        // have the correct directory to begin with
        (VOID) SetupOpenAppendInfFile (NULL, hinfFile, NULL);

        // We need to create our own file queue so we can scan all the
        // files to be copied.  Scanning before committing our queue will
        // prompt the user if the files already exist in the destination
        //
        hr = HrSetupOpenFileQueue (&hfq);
        if (S_OK == hr)
        {
            BOOL fInGuiModeSetup = FInSystemSetup();

            hr = HrSetupInstallFilesFromInfSection (hinfFile, NULL, hfq,
                    pszInfSectionName, NULL, 0);

            // Set the default callback context
            // If the we are in system setup, we need to make sure the
            // callback doesn't display UI
            //
            if (S_OK == hr)
            {
                hr = HrSetupInitDefaultQueueCallbackEx (hwndParent,
                        (fInGuiModeSetup ? (HWND)INVALID_HANDLE_VALUE : NULL),
                        0, 0, NULL, &pvCtx);

                if (S_OK == hr)
                {
                    // Not doing anything special so use SetupApi default
                    // handler for file copy.
                    pfc = SetupDefaultQueueCallback;

                    // Scan the queue to see if the files are already in the
                    // destination and if so, prune them out.
                    DWORD dwScanResult;
                    hr = HrSetupScanFileQueueWithNoCallback (hfq,
                            SPQ_SCAN_FILE_VALIDITY |
                            SPQ_SCAN_PRUNE_COPY_QUEUE, hwndParent,
                            &dwScanResult);

                    // Now commit the queue so any files needing to be
                    // copied, will be.  If the scan result is 1 then there
                    // is nothing to commit.
                    //
                    if ((S_OK == hr) && (1 != dwScanResult))
                    {
                        hr = HrSetupCommitFileQueue (hwndParent, hfq, pfc, pvCtx);
                    }

                    // We need to release the default context and close our
                    // file queue
                    //
                    SetupTermDefaultQueueCallback (pvCtx);
                    SetupCloseFileQueue (hfq);
                }
            }
        }
    }

    if ((S_OK == hr) && (dwInstallFlags & ~SPINST_FILES))
    {
        Assert (hkeyRelative);

        // Now we run all sections but CopyFiles
        hr = HrSetupInstallFromInfSection (hwndParent, hinfFile,
                pszInfSectionName, (dwInstallFlags & ~SPINST_FILES),
                hkeyRelative, NULL, 0, NULL, NULL, NULL, NULL);
    }

    TraceHr (ttidError, FAL, hr, HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr,
            "HrCiInstallFromInfSection");
    return hr;

}



//+--------------------------------------------------------------------------
//
//  Function:   HrCiDoCompleteSectionInstall
//
//  Purpose:    Runs all relevant sections of an inf file using strSection
//                   as the base section name.
//
//  Arguments:
//      hinfFile      [in] SetupApi handle to an inf file
//      hkeyRelative  [in] The registry key that will be the HKR
//                         key during inf processing.
//      pszSection    [in] Section name to install
//      hwndParent    [in] The handle to the parent, for
//                                   displaying UI
//      fEnumerated   [in] TRUE if this component is PnP enumerated
//                         FALSE otherwise
//
//  Returns:    HRESULT. S_OK if sucessful, error code otherwise
//
//  Author:     billbe   15 Apr 1997
//
//  Notes:
//
HRESULT
HrCiDoCompleteSectionInstall(
    IN HINF hinfFile,
    IN HKEY hkeyRelative,
    IN PCWSTR pszSection,
    IN HWND hwndParent,
    IN BOOL fEnumerated)
{
    Assert (IsValidHandle (hinfFile));
    Assert (FImplies (!fEnumerated, hkeyRelative));

    HRESULT hr = S_OK;

    // Only do this if there is a section name to work with
    if (pszSection && *pszSection)
    {
        // If this is an enumerated device, the service section and
        // the copy files section will be processed by the Device Installer
        // fcn SetupDiInstallDevice so we can exclude it from the following
        // calls.  But we do some processing based on registry and log config
        // entries so we will pre-run the registry section for enumerated
        // devices and exclude the others
        //

        // Run the section found using hkeyRelative as the HKR
        hr = HrCiInstallFromInfSection (hinfFile, pszSection,
                hkeyRelative, hwndParent,
                (fEnumerated ? (SPINST_REGISTRY | SPINST_LOGCONFIG) :
                        SPINST_ALL & ~SPINST_REGSVR));

        if (!fEnumerated)
        {
            // We need to run the Services section and
            // check for Winsock dependency if they aren't specified to be
            // excluded.
            //
            // Note:  Other sections may be added later.  The default is to
            // run all sections not listed in dwExcludeSectionFlags
            //
            if (S_OK == hr)
            {
                // run services section if it exists
                hr = HrCiInstallServices (hinfFile, pszSection);
                if (S_OK == hr)
                {
                    // Bug #383239: Wait till services are installed before
                    // running the RegisterDlls section
                    //
                    hr = HrCiInstallFromInfSection (hinfFile, pszSection,
                                                    hkeyRelative, hwndParent,
                                                    SPINST_REGSVR);
                }
            }

        }

        if (S_OK == hr)
        {

            //sb This part can be called for either add or remove. We
            //sb are moving only the remove part forward. This should
            //sb still be performed for add.
            //
            // Determine if a .Winsock section exists for the
            // section specified in szActualSection

            PCWSTR pszSubSection = wcsstr(pszSection, L".Remove");

            if(!pszSubSection || wcscmp(pszSubSection, L".Remove"))
            {
                hr = HrAddOrRemoveWinsockDependancy (hinfFile, pszSection);
            }

            // These other extensions are undocumented and some have been
            // added by external groups.  We don't want any of them
            // processed for enumerated components.
            //
            if ((S_OK == hr) && !fEnumerated)
            {
                // Process the additional INF extensions (SNMP Agent,
                // PrintMonitors, etc.)
                //
                hr = HrProcessAllINFExtensions (hinfFile, pszSection);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr),
            "HrCiDoCompleteSectionInstall");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiRemoveNonEnumeratedComponent
//
//  Purpose:    This will run the remove section and delete the network
//                  instance key for the component if necessary.  This
//                  function is called for partially (i.e. failed install)
//                  and fully installed components
//
//  Arguments:
//      hinf              [in] The handle to the component's inf file
//      hkeyInstance      [in] The handle to the component's instance key
//      Class             [in] The class of the component
//      InstanceGuid      [in] The instance guid of the component
//      pstrRemoveSection [out] Optional pointer to a tstring which receives
//                              the remove section name.
//
//  Returns:    HRESULT. S_OK if successful, NETCFG_S_REBOOT if successful
//                  but a reboot is required, or an error code otherwise
//
//  Author:     billbe   10 Dec 1996
//              Revised  27 Apr 1997
//
//  Notes:
//
HRESULT
HrCiRemoveNonEnumeratedComponent(
    IN HINF hinf,
    IN HKEY hkeyInstance,
    IN NETCLASS Class,
    IN const GUID& InstanceGuid,
    OUT tstring* pstrRemoveSection OPTIONAL)
{
    Assert (IsValidHandle (hinf));
    Assert (IsValidHandle (hkeyInstance));

    static const WCHAR c_szRemoveSectionSuffix[] = L".Remove";

    // We get the remove section name and process all relevant sections
    // We also try to unregister any Notify objects available
    //
    WCHAR szRemoveSection[_MAX_PATH];
    DWORD cbBuffer = sizeof (szRemoveSection);
    HRESULT hr = HrRegQuerySzBuffer (hkeyInstance, REGSTR_VAL_INFSECTION,
                    szRemoveSection, &cbBuffer);

    if (S_OK == hr)
    {
        wcscat (szRemoveSection, c_szRemoveSectionSuffix);
        if (pstrRemoveSection)
        {
            pstrRemoveSection->assign(szRemoveSection);
        }
        hr = HrCiDoCompleteSectionInstall (hinf, hkeyInstance,
                szRemoveSection, NULL, NULL);
    }
    // Whether unregistering the notify object is successful or not,
    // we must fully remove the component.
    (VOID) HrCiRegisterNotificationDll (hkeyInstance, CIRDF_UNREGISTER);

    // Now we need to remove the component key in the Network tree
    // We need to do this regardless of any previous errors
    // so we don't need the return value.
    WCHAR szGuid[c_cchGuidWithTerm];
    StringFromGUID2 (InstanceGuid, szGuid, c_cchGuidWithTerm);
    (VOID) HrCiRegDeleteComponentNetworkKey (Class, szGuid);

    // if all went well, set the return value based on whether a reboot
    // is required or not or any error from HrRegisterNotificationDll.
    //
    if (S_FALSE == hr)
    {
        // S_FALSE is okay but should not be returned by this fcn.
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRemoveNonEnumeratedComponent");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiRemoveComponent
//
//  Purpose:    Called from INetCfg, this will uninstall a network component.
//
//  Arguments:
//      pComponent        [in] The component to uninstall.
//      pstrRemoveSection [out] Optional pointer to a tstring which receives
//                              the remove section name.
//
//  Returns:    HRESULT. S_OK if successful, NETCFG_S_REBOOT if successful
//                  but a reboot is required, or an error code otherwise
//
//  Author:     billbe   10 Dec 1996
//              Revised  27 Apr 1997
//
//  Notes:
//
HRESULT
HrCiRemoveComponent(
    IN const CComponent* pComponent,
    OUT tstring* pstrRemoveSection OPTIONAL)
{
    Assert (pComponent);

    HINF hinf = NULL;
    HDEVINFO hdi = NULL;
    SP_DEVINFO_DATA deid;
    HKEY hkeyInstance = NULL;
    HRESULT hr = S_OK;

    // If this is an enumerated net class component, then we need to
    // create the Device Installer structures for HrSetupDiRemoveDevice
    //
    if (FIsEnumerated (pComponent->Class()))
    {
        if (pComponent->m_dwCharacter & NCF_PHYSICAL)
        {
            // The binding engine calls us to remove physical devices
            // only when we need to potentially cleanup the information
            // we saved away when the class installer removed the device.
            // This happens when the class installer is told to remove
            // the device (which it does) and then notifies the binding
            // engine to remove it from its data structures.  The binding
            // engine then calls this method to cleanup this info we
            // set so that the binding engine could notify components of
            // its removal.
            //
            // We can also be called here when a physical component is
            // removed (with the binding engine write lock held by someone)
            // and then readded immediately.  The new component will get
            // the same PnpId as the removed one but the bindng engine still
            // has the removed component in its structures.  When this
            // condition is detected, the binding engine will remove the
            // old instance (by calling us here).  In this case, if we were
            // to open the device info on pComponent->m_pszPnpId, we'd open
            // the new instance that was added.  We don't want to do this.
            // We just want to cleanup any of the information that we set
            // for the binding engine when we first removed the device.
            //

            HKEY hkeyComponent;
            hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    c_szTempNetcfgStorageForUninstalledEnumeratedComponent,
                    KEY_WRITE, &hkeyComponent);

            if (S_OK == hr)
            {
                WCHAR szGuid[c_cchGuidWithTerm];
                INT cch = StringFromGUID2 (pComponent->m_InstanceGuid, szGuid,
                        c_cchGuidWithTerm);

                Assert (c_cchGuidWithTerm == cch);

                (VOID) HrRegDeleteKeyTree (hkeyComponent, szGuid);
                RegCloseKey (hkeyComponent);
            }
        }
        else
        {
            // Create a device info list
            hr = HrOpenDeviceInfo (pComponent->Class(),
                    pComponent->m_pszPnpId, &hdi, &deid);

            if (S_OK == hr)
            {
                // removals must go through device installer
                // hook (NetClassInstaller).  The function we are
                // in can only be called if the caller has the write lock
                // so we need to indicate this to the device installer hook
                // through our reserved data.
                ADAPTER_REMOVE_PARAMS arp = {0};
                CiSetReservedField (hdi, &deid, &arp);

                // removals must go through device installer
                // hook (NetClassInstaller).
                hr = HrSetupDiCallClassInstaller (DIF_REMOVE, hdi, &deid);

                // clear the reserved field so we don't delete it later
                CiClearReservedField (hdi, &deid);

                if (S_OK == hr)
                {
                    hr = FSetupDiCheckIfRestartNeeded (hdi, &deid) ?
                            NETCFG_S_REBOOT : S_OK;
#ifdef ENABLETRACE
                    if (NETCFG_S_REBOOT == hr)
                    {
                        TraceTag (ttidClassInst, "***********************************"
                                "**************************************************");

                        TraceTag (ttidClassInst, "The component %S needs a reboot "
                                "in order to function", pComponent->m_pszPnpId);

                        TraceTag (ttidClassInst, "***********************************"
                            "**************************************************");
                    }
#endif //ENABLETRACE
                }
                SetupDiDestroyDeviceInfoList (hdi);
            }
        }
    }
    else
    {
        // For non enumerated components, the instance key is the
        // component key
        hr = pComponent->HrOpenInstanceKey (KEY_ALL_ACCESS, &hkeyInstance,
                NULL, NULL);

        if (S_OK == hr)
        {
            if (NC_NETCLIENT == pComponent->Class ())
            {
                hr = HrCiDeleteNetProviderInfo (hkeyInstance, NULL, NULL);
            }


            if (S_OK == hr)
            {
                hr = pComponent->HrOpenInfFile(&hinf);

                if( S_OK == hr )
                {
                    // Remove the component
                    hr = HrCiRemoveNonEnumeratedComponent ( hinf,
                            hkeyInstance, pComponent->Class(),
                            pComponent->m_InstanceGuid,
                            pstrRemoveSection);
                }
            }
        }

        RegSafeCloseKey (hkeyInstance);
    }

    TraceHr (ttidError, FAL, hr, NETCFG_S_REBOOT == hr,
            "HrCiRemoveComponent (%S)", pComponent->PszGetPnpIdOrInfId());
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetDriverInfo
//
//  Purpose:    Finds a component's driver information (in the inf file) and
//              creates a Device Info Data structure containing that
//              information as the structure's selected driver.
//              (see Device Installer Api for more info).
//
//  Arguments:
//      hdi        [in] See Device Installer Api documentation for more info.
//      pdeid      [in, out] See Device Installer Api documentation for
//                    more info. Should be allocated by caller, but empty.
//      guidClass  [in] The class guid for the component.
//      pszInfId   [in] The id of the component as found in its inf.
//      pszInfFile [in] Optional. The inf file for the component.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   11 Mar 1997
//
//  Notes:
//
HRESULT
HrCiGetDriverInfo (
    IN     HDEVINFO hdi,
    IN OUT PSP_DEVINFO_DATA pdeid,
    IN     const GUID& guidClass,
    IN     PCWSTR pszInfId,
    IN     PCWSTR pszInfFile OPTIONAL)
{
    HRESULT hr;

    Assert (IsValidHandle (hdi));
    Assert (pdeid);
    Assert (pszInfId);

    // Copy the Id since we may need to change it.
    //
    WCHAR szId[_MAX_PATH];
    wcscpy (szId, pszInfId);

    // We cannot generate ids via HrSetupDiCreateDeviceInfo if they contain
    // slashes (e.g. Eisa\*pnp0232), so we need to convert any slashes in
    // the instance id to ampersands.
    //
    int iPos = 0;
    while (szId[iPos])
    {
        if (L'\\' == szId[iPos])
        {
            szId[iPos] = L'&';
        }
        ++iPos;
    }

    // First, create a [temporary] device info. This will be used to
    // find the component's Inf file.
    hr = HrSetupDiCreateDeviceInfo (hdi, szId, guidClass, NULL, NULL,
            DICD_GENERATE_ID, pdeid);

    if (S_OK == hr)
    {
        // In order to find the Inf file, Device Installer Api needs the
        // component id which it calls the Hardware id.
        //

        // We need to include an extra null since this registry value is a
        // multi-sz
        //
        wcsncpy (szId, pszInfId, iPos);
        szId[iPos + 1] = 0;

        hr = HrSetupDiSetDeviceRegistryProperty (hdi, pdeid, SPDRP_HARDWAREID,
                (const BYTE*)szId, CbOfSzAndTerm (szId) + sizeof(WCHAR));

        if (S_OK == hr)
        {
            // Get the install params and set the class for compat flag
            // This will use the device's class guid as a filter when
            // searching through infs, speeding things up.  We can also
            // let Device Installer Api know that we want to use a single
            // inf. if we can't get the params and set it it isn't an error
            // since it only slows things down a bit
            //
            SP_DEVINSTALL_PARAMS deip;
            hr = HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);
            if (S_OK == hr)
            {
                deip.FlagsEx |= DI_FLAGSEX_USECLASSFORCOMPAT;

                // If we were not given an inf file to use...
                // We have a map of known components and their inf files.
                // If this component is in the map then we can set the
                // driver path in the device info data and
                // set the enumerate a single inf flag.  This will
                // cause the device installer to just look at the specified
                // inf file for the driver node.
                //

                // We only do this if the node doesn't already have a file
                // name set.
                //
                if (!(*deip.DriverPath))
                {
                    if (pszInfFile && *pszInfFile)
                    {
                        wcscpy (deip.DriverPath, pszInfFile);
                    }
                    else
                    {
                        FInfFileFromComponentId (pszInfId, deip.DriverPath);
                    }
                }

                if (*deip.DriverPath)
                {

                    TraceTag (ttidClassInst, "Class Installer was given %S "
                             "as a filename for %S", deip.DriverPath,
                             pszInfId);
                    deip.Flags |= DI_ENUMSINGLEINF;

                    if ((0 == _wcsicmp(L"netrasa.inf", deip.DriverPath)) ||
                        (0 == _wcsicmp(L"netpsa.inf",  deip.DriverPath)))
                    {
                        deip.Flags |= DI_NOFILECOPY;
                    }
                }
#ifdef ENABLETRACE
                else
                {
                    TraceTag (ttidNetcfgBase,
                              "Perf Warning: No knowledge of INF file for the '%S' "
                              "component.  SetupApi is now thrashing the disk looking for it.",
                              pszInfId);
                }
#endif // ENABLETRACE

                // For non-device classes, we need to allow excluded
                // drivers in order to get any driver list returned.
                if (!FIsEnumerated (guidClass))
                {
                    deip.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;
                }

                (VOID) HrSetupDiSetDeviceInstallParams (hdi, pdeid, &deip);
            }

            // Now we let Device Installer Api build a driver list based on
            // the information we have given so far.  This will result in the
            // Inf file being found if it exists in the usual Inf directory
            //
#ifdef ENABLETRACE
    CBenchmark bmrk;
    bmrk.Start ("SetupDiBuildDriverInfoList");
#endif //ENABLETRACE

            hr = HrSetupDiBuildDriverInfoList (hdi, pdeid,
                    SPDIT_COMPATDRIVER);
#ifdef ENABLETRACE
    bmrk.Stop();
    TraceTag (ttidBenchmark, "%s : %s seconds",
            bmrk.SznDescription(), bmrk.SznBenchmarkSeconds (2));
#endif //ENABLETRACE

            if (S_OK == hr)
            {
                // HrSetupDiSelectBestCompatDrv finds and selects the best
                // driver for the device.
                //
                SP_DRVINFO_DATA drid;
                hr = HrSetupDiSelectBestCompatDrv(hdi, pdeid);

                if (HRESULT_FROM_SETUPAPI(ERROR_NO_COMPAT_DRIVERS) == hr)
                {
                    // Make the ERROR_NO_COMPAT_DRIVERS case look like what
                    // it really means -- the requested component's driver
                    // info (i.e. inf) could not be found.
                    //
                    hr = SPAPI_E_NO_DRIVER_SELECTED;
                }
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                // We couldn't find an inf file which means we cannot
                // selected the driver for this component.
                //
                hr = SPAPI_E_NO_DRIVER_SELECTED;
            }
        }

        // if anything failed, we should remove the device node we created
        if (FAILED(hr))
        {
            (VOID) SetupDiDeleteDeviceInfo (hdi, pdeid);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetDriverInfo");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetClassAndInfFileOfInfId
//
//  Purpose:    Finds a component's class and inf file.
//
//  Arguments:
//      pszInfId   [in]  The Id of the component as found in its Inf.
//      pClass     [out] The class of the component.
//      pszInfFile [out] The filename of the component's inf
//                       (must be _MAX_PATH long).
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   16 Mar 1998
//
//  Notes:
//
HRESULT
HrCiGetClassAndInfFileOfInfId (
    IN PCWSTR pszInfId,
    OUT NETCLASS* pClass,
    OUT PWSTR pszInfFile)   // Must be _MAX_PATH long
{
    HRESULT hr;
    const COMPONENT_INFO* pCompInfo;
    HDEVINFO hdi;

    Assert (pszInfId && *pszInfId);
    Assert (pClass);
    Assert (pszInfFile);

    hr = S_OK;

    // First, try the fast route by seeing if it's in our internal map.
    //
    pCompInfo = PComponentInfoFromComponentId (pszInfId);
    if (pCompInfo)
    {
        *pClass = NetClassEnumFromGuid (*pCompInfo->pguidClass);

        if (FIsValidNetClass (*pClass))
        {
            wcsncpy (pszInfFile, pCompInfo->pszInfFile, _MAX_PATH);
            pszInfFile [_MAX_PATH - 1] = 0;
        }
        else
        {
            hr = SPAPI_E_INVALID_CLASS;
        }
    }
    else
    {
        // Create a device info list.
        //
        hr = HrSetupDiCreateDeviceInfoList (NULL, NULL, &hdi);
        if (S_OK == hr)
        {
            SP_DEVINFO_DATA deid;

            // Get the driver info for the component and set it as the
            // selected driver
            //
            hr = HrCiGetDriverInfo (hdi, &deid, GUID_NULL, pszInfId, NULL);
            if (S_OK == hr)
            {
                SP_DRVINFO_DATA drid;

                // Get the selected driver.
                //
                hr = HrSetupDiGetSelectedDriver (hdi, &deid, &drid);
                if (S_OK == hr)
                {
                    // Set the class output parameter from the dev info data
                    // structure (HrGetDriverInfo updates this field if a driver
                    // was found)
                    //
                    *pClass = NetClassEnumFromGuid (deid.ClassGuid);

                    if (!FIsValidNetClass (*pClass))
                    {
                        hr = SPAPI_E_INVALID_CLASS;
                    }
                    else
                    {
                        PSP_DRVINFO_DETAIL_DATA pdridd;

                        // Now get the driver's detailed information
                        //
                        hr = HrCiGetDriverDetail (hdi, &deid, &drid,
                                                 &pdridd);
                        if (S_OK == hr)
                        {
                            // Get the inf filename and set the
                            // output parameter.
                            //
                            wcsncpy (pszInfFile, pdridd->InfFileName,
                                _MAX_PATH);
                            pszInfFile[_MAX_PATH - 1] = 0;

                            MemFree (pdridd);
                        }
                    }
                }
            }
            SetupDiDestroyDeviceInfoList (hdi);
        }
    }

    if (S_OK != hr)
    {
        *pClass = NC_INVALID;
        *pszInfFile = 0;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetClassAndInfFileOfInfId");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetDriverDetail
//
//  Purpose:    Creates and fills a PSP_DRVINFO_DETAIL_DATA structure
//                  with detailed information about the pDevInfoData's
//                  selected driver
//
//  Arguments:
//      hdi     [in] See Device Installer Api documentation for more info
//      pdeid   [in] See Device Installer Api documentation for more info
//                          This value is NULL for non-physical net
//                          components.
//      pdrid   [in] See Device Installer Api documentation for more info
//      ppdridd [out] See Device Installer Api documentation for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   11 Mar 1997
//
//  Notes:
//
HRESULT
HrCiGetDriverDetail (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid OPTIONAL,
    OUT PSP_DRVINFO_DATA pdrid,
    OUT PSP_DRVINFO_DETAIL_DATA* ppdridd)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);
    Assert(ppdridd);

    // initialize pdrid and set its cbSize field
    ZeroMemory (pdrid, sizeof (SP_DRVINFO_DATA));
    pdrid->cbSize = sizeof (SP_DRVINFO_DATA);

    HRESULT hr = S_OK;

    *ppdridd = NULL;

    // Get the selected driver for the component
    hr = HrSetupDiGetSelectedDriver (hdi, pdeid, pdrid);
    if (S_OK == hr)
    {
        // Get driver detail info
        hr = HrSetupDiGetDriverInfoDetail (hdi, pdeid, pdrid, ppdridd);
    }

    // clean up on failure
    if (FAILED(hr))
    {
        if (*ppdridd)
        {
            MemFree (*ppdridd);
            *ppdridd = NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetDriverDetail");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiRegSetComponentInformation
//
//  Purpose:    Stores component information under the instance key of
//                  the component.
//
//  Arguments:
//      hkeyInstance [in] Component's instance registry key.
//      pcii         [in] Component's information to store in hkeyInstance.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   11 Mar 1997
//
//  Notes:
//
HRESULT
HrCiRegSetComponentInformation(
    IN HKEY hkeyInstance,
    IN COMPONENT_INSTALL_INFO* pcii)
{
    Assert(hkeyInstance);
    Assert(pcii);

    HRESULT hr = S_OK;

    BOOL fIsEnumerated = FIsEnumerated (pcii->Class);

    // Store the characteristics, inf path, and main
    // install section for the component
    //

    hr = HrRegSetDword (hkeyInstance, L"Characteristics", pcii->dwCharacter);

    if (FAILED(hr))
    {
        goto exit;
    }

    if (!fIsEnumerated)
    {
        hr = HrRegSetSz (hkeyInstance, L"InfPath" /*REGSTR_VAL_INFPATH*/,
                pcii->pszInfFile);

        if (FAILED(hr))
        {
            goto exit;
        }

        hr = HrRegSetSz (hkeyInstance, L"InfSection"/*REGSTR_VAL_INFSECTION*/,
                pcii->pszSectionName);

        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // For non-enumerated components, store description into the registry.
    //
    if (!fIsEnumerated)
    {
        hr = HrRegSetSz (hkeyInstance, L"Description", pcii->pszDescription);

        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // If this component is already installed, then there is no need to write
    // the following information
    //
    if (FIsEnumerated (pcii->Class) && !pcii->fPreviouslyInstalled &&
                FIsPhysicalAdapter (pcii->Class, pcii->dwCharacter) &&
                (InterfaceTypeUndefined != pcii->BusType))
    {
        hr = HrRegSetSzAsUlong (hkeyInstance, L"BusType",
                pcii->BusType, c_nBase10);

        if (FAILED(hr))
        {
            goto exit;
        }
    }

    hr = HrRegSetSz (hkeyInstance, L"ComponentId", pcii->pszInfId);

exit:

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRegSetComponentInformation");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiCreateInstanceKey
//
//  Purpose:    Creates an instance key for the component.  For enumerated
//                devices, this is
//                HKLM\System\CCS\Control\Class\<net guid>\<instance id>
//                For non-enumerated components, this is under
//                HKLM\System\CCS\Control\Network\<Class Guid>\<Instance Guid>
//
//  Arguments:
//      pcii          [inout] Component install info structure.
//      phkeyInstance [out]   The component's registry instance key.
//
//  Returns:    HRESULT
//
//  Author:     billbe   22 Mar 1997
//
//  Notes:
//
HRESULT
HrCiCreateInstanceKey(
    IN COMPONENT_INSTALL_INFO* pcii,
    OUT HKEY* phkeyInstance)
{
    Assert (pcii);
    Assert (phkeyInstance);
    Assert (FImplies (FIsEnumerated (pcii->Class),
                    IsValidHandle (pcii->hdi) && pcii->pdeid));

    HRESULT hr = S_OK;

    // initialize the HKEY parameter
    *phkeyInstance = NULL;

    // Create the instance key for this component under the
    // Network\<net guid> tree.  This will be the component's
    // instance key for all but physical net class components.  Their
    // instance key is created by Device Installer Api and lives under the
    // Pnp Net Class driver tree.

    // If the object is an enumerated component then we let
    // the Device Installer api do the work
    //
    if (FIsEnumerated (pcii->Class))
    {

        // We need to create the adapter's driver key under
        // the Pnp Net Class Driver tree.
        //

        hr = HrSetupDiCreateDevRegKey (pcii->hdi,
                pcii->pdeid, DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                NULL, NULL, phkeyInstance);
    }
    else
    {
        // Not a physical net adapter so the component key is
        // the instance key

        // First, create the instance GUID
        hr = CoCreateGuid (&pcii->InstanceGuid);

        // Now create the key
        if (S_OK == hr)
        {
            WCHAR szInstanceKeyPath[_MAX_PATH];

            CreateInstanceKeyPath (pcii->Class, pcii->InstanceGuid,
                    szInstanceKeyPath);

            hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE,
                     szInstanceKeyPath,
                     REG_OPTION_NON_VOLATILE,
                     KEY_ALL_ACCESS,
                     NULL,
                     phkeyInstance,
                     NULL);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiCreateInstanceKey");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetPropertiesFromInf
//
//  Purpose:    Retrieves a set of the component's proerties from the inf
//                  file.
//
//  Arguments:
//      hinfFile [in] A handle to the component's inf file
//      pcii     [inout] The component info structure
//                       See compinfo.h for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   14 Jun 1997
//
//  Notes:
//
HRESULT
HrCiGetPropertiesFromInf (
    IN HINF hinfFile,
    IN OUT COMPONENT_INSTALL_INFO* pcii)
{
    Assert (IsValidHandle (hinfFile));
    Assert (pcii);
    Assert (pcii->pszSectionName);

    // Find the inf line that contains Characteristics and retrieve it

    HRESULT hr = HrSetupGetFirstDword (hinfFile, pcii->pszSectionName,
            L"Characteristics", &pcii->dwCharacter);

    if ((S_OK == hr) &&
            (FIsPhysicalAdapter(pcii->Class, pcii->dwCharacter)))
    {
        hr = HrCiGetBusInfoFromInf (hinfFile, pcii);
    }
#ifdef DBG
    else if (FAILED(hr))
    {
        TraceTag(ttidError, "Inf contains no Characteristics field");
    }
#endif // DBG

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetPropertiesFromInf");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiIsInstalledComponent
//
//  Purpose:    Checks if the component is already installed
//
//
//  Arguments:
//      pcici  [in] A structure containing the component information
//                       See compinst.h for definition
//      phkey  [out] The registry instance key of the adapter
//                     during inf processing. only set if fcn returns S_OK
//
//  Returns:    HRESULT - S_OK if the component is already installed
//                        S_FALSE if the component is not already installed
//                        A win32 converted error otherwise
//
//  Author:     billbe   17 Sep 1997
//
//  Notes:
//
HRESULT
HrCiIsInstalledComponent (
    IN COMPONENT_INSTALL_INFO* pcii,
    OUT HKEY* phkey)
{
    HRESULT hr;

    Assert(pcii);

    if (phkey)
    {
        *phkey = NULL;
    }

    // If this is an enumerated component, we just check for NetCfgInstanceId
    // in the instance (driver) key.
    //
    if (FIsEnumerated (pcii->Class))
    {
        HKEY hkey;
        hr = HrSetupDiOpenDevRegKey (pcii->hdi, pcii->pdeid, DICS_FLAG_GLOBAL,
                0, DIREG_DRV, KEY_ALL_ACCESS, &hkey);

        if (S_OK == hr)
        {
            WCHAR szGuid[c_cchGuidWithTerm];
            DWORD cbGuid = sizeof (szGuid);
            hr = HrRegQuerySzBuffer (hkey, L"NetCfgInstanceId", szGuid,
                    &cbGuid);

            if (S_OK == hr)
            {
                IIDFromString (szGuid, &pcii->InstanceGuid);
                if (phkey)
                {
                    *phkey = hkey;
                }
            }
            else
            {
                RegCloseKey (hkey);
                hr = S_FALSE;
            }
        }
        else if ((SPAPI_E_KEY_DOES_NOT_EXIST == hr) ||
                (SPAPI_E_DEVINFO_NOT_REGISTERED == hr))

        {
            TraceTag(ttidClassInst, "Component is not known by Net Config");
            hr = S_FALSE;
        }
    }
    else
    {
        // For non-enumerated components, we check the netcfg "config blob" to
        // determine if this component is isntalled.
        CNetConfig NetConfig;
        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);

        if (S_OK == hr)
        {
            CComponent* pComponent;
            pComponent = NetConfig.Core.Components.
                    PFindComponentByInfId(pcii->pszInfId, NULL);

            if (pComponent)
            {
                pcii->InstanceGuid = pComponent->m_InstanceGuid;
                if (phkey)
                {
                    hr = pComponent->HrOpenInstanceKey(KEY_ALL_ACCESS, phkey,
                            NULL, NULL);
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr, "HrCiIsInstalledComponent");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiCreateInstanceKeyAndProcessMainInfSection
//
//  Purpose:    Processes a component's main inf section and
//              storing, in the registry, any extra information needed for
//              component initialization
//
//  Arguments:
//      hinf  [in] Handle to the component's inf file.
//      pcii  [inout] Will be filled with information about the
//                    component.
//      phkey [out] Handle to the component's registry instance key.
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   15 Nov 1996
//
//  Notes:
//
HRESULT
HrCiCreateInstanceKeyAndProcessMainInfSection(
    IN HINF hinf,
    IN COMPONENT_INSTALL_INFO* pcii,
    OUT HKEY* phkey)
{
#if defined(REMOTE_BOOT)
    GUID c_guidRemoteBoot;
    static const WCHAR c_szRemoteBootAdapterGuid[] =
            L"{54C7D140-09EF-11D1-B25A-F5FE627ED95E}";

    DEFINE_GUID(c_guidRemoteBoot, 0x54c7d140, 0x09ef, 0x11d1, 0xb2, 0x5a, 0xf5, 0xfe, 0x62, 0x7e, 0xd9, 0x5e);
#endif // defined(REMOTE_BOOT)

    Assert (IsValidHandle (hinf));
    Assert (pcii);
    Assert (phkey);

    // The properties retrieved here will be written to the registry
    // later.
    HRESULT hr = HrCiGetPropertiesFromInf (hinf, pcii);

    if (S_OK == hr)
    {
        BOOL fEnumerated = FIsEnumerated (pcii->Class);

        // If this component is enumerated, then we need to know if it
        // is a remote boot adapter.
        if (fEnumerated)
        {
            Assert (IsValidHandle (pcii->hdi));
            Assert (pcii->pdeid);

#if defined(REMOTE_BOOT)
            // If this adapter is a remote boot adapter, then we have
            // to use a pre-determined GUID
            //
            if (S_OK == HrIsRemoteBootAdapter(pcii->hdi, pcii->pdeid))
            {
                pcai->m_fRemoteBoot = TRUE;
                pcii->InstanceGuid = c_guidRemoteBoot;
            }
#endif // defined(REMOTE_BOOT)

        }

        // Is this a fresh install or a reinstall?
        hr = HrCiIsInstalledComponent(pcii, phkey);

        if (S_FALSE == hr)
        {
            hr = S_OK;

            // Fresh install
            //

            if (S_OK == hr)
            {
                // For non-physical components, the relative key will
                // be the driver instance key which is under the class
                // branch of the Network key. Its form is
                // <Class GUID>/<instance GUID>.
                // For physical components, the key is under
                // the Pnp class driver tree. The next call will
                // create this key

                hr = HrCiCreateInstanceKey(pcii, phkey);

                if (fEnumerated)
                {
                    // If  we don't have an instance
                    // guid (i.e. not remote boot adapter),
                    // get one
                    if (GUID_NULL == pcii->InstanceGuid)
                    {
                        hr = CoCreateGuid(&pcii->InstanceGuid);
#ifdef ENABLETRACE
                        WCHAR szGuid[c_cchGuidWithTerm];
                        StringFromGUID2(pcii->InstanceGuid, szGuid,
                                c_cchGuidWithTerm);
                        TraceTag(ttidClassInst, "NetCfg Instance Guid %S "
                                "generated for %S",
                                 szGuid,
                                 pcii->pszInfId);
#endif // ENABLETRACE
                    }
                }
            }
        }
        else if (S_OK == hr)
        {
            // This component is being reinstalled
            pcii->fPreviouslyInstalled = TRUE;
        }

        if (S_OK == hr)
        {
            // Now that the instance key is created, we need to run
            // the main inf sections
            //
            hr = HrCiDoCompleteSectionInstall(hinf, *phkey,
                    pcii->pszSectionName,
                    pcii->hwndParent, fEnumerated);

            // On failure of fresh installs, remove components
            if (FAILED(hr) && !pcii->fPreviouslyInstalled)
            {
                if (!fEnumerated)
                {
                    HrCiRemoveNonEnumeratedComponent (hinf, *phkey,
                        pcii->Class, pcii->InstanceGuid, NULL);
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrCiCreateInstanceKeyAndProcessMainInfSection");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiDoOemFileCopyIfNeeded
//
//  Purpose: Calls HrSetupCopyOemInf if strInfPath is not already in the
//              inf directory.  This will copy an Oem inf to the inf
//              directory with a new name.
//
//  Arguments:
//      pszInfPath [in]  Path to the inf file
//      pszNewName [out] The new name of the copied inf file
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   15 May 1997
//
//  Notes:
//
HRESULT
HrCiDoOemFileCopyIfNeeded(
    IN PCWSTR pszInfPath,
    OUT PWSTR pszNewName)
{
    Assert (pszInfPath);
    Assert (pszNewName);

    HRESULT hr = S_OK;
    WCHAR szInfDir[_MAX_PATH] = {0};

    // fill buffer with path to %windir%
    GetSystemWindowsDirectory (szInfDir, _MAX_PATH);

    // the inf directory is %windir%\inf
    //
    wcscat (szInfDir, L"\\");
    wcscat (szInfDir, L"Inf");

    // Extract the directory from the filename
    //
    PWSTR pszEnd = wcsrchr (pszInfPath, L'\\');
    DWORD cch;
    if (pszEnd)
    {
        cch = pszEnd - pszInfPath;
    }
    else
    {
        cch = wcslen (pszInfPath);
    }

    // if the inf is not already in the inf directory, copy it there
    //
    if ((cch != wcslen (szInfDir)) ||
            (0 != _wcsnicmp (pszInfPath, szInfDir, cch)))
    {
        WCHAR szDestFilePath[_MAX_PATH];
        PWSTR pszDestFilename;
        hr = HrSetupCopyOemInfBuffer (pszInfPath, NULL, SPOST_PATH, 0,
                szDestFilePath, _MAX_PATH, &pszDestFilename);

        if (S_OK == hr)
        {
            wcscpy (pszNewName, pszDestFilename);
        }
    }
    else
    {
        // The inf is already in the right directory so just copy the
        // current filename component.
        if (pszEnd)
        {
            wcscpy (pszNewName, pszEnd + 1);
        }
        else
        {
            wcscpy (pszNewName, pszInfPath);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiDoOemFileCopyIfNeeded");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallNonEnumeratedComponent
//
//  Purpose:    This function completes the installation of a non-enumerated
//                  component
//
//  Arguments:
//      hinf [in] SetupApi handle to an inf file
//      hkey [in] The registry instance key of the adapter
//                during inf processing.
//      pcii [in] A structure containing the component information
//
//  Returns:    HRESULT. S_OK if successful, or error code otherwise
//
//  Author:     billbe   28 Apr 1997
//
//  Notes:
//
HRESULT
HrCiInstallNonEnumeratedComponent (
    IN HINF hinf,
    IN HKEY hkey,
    IN COMPONENT_INSTALL_INFO* pcii)
{
    // Register the notification dll for this component,
    // if it exists.
    HRESULT hr = HrCiRegisterNotificationDll(hkey, CIRDF_REGISTER);

    // Device Installer Api handles OEM files for
    // enumerated components in InstallDevice
    // Since this component is non-enumerated
    // we need to handle any oem files
    // manually.
    //

    // Copy the inf file if needed then store
    // the new inf name
    // Note: if the inf file does not need to
    // be copied, the new name will be the
    // old name without the directory info.
    //

    if (S_OK == hr)
    {
        WCHAR szNewName[_MAX_PATH];;
        hr = HrCiDoOemFileCopyIfNeeded (pcii->pszInfFile, szNewName);
        if (S_OK == hr)
        {
            // set the new path value in the registry.
            hr = HrRegSetSz (hkey, REGSTR_VAL_INFPATH, szNewName);

            if ((S_OK == hr) && (NC_NETCLIENT == pcii->Class))
            {
                // if this is a network client, do appropriate processing.
                hr = HrCiAddNetProviderInfo (hinf, pcii->pszSectionName,
                        hkey, pcii->fPreviouslyInstalled);
            }
        }
    }

    // On failures of first time installs, remove the component.
    //
    if (FAILED(hr) && !pcii->fPreviouslyInstalled)
    {
        TraceTag (ttidClassInst, "Install canceled. Removing...");
        (VOID) HrCiRemoveNonEnumeratedComponent (hinf, hkey, pcii->Class,
                pcii->InstanceGuid, NULL);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiInstallNonEnumeratedComponent");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallComponentInternal
//
//  Purpose: Installs a component
//
//  Arguments:
//      pcii [in, out] Will be filled with information about the
//                     component.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   15 Nov 1996
//
//  Notes:
//
HRESULT
HrCiInstallComponentInternal (
    IN OUT COMPONENT_INSTALL_INFO* pcii)
{
    HRESULT hr = S_OK;
    HINF hinfInstallFile = NULL;
    HKEY hkeyInstance = NULL;

    TraceTag (ttidClassInst, "Installing %S from %S",
              pcii->pszInfId, pcii->pszInfFile);

    // Open the component's inf file.
    hr = HrSetupOpenInfFile (pcii->pszInfFile, NULL, INF_STYLE_WIN4,
            NULL, &hinfInstallFile);

    // Continue only if we have opened the file.
    if (S_OK == hr)
    {
        // The section we have currently might need to be decorated
        // with OS and Platform specific suffixes.  The next call
        // will return the actual decorated section name or our
        // current section name if the decorated one does not exist.
        //

        // Store the original section name pointer so we can restore
        // it after we have finished.
        PCWSTR pszOriginalSectionName = pcii->pszSectionName;

        // Now we get the actual section name.
        //
        WCHAR szActualSection[_MAX_PATH];
        hr = HrSetupDiGetActualSectionToInstallWithBuffer (hinfInstallFile,
                pcii->pszSectionName, szActualSection, _MAX_PATH, NULL,
                NULL);

        if (S_OK == hr)
        {
            pcii->pszSectionName = szActualSection;
            hr = HrCiCreateInstanceKeyAndProcessMainInfSection (
                hinfInstallFile, pcii, &hkeyInstance);

            if (S_OK == hr)
            {
                // Set up the registry with the component info.
                hr = HrCiRegSetComponentInformation (hkeyInstance, pcii);

                if (S_OK == hr)
                {
                    // We do different things during install based
                    // on whether PnP knows about the component
                    // (i.e. enumerated) or not.

                    if (FIsEnumerated (pcii->Class))
                    {
                        hr = HrCiInstallEnumeratedComponent (
                                hinfInstallFile, hkeyInstance, *pcii);
                    }
                    else
                    {
                        hr = HrCiInstallNonEnumeratedComponent (
                               hinfInstallFile, hkeyInstance, pcii);
                    }
                }
                RegSafeCloseKey(hkeyInstance);
            }
            // set the section name back
            pcii->pszSectionName = pszOriginalSectionName;
        }
        SetupCloseInfFile(hinfInstallFile);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiInstallComponentInternal");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiCallClassInstallerToInstallComponent
//
//  Purpose:    This function invokes the class installer to install an
//              enumerated component.
//
//  Arguments:
//      hdi   [in] See Device Installer docs for more info.
//      pdeid [in]
//
//  Returns:    HRESULT. S_OK if successful, or error code otherwise
//
//  Author:     billbe   28 Apr 1997
//
//  Notes:  This should only be called while the INetCfg lock is held.
//
HRESULT
HrCiCallClassInstallerToInstallComponent(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    HRESULT hr;

    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // We need to register the device before we do any work on it.
    hr = HrSetupDiCallClassInstaller (DIF_REGISTERDEVICE, hdi, pdeid);

    if (S_OK == hr)
    {
        // Check if we can install of this component. i.e. is the inf
        // a valid Windows 2000 inf.
        hr = HrSetupDiCallClassInstaller (DIF_ALLOW_INSTALL, hdi, pdeid);

        if (S_OK == hr)
        {
            BOOL fFileCopy = TRUE;
            SP_DEVINSTALL_PARAMS deip;

            // Fu fu fu: SetupApi is ignoring DI_NOFILECOPY so we'll overcome
            // their shortcomings and do it ourselves.
            //
            hr = HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);
            if (S_OK == hr)
            {
                if (deip.Flags & DI_NOFILECOPY)
                {
                    fFileCopy = FALSE;
                }
            }

            if (fFileCopy)
            {
                // Install needed files.
                hr = HrSetupDiCallClassInstaller (DIF_INSTALLDEVICEFILES, hdi,
                        pdeid);
            }

            if (S_OK == hr)
            {
                // Now that all files have been copied, we need to set the
                // no file copy flag.  Otherwise, setupapi will try to copy
                // files at each dif code.  This results in multiple (1 per
                // dif code) unsigned driver popups if the driver was
                // unsigned.
                // We'll only do this if the no copy file flag wasn't already
                // set. i.e. if fFileCopy is TRUE.
                //
                if (fFileCopy)
                {
                    // An error here isn't bad enough to stop installation.
                    //
                    HRESULT hrTemp;
                    hrTemp = HrSetupDiSetDeipFlags (hdi, pdeid, DI_NOFILECOPY,
                            SDDFT_FLAGS, SDFBO_OR);

                    TraceHr (ttidError, FAL, hrTemp, FALSE,
                            "HrCiCallClassInstallerToInstallComponent: "
                             "HrSetupDiSetDeipFlags");
                }

                // Device co-installers need to be registered at this point
                // so they can do work.
                hr = HrSetupDiCallClassInstaller (DIF_REGISTER_COINSTALLERS,
                        hdi, pdeid);

                if (S_OK == hr)
                {
                    hr = HrSetupDiCallClassInstaller (DIF_INSTALLINTERFACES,
                            hdi, pdeid);

                    if (S_OK == hr)
                    {
                        hr = HrSetupDiCallClassInstaller (DIF_INSTALLDEVICE,
                                hdi, pdeid);
                    }
                }
            }
        }

        // If we failed for any reason, we need to clean up since
        // we initiated this install.
        if (FAILED(hr))
        {
            ADAPTER_REMOVE_PARAMS arp;
            arp.fBadDevInst = TRUE;
            arp.fNotifyINetCfg = FALSE;

            CiSetReservedField (hdi, pdeid, &arp);
            HrSetupDiCallClassInstaller (DIF_REMOVE, hdi, pdeid);
            CiClearReservedField (hdi, pdeid);

        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrCiCallClassInstallerToInstallComponent");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallComponent
//
//  Purpose:    This function takes a Network Component's Id and its class
//              guid and gathers the information needed by
//              HrCiInstallComponent. Since it is called from INetCfg, we
//              have the write lock
//
//  Arguments:
//      Params [in] Component install params. See install.h
//      ppComponent [out] A created CComponent representing the installed
//                        component.
//      pdwNewCharacter [out] Optional pointer to a DWORD to receive the
//                            characteristics of the component.
//
//  Returns:    HRESULT. S_OK is successful, NETCFG_S_REBOOT if a reboot is
//                      needed to start the device, or an error code
//
//  Author:     billbe   16 Mar 1997
//
//  Notes:
//
HRESULT
HrCiInstallComponent (
    IN const COMPONENT_INSTALL_PARAMS& Params,
    OUT CComponent** ppComponent,
    OUT DWORD* pdwNewCharacter)
{
    Assert (FIsValidNetClass (Params.Class));
    Assert (Params.pszInfId && *Params.pszInfId);
    Assert (!Params.pComponent);

    HRESULT hr = S_OK;
    HDEVINFO hdi = NULL;
    SP_DEVINFO_DATA deid;
    const GUID* pguidClass = MAP_NETCLASS_TO_GUID[Params.Class];

    if (ppComponent)
    {
        *ppComponent = NULL;
    }
    if (pdwNewCharacter)
    {
        *pdwNewCharacter = 0;
    }

    // If we're about to install the component, it better not be in
    // lockdown.
    //
    Assert (!FIsComponentLockedDown (Params.pszInfId));

    // First create a device info set
    hr = HrSetupDiCreateDeviceInfoList (pguidClass, NULL, &hdi);

    if (S_OK == hr)
    {
        // This will create an node in the enum tree for this component.
        // If it is enumerated, we will register it which will make
        // it persist.  If non-enumerated, we will not register it and
        // the node will be deleted in the call to SetDiDestroyDeviceInfoList.
        //
        hr = HrCiGetDriverInfo (hdi, &deid, *pguidClass,
                Params.pszInfId, Params.pszInfFile);

        // Get the driver info for the component
        if (S_OK == hr)
        {
            BASIC_COMPONENT_DATA Data = {0};
            Data.Class = Params.Class;
            Data.pszInfId = Params.pszInfId;

            if (FIsEnumerated (Params.Class))
            {
                // If the component is enumerated, we will need a place to
                // store its pnp id.
                WCHAR szPnpId[MAX_DEVICE_ID_LEN];
                ADAPTER_OUT_PARAMS AdapterOutParams;

                ZeroMemory (&AdapterOutParams, sizeof(AdapterOutParams));

                // Net class components have to go through the device
                // installer hook (aka NetClassInstaller)
                //

                if (FInSystemSetup())
                {
                    // if we are in GUI mode we need to make the
                    // device install quiet and always copy from
                    // the source location even if the files are
                    // already present. We also need to set
                    // the in system setup flag.  This is what
                    // syssetup would do if it initiated the install
                    // so INetCfg initiated installs must do the same.
                    //
                    // We should also set the parent hwnd.
                    //

                    SP_DEVINSTALL_PARAMS deip;
                    HRESULT hrTemp = HrSetupDiGetDeviceInstallParams (
                            hdi, &deid, &deip);

                    if (S_OK == hr)
                    {
                        deip.hwndParent = Params.hwndParent;
                        deip.Flags |= DI_QUIETINSTALL | DI_FORCECOPY;
                        deip.FlagsEx |= DI_FLAGSEX_IN_SYSTEM_SETUP;

                        hrTemp = HrSetupDiSetDeviceInstallParams (
                                hdi, &deid, &deip);
                    }

                    TraceHr (ttidError, FAL, hrTemp, FALSE, "Error "
                            "getting and setting device params.");
                }

                CiSetReservedField (hdi, &deid, &AdapterOutParams);

                // Officially call the class installer to install
                // this device
                //
                hr = HrCiCallClassInstallerToInstallComponent (hdi, &deid);

                CiClearReservedField (hdi, &deid);

                Data.dwCharacter = AdapterOutParams.dwCharacter;
                Data.InstanceGuid = AdapterOutParams.InstanceGuid;

                if (S_OK == hr)
                {
                    hr = HrSetupDiGetDeviceInstanceId (hdi, &deid, szPnpId,
                            MAX_DEVICE_ID_LEN, NULL);

                    if (S_OK == hr)
                    {
                        Data.pszPnpId = szPnpId;
                    }
                }
            }
            else // Non-net class components
            {
                COMPONENT_INSTALL_INFO cii;
                PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
                SP_DRVINFO_DATA drid;

                // Now get the driver's detailed information
                hr = HrCiGetDriverDetail (hdi, &deid, &drid, &pdridd);

                if (S_OK == hr)
                {
                    ZeroMemory (&cii, sizeof(cii));
                    cii.Class = Params.Class;
                    cii.pszInfId = Params.pszInfId;
                    cii.pszInfFile = pdridd->InfFileName;
                    cii.hwndParent = Params.hwndParent;
                    cii.pszDescription = drid.Description;
                    cii.pszSectionName = pdridd->SectionName;

                    HINF hinf;
                    hr = HrSetupOpenInfFile (pdridd->InfFileName, NULL,
                            INF_STYLE_WIN4, NULL, &hinf);

                    if (S_OK == hr)
                    {
                        // Make sure this is an NT5 inf network inf
                        //
                        hr = HrSetupIsValidNt5Inf (hinf);
                        SetupCloseInfFile (hinf);
                    }

                    if (S_OK == hr)
                    {
                        hr = HrCiInstallComponentInternal (&cii);
                        if (S_OK == hr)
                        {
                            Data.InstanceGuid = cii.InstanceGuid;
                            Data.dwCharacter = cii.dwCharacter;
                        }
                    }
                    MemFree (pdridd);
                }
            }

            if ((S_OK == hr) && ppComponent) // !previously installed
            {
                CComponent* pComponent;

                hr = CComponent::HrCreateInstance (
                        &Data,
                        CCI_ENSURE_EXTERNAL_DATA_LOADED,
                        Params.pOboToken,
                        &pComponent);

                if (S_OK == hr)
                {
                    *ppComponent = pComponent;
                }
            }

            if ((S_OK == hr) && pdwNewCharacter)
            {
                *pdwNewCharacter = Data.dwCharacter;
            }
        }

        SetupDiDestroyDeviceInfoList(hdi);
    }


#ifdef ENABLETRACE
    if (S_OK == hr)
    {
        TraceTag(ttidClassInst, "Component now installed!");
    }
#endif //ENABLETRACE

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrCiInstallComponent (%S)", Params.pszInfId);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetBadDriverFlagIfNeededInList
//
//  Purpose: Enumerates a driver list setting the DNF_BAD_DRIVER flag
//           in every node that has a DNF_EXCLUDEFROMLIST flag.
//
//  Arguments:
//      hdi      [in] See Device Installer Api documentaion for details
//
//  Returns:    HRESULT. S_OK
//
//  Author:     billbe   24 Nov 1998
//
//  Notes: SetupDi forces us to use the DNF_BAD_DRIVER flag for non-netdevice
//         classes if we want to exclude them from the select device dialog.
//         This means to non-netclass components that
//         DNF_BAD_DRIVER = DNF_EXCLUDEFROMLIST.
//
VOID
SetBadDriverFlagIfNeededInList(HDEVINFO hdi)
{
    Assert(IsValidHandle(hdi));

    HRESULT                 hr = S_OK;
    SP_DRVINSTALL_PARAMS    drip;
    SP_DRVINFO_DATA         drid;
    DWORD                   dwIndex = 0;

    // Enumerate each driver in hdi
    while (S_OK == (hr = HrSetupDiEnumDriverInfo(hdi, NULL,
            SPDIT_CLASSDRIVER, dwIndex++, &drid)))
    {
        hr = HrSetupDiGetDriverInstallParams(hdi, NULL, &drid, &drip);

        if (S_OK == hr)
        {
            // If the driver already has the bad driver flag set,
            // go on to the next one.
            if (drip.Flags & DNF_BAD_DRIVER)
            {
                continue;
            }

            // If the driver has the exclude flag set, then set the
            // bad driver flag.
            if (drip.Flags & DNF_EXCLUDEFROMLIST)
            {
                drip.Flags |= DNF_BAD_DRIVER;
                (VOID) HrSetupDiSetDriverInstallParams(hdi, NULL, &drid,
                        &drip);
            }
        }
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "SetBadDriverFlagIfNeededInList");
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiExcludeNonNetClassDriverFromSelectUsingInfId
//
//  Purpose: Locates a driver in a driver list and sets its exclude from
//              select flag.
//
//  Arguments:
//      hdi      [in] See Device Installer Api documentaion for details
//      pszInfId [in] The INF id of the component to exclude
//
//  Returns:    HRESULT. S_OK
//
//  Author:     billbe   29 Oct 1998
//
//  Notes:
//
HRESULT
HrCiExcludeNonNetClassDriverFromSelectUsingInfId(
    IN HDEVINFO hdi,
    IN PCWSTR pszInfId)
{
    Assert(IsValidHandle(hdi));
    Assert(pszInfId);

    HRESULT                 hr = S_OK;
    SP_DRVINSTALL_PARAMS    drip;
    SP_DRVINFO_DATA         drid;
    PSP_DRVINFO_DETAIL_DATA pdridd;
    DWORD                   dwIndex = 0;

    // Enumerate each driver in hdi
    while (S_OK == (hr = HrSetupDiEnumDriverInfo (hdi, NULL,
            SPDIT_CLASSDRIVER, dwIndex++, &drid)))
    {
        (VOID) HrSetupDiGetDriverInstallParams (hdi, NULL, &drid, &drip);

        // If the driver is already excluded for some other reason
        // don't bother trying to determine if it should be excluded.
        // Note that setupdi forces us to use DNF_BAD_DRIVER to exclude
        // non-device drivers rather than using DNF_EXCLUDEFROMLIST.
        if (drip.Flags & DNF_BAD_DRIVER)
        {
            continue;
        }

        // Get driver detail info
        hr = HrSetupDiGetDriverInfoDetail (hdi, NULL, &drid, &pdridd);

        if (S_OK == hr)
        {
            // If the IDs match, exclude it from the dialog
            //
            if (0 == lstrcmpiW (pdridd->HardwareID, pszInfId))
            {
                // Non-device drivers can't use DNF_EXCLUDEFROMLIST
                // and must use DNF_BAD_DRIVER.
                drip.Flags |= DNF_BAD_DRIVER;
                (VOID) HrSetupDiSetDriverInstallParams (hdi, NULL,
                        &drid, &drip);
            }
            MemFree (pdridd);
        }
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrCiExcludeNonNetClassDriverFromSelectUsingInfId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ExcludeLockedDownComponents
//
//  Purpose:    A callback function compatible with EnumLockedDownComponents
//              that is used to exclude locked down components from
//              selection.  Called from HrCiPrepareSelectDeviceDialog.
//              This call back is called for each locked down component.
//
//  Arguments:
//      pszInfId     [in] the INF ID to exclude.
//      pvCallerData [in] the HDEVINFO cast to PVOID
//
//  Returns:    nothing
//
//  Author:     shaunco   24 May 1999
//
//  Notes:      The callback interface was chosen so that the class installer
//              is not burdended with the details of how/where the locked
//              down components are implemented.
//
VOID
CALLBACK
ExcludeLockedDownComponents (
    IN PCWSTR pszInfId,
    IN PVOID pvCallerData)
{
    Assert (pszInfId && *pszInfId);
    Assert (pvCallerData);

    HDEVINFO hdi = (HDEVINFO)pvCallerData;

    HrCiExcludeNonNetClassDriverFromSelectUsingInfId (hdi, pszInfId);
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiBuildExcludedDriverList
//
//  Purpose: Non-Net class components can only be installed once
//              So we need to iterate through the installed
//              components, find their matching driver node in
//              a Device Installer Api built driver list for the class,
//              and set their exclude from select flag.  This list
//              will then be given to SetupDiSelectDevice which
//              will not display the nodes with the exclude flag set.
//
//  Arguments:
//      hdi       [in] See Device Installer Api documentaion for details
//      guidClass [in] The class of components to build a driver list for
//      pNetCfg   [out] The current network configuration (i.e. what is
//                      installed).
//
//  Returns:    HRESULT. S_OK
//
//  Author:     billbe   10 Dec 1996
//
//  Notes:  Device Installer Api builds the driver list by rummaging
//              through the inf directory and finding the components
//              that are in files with the same class guid as the
//              HDEVINFO.  This is the same processing done
//              in SetupDiSelectDevice, but the process is
//              not repeated twice because we will give the
//              list we built here to SetupDiSelectDevice.
//
HRESULT
HrCiBuildExcludedDriverList(
    IN HDEVINFO hdi,
    IN NETCLASS Class,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;

    Assert(IsValidHandle(hdi));
    Assert(pNetConfig);

    // This might take some time.  We are doing the same work as
    // SetupDiSelectDevice would do. When we are done, we will
    // hand the driver list to SetupDiSelectDevice so it won't
    // need to rummage through the inf directory
    //
    CWaitCursor wc;

    // For non-device classes, we need to allow excluded drivers
    // in order to get a list returned.
    hr = HrSetupDiSetDeipFlags(hdi, NULL,
                    DI_FLAGSEX_ALLOWEXCLUDEDDRVS,
                    SDDFT_FLAGSEX, SDFBO_OR);

    if (S_OK == hr)
    {
#ifdef ENABLETRACE
        CBenchmark bmrk;
        bmrk.Start("SetupDiBuildDriverInfoList");
#endif //ENABLETRACE

        hr = HrSetupDiBuildDriverInfoList(hdi, NULL, SPDIT_CLASSDRIVER);

#ifdef ENABLETRACE
        bmrk.Stop();
        TraceTag(ttidBenchmark, "%s : %s seconds",
                bmrk.SznDescription(), bmrk.SznBenchmarkSeconds(2));
#endif //ENABLETRACE
    }

    // Go through the network configuration and hide already installed
    // components.  Note: We only do this the first time.  We show installed
    // components if the user selects Have Disk on the dialog.
    CComponent* pComponent;
    CComponentList::const_iterator iter;

    for (iter  = pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (Class == pComponent->Class())
        {
            // Hide the driver
            hr = HrCiExcludeNonNetClassDriverFromSelectUsingInfId(
                    hdi, pComponent->m_pszInfId);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiBuildExcludedDriverList");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiSelectComponent
//
//  Purpose:    This function displays the Select Device dialog for the
//              class of components specified by guidClass.  Once the
//              component has been selected, it is installed.. Since
//              this fcn is called from INetCfg, we have the write lock.
//
//  Arguments:
//      Class           [in] The class of components to display in the
//                              Select Device dialog
//      hwndParent      [in] The HWND of the parent window, used to display
//                              the UI
//      pcfi            [in] A structure used to determine what
//                              components should be filtered out of
//                              the select dialog (defined in netcfg.h)
//      ppParams        [out] Params used to install the component.
//
//  Returns:    HRESULT. S_OK if successful, S_FALSE if the component
//                        selected is being reinstalled instead of fresh
//                        installed, an error code otherwise
//
//  Author:     billbe   11 Nov 1996
//
//  Notes:  Filtering is only performed when selecting protocols,
//              services, and clients.
//
HRESULT
HrCiSelectComponent(
    IN NETCLASS Class,
    IN HWND hwndParent,
    IN const CI_FILTER_INFO* pcfi,
    OUT COMPONENT_INSTALL_PARAMS** ppParams)
{
    Assert (ppParams);
    Assert (!FIsEnumerated (Class));

    HRESULT hr;
    HDEVINFO hdi;

    // We need to create a DeviceInfoSet item to use the SelectDevice dialog.
    hr = HrSetupDiCreateDeviceInfoList(
            MAP_NETCLASS_TO_GUID[Class], hwndParent, &hdi);

    if (S_OK == hr)
    {
        // call the class installer to bring up the select device dialog
        // for enumerated components.  This will notify any coinstallers
        //

        // This will be a map of component ids to instance guids
        // for all installed components of Class.
        CNetConfig NetConfig;
        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);
        if (S_OK == hr)
        {
            hr = HrCiBuildExcludedDriverList (hdi, Class, &NetConfig);
        }

        if (S_OK == hr)
        {
            // Store the filter info in the hdi
            CiSetReservedField(hdi, NULL, pcfi);

            // We want the Have disk button, but if the call fails we can
            // still continue
            (VOID) HrSetupDiSetDeipFlags(hdi, NULL, DI_SHOWOEM,
                                         SDDFT_FLAGS, SDFBO_OR);

            // Bring up the dialog
            hr = HrSetupDiCallClassInstaller(DIF_SELECTDEVICE, hdi, NULL);

            if (S_OK == hr)
            {
                SP_DRVINFO_DATA drid;
                PSP_DRVINFO_DETAIL_DATA pdridd;

                // Now get the driver's detailed information
                hr = HrCiGetDriverDetail (hdi, NULL, &drid, &pdridd);

                if (S_OK == hr)
                {
                    DWORD cbInfId = CbOfSzAndTerm(pdridd->HardwareID);
                    DWORD cbInfFile = CbOfSzAndTerm(pdridd->InfFileName);

                    // Create a component install params structure so we
                    // can install the component.
                    hr = E_OUTOFMEMORY;
                    *ppParams = new (extrabytes, cbInfId + cbInfFile)
                            COMPONENT_INSTALL_PARAMS;

                    if (*ppParams)
                    {
                        ZeroMemory (*ppParams,
                                sizeof (COMPONENT_INSTALL_PARAMS));

                        (*ppParams)->Class = Class;
                        (*ppParams)->hwndParent = hwndParent;
                        (*ppParams)->pszInfId = (PCWSTR)(*ppParams + 1);
                        wcscpy ((PWSTR)(*ppParams)->pszInfId,
                                pdridd->HardwareID);

                        (*ppParams)->pszInfFile =
                                (PCWSTR)((BYTE*)(*ppParams)->pszInfId +
                                         cbInfId);

                        wcscpy ((PWSTR)(*ppParams)->pszInfFile,
                                pdridd->InfFileName);

                        hr = S_OK;
                    }
                    MemFree (pdridd);
                }
            }

            // Clear the field so we don't try to destroy it later
            // via DIF_DESTROYPRIVATEDATA
            CiClearReservedField(hdi, NULL);
        }
        SetupDiDestroyDeviceInfoList(hdi);
    }

    TraceHr (ttidError, FAL, hr, HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr,
            "HrCiSelectComponent");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiHideIrrelevantRasProtocols
//
//  Purpose:    Hides protocols from the SelectDevice dialog that RAS does
//                  not interact with.
//
//  Arguments:
//      hdi        [in] Contains a list of available drivers.
//                          See Device Installer Api documentation for
//                          more info
//      eFilter    [in] Either FC_RASSRV or FC_RASCLI.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   18 May 1998
//
//  Notes:
//
HRESULT
HrCiHideIrrelevantRasProtocols (
    IN HDEVINFO hdi,
    IN CI_FILTER_COMPONENT eFilter)
{
    DWORD                   dwIndex = 0;
    SP_DRVINFO_DATA         drid;
    SP_DRVINSTALL_PARAMS    drip;
    PSP_DRVINFO_DETAIL_DATA pdridd;
    HRESULT                 hr;

    extern const WCHAR c_szInfId_MS_AppleTalk[];
    extern const WCHAR c_szInfId_MS_NetMon[];
    extern const WCHAR c_szInfId_MS_NWIPX[];
    extern const WCHAR c_szInfId_MS_TCPIP[];

    static const WCHAR* const c_aszServerProtocols[] = {
        c_szInfId_MS_AppleTalk,
        c_szInfId_MS_NetMon,
        c_szInfId_MS_NWIPX,
        c_szInfId_MS_TCPIP
    };

    static const WCHAR* const c_aszClientProtocols[] = {
        c_szInfId_MS_NetMon,
        c_szInfId_MS_NWIPX,
        c_szInfId_MS_TCPIP
    };

    Assert ((FC_RASSRV == eFilter) || (FC_RASCLI == eFilter));

    const WCHAR* const* aszProtocols;
    DWORD cProtocols;

    // What we show as available protocols to install differs between
    // ras server and ras client (aka Incoming connectoid and Dial-up).
    //
    if (FC_RASSRV == eFilter)
    {
        aszProtocols = c_aszServerProtocols;
        cProtocols = celems(c_aszServerProtocols);

    }
    else
    {
        aszProtocols = c_aszClientProtocols;
        cProtocols = celems(c_aszClientProtocols);
    }

    // Enumerate each driver in hdi
    while (S_OK == (hr = HrSetupDiEnumDriverInfo(hdi, NULL,
            SPDIT_CLASSDRIVER, dwIndex++, &drid)))
    {
        (VOID) HrSetupDiGetDriverInstallParams(hdi, NULL, &drid, &drip);

        // If the driver is already excluded for some other reason
        // don't bother trying to determine if it should be excluded
        // Note that setupdi forces us to use DNF_BAD_DRIVER to exclude
        // non-device drivers rather than using DNF_EXCLUDEFROMLIST.
        if (drip.Flags & DNF_BAD_DRIVER)
        {
            continue;
        }

        // Get driver detail info
        hr = HrSetupDiGetDriverInfoDetail(hdi, NULL, &drid, &pdridd);

        if (S_OK == hr)
        {
            // go through the list of relevant protocols to find which
            // ones can be shown
            //

            // Assume we are going to hide this protocol
            BOOL fHideProtocol = TRUE;
            for (DWORD i = 0; i < cProtocols; i++)
            {
                // If the protocol is on the guest list, we won't boot
                // it out
                //
                if (0 == _wcsicmp(aszProtocols[i], pdridd->HardwareID))
                {
                    fHideProtocol = FALSE;
                }
            }

            if (fHideProtocol)
            {
                // exclude from select
                // Note that setupdi forces us to use DNF_BAD_DRIVER to
                // exclude non-device drivers rather than using
                // DNF_EXCLUDEFROMLIST.
                drip.Flags |= DNF_BAD_DRIVER;
                (VOID) HrSetupDiSetDriverInstallParams(hdi, NULL,
                        &drid, &drip);
            }
            MemFree (pdridd);
        }
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiHideIrrelevantRasProtocols");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiHideIrrelevantDrivers
//
//  Purpose:    Enumerates a driver list, opening each driver file and
//                  processing its registry entries into a temporary key.
//                  The lower range of each driver is then examined for
//                  a match with pszUpperRange.  If no match is
//                  found, the driver's DNF_BAD_DRIVER flag is set
//                  which will prevent it from being shown in the
//                  Select Device Dialog
//
//  Arguments:
//      hdi           [in] Contains a list of available drivers.
//                          See Device Installer Api documentation for
//                          more info
//      pszUpperRange [in] The upper range will be used to hide irrelevant
//                         drivers.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   7 May 1998
//
//  Notes:
//
HRESULT
HrCiHideIrrelevantDrivers(
    IN HDEVINFO hdi,
    IN PCWSTR pszUpperRange)
{
    Assert(IsValidHandle(hdi));
    Assert(pszUpperRange);

    static const WCHAR c_szRegKeyTemp[] =
            L"System\\CurrentControlSet\\Control\\Network\\FTempKey";

    // Create a temporary key so we can process each protocol's
    // registry entries in an effort to get its supported
    // lower range of interfaces
    HKEY hkeyTemp;
    HRESULT hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyTemp,
            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkeyTemp, NULL);

    if (S_OK == hr)
    {
        DWORD                   dwIndex = 0;
        SP_DRVINFO_DATA         drid;
        SP_DRVINSTALL_PARAMS    drip;
        HKEY                    hkeyInterfaces;

        // Enumerate each driver in hdi
        while (S_OK == (hr = HrSetupDiEnumDriverInfo(hdi, NULL,
                SPDIT_CLASSDRIVER, dwIndex++, &drid)))
        {
            (VOID) HrSetupDiGetDriverInstallParams(hdi, NULL, &drid, &drip);

            // If the driver is already excluded for some other reason
            // don't bother trying to determine if it should be exluded.
            // Note that setupdi forces us to use DNF_BAD_DRIVER to exclude
            // non-device drivers rather than using DNF_EXCLUDEFROMLIST.
            if (drip.Flags & DNF_BAD_DRIVER)
            {
                continue;
            }

            // Get driver detail info
            PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
            hr = HrSetupDiGetDriverInfoDetail(hdi, NULL, &drid, &pdridd);

            if (S_OK == hr)
            {
                HINF hinf = NULL;
                // Open the driver inf
                hr = HrSetupOpenInfFile(pdridd->InfFileName,
                        NULL, INF_STYLE_WIN4, NULL, &hinf);

                WCHAR szActual[_MAX_PATH];
                if (S_OK == hr)
                {
                    // Get the actual install section name (i.e. with
                    // os/platform extension if it exists)
                    hr = HrSetupDiGetActualSectionToInstallWithBuffer (hinf,
                            pdridd->SectionName, szActual, _MAX_PATH, NULL,
                            NULL);

                    if (S_OK == hr)
                    {
                        // Run the registry sections into the temporary key
                        hr = HrCiInstallFromInfSection(hinf, szActual,
                                hkeyTemp, NULL, SPINST_REGISTRY);
                    }
                }

                if (S_OK == hr)
                {
                    // Open the interfaces key of the driver
                    hr = HrRegOpenKeyEx(hkeyTemp, L"Ndi\\Interfaces",
                            KEY_ALL_ACCESS, &hkeyInterfaces);

                    if (S_OK == hr)
                    {
                        PWSTR pszLowerRange = NULL;

                        // Read the lower interfaces value.
                        //
                        hr = HrRegQuerySzWithAlloc (hkeyInterfaces,
                                L"LowerRange", &pszLowerRange);

                        // If we succeeded in reading the list and
                        // there is no match with one of the upper
                        // interfaces...
                        if ((S_OK == hr) &&
                                !FSubstringMatch (pszUpperRange,
                                        pszLowerRange, NULL, NULL))
                        {
                            // exclude from select
                            drip.Flags |= DNF_BAD_DRIVER;
                            (VOID) HrSetupDiSetDriverInstallParams(hdi,
                                    NULL, &drid, &drip);
                        }

                        // Clear lower interface list for next component
                        MemFree(pszLowerRange);

                        RegDeleteValue (hkeyInterfaces, L"LowerRange");
                        RegCloseKey(hkeyInterfaces);
                    }
                }
                SetupCloseInfFileSafe(hinf);
                MemFree (pdridd);
            }
        }

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkeyTemp);
        HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_szRegKeyTemp);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiHideIrrelevantDrivers");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiSetSelectDeviceDialogStrings
//
//  Purpose:    This function sets the strings displayed in the Select Device
//                  dialog based on the class of devices being selected.
//
//  Arguments:
//      hdi         [in] See Device Installer Api
//      pdeid       [in]
//      guidClass   [in] The class of device being selected
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise
//
//  Author:     billbe   11 Nov 1996
//
//  Notes:
//
HRESULT
HrCiSetSelectDeviceDialogStrings(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN const GUID& guidClass)
{
    Assert(IsValidHandle(hdi));

    SP_SELECTDEVICE_PARAMS  sdep;

    // The strings used in the dialog are specified through the
    // SP_SELECTDEVICE_PARAMS structure
    //
    HRESULT hr = HrSetupDiGetFixedSizeClassInstallParams(hdi, pdeid,
           (PSP_CLASSINSTALL_HEADER)&sdep, sizeof(sdep));

    if (FAILED(hr))
    {
        // If the error is ERROR_NO_CLASSINSTALL_PARAMS then this function
        // didn't really fail since it is possible
        if (SPAPI_E_NO_CLASSINSTALL_PARAMS == hr)
        {
            hr = S_OK;
        }
    }
    else if (DIF_SELECTDEVICE != sdep.ClassInstallHeader.InstallFunction)
    {
        TraceTag(ttidClassInst, "Incorrect function in Class Install Header "
                 "Expected DIF_SELECTDEVICE, got %lX",
                 sdep.ClassInstallHeader.InstallFunction);
    }


    BOOL fHaveDiskShown = FALSE;
    if (S_OK == hr)
    {
        // Get the install params and check if the DI_SHOWOEM flag is set
        // if so, the Have Disk button will be shown
        //
        SP_DEVINSTALL_PARAMS deip;
        // If the call fails we can still go on unfazed.
        (VOID) HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
        if (deip.Flags & DI_SHOWOEM)
        {
            fHaveDiskShown = TRUE;
        }

        // Now we set the strings based on the type of component we are
        // selecting
        if (GUID_DEVCLASS_NETCLIENT == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICECLIENTTITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICECLIENTLISTLABEL));

            wcscpy (sdep.Instructions,
                    SzLoadIds (IDS_SELECTDEVICECLIENTINSTRUCTIONS));

        }
        else if (GUID_DEVCLASS_NETSERVICE == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICESERVICETITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICESERVICELISTLABEL));

            wcscpy (sdep.Instructions,
                    SzLoadIds (IDS_SELECTDEVICESERVICEINSTRUCTIONS));

        }
        else if (GUID_DEVCLASS_NETTRANS == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICEPROTOCOLTITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICEPROTOCOLLISTLABEL));

            wcscpy (sdep.Instructions,
                SzLoadIds (IDS_SELECTDEVICEPROTOCOLINSTRUCTIONS));
        }
        else if (GUID_DEVCLASS_NET == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICEADAPTERTITLE));

            wcscpy (sdep.SubTitle,
                    SzLoadIds (IDS_SELECTDEVICEADAPTERSUBTITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICEADAPTERLISTLABEL));

            wcscpy (sdep.Instructions,
                    SzLoadIds (IDS_SELECTDEVICEADAPTERINSTRUCTIONS));
        }
        else if (GUID_DEVCLASS_INFRARED == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICEINFRAREDTITLE));

            wcscpy (sdep.SubTitle,
                    SzLoadIds (IDS_SELECTDEVICEINFRAREDSUBTITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICEINFRAREDLISTLABEL));

            wcscpy (sdep.Instructions,
                    SzLoadIds (IDS_SELECTDEVICEINFRAREDINSTRUCTIONS));
        }
        else
        {
            // We should never get here
            AssertSz(FALSE, "Invalid Class");
        }

        // If the Have Disk button is shown, we need to add instructions for
        // it
        if (fHaveDiskShown)
        {
            wcscat (sdep.Instructions, SzLoadIds (IDS_HAVEDISK_INSTRUCTIONS));
        }

        sdep.ClassInstallHeader.InstallFunction = DIF_SELECTDEVICE;

        // Now we update the parameters.
        hr = HrSetupDiSetClassInstallParams (hdi, pdeid,
                (PSP_CLASSINSTALL_HEADER)&sdep,
                sizeof(SP_SELECTDEVICE_PARAMS));
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiSetSelectDeviceDialogStrings");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiPrepareSelectDeviceDialog
//
//  Purpose:    Sets the strings that will appear in the Select Device
//                  dialog based on class type.  Also, filters out components
//                  based on filtering criteria (note: only for non-net
//                  class components
//
//  Arguments:
//      hdi    [in] See Device Installer Api documentation for more info
//      pdeid  [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 Jun 1997
//
//  Notes:
//
HRESULT
HrCiPrepareSelectDeviceDialog(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));

    GUID                guidClass;
    CI_FILTER_INFO*     pcfi;
    HRESULT             hr = S_OK;
    static const WCHAR  c_szNetwareInfId[] = L"MS_NwClient";
    static const WCHAR  c_szQosInfId[] = L"MS_PSched";

    if (pdeid)
    {
        // Get the class guid from the specified device element
        guidClass = pdeid->ClassGuid;
    }
    else
    {
        // otherwise, get it from the hdi
        hr = HrSetupDiGetDeviceInfoListClass (hdi, &guidClass);
    }

    if ((S_OK == hr) && !FIsEnumerated (guidClass))
    {
        // This might take some time.  We are doing the same work as
        // SetupDiSelectDevice would do. When we are done, we will
        // hand the driver list to SetupDiSelectDevice so it won't
        // need to rummage through the inf directory
        //
        CWaitCursor wc;

        // For non-device classes, we need to allow excluded drivers
        // in order to get a list returned.
        hr = HrSetupDiSetDeipFlags(hdi, NULL,
                        DI_FLAGSEX_ALLOWEXCLUDEDDRVS,
                        SDDFT_FLAGSEX, SDFBO_OR);

        if (S_OK == hr)
        {
    #ifdef ENABLETRACE
            CBenchmark bmrk;
            bmrk.Start("SetupDiBuildDriverInfoList");
    #endif //ENABLETRACE

            // If we have already built a driver list, this will return
            // immediately.
            //
            hr = HrSetupDiBuildDriverInfoList(hdi, NULL, SPDIT_CLASSDRIVER);

    #ifdef ENABLETRACE
            bmrk.Stop();
            TraceTag(ttidBenchmark, "%s : %s seconds",
                    bmrk.SznDescription(), bmrk.SznBenchmarkSeconds(2));
    #endif //ENABLETRACE
        }

        if (S_OK == hr)
        {
            // Go through every driver node and set DNF_BAD_DRIVER
            // if DNF_EXCLUDEFROMLIST is set. Note: SetupDi forces us
            // to do this for non netclass driver lists.
            SetBadDriverFlagIfNeededInList(hdi);

            // Exclude components that are in lockdown.
            //
            EnumLockedDownComponents (ExcludeLockedDownComponents, hdi);

            SP_DEVINSTALL_PARAMS deip;
            hr = HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);

            if (S_OK == hr)
            {
                pcfi = (CI_FILTER_INFO*)deip.ClassInstallReserved;

                // if filter info was present and we are selecting protocols...
                if (pcfi)
                {
                    if (GUID_DEVCLASS_NETTRANS == guidClass)
                    {
                        // If the filter is for lan or atm and pvReserved is
                        // not null...
                        if (((FC_LAN == pcfi->eFilter) ||
                                (FC_ATM == pcfi->eFilter))
                             && pcfi->pvReserved)
                        {
                            // Hide any drivers that can't bind to pvReserved
                            hr = HrCiHideIrrelevantDrivers(hdi,
                                    (PCWSTR)pcfi->pvReserved);

                        }
                        else if ((FC_RASSRV == pcfi->eFilter) ||
                                (FC_RASCLI == pcfi->eFilter))
                        {
                            // Hide from the select dialog any protocols RAS does
                            // not support
                            hr = HrCiHideIrrelevantRasProtocols (hdi,
                                    pcfi->eFilter);
                        }
                    }
                    else if ((GUID_DEVCLASS_NETCLIENT == guidClass) &&
                            (FC_ATM == pcfi->eFilter))
                    {
                        // ATM adapters don't bind to Netware Client so
                        // we need to try to hide it from the dialog
                        (VOID) HrCiExcludeNonNetClassDriverFromSelectUsingInfId(
                                hdi, c_szNetwareInfId);
                    }
                    else if ((GUID_DEVCLASS_NETSERVICE == guidClass) &&
                             (FC_ATM == pcfi->eFilter))
                    {
                        // ATM adapters don't bind to QoS so try to hide it
                        (VOID) HrCiExcludeNonNetClassDriverFromSelectUsingInfId(
                                hdi, c_szQosInfId);
                    }
                }
            }
        }
    }

    if (S_OK == hr)
    {

        // Set the strings for the Select Device dialog.
        // This is done by changing the parameters in the DeviceInfoSet.
        // The next call will create this InfoSet
        // If the call fails, we can still go on, we'll just have
        // slightly odd descriptions in the dialog.  This is done after
        // the section above because strings change based on the existence
        // of the Have Disk button
        (VOID) HrCiSetSelectDeviceDialogStrings(hdi, pdeid, guidClass);

        // Now we need to indicate that we created a class install params
        // header in the structures and set the select device dialog strings
        // in it.  If the call fails, we can still proceed though the
        // dialog will appear a bit strange
        (VOID) HrSetupDiSetDeipFlags(hdi, pdeid,
                              DI_USECI_SELECTSTRINGS | DI_CLASSINSTALLPARAMS,
                              SDDFT_FLAGS, SDFBO_OR);
    }


    TraceHr (ttidError, FAL, hr, FALSE, "HrCiPrepareSelectDeviceDialog");
    return hr;
}

HRESULT
HrCiInstallFilterDevice (
    IN HDEVINFO hdi,
    IN PCWSTR pszInfId,
    IN CComponent* pAdapter,
    IN CComponent* pFilter,
    IN CFilterDevice** ppFilterDevice)
{
    HRESULT hr;
    SP_DEVINFO_DATA deid;

    Assert (hdi);
    Assert (pszInfId && *pszInfId);
    Assert (pAdapter);
    Assert (FIsEnumerated(pAdapter->Class()));
    Assert (pFilter);
    Assert (pFilter->FIsFilter());
    Assert (NC_NETSERVICE == pFilter->Class());
    Assert (ppFilterDevice);

    *ppFilterDevice = NULL;

    // Initialize the devinfo data corresponding to the driver the
    // caller wants us to install.
    //
    hr = HrCiGetDriverInfo (hdi, &deid, *MAP_NETCLASS_TO_GUID[NC_NET],
            pszInfId, NULL);

    if (S_OK == hr)
    {
        ADAPTER_OUT_PARAMS AdapterOutParams;

        ZeroMemory (&AdapterOutParams, sizeof(AdapterOutParams));

        CiSetReservedField (hdi, &deid, &AdapterOutParams);

        // Perform the installation.
        //
        hr = HrCiCallClassInstallerToInstallComponent (hdi, &deid);

        CiClearReservedField (hdi, &deid);

        if (S_OK == hr)
        {
            WCHAR szInstanceGuid[c_cchGuidWithTerm];
            INT cch;
            HKEY hkeyInstance;

            // Convert the instance guid to a string.
            //
            cch = StringFromGUID2 (
                    AdapterOutParams.InstanceGuid,
                    szInstanceGuid,
                    c_cchGuidWithTerm);
            Assert (c_cchGuidWithTerm == cch);

            // Open the instance key of the newly installed device
            // so we can write the instance guid and the back pointer
            // to the filter.
            //
            hr = HrSetupDiOpenDevRegKey (hdi, &deid,
                    DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_WRITE,
                    &hkeyInstance);

            if (S_OK == hr)
            {
                // Write the instance guid.
                //
                hr = HrRegSetSz (hkeyInstance, L"NetCfgInstanceId",
                        szInstanceGuid);

                // Write the inf id of the parent filter.
                //
                hr = HrRegSetSz (hkeyInstance, L"FilterInfId",
                        pFilter->m_pszInfId);

                RegCloseKey (hkeyInstance);
            }

            // Set the friendly name to include the adapter being
            // filtered.
            //
            if (S_OK == hr)
            {
                PWSTR pszFilterDesc;

                hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc (
                        hdi, &deid, SPDRP_DEVICEDESC,
                        NULL, (BYTE**)&pszFilterDesc);

                if (S_OK == hr)
                {
                    #define SZ_NAME_SEP L" - "

                    PWSTR pszName;
                    ULONG cb;

                    // sizeof(SZ_NAME_SEP) includes the NULL-terminator
                    // so that will automatically add room for the
                    // NULL-terminator we need to allocate for pszName.
                    //
                    cb = CbOfSzSafe (pAdapter->Ext.PszDescription()) +
                         sizeof(SZ_NAME_SEP) +
                         CbOfSzSafe (pszFilterDesc);

                    pszName = (PWSTR)MemAlloc (cb);
                    if (pszName)
                    {
                        wcscpy (pszName, pAdapter->Ext.PszDescription());
                        wcscat (pszName, SZ_NAME_SEP);
                        wcscat (pszName, pszFilterDesc);

                        Assert (cb == CbOfSzAndTerm(pszName));

                        hr = HrSetupDiSetDeviceRegistryProperty (
                                hdi, &deid,
                                SPDRP_FRIENDLYNAME,
                                (const BYTE*)pszName,
                                cb);

                        MemFree (pszName);
                    }

                    MemFree (pszFilterDesc);
                }

                // If the above fails, its not a big deal.
                //
                hr = S_OK;
            }

            if (S_OK == hr)
            {
                hr = CFilterDevice::HrCreateInstance (
                        pAdapter,
                        pFilter,
                        &deid,
                        szInstanceGuid,
                        ppFilterDevice);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiInstallFilterDevice");
    return hr;
}

HRESULT
HrCiRemoveFilterDevice (
    IN HDEVINFO hdi,
    IN SP_DEVINFO_DATA* pdeid)
{
    HRESULT hr;
    ADAPTER_REMOVE_PARAMS arp = {0};

    Assert (hdi);
    Assert (pdeid);

    CiSetReservedField (hdi, pdeid, &arp);

    hr = HrSetupDiCallClassInstaller (DIF_REMOVE, hdi, pdeid);

    CiClearReservedField (hdi, pdeid);

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRemoveFilterDevice");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\bindings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       B I N D I N G S . H
//
//  Contents:   The basic datatypes for binding objects.  Bindpaths are
//              ordered collections of component pointers.  Bindsets
//              are a collection of bindpaths.  This module declares the
//              objects which represent them.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"

class CComponentList;

// A bindpath is an ordered collection of pointers to components.
// The order in the collection is the order of the components on
// the bindpath from top to bottom.
// e.g.
//   a, b, c, and d represent components.
//   a bindpath of a -> b -> c -> d is represented in this data
//   structure by a vector:
//       vector offset: 0 1 2 3
//       vector data  : a b c d
//   hence, the zeroth element in this data structure is the top-most
//   (first) component in the bindpath.  The last element in this
//   data structure is the bottom-most (last) component.
//
// vector was chosen as the base class because it implements
// contiguous storage with fast inserts at the end.  Since, we only
// build bindpaths by inserting components at the end, it was a
// natural choice.  list uses non-contiguous storage which tends to
// fragment the heap -- especially with lots of small allocations.
// We create many CBindPath instances, and since each node is a pointer,
// using vector over list is much easier on the heap.
//
// For a bindpath to be valid, it must not be empty and it must not
// contain any dupliate component pointers.
//
class CBindPath : public vector<CComponent*>
{
public:
    bool
    operator< (
        const CBindPath& OtherPath) const;

    bool
    operator> (
        const CBindPath& OtherPath) const;

    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    CountComponents () const
    {
        return size();
    }

    BOOL
    FAllComponentsLoadedOkayIfLoadedAtAll () const;

    BOOL
    FContainsComponent (
        IN const CComponent* pComponent) const
    {
        return (find (begin(), end(), pComponent) != end());
    }

    BOOL
    FGetPathToken (
        OUT PWSTR pszToken,
        IN OUT ULONG* pcchToken) const;

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    BOOL
    FIsSameBindPathAs (
        IN const CBindPath* pOtherPath) const;

    BOOL
    FIsSubPathOf (
        IN const CBindPath* pOtherPath) const;

    HRESULT
    HrAppendBindPath (
        IN const CBindPath* pBindPath);

    HRESULT
    HrAppendComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrGetComponentsInBindPath (
        IN OUT CComponentList* pComponents) const;

    HRESULT
    HrInsertComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrReserveRoomForComponents (
        IN UINT cComponents);

    CComponent*
    PGetComponentAtIndex (
        IN UINT unIndex) const
    {
        return (unIndex < size()) ? (*this)[unIndex] : NULL;
    }

    CComponent*
    POwner () const
    {
        AssertH (CountComponents() > 1);
        AssertH (front());
        return front();
    }

    CComponent*
    PLastComponent () const
    {
        AssertH (CountComponents() > 1);
        AssertH (back());
        return back();
    }

    CComponent*
    RemoveFirstComponent ()
    {
        CComponent* pComponent = NULL;
        if (size() > 0)
        {
            pComponent = front();
            AssertH(pComponent);
            erase(begin());
        }
        return pComponent;
    }

    CComponent*
    RemoveLastComponent ()
    {
        CComponent* pComponent = NULL;
        if (size() > 0)
        {
            pComponent = back();
            AssertH(pComponent);
            pop_back();
        }
        return pComponent;
    }

#if DBG
    VOID DbgVerifyBindpath ();
#else
    VOID DbgVerifyBindpath () {}
#endif
};

// A binding set is a set of bindpaths.  Each bindpath in the set
// must be unique and cannot be empty.
//
class CBindingSet : public vector<CBindPath>
{
public:
    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    CountBindPaths () const
    {
        return size();
    }

    VOID
    Printf (
        TRACETAGID ttid,
        PCSTR pszPrefixLine) const;

    BOOL
    FContainsBindPath (
        IN const CBindPath* pBindPath) const;

    BOOL
    FContainsComponent (
        IN const CComponent* pComponent) const;

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    HRESULT
    HrAppendBindingSet (
        IN const CBindingSet* pBindSet);

    HRESULT
    HrAddBindPath (
        IN const CBindPath* pBindPath,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrAddBindPathsInSet1ButNotInSet2 (
        IN const CBindingSet* pSet1,
        IN const CBindingSet* pSet2);

    HRESULT
    HrCopyBindingSet (
        IN const CBindingSet* pSourceSet);

    HRESULT
    HrGetAffectedComponentsInBindingSet (
        IN OUT CComponentList* pComponents) const;

    HRESULT
    HrReserveRoomForBindPaths (
        IN UINT cBindPaths);

    CBindPath*
    PGetBindPathAtIndex (
        IN UINT unIndex)
    {
        return (unIndex < size()) ? (begin() + unIndex) : end();
    }

    VOID
    RemoveBindPath (
        IN const CBindPath* pBindPath);

    VOID
    RemoveBindPathsWithComponent (
        IN const CComponent* pComponent);

    VOID
    RemoveSubpaths ();

    VOID
    SortForPnpBind ();

    VOID
    SortForPnpUnbind ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\comp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P . C P P
//
//  Contents:   The module implements the operations that are valid on
//              network component datatypes.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "comp.h"
#include "icomp.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncstring.h"
#include "util.h"

// NULL entries means we don't use the network subtree for that class.
//
const PCWSTR MAP_NETCLASS_TO_NETWORK_SUBTREE[] =
{
    L"System\\CurrentControlSet\\Control\\Network\\{4d36e972-e325-11ce-bfc1-08002be10318}",
    L"System\\CurrentControlSet\\Control\\Network\\{6BDD1FC5-810F-11D0-BEC7-08002BE2092F}",
    L"System\\CurrentControlSet\\Control\\Network\\{4d36e975-e325-11ce-bfc1-08002be10318}",
    L"System\\CurrentControlSet\\Control\\Network\\{4d36e973-e325-11ce-bfc1-08002be10318}",
    L"System\\CurrentControlSet\\Control\\Network\\{4d36e974-e325-11ce-bfc1-08002be10318}",
    NULL,
    NULL
};

// map of NETCLASS enum to GUIDs for class
//
const GUID* MAP_NETCLASS_TO_GUID[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_INFRARED,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETCLIENT,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_UNKNOWN,
    &GUID_DEVCLASS_UNKNOWN
};

const WCHAR c_szTempNetcfgStorageForUninstalledEnumeratedComponent[] =
    L"System\\CurrentControlSet\\Control\\Network\\Uninstalled\\";

//static
HRESULT
CComponent::HrCreateInstance (
    IN const BASIC_COMPONENT_DATA* pData,
    IN DWORD dwFlags,
    IN const OBO_TOKEN* pOboToken, OPTIONAL
    OUT CComponent** ppComponent)
{
    ULONG cbInfId;
    ULONG cbPnpId;

    Assert (pData);
    Assert (pData->pszInfId && *pData->pszInfId);
    Assert (FIsValidNetClass(pData->Class));
    Assert (FImplies(FIsEnumerated(pData->Class),
                pData->pszPnpId && *pData->pszPnpId));
    Assert (FImplies(pData->pszPnpId, *pData->pszPnpId));
    Assert (FImplies(pData->dwDeipFlags, FIsEnumerated(pData->Class)));
    Assert ((CCI_DEFAULT == dwFlags) ||
            (CCI_ENSURE_EXTERNAL_DATA_LOADED == dwFlags));
    Assert (GUID_NULL != pData->InstanceGuid);

    cbInfId = CbOfSzAndTerm (pData->pszInfId);
    cbPnpId = CbOfSzAndTermSafe (pData->pszPnpId);

    HRESULT hr = E_OUTOFMEMORY;
    CComponent* pComponent = new(extrabytes, cbInfId + cbPnpId) CComponent;
    if (pComponent)
    {
        hr = S_OK;
        ZeroMemory (pComponent, sizeof(CComponent));

        pComponent->m_InstanceGuid  = pData->InstanceGuid;
        pComponent->m_Class         = pData->Class;
        pComponent->m_dwCharacter   = pData->dwCharacter;
        pComponent->m_dwDeipFlags   = pData->dwDeipFlags;

        pComponent->m_pszInfId = (PCWSTR)(pComponent + 1);
        wcscpy ((PWSTR)pComponent->m_pszInfId, pData->pszInfId);
        _wcslwr ((PWSTR)pComponent->m_pszInfId);

        AddOrRemoveDontExposeLowerCharacteristicIfNeeded (pComponent);

        if (cbPnpId)
        {
            pComponent->m_pszPnpId = (PCWSTR)((BYTE*)pComponent->m_pszInfId
                                                + cbInfId);
            wcscpy ((PWSTR)pComponent->m_pszPnpId, pData->pszPnpId);
        }

        if (dwFlags & CCI_ENSURE_EXTERNAL_DATA_LOADED)
        {
            // Let's ensure we can successfully read all of the external
            // data that the component's INF dumped under the instance
            // key.  Failure here means the INF wasn't proper in some
            // way required for us to consider this a valid component.
            //
            hr = pComponent->Ext.HrEnsureExternalDataLoaded ();
        }

        if ((S_OK == hr) && pOboToken)
        {
            // Add a reference by the obo token if we were given one.
            //
            hr = pComponent->Refs.HrAddReferenceByOboToken (pOboToken);
        }

        if (S_OK != hr)
        {
            delete pComponent;
            pComponent = NULL;
        }
    }

    *ppComponent = pComponent;

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrCreateAndInitializeInstance");
    return hr;
}

CComponent::~CComponent()
{
    // If we have a cached INetCfgComponent interface, we need to tell it
    // that we (as the component it represents) no longer exist.  Then we
    // need to release the interface, of course.
    //
    ReleaseINetCfgComponentInterface ();
    if(m_hinf)
    {
        SetupCloseInfFile (m_hinf);
    }
}

VOID
CComponent::ReleaseINetCfgComponentInterface ()
{
    Assert (this);

    if (m_pIComp)
    {
        Assert (this == m_pIComp->m_pComponent);
        m_pIComp->m_pComponent = NULL;
        ReleaseObj (m_pIComp->GetUnknown());
        m_pIComp = NULL;
    }
}

INetCfgComponent*
CComponent::GetINetCfgComponentInterface () const
{
    Assert (this);
    Assert (m_pIComp);
    return m_pIComp;
}

BOOL
CComponent::FCanDirectlyBindTo (
    IN const CComponent* pLower,
    OUT const WCHAR** ppStart,
    OUT ULONG* pcch) const
{
    BOOL fCanBind;

    // If this component is a filter and the lower is an adapter,
    // they can bind (by definition) unless the adapter has an upper range
    // that is excluded by the filter.
    //
    if (FIsFilter() && FIsEnumerated(pLower->Class()))
    {
        fCanBind = TRUE;

        // If the filter has the FilterMediaTypes value specified,
        // then we can bind only if we have a match with the adapters
        // lower range.
        //
        if (Ext.PszFilterMediaTypes())
        {
            fCanBind = FSubstringMatch (Ext.PszFilterMediaTypes(),
                            pLower->Ext.PszLowerRange(), NULL, NULL);
        }

        // If we (the filter) have a list of lower interface to exclude,
        // then we can bind only if we don't have a match.
        //
        if (fCanBind && Ext.PszLowerExclude())
        {
            fCanBind = !FSubstringMatch (Ext.PszLowerExclude(),
                            pLower->Ext.PszUpperRange(), NULL, NULL);
        }

        // If the filter can bind to the adapter, and the caller wants
        // the interface name, it will be the first interface the adapter
        // supports.
        //
        if (fCanBind && ppStart && pcch)
        {
            PCWSTR pStart;
            PCWSTR pEnd;

            pStart = pLower->Ext.PszUpperRange();
            Assert (pStart);

            while (*pStart && (*pStart == L' ' || *pStart == L','))
            {
                pStart++;
            }

            pEnd = pStart;
            while (*pEnd && *pEnd != L' ' && *pEnd != L',')
            {
                pEnd++;
            }

            *ppStart = pStart;
            *pcch = pEnd - pStart;
        }
    }
    else
    {
        fCanBind = FSubstringMatch (
                    Ext.PszLowerRange(),
                    pLower->Ext.PszUpperRange(), ppStart, pcch);
    }

    return fCanBind;
}

BOOL
CComponent::FIsBindable () const
{
    return (0 != _wcsicmp(L"nolower", Ext.PszLowerRange())) ||
           (0 != _wcsicmp(L"noupper", Ext.PszUpperRange()));
}

BOOL
CComponent::FIsWanAdapter () const
{
    Assert (this);

    return (NC_NET == Class()) &&
            FSubstringMatch (Ext.PszLowerRange(), L"wan", NULL, NULL);
}

HRESULT
CComponent::HrGetINetCfgComponentInterface (
    IN CImplINetCfg* pINetCfg,
    OUT INetCfgComponent** ppIComp)
{
    HRESULT hr = S_OK;

    Assert (this);
    Assert (pINetCfg);
    Assert (ppIComp);

    // Caller's are responsible for ensuring that if an interface is about
    // to be handed out, and the external data has been loaded, that the
    // data has been loaded successfully.  If we handed out an interface
    // and the data was NOT loaded successfully, it just means we are doomed
    // to fail later when the client of the interface calls a method that
    // requires that data.
    //
    Assert (Ext.FLoadedOkayIfLoadedAtAll());

    // If we don't yet have the cached INetCfgComponent for ourself,
    // create it and hang onto a reference.
    //
    if (!m_pIComp)
    {
        hr = CImplINetCfgComponent::HrCreateInstance (
                pINetCfg, this, &m_pIComp);
    }

    // AddRef and return a copy for the caller.
    //
    if (S_OK == hr)
    {
        AddRefObj (m_pIComp->GetUnknown());
        *ppIComp = m_pIComp;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrGetINetCfgComponentInterface");
    return hr;
}

HRESULT
CComponent::HrOpenDeviceInfo (
    OUT HDEVINFO* phdiOut,
    OUT SP_DEVINFO_DATA* pdeidOut) const
{
    HRESULT hr;

    Assert (this);
    Assert (phdiOut);
    Assert (pdeidOut);

    hr = ::HrOpenDeviceInfo (
            Class(),
            m_pszPnpId,
            phdiOut,
            pdeidOut);

    TraceHr (ttidError, FAL, hr, SPAPI_E_NO_SUCH_DEVINST == hr,
        "CComponent::HrOpenDeviceInfo (%S)", m_pszPnpId);
    return hr;
}

HRESULT
CComponent::HrOpenInstanceKey (
    IN REGSAM samDesired,
    OUT HKEY* phkey,
    OUT HDEVINFO* phdiOut OPTIONAL,
    OUT SP_DEVINFO_DATA* pdeidOut OPTIONAL) const
{
    HRESULT hr;

    Assert (this);
    Assert (phkey);

    hr = HrOpenComponentInstanceKey (
            Class(),
            m_InstanceGuid,
            m_pszPnpId,
            samDesired,
            phkey,
            phdiOut,
            pdeidOut);

    TraceHr (ttidError, FAL, hr,
        (SPAPI_E_NO_SUCH_DEVINST == hr),
        "CComponent::HrOpenInstanceKey (%S)", PszGetPnpIdOrInfId());
    return hr;
}

HRESULT
CComponent::HrOpenServiceKey (
    IN REGSAM samDesired,
    OUT HKEY* phkey) const
{
    HRESULT hr;
    WCHAR szServiceSubkey [_MAX_PATH];

    Assert (this);
    Assert (phkey);
    Assert (FHasService());

    *phkey = NULL;

    wcscpy (szServiceSubkey, REGSTR_PATH_SERVICES);
    wcscat (szServiceSubkey, L"\\");
    wcscat (szServiceSubkey, Ext.PszService());

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            szServiceSubkey,
            samDesired,
            phkey);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrOpenServiceKey (%S)", Ext.PszService());
    return hr;
}

HRESULT
CComponent::HrStartOrStopEnumeratedComponent (
    IN DWORD dwFlag /* DICS_START or DICS_STOP */) const
{
    HRESULT hr;
    HDEVINFO  hdi;
    SP_DEVINFO_DATA deid;

    Assert (this);
    Assert (FIsEnumerated(Class()));
    Assert ((DICS_START == dwFlag) || (DICS_STOP == dwFlag));

    hr = HrOpenDeviceInfo (&hdi, &deid);
    if (S_OK == hr)
    {
        if (m_dwDeipFlags)
        {
            TraceTag (ttidBeDiag,
                "Using SP_DEVINSTALL_PARAMS.Flags = 0x%08x for %S",
                m_dwDeipFlags,
                m_pszPnpId);

            (VOID) HrSetupDiSetDeipFlags (
                        hdi, &deid,
                        m_dwDeipFlags, SDDFT_FLAGS, SDFBO_OR);
        }

        // $HACK  SetupDi does not honor the DI_DONOTCALLCONFIGMG flag
        // so we can't call it if it is set. If we don't start the device
        // we will return NETCFG_S_REBOOT.
        //
        hr = NETCFG_S_REBOOT;
        if (!(DI_DONOTCALLCONFIGMG & m_dwDeipFlags))
        {
            hr = HrSetupDiSendPropertyChangeNotification (
                    hdi, &deid,
                    dwFlag,
                    DICS_FLAG_CONFIGSPECIFIC,
                    0);
        }

        SetupDiDestroyDeviceInfoList (hdi);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrStartOrStopEnumeratedComponent (%S)", m_pszPnpId);
    return hr;
}

//-----------------------------------------------------------------------
// A convenience method to get the handle to the components inf file.
// If the file has been opened previously, the cached handle is returned.
// Otherwise, the file is opened and the handle is returned.

HRESULT
CComponent::HrOpenInfFile(
    OUT HINF* phinf) const
{
    HRESULT hr = S_OK;
    HKEY  hkeyInstance = NULL;
    WCHAR szInfPath[_MAX_PATH];
    DWORD cbPath = sizeof (szInfPath);

    Assert(phinf);
    *phinf = NULL;

    if (NULL == m_hinf)
    {
        hr = HrOpenInstanceKey (KEY_READ, &hkeyInstance, NULL, NULL);

        if (S_OK == hr)
        {
            hr = HrRegQuerySzBuffer (hkeyInstance, L"InfPath", szInfPath, &cbPath);

            if (S_OK == hr)
            {
                // open the component's inf file
                hr = HrSetupOpenInfFile (szInfPath, NULL, INF_STYLE_WIN4,
                         NULL, &m_hinf);
            }
            RegSafeCloseKey (hkeyInstance);
        }
    }
    *phinf = m_hinf;

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrOpenInfFile (%S)", PszGetPnpIdOrInfId());

    return hr;
}

NETCLASS
NetClassEnumFromGuid (
    const GUID& guidClass)
{
    NETCLASS Class;

    if (GUID_DEVCLASS_NET == guidClass)
    {
        Class = NC_NET;
    }
    else if (GUID_DEVCLASS_INFRARED == guidClass)
    {
        Class = NC_INFRARED;
    }
    else if (GUID_DEVCLASS_NETTRANS == guidClass)
    {
        Class = NC_NETTRANS;
    }
    else if (GUID_DEVCLASS_NETCLIENT == guidClass)
    {
        Class = NC_NETCLIENT;
    }
    else if (GUID_DEVCLASS_NETSERVICE == guidClass)
    {
        Class = NC_NETSERVICE;
    }
    else
    {
        Class = NC_INVALID;
    }

    return Class;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\comp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P . H
//
//  Contents:   The basic datatype for a network component.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "compdefs.h"
#include "comprefs.h"
#include "ecomp.h"
#include "ncstring.h"
#include "netcfgx.h"
#include "notify.h"

// Flags used when creating a CComponent instance.
//
enum CCI_FLAGS
{
    CCI_DEFAULT                     = 0x00000000,
    CCI_ENSURE_EXTERNAL_DATA_LOADED = 0x00000001,
};


class CComponent
{
friend class CExternalComponentData;
friend class CImplINetCfgComponent;

public:
    // The instance guid of the component.  Assigned by the class installer
    // when the component is installed.  The instance guid of a component
    // can NEVER change once it is installed.
    //
    GUID        m_InstanceGuid;

private:
    // The class of the component.  It is private so that folks are forced
    // to use the Class() access method which asserts that the value is
    // in an allowable range.  The class for a component can NEVER change
    // once it is installed.
    //
    NETCLASS    m_Class;

    // Member to store the handle to the inf file of this component.
    // This is used to avoid the expense of opening the inf file more than
    // once over the lifetime of the component.
    //
    mutable HINF m_hinf;

public:
    // The characteristics of the component.  A combination of NCF_
    // flags defined in netcfgx.idl.  The characteristics of a component
    // can NEVER change once it is installed.
    //
    DWORD       m_dwCharacter;

    // The INF ID of the component. e.g. ms_tcpip.  The INF ID of a component
    // can NEVER change once it is installed.
    //
    PCWSTR      m_pszInfId;

    // The PnP Instance ID of the component.  This is only
    // valid for components that are considered of class NET.  It can
    // NEVER change once the component is installed.
    //
    PCWSTR      m_pszPnpId;

    // This is the interface to the component's external data.  External data
    // is under the instance key.
    //
    CExternalComponentData  Ext;

    // This is the interface to the component's optional notify object.
    //
    CNotifyObjectInterface  Notify;

    // This is the interface to the component's references.  i.e. who
    // has installed this component.
    //
    CComponentReferences    Refs;

    // This is a cached copy (addref'd) of this component's
    // INetCfgComponent interface.  It is created via
    // HrGetINetCfgComponentInterface on the first call.
    //
    class CImplINetCfgComponent* m_pIComp;

    // Valid for NCF_FILTER components only.  This is the
    // ordinal position that this filter gets within the range of
    // filter classes.  See filtdevs.h for more info.
    //
    DWORD m_dwFilterClassOrdinal;

    // Valid for enumerated components only.  This is the
    // SP_DEVINSTALL_PARAMS.Flags value the class installer was told to
    // use when installing the device.  We need to honor this when starting
    // it.
    //
    DWORD m_dwDeipFlags;

    // When removing non-enumerated components, this string will hold
    // the name of the remove section valid in this component's INF.
    // We need to process this remove section (for delete files) after
    // we release the notify object so that the component has a chance to
    // properly delete the notify object dll.
    //
    tstring m_strRemoveSection;

private:
    // Declare all constructors private so that no one except
    // HrCreateInstance can create instances of this class.
    //
    CComponent() {}

public:
    ~CComponent();

    NETCLASS
    Class() const
    {
        AssertH (FIsValidNetClass(m_Class));
        return m_Class;
    }

    BOOL
    FCanDirectlyBindTo (
        IN const CComponent* pLower,
        OUT const WCHAR** ppStart,
        OUT ULONG* pcch) const;

    BOOL
    FHasService() const
    {
        return (Ext.PszService()) ? TRUE : FALSE;
    }

    BOOL
    FIsBindable () const;

    BOOL
    FIsFilter () const
    {
        return m_dwCharacter & NCF_FILTER;
    }

    BOOL
    FIsWanAdapter () const;

    HINF
    GetCachedInfFile () const
    {
        return m_hinf;
    }

    HRESULT
    HrOpenInfFile (OUT HINF* phinf) const;

    void
    CloseInfFile () const
    {
        Assert(m_hinf);
        SetupCloseInfFile (m_hinf);
        m_hinf = NULL;
    }

    static
    HRESULT
    HrCreateInstance (
        IN const BASIC_COMPONENT_DATA* pData,
        IN DWORD dwFlags /* CCI_FLAGS */,
        IN const OBO_TOKEN* pOboToken, OPTIONAL
        OUT CComponent** ppComponent);

    HRESULT
    HrGetINetCfgComponentInterface (
        IN class CImplINetCfg* pINetCfg,
        OUT INetCfgComponent** ppIComp);

    INetCfgComponent*
    GetINetCfgComponentInterface () const;

    VOID
    ReleaseINetCfgComponentInterface ();

    HRESULT
    HrOpenDeviceInfo (
        OUT HDEVINFO* phdiOut,
        OUT SP_DEVINFO_DATA* pdeidOut) const;

    HRESULT
    HrOpenInstanceKey (
        IN REGSAM samDesired,
        OUT HKEY* phkey,
        OUT HDEVINFO* phdiOut OPTIONAL,
        OUT SP_DEVINFO_DATA* pdeidOut OPTIONAL) const;

    HRESULT
    HrOpenServiceKey (
        IN REGSAM samDesired,
        OUT HKEY* phkey) const;

    HRESULT
    HrStartOrStopEnumeratedComponent (
        IN DWORD dwFlag /* DICS_START or DICS_STOP */) const;

    PCWSTR
    PszGetPnpIdOrInfId () const
    {
        AssertH (FIsValidNetClass(m_Class));
        AssertH (FImplies(FIsEnumerated(m_Class),
                 m_pszPnpId && *m_pszPnpId));

        if (!m_pszPnpId)
        {
            AssertH (m_pszInfId && *m_pszInfId);
            return m_pszInfId;
        }

        AssertH (m_pszPnpId && *m_pszPnpId);
        return m_pszPnpId;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\compdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P D E F S . H
//
//  Contents:   Basic component related defintions.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgx.h"


// Maximum length (arbitrary) for bind strings.
// Bind strings are of the form \Device\foo_bar_...
//
const UINT _MAX_BIND_LENGTH = 512;


// A property of a component is its "Class".  This corresponds directly
// to the concept of Class exposed by SetupAPI.  That is, devices of all
// kinds belong to a class.  There are five basic network classes:
//   Net        : network adapters or software drivers that usually reside
//                at layer 2 or below.
//   Irda       : represent Infra-red networking devices (layer 2)
//   Nettrans   : network transports (protocols like TCP/IP, IPX, etc.)
//   Netservice : network services (File & Print, QOS, NetBIOS, etc.)
//   Netclient  : network clients (Client for Microsoft Networks, etc.)
//
enum NETCLASS
{
    NC_NET,
    NC_INFRARED,
    NC_NETTRANS,
    NC_NETCLIENT,
    NC_NETSERVICE,

    NC_CELEMS,      // count of elements in this enum, not an item
    NC_INVALID      // sentinel value for an invalid class, not an item
};

// map of NETCLASS enum to GUIDs for class
//
extern const GUID*  MAP_NETCLASS_TO_GUID[];

// map of NETCLASS enum to registry subkey strings for class
//
extern const PCWSTR MAP_NETCLASS_TO_NETWORK_SUBTREE[];

extern const WCHAR c_szTempNetcfgStorageForUninstalledEnumeratedComponent[];

inline
BOOL
FIsValidNetClass (
    NETCLASS Class)
{
    return ((UINT)Class < NC_CELEMS);
}

inline
BOOL
FIsConsideredNetClass (
    NETCLASS Class)
{
    AssertH (FIsValidNetClass (Class));

    return (NC_NET == Class || NC_INFRARED == Class);
}

inline
BOOL
FIsEnumerated (
    NETCLASS Class)
{
    AssertH (FIsValidNetClass (Class));

    // Currently, NC_NET and NC_INFRARED must be enumerated and they
    // are the only ones that are.
    //
    return (NC_NET == Class || NC_INFRARED == Class);
}

inline
BOOL
FIsEnumerated (
    const GUID& guidClass)
{
    // Currently, NET and INFRARED must be enumerated and they
    // are the only ones that are.
    //
    return (GUID_DEVCLASS_NET == guidClass ||
            GUID_DEVCLASS_INFRARED == guidClass);
}


inline
BOOL
FIsPhysicalAdapter (
    NETCLASS Class,
    DWORD dwCharacteristics)
{
    return FIsConsideredNetClass(Class) && (NCF_PHYSICAL & dwCharacteristics);
}

inline
BOOL
FIsPhysicalNetAdapter (
    NETCLASS Class,
    DWORD dwCharacteristics)
{
    return (NC_NET == Class) && (NCF_PHYSICAL & dwCharacteristics);
}

NETCLASS
NetClassEnumFromGuid (
    const GUID& guidClass);



// BASIC_COMPONENT_DATA is a structure used by code which
// creates a CComponent.  It is present just to avoid passing
// bunches of parameters to a function.
//
struct BASIC_COMPONENT_DATA
{
    GUID        InstanceGuid;
    NETCLASS    Class;
    DWORD       dwCharacter;
    DWORD       dwDeipFlags;
    PCWSTR      pszInfId;
    PCWSTR      pszPnpId;
};

HRESULT
HrOpenDeviceInfo (
    IN NETCLASS Class,
    IN PCWSTR pszPnpId,
    OUT HDEVINFO* phdiOut,
    OUT SP_DEVINFO_DATA* pdeidOut);

HRESULT
HrOpenComponentInstanceKey (
    IN NETCLASS Class,
    IN const GUID& InstanceGuid, OPTIONAL
    IN PCWSTR pszPnpId, OPTIONAL
    IN REGSAM samDesired,
    OUT HKEY* phkey,
    OUT HDEVINFO* phdiOut OPTIONAL,
    OUT SP_DEVINFO_DATA* pdeidOut OPTIONAL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\complist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P L I S T . C P P
//
//  Contents:   Implements the basic datatype for a collection of component
//              pointers.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "bindings.h"
#include "complist.h"
#include "nceh.h"
#include "stable.h"

VOID
CComponentList::FreeComponentsNotInOtherComponentList (
    IN const CComponentList* pOtherList)
{
    Assert (this);
    Assert (pOtherList);

    CComponentList::iterator iter;
    CComponent* pComponent;

    iter = begin();
    while (iter != end())
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pOtherList->FComponentInList (pComponent))
        {
            erase (iter);
            delete pComponent;
        }
        else
        {
            iter++;
        }
    }
}

HRESULT
CComponentList::HrCopyComponentList (
    IN const CComponentList* pSourceList)
{
    HRESULT hr;

    Assert (this);
    Assert (pSourceList);

    NC_TRY
    {
        *this = *pSourceList;
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CComponentList::HrCopyComponentList");
    return hr;
}

HRESULT
CComponentList::HrAddComponentsInList1ButNotInList2 (
    IN const CComponentList* pList1,
    IN const CComponentList* pList2)
{
    HRESULT hr;
    CComponentList::const_iterator iter;
    CComponent* pComponent;

    Assert (this);
    Assert (pList1);
    Assert (pList2);

    hr = S_OK;

    for (iter = pList1->begin(); iter != pList1->end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (pList2->FComponentInList (pComponent))
        {
            continue;
        }

        hr = HrInsertComponent (pComponent, INS_IGNORE_IF_DUP | INS_SORTED);
        if (S_OK != hr)
        {
            break;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentList::HrAddComponentsInList1ButNotInList2");
    return hr;
}

HRESULT
CComponentList::HrInsertComponent (
    IN const CComponent* pComponent,
    IN DWORD dwFlags /* INS_FLAGS */)
{
    HRESULT hr;

    Assert (this);
    Assert (pComponent);
    Assert (dwFlags);
    Assert ((dwFlags & INS_ASSERT_IF_DUP) || (dwFlags & INS_IGNORE_IF_DUP));
    Assert ((dwFlags & INS_SORTED) || (dwFlags & INS_NON_SORTED));
    Assert (!(INS_APPEND & dwFlags) && !(INS_INSERT & dwFlags));

    if (FComponentInList (pComponent))
    {
        // If the caller didn't tell us to ignore duplicates, we assert
        // if there is one because it is bad, bad, bad to have duplicate
        // components in the list.
        //
        // If we have a dup, we want the caller to be aware that it
        // is possible, and pass us the flag telling us to ignore it.
        // Otherwise, we assert to let them know. (And we still ignore
        // it.)
        Assert (dwFlags & INS_IGNORE_IF_DUP);

        return S_OK;
    }

    // Assert there is not already a component in the list with the
    // same instance guid.
    //
    Assert (!PFindComponentByInstanceGuid (&pComponent->m_InstanceGuid));

    iterator iter = end();

    if (dwFlags & INS_SORTED)
    {
        // For 'cleanliness sake', keep the components sorted
        // in class order.
        //
        for (iter = begin(); iter != end(); iter++)
        {
            if ((UINT)pComponent->Class() >= (UINT)(*iter)->Class())
            {
                break;
            }
        }
    }

    NC_TRY
    {
        insert (iter, const_cast<CComponent*>(pComponent));
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CComponentList::HrInsertComponent");
    return hr;
}

HRESULT
CComponentList::HrReserveRoomForComponents (
    IN UINT cComponents)
{
    HRESULT hr;

    NC_TRY
    {
        reserve (cComponents);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentList::HrReserveRoomForComponents");
    return hr;
}

CComponent*
CComponentList::PFindComponentByBindForm (
    IN NETCLASS Class OPTIONAL,
    IN PCWSTR pszBindForm) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pszBindForm && *pszBindForm);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Having a bindform is optional.  Skip those who don't have one.
        //
        if (!pComponent->Ext.PszBindForm())
        {
            continue;
        }

        // Skip components that don't match the class optionally
        // specified by the caller.
        //
        if (FIsValidNetClass(Class) && (Class != pComponent->Class()))
        {
            continue;
        }

        Assert (pComponent->Ext.PszBindForm());

        if (0 == _wcsicmp (pszBindForm, pComponent->Ext.PszBindForm()))
        {
            return pComponent;
        }
    }

    return NULL;
}

CComponent*
CComponentList::PFindComponentByBindName (
    IN NETCLASS Class OPTIONAL,
    IN PCWSTR pszBindName) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pszBindName && *pszBindName);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Skip components that don't match the class optionally
        // specified by the caller.
        //
        if (FIsValidNetClass(Class) && (Class != pComponent->Class()))
        {
            continue;
        }

        Assert (pComponent->Ext.PszBindName());

        if (0 == _wcsicmp (pszBindName, pComponent->Ext.PszBindName()))
        {
            return pComponent;
        }
    }

    return NULL;
}

CComponent*
CComponentList::PFindComponentByInstanceGuid (
    IN const GUID* pInstanceGuid) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pInstanceGuid);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (*pInstanceGuid == pComponent->m_InstanceGuid)
        {
            return pComponent;
        }
    }

    return NULL;
}

CComponent*
CComponentList::PFindComponentByInfId (
    IN PCWSTR pszInfId,
    IN OUT ULONG* pulIndex OPTIONAL) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pszInfId && *pszInfId);

    iter = begin();
    if (pulIndex && (*pulIndex <= size()))
    {
        iter = begin() + *pulIndex;
        Assert (iter <= end());
    }

    for (; iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);
        Assert (pComponent->m_pszInfId && *pComponent->m_pszInfId);

        if (0 == _wcsicmp (pszInfId, pComponent->m_pszInfId))
        {
            if (pulIndex)
            {
                Assert (iter >= begin());
                *pulIndex = iter - begin();
            }
            return pComponent;
        }
    }

    return NULL;
}

CComponent*
CComponentList::PFindComponentByPnpId (
    IN PCWSTR pszPnpId) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pszPnpId && *pszPnpId);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pComponent->m_pszPnpId)
        {
            continue;
        }

        Assert (pComponent->m_pszPnpId && *pComponent->m_pszPnpId);

        if (0 == _wcsicmp (pszPnpId, pComponent->m_pszPnpId))
        {
            return pComponent;
        }
    }

    return NULL;
}

VOID
CComponentList::RemoveComponent (
    IN const CComponent* pComponent)
{
    iterator iter;

    Assert (this);
    Assert (pComponent);

    iter = find (begin(), end(), pComponent);

    // Component should be found.
    //
    Assert (iter != end());

    erase (iter);

    // Should not be any dups.  If there are, the list
    // is bogus to begin with.
    //
    Assert (end() == find (begin(), end(), pComponent));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\complist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P L I S T . H
//
//  Contents:   The basic datatype for a collection of component pointers.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "compdefs.h"

class CComponent;

// A component list is a collection of pointers to components.
//
class CComponentList : public vector<CComponent*>
{
public:
    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    Count () const
    {
        return size();
    }

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    BOOL
    FComponentInList (
        IN const CComponent* pComponent) const
    {
        AssertH (this);
        AssertH (pComponent);

        return (find (begin(), end(), pComponent) != end());
    }

    VOID
    FreeComponentsNotInOtherComponentList (
        IN const CComponentList* pOtherList);

    HRESULT
    HrCopyComponentList (
        IN const CComponentList* pSourceList);

    HRESULT
    HrAddComponentsInList1ButNotInList2 (
        IN const CComponentList* pList1,
        IN const CComponentList* pList2);

    HRESULT
    HrInsertComponent (
        IN const CComponent* pComponent,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrReserveRoomForComponents (
        IN UINT cComponents);

    CComponent*
    PFindComponentByBindForm (
        IN NETCLASS Class OPTIONAL,
        IN PCWSTR pszBindForm) const;

    CComponent*
    PFindComponentByBindName (
        IN NETCLASS Class OPTIONAL,
        IN PCWSTR pszBindName) const;

    CComponent*
    PFindComponentByInstanceGuid (
        IN const GUID* pInstanceGuid) const;

    CComponent*
    PFindComponentByInfId (
        IN PCWSTR pszInfId,
        IN OUT ULONG* pulIndex OPTIONAL) const;

    CComponent*
    PFindComponentByPnpId (
        IN PCWSTR pszPnpId) const;

    CComponent*
    PGetComponentAtIndex (
        IN UINT unIndex) const
    {
        AssertH (this);

        return (unIndex < size()) ? (*this)[unIndex] : NULL;
    }

    VOID
    RemoveComponent (
        IN const CComponent* pComponent);

    UINT
    UnGetIndexOfComponent (
        IN const CComponent* pComponent) const
    {
        AssertH (this);

        const_iterator iter = find (begin(), end(), pComponent);
        AssertH (iter != end());
        AssertH ((UINT)(iter - begin()) < size());

        return (UINT)(iter - begin());
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\dihook.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I H O O K. H
//
//  Contents:   Network Class Installer
//
//  Notes:
//
//  Author:     billbe   25 Nov 1996
//
//----------------------------------------------------------------------------

#pragma once

HRESULT
_HrNetClassInstaller (DI_FUNCTION difFunction,
                      HDEVINFO hdi,
                      PSP_DEVINFO_DATA pdeid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\diag.cpp ===
#include "pch.h"
#pragma hdrstop

#include "adapter.h"
#include "diag.h"
#include "inetcfg.h"
#include "lanamap.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netcfg.h"
#include "persist.h"
#include "util.h"
#include <conio.h>      // _kbhit

//move to classinst.cpp
HRESULT
HrCiDoCompleteSectionInstall(
    HINF hinfFile,
    HKEY hkeyRelative,
    PCWSTR szSection,
    HWND hwndParent,
    BOOL fEnumerated);


class CNetCfgInternalDiagnostic
{
public:
    static VOID
    DoCreateReleaseDiagnostic (
        IN const DIAG_OPTIONS* pOptions,
        BOOL fPrime);

    static VOID
    DoEnumAllDiagnostic (
        IN const DIAG_OPTIONS* pOptions);

    static VOID
    DoSaveLoadDiagnostic (
        IN const DIAG_OPTIONS* pOptions,
        IN CNetConfig* pNetConfig);

    static VOID
    DoWriteLockDiagnostic (
        IN const DIAG_OPTIONS* pOptions,
        IN CNetConfig* pNetConfig);

    static VOID
    CmdFullDiagnostic (
        IN const DIAG_OPTIONS* pOptions,
        IN CNetConfig* pNetConfig);
};

VOID
PromptForLeakCheck (
    IN const DIAG_OPTIONS* pOptions,
    IN PCSTR psz)
{
    if (pOptions->fLeakCheck)
    {
        g_pDiagCtx->Printf (ttidBeDiag, psz);
        while (!_kbhit())
        {
            Sleep (50);
        }
        _getch ();
        g_pDiagCtx->Printf (ttidBeDiag, "\n");
    }
}

HRESULT
HrCreateINetCfg (
    IN BOOL fAcquireWriteLock,
    OUT CImplINetCfg** ppINetCfg)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    hr = CComCreator<CComObject <CImplINetCfg> >::CreateInstance(
            NULL, IID_INetCfg, (VOID**)&pINetCfg);
    if (S_OK == hr)
    {
        if (fAcquireWriteLock)
        {
            hr = pINetCfg->AcquireWriteLock (100, L"ncdiag", NULL);

            if (S_FALSE == hr)
            {
                g_pDiagCtx->Printf (ttidBeDiag, "The write lock could not be acquired.\n");
            }
            else if (NETCFG_E_NEED_REBOOT == hr)
            {
                g_pDiagCtx->Printf (ttidBeDiag, "A reboot is required before any futher "
                    "changes can be made.\n");
            }
        }

        if (S_OK == hr)
        {
            hr = pINetCfg->Initialize (NULL);
            if (S_OK == hr)
            {
                *ppINetCfg = pINetCfg;
            }
        }

        if (S_OK != hr)
        {
            ReleaseObj (pINetCfg->GetUnknown());
        }
    }
    return hr;
}

HRESULT
HrFindBindPath (
    IN CImplINetCfg* pINetCfg,
    IN PCWSTR pszPathToken,
    OUT INetCfgBindingPath** ppIPath,
    OUT INetCfgComponentBindings** ppIOwner)
{
    HRESULT hr;
    const WCHAR szDelim[] = L"->";
    WCHAR szBindPath [_MAX_PATH];
    PCWSTR pszInfId;
    PWSTR pszNext;
    INetCfgComponent* pIComp;

    *ppIPath = NULL;

    if (ppIOwner)
    {
        *ppIOwner = NULL;
    }

    wcscpy (szBindPath, pszPathToken);
    pszInfId = GetNextStringToken (szBindPath, szDelim, &pszNext);

    hr = pINetCfg->FindComponent (pszInfId, &pIComp);
    if (S_OK == hr)
    {
        INetCfgComponentBindings* pIBind;

        hr = pIComp->QueryInterface (IID_INetCfgComponentBindings,
                        (VOID**)&pIBind);
        if (S_OK == hr)
        {
            IEnumNetCfgBindingPath* pIEnumPath;

            hr = pIBind->EnumBindingPaths (EBP_BELOW, &pIEnumPath);
            if (S_OK == hr)
            {
                INetCfgBindingPath* rgIPath [256];
                ULONG cIPath;

                hr = pIEnumPath->Next (celems(rgIPath), rgIPath, &cIPath);
                if (SUCCEEDED(hr) && cIPath)
                {
                    for (ULONG iPath = 0;
                         (iPath < cIPath) && !(*ppIPath);
                         iPath++)
                    {
                        PWSTR pszToken;

                        hr = rgIPath[iPath]->GetPathToken (&pszToken);
                        if (S_OK == hr)
                        {
                            if (0 == wcscmp (pszPathToken, pszToken))
                            {
                                AddRefObj (rgIPath[iPath]);
                                *ppIPath = rgIPath[iPath];

                                if (ppIOwner)
                                {
                                    INetCfgComponent* pICompOwner;

                                    hr = rgIPath[0]->GetOwner(&pICompOwner);
                                    Assert (S_OK == hr);

                                    pICompOwner->QueryInterface (
                                        IID_INetCfgComponentBindings,
                                        (VOID**)ppIOwner);

                                    ReleaseObj (pICompOwner);
                                }
                            }
                            CoTaskMemFree (pszToken);
                        }
                    }

                    ReleaseIUnknownArray(cIPath, (IUnknown**)rgIPath);
                    hr = S_OK;
                }

                ReleaseObj (pIEnumPath);
            }

            ReleaseObj (pIBind);
        }

        ReleaseObj (pIComp);
    }
    else if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    return hr;
}

// This test ensures proper circular reference behavior between CNetConfig
// and CImplINetCfg.
// The following is performed:
//     create a CNetConfig and have it create its INetCfg for the notify objects.
//     AddRef its INetCfg
//     destroy the CNetConfig
//     Try to Uninitialize the INetCfg which should fail because it never
//     owned its internal CNetConfig pointer.
//     Release the INetCfg and ensure that nothing is leaked.
//
VOID
CNetCfgInternalDiagnostic::DoCreateReleaseDiagnostic (
    IN const DIAG_OPTIONS* pOptions,
    IN BOOL fPrime)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg = NULL;

    if (!fPrime)
    {
        PromptForLeakCheck (pOptions,
            "Create/Release diagnostic...(dump heap)");
    }

    // Scoping brackets so that NetConfig will be created and destroyed
    // in this scope.
    //
    {
        CNetConfig NetConfig;

        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);
        if (S_OK == hr)
        {
            // Shouldn't have internal INetCfg created yet.
            //
            Assert (!NetConfig.Notify.m_pINetCfg);

            hr = NetConfig.Notify.HrEnsureNotifyObjectsInitialized ();
            if (S_OK == hr)
            {
                // Should now have internal INetCfg created.
                //
                Assert (NetConfig.Notify.m_pINetCfg);
                pINetCfg = NetConfig.Notify.m_pINetCfg;

                // INetCfg should be pointing back to our CNetConfig object.
                //
                Assert (&NetConfig == pINetCfg->m_pNetConfig);

                // Let's hang on to it and see what happens after we let
                // the parent CNetConfig be destroyed.
                //
                pINetCfg = NetConfig.Notify.m_pINetCfg;
                AddRefObj (pINetCfg->GetUnknown());
            }
        }
    }

    if ((S_OK == hr) && pINetCfg)
    {
        // Now that CNetConfig is destroyed, it should not be pointing to
        // any CNetConfig object.
        //
        Assert (!pINetCfg->m_pNetConfig);

        hr = pINetCfg->Uninitialize();
        Assert (NETCFG_E_NOT_INITIALIZED == hr);

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (NETCFG_E_NOT_INITIALIZED == hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "Passed Create/Release diagnostic.\n");
    }
    else
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Create/Release diagnostic.\n");
    }

    if (!fPrime)
    {
        PromptForLeakCheck (pOptions,
            "Create/Release diagnostic...(dump heap and compare)");
    }
}

VOID
CNetCfgInternalDiagnostic::DoEnumAllDiagnostic (
    IN const DIAG_OPTIONS* pOptions)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    PromptForLeakCheck (pOptions, "Enumerate All diagnostic...(dump heap)");

    hr = HrCreateINetCfg (FALSE, &pINetCfg);
    if (S_OK == hr)
    {
        IEnumNetCfgComponent* pIEnum;

        hr = pINetCfg->EnumComponents (NULL, &pIEnum);
        if (S_OK == hr)
        {
            INetCfgComponent* rgIComp[128];
            ULONG cIComp;

            hr = pIEnum->Next (celems(rgIComp), rgIComp, &cIComp);
            if (SUCCEEDED(hr) && cIComp)
            {
                INetCfgComponentBindings* pIBind;
                IEnumNetCfgBindingPath* pIEnumPath;
                INetCfgBindingPath* rgIPath[256];
                PWSTR pszInfId;
                ULONG cIPath;
                ULONG cIPathTotal = 0;
                ULONG cIIntTotal = 0;

                for (ULONG iComp = 0; iComp < cIComp; iComp++)
                {
                    hr = rgIComp[iComp]->GetId (&pszInfId);
                    if (S_OK == hr)
                    {
                        hr = (*pszInfId) ? S_OK : E_FAIL;
                        if (S_OK != hr)
                        {
                            break;
                        }

                        hr = rgIComp[iComp]->QueryInterface (IID_INetCfgComponentBindings, (VOID**)&pIBind);
                        if (S_OK == hr)
                        {
                            hr = pIBind->EnumBindingPaths (EBP_BELOW, &pIEnumPath);
                            if (S_OK == hr)
                            {
                                hr = pIEnumPath->Next (celems(rgIPath), rgIPath, &cIPath);
                                if (SUCCEEDED(hr))
                                {
                                    for (ULONG iPath = 0; iPath < cIPath; iPath++)
                                    {
                                        ULONG ulDepth;
                                        hr = rgIPath[iPath]->GetDepth(&ulDepth);
                                        if (S_OK == hr)
                                        {
                                            IEnumNetCfgBindingInterface* pIEnumInt;
                                            INetCfgBindingInterface* rgIInt[128];
                                            ULONG cIInt;

                                            hr = rgIPath[iPath]->EnumBindingInterfaces (&pIEnumInt);
                                            if (S_OK == hr)
                                            {
                                                hr = pIEnumInt->Next (celems(rgIInt), rgIInt, &cIInt);
                                                if (SUCCEEDED(hr))
                                                {
                                                    cIIntTotal += cIInt;
                                                    ReleaseIUnknownArray(cIInt, (IUnknown**)rgIInt);
                                                }
                                                else if (S_FALSE == hr)
                                                {
                                                    hr = S_OK;
                                                }

                                                ReleaseObj (pIEnumInt);
                                            }
                                        }
                                    }

                                    cIPathTotal += cIPath;
                                    ReleaseIUnknownArray(cIPath, (IUnknown**)rgIPath);
                                    hr = S_OK;
                                }

                                ReleaseObj (pIEnumPath);
                            }

                            ReleaseObj (pIBind);
                        }

                        CoTaskMemFree (pszInfId);
                    }

                    if (S_OK != hr)
                    {
                        break;
                    }
                }

                ReleaseIUnknownArray(cIComp, (IUnknown**)rgIComp);

                // Note: Total bindpaths are not total unique bindpaths.
                // (A component's bindpaths which end in ms_ipx have
                // ms_ipx's lower bindings added.  These additional
                // bindings are counted for every component which has
                // bindpaths that end in ms_ipx.)
                //
                g_pDiagCtx->Printf (ttidBeDiag, "Passed Enumerate All diagnostic.  (%d components, %d (non-unique) bindpaths, %d interfaces)\n", cIComp, cIPathTotal, cIIntTotal);
            }
            else if (S_FALSE == hr)
            {
                hr = S_OK;
            }

            ReleaseObj (pIEnum);
        }
        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Enumerate All diagnostic.\n");
    }

    PromptForLeakCheck (pOptions, "Enumerate All diagnostic...(dump heap and compare)");
}

VOID
CNetCfgInternalDiagnostic::DoSaveLoadDiagnostic (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    BOOL fClearDisabledBindings = FALSE;
    CBindingSet BindingSet;
    CComponentList::iterator iter;
    CComponent* pComponent;

    // Generate a full set of bindings so we test persisting them as
    // disabled bindings, but only if we don't already have disabled
    // bindings.
    //
    if (0 == pNetConfig->Core.DisabledBindings.CountBindPaths())
    {
        fClearDisabledBindings = TRUE;

        for (iter =  pNetConfig->Core.Components.begin();
             iter != pNetConfig->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            hr = pNetConfig->Core.HrGetComponentBindings (
                    pComponent,
                    GBF_ADD_TO_BINDSET,
                    &pNetConfig->Core.DisabledBindings);
            if (S_OK != hr) return;
        }
    }

    PBYTE pbBuf;
    ULONG cbBuf;

    hr = HrSaveNetworkConfigurationToBufferWithAlloc (
            pNetConfig, &pbBuf, &cbBuf);
    if (S_OK == hr)
    {
        CNetConfig NetConfigCopy;

        hr = HrLoadNetworkConfigurationFromBuffer (
                pbBuf, cbBuf, &NetConfigCopy);
        if (S_OK == hr)
        {
            PBYTE pbBufCopy;
            ULONG cbBufCopy;

            hr = HrSaveNetworkConfigurationToBufferWithAlloc (
                    &NetConfigCopy, &pbBufCopy, &cbBufCopy);
            if (S_OK == hr)
            {
                if ((cbBufCopy == cbBuf) && (0 == memcmp(pbBufCopy, pbBuf, cbBuf)))
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "Passed Save/Load diagnostic.  (%d bytes)\n", cbBuf);
                }
                else
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "FAILED compare for Save/Load diagnostic.\n");
                }

                MemFree (pbBufCopy);
            }
        }

        MemFree (pbBuf);
    }

    // Leave the disabled bindings as we found them.
    //
    if (fClearDisabledBindings)
    {
        pNetConfig->Core.DisabledBindings.Clear();
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Save/Load diagnostic.\n");
    }
}

VOID
CNetCfgInternalDiagnostic::DoWriteLockDiagnostic (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;
    BOOL fFailed = FALSE;

    PromptForLeakCheck (pOptions, "WriteLock diagnostic...(dump heap)");

    hr = CComCreator<CComObject <CImplINetCfg> >::CreateInstance(
            NULL, IID_INetCfg, (VOID**)&pINetCfg);
    if (S_OK == hr)
    {
        PWSTR psz;

        hr = pINetCfg->IsWriteLocked (&psz);
        if (S_FALSE != hr) fFailed = TRUE;
        if (psz) fFailed = TRUE;

        hr = pINetCfg->AcquireWriteLock (100, L"ncdiag", &psz);
        if (S_OK != hr) fFailed = TRUE;
        if (psz) fFailed = TRUE;

        if (S_OK == hr)
        {
            hr = pINetCfg->IsWriteLocked (&psz);
            if (S_OK != hr) fFailed = TRUE;
            if (!psz) fFailed = TRUE;

            if (S_OK == hr)
            {
                if (0 != wcscmp(L"ncdiag", psz))
                {
                    fFailed = TRUE;
                }
            }

            CoTaskMemFree (psz);

            hr = pINetCfg->ReleaseWriteLock ();
            if (S_OK != hr) fFailed = TRUE;

            hr = pINetCfg->IsWriteLocked (&psz);
            if (S_FALSE != hr) fFailed = TRUE;
            if (psz) fFailed = TRUE;
        }

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (!fFailed)
    {
        PromptForLeakCheck (pOptions, "WriteLock diagnostic...(dump heap and compare)");
        g_pDiagCtx->Printf (ttidBeDiag, "Passed WriteLock diagnostic.\n");
    }
    else
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED WriteLock diagnostic.\n");
    }
}

VOID
CNetCfgInternalDiagnostic::CmdFullDiagnostic (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    DoCreateReleaseDiagnostic (pOptions, TRUE);
    if (pOptions->fLeakCheck)
    {
        DoCreateReleaseDiagnostic (pOptions, FALSE);
    }

    DoEnumAllDiagnostic (pOptions);

    DoSaveLoadDiagnostic (pOptions, pNetConfig);

    DoWriteLockDiagnostic (pOptions, pNetConfig);
}

VOID
CmdAddComponent (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    PromptForLeakCheck (pOptions, "Add component...(dump heap)");

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgClassSetup* pSetup;

        hr = pINetCfg->QueryNetCfgClass (
                &pOptions->ClassGuid,
                IID_INetCfgClassSetup,
                (VOID**)&pSetup);

        if (S_OK == hr)
        {
            OBO_TOKEN OboToken;
            INetCfgComponent* pIComp;

            ZeroMemory (&OboToken, sizeof(OboToken));
            OboToken.Type = OBO_USER;

            hr = pSetup->Install (
                    pOptions->pszInfId,
                    &OboToken,
                    0, 0, NULL, NULL,
                    &pIComp);

            if (SUCCEEDED(hr))
            {
                ReleaseObj (pIComp);
            }

            if (NETCFG_S_REBOOT == hr)
            {
                hr = S_OK;
                g_pDiagCtx->Printf (ttidBeDiag, "%S was installed, but a reboot is required.\n",
                    pOptions->pszInfId);
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
                g_pDiagCtx->Printf (ttidBeDiag, "The INF file for %S could not be found.\n",
                    pOptions->pszInfId);
            }

            ReleaseObj (pSetup);
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Add component.\n");
    }

    PromptForLeakCheck (pOptions, "Add component...(dump heap and compare)");
}

VOID
CmdAddRemoveStress (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;
    NETCLASS Class;
    PCWSTR pszInfId;
    PRODUCT_FLAVOR Flavor;
    BOOL fPrompted;

    static const struct
    {
        NETCLASS    Class;
        PCWSTR      pszInfId;
        BOOL        fServerOnly;
    } aPassInfo [] =
    {
        { NC_NETCLIENT,  L"ms_msclient",    FALSE },
        { NC_NETCLIENT,  L"ms_nwclient",    FALSE },
//        { NC_NETSERVICE, L"ms_fpnw",        FALSE },    // requries copy files
        { NC_NETSERVICE, L"ms_netbios",     FALSE },
        { NC_NETSERVICE, L"ms_nwsapagent",  FALSE },
        { NC_NETSERVICE, L"ms_psched",      FALSE },
        { NC_NETSERVICE, L"ms_rsvp",        FALSE },
        { NC_NETSERVICE, L"ms_server",      FALSE },
//        { NC_NETSERVICE, L"ms_wlbs",        FALSE },
        { NC_NETTRANS,   L"ms_appletalk",   FALSE },
        { NC_NETTRANS,   L"ms_atmarps",     TRUE },
        { NC_NETTRANS,   L"ms_atmlane",     FALSE },
        { NC_NETTRANS,   L"ms_atmuni",      FALSE },
        { NC_NETTRANS,   L"ms_irda",        FALSE },
//        { NC_NETTRANS,   L"ms_isotpsys",    FALSE },
        { NC_NETTRANS,   L"ms_rawwan",      FALSE },
//        { NC_NETTRANS,   L"ms_streams",     FALSE },
//        { NC_NETTRANS,   L"ms_tcpip",       FALSE },
    };

    GetProductFlavor (NULL, &Flavor);

    fPrompted = FALSE;

    g_pDiagCtx->SetFlags (
        DF_SHOW_CONSOLE_OUTPUT | DF_DONT_START_SERVICES |
        DF_DONT_DO_PNP_BINDS | DF_SUPRESS_E_NEED_REBOOT);

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        UINT cSkip = 0;

        for (BOOL fInstall = TRUE;
             !_kbhit() && (S_OK == hr);
             fInstall = !fInstall)
        {
            for (UINT i = cSkip;
                 (i < celems(aPassInfo)) && (S_OK == hr);
                 i += (1 + cSkip))
            {
                INetCfgClassSetup* pSetup;
                INetCfgComponent* pIComp;

                if (aPassInfo[i].fServerOnly && (PF_WORKSTATION == Flavor))
                {
                    continue;
                }

                Class    = aPassInfo[i].Class;
                pszInfId = aPassInfo[i].pszInfId;

                if (fInstall)
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "--------------------\n"
                        "Installing %S\n", pszInfId);

                    hr = pINetCfg->QueryNetCfgClass (
                            MAP_NETCLASS_TO_GUID[Class],
                            IID_INetCfgClassSetup,
                            (VOID**)&pSetup);

                    if (S_OK == hr)
                    {
                        OBO_TOKEN OboToken;

                        ZeroMemory (&OboToken, sizeof(OboToken));
                        OboToken.Type = OBO_USER;

                        hr = pSetup->Install (
                                pszInfId,
                                &OboToken,
                                0, 0, NULL, NULL,
                                &pIComp);

                        if (SUCCEEDED(hr))
                        {
                            ReleaseObj (pIComp);
                        }

                        if (NETCFG_S_REBOOT == hr)
                        {
                            hr = S_OK;
                            g_pDiagCtx->Printf (ttidBeDiag, "%S was installed, but a reboot is required.\n",
                                pszInfId);
                        }

                        ReleaseObj (pSetup);
                    }
                }
                else
                {
                    hr = pINetCfg->FindComponent (pszInfId, &pIComp);
                    if (S_OK == hr)
                    {
                        GUID ClassGuid;

                        g_pDiagCtx->Printf (ttidBeDiag, "--------------------\n"
                            "Removing %S\n", pszInfId);

                        hr = pIComp->GetClassGuid (&ClassGuid);
                        if (S_OK == hr)
                        {
                            hr = pINetCfg->QueryNetCfgClass (
                                    &ClassGuid,
                                    IID_INetCfgClassSetup,
                                    (VOID**)&pSetup);

                            if (S_OK == hr)
                            {
                                OBO_TOKEN OboToken;

                                ZeroMemory (&OboToken, sizeof(OboToken));
                                OboToken.Type = OBO_USER;

                                hr = pSetup->DeInstall (
                                        pIComp,
                                        &OboToken,
                                        NULL);

                                if (NETCFG_S_REBOOT == hr)
                                {
                                    hr = S_OK;
                                    g_pDiagCtx->Printf (ttidBeDiag, "%S was removed, but a reboot is required.\n",
                                        pszInfId);
                                }

                                if (NETCFG_S_STILL_REFERENCED == hr)
                                {
                                    hr = S_OK;
                                    g_pDiagCtx->Printf (ttidBeDiag, "%S is still referenced\n",
                                        pszInfId);
                                }

                                if (E_INVALIDARG == hr)
                                {
                                    hr = S_OK;
                                    g_pDiagCtx->Printf (ttidBeDiag, "%S is installed, but not on behalf of "
                                        "the user, so we can't remove it.  (Proceeding.)\n",
                                        pszInfId);
                                }

                                ReleaseObj (pSetup);
                            }
                        }

                        ReleaseObj (pIComp);
                    }
                    else if (S_FALSE == hr)
                    {
                        hr = S_OK;
                    }
                }
            }

            cSkip++;
            if (cSkip >= celems(aPassInfo))
            {
                cSkip = 0;
            }

            g_pDiagCtx->Printf (ttidBeDiag, "\n");

            if (!fPrompted)
            {
                PromptForLeakCheck (pOptions, "Add/Remove stress...(dump heap)");
                fPrompted = TRUE;
            }
        }

        if (S_OK == hr)
        {
            _getch ();
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Add/Remove stress component.\n");
    }

    if (fPrompted)
    {
        PromptForLeakCheck (pOptions, "Add/Remove stress...(dump heap and compare)");
    }
}

VOID
CmdCleanup (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    NETCLASS Class;
    PCWSTR pszSubtree;
    HKEY hkeySubtree;
    DWORD dwIndex;
    HKEY hkeyInstance;
    GUID InstanceGuid;
    BOOL fDeleteKey;
    WCHAR szInfPath [_MAX_PATH];
    WCHAR szInfSection [_MAX_PATH];
    DWORD cbData;

    static const struct
    {
        NETCLASS    Class;
        PCWSTR      pszSubtree;
    } aPassInfo [] =
    {
        { NC_NET,        NULL },
        { NC_INFRARED,   NULL },
        { NC_NETTRANS,   NULL },
        { NC_NETCLIENT,  NULL },
        { NC_NETSERVICE, NULL },
        { NC_NET,        L"System\\CurrentControlSet\\Control\\Network\\{4d36e972-e325-11ce-bfc1-08002be10318}" },
    };

    for (UINT i = 0; i < celems(aPassInfo); i++)
    {
        Class      = aPassInfo[i].Class;
        pszSubtree = aPassInfo[i].pszSubtree;

        Assert (FIsValidNetClass(Class));

        if (!pszSubtree)
        {
            pszSubtree = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];
        }

        // Play it safe and assume we don't be deleting anything.
        //
        fDeleteKey = FALSE;

        if (!FIsEnumerated (Class))
        {
            hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    pszSubtree,
                    KEY_READ,
                    &hkeySubtree);

            if (S_OK == hr)
            {
                DWORD cchGuid;
                WCHAR szInstanceGuid [c_cchGuidWithTerm];
                FILETIME ftLastWrite;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    fDeleteKey = FALSE;

                    cchGuid = celems(szInstanceGuid);

                    hr = HrRegEnumKeyEx (
                            hkeySubtree, dwIndex, szInstanceGuid, &cchGuid,
                            NULL, NULL, &ftLastWrite);

                    if ((S_OK == hr) && ((c_cchGuidWithTerm-1) == cchGuid))
                    {
                        hr = IIDFromString (szInstanceGuid, &InstanceGuid);
                        if (S_OK == hr)
                        {
                            if (!pNetConfig->Core.Components.PFindComponentByInstanceGuid(&InstanceGuid))
                            {
                                fDeleteKey = TRUE;

                                hr = HrRegOpenKeyEx (
                                        hkeySubtree,
                                        szInstanceGuid,
                                        KEY_READ,
                                        &hkeyInstance);

                                if (S_OK == hr)
                                {
                                    *szInfPath = 0;
                                    *szInfSection = 0;

                                    cbData = sizeof(szInfPath);
                                    HrRegQuerySzBuffer (hkeyInstance,
                                            REGSTR_VAL_INFPATH,
                                            szInfPath, &cbData);

                                    cbData = sizeof(szInfSection) - sizeof(L".Remove");
                                    HrRegQuerySzBuffer (hkeyInstance,
                                            REGSTR_VAL_INFSECTION,
                                            szInfSection, &cbData);

                                    if (*szInfPath && *szInfSection)
                                    {
                                        HINF hinf;

                                        hr = HrSetupOpenInfFile (
                                                szInfPath,
                                                NULL, INF_STYLE_WIN4, NULL,
                                                &hinf);

                                        if (S_OK == hr)
                                        {
                                            wcscat (szInfSection, L".Remove");

                                            g_pDiagCtx->Printf (ttidBeDiag, "Running %S...\n", szInfSection);

                                            hr = HrCiDoCompleteSectionInstall(
                                                    hinf, hkeyInstance,
                                                    szInfSection, NULL,
                                                    FIsEnumerated(Class));

                                            SetupCloseInfFile (hinf);
                                        }


                                    }

                                    RegCloseKey (hkeyInstance);
                                }
                            }
                        }

                        if (fDeleteKey)
                        {
                            g_pDiagCtx->Printf (ttidBeDiag, "Deleting tree %S...\n", szInstanceGuid);
                            (VOID) HrRegDeleteKeyTree (hkeySubtree, szInstanceGuid);
                            fDeleteKey = FALSE;

                            // Back the index up by one since we just
                            // delete the current element.
                            //
                            dwIndex--;
                        }
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                RegCloseKey (hkeySubtree);
            }
        }
        else
        {

            HDEVINFO hdi;

            hr = HrSetupDiGetClassDevs (MAP_NETCLASS_TO_GUID[Class],
                    NULL, NULL, DIGCF_PROFILE, &hdi);

            if (S_OK == hr)
            {
                SP_DEVINFO_DATA deid;
                WCHAR szPnpId [2 * _MAX_PATH];
                BOOL fr;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    hr = HrSetupDiEnumDeviceInfo (hdi, dwIndex, &deid);

                    if (S_OK == hr)
                    {
                        fr = SetupDiGetDeviceInstanceId (
                                hdi, &deid,
                                szPnpId, celems(szPnpId), NULL);

                        if (fr)
                        {
                            if (!pNetConfig->Core.Components.PFindComponentByPnpId(szPnpId))
                            {
                                g_pDiagCtx->Printf (ttidBeDiag, "Removing %S...\n", szPnpId);

                                ADAPTER_REMOVE_PARAMS arp = {0};
                                CiSetReservedField (hdi, &deid, &arp);
                                hr = HrSetupDiCallClassInstaller (
                                        DIF_REMOVE, hdi, &deid);
                                CiClearReservedField (hdi, &deid);
                            }
                        }
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                SetupDiDestroyDeviceInfoList (hdi);
            }
        }
    }
}

VOID
CmdRemoveComponent (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    PromptForLeakCheck (pOptions, "Remove component...(dump heap)");

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgComponent* pIComp;

        hr = pINetCfg->FindComponent (pOptions->pszInfId, &pIComp);
        if (S_OK == hr)
        {
            GUID ClassGuid;

            hr = pIComp->GetClassGuid (&ClassGuid);
            if (S_OK == hr)
            {
                INetCfgClassSetup* pSetup;

                hr = pINetCfg->QueryNetCfgClass (
                        &ClassGuid,
                        IID_INetCfgClassSetup,
                        (VOID**)&pSetup);

                if (S_OK == hr)
                {
                    OBO_TOKEN OboToken;

                    ZeroMemory (&OboToken, sizeof(OboToken));
                    OboToken.Type = OBO_USER;

                    hr = pSetup->DeInstall (
                            pIComp,
                            &OboToken,
                            NULL);

                    if (NETCFG_S_REBOOT == hr)
                    {
                        hr = S_OK;
                        g_pDiagCtx->Printf (ttidBeDiag, "%S was removed, but a reboot is required.\n",
                            pOptions->pszInfId);
                    }

                    if (NETCFG_S_STILL_REFERENCED == hr)
                    {
                        hr = S_OK;
                        g_pDiagCtx->Printf (ttidBeDiag, "%S is still referenced\n",
                            pOptions->pszInfId);
                    }

                    if (E_INVALIDARG == hr)
                    {
                        hr = S_OK;
                        g_pDiagCtx->Printf (ttidBeDiag, "%S is installed, but not on behalf of "
                            "the user, so it was not removed.\n",
                            pOptions->pszInfId);
                    }

                    ReleaseObj (pSetup);
                }
            }

            ReleaseObj (pIComp);
        }
        else if (S_FALSE == hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "%S was not found.\n", pOptions->pszInfId);
            hr = S_OK;
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
    else if (NETCFG_E_NEED_REBOOT == hr)
    {
        hr = S_OK;
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Remove component.\n");
    }

    PromptForLeakCheck (pOptions, "Remove component...(dump heap and compare)");
}

VOID
CmdUpdateComponent (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    PromptForLeakCheck (pOptions, "Update component...(dump heap)");

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgComponent* pIComp;

        hr = pINetCfg->FindComponent (pOptions->pszInfId, &pIComp);
        if (S_OK == hr)
        {
            INetCfgInternalSetup* pSetup;

            hr = pINetCfg->GetUnknown()->QueryInterface (
                    IID_INetCfgInternalSetup,
                    (VOID**)&pSetup);

            if (S_OK == hr)
            {
                hr = pSetup->UpdateNonEnumeratedComponent (
                        pIComp,
                        NSF_POSTSYSINSTALL,
                        0);

                if (S_OK == hr)
                {
                    hr = pINetCfg->Apply ();

                    if (NETCFG_S_REBOOT == hr)
                    {
                        hr = S_OK;
                        g_pDiagCtx->Printf (ttidBeDiag, "%S was removed, but a reboot is required.\n",
                            pOptions->pszInfId);
                    }
                }

                ReleaseObj (pSetup);
            }

            ReleaseObj (pIComp);
        }
        else if (S_FALSE == hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "%S was not found.\n", pOptions->pszInfId);
            hr = S_OK;
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
    else if (NETCFG_E_NEED_REBOOT == hr)
    {
        hr = S_OK;
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Update component.\n");
    }

    PromptForLeakCheck (pOptions, "Update component...(dump heap and compare)");
}

VOID
CmdRemoveReferences (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    Assert (pOptions->pszInfId);

    CComponent* pComponent;

    pComponent = pNetConfig->Core.Components.PFindComponentByInfId (
                    pOptions->pszInfId, NULL);

    if (pComponent)
    {
        pComponent->Refs.RemoveAllReferences();

        HrSaveNetworkConfigurationToRegistry (pNetConfig);
    }
}

VOID
CmdShowBindings (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr = S_OK;

    CComponent* pComponent;
    CBindingSet BindingSet;
    tstring strBindingSet;

    if (SHOW_DISABLED == pOptions->ShowBindParam)
    {
        pNetConfig->Core.DisabledBindings.Printf (ttidBeDiag, NULL);
        return;
    }
    else if (CST_BY_NAME == pOptions->CompSpecifier.Type)
    {
        pComponent = pNetConfig->Core.Components.PFindComponentByPnpId (
                        pOptions->CompSpecifier.pszInfOrPnpId);

        if (!pComponent)
        {
            pComponent = pNetConfig->Core.Components.PFindComponentByInfId (
                            pOptions->CompSpecifier.pszInfOrPnpId, NULL);
        }

        if (!pComponent)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "Component not found.");
            return;
        }

        if (SHOW_BELOW == pOptions->ShowBindParam)
        {
            hr = pNetConfig->Core.HrGetComponentBindings (
                    pComponent, GBF_DEFAULT, &BindingSet);
        }
        else if (SHOW_INVOLVING == pOptions->ShowBindParam)
        {
            hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                    pComponent, GBF_DEFAULT, &BindingSet);
        }
        if ((SHOW_UPPER == pOptions->ShowBindParam) &&
            FIsEnumerated(pComponent->Class()))
        {
            hr = pNetConfig->Core.HrGetComponentUpperBindings (
                    pComponent, GBF_DEFAULT, &BindingSet);
        }
    }
    else if (CST_ALL == pOptions->CompSpecifier.Type)
    {
        CComponentList::const_iterator iter;

        for (iter =  pNetConfig->Core.Components.begin();
             iter != pNetConfig->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            hr = pNetConfig->Core.HrGetComponentBindings (
                    pComponent,
                    GBF_ADD_TO_BINDSET,
                    &BindingSet);
            if (S_OK != hr) break;
        }
    }

    if ((S_OK == hr) && !BindingSet.FIsEmpty())
    {
        BindingSet.Printf (ttidBeDiag, NULL);
    }
}

VOID
CmdShowComponents (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CComponentList::const_iterator iter;
    const CComponent* pComponent;
    WCHAR szBuffer [256];
    CHAR* pszNetClass;
    UINT CountRefdBy;
    UINT i;

    hr = pNetConfig->HrEnsureExternalDataLoadedForAllComponents ();
    if (S_OK != hr)
    {
        return;
    }

    for (iter =  pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        StringFromGUID2 (pComponent->m_InstanceGuid,
            szBuffer, celems(szBuffer));

        switch (pComponent->Class())
        {
            case NC_NET:
                pszNetClass = "NET      ";
                break;

            case NC_INFRARED:
                pszNetClass = "INFRARED ";
                break;

            case NC_NETTRANS:
                pszNetClass = "TRANSPORT";
                break;

            case NC_NETCLIENT:
                pszNetClass = "CLIENT   ";
                break;

            case NC_NETSERVICE:
                pszNetClass = "SERVICE  ";
                break;

            default:
                pszNetClass = "(Invalid)";
                break;
        }

        tstring     strChars;

        SzFromCharacteristics(pComponent->m_dwCharacter, &strChars);

        g_pDiagCtx->Printf (ttidBeDiag,
            "\n"
            "%S   %S\n"                                 // InfId   PnpId
            "            Description:  %S\n"
            "                  Class:  %s\n"
            "              Character:  (0x%08x) %S\n"
            "                   Guid:  %S\n"
            "          NotifyObject?:  %s\n"
            "               BindForm:  %S\n"
            "               BindName:  %S\n"
            "   Service (CoServices):  %S  (%S)\n"
            "         Ref'd by User?:  %s\n",
            pComponent->m_pszInfId,
            (pComponent->m_pszPnpId) ? pComponent->m_pszPnpId : L"",
            (pComponent->Ext.PszDescription()) ? pComponent->Ext.PszDescription() : L"<no description>",
            pszNetClass, pComponent->m_dwCharacter, strChars.c_str(), szBuffer,
            pComponent->Ext.FHasNotifyObject() ? "Yes" : "No",
            (pComponent->Ext.PszBindForm()) ? pComponent->Ext.PszBindForm() : L"<default>",
            pComponent->Ext.PszBindName(),
            (pComponent->Ext.PszService()) ? pComponent->Ext.PszService() : L"(none)",
            (pComponent->Ext.PszCoServices()) ? pComponent->Ext.PszCoServices() : L"none",
            (pComponent->Refs.FIsReferencedByUser()) ? "Yes" : "No");

        CountRefdBy = pComponent->Refs.CountComponentsReferencedBy();
        if (CountRefdBy)
        {
            *szBuffer = 0;

            for (i = 0; i < CountRefdBy; i++)
            {
                CComponent* pRefdBy;
                pRefdBy = pComponent->Refs.PComponentReferencedByAtIndex(i);
                Assert (pRefdBy);

                wcscat (szBuffer, pRefdBy->PszGetPnpIdOrInfId());
                wcscat (szBuffer, L" ");
            }
        }
        else
        {
            wcscpy (szBuffer, L"(none)");
        }
        g_pDiagCtx->Printf (ttidBeDiag,
            "    Ref'd by Components:  %S\n", szBuffer);

        CountRefdBy = pComponent->Refs.CountSoftwareReferencedBy();
        if (CountRefdBy)
        {
            *szBuffer = 0;

            for (i = 0; i < CountRefdBy; i++)
            {
                const CWideString* pRefdBy;
                pRefdBy = pComponent->Refs.PSoftwareReferencedByAtIndex(i);
                Assert (pRefdBy);

                wcscat (szBuffer, pRefdBy->c_str());
                wcscat (szBuffer, L" ");
            }
        }
        else
        {
            wcscpy (szBuffer, L"(none)");
        }
        g_pDiagCtx->Printf (ttidBeDiag,
            "      Ref'd by Software:  %S\n", szBuffer);


    }
    g_pDiagCtx->Printf (ttidBeDiag, "\n");
}

VOID
CmdShowStackTable (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    const CStackEntry*  pStackEntry;

    g_pDiagCtx->Printf (ttidBeDiag, "\n%15s | %s\n"
        "---------------------------------\n",
        "Upper",
        "Lower");

    for (pStackEntry  = pNetConfig->Core.StackTable.begin();
         pStackEntry != pNetConfig->Core.StackTable.end();
         pStackEntry++)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "%15S | %S\n",
            pStackEntry->pUpper->PszGetPnpIdOrInfId(),
            pStackEntry->pLower->PszGetPnpIdOrInfId());
    }

    g_pDiagCtx->Printf (ttidBeDiag, "\n");
    g_pDiagCtx->Printf (ttidBeDiag, "WAN adapters are ordered %s\n\n",
        (pNetConfig->Core.StackTable.m_fWanAdaptersFirst)
            ? "first" : "last");
}

VOID
CmdShowLanAdapterPnpIds (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CComponentList::const_iterator iter;
    const CComponent* pComponent;

    hr = pNetConfig->HrEnsureExternalDataLoadedForAllComponents ();
    if (S_OK != hr)
    {
        return;
    }

    for (iter =  pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!FSubstringMatch (pComponent->Ext.PszUpperRange (), L"ndis5",
                NULL, NULL))
        {
            continue;
        }

        g_pDiagCtx->Printf (ttidBeDiag, "%S\n", pComponent->m_pszPnpId);
    }
}

VOID
CmdEnableOrDisableBinding (
    IN const DIAG_OPTIONS* pOptions,
    IN BOOL fEnable)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgBindingPath* pIPath;

        hr = HrFindBindPath (pINetCfg, pOptions->pszBindPath, &pIPath, NULL);
        if ((S_OK == hr) && pIPath)
        {
            pIPath->Enable (fEnable);

            ReleaseObj (pIPath);
        }

        hr = pINetCfg->Apply ();
        if (S_OK != hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "FAILED to %s binding\n",
                (fEnable) ? "enable" : "disable");
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
}

VOID
CmdMoveBinding (
    IN const DIAG_OPTIONS* pOptions)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgBindingPath* pIPath;
        INetCfgBindingPath* pIOtherPath;
        INetCfgComponentBindings* pIOwner;

        hr = HrFindBindPath (pINetCfg, pOptions->pszBindPath, &pIPath, &pIOwner);
        if ((S_OK == hr) && pIPath)
        {
            if (0 == _wcsicmp(pOptions->pszOtherBindPath, L"null"))
            {
                pIOtherPath = NULL;
            }
            else
            {
                hr = HrFindBindPath (pINetCfg, pOptions->pszOtherBindPath,
                        &pIOtherPath, NULL);
            }

            if (S_OK == hr)
            {
                if (pOptions->fMoveBefore)
                {
                    hr = pIOwner->MoveBefore (pIPath, pIOtherPath);
                }
                else
                {
                    hr = pIOwner->MoveAfter (pIPath, pIOtherPath);
                }

                ReleaseObj (pIOtherPath);
            }

            ReleaseObj (pIPath);
            ReleaseObj (pIOwner);
        }

        hr = pINetCfg->Apply ();
        if (S_OK != hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "FAILED to move binding\n");
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
}

VOID
CmdWriteBindings (
    IN const DIAG_OPTIONS* pOptions OPTIONAL,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CComponentList::const_iterator iter;
    const CComponent* pComponent;
    CRegistryBindingsContext RegBindCtx;

    hr = RegBindCtx.HrPrepare (pNetConfig);
    if (S_OK != hr)
    {
        return;
    }

    for (iter =  pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        hr = RegBindCtx.HrWriteBindingsForComponent (pComponent);
    }
}

VOID
CmdSetWanOrder (
    IN const DIAG_OPTIONS* pOptions)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgSpecialCase* pSpecialCase;

        hr = pINetCfg->GetUnknown()->QueryInterface (
                IID_INetCfgSpecialCase,
                (VOID**)&pSpecialCase);
        Assert (S_OK == hr);

        hr = pSpecialCase->SetWanAdaptersFirst (pOptions->fWanAdaptersFirst);

        ReleaseObj (pSpecialCase);

        hr = pINetCfg->Apply ();
        if (S_OK != hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "FAILED to move binding\n");
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
}

VOID
CmdShowLanaDiag (
    IN const DIAG_OPTIONS* pOptions)
{
    CLanaMap LanaMap;
    HRESULT hr;

    hr = LanaMap.HrLoadLanaMap();

    if (S_OK == hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "NetBios Bindings and Lana Information\n"
                "-------------------------------------\n");
        CWideString str;
        LanaMap.Dump (&str);
        g_pDiagCtx->Printf (ttidBeDiag, "%S", str.c_str());

        HKEY hkeyNetBios;
        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                L"System\\currentcontrolset\\services\\netbios\\parameters",
                KEY_READ, &hkeyNetBios);

        if (S_OK == hr)
        {
            DWORD MaxLana;
            hr = HrRegQueryDword (hkeyNetBios, L"MaxLana", &MaxLana);
            if (S_OK == hr)
            {
                g_pDiagCtx->Printf (ttidBeDiag, "\nMaximum Lana: %d\n", MaxLana);
            }
            RegCloseKey (hkeyNetBios);
        }

        HKEY hkeyRpc;
        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                L"Software\\microsoft\\rpc\\netbios", KEY_READ, &hkeyRpc);

        if (S_OK == hr)
        {
            DWORD Index = 0;
            WCHAR szValueName [_MAX_PATH];
            DWORD cbValueName = _MAX_PATH * sizeof (WCHAR);
            DWORD Lana;
            DWORD cbLana = sizeof (DWORD);
            DWORD Type;

            g_pDiagCtx->Printf (ttidBeDiag, "\nRPC information\n"
                               "---------------\n");
            while (S_OK == HrRegEnumValue (hkeyRpc, Index, szValueName,
                    &cbValueName, &Type, (BYTE*)&Lana, &cbLana))
            {
                if (REG_DWORD == Type)
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "Lana: %3d\tProvider: %S\n", Lana, szValueName);
                }

                cbLana = sizeof (DWORD);
                cbValueName = _MAX_PATH * sizeof (WCHAR);
                Index++;
            }
            RegCloseKey (hkeyRpc);
        }
    }
}

HRESULT
HrPrintComponentDescriptionsFromBindPath (
    IN PCWSTR pszBindPath,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr = S_OK;
    PCWSTR pszBindName;
    PCWSTR pszEnd;
    DWORD cchComponent;
    CComponent* pComponent;
    WCHAR szComponentBindName[_MAX_PATH] = {0};

    Assert (pszBindPath && *pszBindPath);

    GetFirstComponentFromBindPath (pszBindPath, &pszBindName,
            &cchComponent);

    while (pszBindName && *pszBindName)
    {
        wcsncpy (szComponentBindName, pszBindName, cchComponent);

        pComponent = pNetConfig->Core.Components.
                PFindComponentByBindName (NC_INVALID, szComponentBindName);

        if (pComponent)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "-->%S", pComponent->Ext.PszDescription());
        }
#ifdef ENABLETRACE
        else
        {
            g_pDiagCtx->Printf (ttidBeDiag, "%S", szComponentBindName);
        }
#endif // ENABLETRACE

        pszBindName = wcschr (pszBindName, L'_');
        if (pszBindName)
        {
            pszBindName++;
            pszEnd = wcschr (pszBindName, L'_');
            if (pszEnd)
            {
                cchComponent = pszEnd - pszBindName;
            }
            else
            {
                cchComponent = wcslen (pszBindName);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrPrintComponentDescriptionsFromBindPath");
    return hr;
}

VOID
CmdShowLanaPaths (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CLanaMap LanaMap;
    PCWSTR pszBindPath;
    CLanaEntry* pEntry;

    PromptForLeakCheck (pOptions,
        "Show Lana UI info diagnostic...(dump heap)");
    hr = pNetConfig->HrEnsureExternalDataLoadedForAllComponents();
    if (S_OK != hr)
    {
        return;
    }

    hr = LanaMap.HrLoadLanaMap();
    if (S_OK == hr)
    {
        PCWSTR pszBindName;
        PCWSTR pszEnd;
        DWORD cchComponent;
        CComponent* pComponent;
        WCHAR szComponentBindName[_MAX_PATH] = {0};
        for (pEntry = LanaMap.begin(); pEntry != LanaMap.end();
                pEntry++)
        {
            if (1 == pEntry->RegLanaEntry.Exported)
            {
                g_pDiagCtx->Printf (ttidNcDiag, "Lana: %3d\n",
                        pEntry->RegLanaEntry.LanaNumber);

                pszBindPath = pEntry->pszBindPath;
                GetFirstComponentFromBindPath (pszBindPath,
                        &pszBindName, &cchComponent);

                while (pszBindName && *pszBindName)
                {
                    wcsncpy (szComponentBindName, pszBindName, cchComponent);
                    szComponentBindName[cchComponent] = 0;

                    pComponent = pNetConfig->Core.Components.
                            PFindComponentByBindName (NC_INVALID,
                            szComponentBindName);

                    if (pComponent)
                    {
                        g_pDiagCtx->Printf (ttidNcDiag, "-->%S",
                                pComponent->Ext.PszDescription());
                    }
            #ifdef ENABLETRACE
                    else
                    {
                        g_pDiagCtx->Printf (ttidNcDiag, "-->%S", szComponentBindName);
                    }
            #endif // ENABLETRACE

                    pszBindName = wcschr (pszBindName, L'_');
                    if (pszBindName)
                    {
                        pszBindName++;
                        pszEnd = wcschr (pszBindName, L'_');
                        if (pszEnd)
                        {
                            cchComponent = pszEnd - pszBindName;
                        }
                        else
                        {
                            cchComponent = wcslen (pszBindName);
                        }
                    }
                }

                if (FAILED(hr))
                {
                    break;
                }

                g_pDiagCtx->Printf (ttidNcDiag, "\n\n");
            }
        }
    }
    PromptForLeakCheck (pOptions,
        "Show Lana UI info diagnostic...(dump heap and compare)");
}

VOID
CmdSetLanaNumber (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    CLanaMap LanaMap;
    HRESULT hr;

    hr = pNetConfig->HrEnsureExternalDataLoadedForAllComponents();
    if (S_OK != hr)
    {
        return;
    }

    hr = LanaMap.HrLoadLanaMap();

    if (S_OK == hr)
    {
        if (pOptions->OldLanaNumber != pOptions->NewLanaNumber)
        {
            hr = LanaMap.HrSetLanaNumber (pOptions->OldLanaNumber,
                    pOptions->NewLanaNumber);
            if (S_OK == hr)
            {
                hr = LanaMap.HrWriteLanaConfiguration (
                        pNetConfig->Core.Components);

                g_pDiagCtx->Printf (ttidNcDiag, "\nLana changed.\n");
            }
        }
        else
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nNo change.\n");
        }
    }

    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND) == hr)
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nThe old lana number is not currently "
                    "assigned to a bind path.\n");
        }
        else if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nThe new lana number is currently assigned "
                    "to a bind path.\n");
        }
        else
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nError %X occurred\n", hr);
        }
    }
}

VOID
CmdRewriteLanaInfo (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    const CComponent* pComponent;
    CRegistryBindingsContext RegBindCtx;

    hr = RegBindCtx.HrPrepare (pNetConfig);
    if (S_OK == hr)
    {
        pComponent = pNetConfig->Core.Components.
                PFindComponentByInfId (L"MS_NetBios", NULL);

        if (pComponent)
        {
            hr = RegBindCtx.HrWriteBindingsForComponent (pComponent);
        }
        else
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nNetBios is not installed.\n");
        }
    }
}

EXTERN_C
VOID
WINAPI
NetCfgDiagFromCommandArgs (
    IN DIAG_OPTIONS* pOptions)
{
    Assert (pOptions);
    Assert (pOptions->pDiagCtx);
    g_pDiagCtx = pOptions->pDiagCtx;

    CNetConfig NetConfig;
    HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);

    switch (pOptions->Command)
    {
        case CMD_SHOW_BINDINGS:
            CmdShowBindings (pOptions, &NetConfig);
            break;

        case CMD_SHOW_COMPONENTS:
            CmdShowComponents (pOptions, &NetConfig);
            break;

        case CMD_SHOW_STACK_TABLE:
            CmdShowStackTable (pOptions, &NetConfig);
            break;

        case CMD_SHOW_LAN_ADAPTER_PNPIDS:
            CmdShowLanAdapterPnpIds (pOptions, &NetConfig);
            break;

        case CMD_ADD_COMPONENT:
            CmdAddComponent (pOptions, &NetConfig);
            break;

        case CMD_REMOVE_COMPONENT:
            CmdRemoveComponent (pOptions, &NetConfig);
            break;

        case CMD_UPDATE_COMPONENT:
            CmdUpdateComponent (pOptions, &NetConfig);
            break;

        case CMD_REMOVE_REFS:
            CmdRemoveReferences (pOptions, &NetConfig);
            break;

        case CMD_ENABLE_BINDING:
            CmdEnableOrDisableBinding (pOptions, TRUE);
            break;

        case CMD_DISABLE_BINDING:
            CmdEnableOrDisableBinding (pOptions, FALSE);
            break;

        case CMD_MOVE_BINDING:
            CmdMoveBinding (pOptions);
            break;

        case CMD_WRITE_BINDINGS:
            CmdWriteBindings (pOptions, &NetConfig);
            break;

        case CMD_SET_WANORDER:
            CmdSetWanOrder (pOptions);
            break;

        case CMD_FULL_DIAGNOSTIC:
            CNetCfgInternalDiagnostic::CmdFullDiagnostic (pOptions, &NetConfig);
            break;

        case CMD_CLEANUP:
            CmdCleanup (pOptions, &NetConfig);
            break;

        case CMD_ADD_REMOVE_STRESS:
            CmdAddRemoveStress (pOptions, &NetConfig);
            break;
        default:
            break;
    }

    g_pDiagCtx = NULL;
}

EXTERN_C
VOID
WINAPI
NetCfgDiagRepairRegistryBindings (
    IN FILE* pLogFile)
{
    HRESULT hr;
    BOOL fCoUninitialize = TRUE;

    hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
        else
        {
            fprintf(pLogFile, "CoInitializeEx failed.  (hr=0x%08x)\n", hr);
        }
    }

    if (SUCCEEDED(hr))
    {
        CDiagContext DiagCtx;
        CNetConfig NetConfig;

        DiagCtx.SetFlags (DF_REPAIR_REGISTRY_BINDINGS);
        DiagCtx.SetLogFile (pLogFile);
        g_pDiagCtx = &DiagCtx;

        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);
        if (S_OK == hr)
        {
            CmdWriteBindings (NULL, &NetConfig);
        }
        else
        {
            fprintf(pLogFile,
                    "Failed to load network configuration "
                    "from the registry.  (hr=0x%08x)\n", hr);
        }

        g_pDiagCtx = NULL;

        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }
}

EXTERN_C
VOID
WINAPI
LanaCfgFromCommandArgs (
    IN DIAG_OPTIONS* pOptions)
{
    Assert (pOptions);
    Assert (pOptions->pDiagCtx);
    g_pDiagCtx = pOptions->pDiagCtx;

    CNetConfig NetConfig;
    HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);

    switch (pOptions->Command)
    {
        case CMD_SHOW_LANA_DIAG:
            CmdShowLanaDiag (pOptions);
            break;
        case CMD_SHOW_LANA_PATHS:
            CmdShowLanaPaths (pOptions, &NetConfig);
            break;
        case CMD_SET_LANA_NUMBER:
            CmdSetLanaNumber (pOptions, &NetConfig);
            break;
        case CMD_REWRITE_LANA_INFO:
            CmdRewriteLanaInfo (pOptions, &NetConfig);
            break;
        default:
            break;
    }

    g_pDiagCtx = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\dihook.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I H O O K. C P P
//
//  Contents:   Class installer functions called via the device installer.
//
//  Notes:
//
//  Author:     billbe   25 Nov 1996
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "adapter.h"
#include "benchmrk.h"
#include "classinst.h"
#include "compdefs.h"
#include "iatl.h"
#include "isdnhook.h"
#include "ncatl.h"
#include "ncreg.h"
#include "nceh.h"
#include "netsetup.h"
#include "resource.h"
#include "util.h"
#include "netconp.h"

EXTERN_C const CLSID CLSID_InstallQueue;

const DWORD c_cmsWaitForINetCfgWrite   = 2000;

inline
BOOL
FIsValidErrorFromINetCfgForDiHook (
    IN HRESULT hr)
{
    return (NETCFG_E_NO_WRITE_LOCK == hr) ||
            (NETCFG_E_NEED_REBOOT == hr);
}

inline
BOOL
FIsHandledByClassInstaller(
    IN const GUID& guidClass)
{
    return FIsEnumerated(guidClass) ||
            (GUID_DEVCLASS_NETTRANS == guidClass) ||
            (GUID_DEVCLASS_NETCLIENT == guidClass) ||
            (GUID_DEVCLASS_NETSERVICE == guidClass);
}

//+--------------------------------------------------------------------------
//
//  Function:   HrDiAddComponentToINetCfg
//
//  Purpose:    This function adds or updates a device In InetCfg.
//
//  Arguments:
//      pinc              [in] INetCfg interface
//      pinci             [in] INetCfgInstaller interface
//      guidClass         [in] The class guid of the component
//      pszwPnpid         [in] The pnp instance id of the device
//      eType             [in] The install type (NCI_INSTALL or NCI_UPDATE)
//      pszInstanceGuid   [in] The netcfg instance guid of the component
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   29 Jul 1997
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrDiAddComponentToINetCfg(
    IN INetCfg* pINetCfg,
    IN INetCfgInternalSetup* pInternalSetup,
    IN const NIQ_INFO* pInfo)
{
    Assert (pINetCfg);
    Assert (pInternalSetup);
    Assert (pInfo);

    Assert (pInfo->pszPnpId && *(pInfo->pszPnpId));
    Assert (NCI_REMOVE != pInfo->eType);

    HRESULT hr = S_OK;
    NC_TRY
    {
        CComponent* pComponent;
        BASIC_COMPONENT_DATA Data;
        ZeroMemory (&Data, sizeof(Data));

        Data.InstanceGuid = pInfo->InstanceGuid;
        Data.Class = NetClassEnumFromGuid (pInfo->ClassGuid);
        Data.pszPnpId = pInfo->pszPnpId;
        Data.pszInfId = pInfo->pszInfId;
        Data.dwCharacter = pInfo->dwCharacter;
        Data.dwDeipFlags = pInfo->dwDeipFlags;

        hr = CComponent::HrCreateInstance (
                &Data,
                CCI_ENSURE_EXTERNAL_DATA_LOADED,
                NULL,
                &pComponent);

        if (S_OK == hr)
        {
            hr = pInternalSetup->EnumeratedComponentInstalled (pComponent);

        }
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }

    TraceHr (ttidError, FAL, hr, NETCFG_S_REBOOT == hr,
            "HrDiAddComponentToINetCfg");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrDiNotifyINetCfgOfInstallation
//
//  Purpose:    This function notifies INetCfg that a net class component
//                  has been installed or updated.
//
//  Arguments:
//      hdi             [in] See Device Installer Api for more info
//      pdeid           [in] See Device Installer Api for more info
//      pszwPnpid       [in] The pnp instance id of the device
//      pszInstanceGuid [in] The netcfg instance guid of the device
//      eType           [in] NCI_INSTALL if the component was installed
//                           NCI_UPDATE, if it was updated
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   29 Jul 1997
//
//  Notes:
//
HRESULT
HrDiNotifyINetCfgOfInstallation (
    IN const NIQ_INFO* pInfo)
{
    Assert(pInfo);
    Assert((NCI_INSTALL == pInfo->eType) || (NCI_UPDATE == pInfo->eType));

    static const WCHAR c_szInstaller[] = L"INetCfg Installer Interface";
    INetCfg*    pinc;
    BOOL        fInitCom = TRUE;
    BOOL        fReboot = FALSE;

#ifdef ENABLETRACE
    CBenchmark bmrk2;
    bmrk2.Start ("Notifying INetCfg of installation");
#endif //ENABLETRACE

    TraceTag(ttidClassInst, "Attempting to notify INetCfg.");

    HRESULT hr = HrCreateAndInitializeINetCfg(&fInitCom, &pinc, TRUE,
                                              c_cmsWaitForINetCfgWrite,
                                              c_szInstaller, NULL);
    if (S_OK == hr)
    {
        // Get the INetCfgInternalSetup interface.
        INetCfgInternalSetup* pInternalSetup;
        hr = pinc->QueryInterface (IID_INetCfgInternalSetup,
                (VOID**)&pInternalSetup);

        if (S_OK == hr)
        {
            if (NCI_INSTALL == pInfo->eType)
            {
                hr = HrDiAddComponentToINetCfg(pinc, pInternalSetup, pInfo);
            }
            else // NCI_UPDATE
            {
                hr = pInternalSetup->EnumeratedComponentUpdated (
                        pInfo->pszPnpId);
            }

            if (NETCFG_S_REBOOT == hr)
            {
                fReboot = TRUE;
                hr = S_OK;
            }

            ReleaseObj(pInternalSetup);
        }

        // Whether we succeeded or not, we are done and it's
        // time to clean up.  If there was a previous error
        // we want to preserve that error code so we assign
        // Uninitialize's result to a temporary then assign
        // it to hr if there was no previous error.
        //
        HRESULT hrT = HrUninitializeAndReleaseINetCfg (fInitCom, pinc, TRUE);
        hr = (S_OK == hr) ? hrT : hr;
    }

    if ((S_OK == hr) && fReboot)
    {
        TraceTag(ttidClassInst, "INetCfg returned NETCFG_S_REBOOT");
        hr = NETCFG_S_REBOOT;
    }

#ifdef ENABLETRACE
    bmrk2.Stop();
    TraceTag(ttidBenchmark, "%s : %s seconds",
            bmrk2.SznDescription(), bmrk2.SznBenchmarkSeconds(2));
#endif //ENABLETRACE

    TraceHr (ttidError, FAL, hr,
            NETCFG_S_REBOOT == hr || FIsValidErrorFromINetCfgForDiHook (hr),
             "HrDiNotifyINetCfgOfInstallation");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InsertItemIntoInstallQueue
//
//  Purpose:    This function uses the InstallQueue object to insert a
//              workitem to be processed at a later time.  The workitem:
//              a device that was installed, removed, or updated and
//              INetCfg needs to be notified.
//
//  Arguments:
//      pguid        [in] The class guid of the device
//      pszwDeviceId [in] The Id of the device (PnP instance Id if the device
//                        was added or updated, its netcfg instance guid if
//                        it was removed
//
//  Returns:    hresult. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
HRESULT
HrInsertItemIntoInstallQueue (
    IN const NIQ_INFO* pInfo)
{
    // Initialize COM
    BOOL    fInitCom = TRUE;
    HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED |
            COINIT_DISABLE_OLE1DDE);

    // We may have changed mode but that's okay
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr))
    {
        // Create the Install Queue object and get the
        // INetInstallQueue interface
        //
        INetInstallQueue* pniq;
        hr = HrCreateInstance(
            CLSID_InstallQueue,
            CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &pniq);

        TraceHr (ttidError, FAL, hr, FALSE, "HrCreateInstance");

        if (S_OK == hr)
        {

            TraceTag (ttidClassInst, "Adding item %S to queue.",
                    pInfo->pszPnpId);

            // Add the device info and the install type to the queue
            hr = pniq->AddItem (pInfo);
            pniq->Release();
        }

        if (fInitCom)
        {
            CoUninitialize();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "InsertItemIntoInstallQueue");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrDiInstallNetAdapter
//
//  Purpose:    This function preinstalls the NetAdapter, notifies the
//                  COM interfaces through CINetCfgClass that the
//                  component was added. Then it finalizes the install
//                  by applying all changes to INetCfg.
//  Arguments:
//      hdi        [in] See Device Installer Api for more info
//      pdeid      [in] See Device Installer Api for more info
//      hwndParent [in] The handle to the parent window, used for UI
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   24 Apr 1997
//
//  Notes:
//
HRESULT
HrDiInstallNetAdapter(
    IN COMPONENT_INSTALL_INFO* pcii)
{
    HRESULT                 hr = S_OK;
    ADAPTER_OUT_PARAMS*     pAdapterOutParams = NULL;
    SP_DEVINSTALL_PARAMS    deip;
    BOOL                    fNotifyINetCfg = TRUE;

    // If we were called from INetCfg, we have to store the results of the
    // install in the out params structure placed in the reserved field.
    //
    (VOID) HrSetupDiGetDeviceInstallParams (pcii->hdi, pcii->pdeid, &deip);
    if (deip.ClassInstallReserved)
    {
        pAdapterOutParams = (ADAPTER_OUT_PARAMS*)deip.ClassInstallReserved;
        fNotifyINetCfg = FALSE;
    }

    PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
    SP_DRVINFO_DATA drid;

    hr = HrCiGetDriverDetail (pcii->hdi, pcii->pdeid, &drid, &pdridd);
    if (S_OK == hr)
    {
        pcii->pszInfFile = pdridd->InfFileName;
        pcii->pszSectionName = pdridd->SectionName;
        pcii->pszInfId = pdridd->HardwareID;
        pcii->pszDescription = drid.Description;
    }
    else if (SPAPI_E_NO_DRIVER_SELECTED == hr)
    {
        // If we are in GUI mode and the device was previously installed,
        // then this device should be removed since its inf file could not
        // be found.
        //
        if (FInSystemSetup() &&
                (S_OK == HrCiIsInstalledComponent (pcii, NULL)))
        {
            // This dev node was is being reinstalled but has no driver
            // info.  In this case, we are going to remove the devnode.

            TraceTag (ttidClassInst, "We are in GUI mode and were told to "
                     "install a device that has no driver.  We will remove "
                     "device instead.");
            // We need to set the reserved field in the pdeid so that the
            // remove code will know that this is a bad instance that
            // should be removed regardless of the NCF_NOT_USER_REMOVABLE
            // characteristic.
            //
            ADAPTER_REMOVE_PARAMS arp;
            arp.fBadDevInst = TRUE;
            arp.fNotifyINetCfg = fNotifyINetCfg;
            CiSetReservedField (pcii->hdi, pcii->pdeid, &arp);

            (VOID) HrSetupDiCallClassInstaller (DIF_REMOVE,
                    pcii->hdi, pcii->pdeid);

            CiClearReservedField (pcii->hdi, pcii->pdeid);
        }
    }

    if (S_OK == hr)
    {
        TraceTag (ttidClassInst, "Calling HrCiInstallComponentInternal");

#ifdef ENABLETRACE
        CBenchmark bmrk1;
        bmrk1.Start ("HrCiInstallComponentInternal");
#endif //ENABLETRACE

        // Install (or reinstall) the component
        hr = HrCiInstallComponentInternal (pcii);

#ifdef ENABLETRACE
        bmrk1.Stop();
        TraceTag (ttidBenchmark, "%s : %s seconds",
                bmrk1.SznDescription(), bmrk1.SznBenchmarkSeconds (2));
#endif //ENABLETRACE

        // if we have succeeded so far and we have to notify INetcfg.
        // We also have to update the NT4 legacy registry for adapters.
        // Note that this is not done for filter devices.
        if (S_OK == hr)
        {
            if (fNotifyINetCfg && !FIsFilterDevice (pcii->hdi, pcii->pdeid))
            {
                NIQ_INFO Info;
                ZeroMemory(&Info, sizeof (Info));

                Info.eType = pcii->fPreviouslyInstalled ?
                                    NCI_UPDATE : NCI_INSTALL;
                Info.ClassGuid      = pcii->pdeid->ClassGuid;
                Info.InstanceGuid   = pcii->InstanceGuid;
                Info.dwCharacter    = pcii->dwCharacter;
                Info.dwDeipFlags    = deip.Flags;
                Info.pszInfId       = pcii->pszInfId;
                Info.pszPnpId       = pcii->pszPnpId;

                hr = HrDiNotifyINetCfgOfInstallation (&Info);

                if (FIsValidErrorFromINetCfgForDiHook (hr))
                {
                    WCHAR szGuid[c_cchGuidWithTerm];
                    INT  cch = StringFromGUID2 (pcii->InstanceGuid, szGuid,
                            c_cchGuidWithTerm);

                    Assert (c_cchGuidWithTerm == cch);

                    // use queue
                    hr = HrInsertItemIntoInstallQueue (&Info);
                }
                else if (NETCFG_S_REBOOT == hr)
                {
                    (VOID) HrSetupDiSetDeipFlags (pcii->hdi, pcii->pdeid,
                            DI_NEEDREBOOT, SDDFT_FLAGS, SDFBO_OR);
                    hr = S_OK;
                }
            }
            else // !fNotifyINetCfg or is a filter device.
            {
                // Since we installed this enumerated device from INetCfg
                // we need to set the out params so they can be retrieved
                // when DIF_INSTALLDEVICE has finished.
                //
                if (pAdapterOutParams)
                {
                    Assert (!pcii->fPreviouslyInstalled);
                    pAdapterOutParams->dwCharacter = pcii->dwCharacter;
                    pAdapterOutParams->InstanceGuid = pcii->InstanceGuid;
                }
            }

            // Write out the NT4 legacy registry info for app. compatibility.
            // Note, we only do this for physical net devices.
            if ((NCF_PHYSICAL & pcii->dwCharacter) &&
                    (GUID_DEVCLASS_NET == pcii->pdeid->ClassGuid))
            {
                AddOrRemoveLegacyNt4AdapterKey (pcii->hdi, pcii->pdeid,
                        &pcii->InstanceGuid, pcii->pszDescription,
                        LEGACY_NT4_KEY_ADD);
            }
        }

        MemFree (pdridd);
    }

    // All success codes should be mapped to S_OK since they have no meaning
    // along this code path.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrDiInstallNetAdapter");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrDiNotifyINetCfgOfRemoval
//
//  Purpose:    This function notifies INetCfg that a net class component has
//                  been removed
//
//  Arguments:
//      hdi            [in]  See Device Installer api for more info
//      pdeid          [in]
//      szInstanceGuid [in] The instance guid of the component
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   29 Jul 1997
//
//  Notes:
//
HRESULT
HrDiNotifyINetCfgOfRemoval (
    IN PCWSTR pszPnpId)
{
    static const WCHAR c_szUninstaller[] = L"INetCfg UnInstaller Interface";
    INetCfg* pINetCfg;
    BOOL fInitCom = TRUE;
    HRESULT hr = HrCreateAndInitializeINetCfg(&fInitCom, &pINetCfg, TRUE,
            c_cmsWaitForINetCfgWrite, c_szUninstaller, NULL);

    if (SUCCEEDED(hr))
    {
        BOOL fNeedReboot = FALSE;

        // Get the INetCfgInternalSetup interface.
        INetCfgInternalSetup* pInternalSetup;
        hr = pINetCfg->QueryInterface (IID_INetCfgInternalSetup,
                (VOID**)&pInternalSetup);

        if (SUCCEEDED(hr))
        {
            hr = pInternalSetup->EnumeratedComponentRemoved (pszPnpId);

            if (NETCFG_S_REBOOT == hr)
            {
                fNeedReboot = TRUE;
            }
        }

        // Whether we succeeded or not, we are done and it's
        // time to clean up.  If there was a previous error
        // we want to preserve that error code so we assign
        // Uninitialize's result to a temporary then assign
        // it to hr if there was no previous error.
        //
        HRESULT hrT = HrUninitializeAndReleaseINetCfg (TRUE, pINetCfg, TRUE);

        // If everything was successful then set the return value to be
        // the return of HrUninitializeAndReleaseINetCfg
        hr = SUCCEEDED(hr) ? hrT : hr;

        if (SUCCEEDED(hr) && fNeedReboot)
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    TraceHr (ttidError, FAL, hr,
            NETCFG_S_REBOOT == hr || FIsValidErrorFromINetCfgForDiHook (hr),
             "HrNcNotifyINetCfgOfRemoval");
    return hr;
}


VOID
StoreInfoForINetCfg (
    IN HKEY hkeyInstance)
{
    HKEY hkeyInterfaceStore = NULL;
    HKEY hkeyNdiStore = NULL;
    WCHAR szGuid[c_cchGuidWithTerm];
    DWORD cbGuid = sizeof (szGuid);
    WCHAR szNdiPath[_MAX_PATH];

    HRESULT hr = HrRegQuerySzBuffer (hkeyInstance, L"NetCfgInstanceId", szGuid,
            &cbGuid);

    if (S_OK == hr)
    {
        wcscpy (szNdiPath,
                c_szTempNetcfgStorageForUninstalledEnumeratedComponent);
        wcscat (szNdiPath, szGuid);
        wcscat (szNdiPath, L"\\Ndi");

        hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE, szNdiPath,
                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                &hkeyNdiStore, NULL);
        if (S_OK == hr)
        {
            hr = HrRegCreateKeyEx (hkeyNdiStore, L"Interfaces",
                    REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hkeyInterfaceStore, NULL);
        }
    }

    if (S_OK == hr)
    {
        HKEY hkeyNdi;
        hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

        if (S_OK == hr)
        {
            PWSTR pszRequiredList;
            hr = HrRegQuerySzWithAlloc (hkeyNdi, L"RequiredAll",
                    &pszRequiredList);

            if (S_OK == hr)
            {
                hr = HrRegSetSz (hkeyNdiStore, L"RequiredAll",
                        pszRequiredList);
                MemFree (pszRequiredList);
            }

            if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }

            TraceHr (ttidError, FAL, hr, FALSE, "Writing RequiredAll key "
                     "for INetCfg removal notify");
            RegCloseKey (hkeyNdi);
        }

        HKEY hkeyInterfaces;
        hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi\\Interfaces", KEY_READ,
                &hkeyInterfaces);

        if (S_OK == hr)
        {
            PWSTR pszUpper;
            PWSTR pszLower;
            hr = HrRegQuerySzWithAlloc (hkeyInterfaces, L"UpperRange",
                    &pszUpper);

            if (S_OK == hr)
            {
                (VOID) HrRegSetSz (hkeyInterfaceStore, L"UpperRange",
                        pszUpper);
                MemFree ((VOID*) pszUpper);
            }

            hr = HrRegQuerySzWithAlloc (hkeyInterfaces, L"LowerRange",
                    &pszLower);

            if (S_OK == hr)
            {
                (VOID) HrRegSetSz (hkeyInterfaceStore, L"LowerRange",
                        pszLower);
                MemFree ((VOID*) pszLower);
            }

            RegCloseKey (hkeyInterfaces);
        }
    }
    RegSafeCloseKey (hkeyInterfaceStore);
    RegSafeCloseKey (hkeyNdiStore);
}

//+--------------------------------------------------------------------------
//
//  Function:   HrDiRemoveNetAdapter
//
//  Purpose:    This function removes a net adapter, notifies the
//                  COM interfaces through CINetCfgClass that the
//                  component was removed. Then it finalizes the remove
//                  by applying all changes to INetCfg.
//  Arguments:
//      hdi             [in] See Device Installer Api for more info
//      pdeid           [in] See Device Installer Api for more info
//      pszPnPId        [in] The pnp instance id of the adapter
//      hwndParent      [in] The handle to the parent window, used for UI
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   24 Apr 1997
//
//  Notes:
//
HRESULT
HrDiRemoveNetAdapter (HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                     PWSTR pszPnpId, HWND hwndParent)
{
    BOOL                    fAllowRemove = TRUE;

    SP_DEVINSTALL_PARAMS    deip;
    BOOL                    fNotifyINetCfg = TRUE;
    BOOL                    fBadDevInst = FALSE;
    HRESULT                 hr = S_OK;

    // Check for the existence of a CComponentInfo and retrieve the
    // value of the write lock flag
    //
    (VOID) HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);
    if (deip.ClassInstallReserved)
    {
        ADAPTER_REMOVE_PARAMS* parp = reinterpret_cast<ADAPTER_REMOVE_PARAMS*>
                (deip.ClassInstallReserved);

        fNotifyINetCfg = parp->fNotifyINetCfg;

        fBadDevInst = parp->fBadDevInst;
    }

    if (fNotifyINetCfg)
    {
        // The component is not being removed programmatically (we can tell
        // this because we wouldn't have to notify INetCfg if it was
        // being removed through INetCfg).  Because of this. we have to
        // make sure the user is allowed to do this by checking the
        // component's characteristics
        //
        HKEY hkey;
        hr = HrSetupDiOpenDevRegKey (hdi, pdeid, DICS_FLAG_GLOBAL, 0,
                DIREG_DRV, KEY_READ, &hkey);

        if (S_OK == hr)
        {
            // If we are removing a bad device instance, don't bother
            // checking if we are allowed to.  We need to get rid of it.
            //
            if (!fBadDevInst)
            {
                DWORD dwCharacter;

                hr = HrRegQueryDword (hkey, L"Characteristics", &dwCharacter);

                if (S_OK == hr)
                {
                    // Is the not removable characteristic present?
                    fAllowRemove = !(dwCharacter & NCF_NOT_USER_REMOVABLE);
                }
            }

            if (fAllowRemove)
            {
                StoreInfoForINetCfg (hkey);

                // We need to remove this adapter from the old NT4 registry
                // location.
                //
                if (GUID_DEVCLASS_NET == pdeid->ClassGuid)

                {
                    AddOrRemoveLegacyNt4AdapterKey (hdi, pdeid, NULL, NULL,
                            LEGACY_NT4_KEY_REMOVE);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (ERROR_ACCESS_DENIED);
                TraceTag (ttidClassInst, "User is trying to remove a "
                         "non user-removable device.");
            }
            RegCloseKey (hkey);
        }
        else if (SPAPI_E_KEY_DOES_NOT_EXIST == hr)
        {
            hr = S_OK;
        }
    }

    if ((S_OK == hr) && fAllowRemove)
    {
        // Remove the device
        //

        // Open the device's device parameters key
        //
        HKEY hkeyDevice;
        hr = HrSetupDiOpenDevRegKey (hdi, pdeid, DICS_FLAG_GLOBAL,
                0, DIREG_DEV, KEY_READ, &hkeyDevice);

        if (S_OK == hr)
        {
            // Delete this adapter's index number from the in-use list
            // so it can be reused.
            //

            // First retrieve the index
            //
            DWORD dwInstanceIndex;
            hr = HrRegQueryDword (hkeyDevice, L"InstanceIndex",
                    &dwInstanceIndex);

            if (S_OK == hr)
            {
                // Get the description for the adapter so we can
                // access the index list of that description
                //

                PWSTR pszDescription;
                hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc (hdi, pdeid,
                        SPDRP_DEVICEDESC, NULL,
                        (BYTE**)&pszDescription);

                if (S_OK == hr)
                {
                    // Delete the index
                    (VOID) HrCiUpdateDescriptionIndexList (
                            NetClassEnumFromGuid(pdeid->ClassGuid),
                            pszDescription, DM_DELETE,
                            &dwInstanceIndex);

                    MemFree (pszDescription);
                }
            }
            RegCloseKey (hkeyDevice);
        }

        // Note: Yes we can walk over the last hr result.
        // We can still go on even if we failed to remove the index
        // from the in-use list.

        // remove the adapter
#ifdef ENABLETRACE
        CBenchmark bmrk;
        bmrk.Start ("SetupDiRemoveDevice");
#endif //ENABLETRACE

        hr = HrSetupDiRemoveDevice (hdi, pdeid);

#ifdef ENABLETRACE
        bmrk.Stop();
        TraceTag(ttidBenchmark, "%s : %s seconds",
                bmrk.SznDescription(), bmrk.SznBenchmarkSeconds(2));
#endif //ENABLETRACE

        TraceHr (ttidError, FAL, hr, FALSE,
                "HrRemoveNetAdapter::HrSetupDiRemoveDevice");

        // Notify INetCfg if needed.
        if ((S_OK == hr) && fNotifyINetCfg)
        {
            hr = HrDiNotifyINetCfgOfRemoval (pszPnpId);
            if (FIsValidErrorFromINetCfgForDiHook (hr))
            {
                NIQ_INFO Info;
                ZeroMemory(&Info, sizeof(Info));
                Info.ClassGuid = pdeid->ClassGuid;
                Info.eType = NCI_REMOVE;
                Info.pszInfId = L"";
                Info.pszPnpId = pszPnpId;

                // Use Queue
                hr = HrInsertItemIntoInstallQueue (&Info);
            }

            if (NETCFG_S_REBOOT == hr)
            {
                (VOID) HrSetupDiSetDeipFlags (hdi, pdeid, DI_NEEDREBOOT,
                        SDDFT_FLAGS, SDFBO_OR);
                hr = S_OK;
            }
        }
    }

    if(SUCCEEDED(hr) && GUID_DEVCLASS_NET == pdeid->ClassGuid)
    {
        INetConnectionRefresh * pRefresh = NULL;
        HRESULT hrTemp = HrCreateInstance(
            CLSID_ConnectionManager,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &pRefresh);
        if(SUCCEEDED(hrTemp))
        {
            hrTemp = pRefresh->RefreshAll();
            ReleaseObj(pRefresh);
        }

    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrDiRemoveNetAdapter");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrNetClassInstaller
//
//  Purpose:    This function is called by the Device Installer for a
//                  variety of functions defined by dif.
//                  See SetupDiCallClassInstaller in the Device Installer
//                  documentation for more information.
//  Arguments:
//      dif   [in] See Device Installer Api
//      hdi   [in]
//      pdeid [in]
//
//  Returns:    DWORD. Win32/Device Installer error code
//
//  Author:     billbe   8 May 1997
//
//  Notes:
//
HRESULT _HrNetClassInstaller(DI_FUNCTION dif,
                            HDEVINFO hdi,
                            PSP_DEVINFO_DATA pdeid)
{
    HRESULT hr = SPAPI_E_DI_DO_DEFAULT;

    // The time it takes to remove a device.
    static const DWORD c_cmsNetComponentRemove = 30000;

    if ((DIF_INSTALLDEVICE == dif) || (DIF_REMOVE == dif))
    {
        WCHAR szPnpId[MAX_DEVICE_ID_LEN] = {0};
        hr = HrSetupDiGetDeviceInstanceId(hdi, pdeid, szPnpId,
                MAX_DEVICE_ID_LEN, NULL);

        if (S_OK == hr)
        {

#ifdef DBG
            if (FIsDebugFlagSet (dfidBreakOnNetInstall))
            {
                AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
                         "\"BreakOnNetInstall\" has been set. Set your breakpoints now.");
            }
#endif // DBG
            HWND hwndParent = NULL;

            // If this call fails we don't really care since it is a convenience.
            (VOID) HrSetupDiGetParentWindow (hdi, pdeid, &hwndParent);

#ifdef ENABLETRACE
            CBenchmark bmrk;
            const int c_cchBenchmarkDesc = 156;
            CHAR szBenchmarkDesc[c_cchBenchmarkDesc];
#endif // ENABLETRACE

            if (DIF_INSTALLDEVICE == dif)
            {
                COMPONENT_INSTALL_INFO cii;
                ZeroMemory(&cii, sizeof(cii));

                cii.hwndParent   = hwndParent;
                cii.hdi          = hdi;
                cii.pdeid        = pdeid;
                cii.Class        = NetClassEnumFromGuid (pdeid->ClassGuid);
                cii.BusType      = InterfaceTypeUndefined;
                cii.InstanceGuid = GUID_NULL;
                cii.pszPnpId     = szPnpId;

#ifdef ENABLETRACE
                TraceTag (ttidClassInst, "Installing %S", szPnpId);
                _snprintf (szBenchmarkDesc, c_cchBenchmarkDesc,
                        "Installing %S", szPnpId);
                bmrk.Start (szBenchmarkDesc);
#endif // ENABLETRACE

                // Add the adapter to the network configuration.
                hr = HrDiInstallNetAdapter (&cii);

            }
            else // DIF_REMOVEDEVICE
            {
#ifdef ENABLETRACE
                TraceTag (ttidClassInst, "Removing %S", szPnpId);
                _snprintf (szBenchmarkDesc, c_cchBenchmarkDesc,
                        "Total Time Removing %S", szPnpId);
#endif //ENABLETRACE

                // We need to reset the hresult from SPAPI_E_DO_DEFAULT to S_OK
                // since we check for success a bit later.
                hr = S_OK;

                // Check to see it another net class installer thread is
                // currently deleting this component.
                //

                // The event name will be the adapter instance Id with slashes
                // converted to ampersands.  If we can't get the instance
                // id, we will attempt to remove the adapter without it
                //

                // convert the slashes in the instance id to ampersands
                //
                WCHAR szEventName[MAX_DEVICE_ID_LEN];
                wcscpy (szEventName, szPnpId);
                for (UINT i = 0; i < wcslen (szEventName); ++i)
                {
                    if ('\\' == szEventName[i])
                    {
                        szEventName[i] = L'&';
                    }
                }

                // create the event in the non-signaled state
                BOOL fAlreadyExists;
                HANDLE hRemoveEvent = NULL;
                hr = HrCreateEventWithWorldAccess (szEventName, FALSE, FALSE,
                        &fAlreadyExists, &hRemoveEvent);

                if ((S_OK == hr) && fAlreadyExists)
                {
                    // another instance of netclassinstaller is deleting this
                    // component, so wait till it is finished.  If the following
                    // times out, we still return success.  We are only waiting to
                    // give the other NetClassInstaller time to finish the state
                    // of this component
                    DWORD dwRet = WaitForSingleObject (hRemoveEvent,
                            c_cmsNetComponentRemove);

                    // if the other installer finished okay, we have the event
                    // so we signal (in case yet another process is waiting
                    // for the remove to finish) and close the handle.
                    // If we timeout, we just close the handle
                    if (WAIT_ABANDONED != dwRet)
                    {
                        if (WAIT_OBJECT_0 == dwRet)
                        {
                            SetEvent (hRemoveEvent);
                        }
                        CloseHandle (hRemoveEvent);
                        return S_OK;
                    }

                    // The event was abandoned so let's try to finish the job
                    //
                }
                else if (!hRemoveEvent)
                {
                    hr = HrFromLastWin32Error ();
                }

                if (S_OK == hr)
                {
                    // We created an event so we must make sure to remove it
                    // even if there is an exception.
                    //
                    NC_TRY
                    {

#ifdef ENABLETRACE
                        bmrk.Start (szBenchmarkDesc);
#endif // ENABLETRACE

                        hr = HrDiRemoveNetAdapter (hdi, pdeid, szPnpId,
                                hwndParent);
                    }
                    NC_CATCH_ALL
                    {
                        hr = E_UNEXPECTED;
                    }

                    // We are done.  If we created an event, we need to
                    // signal it and close our handle.
                    if (hRemoveEvent)
                    {
                        SetEvent (hRemoveEvent);
                        CloseHandle (hRemoveEvent);
                    }
                }
            }

#ifdef ENABLETRACE
            if (S_OK == hr)
            {
                bmrk.Stop ();
                TraceTag (ttidBenchmark, "%s : %s seconds",
                        bmrk.SznDescription (), bmrk.SznBenchmarkSeconds (2));
            }
#endif // ENABLETRACE
        }
    }
    else if (DIF_DESTROYPRIVATEDATA == dif)
    {
        SP_DEVINSTALL_PARAMS deip;
        hr = HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
        MemFree ((VOID*)deip.ClassInstallReserved);

    }
    else if (DIF_REGISTERDEVICE == dif)
    {
        // We handle 5 classes of components but we only
        // want to allow registration for two of them
        // (The ones considered NetClassComponents)
        Assert(pdeid);
        if (pdeid)
        {
            if (FIsHandledByClassInstaller(pdeid->ClassGuid))
            {
                if (!FIsEnumerated(pdeid->ClassGuid))
                {
                    // Don't let the device installer register
                    // devices that are not considered net class
                    hr = S_OK;
                }
            }
        }
    }
    else if (DIF_SELECTDEVICE == dif)
    {
        // This will set the proper description strings in the select device
        // dialog.  If it fails, we can still show the dialog
        (VOID) HrCiPrepareSelectDeviceDialog(hdi, pdeid);
    }
    else if (DIF_NEWDEVICEWIZARD_FINISHINSTALL == dif)
    {
        hr = HrAddIsdnWizardPagesIfAppropriate(hdi, pdeid);
    }
    else if (DIF_ALLOW_INSTALL == dif)
    {
        // Get the selected driver for this device
        //
        SP_DRVINFO_DATA             drid;
        hr = HrSetupDiGetSelectedDriver(hdi, pdeid, &drid);

        if (S_OK == hr)
        {
            // Now get the driver's detailed information
            //
            PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
            hr  = HrSetupDiGetDriverInfoDetail(hdi, pdeid,
                &drid, &pdridd);

            if (S_OK == hr)
            {
                // Open the component's inf file
                //
                HINF hinf = NULL;
                hr = HrSetupOpenInfFile(pdridd->InfFileName, NULL,
                        INF_STYLE_WIN4, NULL, &hinf);

                if (S_OK == hr)
                {
                    // Make sure this is an NT5 inf network inf
                    //
                    hr = HrSetupIsValidNt5Inf(hinf);
                    SetupCloseInfFile(hinf);

                    if (S_OK == hr)
                    {
                        hr = SPAPI_E_DI_DO_DEFAULT;
                    }

                }
                MemFree (pdridd);
            }
        }
    }
    else if (DIF_POWERMESSAGEWAKE == dif)
    {
        SP_POWERMESSAGEWAKE_PARAMS_W wakeParams;

        // Get the power message wake params.
        //
        hr = HrSetupDiGetFixedSizeClassInstallParams(hdi, pdeid,
               (PSP_CLASSINSTALL_HEADER)&wakeParams, sizeof(wakeParams));

        if (S_OK == hr)
        {
            Assert (DIF_POWERMESSAGEWAKE ==
                    wakeParams.ClassInstallHeader.InstallFunction);

            // Copy in our string for the power tab.
            wcscpy (wakeParams.PowerMessageWake, SzLoadIds(IDS_POWER_MESSAGE_WAKE));

            // Now we update the parameters.
            hr = HrSetupDiSetClassInstallParams (hdi, pdeid,
                    (PSP_CLASSINSTALL_HEADER)&wakeParams,
                    sizeof(SP_POWERMESSAGEWAKE_PARAMS_W));

            // If we failed to set the text just allow the device installer
            // to do the default.
            if (FAILED(hr))
            {
                hr = SPAPI_E_DI_DO_DEFAULT;
            }
        }
    }

    TraceHr (ttidClassInst, FAL, hr, (SPAPI_E_DI_DO_DEFAULT == hr) ||
            (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr),
             "HrNetClassInstaller");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\comprefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P R E F S . H
//
//  Contents:   Implements the interface to a component's references.  A
//              component can be referenced (installed by) other components,
//              the user, or other software.  This module manages the
//              interface to that data.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "complist.h"
#include "ncstring.h"
#include "netcfgx.h"


struct COMPONENT_REFERENCE_DATA
{
    CComponentList      RefByComponents;
    vector<CWideString> RefBySoftware;
    BOOLEAN             fRefByUser;
};

class CComponentReferences
{
private:
    COMPONENT_REFERENCE_DATA*   m_pData;

private:
    HRESULT
    HrEnsureAllocated ();

public:
    ~CComponentReferences ();

    ULONG
    CountComponentsReferencedBy () const;

    ULONG
    CountSoftwareReferencedBy () const;

    ULONG
    CountTotalReferencedBy () const;

    BOOL
    FIsReferencedByComponent (
        IN const CComponent* pComponent) const;

    BOOL
    FIsReferencedByOboToken (
        IN const OBO_TOKEN* pOboToken) const;

    BOOL
    FIsReferencedByOthers () const;

    BOOL
    FIsReferencedByUser () const
    {
        return (m_pData && m_pData->fRefByUser);
    }

    VOID
    GetReferenceDescriptionsAsMultiSz (
        IN BYTE* pbBuf OPTIONAL,
        OUT ULONG* pcbBuf) const;

    CComponent*
    PComponentReferencedByAtIndex (
        IN UINT unIndex) const;

    const CWideString*
    PSoftwareReferencedByAtIndex (
        IN UINT unIndex) const;

    HRESULT
    HrAddReferenceByUser ();

    HRESULT
    HrAddReferenceByComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrAddReferenceByOboToken (
        IN const OBO_TOKEN* pOboToken);

    HRESULT
    HrAddReferenceBySoftware (
        IN PCWSTR pszKey);

    HRESULT
    HrRemoveReferenceByOboToken (
        IN const OBO_TOKEN* pOboToken);

    VOID
    RemoveAllReferences();

    VOID
    RemoveReferenceByComponent (
        IN const CComponent* pComponent)
    {
        AssertH (pComponent);
        AssertH (m_pData);
        m_pData->RefByComponents.RemoveComponent(pComponent);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ecomp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       E C O M P . C P P
//
//  Contents:   Implements the interface to a component's external data.
//              External data is that data controlled (or placed) by
//              PnP or the network class installer.  Everything under a
//              component's instance key is considered external data.
//              (Internal data is that data we store in the persisted binary
//              for the network configuration.  See persist.cpp for
//              code that deals with internal data.)
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "comp.h"
#include "ncsetup.h"
#include "util.h"

// constants
const WCHAR c_szHelpText[]           = L"HelpText";

//+---------------------------------------------------------------------------
//
//  Function:   HrBuildBindNameFromBindForm
//
//  Purpose:    Build a bindname from a bindform and component parameters.
//
//  Arguments:
//      pszBindForm       [in]  The components bindform.  This is read from
//                              the Ndi key.  If the component did not specify
//                              it in its Ndi key, pass NULL.
//      Class             [in]  The class of the component.
//      dwCharacteristics [in]  The characteristics of the component.
//      pszServiceName    [in]  The components service name.
//      pszInfId          [in]  The component (device) id.
//      szInstanceGuid    [in]  The instance GUID of the component.
//      ppszBindName      [out] The returned bind string.  This must be freed
//                              with LocalFree.
//
//  Returns:    HRESULT
//
//  Author:     shaunco   6 Jun 1997
//  Modified:   ckotze   21 Dec 2000
//
//  Notes:      The bindform contains replaceable parameters designed to
//              be used with the FormatMessage API.
//                  %1 = pszServiceName
//                  %2 = pszInfId
//                  %3 = szInstanceGuid
//
HRESULT
HrBuildBindNameFromBindForm (
    IN PCWSTR pszBindForm,
    IN NETCLASS Class,
    IN DWORD dwCharacteristics,
    IN PCWSTR pszServiceName,
    IN PCWSTR pszInfId,
    IN const GUID& InstanceGuid,
    OUT PWSTR* ppszBindName)
{
    static const WCHAR c_szBindFormNet       [] = L"%3";
    static const WCHAR c_szBindFormNoService [] = L"%2";
    static const WCHAR c_szBindFormDefault   [] = L"%1";

    WCHAR szInstanceGuid [c_cchGuidWithTerm];
    INT cch;
    DWORD dwRet = 0;
    HRESULT hr = S_OK;

    Assert (ppszBindName);
    Assert (FIsValidNetClass(Class));

    cch = StringFromGUID2 (
                InstanceGuid,
                szInstanceGuid,
                c_cchGuidWithTerm);
    
    Assert (c_cchGuidWithTerm == cch);

    if (FIsPhysicalAdapter(Class, dwCharacteristics))
    {
        // netcards use the the instance guid only
        // We disregard any bind form sent in.
        Assert (szInstanceGuid && *szInstanceGuid);
        pszBindForm = c_szBindFormNet;
    }
    else if (!pszBindForm || !*pszBindForm)
    {
        // Figure out which bindform to use since it wasn't specified.
        //
        if (FIsEnumerated(Class))
        {
            // Virtual adapters use the the instance guid only
            Assert (szInstanceGuid && *szInstanceGuid);
            pszBindForm = c_szBindFormNet;
        }
        else if (pszServiceName && *pszServiceName)
        {
            // use the service name if we have one
            pszBindForm = c_szBindFormDefault;
        }
        else
        {
            // if no service, then use the component id
            Assert (pszInfId && *pszInfId);
            pszBindForm = c_szBindFormNoService;
        }
    }
    AssertSz (pszBindForm && *pszBindForm, "Should have pszBindForm by now.");

    // dwRet is either 0 or the number of chars in the resulting string.  Since 
    // *ppszBindName is either NULL or a valid string, we get the last error if it's
    // a NULL and ignore dwRet.
    dwRet = DwFormatStringWithLocalAlloc (
                pszBindForm, ppszBindName,
                pszServiceName, pszInfId, szInstanceGuid);

    if (*ppszBindName)
    {
        // Underscores are not allowed in the bind name so make a pass
        // to remove them.
        //
        PWSTR pszScan = *ppszBindName;
        while (NULL != (pszScan = wcschr (pszScan, L'_')))
        {
            wcscpy (pszScan, pszScan + 1);
        }
    }
    else
    {
        DWORD dwErr = GetLastError();

        hr = HRESULT_FROM_WIN32(dwErr);
    }

    AssertSz (*ppszBindName,
        "BuildBindNameFromBindForm: DwFormatStringWithLocalAlloc failed.");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcLoadRegUIString
//
//  Purpose:    Wrapper around SHLoadRegUIString, which is used to support MUI.
//
//  Arguments:  same as RegQueryValueEx with lpReserved and lpType removed
//   
//  Returns:    If the function succeeds, the return value is ERROR_SUCCESS
//
//  Notes:      SHLoadRegUIString will read a string of the form
// 
//              @[path\]<dllname>,-<strId>
// 
//              The string with id <strId> is loaded from <dllname>.  If no explicit
//              path is provided then the DLL will be chosen according to pluggable UI
//              specifications, if possible.
// 
//              If the registry string is not of the special form described here,
//              SHLoadRegUIString will return the string intact. 
//
//
LONG NcLoadRegUIString (
    IN HKEY         hkey,
    IN PCWSTR       lpValueName,
    IN OUT LPBYTE   lpData OPTIONAL,
    IN OUT LPDWORD  lpcbData)
{
    const DWORD cchGrow    = 256;   // grows at 256 of WCHAR a time
    DWORD       cchBuffer  = 0;     // buffer size in number of WCHAR
    HRESULT     hr         = S_OK;
    LONG        lr         = ERROR_SUCCESS;
    LPWSTR      pwszBuffer = NULL;  // buffer for the WCHAR string
    DWORD       cbBuffer   = 0;     // the real buffer size in bytes
    
    if ( (NULL == hkey) || (NULL == lpValueName) )
    {
        return ERROR_BAD_ARGUMENTS;
    }

    // The lpcbData parameter can be NULL only if lpData is NULL. 
    if ( (NULL == lpcbData) && (NULL != lpData) )
    {
        return ERROR_BAD_ARGUMENTS;
    }
    if ( (NULL == lpcbData) && (lpData == NULL) )
    {
        // no operation
        return ERROR_SUCCESS;
    }
    
    Assert (lpcbData);
    if ( (*lpcbData > 0) && lpData && IsBadWritePtr(lpData, *lpcbData))
    {
        return ERROR_BAD_ARGUMENTS;
    }
    
    do
    {
        if (pwszBuffer)
        {
            // free the last allocated buffer
            MemFree((LPVOID) pwszBuffer);
        }

        // allocate a larger buffer for the string   
        cchBuffer += cchGrow;
        pwszBuffer = (LPWSTR) MemAlloc (cchBuffer * sizeof(WCHAR));

        if (pwszBuffer == NULL)
        {
            return (ERROR_OUTOFMEMORY);
        }

        // load the MUI enabled string from the registry
        // NOTE: for the buffer size, this API takes number of characters including NULL 
        //       character, not number of bytes for the buffer.
        // SHLoadRegUIStringW(HKEY hkey, LPCWSTR  pszValue, IN OUT LPWSTR pszOutBuf, IN UINT cchOutBuf)
        hr = SHLoadRegUIStringW (hkey, lpValueName, (LPWSTR)pwszBuffer, cchBuffer);
        if (FAILED(hr))
        {
            lr = ERROR_FUNCTION_FAILED;
            goto Exit;
        }

        // Unfortunately, SHLoadRegUIString doesn't have a way to query the
        // buffer size, so we assume more data available.  We'll loop around, 
        // grow the buffer, and try again.
        
    } while ( wcslen(pwszBuffer) == (cchBuffer - 1) ); // retry if the last buffer is fully used
    
    Assert (ERROR_SUCCESS == lr);

    // the actual buffer size requirement in bytes
    cbBuffer = (wcslen(pwszBuffer) + 1 ) * sizeof(WCHAR); 

    // If lpData is NULL, and lpcbData is non-NULL, the function returns ERROR_SUCCESS, 
    // and stores the size of the data, in bytes, in the variable pointed to by lpcbData. 
    // This lets an application determine the best way to allocate a buffer for 
    // the value's data. 
    if ( (NULL == lpData) && lpcbData )
    {
        *lpcbData = cbBuffer;
        goto Exit;
    }

    // If the buffer specified by lpData parameter is not large enough to hold the data, 
    // the function returns the value ERROR_MORE_DATA, and stores the required buffer size, 
    // in bytes, into the variable pointed to by lpcbData. In this case, the contents of 
    // the lpValue buffer are undefined. 
    if (cbBuffer > *lpcbData)
    {
        *lpcbData = cbBuffer;
        lr = ERROR_MORE_DATA;
        goto Exit;
    }

    // transfer values
    *lpcbData = cbBuffer;
    if (lpData)
    {
        CopyMemory(lpData, (LPBYTE) pwszBuffer, cbBuffer);
    }
    
Exit:   
    if (pwszBuffer)
    {
        MemFree((LPVOID) pwszBuffer);
    }
    return (lr);
}

//
// Query a value from the registry and ensure it is of the type we expect
// it to be.  When calling RegQueryValueEx, we don't care to know what
// the type is, only to know if it doesn't match what we expect it to be.
// If the value is not of dwType, return ERROR_INVALID_DATATYPE.
//
LONG
RegQueryValueType (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    OUT BYTE* pbData OPTIONAL,
    IN OUT DWORD* pcbData)
{
    LONG lr;
    DWORD dwTypeQueried;

    lr = RegQueryValueExW (hkey, pszValueName, NULL, &dwTypeQueried, pbData, pcbData);
    if (!lr && (dwType != dwTypeQueried))
    {
        lr = ERROR_INVALID_DATATYPE;
    }
    return lr;
}

//
// Read a REG_SZ that is expected to represent a GUID and convert it
// to its GUID representation.  If the value does not seem to be a GUID,
// return ERROR_INVALID_DATATYPE.
//
// hkey is the parent key to read from and pszValueName is the name of the
// value whose data is expected to be a GUID in string form.
// pguidData points to a buffer to receive the GUID.  If pguidData is NULL,
// no data will be returned, but the size of the buffer required will be
// stored at the DWORD pointed to by pcbData.
//
// On input, *pcbData is the size (in bytes) of the buffer pointed to
// by pguidData.  On output, *pcbData is the size (in bytes) required to hold
// the data.
//
LONG
RegQueryGuid (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    OUT GUID* pguidData OPTIONAL,
    IN OUT DWORD* pcbData
    )
{
    LONG lr;
    HRESULT hr;
    WCHAR szGuid [c_cchGuidWithTerm];
    DWORD cbDataIn;
    DWORD cbData;

    Assert (pcbData);

    cbDataIn = *pcbData;
    *pcbData = 0;

    // Get the string form of the guid and store it in szGuid.
    //
    cbData = sizeof (szGuid);
    lr = RegQueryValueType (hkey, pszValueName, REG_SZ, (PBYTE)szGuid, &cbData);
    if (!lr)
    {
        GUID guid;

        // Convert the string to a GUID.  If this fails, the data is invalid
        // and we will return such.
        //
        hr = IIDFromString (szGuid, &guid);
        if (S_OK != hr)
        {
            lr = ERROR_INVALID_DATATYPE;
        }

        if (!lr)
        {
            // The data looks to be a GUID, so we'll return the size
            // and the data if the caller wants it.
            //
            *pcbData = sizeof(GUID);

            if (pguidData)
            {
                if (cbDataIn >= sizeof(GUID))
                {
                    *pguidData = guid;
                }
                else
                {
                    lr = ERROR_MORE_DATA;
                }
            }
        }
    }

    // If querying for the string form of the guid returned ERROR_MORE_DATA,
    // it means that the data is not a GUID.
    //
    else if (ERROR_MORE_DATA == lr)
    {
        lr = ERROR_INVALID_DATATYPE;
    }

    return lr;
}

// Used as input to RegQueryValues.
//
struct REGVALINFO
{
    // The name of the subkey under which this registry value lives.
    // Set this to NULL if this registry value lives under the same key
    // as the previous registry value in the array of this structure.
    //
    PCWSTR  pszSubkey;

    // The name of the registry value.
    //
    PCWSTR  pszValueName;

    // The type of the registry value.  One of REG_SZ, REG_DWORD, etc.
    // REG_GUID is also supported.
    //
    DWORD   dwType;

    // The byte offset of the output pointer within the pbPointers
    // array to store the pointer to the queried data.
    //
    UINT    cbOffset;
};

#define REG_GUID ((DWORD)-5)

//
// Query a batch of values from the registry.  The number of values to query
// is given by cValues.  Information about the values is given through
// an array of REGVALINFO structures.  The data for the values is stored
// in the caller-supplied buffer pointed to by pbBuf.  The caller also
// supplies an array of pointers which will be set to point within pbBuf
// to the data for each value.  This array is must also have cValues elements.
//
// If a value does not exist, its corresponding pointer value in the
// pbPointers array is set to NULL.  This allows the caller to know whether
// the value existed or not.
//
LONG
RegQueryValues (
    IN HKEY hkeyRoot,
    IN ULONG cValues,
    IN const REGVALINFO* aValueInfo,
    OUT BYTE* pbPointers,
    OUT BYTE* pbBuf OPTIONAL,
    IN OUT ULONG* pcbBuf)
{
    LONG lr;
    ULONG cbBufIn;
    ULONG cbBufRequired;
    ULONG cbData;
    ULONG cbPad;
    BYTE *pData;
    const REGVALINFO* pInfo;
    HKEY hkey;
    HRESULT hr;

    Assert (hkeyRoot);
    Assert (pcbBuf);
    Assert (((ULONG_PTR)pbBuf & (sizeof(PVOID)-1)) == 0);

    // On input, *pcbBuf is the number of bytes available in pbBuf.
    //
    cbBufIn = *pcbBuf;
    cbBufRequired = 0;

    hkey = hkeyRoot;

    for (pInfo = aValueInfo; cValues; pInfo++, cValues--)
    {
        // Make sure we have the hkey we want.
        //
        if (pInfo->pszSubkey)
        {
            if (hkey != hkeyRoot)
            {
                RegCloseKey (hkey);
            }

            lr = RegOpenKeyEx (hkeyRoot, pInfo->pszSubkey, 0, KEY_READ, &hkey);
            if (lr)
            {
                continue;
            }
        }

        cbPad = cbBufRequired & (sizeof(PVOID)-1);
        if (cbPad !=0) {

            //
            // The current buffer offset is misaligned.  Increment it so that
            // it is properly aligned.
            // 

            cbPad = sizeof(PVOID) - cbPad;
            cbBufRequired += cbPad;
        }


        if (pbBuf != NULL) {

            //
            // The caller supplied a buffer, so calculate a pointer to the
            // current position within it.
            //

            pData = pbBuf + cbBufRequired;

        } else {

            pData = NULL;
        }

        //
        // Set cbData to the amount of data remaining in the buffer.
        //

        if (cbBufIn > cbBufRequired) {

            cbData = cbBufIn - cbBufRequired;

        } else {

            //
            // No room left, pass in a NULL buffer pointer too.
            //

            cbData = 0;
            pData = NULL;
        }

        //
        // Perform the query based on the desired type.
        //

        if (REG_GUID == pInfo->dwType)
        {
            lr = RegQueryGuid (hkey, pInfo->pszValueName, (GUID*)pData, &cbData);

        } 
        else if ( (REG_SZ == pInfo->dwType) && (!wcscmp(pInfo->pszValueName, c_szHelpText)) )
        {
            // Bug# 310358, load MUI string if necessary
            lr = NcLoadRegUIString(hkey, pInfo->pszValueName, pData, &cbData);
        }    
        else 
        {

            lr = RegQueryValueType (hkey, pInfo->pszValueName,
                    pInfo->dwType, pData, &cbData);
        }

        if (ERROR_SUCCESS == lr || ERROR_MORE_DATA == lr) {

            //
            // cbData contains the amount of data that is available.  Update
            // the buffer size required to contain all of the data.
            // 

            cbBufRequired += cbData;

        } else {

            //
            // The call failed for some reason other than ERROR_MORE_DATA,
            // back out the alignment padding from cbBufRequired.
            // 

            cbBufRequired -= cbPad;
        }

        if (ERROR_SUCCESS == lr && pData != NULL) {

            //
            // Data was retrieved into our buffer.  Store the pointer to the
            // data.
            // 

            *((BYTE**)(pbPointers + pInfo->cbOffset)) = pData;
        }
    }

    if (hkey != hkeyRoot)
    {
        RegCloseKey (hkey);
    }

    *pcbBuf = cbBufRequired;

    if (cbBufRequired <= cbBufIn)
    {
        lr = ERROR_SUCCESS;
    }
    else
    {
        lr = (pbBuf) ? ERROR_MORE_DATA : ERROR_SUCCESS;
    }
    return lr;
}

LONG
RegQueryValuesWithAlloc (
    IN HKEY hkeyRoot,
    IN ULONG cValues,
    IN const REGVALINFO* aValueInfo,
    OUT BYTE* pbPointers,
    OUT BYTE** ppbBuf,
    IN OUT ULONG* pcbBuf)
{
    LONG lr;
    ULONG cbBuf;
    ULONG cbBufConfirm;

    *ppbBuf = NULL;
    *pcbBuf = 0;

    cbBuf = 0;
    lr = RegQueryValues (hkeyRoot, cValues, aValueInfo,
            pbPointers, NULL, &cbBuf);

    if (!lr)
    {
        BYTE* pbBuf;

        lr = ERROR_OUTOFMEMORY;
        pbBuf = (BYTE*)MemAlloc (cbBuf);

        if (pbBuf)
        {
            cbBufConfirm = cbBuf;
            lr = RegQueryValues (hkeyRoot, cValues, aValueInfo,
                    pbPointers, pbBuf, &cbBufConfirm);

            if (!lr)
            {
                Assert (cbBufConfirm == cbBuf);
                *ppbBuf = pbBuf;
                *pcbBuf = cbBuf;
            }
            else
            {
                MemFree (pbBuf);
            }
        }
    }

    return lr;
}

HRESULT
CExternalComponentData::HrEnsureExternalDataLoaded ()
{
    if (m_fInitialized)
    {
        return m_hrLoadResult;
    }

    //$PERF: We can selectively prune certain rows out of this table under
    // certain conditions.  e.g. Enumerated components don't have Clsid or
    // CoServices.
    //
    static const REGVALINFO aValues[] =
    {
        { NULL, L"Description", REG_SZ,       ECD_OFFSET(m_pszDescription) },

        { L"Ndi",
                L"Clsid",       REG_GUID,     ECD_OFFSET(m_pNotifyObjectClsid) },
        { NULL, L"Service",     REG_SZ,       ECD_OFFSET(m_pszService) },
        { NULL, L"CoServices",  REG_MULTI_SZ, ECD_OFFSET(m_pmszCoServices) },
        { NULL, L"BindForm",    REG_SZ,       ECD_OFFSET(m_pszBindForm) },
        { NULL, c_szHelpText,   REG_SZ,       ECD_OFFSET(m_pszHelpText) },

        { L"Ndi\\Interfaces",
                L"LowerRange",      REG_SZ,   ECD_OFFSET(m_pszLowerRange) },
        { NULL, L"LowerExclude",    REG_SZ,   ECD_OFFSET(m_pszLowerExclude) },
        { NULL, L"UpperRange",      REG_SZ,   ECD_OFFSET(m_pszUpperRange) },
        { NULL, L"FilterMediaTypes",REG_SZ,   ECD_OFFSET(m_pszFilterMediaTypes) },
    };

    // Get our containing component pointer so we can open it's
    // instance key.
    //
    CComponent* pThis;
    pThis = CONTAINING_RECORD(this, CComponent, Ext);

    // Open the instance key of the component.
    //
    HRESULT hr;
    HKEY hkeyInstance;
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;

    hr = pThis->HrOpenInstanceKey (KEY_READ, &hkeyInstance, &hdi, &deid);

    if (S_OK == hr)
    {
        LONG lr;
        PVOID pvBuf;
        ULONG cbBuf;

        lr = RegQueryValuesWithAlloc (hkeyInstance, celems(aValues), aValues,
                (BYTE*)this, (BYTE**)&pvBuf, &cbBuf);
        if (!lr)
        {
            // Set our buffer markers.
            //
            m_pvBuffer = pvBuf;
            m_pvBufferLast = (BYTE*)pvBuf + cbBuf;

            // HrOpenInstanceKey may succeed but return a NULL hdi for
            // enumerated components when the real instance key does not
            // exist.  This happens when the class installer removes the
            // instance key and calls us to remove its bindings.
            //
            if (hdi && FIsEnumerated (pThis->Class()))
            {
                hr = HrSetupDiGetDeviceName (hdi, &deid,
                        (PWSTR*)&m_pszDescription);
            }

            if (S_OK == hr)
            {
                hr = HrBuildBindNameFromBindForm (
                        m_pszBindForm,
                        pThis->Class(),
                        pThis->m_dwCharacter,
                        m_pszService,
                        pThis->m_pszInfId,
                        pThis->m_InstanceGuid,
                       (PWSTR*)&m_pszBindName);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lr);
            ZeroMemory (this, sizeof(*this));
        }

        SetupDiDestroyDeviceInfoListSafe (hdi);

        RegCloseKey (hkeyInstance);
    }

    // Only perform initialization once, regardless of whether it succeeds
    // or not.
    //
    m_fInitialized = TRUE;
    m_hrLoadResult = hr;

    TraceHr (ttidError, FAL, m_hrLoadResult, FALSE,
        "CExternalComponentData::HrEnsureExternalDataLoaded (%S)",
        pThis->PszGetPnpIdOrInfId());
    return m_hrLoadResult;
}

BOOL
CExternalComponentData::FLoadedOkayIfLoadedAtAll () const
{
    // Because m_hrLoadResult is S_OK even if we are not initialized,
    // (i.e. if the component's data is not loaded) we can just check
    // m_hrLoadResult without needing to check m_fInitialized.
    //
    return (S_OK == m_hrLoadResult);
}

VOID
CExternalComponentData::FreeDescription ()
{
    // If m_pszDescription is not pointing somewhere in our buffer
    // it means it is using a separate allocation.  (Because it was
    // changed.)
    //
    if ((m_pszDescription < (PCWSTR)m_pvBuffer) ||
        (m_pszDescription > (PCWSTR)m_pvBufferLast))
    {
        MemFree ((VOID*)m_pszDescription);
    }
    m_pszDescription = NULL;
}

VOID
CExternalComponentData::FreeExternalData ()
{
    LocalFree ((VOID*)m_pszBindName);
    FreeDescription();
    MemFree (m_pvBuffer);
}

HRESULT
CExternalComponentData::HrReloadExternalData ()
{
    HRESULT hr;

    FreeExternalData ();
    ZeroMemory (this, sizeof(*this));

    hr = HrEnsureExternalDataLoaded ();

    TraceHr (ttidError, FAL, hr, FALSE,
        "CExternalComponentData::HrReloadExternalData");
    return hr;

}

HRESULT
CExternalComponentData::HrSetDescription (
    PCWSTR pszNewDescription)
{
    HRESULT hr;

    Assert (pszNewDescription);

    FreeDescription();

    hr = E_OUTOFMEMORY;
    m_pszDescription = (PWSTR)MemAlloc (CbOfSzAndTerm(pszNewDescription));
    if (m_pszDescription)
    {
        wcscpy ((PWSTR)m_pszDescription, pszNewDescription);
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\comprefs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P R E F S . C P P
//
//  Contents:   Implements the interface to a component's references.  A
//              component can be referenced (installed by) other components,
//              the user, or other software.  This module manages the
//              interface to that data.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "comp.h"
#include "comprefs.h"
#include "icomp.h"
#include "nceh.h"
#include "ncreg.h"

#define REGSTR_KEY_REFNAMES \
    L"SYSTEM\\CurrentControlSet\\Control\\Network\\RefNames"

// Cannot be inline because comprefs.h cannot include comp.h.
//
CComponentReferences::~CComponentReferences ()
{
    Assert (this);

    // Must use delete on m_pData to get destructors of its members
    // to be called.
    //
    delete m_pData;
}

ULONG
CComponentReferences::CountComponentsReferencedBy () const
{
    Assert (this);

    if (!m_pData)
    {
        return 0;
    }

    return m_pData->RefByComponents.Count ();
}

ULONG
CComponentReferences::CountSoftwareReferencedBy () const
{
    Assert (this);

    if (!m_pData)
    {
        return 0;
    }

    return m_pData->RefBySoftware.size ();
}

ULONG
CComponentReferences::CountTotalReferencedBy () const
{
    Assert (this);

    if (!m_pData)
    {
        return 0;
    }

    return ((m_pData->fRefByUser) ? 1 : 0) +
            m_pData->RefByComponents.Count () +
            m_pData->RefBySoftware.size ();
}

HRESULT
HrGetSoftwareOboTokenKey (
    IN const OBO_TOKEN* pOboToken,
    BOOL fRegister,
    OUT PWSTR* ppszKey)
{
    HRESULT hr;
    UINT cch;

    Assert (pOboToken);
    Assert (OBO_SOFTWARE == pOboToken->Type);
    Assert (pOboToken->pszwManufacturer && *pOboToken->pszwManufacturer);
    Assert (pOboToken->pszwProduct && *pOboToken->pszwProduct);
    Assert (ppszKey);

    cch = wcslen (pOboToken->pszwManufacturer) +
          wcslen (pOboToken->pszwProduct);

    hr = E_OUTOFMEMORY;
    *ppszKey = (PWSTR)MemAlloc ((cch + 1) * sizeof(WCHAR));
    if (*ppszKey)
    {
        hr = S_OK;
        wcscpy (*ppszKey, pOboToken->pszwManufacturer);
        wcscat (*ppszKey, pOboToken->pszwProduct);

        if (fRegister)
        {
            HKEY hkeyRefNames;
            hr = HrRegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    REGSTR_KEY_REFNAMES,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE, NULL, &hkeyRefNames, NULL);

            if (SUCCEEDED(hr))
            {
                hr = HrRegSetSz (
                        hkeyRefNames,
                        *ppszKey,
                        pOboToken->pszwDisplayName);

                RegCloseKey (hkeyRefNames);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrGetSoftwareOboTokenKey");
    return hr;
}

BOOL
CComponentReferences::FIsReferencedByComponent (
    IN const CComponent* pComponent) const
{
    Assert (pComponent);

    if (!m_pData)
    {
        return FALSE;
    }

    return m_pData->RefByComponents.FComponentInList (pComponent);
}


BOOL
CComponentReferences::FIsReferencedByOboToken (
    IN const OBO_TOKEN* pOboToken) const
{
    HRESULT hr;
    BOOL fIsReferenced;
    PWSTR pszKey;

    Assert (pOboToken);

    if (!m_pData)
    {
        return FALSE;
    }

    fIsReferenced = FALSE;

    CComponent* pComponent;

    switch (pOboToken->Type)
    {
        case OBO_USER:
            fIsReferenced = m_pData->fRefByUser;
            break;

        case OBO_COMPONENT:
            // Can't be referenced if there are no references.
            //
            if (m_pData->RefByComponents.Count() > 0)
            {
                pComponent = PComponentFromComInterface (pOboToken->pncc);

                fIsReferenced = m_pData->RefByComponents.FComponentInList (
                                            pComponent);
            }
            break;

        case OBO_SOFTWARE:
            // Can't be referenced if there are no references.
            //
            if (m_pData->RefBySoftware.size() > 0)
            {
                // Get the key for the software token, but don't register
                // the display name.
                //
                hr = HrGetSoftwareOboTokenKey (pOboToken, FALSE, &pszKey);
                if (S_OK == hr)
                {
                    fIsReferenced =
                        find (m_pData->RefBySoftware.begin(),
                              m_pData->RefBySoftware.end(), pszKey) !=
                        m_pData->RefBySoftware.end();

                    MemFree (pszKey);
                }
            }
            break;

        default:
            AssertSz (FALSE, "Invalid obo token");
    }

    return fIsReferenced;
}

VOID
CComponentReferences::GetReferenceDescriptionsAsMultiSz (
    IN BYTE* pbBuf OPTIONAL,
    OUT ULONG* pcbBuf) const
{
    ULONG cbBuf;
    ULONG cbBufIn;
    ULONG cb;
    CComponentList::const_iterator iter;
    const CComponent* pComponent;
    vector<CWideString>::const_iterator pStr;

    Assert (this);
    Assert (m_pData);
    Assert (pcbBuf);

    cbBufIn = *pcbBuf;
    cbBuf = 0;

    // Get/Size the component descriptions.
    //
    for (iter  = m_pData->RefByComponents.begin();
         iter != m_pData->RefByComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        cb = CbOfSzAndTermSafe(pComponent->Ext.PszDescription());
        cbBuf += cb;
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            wcscpy ((PWSTR)pbBuf, pComponent->Ext.PszDescription());
            pbBuf += cb;
        }
    }

    // Get/Size the software descriptions.
    //
    if (!m_pData->RefBySoftware.empty())
    {
        HRESULT hr;
        HKEY hkeyRefNames;

        hr = HrRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                REGSTR_KEY_REFNAMES,
                KEY_READ,
                &hkeyRefNames);

        if (S_OK == hr)
        {
            for (pStr  = m_pData->RefBySoftware.begin();
                 pStr != m_pData->RefBySoftware.end();
                 pStr++)
            {
                cb = cbBufIn - cbBuf;

                hr = HrRegQuerySzBuffer (hkeyRefNames, pStr->c_str(),
                        (PWSTR)pbBuf, &cb);

                if (S_OK == hr)
                {
                    cbBuf += cb;

                    if (pbBuf)
                    {
                        pbBuf += cb;
                    }
                }
            }

            RegCloseKey (hkeyRefNames);
        }
    }

    // Terminate the multi-sz.
    //
    cbBuf += sizeof(WCHAR);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(PWSTR)pbBuf = 0;
    }

    // Return the size of the buffer required.
    //
    *pcbBuf = cbBuf;
}

BOOL
CComponentReferences::FIsReferencedByOthers () const
{
    Assert (this);

    if (!m_pData)
    {
        return FALSE;
    }

    return m_pData->fRefByUser ||
           !m_pData->RefByComponents.empty() ||
           !m_pData->RefBySoftware.empty();
}

CComponent*
CComponentReferences::PComponentReferencedByAtIndex (
    IN UINT unIndex) const
{
    Assert (this);

    if (!m_pData)
    {
        return NULL;
    }

    return m_pData->RefByComponents.PGetComponentAtIndex (unIndex);
}

const CWideString*
CComponentReferences::PSoftwareReferencedByAtIndex (
    IN UINT unIndex) const
{
    Assert (this);

    if (!m_pData)
    {
        return NULL;
    }

    return &m_pData->RefBySoftware[unIndex];
}


HRESULT
CComponentReferences::HrEnsureAllocated ()
{
    Assert (this);

    if (m_pData)
    {
        return S_OK;
    }

    HRESULT hr;

    hr = E_OUTOFMEMORY;
    m_pData = new COMPONENT_REFERENCE_DATA;
    if (m_pData)
    {
        ZeroMemory (m_pData, sizeof(COMPONENT_REFERENCE_DATA));
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrEnsureAllocated");
    return hr;
}

HRESULT
CComponentReferences::HrAddReferenceByUser ()
{
    HRESULT hr;

    Assert (this);

    hr = HrEnsureAllocated ();
    if (S_OK == hr)
    {
        m_pData->fRefByUser = TRUE;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::AddReferenceByUser");
    return hr;
}

HRESULT
CComponentReferences::HrAddReferenceByComponent (
    IN const CComponent* pComponent)
{
    HRESULT hr;

    Assert (this);
    Assert (pComponent);

    hr = HrEnsureAllocated ();
    if (S_OK == hr)
    {
        // If someone wants to add a reference by the same component
        // multiple times, we'll allow it.  The component only goes in the
        // list once.
        //
        hr = m_pData->RefByComponents.HrInsertComponent (
                pComponent, INS_IGNORE_IF_DUP | INS_NON_SORTED);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrAddReferenceByComponent");
    return hr;
}

HRESULT
CComponentReferences::HrAddReferenceByOboToken (
    IN const OBO_TOKEN* pOboToken)
{
    Assert (pOboToken);

    HRESULT hr;
    CComponent* pComponent;
    PWSTR pszKey;

    switch (pOboToken->Type)
    {
        case OBO_USER:
            hr = HrAddReferenceByUser ();
            break;

        case OBO_COMPONENT:
            pComponent = PComponentFromComInterface (pOboToken->pncc);

            hr = HrAddReferenceByComponent (pComponent);
            break;

        case OBO_SOFTWARE:
            // Register the display name of the obo token.
            //
            hr = HrGetSoftwareOboTokenKey (pOboToken, TRUE, &pszKey);
            if (S_OK == hr)
            {
                hr = HrAddReferenceBySoftware (pszKey);

                MemFree (pszKey);
            }
            break;

        default:
            AssertSz (FALSE, "Invalid obo token");
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrAddReferenceByOboToken");
    return hr;
}

HRESULT
CComponentReferences::HrAddReferenceBySoftware (
    IN PCWSTR pszKey)
{
    HRESULT hr;

    Assert (this);
    Assert (pszKey && *pszKey);

    hr = HrEnsureAllocated ();
    if (S_OK == hr)
    {
        // If the key is not in the list, add it.
        //
        if (find (m_pData->RefBySoftware.begin(),
                  m_pData->RefBySoftware.end(), pszKey) ==
            m_pData->RefBySoftware.end())
        {
            NC_TRY
            {
                m_pData->RefBySoftware.push_back (pszKey);
                Assert (S_OK == hr);
            }
            NC_CATCH_ALL
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrAddReferenceBySoftware");
    return hr;
}

VOID
CComponentReferences::RemoveAllReferences()
{
    Assert (this);

    if (m_pData)
    {
        m_pData->fRefByUser = FALSE;
        m_pData->RefByComponents.Clear();
        m_pData->RefBySoftware.clear();
    }
}

HRESULT
CComponentReferences::HrRemoveReferenceByOboToken (
    IN const OBO_TOKEN* pOboToken)
{
    Assert (pOboToken);

    HRESULT hr;
    CComponent* pComponent;
    PWSTR pszKey;

    if (!m_pData)
    {
        return S_OK;
    }

    hr = S_OK;

    switch (pOboToken->Type)
    {
        case OBO_USER:
            // Don't allow the user's reference to be removed until all
            // other references are.  This is to prevent the case where
            // the user wants to remove IPX, but it is still referenced by
            // SAP.  If we remove the user's reference to IPX, then we will
            // report that it was not removed.  If the user then removes
            // SAP, both SAP and IPX will be removed.  While this will
            // certainly work, to end users, they feel that if we tell them
            // we can't remove IPX because it is still referenced, then they
            // believe we have left IPX untouched and they should first remove
            // SAP and then come back and remove IPX.
            //
            if (m_pData->RefByComponents.empty() &&
                m_pData->RefBySoftware.empty())
            {
                m_pData->fRefByUser = FALSE;
            }
            break;

        case OBO_COMPONENT:
            pComponent = PComponentFromComInterface (pOboToken->pncc);

            m_pData->RefByComponents.RemoveComponent(pComponent);
            break;

        case OBO_SOFTWARE:
            // Register the display name of the obo token.
            //
            hr = HrGetSoftwareOboTokenKey (pOboToken, TRUE, &pszKey);
            if (S_OK == hr)
            {
                vector<CWideString>::iterator iter;

                iter = find (m_pData->RefBySoftware.begin(),
                             m_pData->RefBySoftware.end(), pszKey);
                Assert (m_pData->RefBySoftware.end() != iter);

                m_pData->RefBySoftware.erase (iter);

                Assert (m_pData->RefBySoftware.end() ==
                            find (m_pData->RefBySoftware.begin(),
                                  m_pData->RefBySoftware.end(), pszKey));

                MemFree (pszKey);
            }
            break;

        default:
            AssertSz (FALSE, "Invalid obo token");
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrRemoveReferenceByOboToken");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\filtdev.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       F I L T D E V . C P P
//
//  Contents:   Implements the object that represents filter devices.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "filtdev.h"

//static
HRESULT
CFilterDevice::HrCreateInstance (
    IN CComponent* pAdapter,
    IN CComponent* pFilter,
    IN const SP_DEVINFO_DATA* pdeid,
    IN PCWSTR pszInstanceGuid,
    OUT CFilterDevice** ppFilterDevice)
{
    Assert (pAdapter);
    Assert (FIsEnumerated(pAdapter->Class()));
    Assert (pFilter);
    Assert (pFilter->FIsFilter());
    Assert (NC_NETSERVICE == pFilter->Class());
    Assert (pdeid);
    Assert (pszInstanceGuid && *pszInstanceGuid);
    Assert ((c_cchGuidWithTerm - 1) == wcslen(pszInstanceGuid));
    Assert (ppFilterDevice);

    HRESULT hr = E_OUTOFMEMORY;
    CFilterDevice* pFilterDevice = new CFilterDevice;
    if (pFilterDevice)
    {
        pFilterDevice->m_pAdapter = pAdapter;
        pFilterDevice->m_pFilter = pFilter;
        pFilterDevice->m_deid = *pdeid;
        wcscpy(pFilterDevice->m_szInstanceGuid, pszInstanceGuid);
        hr = S_OK;
    }

    *ppFilterDevice = pFilterDevice;

    TraceHr (ttidError, FAL, hr, FALSE, "CFilterDevice::HrCreateInstance");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ecomp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       E C O M P . H
//
//  Contents:   Implements the interface to a component's external data.
//              External data is that data controlled (or placed) by
//              PnP or the network class installer.  Everything under a
//              component's instance key is considered external data.
//              (Internal data is that data we store in the persisted binary
//              for the network configuration.  See persist.cpp for
//              code that deals with internal data.)
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "ncmisc.h"

#define ECD_OFFSET(_p) (UINT)FIELD_OFFSET(CExternalComponentData, _p)

class CExternalComponentData
{
friend class CImplINetCfgComponent;

private:
    // The data buffer into which subsequent member pointers will point.
    // Always freed.
    //
    PVOID       m_pvBuffer;

    // For enumerated components, this is the 'DriverDesc' value from PnP.
    // For non-enumerated components, this is read from the instance key.
    // In both cases, this is the localizable string value that comes from
    // the component's INF.  It is displayed as the component's
    // display name in any UI.  Note that this is the only member which
    // can be changed.  Therefore, it does not point into the same buffer
    // which all the others point.  Freed if it does not point into
    // m_pvBuffer.
    //
    PCWSTR      m_pszDescription;

    // The CLSID of the component's notify object.  Will be NULL in
    // the case the component does not have a notify object.  Never freed.
    //
    const GUID* m_pNotifyObjectClsid;

    // The component's primary service.  Will be NULL if the component does
    // not have a service.  Never freed.
    //
    PCWSTR      m_pszService;

    // The component's list of co-services as a multi-sz.  Will be NULL
    // if the component does not have any co-services.  Never freed.
    //
    PCWSTR      m_pmszCoServices;

    // The component's bind form.  Will be NULL if the component takes the
    // default bindform.  Never freed.
    //
    PCWSTR      m_pszBindForm;

    // The component's help text.  Will be NULL if the component does not
    // have any help text.  (Not recommened for visible component's)
    // Never freed.
    //
    PCWSTR      m_pszHelpText;

    // Comma-separated list of sub-strings that are the
    // lower-edge binding interfaces.  Never freed.
    //
    PCWSTR      m_pszLowerRange;

    // Comma-separated list of sub-strings that are the
    // upper-edge binding interfaces.
    //
    PCWSTR      m_pszUpperRange;

    // Comma-separated list of sub-strings that are the excluded
    // binding interfaces.
    //
    PCWSTR      m_pszLowerExclude;

    // Comma-separated list of sub-strings that are the media types supported
    // by this filter component.  (Only valid for filters.)
    //
    PCWSTR      m_pszFilterMediaTypes;

    // This pointer is just so that we have an upper bound on the pointers
    // that point into m_pvBuffer.  We use this knowledge to know
    // whether or not to free m_pszDescription as it may not be
    // pointing somewhere in this buffer for the case when it has been
    // changed and hence uses its own allocation.
    //
    PVOID       m_pvBufferLast;

    // The bindname for the component.  This is built from BindForm,
    // Class, Character, ServiceName, InfId, and InstanceGuid.
    // It is a seaparate allocation made with LocalAlloc (because
    // FormatMessage is used to build it.)  Freed with LocalFree.
    //
    PCWSTR      m_pszBindName;

    // The result of HrEnsureExternalDataLoaded.  It is saved, so that on
    // subsequent calls, we return the same result we did the first time.
    //
    HRESULT     m_hrLoadResult;

    // FALSE until HrEnsureExternalDataLoaded is called.  TRUE thereafter
    // which prevents HrEnsureExternalDataLoaded from hitting the registry
    // again.  Indicates all of the other members are cached and valid.
    //
    BOOLEAN     m_fInitialized;

private:
    HRESULT
    HrLoadData (
        IN HKEY hkeyInstance,
        OUT BYTE* pbBuf OPTIONAL,
        IN OUT ULONG* pcbBuf);

    VOID
    FreeDescription ();

    VOID
    FreeExternalData ();

public:
    ~CExternalComponentData ()
    {
        FreeExternalData ();
    }

    HRESULT
    HrEnsureExternalDataLoaded ();

    HRESULT
    HrReloadExternalData ();

    HRESULT
    HrSetDescription (
        PCWSTR pszNewDescription);

    BOOL
    FHasNotifyObject () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return (NULL != m_pNotifyObjectClsid);
    }

    BOOL
    FLoadedOkayIfLoadedAtAll () const;

    const CLSID*
    PNotifyObjectClsid () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        AssertH (m_pNotifyObjectClsid);
        return m_pNotifyObjectClsid;
    }

    PCWSTR
    PszAtOffset (
        IN UINT unOffset) const
    {
        AssertH (
            (ECD_OFFSET(m_pszDescription) == unOffset) ||
            (ECD_OFFSET(m_pszService) == unOffset) ||
            (ECD_OFFSET(m_pszBindForm) == unOffset) ||
            (ECD_OFFSET(m_pszHelpText) == unOffset) ||
            (ECD_OFFSET(m_pszLowerRange) == unOffset) ||
            (ECD_OFFSET(m_pszUpperRange) == unOffset) ||
            (ECD_OFFSET(m_pszBindName) == unOffset));

        PCWSTR psz;
        psz = *(PCWSTR*)((BYTE*)this + unOffset);

        AssertH (
            (m_pszDescription == psz) ||
            (m_pszService == psz) ||
            (m_pszBindForm == psz) ||
            (m_pszHelpText == psz) ||
            (m_pszLowerRange == psz) ||
            (m_pszLowerRange == psz) ||
            (m_pszBindName == psz));

        return psz;
    }

    PCWSTR
    PszBindForm () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszBindForm;
    }

    PCWSTR
    PszBindName () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        AssertH (m_pszBindName && *m_pszBindName);
        return m_pszBindName;
    }

    PCWSTR
    PszDescription () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszDescription;
    }

    PCWSTR
    PszHelpText () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszHelpText;
    }

    PCWSTR
    PszService () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszService;
    }

    PCWSTR
    PszCoServices () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pmszCoServices;
    }

    PCWSTR
    PszFilterMediaTypes () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszFilterMediaTypes;
    }

    PCWSTR
    PszLowerRange () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return (m_pszLowerRange) ? m_pszLowerRange : L"";
    }

    PCWSTR
    PszLowerExclude () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszLowerExclude;
    }

    PCWSTR
    PszUpperRange () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return (m_pszUpperRange) ? m_pszUpperRange : L"";
    }

#if DBG
    BOOL DbgIsExternalDataLoaded () const
    {
        return m_fInitialized && (S_OK == m_hrLoadResult);
    }
    VOID DbgVerifyExternalDataLoaded () const
    {
        AssertH (DbgIsExternalDataLoaded());
    }
#else
    BOOL DbgIsExternalDataLoaded () const { return TRUE; }
    VOID DbgVerifyExternalDataLoaded () const {}
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\file.cpp ===
#include "pch.h"
#pragma hdrstop

#include "file.h"
#include "ncsetup.h"

//+---------------------------------------------------------------------------
//
//  Parse the specified INF section which corresponds to a component's
//  defintion. Return the upper-range and lower-range that the component
//  can bind over.
//  e.g. a section like:
//      [Tcpip]
//      UpperRange = "tdi"
//      LowerRange = "ndis5,ndis4,ndisatm,ndiswanip,ndis5_ip"
//
//  Arguments:
//      inf            [in]
//      pszSection     [in]
//      pstrUpperRange [out]
//      pstrLowerRange [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   25 Oct 1998
//
//  Notes:
//
HRESULT
HrParseComponentSection (
    IN  HINF        inf,
    IN  PCWSTR     pszSection,
    OUT tstring*    pstrUpperRange,
    OUT tstring*    pstrLowerRange)
{
    HRESULT hr;

    // Initialize the output parameters.
    //
    pstrUpperRange->erase();
    pstrLowerRange->erase();

    // Get the UpperRange string.  It is a set of comma-separated sub-strings.
    //
    hr = HrSetupGetFirstString (
            inf,
            pszSection,
            L"UpperRange",
            pstrUpperRange);

    if (S_OK == hr)
    {
        if (0 == _wcsicmp (L"noupper", pstrUpperRange->c_str()))
        {
            pstrUpperRange->erase();
        }
    }
    else if (SPAPI_E_LINE_NOT_FOUND != hr)
    {
        goto finished;
    }

    // Get the LowerRange string.  It is a set of comma-separated sub-strings.
    //
    hr = HrSetupGetFirstString (
            inf,
            pszSection,
            L"LowerRange",
            pstrLowerRange);

    if (S_OK == hr)
    {
        if (0 == _wcsicmp (L"nolower", pstrLowerRange->c_str()))
        {
            pstrLowerRange->erase();
        }
    }
    else if (SPAPI_E_LINE_NOT_FOUND == hr)
    {
        hr = S_OK;
    }

finished:

    TraceHr (ttidError, FAL, hr, FALSE, "HrParseComponentSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Initialize a CNetConfig instance by reading information from an
//  INF-style file.
//
//  Arguments:
//      pszFilepath [in]
//      pNetConfig  [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   25 Oct 1998
//
//  Notes:
//
HRESULT
HrLoadNetworkConfigurationFromFile (
    IN  PCTSTR      pszFilepath,
    OUT CNetConfig* pNetConfig)
{
    CSetupInfFile   inf;
    UINT            unErrorLine;
    HRESULT         hr;
    INFCONTEXT      ctx;

    // Open the answer file.  It will close itself in it's destructor.
    //
    hr = inf.HrOpen (
                pszFilepath, NULL,
                INF_STYLE_OLDNT | INF_STYLE_WIN4,
                &unErrorLine);

    if (S_OK == hr)
    {
        tstring strInfId;
        tstring strPnpId;
        tstring strUpperRange;
        tstring strLowerRange;
        BASIC_COMPONENT_DATA Data;
        CComponent* pComponent;

        // Find the [Components] section.  This is a list of all of
        // the components involved.
        //
        hr = HrSetupFindFirstLine (inf.Hinf(),
                L"Components",
                NULL,
                &ctx);

        // Process each line in this section by creating a CComponent instance
        // for it and inserting it into the list of components owned by
        // the CNetConfig instance we are initializing.
        //
        while (S_OK == hr)
        {
            ZeroMemory (&Data, sizeof(Data));

            // Get each string field into a local variable and create
            // a new CComponent instance if all succeed.
            //
            //hr = HrSetupGetStringField (ctx, 0, &strInstanceId);
            //if (S_OK != hr) goto finished;
            CoCreateGuid(&Data.InstanceGuid);

            hr = HrSetupGetStringField (ctx, 1, &strInfId);
            if (S_OK != hr) goto finished;
            Data.pszInfId = strInfId.c_str();

            hr = HrSetupGetIntField (ctx, 2, (INT*)&Data.Class);
            if (S_OK != hr) goto finished;

            hr = HrSetupGetIntField (ctx, 3, (INT*)&Data.dwCharacter);
            if (S_OK != hr) goto finished;

            hr = HrSetupGetStringField (ctx, 4, &strPnpId);
            if (S_OK != hr) goto finished;
            Data.pszPnpId = strPnpId.c_str();

            hr = HrParseComponentSection (inf.Hinf(), strInfId.c_str(),
                    &strUpperRange, &strLowerRange);
            if (S_OK != hr) goto finished;
            //Data.pszUpperRange = strUpperRange.c_str();
            //Data.pszLowerRange = strLowerRange.c_str();

            hr = CComponent::HrCreateInstance(
                    &Data,
                    CCI_DEFAULT,
                    NULL,
                    &pComponent);

            if (S_OK == hr)
            {
                hr = pNetConfig->Core.Components.HrInsertComponent (
                        pComponent, INS_NON_SORTED);
            }

            // S_FALSE returned if there is no next line.
            //
            hr = HrSetupFindNextMatchLine (ctx, NULL, &ctx);
        }
    }

    if (SUCCEEDED(hr))
    {
        CComponentList* pComponents = &pNetConfig->Core.Components;
        ULONG       ulUpperIndex;
        ULONG       ulLowerIndex;
        CStackEntry StackEntry;

        // Find the [StackTable] section.  This is a list of how the
        // components are "stacked" on each other.
        //
        hr = HrSetupFindFirstLine (inf.Hinf(),
                L"StackTable",
                NULL,
                &ctx);

        // Process each line in this section by initialzing a CStackEntry
        // structure and inserting a copy of it into the stack table
        // maintained by the CNetConfig instance we are initializing.
        //
        while (S_OK == hr)
        {
            hr = HrSetupGetIntField (ctx, 0, (INT*)&ulUpperIndex);
            if (S_OK != hr) goto finished;

            hr = HrSetupGetIntField (ctx, 1, (INT*)&ulLowerIndex);
            if (S_OK != hr) goto finished;

            StackEntry.pUpper = pComponents->PGetComponentAtIndex (
                                    ulUpperIndex);

            StackEntry.pLower = pComponents->PGetComponentAtIndex (
                                    ulLowerIndex);

            hr = pNetConfig->Core.StackTable.HrInsertStackEntry (
                    &StackEntry, INS_SORTED);
            if (S_OK != hr) goto finished;

            // S_FALSE returned if there is no next line.
            //
            hr = HrSetupFindNextMatchLine (ctx, NULL, &ctx);
        }
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        pNetConfig->Core.DbgVerifyData();
    }

finished:
    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadNetworkConfigurationFromFile");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\file.h ===
#pragma once
#include "netcfg.h"

HRESULT
HrLoadNetworkConfigurationFromFile (
    IN  PCTSTR      pszFilepath,
    OUT CNetConfig* pNetConfig);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\filtdevs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       F I L T D E V S . H
//
//  Contents:   Implements the basic datatype for a collection of filter
//              devices.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "filtdev.h"
#include "ncsetup.h"
#include "netcfg.h"

// Filter devices is a collection of pointers to CFilterDevice.
//
class CFilterDevices : public vector<CFilterDevice*>
{
friend class CRegistryBindingsContext;

private:
    CNetConfigCore* m_pCore;

    CComponentList  m_Filters;

    HDEVINFO        m_hdi;

    // This multi-sz is read from the registry (Control\Network\FilterClasses)
    // and defines the order in which filters stack up.  Each filter INF
    // specifies Ndi\FilterClass which matches a string in this list.  In
    // the event that the string does not match any in the list, it is added
    // to the top of the list.  (Top was chosen arbitrarily.)
    //
    PWSTR           m_pmszFilterClasses;

public:
    // When filters are installed or removed (or we see that a filter is
    // no longer active or newly active over an adapter as in the case of
    // disabling the binding between the filter and an adapter) we add the
    // upper bindings of the adapter to this binding set.
    // These bindings will be unbound before we start the filter devices.
    // This breaks the filter chain and allows NDIS to properly reconstruct
    // it when the new devices are started.
    // Then these bindings will be added to the set of added bindpaths in
    // CModifyContext::ApplyChanges and hence will be sent BIND
    // notifications.  This has to happen so that the protocol(s)
    // bound to the adapter get dynamically rebound after they have been
    // implicitly unbound due to the filter device removal.
    //
    CBindingSet     m_BindPathsToRebind;

private:
    HRESULT
    HrInsertFilterDevice (
        IN CFilterDevice* pDevice);

    HRESULT
    HrLoadFilterDevice (
        IN SP_DEVINFO_DATA* pdeid,
        IN HKEY hkeyInstance,
        IN PCWSTR pszFilterInfId,
        OUT BOOL* pfRemove);

    DWORD
    MapFilterClassToOrdinal (
        IN PCWSTR pszFilterClass);

    CFilterDevice*
    PFindFilterDeviceByAdapterAndFilter (
        IN const CComponent* pAdapter,
        IN const CComponent* pFilter) const;

    CFilterDevice*
    PFindFilterDeviceByInstanceGuid (
        IN PCWSTR pszInstanceGuid) const;

public:
    CFilterDevices (
        IN CNetConfigCore* pCore);

    ~CFilterDevices ();

    HRESULT
    HrPrepare ();

    VOID
    Free ();

    VOID
    LoadAndRemoveFilterDevicesIfNeeded ();

    VOID
    InstallFilterDevicesIfNeeded ();

    VOID
    SortForWritingBindings ();

    VOID
    StartFilterDevices ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\filtdev.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       F I L T D E V . H
//
//  Contents:   Implements the object that represents filter devices.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"

class CFilterDevice
{
public:
    // The component which represents the adapter this filter device
    // filters.
    //
    CComponent*     m_pAdapter;

    // The component which represents the filter service itself.
    //
    CComponent*     m_pFilter;

    // The device info data for this filter device.
    // (Referencing HDEVINFO is kept external and is valid for the life of
    // these objects.)
    //
    SP_DEVINFO_DATA     m_deid;

    // The instance guid of the device in string form.
    // Assigned by the class installer when the device is installed.
    // This guid is stored in the instance key of the device under
    // 'NetCfgInstanceId'.  It is used to form the bind strings to
    // this device.
    //
    WCHAR   m_szInstanceGuid [c_cchGuidWithTerm];

private:
    // Declare all constructors private so that no one except
    // HrCreateInstance can create instances of this class.
    //
    CFilterDevice () {}

public:
    ~CFilterDevice () {}

    bool
    operator< (
        const CFilterDevice& OtherPath) const;

    static
    HRESULT
    HrCreateInstance (
        IN CComponent* pAdapter,
        IN CComponent* pFilter,
        IN const SP_DEVINFO_DATA* pdeid,
        IN PCWSTR pszInstanceGuid,
        OUT CFilterDevice** ppFilterDevice);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\filtdevs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       F I L T D E V S . C P P
//
//  Contents:   Implements the basic datatype for a collection of filter
//              devices.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "classinst.h"
#include "filtdevs.h"
#include "nceh.h"
#include "ncreg.h"
#include "ncstl.h"
#include "ncsetup.h"


CFilterDevices::CFilterDevices (
    IN CNetConfigCore* pCore)
{
    Assert (pCore);

    ZeroMemory (this, sizeof(*this));

    m_pCore = pCore;
}

CFilterDevices::~CFilterDevices ()
{
    // Free had better have been called before this.
    //
    Assert (this);
    Assert (!m_hdi);
    Assert (!m_pmszFilterClasses);
    Assert (empty());
}

HRESULT
CFilterDevices::HrInsertFilterDevice (
    IN CFilterDevice* pDevice)
{
    HRESULT hr;

    Assert (this);
    Assert (pDevice);

    // Assert there is not already a device in the list with the
    // same instance guid.
    //
    Assert (!PFindFilterDeviceByInstanceGuid (pDevice->m_szInstanceGuid));

    // Assert there is not already a device in the list with the
    // same parent filter AND the same filtered adapter.
    //
    Assert (!PFindFilterDeviceByAdapterAndFilter (
                pDevice->m_pAdapter,
                pDevice->m_pFilter));

    NC_TRY
    {
        push_back (pDevice);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CFilterDevices::HrInsertFilterDevice");
    return hr;
}

HRESULT
CFilterDevices::HrPrepare ()
{
    HRESULT hr;
    HKEY hkeyNetwork;

    // Reserve room for 8 different filters in our internal member.
    // We use this component list at various times as "scratch space" when
    // figuring out which filters are enabled for an adapter.
    //
    hr = m_Filters.HrReserveRoomForComponents (8);
    if (S_OK != hr)
    {
        goto finished;
    }

    hr = m_BindPathsToRebind.HrReserveRoomForBindPaths (8);
    if (S_OK != hr)
    {
        goto finished;
    }

    // Load the FilterClasses multi-sz.
    //

    hr = HrOpenNetworkKey (KEY_READ, &hkeyNetwork);

    if (S_OK == hr)
    {
        hr = HrRegQueryMultiSzWithAlloc (
                hkeyNetwork,
                L"FilterClasses",
                &m_pmszFilterClasses);

        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            Assert (!m_pmszFilterClasses);
            hr = S_OK;
        }

        RegCloseKey (hkeyNetwork);
    }

finished:

    TraceHr (ttidError, FAL, hr, FALSE, "CFilterDevices::HrPrepare");
    return hr;
}

CFilterDevice*
CFilterDevices::PFindFilterDeviceByAdapterAndFilter (
    IN const CComponent* pAdapter,
    IN const CComponent* pFilter) const
{
    const_iterator  iter;
    CFilterDevice*  pDevice;

    Assert (this);
    Assert (pAdapter);
    Assert (pFilter);
    Assert (FIsEnumerated(pAdapter->Class()));
    Assert (NC_NETSERVICE == pFilter->Class());
    Assert (pFilter->FIsFilter());

    for (iter = begin(); iter != end(); iter++)
    {
        pDevice = *iter;
        Assert (pDevice);

        if ((pAdapter == pDevice->m_pAdapter) &&
            (pFilter  == pDevice->m_pFilter))
        {
            return pDevice;
        }
    }

    return NULL;
}

DWORD
CFilterDevices::MapFilterClassToOrdinal (
    IN PCWSTR pszFilterClass)
{
    DWORD Ordinal;
    DWORD dwIndex;
    DWORD cStrings;

    Assert (pszFilterClass);
#if DBG
    Ordinal = 0;
#endif

    // If the class is found in the list, return its position.
    //
    if (FGetSzPositionInMultiSzSafe (
            pszFilterClass,
            m_pmszFilterClasses,
            &dwIndex,
            NULL,
            &cStrings))
    {
        Ordinal = dwIndex + 1;
    }
    else
    {
        HRESULT hr;
        PWSTR pmszNew;
        BOOL fChanged;

        // We're adding another string, so compute the new ordinal value
        // for return.
        //
        Ordinal = cStrings + 1;

        // String was not found, so we append it at the end.
        // It is important to insert at the end so we don't have to
        // change the ordinals of any existing filters that already
        // had their ordinal computed.
        //
        hr = HrAddSzToMultiSz (pszFilterClass, m_pmszFilterClasses,
                STRING_FLAG_ENSURE_AT_END, 0, &pmszNew, &fChanged);

        if (S_OK == hr)
        {
            HKEY hkeyNetwork;

            // It better have changed because we didn't find the string
            // above.
            //
            Assert (fChanged);

            // Out with the old. In with the new.
            //
            MemFree (m_pmszFilterClasses);
            m_pmszFilterClasses = pmszNew;

            // Save it back to the registry.
            //
            hr = HrOpenNetworkKey (KEY_WRITE, &hkeyNetwork);

            if (S_OK == hr)
            {
                hr = HrRegSetMultiSz (
                        hkeyNetwork,
                        L"FilterClasses",
                        m_pmszFilterClasses);

                Assert (S_OK == hr);

                RegCloseKey (hkeyNetwork);
            }
        }
    }

    // By definition, Ordinal is 1-based.  This is so that when stored
    // in CComponent, we know we have to load the filter class and get
    // its ordinal if CComponent::FilterClassOrdinal is zero.  i.e. zero
    // is a sentinel value that means we need to do work and when non-zero
    // means we don't have to do that work again.
    //
    Assert (Ordinal != 0);
    return Ordinal;
}

CFilterDevice*
CFilterDevices::PFindFilterDeviceByInstanceGuid (
    IN PCWSTR pszInstanceGuid) const
{
    const_iterator  iter;
    CFilterDevice*  pDevice;

    Assert (this);
    Assert (pszInstanceGuid && *pszInstanceGuid);

    for (iter = begin(); iter != end(); iter++)
    {
        pDevice = *iter;
        Assert (pDevice);

        if (0 == wcscmp(pszInstanceGuid, pDevice->m_szInstanceGuid))
        {
            return pDevice;
        }
    }

    return NULL;
}

HRESULT
CFilterDevices::HrLoadFilterDevice (
    IN SP_DEVINFO_DATA* pdeid,
    IN HKEY hkeyInstance,
    IN PCWSTR pszFilterInfId,
    OUT BOOL* pfRemove)
{
    HRESULT hr;
    CComponent* pAdapter;
    CComponent* pFilter;
    WCHAR szInstanceGuid [c_cchGuidWithTerm];
    DWORD cbBuffer;

    Assert (pszFilterInfId && *pszFilterInfId);
    Assert (pfRemove);

    *pfRemove = FALSE;

    // Initialize these to NULL.  If we don't find them below, they will
    // remain NULL and this will tell us something.
    //
    pAdapter = NULL;
    pFilter = NULL;

    cbBuffer = sizeof(szInstanceGuid);
    hr = HrRegQuerySzBuffer (
            hkeyInstance,
            L"NetCfgInstanceId",
            szInstanceGuid, &cbBuffer);

    if (S_OK == hr)
    {
        HKEY hkeyLinkage;

        // Read the RootDevice registry value for this filter device.  The
        // last entry in that multi-sz will be the bindname of the adapter
        // being filtered.
        //
        hr = HrRegOpenKeyEx (
                hkeyInstance,
                L"Linkage",
                KEY_READ,
                &hkeyLinkage);

        if (S_OK == hr)
        {
            PWSTR pmszRootDevice;

            hr = HrRegQueryMultiSzWithAlloc (
                    hkeyLinkage,
                    L"RootDevice",
                    &pmszRootDevice);

            if (S_OK == hr)
            {
                PCWSTR pszScan;
                PCWSTR pszLastDevice = NULL;

                // Scan to the last string in the multi-sz and note it.
                //
                for (pszScan = pmszRootDevice;
                     *pszScan;
                     pszScan += wcslen(pszScan) + 1)
                {
                    pszLastDevice = pszScan;
                }

                // The last string in the multi-sz is the bindname of the
                // adapter being filtered.
                //
                if (pszLastDevice)
                {
                    pAdapter = m_pCore->Components.PFindComponentByBindName (
                                                    NC_NET, pszLastDevice);
                    if (!pAdapter)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
                    }
                }

                MemFree (pmszRootDevice);
            }

            RegCloseKey (hkeyLinkage);
        }

        if (S_OK == hr)
        {
            // Should have the adapter if no error.
            //
            Assert (pAdapter);

            // Get the enabled filters for the adapter.
            //
            hr = m_pCore->HrGetFiltersEnabledForAdapter (pAdapter, &m_Filters);
            if (S_OK == hr)
            {
                // Use pszFilterInfId to find the parent filter component for
                // this filter device.  If it is not found, it probably means
                // the entire filter is in the process of being removed.
                // (Or the registry was messed with.)
                //
                pFilter = m_pCore->Components.PFindComponentByInfId (
                                                pszFilterInfId, NULL);

                // If the filter corresponding to this device is still
                // installed and is enabled over the adapter, then we'll
                // insert the device into our list.  Otherwise, we're going
                // to remove it.
                //
                if (pFilter && m_Filters.FComponentInList (pFilter))
                {
                    CFilterDevice* pFilterDevice;

                    // Create an instance of the filter device class to
                    // represent this filter device.
                    //
                    hr = CFilterDevice::HrCreateInstance (
                            pAdapter,
                            pFilter,
                            pdeid,
                            szInstanceGuid,
                            &pFilterDevice);

                    if (S_OK == hr)
                    {
                        // Add the filter device to our list of filter devices.
                        //
                        hr = HrInsertFilterDevice (pFilterDevice);

                        if (S_OK != hr)
                        {
                            delete pFilterDevice;
                        }
                    }
                }
                else
                {
                    *pfRemove = TRUE;

                    Assert (pszFilterInfId && *pszFilterInfId);
                    Assert (pAdapter);

                    g_pDiagCtx->Printf (ttidBeDiag,
                        "   Removing filter device for %S over %S adapter\n",
                        pszFilterInfId,
                        pAdapter->m_pszPnpId);

                    // Since we will be removing a filter device from the
                    // chain, we need to rebind the protocols above the
                    // adapter we are removing the filter device for.
                    //
                    // So, get the upper bindings of the adapter (bindpaths
                    // are only 2 levels deep) and add them to the bind set
                    // that we will rebind later on.
                    //
                    hr = m_pCore->HrGetComponentUpperBindings (
                            pAdapter,
                            GBF_ADD_TO_BINDSET | GBF_PRUNE_DISABLED_BINDINGS,
                            &m_BindPathsToRebind);
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr,
        "CFilterDevices::HrLoadFilterDevice");
    return hr;
}

VOID
CFilterDevices::LoadAndRemoveFilterDevicesIfNeeded ()
{
    HRESULT hr;
    SP_DEVINFO_DATA deid;
    DWORD dwIndex;
    DWORD cbBuffer;
    WCHAR szFilterInfId [_MAX_PATH];

    Assert (this);
    Assert (m_pCore);
    Assert (!m_hdi);
    Assert (empty());

    // Filter devices can only be of net class.
    //
    hr = HrSetupDiGetClassDevs (&GUID_DEVCLASS_NET, NULL, NULL,
            DIGCF_PROFILE, &m_hdi);

    if (S_OK != hr)
    {
        return;
    }

    Assert (m_hdi);

    // Enumerate all net class devices from setupapi.
    //
    for (dwIndex = 0; S_OK == hr; dwIndex++)
    {
        hr = HrSetupDiEnumDeviceInfo (m_hdi, dwIndex, &deid);

        if (S_OK == hr)
        {
            HKEY hkeyInstance;

            hr = HrSetupDiOpenDevRegKey (
                    m_hdi, &deid,
                    DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                    KEY_READ, &hkeyInstance);

            if (S_OK == hr)
            {
                // If the device has a "FilterInfId" value under its
                // instance key, its one of ours.
                //
                cbBuffer = sizeof(szFilterInfId);
                hr = HrRegQuerySzBuffer (
                        hkeyInstance,
                        L"FilterInfId",
                        szFilterInfId,
                        &cbBuffer);

                if (S_OK == hr)
                {
                    BOOL fRemove;

                    // Load the rest of the filter device, and add it to
                    // our list.  If this fails for any reason, remove the
                    // filter device because its of no use to us anymore.
                    //
                    hr = HrLoadFilterDevice (
                            &deid,
                            hkeyInstance,
                            szFilterInfId,
                            &fRemove);

                    if ((S_OK != hr) || fRemove)
                    {
                        if (S_OK != hr)
                        {
                            g_pDiagCtx->Printf (ttidBeDiag,
                                "   Removing filter device for %S\n",
                                szFilterInfId);
                        }

                        (VOID) HrCiRemoveFilterDevice (m_hdi, &deid);
                        hr = S_OK;
                    }
                }

                //else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                //{
                    // Not a filter device.  Skip it.
                //}

                RegCloseKey (hkeyInstance);
            }

            // Allow the loop to continue;
            //
            hr = S_OK;
        }
    }
    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    g_pDiagCtx->Printf (ttidBeDiag, "   Loaded %d filter devices\n", size());
}

VOID
CFilterDevices::InstallFilterDevicesIfNeeded ()
{
    HRESULT hr;
    CComponentList::iterator iterAdapter;
    CComponentList::iterator iterFilter;
    CComponent* pAdapter;
    CComponent* pFilter;
    HKEY hkeyInstance;
    HKEY hkeyNdi;
    DWORD cbBuffer;
    BOOL fAddDevice;
    BOOL fAddedDeviceForAdapter;
    WCHAR szFilterDeviceInfId [_MAX_PATH];
    WCHAR szFilterClass [_MAX_PATH];

    Assert (this);
    Assert (m_pCore);

    // If, for some reason, we couldn't get m_hdi up in
    // RemoveFilterDevicesIfNeeded, we can't proceed.
    //
    if (!m_hdi)
    {
        return;
    }

    // For all adapters (because filters possibly bind to any adapter)
    // we get the filters enabled for each.  For each on of these filters
    // that don't already have an associated filter device for the adapter,
    // we create a new one and associated it.
    //
    for (iterAdapter  = m_pCore->Components.begin();
         iterAdapter != m_pCore->Components.end();
         iterAdapter++)
    {
        pAdapter = *iterAdapter;
        Assert (pAdapter);

        // Skip components that are not network adapters.
        //
        if (NC_NET != pAdapter->Class())
        {
            continue;
        }

        hr = m_pCore->HrGetFiltersEnabledForAdapter (pAdapter, &m_Filters);

        if (S_OK != hr)
        {
            // More than likely, we are out of memory.
            //
            TraceHr (ttidError, FAL, hr, FALSE,
                "HrGetFiltersEnabledForAdapter failed in "
                "InstallFilterDevicesIfNeeded. Adapter=%S",
                pAdapter->m_pszPnpId);
            break;
        }

        // We haven't yet added any devices for this adapter.
        //
        fAddedDeviceForAdapter = FALSE;

        // For each of the filters enabled for this adapter, install
        // a filter device if needed and make sure the filter has its
        // ordinal position with respect other filters read from the
        // registry.  We need m_dwFilterClassOrdinal to be valid (non-zero)
        // before we sort the filter devices when writing their bindings.
        //
        for (iterFilter  = m_Filters.begin();
             iterFilter != m_Filters.end();
             iterFilter++)
        {
            pFilter = *iterFilter;
            Assert (pFilter);

            // If there isn't a filter device for the current adapter
            // and filter, we need to install one.
            //
            fAddDevice = !PFindFilterDeviceByAdapterAndFilter (
                            pAdapter, pFilter);

            // If we don't need to add a filter device and we already
            // have the ordinal position of the filter, we can continue with
            // the next filter for this adapter.
            //
            if (!fAddDevice && (0 != pFilter->m_dwFilterClassOrdinal))
            {
                continue;
            }

            *szFilterDeviceInfId = 0;

            // Open the instance key of the filter so we can read
            // a few values.
            //
            hr = pFilter->HrOpenInstanceKey (KEY_READ, &hkeyInstance,
                    NULL, NULL);

            if (S_OK == hr)
            {
                // Open the Ndi key.
                //
                hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi",
                        KEY_READ, &hkeyNdi);

                if (S_OK == hr)
                {
                    if (0 == pFilter->m_dwFilterClassOrdinal)
                    {
                        // Read the filter class and convert it to an
                        // ordinal based on its position in the
                        // filter classes list.
                        //
                        cbBuffer = sizeof(szFilterClass);

                        hr = HrRegQuerySzBuffer (hkeyNdi,
                                L"FilterClass",
                                szFilterClass,
                                &cbBuffer);

                        if (S_OK == hr)
                        {
                            pFilter->m_dwFilterClassOrdinal =
                                MapFilterClassToOrdinal (szFilterClass);
                        }
                    }

                    if (fAddDevice)
                    {
                        // Read the ind id of the filter device.
                        //
                        cbBuffer = sizeof(szFilterDeviceInfId);

                        hr = HrRegQuerySzBuffer (
                                hkeyNdi, L"FilterDeviceInfId",
                                szFilterDeviceInfId, &cbBuffer);
                    }

                    RegCloseKey (hkeyNdi);
                }

                RegCloseKey (hkeyInstance);
            }

            if ((S_OK == hr) && fAddDevice)
            {
                CFilterDevice* pFilterDevice;

                Assert (*szFilterDeviceInfId);

                g_pDiagCtx->Printf (ttidBeDiag,
                    "   Installing filter device for %S over %S adapter\n",
                    pFilter->m_pszInfId,
                    pAdapter->m_pszPnpId);


                hr = HrCiInstallFilterDevice (m_hdi,
                        szFilterDeviceInfId,
                        pAdapter,
                        pFilter,
                        &pFilterDevice);

                if (S_OK == hr)
                {
                    hr = HrInsertFilterDevice (pFilterDevice);
                    if (S_OK == hr)
                    {
                        fAddedDeviceForAdapter = TRUE;
                    }
                    else
                    {
                        delete pFilterDevice;
                    }
                }
            }
        }

        // If we added at least one filter device in the chain for this
        // adapter, we'll need to unbind the adapter from whatever it is
        // currently bound to before we start the filter device.
        //
        if (fAddedDeviceForAdapter)
        {
            // So, get the upper bindings of the adapter (bindpaths
            // are only 2 levels deep) and add them to the bind set
            // that we will rebind later on.
            //
            hr = m_pCore->HrGetComponentUpperBindings (
                    pAdapter,
                    GBF_ADD_TO_BINDSET | GBF_PRUNE_DISABLED_BINDINGS,
                    &m_BindPathsToRebind);
        }
    }
}

INT
__cdecl
CompareFilterDevices (
    const VOID* pv1,
    const VOID* pv2)
{
    CFilterDevice* pDevice1 = *((CFilterDevice**)pv1);
    CFilterDevice* pDevice2 = *((CFilterDevice**)pv2);

    if (pDevice1->m_pAdapter == pDevice2->m_pAdapter)
    {
        Assert (pDevice1->m_pFilter != pDevice2->m_pFilter);

        if (pDevice1->m_pFilter->m_dwFilterClassOrdinal ==
            pDevice2->m_pFilter->m_dwFilterClassOrdinal)
        {
            AssertSz (0, "We have two filters of the same class installed.");
            return 0;
        }

        return (pDevice1->m_pFilter->m_dwFilterClassOrdinal <
                pDevice2->m_pFilter->m_dwFilterClassOrdinal)
                    ? -1 : 1;
    }

    return (pDevice1->m_pAdapter < pDevice2->m_pAdapter) ? -1 : 1;

/*
    if (pDevice1->m_pFilter == pDevice2->m_pFilter)
    {
        Assert (pDevice1->m_pAdapter != pDevice2->m_pAdapter);

        return (pDevice1->m_pAdapter < pDevice2->m_pAdapter) ? -1 : 1;
    }

    if (pDevice1->m_pFilter->m_dwFilterClassOrdinal ==
        pDevice2->m_pFilter->m_dwFilterClassOrdinal)
    {
        AssertSz (0, "We have two filters of the same class installed.");
        return 0;
    }

    return (pDevice1->m_pFilter->m_dwFilterClassOrdinal <
            pDevice2->m_pFilter->m_dwFilterClassOrdinal)
                ? -1 : 1;
*/
}

VOID
CFilterDevices::SortForWritingBindings ()
{
    Assert (this);

    // If we're empty, there is nothing to do.
    //
    if (empty())
    {
        return;
    }

    qsort (begin(), size(), sizeof(CFilterDevice*), CompareFilterDevices);
}

VOID
CFilterDevices::StartFilterDevices ()
{
    HRESULT hr;
    CFilterDevices::reverse_iterator iter;
    CFilterDevice* pDevice;

    Assert (this);
    Assert (m_pCore);

    // If we're empty, there is nothing to do.
    //
    if (empty())
    {
        return;
    }

    // If we're not empty, we must have had m_hdi to insert something.
    //
    Assert (m_hdi);

    for (iter = rbegin(); iter != rend(); iter++)
    {
        pDevice = *iter;
        Assert (pDevice);

        g_pDiagCtx->Printf (ttidBeDiag, "   %S filter over %S adapter\n",
            pDevice->m_pFilter->m_pszInfId,
            pDevice->m_pAdapter->m_pszPnpId);

        hr = HrSetupDiSendPropertyChangeNotification (
                m_hdi,
                &pDevice->m_deid,
                DICS_START,
                DICS_FLAG_CONFIGSPECIFIC,
                0);

        if (S_OK != hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   Failed to start filter device for "
                "%S over %S adapter\n",
                pDevice->m_pFilter->m_pszInfId,
                pDevice->m_pAdapter->m_pszPnpId);
        }
    }
}

VOID
CFilterDevices::Free ()
{
    Assert (this);

    MemFree (m_pmszFilterClasses);
    m_pmszFilterClasses = NULL;

    SetupDiDestroyDeviceInfoListSafe (m_hdi);
    m_hdi = NULL;

    FreeCollectionAndItem (*this);

    // Do NOT free m_BindPathsToRebind.  This is used even after ApplyChanges
    // calls Free.
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\friendly.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       F R I E N D L Y . C P P
//
//  Contents:   Creates indexes for device installs and sets friendly
//              name descriptions based on the indexes.
//
//  Notes:
//
//  Author:     billbe   6 Nov 1998
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "adapter.h"
#include "classinst.h"
#include "ncmsz.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "util.h"


const WCHAR c_szRegValueInstanceIndex[] = L"InstanceIndex";

const DWORD c_cchIndexValueNameLen = 6;
const ULONG c_cMaxDescriptions = 10001; // SetupDi only allows 0-9999
const WCHAR c_szRegKeyDescriptions[] = L"Descriptions";

//+--------------------------------------------------------------------------
//
//  Function:   HrCiAddNextAvailableIndex
//
//  Purpose:    Adds the next available index to a multi-sz of indexes.
//
//  Arguments:
//      pmszIndexesIn  [in]    MultiSz of current indexes.
//      pulIndex       [inout] The index added.
//      ppmszIndexesOut[out]   New multiSz with the added index.
//
//  Returns:    HRESULT. S_OK is successful, a converted Win32 error otherwise
//
//  Author:     billbe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrCiAddNextAvailableIndex(PWSTR pmszIndexesIn, ULONG* pIndex,
        PWSTR* ppmszIndexesOut)
{
    Assert(pmszIndexesIn);
    Assert(ppmszIndexesOut);

    HRESULT          hr = S_OK;
    WCHAR            szIndex[c_cchIndexValueNameLen];

    // clear out param.
    *ppmszIndexesOut = NULL;

    // We are adding a new index.  Find the first available
    // index.
    //
    ULONG Index;
    ULONG NextIndex;
    PWSTR pszStopString;
    PWSTR pszCurrentIndex = pmszIndexesIn;
    DWORD PositionInMultiSz = 0;
    for (NextIndex = 1; NextIndex < c_cMaxDescriptions;
            ++NextIndex)
    {
        Index = wcstoul(pszCurrentIndex, &pszStopString, c_nBase10);
        if (Index != NextIndex)
        {
            // We found an available index.  Now we insert it.
            //
            swprintf(szIndex, L"%u", NextIndex);
            BOOL fChanged;
            hr = HrAddSzToMultiSz(szIndex, pmszIndexesIn,
                    STRING_FLAG_ENSURE_AT_INDEX, PositionInMultiSz,
                    ppmszIndexesOut, &fChanged);

            AssertSz(fChanged,
                    "We were adding a new index. Something had to change!");
            break;
        }

        ++PositionInMultiSz;

        // Try the next index.
        pszCurrentIndex += wcslen(pszCurrentIndex) + 1;
    }

    // If we succeeded, set the output param.
    if (S_OK == hr)
    {
        *pIndex = NextIndex;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiAddNextAvailableIndex");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiCreateAndWaitForIndexListMutex
//
//  Purpose:    Creates Updates the description map by adding or removing
//              entries for pszDescription.
//
//  Arguments:
//      pszName     [in]  The name for this mutex.
//      phMutex     [out] The created mutex.
//
//  Returns:    HRESULT. S_OK is successful, a converted Win32 error otherwise
//
//  Author:     billbe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrCiCreateAndWaitForIndexListMutex(HANDLE* phMutex)
{
    Assert(phMutex);

    const WCHAR c_szMutexName[] = L"Global\\{84b06608-8026-11d2-b1f2-00c04fd912b2}";

    HRESULT hr = S_OK;

    // Create the mutex.
    hr = HrCreateMutexWithWorldAccess(c_szMutexName, FALSE,
            NULL, phMutex);

    if (S_OK == hr)
    {
        // Wait until the mutex is free or cMaxWaitMilliseconds seconds
        // have passed.
        //
        while (1)
        {
            const DWORD cMaxWaitMilliseconds = 30000;   // 30 seconds

            DWORD dwWait = MsgWaitForMultipleObjects (1, phMutex, FALSE,
                                cMaxWaitMilliseconds, QS_ALLINPUT);
            if ((WAIT_OBJECT_0 + 1) == dwWait)
            {
                // We have messages to pump.
                //
                MSG msg;
                while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                    DispatchMessage (&msg);
                }
            }
            else
            {
                // Wait is satisfied, or we had a timeout, or an error.
                //
                if (WAIT_TIMEOUT == dwWait)
                {
                    hr = HRESULT_FROM_WIN32 (ERROR_TIMEOUT);
                }
                else if (0xFFFFFFFF == dwWait)
                {
                    hr = HrFromLastWin32Error ();
                }

                break;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiCreateAndWaitForIndexListMutex");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiUpdateDescriptionIndexList
//
//  Purpose:    Updates the description map by adding or removing
//              entries for pszDescription.
//
//  Arguments:
//      pguidClass      [in]    The device's class guid
//      pszDescription  [in]    Description of the adapter
//      eOp             [in]    The operation to perform. DM_ADD to add
//                              an index, DM_DELETE to delete an index.
//      pulIndex        [inout] The index added if eOp was DM_ADD.
//                              The index to delete if eOp was DM_DELETE.
//
//  Returns:    HRESULT. S_OK is successful, a converted Win32 error otherwise
//
//  Author:     billbe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrCiUpdateDescriptionIndexList (
    IN NETCLASS Class,
    IN PCWSTR pszDescription,
    IN DM_OP eOp,
    IN OUT ULONG* pIndex)
{
    Assert(pszDescription);
    Assert(pIndex);
    Assert(FIsEnumerated(Class));

    // We don't want to update a decription's index list at the same time
    // as another process, so create a mutex and wait until it is available.
    //
    HANDLE hMutex = NULL;
    HRESULT hr = HrCiCreateAndWaitForIndexListMutex(&hMutex);

    if (S_OK == hr)
    {

        // Build the path to the description key
        // e.g. ...\Network\<net/infrared guid>\c_szRegKeyDescriptions
        //
        WCHAR szPath[_MAX_PATH];
        PCWSTR pszNetworkSubtreePath;

        pszNetworkSubtreePath = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];
        AssertSz (pszNetworkSubtreePath,
            "This class does not use the network subtree.");

        wcscpy (szPath, pszNetworkSubtreePath);
        wcscat (szPath, L"\\");
        wcscat (szPath, c_szRegKeyDescriptions);

        // Open/Create the description key
        //
        HKEY hkeyDescription;
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                szPath, 0, KEY_READ_WRITE_DELETE, NULL, &hkeyDescription, NULL);

        if (S_OK == hr)
        {
            // Get the description index list if it exists.
            //
            PWSTR pmszIndexesOld;

            hr = HrRegQueryMultiSzWithAlloc(
                    hkeyDescription,
                    pszDescription,
                    &pmszIndexesOld);

            // If we have the list...
            if (S_OK == hr)
            {
                // Perform the requested operation on the list.
                //

                PWSTR pmszBufferToSet = NULL;
                PWSTR pmszIndexesNew = NULL;

                if (DM_ADD == eOp)
                {
                    // We need to add a new index.
                    hr = HrCiAddNextAvailableIndex(pmszIndexesOld,
                            pIndex, &pmszIndexesNew);

                    pmszBufferToSet = pmszIndexesNew;
                }
                else if (DM_DELETE == eOp)
                {
                    // Delete the index from the list.
                    //
                    WCHAR szDelete[c_cchIndexValueNameLen];
                    BOOL fRemoved;
                    swprintf(szDelete, L"%u", *pIndex);
                    RemoveSzFromMultiSz(szDelete, pmszIndexesOld,
                            STRING_FLAG_REMOVE_SINGLE, &fRemoved);

                    // If something was removed, check to see if the
                    // index list is empty.  If it is, delete the
                    // registry value.
                    //
                    if (fRemoved)
                    {
                        ULONG cchIndexes = CchOfMultiSzSafe(pmszIndexesOld);
                        if (!cchIndexes)
                        {
                            // Index list is empty, delete the value.
                            HrRegDeleteValue(hkeyDescription, pszDescription);
                        }
                        else
                        {
                            // Something was removed and there are still
                            // index entries so we have a buffer to set in the
                            // registry.
                            pmszBufferToSet = pmszIndexesOld;
                        }
                    }
                }

                // If we succeeded and have a new list to set...
                //
                if ((S_OK == hr) && pmszBufferToSet)
                {
                    // Set the map back in the registry.
                    hr = HrRegSetMultiSz(hkeyDescription,
                            pszDescription, pmszBufferToSet);
                }

                MemFree(pmszIndexesNew);
                MemFree(pmszIndexesOld);
            }
            else if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) &&
                    (DM_ADD == eOp))
            {
                // There was no entry for this description so we need to
                // create one.
                //
                hr = HrRegAddStringToMultiSz(L"1", hkeyDescription,
                        NULL, pszDescription, STRING_FLAG_ENSURE_AT_FRONT, 0);

                if (S_OK == hr)
                {
                    *pIndex = 1;
                }
            }

            RegCloseKey(hkeyDescription);
        }

        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiUpdateDescriptionIndexList");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   CiSetFriendlyNameIfNeeded
//
//  Purpose:    Sets an instance index for the adapter.  If this adapter's
//              description already exists (i.e. another similar adapter
//              is installed), then a friendly name for this adapter will be
//              set using the current description appened with the instance
//              index.
//
//  Arguments:
//      cii [in] See classinst.h
//
//  Returns:    nothing
//
//  Author:     billbe   30 Oct 1998
//
//  Notes:  If previous adapter descriptions were Foo, Foo, Foo
//          They will have friendly names Foo, Foo #2, Foo #3
//
VOID
CiSetFriendlyNameIfNeeded(IN const COMPONENT_INSTALL_INFO& cii)
{
    Assert(IsValidHandle(cii.hdi));
    Assert(cii.pdeid);
    Assert(FIsEnumerated(cii.Class));
    Assert(cii.pszDescription);

    // Open the device parameters key.
    //
    HKEY hkeyDevice;
    HRESULT hr;

    hr = HrSetupDiCreateDevRegKey(cii.hdi, cii.pdeid,
            DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL, &hkeyDevice);

    if (S_OK == hr)
    {
        // Does this device already have an index?
        //
        DWORD Index;
        hr = HrRegQueryDword(hkeyDevice, c_szRegValueInstanceIndex, &Index);

        // This device doesn't have an index, so we need to give it one.
        //
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // Update the description map and get the new index.
            hr = HrCiUpdateDescriptionIndexList(cii.Class,
                    cii.pszDescription, DM_ADD, &Index);

            if (S_OK == hr)
            {
                // Store the index there so we can retrieve it when
                // the device is uninstalled and delete the index from
                // out table of indexes in use.
                (void) HrRegSetDword(hkeyDevice, c_szRegValueInstanceIndex,
                        Index);
            }
        }

        // The first index doesn't get a new name.
        // i.e. the following same named devices:
        //
        // foo, foo, foo
        //
        // become
        //
        // foo, foo #2, foo #3
        //
        if ((S_OK == hr) && (1 != Index) && !FIsFilterDevice(cii.hdi, cii.pdeid))
        {
            // Now build the new name of this device using the index
            // number.
            //
            // Note: It doesn't matter if we failed to open the driver key
            // above; we can still continue.  It only means that this index
            // cannot be reused if the device is deleted.
            //
            WCHAR szIndex[c_cchIndexValueNameLen];
            swprintf(szIndex, L"%u", Index);

            WCHAR szNewName[LINE_LEN + 1] = {0};
            wcsncpy(szNewName, cii.pszDescription,
                    LINE_LEN - c_cchIndexValueNameLen);
            wcscat(szNewName, L" #");
            wcscat(szNewName, szIndex);

            // Set the new name as the friendly name of the device
            hr = HrSetupDiSetDeviceRegistryProperty(cii.hdi,
                    cii.pdeid,
                    SPDRP_FRIENDLYNAME,
                    reinterpret_cast<const BYTE*>(szNewName),
                    CbOfSzAndTerm(szNewName));

        }

        RegCloseKey(hkeyDevice);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "FCiSetFriendlyNameIfNeeded");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ibind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I B I N D . C P P
//
//  Contents:   Implements the INetCfgBindingInterface and INetCfgBindingPath
//              COM interfaces.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ibind.h"
#include "ncvalid.h"
#include "netcfg.h"
#include "util.h"


//static
HRESULT
CImplINetCfgBindingInterface::HrCreateInstance (
    IN  CImplINetCfg* pINetCfg,
    IN  CImplINetCfgComponent* pUpper,
    IN  CImplINetCfgComponent* pLower,
    OUT INetCfgBindingInterface** ppv)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr = E_OUTOFMEMORY;

    CImplINetCfgBindingInterface* pObj;
    pObj = new CComObject <CImplINetCfgBindingInterface>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_pUpper = pUpper;
        pObj->m_pLower = pLower;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            hr = pObj->QueryInterface (IID_INetCfgBindingInterface,
                        (VOID**)ppv);

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                AddRefObj (pUpper->GetUnknown());
                AddRefObj (pLower->GetUnknown());
                pObj->HoldINetCfg (pINetCfg);
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterface::HrCreateInstance");
    return hr;
}

HRESULT
CImplINetCfgBindingInterface::HrLockAndTestForValidInterface (
    DWORD dwFlags)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    Lock();

    hr = m_pUpper->HrIsValidInterface (dwFlags);
    if (S_OK == hr)
    {
        hr = m_pLower->HrIsValidInterface (dwFlags);
    }

    if (S_OK != hr)
    {
        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterface::HrLockAndTestForValidInterface");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgBindingInterface
//

STDMETHODIMP
CImplINetCfgBindingInterface::GetName (
    OUT PWSTR* ppszInterfaceName)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppszInterfaceName))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszInterfaceName = NULL;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA);
        if (S_OK == hr)
        {
            CComponent*  pUpper = m_pUpper->m_pComponent;
            CComponent*  pLower = m_pLower->m_pComponent;
            const WCHAR* pch;
            ULONG        cch;

            if (pUpper->FCanDirectlyBindTo (pLower, &pch, &cch))
            {
                hr = HrCoTaskMemAllocAndDupSzLen (
                        pch, cch, ppszInterfaceName);
            }
            else
            {
                AssertSz(0, "Why no match if we have a binding interface "
                    "created for these components?");
                hr = E_UNEXPECTED;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterface::GetName");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingInterface::GetUpperComponent (
    OUT INetCfgComponent** ppComp)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppComp))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppComp = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            AddRefObj (m_pUpper->GetUnknown());
            *ppComp = m_pUpper;

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterfaceGetName::GetUpperComponent");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingInterface::GetLowerComponent (
    OUT INetCfgComponent** ppComp)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppComp))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppComp = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            AddRefObj (m_pLower->GetUnknown());
            *ppComp = m_pLower;

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterfaceGetName::GetLowerComponent");
    return hr;
}


//static
HRESULT
CImplINetCfgBindingPath::HrCreateInstance (
    IN CImplINetCfg* pINetCfg,
    IN const CBindPath* pBindPath,
    OUT INetCfgBindingPath** ppIPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;
    ULONG ulDepth;
    ULONG cbArray;
    CComponent* pComponent;
    CImplINetCfgBindingPath* pObj;

    Assert (pINetCfg);
    Assert (pBindPath);
    Assert (ppIPath);

    // Caller's are responsible for ensuring that if an interface is about
    // to be handed out, and the external data has been loaded, that the
    // data has been loaded successfully.  If we handed out an interface
    // and the data was NOT loaded successfully, it just means we are doomed
    // to fail later when the client of the interface calls a method that
    // requires that data.
    //
    Assert (pBindPath->FAllComponentsLoadedOkayIfLoadedAtAll());

    hr = E_OUTOFMEMORY;
    pObj = new CComObject <CImplINetCfgBindingPath>;

    if (pObj)
    {
        // Initialize our members.
        //

        ulDepth = pBindPath->CountComponents();
        cbArray = ulDepth * sizeof(INetCfgComponent*);

        AssertSz (0 != ulDepth, "Why are we being asked to expose an empty bindpath?");
        AssertSz (1 != ulDepth, "Why are we being asked to expose a bindpath with only one component?");

        // If the bindpath has more components than our static
        // array has room for, we'll have to use an allocated array.
        //
        if (cbArray > sizeof(pObj->m_apIComp))
        {
            // Ensure failure of MemAlloc causes us to return the correct
            // error code.  (Should be set above and not changed between.)
            //
            Assert (E_OUTOFMEMORY == hr);

            pObj->m_papIComp = (INetCfgComponent**) MemAlloc (cbArray);

            if (pObj->m_papIComp)
            {
                hr = S_OK;
            }
        }
        else
        {
            pObj->m_papIComp = pObj->m_apIComp;
            hr = S_OK;
        }

        // Now get each INetCfgComponent interface for the components in
        // the bindpath.
        //
        if (S_OK == hr)
        {
            UINT iComp;

            ZeroMemory (pObj->m_papIComp, cbArray);

            for (iComp = 0; iComp < ulDepth; iComp++)
            {
                pComponent = pBindPath->PGetComponentAtIndex (iComp);
                Assert (pComponent);

                hr = pComponent->HrGetINetCfgComponentInterface (
                        pINetCfg, pObj->m_papIComp + iComp);

                if (S_OK != hr)
                {
                    ReleaseIUnknownArray (iComp+1, (IUnknown**)pObj->m_papIComp);
                    break;
                }
            }
        }

        if (S_OK == hr)
        {
            pObj->m_cpIComp = ulDepth;

            // Do the standard CComCreator::CreateInstance stuff.
            //
            pObj->SetVoid (NULL);
            pObj->InternalFinalConstructAddRef ();
            hr = pObj->FinalConstruct ();
            pObj->InternalFinalConstructRelease ();

            if (S_OK == hr)
            {
                hr = pObj->QueryInterface (IID_INetCfgBindingPath,
                            (VOID**)ppIPath);

                // The last thing we do is addref any interfaces we hold.
                // We only do this if we are returning success.
                //
                if (S_OK == hr)
                {
                    pObj->HoldINetCfg (pINetCfg);
                }
            }
        }

        if (S_OK != hr)
        {
            if (pObj->m_papIComp != pObj->m_apIComp)
            {
				MemFree (pObj->m_papIComp);
            }

            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::HrCreateInstance");
    return hr;
}

HRESULT
CImplINetCfgBindingPath::HrIsValidInterface (
    IN DWORD dwFlags,
    OUT CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    hr = m_pINetCfg->HrIsValidInterface (dwFlags);

    if ((S_OK == hr) && pBindPath)
    {
        Assert (0 == pBindPath->CountComponents());

        // When pBindPath is specified, it means the caller wants a
        // CBindPath representation of the bindpath we represent.
        // We have to build this using the array of INetCfgComponent
        // pointer we maintain.  Do this by verifying each one is valid
        // and then adding its internal CComponent* to pBindPath.
        //
        hr = pBindPath->HrReserveRoomForComponents (m_cpIComp);

        if (S_OK == hr)
        {
            CImplINetCfgComponent* pIComp;
            CComponent* pComponent;

            // For each INetCfgComponent* in our array...
            //
            for (UINT i = 0; i < m_cpIComp; i++)
            {
                pIComp = (CImplINetCfgComponent*)m_papIComp[i];

                if (pIComp == NULL)
				{
					return(E_OUTOFMEMORY);
				}

                hr = pIComp->HrIsValidInterface (IF_DEFAULT);

                if (S_OK != hr)
                {
                    break;
                }

                pComponent = pIComp->m_pComponent;
                Assert (pComponent);

                hr = pBindPath->HrAppendComponent (pComponent);
                if (S_OK != hr)
                {
                    break;
                }
            }
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::HrIsValidInterface");
    return hr;
}

HRESULT
CImplINetCfgBindingPath::HrLockAndTestForValidInterface (
    IN DWORD dwFlags,
    OUT CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    Lock();

    hr = HrIsValidInterface (dwFlags, pBindPath);

    if (S_OK != hr)
    {
        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgHolder::HrLockAndTestForValidInterface");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgBindingPath
//

STDMETHODIMP
CImplINetCfgBindingPath::IsSamePathAs (
    IN INetCfgBindingPath* pIPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pIPath))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            CImplINetCfgBindingPath* pOther = (CImplINetCfgBindingPath*)pIPath;

            Assert (m_cpIComp);
            Assert (m_papIComp);
            Assert (pOther->m_cpIComp);
            Assert (pOther->m_papIComp);

            // Can't be the same if our length is not the same.
            //
            if (m_cpIComp != pOther->m_cpIComp)
            {
                hr = S_FALSE;
            }
            else
            {
                UINT cb;

                cb = m_cpIComp * sizeof(INetCfgComponent*);

                hr = (0 == memcmp (
                            (BYTE*)(m_papIComp),
                            (BYTE*)(pOther->m_papIComp),
                            cb)) ? S_OK : S_FALSE;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CImplINetCfgBindingPath::IsSamePathAs");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::IsSubPathOf (
    IN INetCfgBindingPath* pIPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pIPath))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            CImplINetCfgBindingPath* pOther = (CImplINetCfgBindingPath*)pIPath;

            Assert (m_cpIComp);
            Assert (m_papIComp);
            Assert (pOther->m_cpIComp);
            Assert (pOther->m_papIComp);

            // Can't be a subpath if our length is greater or equal.
            //
            if (m_cpIComp >= pOther->m_cpIComp)
            {
                hr = S_FALSE;
            }
            else
            {
                UINT cb;
                UINT unSkipComponents;

                cb = m_cpIComp * sizeof(INetCfgComponent*);

                Assert (pOther->m_cpIComp > m_cpIComp);
                unSkipComponents = pOther->m_cpIComp - m_cpIComp;

                hr = (0 == memcmp (
                            (BYTE*)(m_papIComp),
                            (BYTE*)(pOther->m_papIComp + unSkipComponents),
                            cb)) ? S_OK : S_FALSE;
            }

            // Special Case: NCF_DONTEXPOSELOWER
            // If we're about to return false, let's check for a case like:
            // is ms_ipx->adapter a subpath of ms_server->ms_ipx and return
            // TRUE.  For this case, it really is a subpath, but the binding
            // has been broken because of NCF_DONTEXPOSELOWER.
            //
            // If the last component of pIPath, and the first component of
            // this path both are NCF_DONTEXPOSELOWER, then consider this
            // path a subpath of pIPath.  This assumes that ms_nwipx and
            // ms_nwnb are the only components with this characteristic.
            //
            if (S_FALSE == hr)
            {
                CImplINetCfgComponent* pIFirst;
                CImplINetCfgComponent* pILast;

                pIFirst = (CImplINetCfgComponent*)m_papIComp[0];
                pILast = (CImplINetCfgComponent*)pOther->m_papIComp[pOther->m_cpIComp - 1];

				if ((pIFirst == NULL) ||
					(pILast == NULL))
				{
					return(E_OUTOFMEMORY);
				}

                if ((S_OK == pIFirst->HrIsValidInterface(IF_DEFAULT)) &&
                    (S_OK == pILast->HrIsValidInterface(IF_DEFAULT)))
                {
                    Assert (pIFirst->m_pComponent);
                    Assert (pILast->m_pComponent);

                    if ((pIFirst->m_pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER) &&
                        (pILast->m_pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER))
                    {
                        if (0 == wcscmp(L"ms_nwipx", pIFirst->m_pComponent->m_pszInfId))
                        {
                            hr = S_OK;
                        }
                        else if (pIFirst->m_pComponent == pILast->m_pComponent)
                        {
                            hr = S_OK;
                        }
                    }
                }
            }
            // End Special case

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CImplINetCfgBindingPath::IsSubPathOf");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::IsEnabled ()
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;
    CBindPath BindPath;

    hr = HrLockAndTestForValidInterface (IF_DEFAULT, &BindPath);
    if (S_OK == hr)
    {
        Assert (m_pINetCfg);

        if (m_pINetCfg->m_pNetConfig->Core.FIsBindPathDisabled (
                            &BindPath, IBD_MATCH_SUBPATHS_TOO))
        {
            hr = S_FALSE;
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgBindingPath::IsEnabled");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::Enable (
    IN BOOL fEnable)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;
    CBindPath BindPath;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK, &BindPath);
    if (S_OK == hr)
    {
        Assert (m_pINetCfg);

        hr = m_pINetCfg->m_pNetConfig->ModifyCtx.HrEnableOrDisableBindPath (
                    (fEnable) ? NCN_ENABLE : NCN_DISABLE,
                    &BindPath,
                    this);

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::Enable");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::GetPathToken (
    OUT PWSTR* ppszPathToken)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppszPathToken))
    {
        hr = E_POINTER;
    }
    else
    {
        CBindPath BindPath;

        *ppszPathToken = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, &BindPath);
        if (S_OK == hr)
        {
            ULONG cch;

            cch = 0;
            BindPath.FGetPathToken (NULL, &cch);
            if (cch)
            {
                hr = HrCoTaskMemAlloc (
                        ((cch + 1) * sizeof(WCHAR)),
                        (VOID**)ppszPathToken);

                if (S_OK == hr)
                {
                    BindPath.FGetPathToken (*ppszPathToken, &cch);
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::GetPathToken");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::GetOwner (
    OUT INetCfgComponent** ppIComp)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppIComp))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIComp = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            Assert (m_cpIComp);
            Assert (m_papIComp);
            Assert (m_papIComp[0]);

            AddRefObj (m_papIComp[0]);
            *ppIComp = m_papIComp[0];

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::GetOwner");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::GetDepth (
    OUT ULONG* pulDepth)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(pulDepth))
    {
        hr = E_POINTER;
    }
    else
    {
        *pulDepth = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            Assert (m_cpIComp);

            *pulDepth = m_cpIComp;

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::GetDepth");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::EnumBindingInterfaces (
    OUT IEnumNetCfgBindingInterface** ppIEnum)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppIEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIEnum = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            hr = CImplIEnumNetCfgBindingInterface::HrCreateInstance (
                    m_pINetCfg,
                    this,
                    ppIEnum);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::EnumBindingInterfaces");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\iatl.h ===
#pragma once

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\guisetup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       G U I S E T U P . H
//
//  Contents:   Routines that are only executed during GUI setup.
//
//  Notes:
//
//  Author:     shaunco   19 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"
#include "pszarray.h"

VOID
ExcludeMarkedServicesForSetup (
    IN const CComponent* pComponent,
    IN OUT CPszArray* pServiceNames);

VOID
ProcessAdapterAnswerFileIfExists (
    IN const CComponent* pComponent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\guisetup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       G U I S E T U P . C P P
//
//  Contents:   Routines that are only executed during GUI setup.
//
//  Notes:
//
//  Author:     shaunco   19 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "guisetup.h"
#include "nceh.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netcomm.h"
#include "netsetup.h"

VOID
ExcludeMarkedServicesForSetup (
    IN const CComponent* pComponent,
    IN OUT CPszArray* pServiceNames)
{
    HRESULT hr;
    HKEY hkeyInstance;
    HKEY hkeyNdi;
    PWSTR pmszExclude;
    CPszArray::iterator iter;
    PCWSTR pszServiceName;

    hr = pComponent->HrOpenInstanceKey (KEY_READ, &hkeyInstance, NULL, NULL);

    if (S_OK == hr)
    {
        hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

        if (S_OK == hr)
        {
            hr = HrRegQueryMultiSzWithAlloc (
                    hkeyNdi,
                    L"ExcludeSetupStartServices",
                    &pmszExclude);

            if (S_OK == hr)
            {
                iter = pServiceNames->begin();
                while (iter != pServiceNames->end())
                {
                    pszServiceName = *iter;
                    Assert (pszServiceName);

                    if (FIsSzInMultiSzSafe (pszServiceName, pmszExclude))
                    {
                        pServiceNames->erase (iter);
                    }
                    else
                    {
                        iter++;
                    }
                }

                MemFree (pmszExclude);
            }

            RegCloseKey (hkeyNdi);
        }

        RegCloseKey (hkeyInstance);
    }
}

VOID
ProcessAdapterAnswerFileIfExists (
    IN const CComponent* pComponent)
{
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;
    HRESULT hr;

    Assert (pComponent);

    hr = pComponent->HrOpenDeviceInfo (&hdi, &deid);
    if (S_OK == hr)
    {
        PWSTR pszAnswerFile = NULL;
        PWSTR pszAnswerSections = NULL;

        TraceTag (ttidNetcfgBase, "Calling Netsetup for Install parameters");

        NC_TRY
        {
            // Get the Network install params for the adapter
            //
            hr = HrGetAnswerFileParametersForNetCard (hdi, &deid,
                    pComponent->Ext.PszBindName(),
                    &pComponent->m_InstanceGuid,
                    &pszAnswerFile, &pszAnswerSections);
        }
        NC_CATCH_ALL
        {
            hr = E_UNEXPECTED;
        }

        if (S_OK == hr)
        {
#ifdef ENABLETRACE
            if (pszAnswerFile)
            {
                TraceTag (ttidNetcfgBase, "Answerfile %S given for adapter",
                          pszAnswerFile);
            }

            if (pszAnswerSections)
            {
                TraceTag (ttidNetcfgBase, "Section %S given for adapter",
                          pszAnswerSections);
            }
#endif // ENABLETRACE
            if (ProcessAnswerFile (pszAnswerFile, pszAnswerSections, hdi,
                    &deid))
            {
                hr = HrSetupDiSendPropertyChangeNotification (hdi, &deid,
                        DICS_PROPCHANGE, DICS_FLAG_GLOBAL, 0);
            }
        }
        // Cleanup up if necessary
        CoTaskMemFree (pszAnswerFile);
        CoTaskMemFree (pszAnswerSections);

        SetupDiDestroyDeviceInfoList (hdi);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\iclass.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I C L A S S . H
//
//  Contents:   Implements the INetCfgClass and INetCfgClassSetup COM
//              interfaces on the NetCfgClass sub-level COM object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "iatl.h"
#include "inetcfg.h"
#include "compdefs.h"
#include "netcfgx.h"


//+---------------------------------------------------------------------------
// INetCfgClass -
//
class ATL_NO_VTABLE CImplINetCfgClass :
    public CImplINetCfgHolder,
    public INetCfgClass,
    public INetCfgClassSetup
{
private:
    NETCLASS    m_Class;

public:
    CImplINetCfgClass ()
    {
        m_Class = NC_INVALID;
    }

    BEGIN_COM_MAP(CImplINetCfgClass)
        COM_INTERFACE_ENTRY(INetCfgClass)
        COM_INTERFACE_ENTRY(INetCfgClassSetup)
    END_COM_MAP()

    // INetCfgClass
    //
    STDMETHOD (FindComponent) (
        IN PCWSTR pszInfId,
        OUT INetCfgComponent** ppComp);

    STDMETHOD (EnumComponents) (
        OUT IEnumNetCfgComponent** ppIEnum);

    // INetCfgClassSetup
    //
    STDMETHOD (SelectAndInstall) (
        IN HWND hwndParent,
        IN OBO_TOKEN* pOboToken,
        OUT INetCfgComponent** ppIComp);

    STDMETHOD (Install) (
        IN PCWSTR pszwInfId,
        IN OBO_TOKEN* pOboToken,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo,
        IN PCWSTR pszAnswerFile,
        IN PCWSTR pszAnswerSection,
        OUT INetCfgComponent** ppIComp);

    STDMETHOD (DeInstall) (
        IN INetCfgComponent* pIComp,
        IN OBO_TOKEN* pOboToken,
        OUT PWSTR* ppmszwRefs);

public:
    static HRESULT HrCreateInstance (
        IN  CImplINetCfg* pINetCfg,
        IN  NETCLASS Class,
        OUT INetCfgClass** ppIClass);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\iclass.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I C L A S S . C P P
//
//  Contents:   Implements the INetCfgClass and INetCfgClassSetup COM
//              interfaces on the NetCfgClass sub-level COM object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "iclass.h"
#include "icomp.h"
#include "ienum.h"
#include "install.h"
#include "netcfg.h"
#include "obotoken.h"


// static
HRESULT
CImplINetCfgClass::HrCreateInstance (
    IN  CImplINetCfg* pINetCfg,
    IN  NETCLASS Class,
    OUT INetCfgClass** ppIClass)
{
    HRESULT hr = E_OUTOFMEMORY;

    CImplINetCfgClass* pObj;
    pObj = new CComObject <CImplINetCfgClass>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_Class = Class;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            hr = pObj->GetUnknown()->QueryInterface (IID_INetCfgClass,
                    (VOID**)ppIClass);

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                pObj->HoldINetCfg (pINetCfg);
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfgClass::HrCreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgClass -
//

STDMETHODIMP
CImplINetCfgClass::FindComponent (
    IN PCWSTR pszInfId,
    OUT INetCfgComponent** ppComp OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pszInfId) || FBadOutPtrOptional(ppComp))
    {
        hr = E_POINTER;
    }
    else
    {
        if (ppComp)
        {
            *ppComp = NULL;
        }

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            CComponent* pComponent;

            pComponent = m_pINetCfg->m_pNetConfig->Core.Components.
                            PFindComponentByInfId (pszInfId, NULL);

            // Don't return interfaces to components that have had
            // problem loading.
            //
            if (pComponent &&
                pComponent->Ext.FLoadedOkayIfLoadedAtAll() &&
                (m_Class == pComponent->Class()))
            {
                hr = S_OK;

                if (ppComp)
                {
                    hr = pComponent->HrGetINetCfgComponentInterface (
                            m_pINetCfg, ppComp);
                }
            }
            else
            {
                hr = S_FALSE;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CImplINetCfgClass::FindComponent");
    return hr;
}

STDMETHODIMP
CImplINetCfgClass::EnumComponents (
    OUT IEnumNetCfgComponent** ppIEnum)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppIEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIEnum = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            hr = CImplIEnumNetCfgComponent::HrCreateInstance (
                    m_pINetCfg,
                    m_Class,
                    ppIEnum);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfgClass::EnumComponents");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgClassSetup -
//
STDMETHODIMP
CImplINetCfgClass::SelectAndInstall (
    IN HWND hwndParent,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    OUT INetCfgComponent** ppIComp OPTIONAL)
{
    HRESULT hr = m_pINetCfg->SelectWithFilterAndInstall(
            hwndParent,
            MAP_NETCLASS_TO_GUID[m_Class],
            pOboToken,
            NULL,
            ppIComp);

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ||
        (NETCFG_S_REBOOT == hr),
        "CImplINetCfgClass::SelectAndInstall");
    return hr;
}

STDMETHODIMP
CImplINetCfgClass::Install (
    IN PCWSTR pszwInfId,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    IN DWORD dwSetupFlags OPTIONAL,
    IN DWORD dwUpgradeFromBuildNo OPTIONAL,
    IN PCWSTR pszAnswerFile OPTIONAL,
    IN PCWSTR pszAnswerSection OPTIONAL,
    OUT INetCfgComponent** ppIComp OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pszwInfId) ||
        !FOboTokenValidForClass(pOboToken, m_Class) ||
        FBadInPtrOptional (pszAnswerFile) ||
        FBadInPtrOptional (pszAnswerSection) ||
        FBadOutPtrOptional(ppIComp))
    {
        hr = E_POINTER;
    }
    // Must specifiy a non-empty INF id, and must either not specifiy,
    // or completely specifiy the answerfile and the section.
    //
    else if (!(*pszwInfId) ||
             ((!!pszAnswerFile) ^ (!!pszAnswerSection)))
    {
        hr = E_INVALIDARG;
    }
    else if (S_OK == (hr = HrProbeOboToken(pOboToken)))
    {
        if (ppIComp)
        {
            *ppIComp = NULL;
        }

        hr = HrLockAndTestForValidInterface (
                IF_NEED_WRITE_LOCK | IF_REFUSE_REENTRANCY |
                IF_ALLOW_INSTALL_OR_REMOVE);
        if (S_OK == hr)
        {
            Assert (m_pINetCfg->m_pNetConfig->ModifyCtx.m_fPrepared);

            NETWORK_INSTALL_PARAMS nip;
            COMPONENT_INSTALL_PARAMS Params;
            CComponent* pComponent;

            // Pack the network install parameters and call the common
            // function.
            //
            //$REVIEW: Just make this method take NETWORK_INSTALL_PARAMS?.
            //
            nip.dwSetupFlags         = dwSetupFlags;
            nip.dwUpgradeFromBuildNo = dwUpgradeFromBuildNo;
            nip.pszAnswerFile        = pszAnswerFile;
            nip.pszAnswerSection     = pszAnswerSection;

            // Setup the component install parameters.
            //
            ZeroMemory (&Params, sizeof(Params));
            Params.Class     = m_Class;
            Params.pszInfId  = pszwInfId;
            Params.pOboToken = pOboToken;
            Params.pnip      = &nip;

            hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                    HrInstallNewOrReferenceExistingComponent (
                        Params,
                        &pComponent);

            // The above may return NETCFG_S_REBOOT so use SUCCEEDED instead
            // of checking for S_OK only.
            //
            if (SUCCEEDED(hr) && ppIComp)
            {
                pComponent->HrGetINetCfgComponentInterface (
                    m_pINetCfg,
                    ppIComp);
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "CImplINetCfgClass::Install");
    return hr;
}

STDMETHODIMP
CImplINetCfgClass::DeInstall (
    IN INetCfgComponent* pIComp,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    OUT PWSTR* ppmszwRefs OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pIComp) ||
        !FOboTokenValidForClass(pOboToken, m_Class) ||
        FBadOutPtrOptional(ppmszwRefs))
    {
        hr = E_POINTER;
    }
    else if (S_OK == (hr = HrProbeOboToken(pOboToken)))
    {
        if (ppmszwRefs)
        {
            *ppmszwRefs = NULL;
        }

        hr = HrLockAndTestForValidInterface (
                IF_NEED_WRITE_LOCK | IF_REFUSE_REENTRANCY |
                IF_ALLOW_INSTALL_OR_REMOVE);
        if (S_OK == hr)
        {
            Assert (m_pINetCfg->m_pNetConfig->ModifyCtx.m_fPrepared);

            CImplINetCfgComponent* pICompToRemove;
            pICompToRemove = (CImplINetCfgComponent*)pIComp;

            hr = pICompToRemove->HrIsValidInterface (IF_NEED_COMPONENT_DATA);

            if (S_OK == hr)
            {
                // We don't allow removals of physical adapters via INetCfg.
                //
                if (!FIsPhysicalAdapter (m_Class,
                        pICompToRemove->m_pComponent->m_dwCharacter))
                {
                    hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                            HrRemoveComponentIfNotReferenced (
                                pICompToRemove->m_pComponent,
                                pOboToken,
                                ppmszwRefs);
                }
                else
                {
                    hr = SPAPI_E_INVALID_CLASS;
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "CImplINetCfgClass::DeInstall");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ibind.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I B I N D . H
//
//  Contents:   Implements the INetCfgBindingInterface and INetCfgBindingPath
//              COM interfaces.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "bindings.h"
#include "iatl.h"
#include "ienum.h"
#include "icomp.h"
#include "inetcfg.h"

//+---------------------------------------------------------------------------
// INetCfgBindingInterface -
//
class ATL_NO_VTABLE CImplINetCfgBindingInterface :
    public CImplINetCfgHolder,
    public INetCfgBindingInterface
{
private:
    CImplINetCfgComponent*  m_pUpper;
    CImplINetCfgComponent*  m_pLower;

private:
    HRESULT HrLockAndTestForValidInterface (
        DWORD dwFlags);

public:
    CImplINetCfgBindingInterface ()
    {
        m_pUpper = NULL;
        m_pLower = NULL;
    }

    VOID FinalRelease ()
    {
        AssertH (m_pUpper);
        AssertH (m_pLower);
        ReleaseObj (m_pUpper->GetUnknown());
        ReleaseObj (m_pLower->GetUnknown());

        CImplINetCfgHolder::FinalRelease();
    }

    BEGIN_COM_MAP(CImplINetCfgBindingInterface)
        COM_INTERFACE_ENTRY(INetCfgBindingInterface)
    END_COM_MAP()

    // INetCfgBindingInterface
    //
    STDMETHOD (GetName) (
        OUT PWSTR* ppszInterfaceName);

    STDMETHOD (GetUpperComponent) (
        OUT INetCfgComponent** ppComp);

    STDMETHOD (GetLowerComponent) (
        OUT INetCfgComponent** ppComp);

public:
    static HRESULT HrCreateInstance (
        IN  CImplINetCfg* pINetCfg,
        IN  CImplINetCfgComponent* pUpper,
        IN  CImplINetCfgComponent* pLower,
        OUT INetCfgBindingInterface** ppv);
};


//+---------------------------------------------------------------------------
// INetCfgBindingPath -
//
class ATL_NO_VTABLE CImplINetCfgBindingPath :
    public CImplINetCfgHolder,
    public INetCfgBindingPath
{
friend class CImplIEnumNetCfgBindingInterface;

private:
    // Note: For code coverage, we keep the static array small to
    // test the case where we don't fit and have to allocate.
    // Make this number 8 after we test both cases.
    //
    INetCfgComponent*   m_apIComp [8];
    INetCfgComponent**  m_papIComp;
    ULONG               m_cpIComp;

private:
    HRESULT HrLockAndTestForValidInterface (
        IN DWORD dwFlags,
        OUT CBindPath* pBindPath);

public:
    CImplINetCfgBindingPath ()
    {
        m_papIComp = NULL;
        m_cpIComp = 0;
    }

    VOID FinalRelease ()
    {
        AssertH (m_cpIComp);
        AssertH (m_papIComp);

        ReleaseIUnknownArray (m_cpIComp, (IUnknown**)m_papIComp);

        // If we are not using our static array, free what we allocated.
        //
        if (m_papIComp != m_apIComp)
        {
            MemFree (m_papIComp);
        }

        CImplINetCfgHolder::FinalRelease();
    }

    HRESULT
    HrIsValidInterface (
        IN DWORD dwFlags,
        OUT CBindPath* pBindPath);

    BEGIN_COM_MAP(CImplINetCfgBindingPath)
        COM_INTERFACE_ENTRY(INetCfgBindingPath)
    END_COM_MAP()

    // INetCfgBindingPath
    //
    STDMETHOD (IsSamePathAs) (
        IN INetCfgBindingPath* pIPath);

    STDMETHOD (IsSubPathOf) (
        IN INetCfgBindingPath* pIPath);

    STDMETHOD (IsEnabled) ();

    STDMETHOD (Enable) (
        IN BOOL fEnable);

    STDMETHOD (GetPathToken) (
        OUT PWSTR* ppszPathToken);

    STDMETHOD (GetOwner) (
        OUT INetCfgComponent** ppIComp);

    STDMETHOD (GetDepth) (
        OUT ULONG* pulDepth);

    STDMETHOD (EnumBindingInterfaces) (
        OUT IEnumNetCfgBindingInterface** ppIEnum);

public:
    static HRESULT HrCreateInstance (
        IN  CImplINetCfg* pINetCfg,
        IN  const CBindPath* pBindPath,
        OUT INetCfgBindingPath** ppIPath);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\icomp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I C O M P . C P P
//
//  Contents:   Implements the INetCfgComponent COM interface.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ibind.h"
#include "icomp.h"
#include "ienum.h"
#include "nccfgmgr.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncvalid.h"
#include "netcfg.h"
#include "netconp.h"
#include "util.h"


HRESULT
HrIsValidINetCfgComponent (
    IN INetCfgComponent* pICompInterface)
{
    Assert (pICompInterface);

    CImplINetCfgComponent* pIComp;
    pIComp = (CImplINetCfgComponent*)pICompInterface;

	if (pIComp == NULL)
	{
		return(E_OUTOFMEMORY);
	}

    return pIComp->HrIsValidInterface (IF_DEFAULT);
}

CComponent*
PComponentFromComInterface (
    IN INetCfgComponent* pICompInterface)
{
    Assert (pICompInterface);

    CImplINetCfgComponent* pIComp;
    pIComp = (CImplINetCfgComponent*)pICompInterface;

    // Can't do the following assert because we may be referencing the
    // component before it has been added to the core.  This case is possible
    // when installing a new component that installed a required component
    // on behalf of itself.  We will wind up in the function when adding
    // the refernce for the obo token.
    //
    //Assert (S_OK == pIComp->HrIsValidInterface (dwFlags));

    Assert (pIComp->m_pComponent);
    return pIComp->m_pComponent;
}

// static
HRESULT
CImplINetCfgComponent::HrCreateInstance (
    IN  CImplINetCfg* pINetCfg,
    IN  CComponent* pComponent,
    OUT CImplINetCfgComponent** ppIComp)
{
    HRESULT hr = E_OUTOFMEMORY;

    CImplINetCfgComponent* pObj;
    pObj = new CComObject <CImplINetCfgComponent>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_pComponent = pComponent;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            pObj->HoldINetCfg (pINetCfg);

            AddRefObj (pObj->GetUnknown());
            *ppIComp = pObj;
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::HrCreateInstance");
    return hr;
}

HRESULT
CImplINetCfgComponent::HrIsValidInterface (
    IN DWORD dwFlags)
{
    HRESULT hr;

    hr = m_pINetCfg->HrIsValidInterface (dwFlags);
    if (S_OK != hr)
    {
        return hr;
    }

    // Check for deleted component.
    //
    if (!m_pComponent)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    // If we made it this far, the component this interface represents
    // should definately be in the core component list or in the core
    // that we started with in the case that this component is in the middle
    // of being removed.
    //
    Assert(m_pINetCfg->m_pNetConfig->Core.Components.
                FComponentInList (m_pComponent) ||
           m_pINetCfg->m_pNetConfig->ModifyCtx.m_CoreStartedWith.Components.
                FComponentInList (m_pComponent));

    if (dwFlags & IF_NEED_COMPONENT_DATA)
    {
        hr = m_pComponent->Ext.HrEnsureExternalDataLoaded ();
    }

    return hr;
}

// We need to override CImplINetCfgHolder::HrLockAndTestForValidInterface
// because we have our own HrIsValidInterface to be called.
//
HRESULT
CImplINetCfgComponent::HrLockAndTestForValidInterface (
    IN DWORD dwFlags,
    IN INetCfgComponent* pIOtherComp, OPTIONAL
    OUT CComponent** ppOtherComp OPTIONAL)
{
    HRESULT hr;

    Lock();

    hr = HrIsValidInterface (dwFlags);

    // If pIOtherComp was passed in, the caller wants that interface
    // validated and the internal CComponent pointer for it returned.
    //
    if ((S_OK == hr) && pIOtherComp)
    {
        CImplINetCfgComponent* pOther;

        Assert (ppOtherComp);

        pOther = (CImplINetCfgComponent*)pIOtherComp;

        hr = pOther->HrIsValidInterface (IF_NEED_COMPONENT_DATA);
        if (S_OK == hr)
        {
            *ppOtherComp = pOther->m_pComponent;
        }
    }

    if (S_OK != hr)
    {
        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::HrLockAndTestForValidInterface");
    return hr;
}

HRESULT
CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy (
    IN UINT unOffset,
    OUT PWSTR* ppszDst)
{
    HRESULT hr;

    // Validate parameter.
    //
    if (FBadOutPtr (ppszDst))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszDst = NULL;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            hr = HrCoTaskMemAllocAndDupSz (
                    m_pComponent->Ext.PszAtOffset (unOffset),
                    ppszDst);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponent -
//
STDMETHODIMP
CImplINetCfgComponent::GetDisplayName (
    OUT PWSTR* ppszDisplayName)
{
    HRESULT hr;

    hr = HrAccessExternalStringAtOffsetAndCopy (
            ECD_OFFSET(m_pszDescription),
            ppszDisplayName);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetDisplayName");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::SetDisplayName (
    IN PCWSTR pszDisplayName)
{
    HRESULT hr;

    // Validate parameter.
    //
    if (FBadInPtr (pszDisplayName))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            // We only allow changing the display name (SPDRP_FRIENDLYNAME,
            // actually) of enumerated components.
            //
            if (FIsEnumerated(m_pComponent->Class()))
            {
                HDEVINFO hdi;
                SP_DEVINFO_DATA deid;

                hr = m_pComponent->HrOpenDeviceInfo (&hdi, &deid);
                if (S_OK == hr)
                {
                    hr = HrSetupDiSetDeviceName (hdi, &deid, pszDisplayName);

                    if (S_OK == hr)
                    {
                        m_pComponent->Ext.HrSetDescription (pszDisplayName);
                    }

                    SetupDiDestroyDeviceInfoList (hdi);
                }
            }
            else
            {
                hr = E_NOTIMPL;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::SetDisplayName");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetHelpText (
    OUT PWSTR* pszHelpText)
{
    HRESULT hr;

    hr = HrAccessExternalStringAtOffsetAndCopy (
            ECD_OFFSET(m_pszHelpText),
            pszHelpText);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetHelpText");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetId (
    OUT PWSTR* ppszId)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (ppszId))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            hr = HrCoTaskMemAllocAndDupSz (
                    m_pComponent->m_pszInfId,
                    ppszId);

            Unlock();
        }
        else
        {
            *ppszId = NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetId");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetCharacteristics (
    OUT LPDWORD pdwCharacteristics)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pdwCharacteristics))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            *pdwCharacteristics = m_pComponent->m_dwCharacter;

            Unlock();
        }
        else
        {
            *pdwCharacteristics = 0;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetCharacteristics");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetInstanceGuid (
    OUT GUID* pInstanceGuid)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pInstanceGuid))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            *pInstanceGuid = m_pComponent->m_InstanceGuid;

            Unlock();
        }
        else
        {
            *pInstanceGuid = GUID_NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetInstanceGuid");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetPnpDevNodeId (
    OUT PWSTR* ppszDevNodeId)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (ppszDevNodeId))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            if (FIsEnumerated(m_pComponent->Class()))
            {
                hr = HrCoTaskMemAllocAndDupSz (
                        m_pComponent->m_pszPnpId,
                        ppszDevNodeId);
            }
            else
            {
                hr = E_NOTIMPL;
            }

            Unlock();
        }
        else
        {
            *ppszDevNodeId = NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetPnpDevNodeId");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetClassGuid (
    OUT GUID* pguidClass)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pguidClass))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            *pguidClass = *MAP_NETCLASS_TO_GUID[m_pComponent->Class()];

            Unlock();
        }
        else
        {
            *pguidClass = GUID_NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetClassGuid");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetBindName (
    OUT PWSTR* ppszBindName)
{
    HRESULT hr;

    hr = HrAccessExternalStringAtOffsetAndCopy (
            ECD_OFFSET(m_pszBindName),
            ppszBindName);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetBindName");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetDeviceStatus (
    OUT ULONG* pulStatus)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pulStatus))
    {
        hr = E_POINTER;
    }
    else
    {
        *pulStatus = 0;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            if (!FIsEnumerated(m_pComponent->Class()))
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                HDEVINFO hdi;
                SP_DEVINFO_DATA deid;

                hr = m_pComponent->HrOpenDeviceInfo (&hdi, &deid);

                if (S_OK == hr)
                {
                    ULONG ulStatus;
                    ULONG ulProblem;
                    CONFIGRET cfgRet;

                    cfgRet = CM_Get_DevNode_Status_Ex (
                                &ulStatus, &ulProblem, deid.DevInst, 0, NULL);

                    if (CR_SUCCESS == cfgRet)
                    {
                        hr = S_OK;
                        *pulStatus = ulProblem;
                    }
                    else if(CR_NO_SUCH_DEVINST == cfgRet)
                    {
                        hr = NETCFG_E_ADAPTER_NOT_FOUND;
                    }
                    else
                    {
                        TraceTag (ttidError, "CM_Get_DevNode_Status_Ex for "
                            "%S returned cfgRet=0x%08x, ulStatus=0x%08x, ulProblem=0x%08x",
                            m_pComponent->m_pszPnpId,
                            cfgRet,
                            ulStatus,
                            ulProblem);

                        hr = HrFromConfigManagerError (cfgRet, E_FAIL);
                    }

                    SetupDiDestroyDeviceInfoList (hdi);
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetDeviceStatus");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::OpenParamKey (
    OUT HKEY* phkey)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (phkey))
    {
        hr = E_POINTER;
    }
    else
    {
        *phkey = NULL;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            // Get the correct REGSAM value base on?
            //
            REGSAM samDesired = KEY_READ_WRITE;

            // For enumerated components, the parameter key is the
            // instance key.
            //
            if (FIsEnumerated (m_pComponent->Class()))
            {
                hr = m_pComponent->HrOpenInstanceKey (
                            samDesired, phkey, NULL, NULL);
            }

            // For non-enumerated components, the parameter is either under
            // the service key (if the component has a service) or it is
            // under the instance key.
            //
            else
            {
                // Get the parent of the parameters key.
                //
                HKEY hkeyParent;

                #if DBG
                hkeyParent = NULL;
                #endif

                if (m_pComponent->FHasService())
                {
                    hr = m_pComponent->HrOpenServiceKey (
                            samDesired, &hkeyParent);
                }
                else
                {
                    hr = m_pComponent->HrOpenInstanceKey (
                            samDesired, &hkeyParent, NULL, NULL);
                }

                if (S_OK == hr)
                {
                    Assert (hkeyParent);

                    DWORD dwDisposition;
                    hr = HrRegCreateKeyEx (
                            hkeyParent,
                            L"Parameters",
                            REG_OPTION_NON_VOLATILE,
                            samDesired,
                            NULL,
                            phkey,
                            &dwDisposition);

                    RegCloseKey (hkeyParent);
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::OpenParamKey");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::RaisePropertyUi (
    IN HWND hwndParent,
    IN DWORD dwFlags, /* NCRP_FLAGS */
    IN IUnknown* punkContext OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if ((!IsWindow (hwndParent) && (dwFlags & NCRP_SHOW_PROPERTY_UI)) ||
        !(dwFlags & (NCRP_QUERY_PROPERTY_UI | NCRP_SHOW_PROPERTY_UI)) ||
        ((dwFlags & NCRP_QUERY_PROPERTY_UI) && (dwFlags & NCRP_SHOW_PROPERTY_UI)))
    {
        hr = E_INVALIDARG;
    }
    else if (FBadInPtrOptional (punkContext))
    {
        hr = E_POINTER;
    }
    else
    {
        DWORD dwIfFlags = IF_NEED_WRITE_LOCK;
        BOOL fReadOnlyRasUiContext = FALSE;
        
        // Special case: for RAS UI.  We need to allow raising property
        // sheets within the context of a RAS connection even when we
        // don't have the write lock.  This is because non-admins need to be
        // able to change TCP/IP properties for their connections.  The 
        // property values will be stored in the phonebook and we won't need 
        // to make any netcfg changes anyway.  Therefore, if we have a
        // punkContext, we'll check to see if it supports the private 
        // interface that we know RAS uses when it raises properties.
        // If this interface is present, we won't require the write lock
        // to proceed
        //
        if (punkContext && !m_pINetCfg->m_WriteLock.FIsOwnedByMe ())
        {
            INetRasConnectionIpUiInfo* pRasUiInfo;
            hr = punkContext->QueryInterface (IID_INetRasConnectionIpUiInfo,
                                (PVOID*)&pRasUiInfo);
            if (S_OK == hr)
            {
                dwIfFlags &= ~IF_NEED_WRITE_LOCK;
                dwIfFlags |= IF_NEED_COMPONENT_DATA;
                fReadOnlyRasUiContext = TRUE;
                
                ReleaseObj (pRasUiInfo);
            }
            hr = S_OK;
        }
        // End special case
        
        hr = HrLockAndTestForValidInterface (dwIfFlags, NULL, NULL);
        if (S_OK == hr)
        {
            // Special case: (see above)
            //
            if (fReadOnlyRasUiContext)
            {
                if (0 == wcscmp (m_pComponent->m_pszInfId, L"ms_tcpip"))
                {
                    hr = m_pComponent->Notify.HrEnsureNotifyObjectInitialized (
                            m_pINetCfg, FALSE);
                }
                else
                {
                    hr = NETCFG_E_NO_WRITE_LOCK;
                }
            }
            // End special case
            
            if (S_OK == hr)
            {
                if (dwFlags & NCRP_QUERY_PROPERTY_UI)
                {
                    hr = m_pComponent->Notify.HrQueryPropertyUi (
                            m_pINetCfg,
                            punkContext);
                }
                else
                {
                    Assert (dwFlags & NCRP_SHOW_PROPERTY_UI);

                    hr = m_pComponent->Notify.HrShowPropertyUi (
                            m_pINetCfg,
                            hwndParent,
                            punkContext);
                }
            }

            Unlock ();
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ||
        (S_FALSE == hr),
        "CImplINetCfgComponent::RaisePropertyUi");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponentBindings -
//
HRESULT
CImplINetCfgComponent::HrBindToOrUnbindFrom (
    IN INetCfgComponent* pIOtherComp,
    IN DWORD dwChangeFlag)
{
    HRESULT hr;

    Assert ((dwChangeFlag == NCN_ENABLE) || (dwChangeFlag == NCN_DISABLE));

    // Validate parameters.
    //
    if (FBadInPtr (pIOtherComp))
    {
        hr = E_POINTER;
    }
    else
    {
        CComponent* pLower;

        hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK,
                pIOtherComp, &pLower);

        if (S_OK == hr)
        {
            const CComponent* pUpper = m_pComponent;

            // Assume the components do not bind.
            //
            hr = S_FALSE;

            if (pUpper != pLower)
            {
                CBindingSet BindingSet;

                hr = m_pINetCfg->m_pNetConfig->Core.HrGetComponentBindings (
                        pUpper, GBF_DEFAULT, &BindingSet);

                if (S_OK == hr)
                {
                    CBindPath* pBindPath;

                    // Assume we don't find the component in any bindings.
                    //
                    hr = S_FALSE;

                    for (pBindPath  = BindingSet.begin();
                         pBindPath != BindingSet.end();
                         pBindPath++)
                    {
                        // Skip bindpaths that don't contain the lower
                        // component.
                        //
                        if (!pBindPath->FContainsComponent (pLower))
                        {
                            continue;
                        }

                        hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                                HrEnableOrDisableBindPath (
                                    dwChangeFlag,
                                    pBindPath,
                                    NULL);

                        if (S_OK != hr)
                        {
                            break;
                        }
                    }
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::HrBindToOrUnbindFrom");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::BindTo (
    IN INetCfgComponent* pIOtherComp)
{
    HRESULT hr;

    hr = HrBindToOrUnbindFrom (pIOtherComp, NCN_ENABLE);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::BindTo");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::UnbindFrom (
    IN INetCfgComponent* pIOtherComp)
{
    HRESULT hr;

    hr = HrBindToOrUnbindFrom (pIOtherComp, NCN_DISABLE);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::UnbindFrom");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::SupportsBindingInterface (
    IN DWORD dwFlags,
    IN PCWSTR pszInterfaceName)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!((dwFlags & NCF_UPPER) || (dwFlags & NCF_LOWER)))
    {
        hr = E_INVALIDARG;
    }
    else if (FBadInPtr (pszInterfaceName))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            PCWSTR pszRange;

            pszRange = (dwFlags & NCF_LOWER)
                            ? m_pComponent->Ext.PszLowerRange()
                            : m_pComponent->Ext.PszUpperRange();

            hr =  (FSubstringMatch (pszRange, pszInterfaceName, NULL, NULL))
                    ? S_OK
                    : S_FALSE;

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::SupportsBindingInterface");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::IsBoundTo (
    IN INetCfgComponent* pIOtherComp)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pIOtherComp))
    {
        hr = E_POINTER;
    }
    else
    {
        CComponent* pLower;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA,
                pIOtherComp, &pLower);

        if (S_OK == hr)
        {
            const CComponent* pUpper = m_pComponent;

            hr = S_FALSE;  // assume it is not bound or is disabled

            if (pUpper != pLower)
            {
                CBindingSet BindingSet;

                hr = m_pINetCfg->m_pNetConfig->Core.HrGetComponentBindings (
                        pUpper, GBF_DEFAULT, &BindingSet);

                // If we think its bound, make sure it exists in at least
                // one bindpath that is not disabled.
                //
                if (S_OK == hr)
                {
                    CBindPath* pBindPath;

                    // Assume we don't fint it in at least one enabled
                    // bindpath.
                    //
                    hr = S_FALSE;

                    for (pBindPath  = BindingSet.begin();
                         pBindPath != BindingSet.end();
                         pBindPath++)
                    {
                        // If the bindpath contains the component, and it is
                        // not a disabled bindpath, it means pUpper has a
                        // path to pLower.
                        //

                        if (pBindPath->FContainsComponent (pLower) &&
                            !m_pINetCfg->m_pNetConfig->Core.
                                FIsBindPathDisabled (pBindPath,
                                    IBD_MATCH_SUBPATHS_TOO))
                        {
                            hr = S_OK;
                            break;
                        }
                    }
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::IsBoundTo");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::IsBindableTo (
    IN INetCfgComponent* pIOtherComp)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pIOtherComp))
    {
        hr = E_POINTER;
    }
    else
    {
        CComponent* pLower;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA,
                pIOtherComp, &pLower);

        if (S_OK == hr)
        {
            const CComponent* pUpper = m_pComponent;

            hr = S_FALSE;  // assume it does not bind

            if (pUpper != pLower)
            {
                CBindingSet BindingSet;

                hr = m_pINetCfg->m_pNetConfig->Core.HrGetComponentBindings (
                        pUpper, GBF_DEFAULT, &BindingSet);

                if (S_OK == hr)
                {
                    hr = (BindingSet.FContainsComponent (pLower))
                            ? S_OK : S_FALSE;
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::IsBindableTo");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::EnumBindingPaths (
    IN DWORD dwFlags,
    OUT IEnumNetCfgBindingPath** ppIEnum)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (ppIEnum))
    {
        hr = E_POINTER;
    }
    else if ((EBP_ABOVE != dwFlags) &&
             (EBP_BELOW != dwFlags))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppIEnum = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            CImplIEnumNetCfgBindingPath* pIEnum;

            // Create an empty bindpath enumerator.  We create it empty
            // before we get the set of bindings so we don't have to copy
            // the bindings.
            //
            hr = CImplIEnumNetCfgBindingPath::HrCreateInstance (
                    m_pINetCfg,
                    NULL,
                    EBPC_CREATE_EMPTY,
                    &pIEnum);

            if (S_OK == hr)
            {
                // Get the bindset and store it directly in the enumerator
                // for its exclusive use.
                //
                if (EBP_ABOVE == dwFlags)
                {
                    hr = m_pINetCfg->m_pNetConfig->Core.
                            HrGetBindingsInvolvingComponent (
                                m_pComponent,
                                GBF_DEFAULT,
                                &pIEnum->m_InternalBindSet);
                }
                else
                {
                    hr = m_pINetCfg->m_pNetConfig->Core.
                            HrGetComponentBindings (
                                m_pComponent,
                                GBF_DEFAULT,
                                &pIEnum->m_InternalBindSet);
                }

                if (S_OK == hr)
                {
                    // Must Reset so that the internal iterator is setup properly
                    // after we initialized the InternalBindSet above.
                    //
                    hr = pIEnum->Reset ();
                    Assert (S_OK == hr);

                    AddRefObj (pIEnum->GetUnknown());
                    *ppIEnum = pIEnum;
                }

                ReleaseObj (pIEnum->GetUnknown());
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::EnumBindingPaths");
    return hr;
}

HRESULT
CImplINetCfgComponent::HrMoveBindPath (
    IN INetCfgBindingPath* pIPathSrc,
    IN INetCfgBindingPath* pIPathDst,
    IN MOVE_FLAG Flag)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pIPathSrc) || FBadInPtrOptional (pIPathDst))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK, NULL, NULL);
        if (S_OK == hr)
        {
            CImplINetCfgBindingPath* pISrc;
            CImplINetCfgBindingPath* pIDst;
            CBindPath SrcBindPath;
            CBindPath DstBindPath;
            CBindPath::const_iterator iterSrc;
            CBindPath::const_iterator iterDst;
            CStackEntry SrcEntry;
            CStackEntry DstEntry;

            Assert (m_pINetCfg);
            Assert (m_pINetCfg->m_pNetConfig->ModifyCtx.m_fPrepared);

            pISrc = (CImplINetCfgBindingPath*)pIPathSrc;
            pIDst = (CImplINetCfgBindingPath*)pIPathDst;

            hr = pISrc->HrIsValidInterface (IF_NEED_WRITE_LOCK, &SrcBindPath);
            if (S_OK != hr)
            {
                goto unlock;
            }

            // pIPathDst (hence pIDst) may be NULL.
            //
            if (pIDst)
            {
                hr = pIDst->HrIsValidInterface (IF_NEED_WRITE_LOCK, &DstBindPath);
                if (S_OK != hr)
                {
                    goto unlock;
                }
            }

            // The first component of both bindpaths must be this component.
            //
            if ((m_pComponent != SrcBindPath.POwner()) ||
                (pIDst && (m_pComponent != DstBindPath.POwner())))
            {
                hr = E_INVALIDARG;
                goto unlock;
            }

            if (pIDst)
            {
                // Scan down both bindpaths until we find the first components
                // that don't match.  Assume we don't find this occurance and
                // return E_INVALIDARG if we don't.
                //
                hr = E_INVALIDARG;

                for (iterSrc  = SrcBindPath.begin(), iterDst  = DstBindPath.begin();
                     iterSrc != SrcBindPath.end() && iterDst != DstBindPath.end();
                     iterSrc++, iterDst++)
                {
                    // First time through *iterSrc is guaranteed to be the
                    // sameas *iterDst because the first component in both
                    // bindpaths is m_pComponent as tested above.
                    //
                    if (*iterSrc != *iterDst)
                    {
                        SrcEntry.pLower = *iterSrc;
                        Assert (SrcEntry.pLower);

                        DstEntry.pLower = *iterDst;
                        Assert (DstEntry.pUpper);

                        Assert (SrcEntry.pUpper == DstEntry.pUpper);
                        Assert (SrcEntry.pLower != DstEntry.pLower);

                        hr = m_pINetCfg->m_pNetConfig->Core.StackTable.
                                HrMoveStackEntries (
                                    &SrcEntry,
                                    &DstEntry,
                                    Flag,
                                    &m_pINetCfg->m_pNetConfig->ModifyCtx);

                        if(SUCCEEDED(hr))
                        {
                            // Mark this component as dirty so it's bindings will be written out and 
                            // NDIS will be notified.
                            m_pINetCfg->m_pNetConfig->ModifyCtx.
                                HrDirtyComponentAndComponentsAbove(SrcEntry.pUpper);
                            m_pINetCfg->m_pNetConfig->ModifyCtx.
                                HrDirtyComponentAndComponentsAbove(DstEntry.pUpper);
                        }

                        break;
                    }

                    // Remember the upper components as we are about to
                    // advance past them.
                    //
                    SrcEntry.pUpper = *iterSrc;
                    Assert (SrcEntry.pUpper);

                    DstEntry.pUpper = *iterDst;
                    Assert (SrcEntry.pUpper);

                    Assert (SrcEntry.pUpper == DstEntry.pUpper);
                }
            }
            else
            {
                SrcEntry.pUpper = SrcBindPath.POwner();
                Assert ((SrcBindPath.begin() + 1) != SrcBindPath.end());
                SrcEntry.pLower = *(SrcBindPath.begin() + 1);

                hr = m_pINetCfg->m_pNetConfig->Core.StackTable.
                        HrMoveStackEntries (
                            &SrcEntry,
                            NULL,
                            Flag,
                            &m_pINetCfg->m_pNetConfig->ModifyCtx);

                if(SUCCEEDED(hr))
                {
                    // Mark this component as dirty so it's bindings will be written out and 
                    // NDIS will be notified.
                    m_pINetCfg->m_pNetConfig->ModifyCtx.
                        HrDirtyComponentAndComponentsAbove(SrcEntry.pUpper);
                }
            }

unlock:
            Unlock();
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::HrMoveBindPath");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::MoveBefore (
    IN INetCfgBindingPath* pIPathSrc,
    IN INetCfgBindingPath* pIPathDst)
{
    HRESULT hr;

    hr = HrMoveBindPath (pIPathSrc, pIPathDst, MOVE_BEFORE);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::MoveBefore");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::MoveAfter (
    IN INetCfgBindingPath* pIPathSrc,
    IN INetCfgBindingPath* pIPathDst)
{
    HRESULT hr;

    hr = HrMoveBindPath (pIPathSrc, pIPathDst, MOVE_AFTER);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::MoveAfter");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponentPrivate -
//
STDMETHODIMP
CImplINetCfgComponent::QueryNotifyObject (
    IN REFIID riid,
    OUT VOID** ppvObject)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(&riid) || FBadOutPtr (ppvObject))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppvObject = NULL;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            hr = m_pComponent->Notify.QueryNotifyObject (
                    m_pINetCfg, riid, ppvObject);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::QueryNotifyObject");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::SetDirty ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK, NULL, NULL);
    if (S_OK == hr)
    {
        hr = m_pINetCfg->m_pNetConfig->ModifyCtx.HrDirtyComponent(
                m_pComponent);

        Unlock ();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfgComponent::SetDirty");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::NotifyUpperEdgeConfigChange ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK, NULL, NULL);
    if (S_OK == hr)
    {
        hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                HrDirtyComponentAndComponentsAbove (m_pComponent);

        Unlock ();
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::NotifyUpperEdgeConfigChange");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ienum.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I E N U M . H
//
//  Contents:   Implements the IEnumNetCfgBindingInterface,
//              IEnumNetCfgBindingPath, and IEnumNetCfgComponent COM
//              interfaces.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "bindings.h"
#include "compdefs.h"
#include "complist.h"
#include "iatl.h"
#include "inetcfg.h"

//+---------------------------------------------------------------------------
// IEnumNetCfgBindingInterface -
//
class ATL_NO_VTABLE CImplIEnumNetCfgBindingInterface :
    public CImplINetCfgHolder,
    public IEnumNetCfgBindingInterface
{
private:
    class CImplINetCfgBindingPath*  m_pIPath;
    UINT                            m_unIndex;

private:
    HRESULT
    HrNextOrSkip (
        IN ULONG celt,
        OUT INetCfgBindingInterface** rgelt,
        OUT ULONG* pceltFetched);

public:
    CImplIEnumNetCfgBindingInterface ()
    {
        m_pIPath = NULL;
        m_unIndex = 1;
    }

    VOID FinalRelease ();

    BEGIN_COM_MAP(CImplIEnumNetCfgBindingInterface)
        COM_INTERFACE_ENTRY(IEnumNetCfgBindingInterface)
    END_COM_MAP()

    // IEnumNetCfgBindingInterface
    STDMETHOD (Next) (
        IN ULONG celt,
        OUT INetCfgBindingInterface** rgelt,
        OUT ULONG* pceltFetched);

    STDMETHOD (Skip) (
        IN ULONG celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        OUT IEnumNetCfgBindingInterface** ppIEnum);

public:
    static HRESULT HrCreateInstance (
        IN CImplINetCfg* pINetCfg,
        IN class CImplINetCfgBindingPath* pIPath,
        OUT IEnumNetCfgBindingInterface** ppIEnum);
};


//+---------------------------------------------------------------------------
// IEnumNetCfgBindingPath -
//
enum EBPC_FLAGS
{
    EBPC_CREATE_EMPTY    = 0x00000001,
    EBPC_COPY_BINDSET    = 0x00000002,
    EBPC_TAKE_OWNERSHIP  = 0x00000004,
};

class ATL_NO_VTABLE CImplIEnumNetCfgBindingPath :
    public CImplINetCfgHolder,
    public IEnumNetCfgBindingPath
{
friend CImplINetCfgComponent;

private:
    CBindingSet m_InternalBindSet;

    // m_pBindSet is the pointer through which we access the data being
    // enumerated.  It will either point to m_InternalBindSet above or some
    // other bindset that we were given ownership of via HrCreateInstance.
    //
    const CBindingSet*  m_pBindSet;

    // The current enumeration position.
    //
    CBindingSet::const_iterator m_iter;

private:
    HRESULT
    HrNextOrSkip (
        IN ULONG celt,
        OUT INetCfgBindingPath** rgelt,
        OUT ULONG* pceltFetched);

public:
    CImplIEnumNetCfgBindingPath ()
    {
        m_pBindSet = NULL;
        m_iter = NULL;
    }

    ~CImplIEnumNetCfgBindingPath ()
    {
        // Delete m_pBindSet if we own it.  (If it's not aliasing a copied
        // bindset.)
        //
        if (&m_InternalBindSet != m_pBindSet)
        {
            delete m_pBindSet;
        }
    }

    BEGIN_COM_MAP(CImplIEnumNetCfgBindingPath)
        COM_INTERFACE_ENTRY(IEnumNetCfgBindingPath)
    END_COM_MAP()

    // IEnumNetCfgBindingPath
    STDMETHOD (Next) (
        IN ULONG celt,
        OUT INetCfgBindingPath** rgelt,
        OUT ULONG* pceltFetched);

    STDMETHOD (Skip) (
        IN ULONG celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        OUT IEnumNetCfgBindingPath** ppIEnum);

public:
    static HRESULT HrCreateInstance (
        IN CImplINetCfg* pINetCfg,
        IN const CBindingSet* pBindSet OPTIONAL,
        IN DWORD dwFlags,
        OUT CImplIEnumNetCfgBindingPath** ppIEnum);
};

//+---------------------------------------------------------------------------
// IEnumNetCfgComponent -
//
class ATL_NO_VTABLE CImplIEnumNetCfgComponent :
    public CImplINetCfgHolder,
    public IEnumNetCfgComponent
{
private:
    UINT            m_unIndex;
    NETCLASS        m_Class;

private:
    HRESULT
    HrNextOrSkip (
        IN ULONG celt,
        OUT INetCfgComponent** rgelt,
        OUT ULONG* pceltFetched);

public:
    CImplIEnumNetCfgComponent ()
    {
        m_unIndex = 0;
    }

    BEGIN_COM_MAP(CImplIEnumNetCfgComponent)
        COM_INTERFACE_ENTRY(IEnumNetCfgComponent)
    END_COM_MAP()

    // IEnumNetCfgComponent
    STDMETHOD (Next) (
        IN ULONG celt,
        OUT INetCfgComponent** rgelt,
        OUT ULONG* pceltFetched);

    STDMETHOD (Skip) (
        IN ULONG celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        OUT IEnumNetCfgComponent** ppIEnum);

public:
    static HRESULT HrCreateInstance (
        IN CImplINetCfg* pINetCfg,
        IN NETCLASS Class,
        OUT IEnumNetCfgComponent** ppIEnum);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ienum.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I E N U M . C P P
//
//  Contents:   Implements the IEnumNetCfgBindingInterface,
//              IEnumNetCfgBindingPath, and IEnumNetCfgComponent COM
//              interfaces.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ibind.h"
#include "ienum.h"
#include "ncatl.h"
#include "netcfg.h"

/*
 A helper function for finishing up the semantics of a IEnumXXX::Next or
 IEnumXXX::Skip. Return S_OK if no error passed in and celt == celtFetched.
 Return S_FALSE if no error passed in and celt != celtFetched. If returning
 an error, release celt IUnknowns from rgelt.

 Returns:   S_OK, S_FALSE,  or an error code

 Author:    shaunco   13 Jan 1999
*/
HRESULT
HrFinishNextOrSkipContract (
    IN HRESULT hr,
    IN ULONG celtFetched,
    IN ULONG celt,
    IN OUT IUnknown** rgelt,
    OUT ULONG* pceltFetched)
{
    if (S_OK == hr)
    {
        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        hr = (celtFetched == celt) ? S_OK : S_FALSE;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        if (rgelt)
        {
            for (ULONG ulIndex = 0; ulIndex < celt; ulIndex++)
            {
                ReleaseObj (rgelt[ulIndex]);
                rgelt[ulIndex] = NULL;
            }
        }
        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
// CImplIEnumNetCfgBindingInterface -
//

/*
 Create an instance of a binding interface enumerator.

 Returns:   S_OK or an error code

 Author:    shaunco   13 Jan 1999
*/
// static
HRESULT
CImplIEnumNetCfgBindingInterface::HrCreateInstance (
    IN CImplINetCfg* pINetCfg,
    IN CImplINetCfgBindingPath* pIPath,
    OUT IEnumNetCfgBindingInterface** ppIEnum)
{
    HRESULT hr = E_OUTOFMEMORY;

    CImplIEnumNetCfgBindingInterface* pObj;
    pObj = new CComObject <CImplIEnumNetCfgBindingInterface>;
    if (pObj)
    {
        hr = S_OK;

        // Initialize our members.
        //
        pObj->m_pIPath = pIPath;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        // The last thing we do is addref any interfaces we hold.
        // We only do this if we are returning success.
        //
        if (S_OK == hr)
        {
            hr = pObj->QueryInterface (IID_IEnumNetCfgBindingInterface,
                        (VOID**)ppIEnum);

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                AddRefObj (pIPath->GetUnknown());
                pObj->HoldINetCfg (pINetCfg);
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplIEnumNetCfgBindingInterface::HrCreateInstance");
    return hr;
}

VOID
CImplIEnumNetCfgBindingInterface::FinalRelease ()
{
    AssertH (m_pIPath);
    ReleaseObj (m_pIPath->GetUnknown());

    CImplINetCfgHolder::FinalRelease();
}

HRESULT
CImplIEnumNetCfgBindingInterface::HrNextOrSkip (
    IN ULONG celt,
    OUT INetCfgBindingInterface** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    Assert (m_unIndex >= 1);

    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    hr = HrLockAndTestForValidInterface (IF_DEFAULT);
    if (S_OK == hr)
    {
        // Enumerate the requested number of elements or stop short
        // if we don't have that many left to enumerate.
        //
        ULONG celtFetched = 0;
        while ((S_OK == hr)
                && (celtFetched < celt)
                && (m_unIndex < m_pIPath->m_cpIComp))
        {
            if (rgelt)
            {
                hr = CImplINetCfgBindingInterface::HrCreateInstance (
                        m_pINetCfg,
                        (CImplINetCfgComponent*)m_pIPath->
                            m_papIComp[m_unIndex-1],

                        (CImplINetCfgComponent*)m_pIPath->
                            m_papIComp[m_unIndex],
                        rgelt + celtFetched);
            }

            celtFetched++;
            m_unIndex++;
        }
        Unlock();

        hr = HrFinishNextOrSkipContract (hr, celtFetched, celt,
                reinterpret_cast<IUnknown**>(rgelt), pceltFetched);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingInterface::HrNextOrSkip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingInterface::Next (
    IN ULONG celt,
    OUT INetCfgBindingInterface** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else if (rgelt && IsBadWritePtr(rgelt, celt * sizeof(*rgelt)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingInterface::Next");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingInterface::Skip (
    IN ULONG celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingInterface::Skip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingInterface::Reset ()
{
    Lock();
    Assert (m_pIPath);
    m_unIndex = 1;
    Unlock();

    return S_OK;
}

STDMETHODIMP
CImplIEnumNetCfgBindingInterface::Clone (
    OUT IEnumNetCfgBindingInterface** ppIEnum)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
// CImplIEnumNetCfgBindingPath -
//

// static
HRESULT
CImplIEnumNetCfgBindingPath::HrCreateInstance (
    IN CImplINetCfg* pINetCfg,
    IN const CBindingSet* pBindSet OPTIONAL,
    IN DWORD dwFlags,
    OUT CImplIEnumNetCfgBindingPath** ppIEnum)
{
    HRESULT hr = E_OUTOFMEMORY;

    Assert (dwFlags);
    if (pBindSet)
    {
        pINetCfg->m_pNetConfig->Core.DbgVerifyBindingSet (pBindSet);
    }

    CImplIEnumNetCfgBindingPath* pObj;
    pObj = new CComObject <CImplIEnumNetCfgBindingPath>;
    if (pObj)
    {
        hr = S_OK;

        // Initialize our members.
        //
        if (dwFlags & EBPC_TAKE_OWNERSHIP)
        {
            Assert (pBindSet);
            pObj->m_pBindSet = pBindSet;
            pObj->m_iter = pBindSet->begin();
        }
        else if (dwFlags & EBPC_COPY_BINDSET)
        {
            Assert (pBindSet);
            hr = pObj->m_InternalBindSet.HrCopyBindingSet(pBindSet);
            pObj->m_pBindSet = &pObj->m_InternalBindSet;
            pObj->m_iter = pObj->m_InternalBindSet.begin();
        }
        else
        {
            Assert (dwFlags & EBPC_CREATE_EMPTY);
            pObj->m_pBindSet = &pObj->m_InternalBindSet;
            pObj->m_iter = pObj->m_InternalBindSet.begin();
        }

        if (S_OK == hr)
        {
            // Do the standard CComCreator::CreateInstance stuff.
            //
            pObj->SetVoid (NULL);
            pObj->InternalFinalConstructAddRef ();
            hr = pObj->FinalConstruct ();
            pObj->InternalFinalConstructRelease ();

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                pObj->HoldINetCfg (pINetCfg);

                AddRefObj (pObj->GetUnknown());
                *ppIEnum = pObj;
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }

    if ((S_OK != hr) && (dwFlags & EBPC_TAKE_OWNERSHIP))
    {
        delete pBindSet;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplIEnumNetCfgBindingPath::HrCreateInstance");
    return hr;
}

HRESULT
CImplIEnumNetCfgBindingPath::HrNextOrSkip (
    IN ULONG celt,
    OUT INetCfgBindingPath** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    Assert(m_iter >= m_pBindSet->begin());

    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    hr = HrLockAndTestForValidInterface (IF_DEFAULT);
    if (S_OK == hr)
    {
        // Enumerate the requested number of elements or stop short
        // if we don't have that many left to enumerate.
        //
        ULONG celtFetched = 0;
        while ((S_OK == hr)
                && (celtFetched < celt)
                && (m_iter != m_pBindSet->end()))
        {
            // Don't return interfaces to bindpaths that contain
            // components that have had problem loading.
            //
            if (m_iter->FAllComponentsLoadedOkayIfLoadedAtAll())
            {
                if (rgelt)
                {
                    hr = CImplINetCfgBindingPath::HrCreateInstance (
                            m_pINetCfg,
                            m_iter,
                            rgelt + celtFetched);
                }

                celtFetched++;
            }

            m_iter++;
        }

        Unlock();

        hr = HrFinishNextOrSkipContract (hr, celtFetched, celt,
                reinterpret_cast<IUnknown**>(rgelt), pceltFetched);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingPath::HrNextOrSkip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingPath::Next (
    IN ULONG celt,
    OUT INetCfgBindingPath** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else if (rgelt && IsBadWritePtr(rgelt, celt * sizeof(*rgelt)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingPath::Next");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingPath::Skip (
    IN ULONG celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingPath::Skip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingPath::Reset ()
{
    Lock();
    Assert (m_pBindSet);
    m_iter = m_pBindSet->begin();
    Unlock();

    return S_OK;
}

STDMETHODIMP
CImplIEnumNetCfgBindingPath::Clone (
    OUT IEnumNetCfgBindingPath** ppIEnum)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
// CImplIEnumNetCfgComponent -
//

// static
HRESULT
CImplIEnumNetCfgComponent::HrCreateInstance (
    IN CImplINetCfg* pINetCfg,
    IN NETCLASS Class,
    OUT IEnumNetCfgComponent** ppIEnum)
{
    HRESULT hr = E_OUTOFMEMORY;

    CImplIEnumNetCfgComponent* pObj;
    pObj = new CComObject <CImplIEnumNetCfgComponent>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_unIndex = 0;
        pObj->m_Class = Class;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            hr = pObj->QueryInterface (IID_IEnumNetCfgComponent,
                        (VOID**)ppIEnum);

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                pObj->HoldINetCfg (pINetCfg);
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplIEnumNetCfgComponent::HrCreateInstance");
    return hr;
}

HRESULT
CImplIEnumNetCfgComponent::HrNextOrSkip (
    IN ULONG celt,
    OUT INetCfgComponent** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    hr = HrLockAndTestForValidInterface (IF_DEFAULT);
    if (S_OK == hr)
    {
        CComponentList* pComponents;
        CComponent* pComponent;

        pComponents = &m_pINetCfg->m_pNetConfig->Core.Components;

        // Enumerate the requested number of elements or stop short
        // if we don't have that many left to enumerate.
        //
        ULONG celtFetched = 0;
        while ((S_OK == hr)
                && (celtFetched < celt)
                && (NULL != (pComponent = pComponents->PGetComponentAtIndex(
                                                            m_unIndex))))
        {
            // Don't return interfaces to components that have had
            // problem loading.
            //
            if (((NC_INVALID == m_Class) ||
                 (m_Class == pComponent->Class())) &&
                pComponent->Ext.FLoadedOkayIfLoadedAtAll())
            {
                if (rgelt)
                {
                    hr = pComponent->HrGetINetCfgComponentInterface(
                            m_pINetCfg, rgelt + celtFetched);
                }

                celtFetched++;
            }

            m_unIndex++;
        }

        Unlock();

        hr = HrFinishNextOrSkipContract (hr, celtFetched, celt,
                reinterpret_cast<IUnknown**>(rgelt), pceltFetched);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgComponent::HrNextOrSkip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgComponent::Next (
    IN ULONG celt,
    OUT INetCfgComponent** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else if (rgelt && IsBadWritePtr(rgelt, celt * sizeof(*rgelt)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgComponent::Next");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgComponent::Skip (
    IN ULONG celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgComponent::Skip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgComponent::Reset ()
{
    Lock();
    m_unIndex = 0;
    Unlock();

    return S_OK;
}

STDMETHODIMP
CImplIEnumNetCfgComponent::Clone (
    OUT IEnumNetCfgComponent** ppIEnum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\icomp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I C O M P . H
//
//  Contents:   Implements the INetCfgComponent COM interface.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"
#include "iatl.h"
#include "inetcfg.h"
#include "netcfgx.h"
#include "stable.h"

HRESULT
HrIsValidINetCfgComponent (
    IN INetCfgComponent* pICompInterface);

CComponent*
PComponentFromComInterface (
    IN INetCfgComponent* pICompInterface);

//+---------------------------------------------------------------------------
// INetCfgComponent -
//
class ATL_NO_VTABLE CImplINetCfgComponent :
    public CImplINetCfgHolder,
    public INetCfgComponent,
    public INetCfgComponentBindings,
    public INetCfgComponentPrivate
{
friend class CImplINetCfg;
friend class CImplINetCfgClass;
friend class CImplINetCfgBindingInterface;
friend class CImplINetCfgBindingPath;
friend class CComponent;
friend CComponent* PComponentFromComInterface (
        IN INetCfgComponent* pICompInterface);
friend HRESULT HrIsValidINetCfgComponent (
        IN INetCfgComponent* pICompInterface);

private:
    // Pointer to the component this object represents.  This points directly
    // into CNetConfig.Components.  When NULL, it means that someone
    // is still holding a reference to this object, but the underlying
    // CComponent has been removed from CNetConfig.
    //
    CComponent*     m_pComponent;

protected:
    HRESULT
    HrIsValidInterface (
        IN DWORD dwFlags);

    HRESULT
    HrLockAndTestForValidInterface (
        IN DWORD dwFlags,
        IN INetCfgComponent* pIOtherComp, OPTIONAL
        OUT CComponent** ppOtherComp OPTIONAL);

    HRESULT
    HrAccessExternalStringAtOffsetAndCopy (
        IN UINT unOffset,
        OUT PWSTR* ppszDst);

    HRESULT
    HrBindToOrUnbindFrom (
        IN INetCfgComponent* pIOtherComp,
        IN DWORD dwChangeFlag);

    HRESULT
    HrMoveBindPath (
        IN INetCfgBindingPath* pIPathSrc,
        IN INetCfgBindingPath* pIPathDst,
        IN MOVE_FLAG Flag);

public:
    CImplINetCfgComponent ()
    {
        m_pComponent = NULL;
    }

    BEGIN_COM_MAP(CImplINetCfgComponent)
        COM_INTERFACE_ENTRY(INetCfgComponent)
        COM_INTERFACE_ENTRY(INetCfgComponentBindings)
        COM_INTERFACE_ENTRY(INetCfgComponentPrivate)
    END_COM_MAP()

    // INetCfgComponent
    //
    STDMETHOD (GetDisplayName) (
        OUT PWSTR* ppszDisplayName);

    STDMETHOD (SetDisplayName) (
        IN PCWSTR pszDisplayName);

    STDMETHOD (GetHelpText) (
        OUT PWSTR* pszHelpText);

    STDMETHOD (GetId) (
        OUT PWSTR* ppszId);

    STDMETHOD (GetCharacteristics) (
        OUT LPDWORD pdwCharacteristics);

    STDMETHOD (GetInstanceGuid) (
        OUT GUID* pInstanceGuid);

    STDMETHOD (GetPnpDevNodeId) (
        OUT PWSTR* ppszDevNodeId);

    STDMETHOD (GetClassGuid) (
        OUT GUID* pguidClass);

    STDMETHOD (GetBindName) (
        OUT PWSTR* ppszBindName);

    STDMETHOD (GetDeviceStatus) (
        OUT ULONG* pulStatus);

    STDMETHOD (OpenParamKey) (
        OUT HKEY* phkey);

    STDMETHOD (RaisePropertyUi) (
        IN HWND hwndParent,
        IN DWORD dwFlags, /* NCRP_FLAGS */
        IN IUnknown* punkContext OPTIONAL);

    // INetCfgComponentBindings
    //
    STDMETHOD (BindTo) (
        IN INetCfgComponent* pIOtherComp);

    STDMETHOD (UnbindFrom) (
        IN INetCfgComponent* pIOtherComp);

    STDMETHOD (SupportsBindingInterface) (
        IN DWORD dwFlags,
        IN PCWSTR pszInterfaceName);

    STDMETHOD (IsBoundTo) (
        IN INetCfgComponent* pIOtherComp);

    STDMETHOD (IsBindableTo) (
        IN INetCfgComponent* pIOtherComp);

    STDMETHOD (EnumBindingPaths) (
        IN DWORD dwFlags,
        OUT IEnumNetCfgBindingPath** ppIEnum);

    STDMETHOD (MoveBefore) (
        IN INetCfgBindingPath* pIPathSrc,
        IN INetCfgBindingPath* pIPathDst);

    STDMETHOD (MoveAfter) (
        IN INetCfgBindingPath* pIPathSrc,
        IN INetCfgBindingPath* pIPathDst);

    // INetCfgComponentPrivate
    //
    STDMETHOD (QueryNotifyObject) (
        IN REFIID riid,
        OUT VOID** ppvObject);

    STDMETHOD (SetDirty) ();

    STDMETHOD (NotifyUpperEdgeConfigChange) ();


public:
    static HRESULT HrCreateInstance (
        IN  CImplINetCfg* pINetCfg,
        IN  CComponent* pComponent,
        OUT CImplINetCfgComponent** ppIComp);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\install.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I N S T A L L . H
//
//  Contents:   Implements actions related to installing components.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once

#include "comp.h"
#include "ncnetcfg.h"

struct COMPONENT_INSTALL_PARAMS
{
    IN NETCLASS                         Class;
    IN PCWSTR                           pszInfId;
    IN PCWSTR                           pszInfFile; OPTIONAL
    IN const OBO_TOKEN*                 pOboToken;  OPTIONAL
    IN const NETWORK_INSTALL_PARAMS*    pnip;       OPTIONAL
    IN HWND                             hwndParent; OPTIONAL
    IN CComponent*                      pComponent; OPTIONAL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\isdnhook.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N H O O K . H
//
//  Contents:   ISDN Hook functionality for the class installer.
//
//  Notes:
//
//  Author:     jeffspr   14 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _ISDNHOOK_H_
#define _ISDNHOOK_H_

HRESULT HrAddIsdnWizardPagesIfAppropriate(HDEVINFO hdi,
                                          PSP_DEVINFO_DATA pdeid);

#endif // _ISDNHOOK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\inetcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I N E T C F G . C P P
//
//  Contents:   Implements the COM interfaces on the top-level NetCfg object.
//              These interfaces are: INetCfg and INetCfgLock.  Also
//              implements a base C++ class inherited by sub-level NetCfg
//              objects which hold a reference to the top-level object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "classinst.h"
#include "iclass.h"
#include "icomp.h"
#include "ienum.h"
#include "inetcfg.h"
#include "ncperms.h"
#include "ncras.h"
#include "ncreg.h"
#include "ncui.h"
#include "ncvalid.h"
#include "ndispnp.h"
#include "netcfg.h"
#include "obotoken.h"
#include "resource.h"

// static
HRESULT
CImplINetCfg::HrCreateInstance (
    CNetConfig* pNetConfig,
    CImplINetCfg** ppINetCfg)
{
    Assert (pNetConfig);
    Assert (ppINetCfg);

    HRESULT hr = E_OUTOFMEMORY;

    CImplINetCfg* pObj;
    pObj = new CComObject <CImplINetCfg>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_pNetConfig = pNetConfig;
        Assert (!pObj->m_fOwnNetConfig);

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            AddRefObj (pObj->GetUnknown());
            *ppINetCfg = pObj;
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::HrCreateInstance");
    return hr;
}

HRESULT
CImplINetCfg::HrCoCreateWrapper (
    IN REFCLSID rclsid,
    IN LPUNKNOWN punkOuter,
    IN DWORD dwClsContext,
    IN REFIID riid,
    OUT LPVOID FAR* ppv)
{
/*
    HRESULT hr = S_OK;

    if (!m_fComInitialized)
    {
        m_fComInitialized = TRUE;

        hr = CoInitializeEx (
                NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
        if (SUCCEEDED(hr))
        {
            m_fUninitCom = TRUE;
            hr = S_OK;  // mask S_FALSE
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            Assert (!m_fUninitCom);
        }
    }

    if (S_OK == hr)
    {
        hr = CoCreateInstance (rclsid, punkOuter, dwClsContext, riid, ppv);
    }
*/

    HRESULT hr;
    hr = CoCreateInstance (rclsid, punkOuter, dwClsContext, riid, ppv);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::HrCoCreateWrapper");
    return hr;
}

HRESULT
CImplINetCfg::HrCheckForReentrancy (
    IN DWORD dwFlags)
{
    Assert (FImplies(dwFlags & IF_ALLOW_INSTALL_OR_REMOVE,
                     dwFlags & IF_REFUSE_REENTRANCY));

    if (dwFlags & IF_ALLOW_INSTALL_OR_REMOVE)
    {
        if (m_LastAllowedSetupRpl != m_CurrentRpl)
        {
            return E_FAIL;
        }
    }
    else if (0 != m_CurrentRpl)
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
CImplINetCfg::HrIsValidInterface (
    IN DWORD dwFlags)
{
    HRESULT hr;

    // Check if we need to refuse re-entrancy.
    //
    if (dwFlags & IF_REFUSE_REENTRANCY)
    {
        hr = HrCheckForReentrancy (dwFlags);
        if (S_OK != hr)
        {
            return hr;
        }
    }

    // Check if initialized/uninitalized as required.
    //
    if ((dwFlags & IF_NEED_UNINITIALIZED) && m_pNetConfig)
    {
        return NETCFG_E_ALREADY_INITIALIZED;
    }
    else if (!(dwFlags & IF_NEED_UNINITIALIZED) && !m_pNetConfig)
    {
        return NETCFG_E_NOT_INITIALIZED;
    }

    // Check for the write lock.
    //
    if (dwFlags & IF_NEED_WRITE_LOCK)
    {
        if (!m_WriteLock.FIsOwnedByMe ())
        {
            return NETCFG_E_NO_WRITE_LOCK;
        }

        // Needing the write lock means we need the modify context to
        // be prepared (unless the caller specified
        // IF_DONT_PREPARE_MODIFY_CONTEXT).
        //
        if (!m_pNetConfig->ModifyCtx.m_fPrepared &&
            !(dwFlags & IF_DONT_PREPARE_MODIFY_CONTEXT))
        {
            hr = m_pNetConfig->ModifyCtx.HrPrepare ();
            if (S_OK != hr)
            {
                return hr;
            }
        }
    }

    if (!(dwFlags & IF_UNINITIALIZING))
    {
        // Check for an error that occured during the current modification
        // that has not been rolled back yet.  i.e. keep people out until
        // we unwind enough to cleanup our modify context.
        //
        if (m_pNetConfig && (S_OK != m_pNetConfig->ModifyCtx.m_hr))
        {
            return m_pNetConfig->ModifyCtx.m_hr;
        }
    }

    Assert (FImplies(!m_pNetConfig, (dwFlags & IF_NEED_UNINITIALIZED)));

    return S_OK;
}

VOID
CImplINetCfg::LowerRpl (
    IN RPL_FLAGS Flags)
{
    if (RPL_ALLOW_INSTALL_REMOVE == Flags)
    {
        Assert (m_LastAllowedSetupRpl > 0);
        m_LastAllowedSetupRpl--;
    }

    Assert (m_CurrentRpl > 0);
    m_CurrentRpl--;
}

VOID
CImplINetCfg::RaiseRpl (
    IN RPL_FLAGS Flags)
{
    m_CurrentRpl++;

    if (RPL_ALLOW_INSTALL_REMOVE == Flags)
    {
        m_LastAllowedSetupRpl++;
    }
}

HRESULT
CImplINetCfg::HrLockAndTestForValidInterface (
    DWORD dwFlags)
{
    HRESULT hr;

    Lock();

    hr = HrIsValidInterface (dwFlags);

    if (S_OK != hr)
    {
        Unlock();
    }

    return hr;
}

//+---------------------------------------------------------------------------
// INetCfg -
//
STDMETHODIMP
CImplINetCfg::Initialize (
    IN PVOID pvReserved)
{
    HRESULT hr;

    ULONG* pReserved = (ULONG*)pvReserved;

    // Validate parameters.
    //
    if (FBadInPtrOptional(pReserved))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (
                IF_NEED_UNINITIALIZED | IF_REFUSE_REENTRANCY);
        if (S_OK == hr)
        {
            Assert (!m_pNetConfig);

            hr = CNetConfig::HrCreateInstance (
                    this,
                    &m_pNetConfig);

            if (S_OK == hr)
            {
                Assert (m_pNetConfig);

                m_fOwnNetConfig = TRUE;
            }
            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::Initialize");
    return hr;
}

STDMETHODIMP
CImplINetCfg::Uninitialize ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (
            IF_REFUSE_REENTRANCY | IF_UNINITIALIZING);
    if (S_OK == hr)
    {
        Assert (m_pNetConfig);
        Assert (m_fOwnNetConfig);

        delete m_pNetConfig;

        // CGlobalNotifyInterface::ReleaseINetCfg (called via the above
        // delete call) will set m_pNetConfig to NULL for us.
        // Verify it is so.
        //
        Assert (!m_pNetConfig);

        // Release our cache of INetCfgClass pointers.
        //
        ReleaseIUnknownArray (celems(m_apINetCfgClass), (IUnknown**)m_apINetCfgClass);
        ZeroMemory (m_apINetCfgClass, sizeof(m_apINetCfgClass));

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, NETCFG_E_NOT_INITIALIZED == hr,
        "CImplINetCfg::Uninitialize");
    return hr;
}

STDMETHODIMP
CImplINetCfg::Validate ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_REFUSE_REENTRANCY);
    if (S_OK == hr)
    {

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::Validate");
    return hr;
}

STDMETHODIMP
CImplINetCfg::Cancel ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_REFUSE_REENTRANCY);
    if (S_OK == hr)
    {
        // Only cancel the changes if we have a prepared modify context.
        //
        if (m_pNetConfig->ModifyCtx.m_fPrepared)
        {
            hr = m_pNetConfig->ModifyCtx.HrApplyIfOkOrCancel (FALSE);
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::Cancel");
    return hr;
}

STDMETHODIMP
CImplINetCfg::Apply ()
{
    HRESULT hr;

    // We need the write lock to Apply, but we don't want to prepare the
    // modify context if it has not been prepared.  (This case amounts to
    // applying no changes.)  Hence we use the IF_DONT_PREPARE_MODIFY_CONTEXT
    // flag.
    //
    hr = HrLockAndTestForValidInterface (
            IF_NEED_WRITE_LOCK | IF_REFUSE_REENTRANCY |
            IF_DONT_PREPARE_MODIFY_CONTEXT);
    if (S_OK == hr)
    {
        // Only apply the changes if we have a prepared modify context.
        //
        if (m_pNetConfig->ModifyCtx.m_fPrepared)
        {
            hr = m_pNetConfig->ModifyCtx.HrApplyIfOkOrCancel (TRUE);
        }

        // If there is nothing to apply, but we've previously applied
        // something that indicated a reboot was recommened or required,
        // return an indication.
        //
        else if (m_pNetConfig->ModifyCtx.m_fRebootRecommended ||
                 m_pNetConfig->ModifyCtx.m_fRebootRequired)
        {
            hr = NETCFG_S_REBOOT;
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, NETCFG_S_REBOOT == hr,
        "CImplINetCfg::Apply");
    return hr;
}

STDMETHODIMP
CImplINetCfg::EnumComponents (
    IN const GUID* pguidClass OPTIONAL,
    OUT IEnumNetCfgComponent** ppIEnum)
{
    HRESULT hr;
    NETCLASS Class;

    // Validate parameters.
    //
    if (FBadInPtrOptional(pguidClass) || FBadOutPtr(ppIEnum))
    {
        hr = E_POINTER;
    }
    else if (pguidClass &&
             (NC_INVALID == (Class = NetClassEnumFromGuid(*pguidClass))))
    {
        hr = E_INVALIDARG;
        *ppIEnum = NULL;
    }
    else
    {
        *ppIEnum = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            hr = CImplIEnumNetCfgComponent::HrCreateInstance (
                    this,
                    (pguidClass) ? Class : NC_INVALID,
                    ppIEnum);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::EnumComponents");
    return hr;
}

STDMETHODIMP
CImplINetCfg::FindComponent (
    IN PCWSTR pszInfId,
    OUT INetCfgComponent** ppIComp OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pszInfId) || FBadOutPtrOptional(ppIComp))
    {
        hr = E_POINTER;
    }
    else
    {
        if (ppIComp)
        {
            *ppIComp = NULL;
        }

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            CComponent* pComponent;

            pComponent = m_pNetConfig->Core.Components.
                            PFindComponentByInfId (pszInfId, NULL);

            // Don't return interfaces to components that have had
            // problem loading.
            //
            if (pComponent &&
                pComponent->Ext.FLoadedOkayIfLoadedAtAll())
            {
                hr = S_OK;

                if (ppIComp)
                {
                    hr = pComponent->HrGetINetCfgComponentInterface (
                            this, ppIComp);
                }
            }
            else
            {
                hr = S_FALSE;
            }


            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CImplINetCfg::FindComponent");
    return hr;
}

STDMETHODIMP
CImplINetCfg::QueryNetCfgClass (
    IN const GUID* pguidClass,
    IN REFIID riid,
    OUT VOID** ppv)
{
    HRESULT hr;
    NETCLASS Class;

    // Validate parameters.
    //
    if (FBadInPtr(pguidClass) || FBadInPtr(&riid) || FBadOutPtr(ppv))
    {
        hr = E_POINTER;
    }
    else if (NC_INVALID == (Class = NetClassEnumFromGuid(*pguidClass)))
    {
        hr = E_INVALIDARG;
        *ppv = NULL;
    }
    else
    {
        *ppv = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            // Get the INetCfgClass interface from our cache.
            //
            Assert(Class < celems(m_apINetCfgClass));
            INetCfgClass* pIClass = m_apINetCfgClass[Class];

            // If we don't have it yet, create it.
            //
            if (!pIClass)
            {
                hr = CImplINetCfgClass::HrCreateInstance (
                        this,
                        Class,
                        &pIClass);
                if (S_OK == hr)
                {
                    pIClass = m_apINetCfgClass[Class] = pIClass;
                    Assert(pIClass);
                }
            }

            // Give the caller the requested interface.
            //
            if (S_OK == hr)
            {
                hr = pIClass->QueryInterface (riid, ppv);
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::QueryNetCfgClass");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgLock -
//
STDMETHODIMP
CImplINetCfg::AcquireWriteLock (
    IN DWORD cmsTimeout,
    IN PCWSTR pszClientDescription,
    OUT PWSTR* ppszClientDescription OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pszClientDescription) ||
        FBadOutPtrOptional (ppszClientDescription))
    {
        hr = E_POINTER;
    }
    else
    {
        TraceTag (ttidNetcfgBase, "%S is asking for the write lock",
                pszClientDescription);

        // Initialize the optional output parameter.
        //
        if (ppszClientDescription)
        {
            *ppszClientDescription = NULL;
        }

        // Only administrators and netconfig operators can make changes requiring the write lock.
        //
        if (!FIsUserAdmin() && !FIsUserNetworkConfigOps())
        {
            hr = E_ACCESSDENIED;
        }
        else
        {
            hr = HrLockAndTestForValidInterface (
                    IF_NEED_UNINITIALIZED | IF_REFUSE_REENTRANCY);
            if (S_OK == hr)
            {
                // Wait for the mutex to become available.
                //
                if (m_WriteLock.WaitToAcquire (cmsTimeout,
                        pszClientDescription, ppszClientDescription))
                {
                    hr = S_OK;
                }
                else
                {
                    hr = S_FALSE;
                }

                Unlock();
            }
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfg::AcquireWriteLock");
    return hr;
}

STDMETHODIMP
CImplINetCfg::ReleaseWriteLock ()
{
    HRESULT hr;

    // This method that can be called whether we are initialized or
    // not.  That is why we don't call HrLockAndTestForValidInterface.
    //
    Lock ();

    // Check if we need to refuse re-entrancy.
    //
    hr = HrCheckForReentrancy (IF_DEFAULT);
    if (S_OK == hr)
    {
        m_WriteLock.ReleaseIfOwned ();
    }

    Unlock();

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::ReleaseWriteLock");
    return hr;
}

STDMETHODIMP
CImplINetCfg::IsWriteLocked (
    OUT PWSTR* ppszClientDescription)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtrOptional (ppszClientDescription))
    {
        hr = E_POINTER;
    }
    else
    {
        if (ppszClientDescription)
        {
            *ppszClientDescription = NULL;
        }

        // This method that can be called whether we are initialized or
        // not.  That is why we don't call HrLockAndTestForValidInterface.
        //
        Lock ();

        // Check if we need to refuse re-entrancy.
        //
        hr = HrCheckForReentrancy (IF_DEFAULT);
        if (S_OK == hr)
        {
            hr = (m_WriteLock.FIsLockedByAnyone (ppszClientDescription))
                    ? S_OK : S_FALSE;
        }

        Unlock ();
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfg::IsWriteLocked");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgInternalSetup -
//
STDMETHODIMP
CImplINetCfg::BeginBatchOperation ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK);

    if (S_OK == hr)
    {
        hr = m_pNetConfig->ModifyCtx.HrBeginBatchOperation ();

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "BeginBatchOperation");
    return hr;
}

STDMETHODIMP
CImplINetCfg::CommitBatchOperation ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK);

    if (S_OK == hr)
    {
        hr = m_pNetConfig->ModifyCtx.HrEndBatchOperation (EBO_COMMIT_NOW);

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CommitBatchOperation");
    return hr;
}

STDMETHODIMP
CImplINetCfg::SelectWithFilterAndInstall (
    IN HWND hwndParent,
    IN const GUID* pClassGuid,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    IN const CI_FILTER_INFO* pcfi OPTIONAL,
    OUT INetCfgComponent** ppIComp OPTIONAL)
{
    Assert (pClassGuid);
    HRESULT hr;
    NETCLASS Class;

    if (FBadInPtr(pClassGuid))
    {
        hr = E_POINTER;
    }
    else if (FIsEnumerated ((Class = NetClassEnumFromGuid(*pClassGuid))))
    {
        // This fcn is only for selecting non-enumerated components.
        //
        return E_INVALIDARG;
    }
    else if (!FOboTokenValidForClass(pOboToken, Class) ||
             FBadOutPtrOptional(ppIComp))
    {
        hr = E_POINTER;
    }
    else if (hwndParent && !IsWindow(hwndParent))
    {
        hr = E_INVALIDARG;
    }
    else if (S_OK == (hr = HrProbeOboToken(pOboToken)))
    {
        if (ppIComp)
        {
            *ppIComp = NULL;
        }

        hr = HrLockAndTestForValidInterface (
                IF_NEED_WRITE_LOCK | IF_ALLOW_INSTALL_OR_REMOVE);

        if (S_OK == hr)
        {
            Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

            // if a filter info was specified, and it is for FC_LAN or FC_ATM,
            // we need to set up the reserved member of the filter info for
            // the class installer.
            //
            if (pcfi &&
                    ((FC_LAN == pcfi->eFilter) || (FC_ATM == pcfi->eFilter)))
            {
                // If the pIComp member was NULL, then return invalid
                // argument.
                //
                Assert (pcfi->pIComp);
                CImplINetCfgComponent* pICompImpl;
                pICompImpl = (CImplINetCfgComponent*)pcfi->pIComp;

                hr = pICompImpl->HrIsValidInterface (IF_NEED_COMPONENT_DATA);

                if (S_OK == hr)
                {
                    // The class installer only needs the component's
                    // range of upper interfaces so we need to store that in the
                    // reserved field of the filter info
                    Assert (pICompImpl->m_pComponent);
                    ((CI_FILTER_INFO*)pcfi)->pvReserved = (void*)
                            pICompImpl->m_pComponent->Ext.PszUpperRange();
                }
            }

            COMPONENT_INSTALL_PARAMS* pParams;
            hr = HrCiSelectComponent (Class, hwndParent, pcfi, &pParams);

            if (pcfi)
            {
                // Don't want to return the private data to the client.
                //
                ((CI_FILTER_INFO*)pcfi)->pvReserved = NULL;
            }

            // Check for installing a NET_SERVICE and active RAS connections
            // exist.  If so, warn the user that this may disconnect those
            // connections.  (This assumes that all filter components are
            // of class NET_SERVICE.)
            //
            if (S_OK == hr)
            {
                Assert (pParams);
                if ((NC_NETSERVICE == pParams->Class) &&
                    FExistActiveRasConnections ())
                {
                    INT nRet;

                    nRet = NcMsgBox (
                            _Module.GetResourceInstance(),
                            hwndParent,
                            IDS_WARNING_CAPTION,
                            IDS_ACTIVE_RAS_CONNECTION_WARNING,
                            MB_ICONQUESTION | MB_YESNO);

                    if (IDYES != nRet)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    }
                }
            }

            if (S_OK == hr)
            {
                Assert(pParams);
                CComponent* pComponent;

                // Check to see if the user selected a component that
                // is already installed.  If so, we need to reinstall.
                //
                pComponent = m_pNetConfig->Core.Components.
                        PFindComponentByInfId(pParams->pszInfId, NULL);

                if (!pComponent)
                {
                    pParams->pOboToken = pOboToken;
                    hr = m_pNetConfig->ModifyCtx.
                            HrInstallNewOrReferenceExistingComponent (
                                *pParams, &pComponent);
                }
                else
                {
                    // reinstall. call Update.
                    hr = UpdateNonEnumeratedComponent (
                            pComponent->GetINetCfgComponentInterface(),
                            NSF_COMPONENT_UPDATE, 0);
                }

                // The above may return NETCFG_S_REBOOT so use SUCCEEDED instead
                // of checking for S_OK only.
                //
                if (SUCCEEDED(hr) && ppIComp)
                {
                    pComponent->HrGetINetCfgComponentInterface (
                        this,
                        ppIComp);
                }

                delete pParams;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ||
        (NETCFG_S_REBOOT == hr),
        "SelectWithFilterAndInstall");
    return hr;
}

STDMETHODIMP
CImplINetCfg::EnumeratedComponentInstalled (
    IN PVOID pv /* type of CComponent */)
{
    HRESULT hr;
    CComponent* pComponent;

    pComponent = (CComponent*)pv;

    Assert (pComponent);
    Assert (FIsEnumerated(pComponent->Class()));
    Assert (pComponent->m_pszInfId && *pComponent->m_pszInfId);
    Assert (pComponent->m_pszPnpId && *pComponent->m_pszPnpId);

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK |
            IF_ALLOW_INSTALL_OR_REMOVE);

    if (S_OK == hr)
    {
        COMPONENT_INSTALL_PARAMS Params;
        CComponent* pReturned;

        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        ZeroMemory(&Params, sizeof(Params));
        Params.pComponent = (CComponent*)pComponent;

        hr = m_pNetConfig->ModifyCtx.HrInstallNewOrReferenceExistingComponent (
                            Params,
                            &pReturned);

        if (S_OK == hr)
        {
            Assert (pComponent == pReturned);
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "EnumeratedComponentInstalled");
    return hr;
}

STDMETHODIMP
CImplINetCfg::EnumeratedComponentUpdated (
    IN PCWSTR pszPnpId)
{
    HRESULT hr;

    Assert (pszPnpId && *pszPnpId);

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK);

    if (S_OK == hr)
    {
        CComponent* pComponent;

        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        pComponent = m_pNetConfig->Core.Components.
                        PFindComponentByPnpId (pszPnpId);

        if (pComponent)
        {
            // Note: Core info may have changed so load core info from driver key.

            // If not a remote boot adapter, do a binding analysis to see if
            // anything has changed.

            hr = S_OK;
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "EnumeratedComponentUpdated");
    return hr;
}

STDMETHODIMP
CImplINetCfg::UpdateNonEnumeratedComponent (
    IN INetCfgComponent* pIComp,
    IN DWORD dwSetupFlags,
    IN DWORD dwUpgradeFromBuildNo)
{
    HRESULT hr;

    Assert (pIComp);

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK |
            IF_ALLOW_INSTALL_OR_REMOVE);

    if (S_OK == hr)
    {
        CImplINetCfgComponent* pICompToUpdate;

        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        pICompToUpdate = (CImplINetCfgComponent*)pIComp;
        if (pICompToUpdate == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = pICompToUpdate->HrIsValidInterface (IF_NEED_COMPONENT_DATA);

        if (S_OK == hr)
        {
            HKEY hkeyInstance;
            CComponent* pComponent = pICompToUpdate->m_pComponent;


            hr = pComponent->HrOpenInstanceKey (KEY_READ_WRITE_DELETE, &hkeyInstance,
                    NULL, NULL);

            if (S_OK == hr)
            {
                DWORD dwNewCharacter;
                COMPONENT_INSTALL_PARAMS Params;
                ZeroMemory (&Params, sizeof (Params));

                Params.Class = pComponent->Class();
                Params.pszInfId = pComponent->m_pszInfId;

                hr = HrCiInstallComponent (Params, NULL, &dwNewCharacter);

                // The driver could not be selected because
                // this component's section or inf is missing.
                // We will remove the component in this case.
                //
                if (SPAPI_E_NO_DRIVER_SELECTED == hr)
                {
                    pComponent->Refs.RemoveAllReferences();

                    hr = m_pNetConfig->ModifyCtx.
                            HrRemoveComponentIfNotReferenced (pComponent,
                                NULL, NULL);
                }
                else if (S_OK == hr)
                {
                    pComponent->m_dwCharacter = dwNewCharacter;

                    AddOrRemoveDontExposeLowerCharacteristicIfNeeded (
                            pComponent);

                    hr = m_pNetConfig->ModifyCtx.HrUpdateComponent (
                            pComponent,
                            dwSetupFlags,
                            dwUpgradeFromBuildNo);
                }
                RegCloseKey (hkeyInstance);
            }
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "UpdateNonEnumeratedComponent");
    return S_OK;
}


STDMETHODIMP
CImplINetCfg::EnumeratedComponentRemoved (
    IN PCWSTR pszPnpId)
{
    HRESULT hr;

    Assert (pszPnpId);

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK |
            IF_ALLOW_INSTALL_OR_REMOVE);

    if (S_OK == hr)
    {
        CComponent* pComponent;

        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        pComponent = m_pNetConfig->Core.Components.
                        PFindComponentByPnpId (pszPnpId);

        // If we found it, remove it.  Otherwise our work here is done.
        //
        if (pComponent)
        {
            hr = m_pNetConfig->ModifyCtx.
                    HrRemoveComponentIfNotReferenced (pComponent, NULL, NULL);
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "EnumeratedComponentRemoved");
    return hr;
}


//+---------------------------------------------------------------------------
// INetCfgSpecialCase -
//
STDMETHODIMP
CImplINetCfg::GetAdapterOrder (
    OUT DWORD* pcAdapters,
    OUT INetCfgComponent*** papAdapters,
    OUT BOOL* pfWanAdaptersFirst)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImplINetCfg::SetAdapterOrder (
    IN DWORD cAdapters,
    IN INetCfgComponent** apAdapters,
    IN BOOL fWanAdaptersFirst)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImplINetCfg::GetWanAdaptersFirst (
    OUT BOOL* pfWanAdaptersFirst)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pfWanAdaptersFirst))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            *pfWanAdaptersFirst = m_pNetConfig->Core.
                                    StackTable.m_fWanAdaptersFirst;

            Unlock();
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::GetWanAdaptersFirst");
    return hr;
}

STDMETHODIMP
CImplINetCfg::SetWanAdaptersFirst (
    IN BOOL fWanAdaptersFirst)
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK);
    if (S_OK == hr)
    {
        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        m_pNetConfig->Core.StackTable.SetWanAdapterOrder (!!fWanAdaptersFirst);

        Unlock();
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::SetWanAdaptersFirst");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgPnpReconfigCallback -
//
STDMETHODIMP
CImplINetCfg::SendPnpReconfig (
    IN NCPNP_RECONFIG_LAYER Layer,
    IN PCWSTR pszUpper,
    IN PCWSTR pszLower,
    IN PVOID pvData,
    IN DWORD dwSizeOfData)
{
    HRESULT hr;

    if ((NCRL_NDIS != Layer) && (NCRL_TDI != Layer))
    {
        hr = E_INVALIDARG;
    }
    else if (FBadInPtr(pszUpper) || FBadInPtr(pszLower) ||
             IsBadReadPtr(pvData, dwSizeOfData))
    {
        hr = E_POINTER;
    }
    else
    {
        BOOL fOk;
        UNICODE_STRING LowerString;
        UNICODE_STRING UpperString;
        UNICODE_STRING BindList;
        WCHAR szLower [_MAX_PATH];

        hr = S_OK;

        *szLower = 0;
        if (*pszLower)
        {
            wcscpy (szLower, L"\\Device\\");
            wcsncat (szLower, pszLower, celems(szLower) - wcslen(szLower));
        }

        RtlInitUnicodeString (&LowerString, szLower);
        RtlInitUnicodeString (&UpperString, pszUpper);
        RtlInitUnicodeString (&BindList, NULL);

        fOk = NdisHandlePnPEvent (
                (NCRL_NDIS == Layer) ? NDIS : TDI,
                RECONFIGURE,
                &LowerString,
                &UpperString,
                &BindList,
                pvData,
                dwSizeOfData);

        if (!fOk)
        {
            hr = HrFromLastWin32Error ();
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::SendPnpReconfig");
    return hr;
}

//+---------------------------------------------------------------------------
// CImplINetCfgHolder -
//

VOID
CImplINetCfgHolder::HoldINetCfg (
    CImplINetCfg* pINetCfg)
{
    Assert(pINetCfg);
    AddRefObj (pINetCfg->GetUnknown());
    m_pINetCfg = pINetCfg;
}

HRESULT
CImplINetCfgHolder::HrLockAndTestForValidInterface (
    DWORD dwFlags)
{
    HRESULT hr;

    Lock();

    hr = m_pINetCfg->HrIsValidInterface (dwFlags);

    if (S_OK != hr)
    {
        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgHolder::HrLockAndTestForValidInterface");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\inetcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I N E T C F G . H
//
//  Contents:   Implements the COM interfaces on the top-level NetCfg object.
//              These interfaces are: INetCfg and INetCfgLock.  Also
//              implements a base C++ class inherited by sub-level NetCfg
//              objects which hold a reference to the top-level object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "iatl.h"
#include "compdefs.h"
#include "nccom.h"
#include "ncres.h"
#include "netcfgp.h"
#include "netcfgn.h"
#include "wrlock.h"

// Flags for HrIsValidInterface.
//
enum IF_FLAGS
{
    IF_DEFAULT                      = 0x00000000,
    IF_NEED_UNINITIALIZED           = 0x00000001,
    IF_NEED_WRITE_LOCK              = 0x00000002,
    IF_NEED_COMPONENT_DATA          = 0x00000004,
    IF_REFUSE_REENTRANCY            = 0x00000010,
    IF_ALLOW_INSTALL_OR_REMOVE      = 0x00000020,
    IF_UNINITIALIZING               = 0x00000040,
    IF_DONT_PREPARE_MODIFY_CONTEXT  = 0x00000080,
};

enum RPL_FLAGS
{
    RPL_ALLOW_INSTALL_REMOVE,
    RPL_DISALLOW,
};

class CNetConfig;

class ATL_NO_VTABLE CImplINetCfg :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass<CImplINetCfg, &CLSID_CNetCfg>,
    public INetCfg,
    public INetCfgLock,
    public INetCfgInternalSetup,
    public INetCfgSpecialCase,
    public INetCfgPnpReconfigCallback
{
friend class CGlobalNotifyInterface;
friend class CImplIEnumNetCfgBindingPath;
friend class CImplIEnumNetCfgComponent;
friend class CImplINetCfgBindingPath;
friend class CImplINetCfgClass;
friend class CImplINetCfgComponent;
friend class CModifyContext;
friend class CNetCfgInternalDiagnostic;
friend class CNetConfig;
friend class CNotifyObjectInterface;

private:
    // This is our data.  We own it (i.e. we created it) if Initialize is
    // called.  We will delete it when Unintialize is called.  We won't own
    // it if we were created by CNetConfig.
    //
    CNetConfig*     m_pNetConfig;

    // m_apINetCfgClass is an array of cached INetCfgClass pointers.
    // These are created in QueryNetCfgClass (if needed) and released
    // during Uninitialize.
    //
    INetCfgClass*   m_apINetCfgClass [NC_CELEMS];

    // This controls the write lock.
    //
    CWriteLock      m_WriteLock;

    // Reentrancy Protection Levels.  General reentrancy is prevented when
    // m_CurrentRpl is non-zero.  Reentrancy for setup calls (Install or
    // Remove) is allowed when m_LastAllowedSetupRpl equals m_CurrentRpl.
    // Both are incremented when we call a notify object and we want to
    // prevent general reentrancy but allow Install or Remove.  Only
    // m_CurrentRpl is incremented when we want to prevent all reentrancy.
    // See LowerRpl() and RaiseRpl().
    //
    ULONG           m_CurrentRpl;
    ULONG           m_LastAllowedSetupRpl;

    BOOLEAN         m_fOwnNetConfig;

private:
    HRESULT
    HrCheckForReentrancy (
        IN DWORD dwFlags);

    HRESULT
    HrLockAndTestForValidInterface (
        IN DWORD dwFlags);

    VOID
    LowerRpl (
        IN RPL_FLAGS Flags);

    VOID
    RaiseRpl (
        IN RPL_FLAGS Flags);

public:
    CImplINetCfg ()
    {
        m_pNetConfig = NULL;
        m_CurrentRpl = 0;
        m_LastAllowedSetupRpl = 0;
        m_fOwnNetConfig = FALSE;
        ZeroMemory (m_apINetCfgClass, sizeof(m_apINetCfgClass));
    }

    VOID FinalRelease ()
    {
        // Should be NULL because we either delete it during Uninitialize,
        // or it is NULL'd for us via CGlobalNotifyInterface::ReleaseINetCfg
        // before they release us.
        //
        AssertH (!m_pNetConfig);

        // Release our cache of INetCfgClass pointers.
        //
        ReleaseIUnknownArray (celems(m_apINetCfgClass), (IUnknown**)m_apINetCfgClass);

    }

    HRESULT HrCoCreateWrapper (
        IN REFCLSID rclsid,
        IN LPUNKNOWN pUnkOuter,
        IN DWORD dwClsContext,
        IN REFIID riid,
        OUT LPVOID FAR* ppv);

    HRESULT HrIsValidInterface (
        DWORD dwFlags);

    BEGIN_COM_MAP(CImplINetCfg)
        COM_INTERFACE_ENTRY(INetCfg)
        COM_INTERFACE_ENTRY(INetCfgLock)
        COM_INTERFACE_ENTRY(INetCfgInternalSetup)
        COM_INTERFACE_ENTRY(INetCfgSpecialCase)
        COM_INTERFACE_ENTRY(INetCfgPnpReconfigCallback)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NETCFG)

    // INetCfg
    //
    STDMETHOD (Initialize) (
        IN PVOID pvReserved);

    STDMETHOD (Uninitialize) ();

    STDMETHOD (Validate) ();

    STDMETHOD (Cancel) ();

    STDMETHOD (Apply) ();

    STDMETHOD (EnumComponents) (
        IN const GUID* pguidClass OPTIONAL,
        OUT IEnumNetCfgComponent** ppIEnum);

    STDMETHOD (FindComponent) (
        IN PCWSTR pszInfId,
        OUT INetCfgComponent** ppIComp);

    STDMETHOD (QueryNetCfgClass) (
        IN const GUID* pguidClass,
        IN REFIID riid,
        OUT VOID** ppv);

    // INetCfgLock
    //
    STDMETHOD (AcquireWriteLock) (
        IN DWORD cmsTimeout,
        IN PCWSTR pszClientDescription,
        OUT PWSTR* ppszClientDescription);

    STDMETHOD (ReleaseWriteLock) ();

    STDMETHOD (IsWriteLocked) (
        OUT PWSTR* ppszClientDescription);

    // INetCfgInternalSetup
    //
    STDMETHOD (BeginBatchOperation) ();
    STDMETHOD (CommitBatchOperation) ();

    STDMETHOD (SelectWithFilterAndInstall) (
        IN HWND hwndParent,
        IN const GUID* pClassGuid,
        IN OBO_TOKEN* pOboToken,
        IN const CI_FILTER_INFO* pcfi,
        OUT INetCfgComponent** ppnccItem);

    STDMETHOD (EnumeratedComponentInstalled) (
        IN PVOID pComponent /* type of CComponent */);

    STDMETHOD (EnumeratedComponentUpdated) (
        IN PCWSTR pszPnpId);

    STDMETHOD (UpdateNonEnumeratedComponent) (
        IN INetCfgComponent* pIComp,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo);

    STDMETHOD (EnumeratedComponentRemoved) (
        IN PCWSTR pszPnpId);

    // INetCfgSpecialCase
    //
    STDMETHOD (GetAdapterOrder) (
        OUT DWORD* pcAdapters,
        OUT INetCfgComponent*** papAdapters,
        OUT BOOL* pfWanAdaptersFirst);

    STDMETHOD (SetAdapterOrder) (
        IN DWORD cAdapters,
        IN INetCfgComponent** apAdapters,
        IN BOOL fWanAdaptersFirst);

    STDMETHOD (GetWanAdaptersFirst) (
        OUT BOOL* pfWanAdaptersFirst);

    STDMETHOD (SetWanAdaptersFirst) (
        IN BOOL fWanAdaptersFirst);

    // INetCfgPnpReconfigCallback
    //
    STDMETHOD (SendPnpReconfig) (
        IN NCPNP_RECONFIG_LAYER Layer,
        IN PCWSTR pszUpper,
        IN PCWSTR pszLower,
        IN PVOID pvData,
        IN DWORD dwSizeOfData);

    static HRESULT
    HrCreateInstance (
        CNetConfig* pNetConfig,
        CImplINetCfg** ppINetCfg);
};


//+---------------------------------------------------------------------------
// CImplINetCfgHolder -
//
// No need for a critical section for these objects because they
// use the lock provided by CImplINetCfg.  i.e. use CComMultiThreadModelNoCS
// instead of CComMultiThreadModel.
//
class ATL_NO_VTABLE CImplINetCfgHolder :
    public CComObjectRootEx <CComMultiThreadModelNoCS>
{
protected:
    CImplINetCfg*   m_pINetCfg;

protected:
    VOID HoldINetCfg (
        CImplINetCfg* pINetCfg);

    HRESULT HrLockAndTestForValidInterface (
        DWORD dwFlags);

public:
    CImplINetCfgHolder ()
    {
        m_pINetCfg = NULL;
    }

#if DBG
    ~CImplINetCfgHolder ()
    {
        AssertH (!m_pINetCfg);
    }
#endif // DBG

    VOID FinalRelease ()
    {
        AssertH (m_pINetCfg);
        ReleaseObj (m_pINetCfg->GetUnknown());

#if DBG
        m_pINetCfg = NULL;
#endif // DBG

        CComObjectRootEx <CComMultiThreadModelNoCS>::FinalRelease();
    }

    VOID Lock ()
    {
        CComObjectRootEx <CComMultiThreadModelNoCS>::Lock();

        AssertH(m_pINetCfg);
        m_pINetCfg->Lock ();
    }
    VOID Unlock ()
    {
        AssertH(m_pINetCfg);
        m_pINetCfg->Unlock ();

        CComObjectRootEx <CComMultiThreadModelNoCS>::Unlock();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\install.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I N S T A L L . C P P
//
//  Contents:   Implements actions related to installing components.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "classinst.h"
#include "lockdown.h"
#include "netcfg.h"
#include "obotoken.h"
#include "util.h"


#if DBG

VOID
DbgVerifyComponentInstallParams (
    IN const COMPONENT_INSTALL_PARAMS& Params)
{
    if (!Params.pComponent)
    {
        Assert (FIsValidNetClass (Params.Class));
        Assert (Params.pszInfId && *Params.pszInfId);
        Assert (FOboTokenValidForClass (Params.pOboToken, Params.Class));
    }
}

#else

#define DbgVerifyComponentInstallParams NOP_FUNCTION

#endif


VOID
CModifyContext::InstallAndAddAndNotifyComponent(
    IN const COMPONENT_INSTALL_PARAMS& Params,
    OUT CComponent** ppComponent)
{
    CNetConfig* pNetConfig;
    CComponent* pComponent;
    UINT cPreviousAddedBindPaths;

    Assert (this);
    Assert (S_OK == m_hr);
    DbgVerifyComponentInstallParams (Params);
    Assert (ppComponent);

    pNetConfig = PNetConfig();

    // Call the class installer to do the grunt work of finding the
    // INF, processing it, creating the instance key, etc.  If this
    // all succeeds, we are returned an allocated CComponent.
    //
    //$REVIEW: Think about having HrCiInstallComponent return the
    // list of required components.  This will keep us from having to
    // reopen the instance key and ndi key.
    //
    if (!Params.pComponent)
    {

// error test only
//if (0 == _wcsicmp(L"ms_nwipx", Params.pszInfId))
//{
//    TraceTag (ttidBeDiag, "Simulating failure for: %S", Params.pszInfId);
//    m_hr = E_FAIL;
//    return;
//}

        m_hr = HrCiInstallComponent (Params, &pComponent, NULL);
        if (S_OK != m_hr)
        {
            Assert(FAILED(m_hr));
            return;
        }
    }
    else
    {
        pComponent = Params.pComponent;
    }
    Assert (pComponent);

    // Install all of the components required by this component.
    //
    // THIS MAY CAUSE RECURSION
    //
    InstallOrRemoveRequiredComponents (pComponent, IOR_INSTALL);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // If this is an enumerated component, and it has the same PnpId as
    // a component already in our core, we will remove the existing component.
    // This can happen if an adapter is removed and reinstalled and the
    // binding engine could not be notified of both because the write
    // lock was held at the time of remove.
    //
    if (FIsEnumerated(pComponent->Class()))
    {
        CComponent* pDup;

        while (NULL != (pDup = pNetConfig->Core.Components.PFindComponentByPnpId (
                                    pComponent->m_pszPnpId)))
        {
            TraceTag (ttidBeDiag, "Removing duplicate PnpId: %S",
                pComponent->m_pszPnpId);

            pDup->Refs.RemoveAllReferences();
            (VOID) HrRemoveComponentIfNotReferenced (pDup, NULL, NULL);
        }
    }

    // We only insert the component and its stack table entries into our
    // list after all of its required components have been installed.
    // This is just the concept of "don't consider a component installed
    // until all of its requirements are also installed".
    // i.e. Atomicity of component installation.
    //
    m_hr = pNetConfig->Core.HrAddComponentToCore (pComponent, INS_SORTED);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Notify the component's notify object it is being installed.
    // This also sends global notifications to other notify objects
    // who may be interested.
    //
    // THIS MAY CAUSE RECURSION
    //
    m_hr = pNetConfig->Notify.ComponentAdded (pComponent, Params.pnip);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Note the number of bindpaths currently in m_AddedBindPaths.
    // We need this so that when we add to the set, we only notify
    // for the ones we add.
    //
    cPreviousAddedBindPaths = m_AddedBindPaths.CountBindPaths ();

    // Get the bindpaths that involve the component we are adding.
    // Add these to the added bindpaths we are keeping track of.
    //
    m_hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                pComponent,
                GBF_ADD_TO_BINDSET | GBF_ONLY_WHICH_CONTAIN_COMPONENT,
                &m_AddedBindPaths);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Query and notify for these added bindpaths.
    //
    // THIS MAY CAUSE RECURSION
    //
    if (m_AddedBindPaths.CountBindPaths() > cPreviousAddedBindPaths)
    {
        m_hr = pNetConfig->Notify.QueryAndNotifyForAddedBindPaths (
                    &m_AddedBindPaths,
                    cPreviousAddedBindPaths);
        if (S_OK != m_hr)
        {
            Assert(FAILED(m_hr));
            return;
        }
    }

    // Install any components as a convenience to the user
    // depending on the component we just installed component.
    //
    // THIS MAY CAUSE RECURSION
    //
    InstallConvenienceComponentsForUser (pComponent);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Assign the output pointer.
    //
    Assert (S_OK == m_hr);
    Assert (pComponent);
    *ppComponent = pComponent;
}


//+---------------------------------------------------------------------------
// Install components on behalf of the user
//
// Assumptions:
//
VOID
CModifyContext::InstallConvenienceComponentsForUser (
    IN const CComponent* pComponent)
{
    COMPONENT_INSTALL_PARAMS Params;
    OBO_TOKEN UserOboToken;
    CComponent* pNewComponent;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (pComponent);

    ZeroMemory (&UserOboToken, sizeof(UserOboToken));
    UserOboToken.Type = OBO_USER;

    // If the component is an ATM adapter, make sure ATMUNI and ATMLANE are
    // installed.
    //
    if (FSubstringMatch (L"ndisatm", pComponent->Ext.PszUpperRange(),
            NULL, NULL))
    {
        ZeroMemory (&Params, sizeof(Params));
        Params.pOboToken = &UserOboToken;
        Params.Class = NC_NETTRANS;

        Params.pszInfId  = L"ms_atmuni";
        HrInstallNewOrReferenceExistingComponent (Params, &pNewComponent);

        Params.pszInfId  = L"ms_atmlane";
        HrInstallNewOrReferenceExistingComponent (Params, &pNewComponent);
    }
}

HRESULT
CModifyContext::HrInstallNewOrReferenceExistingComponent (
    IN const COMPONENT_INSTALL_PARAMS& Params,
    OUT CComponent** ppComponent)
{
    HRESULT hr;
    BOOL fInstallNew;
    CNetConfig* pNetConfig;
    CComponent* pComponent;

    Assert (this);
    Assert (S_OK == m_hr);
    DbgVerifyComponentInstallParams (Params);
    Assert (ppComponent);

    // Initialize the output parameter.
    //
    *ppComponent = NULL;

    // Assume, for now, that we will be installing a new component.
    //
    hr = S_OK;
    fInstallNew = TRUE;
    pNetConfig = PNetConfig();
    pComponent = NULL;

    // If the user wishes to add a reference if the component is already
    // installed...
    //
    if (Params.pOboToken)
    {
        // ...then look to see if the component is installed...
        //
        pComponent = pNetConfig->Core.Components.
                        PFindComponentByInfId (Params.pszInfId, NULL);

        // ...if it is, we won't be installing a new one.
        //
        if (pComponent)
        {
            fInstallNew = FALSE;

            if (pComponent->m_dwCharacter & NCF_SINGLE_INSTANCE)
            {
                *ppComponent = NULL;
                return HRESULT_FROM_SETUPAPI(ERROR_DEVINST_ALREADY_EXISTS);
            }

            // If the existing component is already referenced by
            // the specified obo token, we can return.
            //
            if (pComponent->Refs.FIsReferencedByOboToken (Params.pOboToken))
            {
                *ppComponent = pComponent;
                return S_OK;
            }
        }

        // ...otherwise, (it is not in the current core) but if it IS
        // in the core we started with, it means someone had previously
        // removed it during this modify context and now wants to add it
        // back.  This is tricky and should probably be implemented later.
        // For now, return an error and throw up an assert so we can see
        // who needs to do this.
        //
        else if (m_CoreStartedWith.Components.
                        PFindComponentByInfId (Params.pszInfId, NULL))
        {
            AssertSz (FALSE, "Whoa.  Someone is trying to install a "
                "component that was previously removed during this same "
                "modify context.  We need to decide if we can support this.");
            return E_UNEXPECTED;
        }
    }

    // If we've decided to install a new component, (which can happen
    // if an obo token was not specified OR if an obo token was specified
    // but the component was not already present) then do the work.
    //
    if (fInstallNew)
    {
        // If the component to be installed is locked down, bail out.
        // Note we don't put the modify context into error if this situation
        // occurs.
        // Note too that we only do this if Params.pComponent is not present
        // which would indicate the class installer calling us to install an
        // enumerated component.
        //
        if (!Params.pComponent)
        {
            if (FIsComponentLockedDown (Params.pszInfId))
            {
                TraceTag (ttidBeDiag, "%S is locked down and cannot be installed "
                    "until the next reboot.",
                    Params.pszInfId);

                return NETCFG_E_NEED_REBOOT;
            }
        }

        // Make sure the modify context is setup and keep track of our
        // recursion depth.
        //
        PushRecursionDepth ();
        Assert (S_OK == m_hr);

        InstallAndAddAndNotifyComponent (Params, ppComponent);

        hr = HrPopRecursionDepth ();

        // If the component to be installed was not found, the return code
        // will be SPAPI_E_NO_DRIVER_SELECTED.  We want to return this to the
        // caller, but we don't need the context to remain with this error.
        // This will allow subsequent calls to install other componetns to
        // proceed.
        //
        if (SPAPI_E_NO_DRIVER_SELECTED == m_hr)
        {
            m_hr = S_OK;
            Assert (SPAPI_E_NO_DRIVER_SELECTED == hr);
        }
    }
    else
    {
        // Referencing pComponent on behalf of the obo token.
        //
        Assert (pComponent);
        Assert (Params.pOboToken);

        // Make sure the modify context is setup and keep track of our
        // recursion depth.
        //
        PushRecursionDepth ();
        Assert (S_OK == m_hr);

        m_hr = pComponent->Refs.HrAddReferenceByOboToken (Params.pOboToken);

        if (S_OK == m_hr)
        {
            *ppComponent = pComponent;
        }

        hr = HrPopRecursionDepth ();
    }

    // If we are returning success, we'd better have our ouput parameter set.
    //
    Assert (FImplies(SUCCEEDED(hr), *ppComponent));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\lanamap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       L A N A M A P . H
//
//  Contents:   NetBios Lana map routines.
//
//  Notes:
//
//  Author:     billbe   17 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

#include "nb30.h"
#include "ncstring.h"
#include "netcfg.h"
#include "util.h"

//
// Structure of LANA MAP
//
// The Lana map is a simple structure that looks like this in memory:
//
//    Entry #0    Entry #1   .....   Entry #n
// |-----------|-----------| ..... |-----------|
// | 0x01 0x00 | 0x00 0x01 | ..... | 0x01 0x03 |
// |-----------|-----------| ..... |-----------|
//   EP0   LN0   EP1   LN1           EPn  LNn
//
// EP is "ExportPref" - means that when someone asks for the list of
// all Lana numbers, entries with a 0 here will not be returned.
//
// LN is the "Lana number" - see the IBM NetBIOS spec for details.
// Basically, this describes a single, unique network route which
// uses NetBIOS.
//
// Using the above example, Entry #0 has a lana number of 0 and WILL
// be returned during enumeration. Entry #1 has a lana number of 1
// and WILL NOT be returned.
//

struct REG_LANA_ENTRY
{
    BYTE Exported;
    BYTE LanaNumber;
};

class CLanaEntry
{
public:
    PCWSTR pszBindPath;
    REG_LANA_ENTRY RegLanaEntry;
};


class CLanaMap : public vector<CLanaEntry>
{
public:

    CLanaMap()
    {
        ZeroMemory (this, sizeof (*this));
        m_RegistryLanaMap.SetGranularity (256);
    }

    ~CLanaMap()
    {
        MemFree ((VOID*)m_pszBindPathsBuffer);
    };

    VOID
    Clear()
    {
        clear();
    }

    UINT
    CountEntries() const
    {
        return size();
    }

    VOID
    Dump (
        CWideString* pstr) const;

    HRESULT
    HrReserveRoomForEntries (
        IN UINT cEntries);

    HRESULT
    HrAppendEntry (
        IN CLanaEntry* pEntry);

    BYTE
    GetExportValue (
        IN const CComponentList& Components,
        IN PCWSTR pszBindPath);

    HRESULT
    HrSetLanaNumber (
        IN BYTE OldLanaNumber,
        IN BYTE NewLanaNumber);

    HRESULT
    HrCreateRegistryMap();

    VOID
    GetLanaEntry (
        IN const CComponentList& Components,
        IN CLanaEntry* pEntry);

    HRESULT
    HrLoadLanaMap();

    BYTE
    GetMaxLana();

    HRESULT
    HrWriteLanaConfiguration (
        IN const CComponentList& Components);

private:
    PCWSTR m_pszBindPathsBuffer;
    BYTE m_LanasInUse[MAX_LANA + 1];
    CDynamicBuffer m_RegistryLanaMap;

    HRESULT
    HrWriteLanaMapConfig();
};

HRESULT
HrUpdateLanaConfig (
    IN const CComponentList& Components,
    IN PCWSTR pszBindPaths,
    IN UINT cPaths);

VOID
GetFirstComponentFromBindPath (
    IN PCWSTR pszBindPath,
    OUT PCWSTR* ppszComponentStart,
    OUT DWORD* pcchComponent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\lockdown.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       L O C K D O W N . C P P
//
//  Contents:   Routines to get and set components that are in a lockdown
//              state.  A component goes into lockdown when it requires a
//              reboot on removal.  When a component is locked down, it
//              cannot be installed until after the next reboot.
//
//  Notes:      Because a component comes out of lockdown after a reboot,
//              a natural choice for implementation is to use a volatile
//              registry key to keep track of the state.  Each component
//              that is locked down is represented by a volatile registry
//              key the name of which is the same as the INF ID of the
//              component.  These keys exist under
//              SYSTEM\CurrentControlSet\Control\Network\Lockdown.
//
//  Author:     shaunco   24 May 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "diagctx.h"
#include "lockdown.h"
#include "ncreg.h"

#define REGSTR_KEY_LOCKDOWN \
    L"SYSTEM\\CurrentControlSet\\Control\\Network\\Lockdown"


//+---------------------------------------------------------------------------
//
//  Function:   EnumLockedDownComponents
//
//  Purpose:    Enumerate the currently locked down components via a
//              caller-supplied callback.
//
//  Arguments:
//      pfnCallback [in] pointer to callback function
//      OPTIONAL    [in] optional caller-supplied data to pass back
//
//  Returns:    nothing
//
//  Author:     shaunco   24 May 1999
//
VOID
EnumLockedDownComponents (
    IN PFN_ELDC_CALLBACK pfnCallback,
    IN PVOID pvCallerData OPTIONAL)
{
    HRESULT hr;
    HKEY hkey;

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_KEY_LOCKDOWN,
            KEY_READ,
            &hkey);

    if (S_OK == hr)
    {
        WCHAR szInfId [_MAX_PATH];
        FILETIME ft;
        DWORD dwSize;
        DWORD dwRegIndex;

        for (dwRegIndex = 0, dwSize = celems(szInfId);
             S_OK == HrRegEnumKeyEx(hkey, dwRegIndex, szInfId,
                        &dwSize, NULL, NULL, &ft);
             dwRegIndex++, dwSize = celems(szInfId))
        {
            pfnCallback (szInfId, pvCallerData);
        }

        RegCloseKey (hkey);;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetOrSetComponentLockDown
//
//  Purpose:    Gets or sets the state of whether a component is locked down.
//
//  Arguments:
//      fSet     [in] TRUE to set into the lockdown state, FALSE to get.
//      pszInfId [in] the INF ID of the component in question.
//
//  Returns:    TRUE if non-zero fSet and component is locked down.
//              FALSE otherwise.
//
//  Author:     shaunco   24 May 1999
//
BOOL
FGetOrSetComponentLockDown (
    IN BOOL fSet,
    IN PCWSTR pszInfId)
{
    Assert (pszInfId);

    HRESULT hr;
    HKEY hkey;
    BOOL fRet;
    WCHAR szKey [_MAX_PATH];

    fRet = FALSE;
    hkey = NULL;

    wcscpy (szKey, REGSTR_KEY_LOCKDOWN);
    wcscat (szKey, L"\\");
    wcscat (szKey, pszInfId);

    if (fSet)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "      %S is being locked "
            "down to prevent re-install until the next reboot\n",
            pszInfId);

        hr = HrRegCreateKeyEx (
                HKEY_LOCAL_MACHINE,
                szKey,
                REG_OPTION_VOLATILE,
                KEY_WRITE,
                NULL,
                &hkey,
                NULL);
    }
    else
    {
        hr = HrRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                szKey,
                KEY_READ,
                &hkey);

        if (S_OK == hr)
        {
            fRet = TRUE;
        }
    }

    RegSafeCloseKey (hkey);

    return fRet;
}

BOOL
FIsComponentLockedDown (
    IN PCWSTR pszInfId)
{
    return FGetOrSetComponentLockDown (FALSE, pszInfId);
}


struct LOCKDOWN_DEPENDENCY_ENTRY
{
    PCWSTR          pszInfId;
    const PCWSTR*   ppszDependentInfIds;
};

extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_FPNW[];
extern const WCHAR c_szInfId_MS_NWClient[];
extern const WCHAR c_szInfId_MS_NwSapAgent[];

static const PCWSTR c_apszNwlnkIpxDependentInfIds [] =
{
    c_szInfId_MS_FPNW,
    c_szInfId_MS_NWClient,
    c_szInfId_MS_NwSapAgent,
    NULL,
};

static const LOCKDOWN_DEPENDENCY_ENTRY c_LockdownDependencyMap [] =
{
    { c_szInfId_MS_NWIPX, c_apszNwlnkIpxDependentInfIds },
    { NULL, NULL }
};

VOID
LockdownComponentUntilNextReboot (
    IN PCWSTR pszInfId)
{
    (VOID) FGetOrSetComponentLockDown (TRUE, pszInfId);

    // Lock down dependents of the component as well.
    //
    const LOCKDOWN_DEPENDENCY_ENTRY* pEntry;
    UINT ipsz;

    // Search for the matching entry in c_LockdownDependencyMap.
    //
    for (pEntry = c_LockdownDependencyMap;
         pEntry->pszInfId;
         pEntry++)
    {
        if (0 != _wcsicmp (pEntry->pszInfId, pszInfId))
        {
            continue;
        }

        // Found a matching entry.  Now lock down all of its
        // dependent INF ids.  The array of const PCWSTR pointers is
        // terminated with a NULL pointer.
        //
        Assert (pEntry->ppszDependentInfIds);

        for (ipsz = 0;
             pEntry->ppszDependentInfIds [ipsz];
             ipsz++)
        {
            (VOID) FGetOrSetComponentLockDown (
                    TRUE, pEntry->ppszDependentInfIds [ipsz]);
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\lanamap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       L A N A M A P . C P P
//
//  Contents:   NetBios Lana map routines.
//
//  Notes:
//
//  Author:     billbe   17 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "lanamap.h"
#include "nceh.h"
#include "ncerror.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netsetup.h"
#include "persist.h"

const WCHAR c_szRegKeyNetBiosLinkage[] =
        L"System\\CurrentControlSet\\Services\\NetBios\\Linkage";

const WCHAR c_szRegKeyNetBiosParameters[] =
        L"System\\CurrentControlSet\\Services\\NetBIOS\\Parameters";

const WCHAR c_szRegValueLanaMap[] = L"LanaMap";
const WCHAR c_szRegValueMaxLana[] = L"MaxLana";

#if DBG
    VOID DbgVerifyBindPathString (PCWSTR pszBindPath);
#else
    VOID DbgVerifyBindPathString (PCWSTR /*pszBindPath*/) {}
#endif


typedef vector<const GUID*> VECTOR_OF_GUIDS;

struct LANA_BIND_PATH
{
    VECTOR_OF_GUIDS GuidsOfComponentsOnPath;
    BYTE LanaNumber;
};

VOID
GetFirstComponentFromBindPath (
    IN PCWSTR pszBindPath,
    OUT PCWSTR* ppszComponentStart,
    OUT DWORD* pcchComponent)
{
    PCWSTR pszComponentEnd;
    PCWSTR pszComponentStart;

    Assert (pszBindPath);
    Assert (ppszComponentStart);
    Assert (pcchComponent);

    *pcchComponent = 0;

    // The Bind path is of the form \Device\<component>_<component>_<etc.>
    //
    pszComponentEnd = wcschr (pszBindPath, L'_');
    if (!pszComponentEnd)
    {
        // There is no underscore so set the end pointer
        // to the end of the string.
        pszComponentEnd = pszBindPath + wcslen (pszBindPath);
    }

    for (pszComponentStart = pszComponentEnd;
            pszComponentStart != pszBindPath; pszComponentStart--)
    {
        // Backup from the end until we get to the slash.
        // If we don't find a slash, the loop will stop when
        // we hit the beginning.
        //
        if (L'\\' == *pszComponentStart)
        {
            // We hit the slash. The Component start is one character
            // past that.
            pszComponentStart++;
            break;
        }
    }

    *ppszComponentStart = pszComponentStart;
    *pcchComponent = pszComponentEnd - pszComponentStart;
}

VOID
CLanaMap::Dump (
    OUT CWideString* pstr) const
{
    Assert (this);
    Assert (pstr);

    WCHAR pszBuf[1024];
    pstr->erase();

    const CLanaEntry* pEntry;

    for (pEntry = begin(); pEntry != end(); pEntry++)
    {
        swprintf (pszBuf, L"Lana: %3d  Export: %d Path: %s\n",
                pEntry->RegLanaEntry.LanaNumber,
                pEntry->RegLanaEntry.Exported, pEntry->pszBindPath);

        pstr->append (pszBuf);
    }
}

HRESULT
CLanaMap::HrLoadLanaMap()
{
    HRESULT hr;
    HKEY hkey;

    // The lana map is stored in Netbios's linkage key.
    //
    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyNetBiosLinkage,
            KEY_READ, &hkey);

    if (S_OK == hr)
    {
        REG_LANA_ENTRY* pRegEntries;
        DWORD cbLanaEntries;

        // Read in the lana map binary blob.
        hr = HrRegQueryBinaryWithAlloc (hkey, c_szRegValueLanaMap,
                (BYTE**)&pRegEntries, &cbLanaEntries);

        if (S_OK == hr)
        {
            DWORD cEntries = cbLanaEntries / sizeof (REG_LANA_ENTRY);

            PWSTR pmszBindPaths;

            // Grab the bind paths for NetBios so we can match them
            // up with the lana map.
            hr = HrRegQueryMultiSzWithAlloc (hkey, L"Bind", &pmszBindPaths);

            if (S_OK == hr)
            {
                PCWSTR pszScan;
                DWORD cPaths;
                for (pszScan = pmszBindPaths, cPaths = 0;
                        *pszScan;
                            pszScan += wcslen(pszScan) + 1)
                {
                    ++cPaths;
                }

                m_pszBindPathsBuffer = pmszBindPaths;

                hr = HrReserveRoomForEntries (cPaths);

                if (S_OK == hr)
                {
                    DWORD dw = 0;
                    CLanaEntry Entry;

                    for (pszScan = pmszBindPaths;
                            *pszScan;
                                pszScan += wcslen(pszScan) + 1)
                    {
                        Entry.pszBindPath = pszScan;

                        if (dw < cEntries)
                        {
                            Entry.RegLanaEntry.LanaNumber =
                                    pRegEntries[dw].LanaNumber;
                            Entry.RegLanaEntry.Exported =
                                    pRegEntries[dw].Exported;
                        }
                        else
                        {
                            // We have more bind paths but no more
                            // lana map entries to correlate.
                            // Now we assign available lanas.
                            //
                            BYTE* location = find (m_LanasInUse,
                                    m_LanasInUse + MAX_LANA, 0);
                            if (location != m_LanasInUse + MAX_LANA)
                            {
                                Entry.RegLanaEntry.LanaNumber =
                                        location - m_LanasInUse;
                                Entry.RegLanaEntry.Exported = 1;
                            }
                        }

                        // Mark this Lana as taken.
                        m_LanasInUse[Entry.RegLanaEntry.LanaNumber] = 1;

                        hr = HrAppendEntry (&Entry);

                        if (S_OK != hr)
                        {
                            break;
                        }

                        dw++;
                    }
                }

            }
            MemFree (pRegEntries);
        }

        // If lana map or bind is not there, it is okay since we will be
        // recreating the info.
        //
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey (hkey);
    }
    else
    {
        // If the linkage has not been created yet, it is okay since it will
        // be creating after the lanamap is written out.  This occurs when
        // NetBios is first installed.
        //
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrLoadLanaMap");
    return hr;
}

#if DBG
VOID
DbgVerifyBindPathString (
    PCWSTR pszBindPath)
{
    const WCHAR c_szDevice[] = L"\\Device\\";
    Assert (pszBindPath);
    Assert (0 == _wcsnicmp (pszBindPath, c_szDevice, celems(c_szDevice)-1));
}
#endif // DBG


BOOL
FBindPathContainsMultipleInterface (
    IN const CComponentList& Components,
    IN PCWSTR pszBindPath)
{
    BOOL fContainsMultipleInterface = FALSE;
    PCWSTR pszLastDevice = wcsrchr (pszBindPath, L'{');

    if (pszLastDevice)
    {
        GUID Guid;
        if (S_OK == IIDFromString ((PWSTR)pszLastDevice, &Guid))
        {
            // If this is a multiple interface, it will not exist
            // as a component.
            //
            CComponent* pComponent;

            pComponent = Components.
                    PFindComponentByInstanceGuid (&Guid);

            if (!pComponent)
            {
                // This means the path contains a multiple interface.
                fContainsMultipleInterface = TRUE;
            }
        }
    }
    return fContainsMultipleInterface;
}

HRESULT
CLanaMap::HrAppendEntry (
    IN CLanaEntry* pEntry)
{
    HRESULT hr;

    Assert (pEntry);
    Assert (pEntry->pszBindPath && *(pEntry->pszBindPath));

    DbgVerifyBindPathString (pEntry->pszBindPath);

    NC_TRY
    {
        push_back (*pEntry);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        // Update out lanas in use map.
        m_LanasInUse[pEntry->RegLanaEntry.LanaNumber] = 1;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrAppendLanaEntry");
    return hr;
}

HRESULT
CLanaMap::HrCreateRegistryMap()
{
    HRESULT hr;

    CLanaEntry* pEntry;

    if (m_RegistryLanaMap.CountOfBytesUsed())
    {
        m_RegistryLanaMap.Clear();
    }

    hr = m_RegistryLanaMap.HrReserveBytes (
            CountEntries() * sizeof (REG_LANA_ENTRY));

    if (S_OK == hr)
    {
        for (pEntry = begin(); pEntry != end(); pEntry++)
        {
            hr = m_RegistryLanaMap.HrCopyBytes ((BYTE*)&pEntry->RegLanaEntry,
                    sizeof (REG_LANA_ENTRY));
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaEntry::HrCreateRegistryMap");
    return hr;
}

HRESULT
CLanaMap::HrReserveRoomForEntries (
    IN UINT cEntries)
{
    HRESULT hr;

    NC_TRY
    {
        reserve (cEntries);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrReserveRoomForEntries");
    return hr;
}

BYTE
CLanaMap::GetExportValue (
    IN const CComponentList& Components,
    IN PCWSTR pszBindPath)
{
    const WCHAR c_szNdisWanNbfIn[] = L"NdisWanNbfIn{";

    BYTE Exported = 1;
    PCWSTR pszLastDevice;

    Assert (pszBindPath && *pszBindPath);

    // Get the last "device" on the bind path.
    // If it matches NbfIn, we don't export.
    //

    pszLastDevice = wcsrchr (pszBindPath, L'_');
    if (!pszLastDevice)
    {
        pszLastDevice = wcsrchr (pszBindPath, L'\\');
        if (!pszLastDevice)
        {
            pszLastDevice = pszBindPath;
        }
    }

    if (pszLastDevice != pszBindPath)
    {
        pszLastDevice++;
    }

    if (0 == _wcsnicmp (pszLastDevice, c_szNdisWanNbfIn,
            wcslen (c_szNdisWanNbfIn)))
    {
        Exported = 0;
    }

    // If we haven't turned off export, check to see if this bind path
    // contains a multiple interface.
    //
    if (0 != Exported && FBindPathContainsMultipleInterface (Components,
            pszBindPath))
    {
        Exported = 0;
    }

    return Exported;
}

VOID
CLanaMap::GetLanaEntry (
    IN const CComponentList& Components,
    IN CLanaEntry* pEntry)
{
    CLanaEntry* pCurrentEntry;
    BOOL fFound = FALSE;

    Assert (pEntry->pszBindPath);

    // Check the map for the entry
    //
    for (pCurrentEntry = begin(); pCurrentEntry != end(); pCurrentEntry++)
    {
        if (0 == _wcsicmp (pEntry->pszBindPath, pCurrentEntry->pszBindPath))
        {
            // Found the entry, set the lana number and figure out
            // if this entry should be exported.
            //
            pEntry->RegLanaEntry.Exported =
                    GetExportValue (Components, pEntry->pszBindPath);
            pEntry->RegLanaEntry.LanaNumber =
                    pCurrentEntry->RegLanaEntry.LanaNumber;
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        // no match, get next available lana number
        BYTE* location = find (m_LanasInUse, m_LanasInUse + MAX_LANA, 0);
        if (location != m_LanasInUse + MAX_LANA)
        {
            pEntry->RegLanaEntry.Exported =
                    GetExportValue (Components, pEntry->pszBindPath);
            pEntry->RegLanaEntry.LanaNumber = location - m_LanasInUse;
            m_LanasInUse[location - m_LanasInUse] = 1;
        }
        else
        {
            // They tell me this is impossible.
            AssertSz (FALSE, "No more available Lanas.");
            pEntry->RegLanaEntry.Exported = 0;
            pEntry->RegLanaEntry.LanaNumber = MAX_LANA + 1;
        }
    }
}

HRESULT
CLanaMap::HrWriteLanaMapConfig()
{
    HKEY hkeyLinkage;
    HRESULT hr;

    hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyNetBiosLinkage,
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyLinkage, NULL);

    if (S_OK == hr)
    {
        const BYTE* pbBuffer;
        DWORD cbBuffer = m_RegistryLanaMap.CountOfBytesUsed();

        if (cbBuffer > 0)
        {
            pbBuffer = m_RegistryLanaMap.PbBuffer();
        }
        else
        {
            pbBuffer = NULL;
        }

        hr = HrRegSetBinary (hkeyLinkage, c_szRegValueLanaMap,
                pbBuffer, cbBuffer);
        RegCloseKey (hkeyLinkage);
    }

    if (S_OK == hr)
    {
        HKEY hkeyParams;
        hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE,
                c_szRegKeyNetBiosParameters, REG_OPTION_NON_VOLATILE,
                KEY_WRITE, NULL, &hkeyParams, NULL);

        if (S_OK == hr)
        {
            hr = HrRegSetDword (hkeyParams, c_szRegValueMaxLana,
                    GetMaxLana());

            RegCloseKey (hkeyParams);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrWriteLanaMapConfig");
    return hr;
}

HRESULT
HrGetNetBiosProviderName (
    IN CComponent* pComponent,
    OUT PWSTR pszName)
{
    HRESULT hr;

    Assert (pComponent);
    Assert (pszName);

    // The netbios provider name for a component is stored in its
    // <service>\Parameters key.
    //
    HKEY hkeyService;
    hr = pComponent->HrOpenServiceKey (KEY_READ, &hkeyService);

    if (S_OK == hr)
    {
        HKEY hkeyParams;
        hr = HrRegOpenKeyEx (hkeyService, L"Parameters", KEY_READ,
                &hkeyParams);

        if (S_OK == hr)
        {
            DWORD cbBuffer = _MAX_PATH;
            hr = HrRegQuerySzBuffer (hkeyParams, L"NbProvider", pszName,
                    &cbBuffer);

            RegCloseKey (hkeyParams);
        }
        RegCloseKey (hkeyService);
    }

    TraceHr (ttidError, FAL, hr,
             HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
             "HrGetNetBiosProviderName");
    return hr;
}

HRESULT
CLanaMap::HrSetLanaNumber (
    IN BYTE OldLanaNumber,
    IN BYTE NewLanaNumber)
{
    HRESULT hr = S_OK;
    if (0 == m_LanasInUse[NewLanaNumber])
    {
        CLanaEntry* pEntry;

        for (pEntry = begin(); pEntry != end(); pEntry++)
        {
            if (OldLanaNumber == pEntry->RegLanaEntry.LanaNumber)
            {
                // free up the lana number this entry had.
                m_LanasInUse[pEntry->RegLanaEntry.LanaNumber] = 0;

                // Give the entry the new lana number.
                pEntry->RegLanaEntry.LanaNumber = NewLanaNumber;

                m_LanasInUse[NewLanaNumber] = 1;
                break;
            }
        }

        if (pEntry == end())
        {
            hr = HRESULT_FROM_WIN32 (ERROR_OBJECT_NOT_FOUND);
        }
    }
    else
    {
        // The lana is not free.  We will swap the lanas used by the
        // two paths.
        //

        CLanaEntry* pEntry;
        CLanaEntry* pEntryToSet = NULL;
        CLanaEntry* pEntryUsingLana = NULL;

        for (pEntry = begin(); pEntry != end(); pEntry++)
        {
            if (!pEntryToSet &&
                    (OldLanaNumber == pEntry->RegLanaEntry.LanaNumber))
            {
                pEntryToSet = pEntry;
            }
            else if (!pEntryUsingLana &&
                     (NewLanaNumber == pEntry->RegLanaEntry.LanaNumber))
            {
                pEntryUsingLana = pEntry;
            }

            if (pEntryToSet && pEntryUsingLana)
            {
                // Give the entry the new lana number.
                pEntryToSet->RegLanaEntry.LanaNumber = NewLanaNumber;

                // Give the old lana number to the entry that was using the
                // new lana number.
                pEntryUsingLana->RegLanaEntry.LanaNumber = OldLanaNumber;
                break;
            }
        }

        if (!pEntryToSet || !pEntryUsingLana)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_OBJECT_NOT_FOUND);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrSetLanaNumber");

    return hr;
}

BYTE
CLanaMap::GetMaxLana()
{
   for (BYTE b = MAX_LANA; b; b--)
   {
       if (m_LanasInUse[b]) return b;
   }

   return 0;
}


HRESULT
CLanaMap::HrWriteLanaConfiguration (
    IN const CComponentList& Components)
{
    HRESULT hr;

    // Create the registry map that will be stored.
    hr = HrCreateRegistryMap();
    if (S_OK == hr)
    {
        // Write out the map and other lana info.
        hr = HrWriteLanaMapConfig();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrWriteLanaConfiguration");
    return hr;
}

VOID
DumpLanaBindPaths (
    IN LANA_BIND_PATH* pBindSet,
    IN DWORD cPaths)
{
    LANA_BIND_PATH* pPath = pBindSet;
    DWORD dw = 0;
    VECTOR_OF_GUIDS::iterator iter;

    for (dw = 0; dw < cPaths; dw++)
    {
        TraceTag (ttidNetcfgBase, "Path %d", dw);
        for (iter = pPath->GuidsOfComponentsOnPath.begin();
                iter != pPath->GuidsOfComponentsOnPath.end();
                iter++)
        {
            const GUID* guid = *iter;
            TraceTag (ttidNetcfgBase, "    %lX", guid->Data1);
        }
        pPath++;
    }
}


VOID
UpdateLanaConfigWithAnswerFileInfo (
    IN CLanaMap* pLanaMap,
    IN DWORD cAfPaths,
    IN LANA_BIND_PATH* pOriginalBindSet,
    IN LANA_BIND_PATH* pAnswerFileBindSet)
{
    DWORD dwAnswerFile;
    DWORD dwPaths;
    DWORD dwComponents;
    DWORD dwNumberOfComponents;
    BOOL fEqual;
    LANA_BIND_PATH* pAfEntry;
    LANA_BIND_PATH* pOEntry;

    Assert (pLanaMap);
    Assert (pOriginalBindSet);
    Assert (pAnswerFileBindSet);

    TraceTag (ttidNetcfgBase, "Dumping original bind set");
    DumpLanaBindPaths (pOriginalBindSet, pLanaMap->CountEntries());
    TraceTag (ttidNetcfgBase, "Dumping af bind set");
    DumpLanaBindPaths (pAnswerFileBindSet, cAfPaths);

    pAfEntry = pAnswerFileBindSet;
    for (dwAnswerFile = 0; dwAnswerFile < cAfPaths; dwAnswerFile++)
    {
        // Do we have a valid path?
        if (!pAfEntry->GuidsOfComponentsOnPath.empty())
        {
            pOEntry = pOriginalBindSet;
            for (dwPaths = 0; dwPaths < pLanaMap->CountEntries(); dwPaths++)
            {
                if (pAfEntry->GuidsOfComponentsOnPath.size() ==
                        pOEntry->GuidsOfComponentsOnPath.size())
                {
                    dwNumberOfComponents =
                            pAfEntry->GuidsOfComponentsOnPath.size();

                    fEqual = TRUE;
                    for (dwComponents = 0;
                            dwComponents < dwNumberOfComponents;
                            dwComponents++)
                    {
                        if (pAfEntry->GuidsOfComponentsOnPath[dwComponents] !=
                                pOEntry->GuidsOfComponentsOnPath[dwComponents])
                        {
                            fEqual = FALSE;
                        }
                    }

                    if (fEqual)
                    {
                        HRESULT hr;
                        hr = pLanaMap->HrSetLanaNumber (
                                pOEntry->LanaNumber,
                                pAfEntry->LanaNumber);


                        TraceTag (ttidNetcfgBase, "af path %d matches %d",
                                dwAnswerFile, dwPaths);
                        TraceTag (ttidNetcfgBase, "Changing lana number "
                                  "from %X to %X", pOEntry->LanaNumber,
                                  pAfEntry->LanaNumber);

                        TraceHr (ttidError, FAL, hr, FALSE, "Setting lana");
                    }
                }
                pOEntry++;
            }
        }
        pAfEntry++;
    }
}

VOID
ConvertAnswerFileComponentsToGuids (
    IN const CComponentList& Components,
    IN PCWSTR mszComponents,
    OUT VECTOR_OF_GUIDS* pvector)
{
    CComponent* pComponent;
    PCWSTR pszScan;
    const GUID* pguid;
    GUID guidTemp;

    Assert (mszComponents);
    Assert (pvector);

    for (pszScan = mszComponents; *pszScan; pszScan += wcslen (pszScan) + 1)
    {

        TraceTag (ttidNetcfgBase, "  Looking for af component %S", pszScan);

        // Look for the component in our installed components list.
        //
        pComponent = Components.PFindComponentByInfId (pszScan, NULL);

        if (pComponent)
        {
            pguid = &pComponent->m_InstanceGuid;
        }
        else
        {
            TraceTag (ttidNetcfgBase, "    Id did not match installed ids. "
                    "Checking af map");

            // The component wasn't listed in our installed list.  The inf
            // id might be something that the answerfile processor has mapped
            // to the component's instance guid.  This happens for adapters.
            // e.g. Id is listed as Adapter01 so netsetup uses an alogrithm
            // to determine which adapter it is and then save off its
            // instance guid in a map.
            //
            if (FGetInstanceGuidOfComponentFromAnswerFileMap (
                    pszScan, &guidTemp))
            {
                pComponent = Components.PFindComponentByInstanceGuid (
                    &guidTemp);
            }
            else
            {
                TraceTag (ttidError, "    Component %S not found in answerfile "
                          "map", pszScan);
            }

            // If we found the component, store a reference to its
            // instance guid
            //
            if (pComponent)
            {
                TraceTag (ttidNetcfgBase, "    Found component");
                pguid = &pComponent->m_InstanceGuid;
            }
            else
            {
                // We didn't find the component. Store GUID_NULL.
                pguid = &GUID_NULL;
            }
        }
        TraceTag (ttidNetcfgBase, "    Using GUID %lX", pguid->Data1);

        pvector->push_back (pguid);
    }
}

HRESULT
HrConvertAnswerFileParamsToLanaBindSet (
    IN INFCONTEXT& ctxLana,
    IN const CComponentList& Components,
    IN DWORD cPaths,
    OUT LANA_BIND_PATH* pBindSet)
{
    DWORD cchField = _MAX_PATH;
    DWORD cchRequired;
    INT LanaCode;
    PWSTR mszComponents;
    HRESULT hr;
    DWORD dw;
    INFCONTEXT ctx = ctxLana;
    LANA_BIND_PATH* pPath;

    hr = S_OK;
    mszComponents = (PWSTR)MemAlloc (cchField * sizeof (WCHAR));

    pPath = pBindSet;
    for (dw = 0; dw < cPaths; dw++)
    {
        if (mszComponents && (S_OK == hr))
        {
            hr = HrSetupGetMultiSzField (ctx, 1, mszComponents, cchField,
                    &cchRequired);

            if (S_OK == hr)
            {
                TraceTag (ttidNetcfgBase, "Path %ld", dw);
                ConvertAnswerFileComponentsToGuids (Components,
                        mszComponents,
                        &(pPath->GuidsOfComponentsOnPath));

                hr = HrSetupFindNextLine (ctx, &ctx);

                if (S_OK == hr)
                {
                    hr = HrSetupGetIntField (ctx, 1, &LanaCode);

                    if (S_OK == hr)
                    {
                        pPath->LanaNumber = LanaCode & 0xff;

                        TraceTag (ttidNetcfgBase, "  Using LanaNumber %X for "
                            "path", pPath->LanaNumber);
                    }
                    else
                    {
                        TraceTag (ttidNetcfgBase, "  Bad lana code");
                        // Bad lana number, clear the guids so we won't match
                        // this path and use this info.
                        //
                        pPath->GuidsOfComponentsOnPath.erase(
                            pPath->GuidsOfComponentsOnPath.begin(),
                            pPath->GuidsOfComponentsOnPath.end());
                    }
                }

                hr = HrSetupFindNextMatchLine (ctx, L"LanaPath", &ctx);

                if (S_FALSE == hr)
                {
                    break;
                }

                pPath++;
            }
            else if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
            {
                // Reallocate the buffer.
                //
                hr = S_OK;
                MemFree (mszComponents);
                mszComponents = (PWSTR)MemAlloc (cchRequired * sizeof(WCHAR));
                cchField = cchRequired;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }

    if (S_FALSE == hr)
    {
        // Check to see if we were really finished.
        if ((dw + 1) < cPaths)
        {
            TraceTag (ttidError, "Answerfile specified %d lana paths "
                    "but only %d were found", cPaths, (dw + 1));
        }

        // This fcn only returns S_OK on success.
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrConvertAnswerFileParamsToLanaBindSet");
    return hr;
}

HRESULT
HrProcessAnswerFile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszSection,
    IN const CComponentList& Components,
    OUT LANA_BIND_PATH** ppBindSet,
    OUT DWORD* pcPaths)
{
    HINF hinf;
    PCWSTR pszBindPath;
    WCHAR szBindName[_MAX_PATH];
    HRESULT hr;

    Assert (pszAnswerFile);
    Assert (pszSection);
    Assert (ppBindSet);
    Assert (pcPaths);

    *pcPaths = 0;
    *ppBindSet = NULL;

    hr = HrSetupOpenInfFile (pszAnswerFile, NULL,
            INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL, &hinf);

    if (S_OK == hr)
    {
        hr = HrSetupGetFirstDword (hinf, pszSection,
                L"NumberOfPaths", pcPaths);

        if (S_OK == hr)
        {
            TraceTag (ttidNetcfgBase, "\n\n");
            TraceTag (ttidNetcfgBase, "%d paths found in answerfile",
                    *pcPaths);

            hr = E_OUTOFMEMORY;
            *ppBindSet = new LANA_BIND_PATH[*pcPaths];
            if (*ppBindSet)
            {
                hr = S_OK;
            }
        }

        if (S_OK == hr)
        {
            INFCONTEXT ctx;
            hr = HrSetupFindFirstLine (hinf, pszSection, L"LanaPath", &ctx);

            if (S_OK == hr)
            {
                hr = HrConvertAnswerFileParamsToLanaBindSet (ctx, Components,
                        *pcPaths, *ppBindSet);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrProcessAnswerFile");
    return hr;
}


HRESULT
HrConvertBindingsToLanaBindSet (
    IN const CComponentList& Components,
    IN const CLanaMap& LanaMap,
    OUT LANA_BIND_PATH** ppBindSet)
{

    PCWSTR pszBindPath;
    WCHAR szBindName[_MAX_PATH];
    HRESULT hr;
    DWORD cPaths;

    Assert (ppBindSet);

    cPaths = LanaMap.CountEntries();

    TraceTag (ttidNetcfgBase, "%d paths in system", cPaths);

    hr = E_OUTOFMEMORY;
    *ppBindSet = new LANA_BIND_PATH[cPaths];

    if (*ppBindSet)
    {
        LANA_BIND_PATH* pBindPath = *ppBindSet;
        CComponent* pComponent;
        PCWSTR pszCompStart;
        PCWSTR pszCompEnd;
        DWORD cchComp;

        hr = S_OK;

        const CLanaEntry* pEntry;
        for (pEntry = LanaMap.begin(); pEntry != LanaMap.end(); pEntry++)
        {
            pszBindPath = pEntry->pszBindPath;

            TraceTag (ttidNetcfgBase, "BindPath %S", pszBindPath);

            pBindPath->LanaNumber = pEntry->RegLanaEntry.LanaNumber;
            TraceTag (ttidNetcfgBase, "Lana %X", pBindPath->LanaNumber);

            GetFirstComponentFromBindPath (pszBindPath, &pszCompStart,
                    &cchComp);

            while (*pszCompStart)
            {
                wcsncpy (szBindName, pszCompStart, cchComp);
                szBindName[cchComp] = L'\0';

                TraceTag (ttidNetcfgBase, "  Searching for component with bind name %S",
                        szBindName);

                pComponent = Components.PFindComponentByBindName (NC_INVALID,
                        szBindName);

                if (pComponent)
                {
                    TraceTag (ttidNetcfgBase, "  Found component. Guid = %lX",
                            pComponent->m_InstanceGuid.Data1);
                    pBindPath->GuidsOfComponentsOnPath.push_back (&pComponent->m_InstanceGuid);
                }
                else
                {
                    if (*pszCompEnd)
                    {
                        AssertSz (FALSE, "  Bind Name not found in component list");
                        pBindPath->GuidsOfComponentsOnPath.push_back (&GUID_NULL);
                    }
                }

                pszCompStart = pszCompStart + cchComp;

                if (*pszCompStart)
                {
                    pszCompStart++;

                    pszCompEnd = wcschr (pszCompStart, L'_');
                    if (!pszCompEnd)
                    {
                        // There is no underscore so set the end pointer
                        // to the end of the string.
                        pszCompEnd = pszBindPath + wcslen (pszBindPath);
                    }
                }

                cchComp = pszCompEnd - pszCompStart;
            }
            pBindPath++;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrConvertBindingsToLanaBindSet");
    return hr;
}

HRESULT
HrUpdateLanaConfig (
    IN const CComponentList& Components,
    IN PCWSTR pszBindPaths,
    IN UINT cPaths)
{
    CLanaMap CurrentLanaMap;
    CLanaMap NewLanaMap;
    HRESULT hr;

    hr = CurrentLanaMap.HrLoadLanaMap();

    if (S_OK == hr)
    {
        hr = NewLanaMap.HrReserveRoomForEntries (cPaths);

        if (S_OK == hr)
        {
            PCWSTR pszScan;
            CLanaEntry LanaEntry;

            for (pszScan = pszBindPaths;
                 *pszScan;
                 pszScan += wcslen (pszScan) + 1)
            {
                LanaEntry.pszBindPath = pszScan;
                CurrentLanaMap.GetLanaEntry (Components, &LanaEntry);

                hr = NewLanaMap.HrAppendEntry (&LanaEntry);

                if (S_OK != hr)
                {
                    break;
                }
            }

            if (S_OK == hr)
            {
                hr = NewLanaMap.HrWriteLanaConfiguration (Components);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrUpdateLanaConfig");
    return hr;

}

EXTERN_C
VOID
WINAPI
UpdateLanaConfigUsingAnswerfile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszSection)
{
    HRESULT hr;
    CLanaMap LanaMap;

    // Load the current lanamap information.
    hr = LanaMap.HrLoadLanaMap();

    if (S_OK == hr)
    {
        TraceTag (ttidNetcfgBase, "Answerfile params %S:%S",
                pszAnswerFile, pszSection);

        // Load up the current network configuration.
        //

        CNetConfig NetConfig;
        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);

        if (S_OK == hr)
        {
            hr = NetConfig.HrEnsureExternalDataLoadedForAllComponents();

            if (S_OK == hr)
            {
                // Convert our current lana bind paths to a lana bind set.
                //
                LANA_BIND_PATH* pBindSet;
                hr = HrConvertBindingsToLanaBindSet (
                        NetConfig.Core.Components, LanaMap, &pBindSet);

                if (S_OK == hr)
                {
                    // Convert the answerfile lana bind paths
                    // to a lana bind set.
                    //
                    LANA_BIND_PATH* pAnswerFileBindSet;
                    DWORD cAnswerFilePaths;

                    hr = HrProcessAnswerFile (
                            pszAnswerFile, pszSection,
                            NetConfig.Core.Components, &pAnswerFileBindSet,
                            &cAnswerFilePaths);

                    if (S_OK == hr)
                    {
                        // Now update the config using the answerfile info.
                        //
                        UpdateLanaConfigWithAnswerFileInfo (
                                &LanaMap, cAnswerFilePaths,
                                pBindSet, pAnswerFileBindSet);

                        // Write out the information.
                        hr = LanaMap.HrWriteLanaConfiguration (
                                NetConfig.Core.Components);

                        delete [] pAnswerFileBindSet;
                    }
                    delete [] pBindSet;
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "UpdateLanaConfigUsingAnswerfile");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\lockdown.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       L O C K D O W N . H
//
//  Contents:   Routines to get and set components that are in a lockdown
//              state.  A component goes into lockdown when it requires a
//              reboot on removal.  When a component is locked down, it
//              cannot be installed until after the next reboot.
//
//  Notes:
//
//  Author:     shaunco   24 May 1999
//
//----------------------------------------------------------------------------

#pragma once

typedef VOID
(CALLBACK* PFN_ELDC_CALLBACK) (
    IN PCWSTR pszInfId,
    IN PVOID pvCallerData OPTIONAL);

VOID
EnumLockedDownComponents (
    IN PFN_ELDC_CALLBACK pfnCallback,
    IN PVOID pvCallerData OPTIONAL);

BOOL
FIsComponentLockedDown (
    IN PCWSTR pszInfId);

VOID
LockdownComponentUntilNextReboot (
    IN PCWSTR pszInfId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ncprsht.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P R S H T . C P P
//
//  Contents:   NetCfg custom PropertySheet
//
//  Notes:
//
//  Author:     billbe   8 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncprsht.h"
#include <prsht.h>
#include "nceh.h"

// Necessary evil globals
CAPAGES g_capPagesToAdd;  // Counted array of pages to add after Property
                          // Sheet is initialized
CAINCP  g_cai;  // Counted array of INetCfgProperty pointers
HRESULT g_hr; // Global error code
BOOL    g_fChanged; // Global flag representing whether a PSM_CHANGED
                    // message was sent by a page

DLGPROC lpfnOldWndProc; // Previous dialog procedure

// NetCfg Property Sheet dialog procedure
LONG FAR PASCAL NetCfgPsDlgProc(HWND hDlg, UINT msg, WPARAM wParam,
        LPARAM lParam);


//+---------------------------------------------------------------------------
//
//  Function:   SetLastHresult
//
//  Purpose:    This sets a global hresult variable.  The function
//              is analogous to SetLastError
//
//  Arguments:
//      HRESULT [in] Result to set
//
//  Returns:    nothing
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:
//
//
inline void
SetLastHresult(HRESULT hr)
{
    g_hr = hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetLastHresult
//
//  Purpose:    This returns the value of the global hresult variable.
//              The function is analogous to GetLastError
//
//  Arguments:
//      none
//
//  Returns:    HRESULT. Value of the global g_hr.
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:
//
//
inline HRESULT
HrGetLastHresult()
{
    return (g_hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ResetChanged
//
//  Purpose:    This resets the global changed flag. The reset state
//                  indicates that a PSM_VHANGED message was not sent
//
//  Arguments:
//      none
//
//  Returns:
//      (nothing)
//
//  Author:     billbe   3 May 1997
//
//  Notes:
//
//
inline void
ResetChanged()
{
    g_fChanged = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetChanged
//
//  Purpose:    This sets the global changed flag.  The set state indicates
//                  that a PSM_CHANGED message was sent
//
//  Arguments:
//      none
//
//  Returns:
//      (nothing)
//
//  Author:     billbe   3 May 1997
//
//  Notes:
//
//
inline void
SetChanged()
{
    g_fChanged = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetChanged
//
//  Purpose:    This returns the state of the global changed flag.  The set
//                  state indicates whether a PSM_CHANGED message was sent
//                  or not.
//
//  Arguments:
//      none
//
//  Returns:
//      BOOL. Value of the global g_fChanged flag.
//
//  Author:     billbe   3 May 1997
//
//  Notes:
//
//
inline BOOL
FGetChanged()
{
    return (g_fChanged);
}

//+---------------------------------------------------------------------------
//
//  Function:   NetCfgPropSheetCallback
//
//  Purpose:    This callback is called after the aheet dialog is
//              initialized. We subclass the dialog and add any OEM
//              pages here (if common pages exist).  See Win32 for
//              discussion of PropSheetProc
//
//  Arguments:
//      HWND [in] hwndDlg handle to the property sheet dialog box
//      UINT uMsg [in] message identifier
//      LPARAM lParam  [in] message parameter
//
//  Returns:    int, The function returns zero.
//
//  Author:     billbe   11 Nov 1996
//
//  Notes:
//
//
int
CALLBACK NetCfgPropSheetCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    // If the sheet has just been initialized
    if (uMsg == PSCB_INITIALIZED)
    {
        // Replace the original procedure with ours
        lpfnOldWndProc = (DLGPROC)SetWindowLongPtr(hwndDlg, DWLP_DLGPROC, (LONG_PTR) NetCfgPsDlgProc);
        Assert(lpfnOldWndProc);

        // Add the OEM pages that were scheduled for late add
        // This will cause them to be clipped if they are larger than
        // the common (default) pages.  Note that this is the desired
        // result.
        //
        for (int i = 0; i < g_capPagesToAdd.nCount; i++)
        {
            PropSheet_AddPage(hwndDlg, g_capPagesToAdd.ahpsp[i]);
        }

    }

    return (0);
}




//+---------------------------------------------------------------------------
//
//  Function:   HrCallValidateProperties
//
//  Purpose:    This function calls the notify objects'
//              INetCfgProperties::ValidateProperties method.
//
//  Arguments:
//      none
//
//  Returns:    HRESULT, S_OK if all of the INetCfgProperties return S_OK
//                       of the result of the first interface that does not
//                       return S_OK.
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:  If one of the interfaces returns something other than S_OK, the
//          others will not be called and the function will return the hresult
//          of that interface.
//
HRESULT
HrCallValidateProperties(HWND hwndSheet)
{
    HRESULT hr = S_OK;

    // enumerate through the counted array of interfaces
    // and call ValidateProperties
    //
    for (int i = 0; i < g_cai.nCount; i++)
    {
        // At the first sign of non-S_OK get out
        if (S_OK != (hr = g_cai.apncp[i]->ValidateProperties(hwndSheet)))
            break;
    }

    TraceError("HrCallValidateProperties", hr);
    return (hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   NetCfgPsDlgProc
//
//  Purpose:    This function is the dialog procedure for the property sheet
//              See Win32 documentation on DialogProc for more information
//
//  Arguments:
//      hwndDlg [in] handle to dialog box
//      uMsg    [in] message
//      wParam  [in] first message parameter
//      lParam  [in] second message parameter
//
//  Returns:    LONG, Except in response to the WM_INITDIALOG message, the
//              dialog box procedure should return nonzero if it processes
//              the message, and zero if it does not.
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:
//
LONG
FAR PASCAL NetCfgPsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_DESTROY:
        // restore the dialog procedure before we exit
        SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LONG_PTR) lpfnOldWndProc);
        break;
    case WM_SYSCOMMAND:
        // The user is closing through the system menu. This is like
        // canceling
        if (SC_CLOSE == wParam)
        {
            SetLastHresult(HRESULT_FROM_WIN32(ERROR_CANCELLED));
        }
        break;
    case PSM_CHANGED:
        SetChanged();
        break;
    case WM_COMMAND:
        // If the user pressed OK
        if ((IDOK == LOWORD(wParam)) && (BN_CLICKED == HIWORD(wParam)))
        {

            // Send a KillActive message to the currect page. This echoes
            // what the Win32 propertysheet would do.  This results in a
            // second KillActive message being sent to the active page
            // when the OK message is processed. It is necessary
            // to send it here because we need its result before we
            // call HrCallValidateProperties which is done before the OK
            // is processed.
            //

            NMHDR nmhdr;
            ZeroMemory(&nmhdr, sizeof(NMHDR));
            nmhdr.hwndFrom = hDlg;
            nmhdr.code = PSN_KILLACTIVE;

            if (SendMessage(PropSheet_GetCurrentPageHwnd(hDlg), WM_NOTIFY,
                    0, (LPARAM) &nmhdr))
            {
                // The page does not want the PropertySheet to go away so exit
                // without allowing the original procedure to get the message
                return (TRUE);
            }

            // The current page validated okay so now we must call all the
            // ValidateProperties necessary.
            if (S_OK != HrCallValidateProperties(hDlg))
            {
                // One of the interfaces returned something other than S_OK
                // from Validateproperties so we exit without letting
                // the original dialog procedure process the message.
                // This will keep the PropertySheet active.
                return (TRUE);
            }
        }
        else if (IDCANCEL == LOWORD(wParam) && BN_CLICKED == HIWORD(wParam))
        {
            // If Cancel was pressed set the last hresult
            SetLastHresult(HRESULT_FROM_WIN32(ERROR_CANCELLED));
        }
        break;

    }

    // call the original dialog procedure
    return (CallWindowProc((WNDPROC)lpfnOldWndProc, hDlg, msg, wParam, lParam));

}


//+---------------------------------------------------------------------------
//
//  Function:   VerifyCAPAGES
//
//  Synopsis:   function to check the validity of a given CAPAGES structure
//
//  Arguments:  [cap] --
//
//  Returns:    BOOL
//
//  Notes:      14-Jan-1998     SumitC      Created
//
//----------------------------------------------------------------------------

BOOL
FVerifyCAPAGES(const struct CAPAGES& cap)
{
    BOOL fGood = FALSE;

    if (cap.nCount == 0)
    {
        fGood = (cap.ahpsp == NULL);
    }
    else
    {
        fGood = !IsBadReadPtr(cap.ahpsp, sizeof(HPROPSHEETPAGE) * cap.nCount);
    }

    return fGood;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrNetCfgPropertySheet
//
//  Purpose:    This function is sets up our custom property sheet which is
//              a subclassed Win32 property sheet.
//              See Win32 documentation on PropertySheet for more information
//
//  Arguments:
//      lppsh           [in] a PROPSHEETHEADER
//      capOem          [in] A counted array of Oem pages
//      pStartPage      [in] Name of the initial page that appears when the property
//                              sheet dialog box is created. This member can specify
//                              either the identifier of a string resource or the
//                              pointer to a string that specifies the name.
//      caiProperties   [in] A counted array of INetCfgProperties interfaces
//
//  Returns:    HRESULT, S_OK if OK was pressed and changes were made,
//                          S_FALSE if OK was pressed and no changes were
//                          made. An error code otherwise.
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:
//          HRESULT_FROM_WIN32(ERROR_CANCELLED) is returned if the
//              cancel button was pressed
//
HRESULT
HrNetCfgPropertySheet(
        IN OUT LPPROPSHEETHEADER lppsh,
        IN const CAPAGES& capOem,
        IN PCWSTR pStartPage,
        const CAINCP& caiProperties)
{
    HRESULT hr = S_OK;

    Assert(lppsh);

    // The following should not be set since we are setting them
    Assert(0 == lppsh->nPages);
    Assert(NULL == lppsh->phpage);
    Assert(!(PSH_USECALLBACK & lppsh->dwFlags));
    Assert(!(PSH_PROPSHEETPAGE & lppsh->dwFlags));

    // If a start page was specified than there had better be Oem Pages
    Assert(FImplies(pStartPage, capOem.nCount));

    // We have to have at least one INetCfgProperties since we are here
    Assert(caiProperties.nCount);
    Assert(caiProperties.apncp);

    // Set our global CAINCP structure
    g_cai.nCount = caiProperties.nCount;
    g_cai.apncp = caiProperties.apncp;

    // Reset our global CAPAGES
    g_capPagesToAdd.nCount = 0;
    g_capPagesToAdd.ahpsp = NULL;

    // We need to set up a callback to subclass the dialog
    lppsh->dwFlags |= PSH_USECALLBACK;
    lppsh->pfnCallback = NetCfgPropSheetCallback;

    // There are no common pages to show so we will use the OEM pages
    // instead
    Assert(capOem.nCount);
    if (FVerifyCAPAGES(capOem))
    {
        lppsh->nPages = capOem.nCount;
        lppsh->phpage = capOem.ahpsp;
    }
    else
    {
        //$ REVIEW sumitc: or just return E_INVALIDARG?
        lppsh->nPages = 0;
        lppsh->phpage = NULL;
    }
    Assert(FImplies(lppsh->nPages, lppsh->phpage));

    // If a start page was specified, set the propsheet flag and
    // start page member.
    // Note: (billbe) This will not work if common pages exist since
    // that means Oem pages are added after the sheet is initialized
    if (pStartPage)
    {
        lppsh->dwFlags |= PSH_USEPSTARTPAGE;
        lppsh->pStartPage = pStartPage;
    }


    // Clear last hresult and changed flag
    SetLastHresult(S_OK);
    ResetChanged();

    // Call the Win32 property sheet
    NC_TRY
    {
        int iRetVal = PropertySheet(lppsh);
        if (-1 == iRetVal)
        {
            // The Win32 Sheet failed so we return E_FAIL
            SetLastHresult(E_FAIL);
        }
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }

    if (S_OK == hr)
    {
        // if the catch hasn't set hr to some error
        hr = HrGetLastHresult();
    }

    // if everthing went well, return the correct value based on whether
    // any of the pages changed
    //
    if (SUCCEEDED(hr))
    {
        // S_OK - changes were made, S_FALSE - no changes were made
        hr = FGetChanged() ? S_OK : S_FALSE;
    }

    TraceError("HrNetCfgPropertySheet",
        ((HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) || (S_FALSE == hr)) ? S_OK : hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ncprsht.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P R S H T . H
//
//  Contents:   NetCfg custom PropertySheet header
//
//  Notes:
//
//  Author:     billbe   8 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgn.h"

struct CAPAGES
{
    int nCount;
    HPROPSHEETPAGE* ahpsp;
};

struct CAINCP
{
    int nCount;
    INetCfgComponentPropertyUi** apncp;
};

HRESULT
HrNetCfgPropertySheet(IN OUT LPPROPSHEETHEADER lppsh,
        IN const CAPAGES& capOem,
        IN PCWSTR pStartPage,
        IN const CAINCP& caiProperties);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\modify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       M O D I F Y . C P P
//
//  Contents:   Routines used to setup modifications to the network
//              configuration.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "classinst.h"
#include "filtdevs.h"
#include "guisetup.h"
#include "inetcfg.h"
#include "lockdown.h"
#include "ncmsz.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "ndispnp.h"
#include "netcfg.h"
#include "persist.h"
#include "pnpbind.h"
#include "pszarray.h"
#include "util.h"
#include "wscfg.h"
#include "ncwins.h"
#include "ncperms.h"

CNetConfig*
CModifyContext::PNetConfig ()
{
    TraceFileFunc(ttidNetcfgBase);

    CNetConfig* pNetConfig;

    Assert ((LONG_PTR)this > FIELD_OFFSET(CNetConfig, ModifyCtx));

    // Get our containing CNetConfig pointer.
    //
    pNetConfig = CONTAINING_RECORD(this, CNetConfig, ModifyCtx);
    pNetConfig->Core.DbgVerifyData ();

    return pNetConfig;
}

HRESULT
CModifyContext::HrDirtyComponent (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (pComponent);

    m_hr = m_DirtyComponents.HrInsertComponent (pComponent,
            INS_IGNORE_IF_DUP | INS_SORTED);

#if DBG
    m_fComponentExplicitlyDirtied = TRUE;
#endif

    TraceHr (ttidError, FAL, m_hr, FALSE,
        "CModifyContext::HrDirtyComponentAndComponentsAbove");
    return m_hr;
}

HRESULT
CModifyContext::HrDirtyComponentAndComponentsAbove (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetcfgBase);

    GCCONTEXT Ctx;

    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (pComponent);

    // And insert the component itself.
    //
    m_hr = HrDirtyComponent (pComponent);

    // Only dirty the ones above if this component doesn't have the
    // NCF_DONTEXPOSELOWER characteristic.
    //
    if ((S_OK == m_hr) && !(pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER))
    {
        // Initialize the members of our context structure for recursion.
        //
        ZeroMemory (&Ctx, sizeof(Ctx));
        Ctx.pStackTable = &(PNetConfig()->Core.StackTable);
        Ctx.pComponents = &m_DirtyComponents;

        // Insert all of the component above.
        //
        GetComponentsAboveComponent (pComponent, &Ctx);
        m_hr = Ctx.hr;
    }

    TraceHr (ttidError, FAL, m_hr, FALSE,
        "CModifyContext::HrDirtyComponentAndComponentsAbove");
    return m_hr;
}

HRESULT
CModifyContext::HrApplyIfOkOrCancel (
    IN BOOL fApply)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    CNetConfig* pNetConfig;

    Assert (m_fPrepared);
    pNetConfig = PNetConfig();

    // Only apply if the context result is S_OK.
    //
    if (fApply && (S_OK == m_hr))
    {
        // Setupapi calls that we make during ApplyChanges have the
        // potential to return control to our clients windows message loop.
        // When this happens, and our clients are poorly written, they
        // may try to re-enter us on the same thread.  This is disaster
        // waiting to happen, so we need to prevent it by raising our
        // reentrancy protection level before we start apply changes.
        //
        pNetConfig->Notify.PINetCfg()->RaiseRpl (RPL_DISALLOW);

        ApplyChanges ();

        pNetConfig->Notify.PINetCfg()->LowerRpl (RPL_DISALLOW);

        // Delete those components from m_CoreStartedWith that are not
        // in the current core and reset the modify context.
        //
        m_CoreStartedWith.Components.FreeComponentsNotInOtherComponentList (
                &pNetConfig->Core.Components);
        m_CoreStartedWith.Clear();

        hr = S_OK;

        // Return the correct HRESULT to the caller.  If we've successfully
        // applied, but need a reboot, return so.
        //
        if (m_fRebootRecommended || m_fRebootRequired)
        {
            hr = NETCFG_S_REBOOT;
        }
    }
    else
    {
        // Cancel and release all notify objects.  Do this for what is
        // in the core as well as what we started with.  (There will
        // be some overlap, but they will only be released once.)
        // We need to do both sets so we don't miss releasing components
        // that have been removed.  (Removed components won't be in
        // current core, but they will be in the core that we started
        // with.)  Likewise, if we just released the core we started with,
        // we'd miss releasing those components that were added.)
        //
        pNetConfig->Notify.ReleaseAllNotifyObjects (pNetConfig->Core.Components, TRUE);
        pNetConfig->Notify.ReleaseAllNotifyObjects (m_CoreStartedWith.Components, TRUE);

        // Delete those components from m_CoreStartedWith that are not
        // in the current core.  Then delete all the components in the
        // current core and reload from our persistent storage.
        // (This has the nice effect of invalidating all outstanding
        // INetCfgComponent interfaces.)
        //
        m_CoreStartedWith.Components.FreeComponentsNotInOtherComponentList (
                &pNetConfig->Core.Components);
        pNetConfig->Core.Free ();

        // Eject both cores (didn't you just know this metaphor was coming ;-)
        // and reload the core from our persisted binary.  This magically,
        // and completely rolls everything back.
        //
        m_CoreStartedWith.Clear();
        pNetConfig->Core.Clear();

        // Return reason for failure through hr.
        //
        hr = m_hr;

        // Reload the configuration and, if successful, it means m_hr
        // will be S_OK.  If unsuccessful, m_hr will be the error and will
        // prevent subsequent operations.
        //
        m_hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, pNetConfig);
    }

    // Very important to set m_fPrepared back to FALSE so that HrPrepare gets
    // called for the next modifcation and correctly copy the core etc.
    //
    m_fPrepared = FALSE;
    m_AddedBindPaths.Clear();
    m_DeletedBindPaths.Clear();
    m_DirtyComponents.Clear();
#if DBG
    m_fComponentExplicitlyDirtied = FALSE;
#endif

    Assert (!m_fPrepared);
    Assert (m_CoreStartedWith.FIsEmpty());
    Assert (m_AddedBindPaths.FIsEmpty());
    Assert (m_DeletedBindPaths.FIsEmpty());
    Assert (m_DirtyComponents.FIsEmpty());
    Assert (0 == m_ulRecursionDepth);
    Assert (!m_fComponentExplicitlyDirtied);

    Assert ((S_OK == hr) || (NETCFG_S_REBOOT == hr) || FAILED(hr));
    TraceHr (ttidError, FAL, hr, NETCFG_S_REBOOT == hr,
        "CModifyContext::HrApplyIfOkOrCancel");
    return hr;
}

HRESULT
CModifyContext::HrPrepare ()
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (S_OK == m_hr);
    Assert (!m_fPrepared);
    Assert (m_CoreStartedWith.FIsEmpty());
    Assert (m_AddedBindPaths.FIsEmpty());
    Assert (m_DeletedBindPaths.FIsEmpty());
    Assert (m_DirtyComponents.FIsEmpty());
    Assert (0 == m_ulRecursionDepth);
    Assert (!m_fComponentExplicitlyDirtied);

    CNetConfig* pThis;

    pThis = PNetConfig();

    // Prepare the bind context.  This will ensure all of the external
    // data for all components is loaded as well as all ensuring that
    // all notify objects have been initialized.
    //
    m_hr = m_RegBindCtx.HrPrepare (pThis);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Snapshot the current core so that we know what we started with.
    // We will use the differences when we apply (if we get that far).
    //
    m_hr = m_CoreStartedWith.HrCopyCore (&pThis->Core);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room for 64 components in the core.
    // (64 * 4 = 256 bytes on 32-bit platforms)
    //
    m_hr = pThis->Core.Components.HrReserveRoomForComponents (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room for 64 stack entries in the core.
    // (64 * (4 + 4) = 512 bytes on 32-bit platforms)
    //
    m_hr = pThis->Core.StackTable.HrReserveRoomForEntries (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room in our added list for 64 bindpaths of 8 components.
    // (64 * 16 = 1K bytes on 32-bit platforms)
    //
    m_hr = m_AddedBindPaths.HrReserveRoomForBindPaths (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room in our deleted list for 64 bindpaths of 8 components.
    // (64 * 16 = 1K bytes on 32-bit platforms)
    //
    m_hr = m_DeletedBindPaths.HrReserveRoomForBindPaths (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room for 64 components in the dirty component list.
    // (64 * 4) = 256 bytes on 32-bit platforms)
    //
    m_hr = m_DirtyComponents.HrReserveRoomForComponents (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    m_fPrepared = TRUE;

finished:
    TraceHr (ttidError, FAL, m_hr, FALSE, "CModifyContext::HrPrepare");
    return m_hr;
}

HRESULT
CModifyContext::HrBeginBatchOperation ()
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (0 == m_ulRecursionDepth);

    TraceTag (ttidBeDiag, "Begin batch operation...");

    PushRecursionDepth();
    return m_hr;
}

HRESULT
CModifyContext::HrEndBatchOperation (
    IN EBO_FLAG Flag)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;

    Assert (m_fPrepared);
    Assert (1 == m_ulRecursionDepth);

    if (EBO_COMMIT_NOW == Flag)
    {
        TraceTag (ttidBeDiag, "End batch (commiting changes)...");

        hr = HrPopRecursionDepth ();
    }
    else
    {
        Assert (EBO_DEFER_COMMIT_UNTIL_APPLY == Flag);

        TraceTag (ttidBeDiag, "End batch (deferring commit until Apply)...");

        m_ulRecursionDepth = 0;
        hr = S_OK;
    }

    Assert (0 == m_ulRecursionDepth);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrEndBatchOperation");
    return hr;
}

VOID
CModifyContext::PushRecursionDepth ()
{
    TraceFileFunc(ttidNetcfgBase);
    Assert (S_OK == m_hr);
    Assert (m_fPrepared);

    m_ulRecursionDepth++;
}

HRESULT
CModifyContext::HrPopRecursionDepth ()
{
    TraceFileFunc(ttidNetcfgBase);
    Assert (m_fPrepared);
    Assert (m_ulRecursionDepth > 0);

    m_ulRecursionDepth--;

    if (0 != m_ulRecursionDepth)
    {
        return m_hr;
    }

    // We're at the top-level of the install or remove modifcation so
    // apply or cancel the changes depending on the state of the context
    // result.
    //
    HRESULT hr;

    hr = HrApplyIfOkOrCancel (S_OK == m_hr);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrPopRecursionDepth");
    return hr;
}

//----------------------------------------------------------------------------
// This is a convenience method to find and process Winsock Remove
// section for a component which is about to be removed.

HRESULT
CModifyContext::HrProcessWinsockRemove(IN const CComponent *pComponent)
{
    TraceFileFunc(ttidNetcfgBase);

    HINF hinf = NULL;
    HKEY hkeyInstance = NULL;
    HRESULT hr;

    Assert(pComponent);

    hr = pComponent->HrOpenInfFile(&hinf);
    if (S_OK == hr)
    {
        static const WCHAR c_szRemoveSectionSuffix[] = L".Remove";

        // We get the remove section name and process all relevant sections
        WCHAR szRemoveSection[_MAX_PATH];
        DWORD cbBuffer = sizeof (szRemoveSection);

        hr = pComponent->HrOpenInstanceKey (KEY_READ,
            &hkeyInstance, NULL, NULL);

        if(S_OK == hr)
        {
            hr = HrRegQuerySzBuffer (hkeyInstance, REGSTR_VAL_INFSECTION,
                        szRemoveSection, &cbBuffer);

            if (S_OK == hr)
            {
                //HrAddOrRemoveWinsockDependancy processes the winsock
                //remove section in the given inf file and then calls
                //MigrateWinsockConfiguration which will cause the
                //necessary PnP notifications to be issued to the
                //interested application.
                wcscat (szRemoveSection, c_szRemoveSectionSuffix);

                hr = HrAddOrRemoveWinsockDependancy (hinf, szRemoveSection);
            }
            RegSafeCloseKey (hkeyInstance);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrProcessWinsockRemove (%S)",
        pComponent->PszGetPnpIdOrInfId());

    return hr;
}

VOID
CModifyContext::ApplyChanges ()
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    CNetConfig* pNetConfig;
    CComponentList::const_iterator iter;
    CComponent* pComponent;
    CFilterDevices FilterDevices (&PNetConfig()->Core);
    CPszArray ServiceNames;
    CServiceManager ServiceManager;
    PCWSTR pszService;
    BOOL fRebootNeeded;
    BOOL fMigrateWinsock;
    BOOL fModifyFilterDevices;
    BOOL fSignalNetworkProviderLoaded;
    BOOL fUserIsNetConfigOps;
    BOOL fCallCoFreeUnusedLibraries;

    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (0 == m_ulRecursionDepth);

    pNetConfig = PNetConfig();

    fMigrateWinsock = FALSE;
    fModifyFilterDevices = FALSE;
    fSignalNetworkProviderLoaded = FALSE;
    fUserIsNetConfigOps = FIsUserNetworkConfigOps();
    fCallCoFreeUnusedLibraries = FALSE;

    //+-----------------------------------------------------------------------
    // Step 0: Prepare m_AddedBindPaths, m_DeletedBindPaths, and
    // m_DirtyComponents.
    //

    // Add the bindpaths that were once disabled, but are now enabled, to
    // m_AddedBindPaths.  We do this so that PnP notifications are sent for
    // them.
    //
    m_hr = m_AddedBindPaths.HrAddBindPathsInSet1ButNotInSet2 (
                &m_CoreStartedWith.DisabledBindings,
                &pNetConfig->Core.DisabledBindings);
    if (S_OK != m_hr)
    {
        return;
    }

    // Add the bindpaths that were once enabled, but are now disabled, to
    // m_DeletedBindPaths.  We do this so that PnP notifications are sent for
    // them.
    //
    m_hr = m_DeletedBindPaths.HrAddBindPathsInSet1ButNotInSet2 (
                &pNetConfig->Core.DisabledBindings,
                &m_CoreStartedWith.DisabledBindings);
    if (S_OK != m_hr)
    {
        return;
    }

    // m_fDirtyComponents should be empty unless we've explicitly dirtied
    // one or more.  If m_fDirtyComponents were not empty, it would probably
    // mean we forgot to clear it after the last Apply or Cancel.
    // Conversely, m_DirtyComponents better not be empty if we've explicitly
    // dirtied one or more.
    //
    Assert (FIff(!m_fComponentExplicitlyDirtied, m_DirtyComponents.FIsEmpty()));

    // Dirty the affected components (owners and adapters in bindpaths of
    // length 2) from the added and deleted bindpaths.  We need to write
    // bindings for these components.
    //
    m_hr = m_AddedBindPaths.HrGetAffectedComponentsInBindingSet (
                &m_DirtyComponents);
    if (S_OK != m_hr)
    {
        return;
    }

    m_hr = m_DeletedBindPaths.HrGetAffectedComponentsInBindingSet (
                &m_DirtyComponents);
    if (S_OK != m_hr)
    {
        return;
    }

    // Dirty components that exist in the current core, but not in the core
    // we started with.  (These are added components).
    //
    m_hr = m_DirtyComponents.HrAddComponentsInList1ButNotInList2 (
                &pNetConfig->Core.Components,
                &m_CoreStartedWith.Components);
    if (S_OK != m_hr)
    {
        return;
    }

    // Dirty components that exist in the core we started with, but not in
    // the current core.  (These are removed components).
    //
    m_hr = m_DirtyComponents.HrAddComponentsInList1ButNotInList2 (
                &m_CoreStartedWith.Components,
                &pNetConfig->Core.Components);
    if (S_OK != m_hr)
    {
        return;
    }

    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 0: The following components are dirty:\n");
    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pNetConfig->Core.Components.FComponentInList (pComponent))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %-12S  (removed)\n",
                pComponent->PszGetPnpIdOrInfId());
        }
        else if (!m_CoreStartedWith.Components.FComponentInList (pComponent))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %-12S  (installed)\n",
                pComponent->PszGetPnpIdOrInfId());
        }
        else
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %S\n",
                pComponent->PszGetPnpIdOrInfId());
        }
    }

    // Reserve room for 32 pointers to service names.  We use this buffer
    // to start and stop services.
    //
    m_hr = ServiceNames.HrReserveRoomForPointers (32);
    if (S_OK != m_hr)
    {
        return;
    }

    // See if we are going to modify any filter devices.  If we are,
    // we'll go through all of the steps of loading filter devices, removing
    // any we don't need, installing any new ones, and binding them all up.
    // We only modify filter devices if the user is a normal admin and not
    // a netcfgop.
    //
    // This test could be further refined to see if we had any filters which
    // were dirty or if we had any dirty adapters which are filtered.
    //
    if (!fUserIsNetConfigOps)
    {
        fModifyFilterDevices = pNetConfig->Core.FContainsFilterComponent() ||
                              m_CoreStartedWith.FContainsFilterComponent();
    }
    else
    {
        Assert(!fModifyFilterDevices);
    }

    if (fModifyFilterDevices)
    {
        // Allow the filter devices structure to reserve whatever memory it
        // may need.
        //
        m_hr = FilterDevices.HrPrepare ();
        if (S_OK != m_hr)
        {
            return;
        }
    }

    pNetConfig->Core.DisabledBindings.Printf (ttidBeDiag,
        "   The following bindings are currently disabled:\n");


    //+-----------------------------------------------------------------------
    // Step 1: Save the network configuration binary.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 1: Save the network configuration binary.\n");

    HrSaveNetworkConfigurationToRegistry (pNetConfig);


    //+-----------------------------------------------------------------------
    // Step 2: Write the static bindings for all changed components.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 2: Write the following static bindings.\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // If any protocols are dirty, we'll want to migrate winsock
        // configuration later.
        //
        if (NC_NETTRANS == pComponent->Class())
        {
            fMigrateWinsock = TRUE;
        }

        // If the component is in the core, write its bindings.
        // If it is not in the core, it means it has been removed and
        // we should therefore remove its bindings.
        //
        if (pNetConfig->Core.Components.FComponentInList (pComponent))
        {
            hr = m_RegBindCtx.HrWriteBindingsForComponent (pComponent);

            // Remember any errors, but continue.
            //
            if (S_OK != hr)
            {
                Assert (FAILED(hr));
                m_hr = hr;
            }
        }
        else
        {
            // Only delete if we're not installing another version of this
            // component that has a duplicate PnpId.  If we had already
            // written the bindings for the newly installed one, and then
            // deleted the ones for the removed (yet duplicate PnpId), we'd
            // effectivly delete the bindings for the new one too.  See the
            // comments at step 6 for how we can get into this case.
            //
            if (!FIsEnumerated (pComponent->Class()) ||
                !pNetConfig->Core.Components.PFindComponentByPnpId (
                    pComponent->m_pszPnpId))
            {
                // There's no reason to fail if we can't delete the bindings.
                // The entire component is about to be tossed anyway.
                //
                (VOID) m_RegBindCtx.HrDeleteBindingsForComponent (pComponent);
            }
        }
    }


    //+-----------------------------------------------------------------------
    // Step 3: Notify ApplyRegistryChanges
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 3: Notify: apply registry changes\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        pComponent->Notify.ApplyRegistryChanges (
            pNetConfig->Notify.PINetCfg(),
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            m_fRebootRecommended = TRUE;

            g_pDiagCtx->Printf (ttidBeDiag, "      %S notify object wants a reboot\n",
                pComponent->m_pszInfId);
        }
    }

    // Migrate Winsock configuration if needed.
    // Important to do this after the LANA map is written, afer Notify Applys
    // are called, but before any services are started.
    //
    if (fMigrateWinsock)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "Migrating winsock configuration.\n");
        (VOID) HrMigrateWinsockConfiguration ();
    }

    //+-----------------------------------------------------------------------
    // Step 4: Unbind deleted bindpaths.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 4: Unbind the following deleted bindings:\n");

    if (!m_DeletedBindPaths.FIsEmpty())
    {
        // We don't need to send UNBIND notifications for bindpaths that
        // involve adapters that have been removed.  They will be unbound
        // automatically when the adapter is uninstalled.  (For the case
        // when the class installer is notifying us of a removed adapter,
        // its important NOT to try to send an UNBIND notification because
        // the adapter has already been uninstalled (hence unbound) and
        // our notification might come back in error causing us to need
        // a reboot uneccessary.
        //
        // So, remove the bindpaths in m_DeletedBindPaths that involve
        // adapters that have been removed.
        //
        for (iter  = m_DirtyComponents.begin();
             iter != m_DirtyComponents.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // If its enumerated, and not in the current core, its a
            // removed adapter.
            //
            if (FIsEnumerated (pComponent->Class()) &&
                !pNetConfig->Core.Components.FComponentInList (pComponent))
            {
                m_DeletedBindPaths.RemoveBindPathsWithComponent (pComponent);
            }
        }

        m_DeletedBindPaths.SortForPnpUnbind ();

        m_RegBindCtx.PnpBindOrUnbindBindPaths (UNBIND,
            &m_DeletedBindPaths,
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            m_fRebootRecommended = TRUE;
        }
    }


    //+-----------------------------------------------------------------------
    // Step 5: Stop services for removed components.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 5: Stop the following services:\n");

    Assert (0 == ServiceNames.Count());
    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Ignore enumerated components because they will have their drivers
        // stopped automatically (if appropriate) when they are removed.
        // Ignore components that are in the current core (not being removed).
        //
        if (FIsEnumerated (pComponent->Class()) ||
            pNetConfig->Core.Components.FComponentInList (pComponent))
        {
            continue;
        }

        // Winsock remove section needs to be processed for every
        // component that is being removed in order to update
        // Transport key for the winsock registry settings

        HrProcessWinsockRemove (pComponent);

        // If its a protcol, send an UNLOAD before trying to stop the service.
        //

        if ((NC_NETTRANS == pComponent->Class()) || (NCF_NDIS_PROTOCOL & pComponent->m_dwCharacter))
        {
            // Unload can fail as a lot of drivers do not support it.
            // Treat it as an 'FYI' indication and don't set the reboot
            // flag if it fails.
            //
            (VOID) HrPnpUnloadDriver (NDIS, pComponent->Ext.PszBindName());
        }

        // Ignore components that don't have any services.
        if (!pComponent->Ext.PszCoServices())
        {
            continue;
        }


        for (pszService = pComponent->Ext.PszCoServices();
             *pszService;
             pszService += wcslen(pszService) + 1)
        {
            (VOID)ServiceNames.HrAddPointer (pszService);

            g_pDiagCtx->Printf (ttidBeDiag, "   %S", pszService);
        }
        g_pDiagCtx->Printf (ttidBeDiag, "\n");
    }

    if (ServiceNames.Count() > 0)
    {
        static const CSFLAGS CsStopFlags =
        {
            FALSE,                  // FALSE means don't start
            SERVICE_CONTROL_STOP,   // use this control instead
            15000,                  // wait up to 15 seconds...
            SERVICE_STOPPED,        // ... for service to reach this state
            FALSE,                  //
        };

        hr = ServiceManager.HrControlServicesAndWait (
                ServiceNames.Count(),
                ServiceNames.begin(),
                &CsStopFlags);

        if (S_OK != hr)
        {
            m_fRebootRequired = TRUE;

            g_pDiagCtx->Printf (ttidBeDiag, "      some service failed to stop (hr = 0x%08X)\n",
                hr);

            // Unfortunately, there is no easy way to get back which service
            // did not stop and then to figure out which component contains
            // that service.  Sooo, we'll just put every component that is
            // being removed in lockdown.  This isn't a big deal when the UI
            // is doing the removal because it only removes things one at a
            // time.
            //
            for (iter  = m_DirtyComponents.begin();
                 iter != m_DirtyComponents.end();
                 iter++)
            {
                pComponent = *iter;
                Assert (pComponent);

                if (FIsEnumerated (pComponent->Class()) ||
                    !pComponent->Ext.PszCoServices() ||
                    pNetConfig->Core.Components.FComponentInList (pComponent))
                {
                    continue;
                }

                LockdownComponentUntilNextReboot (pComponent->m_pszInfId);
            }
        }

        ServiceNames.Clear();
    }

    //+-----------------------------------------------------------------------
    // Step 5a: Uninstall filters first.
    //

    if (fModifyFilterDevices)
    {
        g_pDiagCtx->Printf(ttidBeDiag, "Step 5a: Remove filter devices:\n");

        // Order is of utmost importance here.  Remove must be called first
        // because it initializes some state internal to FilterDevices.  Start
        // must come after Write and Write obviously has to come after all
        // new filter devices are installed.
        //
        FilterDevices.LoadAndRemoveFilterDevicesIfNeeded ();
    }


    //+-----------------------------------------------------------------------
    // Step 6: Uninstall removed components.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 6: Uninstall the following components:\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // If the component is in the core, ignore it.
        // If it is not in the core, it means it has been removed and
        // we should therefore remove its bindings.
        //
        if (pNetConfig->Core.Components.FComponentInList (pComponent))
        {
            continue;
        }

        // If this is an enumerated component whose PnpId matches that of
        // a component in the current core, we've run into a special case.
        // This can happen when the external data (like the NetCfgInstanceId)
        // is corrupted and the class installer was told to update the
        // component.  The class installer is really told to "install" the
        // component, but if it already exists as determined by the presence
        // of NetCfgInstanceId, the class installer translates it to "update".
        // Without the key, the class installer thinks its installing
        // a new one.  We detect the duplicate PnpId and remove the "prior"
        // so we can install the "new".  This "prior" instance is what we
        // are finalizing the remove of, but if we call HrCiRemoveComponent,
        // it just removes the same PnpId that the class installer told us
        // to install.  By not calling HrCiRemoveComponent for this case,
        // the "prior" instance key gets reused implicitly by the "new"
        // instance.
        //
        if (FIsEnumerated (pComponent->Class()) &&
            pNetConfig->Core.Components.PFindComponentByPnpId (
                pComponent->m_pszPnpId))
        {
            g_pDiagCtx->Printf (ttidBeDiag,
                "   Skip removal of %S because a duplicate was installed\n",
                pComponent->m_pszPnpId);

            continue;
        }

        g_pDiagCtx->Printf (ttidBeDiag,
            "   %S\n", pComponent->PszGetPnpIdOrInfId());

        hr = HrCiRemoveComponent (pComponent, &pComponent->m_strRemoveSection);

        // We can ignore SPAPI_E_NO_SUCH_DEVINST because the class installer
        // may have already removed it and is just notifying us.
        //
        if ((S_OK != hr) && (SPAPI_E_NO_SUCH_DEVINST != hr))
        {
            m_fRebootRequired = TRUE;

            g_pDiagCtx->Printf (ttidBeDiag, "      ^^^ needs a reboot (hr = 0x%08X)\n",
                hr);
        }
    }

    //+-----------------------------------------------------------------------
    // Step 6a: Modify filter devices.
    //
    if (fModifyFilterDevices)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "Step 6a: Modify filter devices:\n");

        FilterDevices.InstallFilterDevicesIfNeeded ();

        (VOID)m_RegBindCtx.HrWriteBindingsForFilterDevices (&FilterDevices);

        PruneNdisWanBindPathsIfActiveRasConnections (
            &FilterDevices.m_BindPathsToRebind,
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            m_fRebootRecommended = TRUE;
        }

        m_RegBindCtx.PnpBindOrUnbindBindPaths (UNBIND,
            &FilterDevices.m_BindPathsToRebind,
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            m_fRebootRecommended = TRUE;
        }

        g_pDiagCtx->Printf (ttidBeDiag, "Step 6b: Starting filter devices:\n");

        FilterDevices.StartFilterDevices ();
        FilterDevices.Free ();
    }

    //+-----------------------------------------------------------------------
    // Step 7: Start services for added components.
    //
    Assert (0 == ServiceNames.Count());

    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 7: Start the following drivers/services:\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // If the component is in the core we started with, ignore it.
        // If it is not in the core we started with, it means it is newly
        // installed we should therefore start its services.
        //
        if (m_CoreStartedWith.Components.FComponentInList (pComponent))
        {
            continue;
        }

        // If we've added a network client, we'll need to signal the
        // network provider loaded event after we've started its service.
        //
        if (NC_NETCLIENT == pComponent->Class())
        {
            fSignalNetworkProviderLoaded = TRUE;
        }

        if (FIsEnumerated (pComponent->Class()))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %S\n", pComponent->m_pszPnpId);

            hr = pComponent->HrStartOrStopEnumeratedComponent (DICS_START);

            if (S_OK != hr)
            {
                m_fRebootRecommended = TRUE;

                g_pDiagCtx->Printf (ttidBeDiag, "      ^^^ needs a reboot (hr = 0x%08X)\n",
                    hr);
            }

            if (FIsPhysicalNetAdapter (pComponent->Class(),
                    pComponent->m_dwCharacter) && FInSystemSetup())
            {
                ProcessAdapterAnswerFileIfExists (pComponent);
            }
        }
        else if (pComponent->Ext.PszCoServices())
        {
            for (pszService = pComponent->Ext.PszCoServices();
                 *pszService;
                 pszService += wcslen(pszService) + 1)
            {
                (VOID)ServiceNames.HrAddPointer (pszService);

                g_pDiagCtx->Printf (ttidBeDiag, "   %S", pszService);
            }
            g_pDiagCtx->Printf (ttidBeDiag, "\n");

            // If we're in system setup, then exclude whatever services
            // the component has marked as such.
            //
            if (FInSystemSetup())
            {
                ExcludeMarkedServicesForSetup (pComponent, &ServiceNames);
            }
        }
    }

    if ((ServiceNames.Count() > 0) &&
        !(g_pDiagCtx->Flags() & DF_DONT_START_SERVICES))
    {
        static const CSFLAGS CsStartFlags =
        {
            TRUE,               // TRUE means start
            0,
            20000,              // wait up to 20 seconds...
            SERVICE_RUNNING,    // ... for service to reach this state
            TRUE,               // ignore demand-start and disabled
        };

        hr = ServiceManager.HrControlServicesAndWait (
                ServiceNames.Count(),
                ServiceNames.begin(),
                &CsStartFlags);

        if (S_OK != hr)
        {
            m_fRebootRecommended = TRUE;

            g_pDiagCtx->Printf (ttidBeDiag, "      some service failed to start (hr = 0x%08X)\n",
                hr);
        }
    }


    //+-----------------------------------------------------------------------
    // Step 8: Bind added bindpaths.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 8: Bind the following added bindings:\n");

    if (fModifyFilterDevices)
    {
        hr = m_AddedBindPaths.HrAppendBindingSet (
                &FilterDevices.m_BindPathsToRebind);
        if (S_OK != hr)
        {
            // Well, that's not good, but there is nothing we can do about
            // it now.  (Most likely we ran out of memory.)
        }
    }

    if (!m_AddedBindPaths.FIsEmpty())
    {
        CBindPath* pBindPath;

        // We don't need to send BIND notifications for bindpaths that
        // involve adapters that have been newly installed.  They will be
        // bound automatically when the adapter is started.
        //
        // Update to the above comment: We THOUGHT that was correct, but it
        // turns out it isn't.  TDI isn't PNP (guess they must have missed
        // THAT memo) and they are not re-reading the new bind strings
        // from the registry when lower notifications bubble up.  So, we
        // have to send these BINDS for added adapters too.
        //
        // We should remove bindpaths that involve components that have
        // been removed.  These can end up in added bindpaths because way
        // up in step 0, we added bindpaths that were disabled in the
        // core we started with and that are no longer disabled in the
        // current core.  Well, when the component is removed, its disabled
        // bindings are removed, so this case would have caused us to add
        // the bindpath to this binding set.
        //
        for (iter  = m_DirtyComponents.begin();
             iter != m_DirtyComponents.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // If its been removed, remove any bindpaths that reference it.
            //
            if (!pNetConfig->Core.Components.FComponentInList (pComponent))
            {
                m_AddedBindPaths.RemoveBindPathsWithComponent (pComponent);
            }
        }

        // To prevent TDI from sending duplicate BINDs to its clients, we
        // have to do a little more work.  We need to not send the TDI
        // BINDs to components that are newly installed.  This is because
        // TDI sent them the BINDs when we started the driver above.
        // So, for each added bindpath, if it's going to the TDI layer, and
        // the owner (topmost) component of the bindpath is newly installed,
        // remove it from the added binding so we won't send a notification
        // for it below.
        //
        pBindPath = m_AddedBindPaths.begin();
        while (pBindPath != m_AddedBindPaths.end())
        {
            UINT unLayer = GetPnpLayerForBindPath (pBindPath);

            if ((TDI == unLayer) &&
                !m_CoreStartedWith.Components.FComponentInList (
                        pBindPath->POwner()))
            {
                m_AddedBindPaths.erase (pBindPath);
            }
            else
            {
                pBindPath++;
            }
        }

        m_AddedBindPaths.SortForPnpBind ();

        m_RegBindCtx.PnpBindOrUnbindBindPaths (BIND,
            &m_AddedBindPaths,
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            // If BINDs fail, we should recommend a reboot, but one is
            // not required for subsequent installs or removes.
            //
            m_fRebootRecommended = TRUE;
        }
    }

    // Signal the network provider loaded event if needed.
    // Probably best to do this after we've indiciated the PnP bindings
    // (above) to the new clients.
    //
    if (fSignalNetworkProviderLoaded)
    {
        SignalNetworkProviderLoaded ();
    }

    //+-----------------------------------------------------------------------
    // Step 9: Allow notify objects to apply PnP changes
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 9: Notify: apply PnP changes\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        pComponent->Notify.ApplyPnpChanges (
            pNetConfig->Notify.PINetCfg(),
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            g_pDiagCtx->Printf (ttidBeDiag,
                "      %S notify object wants a reboot\n",
                pComponent->m_pszInfId);

            // If the component has been removed, treat the reboot
            // as mandatory.  (The reason being that we cannot risk a
            // failed re-install.)  We put the component into lockdown
            // in this situation.
            //
            if (!pNetConfig->Core.Components.FComponentInList (pComponent))
            {
                m_fRebootRequired = TRUE;

                LockdownComponentUntilNextReboot (pComponent->m_pszInfId);
            }
            else
            {
                m_fRebootRecommended = TRUE;
            }
        }
    }

    //+-----------------------------------------------------------------------
    // Step 10: Release notify objects for removed components and
    // process any DelFiles in the remove section of their INF.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 10: Release notify objects for removed components:\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Skip enumerated components (they don't have notify objects), and
        // Skip components that were not removed.
        // Skip components that don't have their INF open (like unsupported
        // components that get removed during GUI setup.)
        //
        if (FIsEnumerated (pComponent->Class()) ||
            pNetConfig->Core.Components.FComponentInList (pComponent) ||
            !pComponent->GetCachedInfFile())
        {
            continue;
        }

        pComponent->Notify.ReleaseNotifyObject(NULL, FALSE);

        fCallCoFreeUnusedLibraries = TRUE;
    }

    if (fCallCoFreeUnusedLibraries)
    {
        g_pDiagCtx->Printf (ttidBeDiag,
            "   calling CoFreeUnusedLibraries before running remove sections\n");

        // Now ask COM to unload any DLLs hosting COM objects that are no longer
        // in use.  (This is a bit heavy-handed as it affects the entire process,
        // but there is currently no other way to safely unload the DLLs hosting
        // the notify objects of the removed components.)
        //
        CoFreeUnusedLibrariesEx(0, 0);

        for (iter  = m_DirtyComponents.begin();
             iter != m_DirtyComponents.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // Skip enumerated components (they don't have notify objects), and
            // Skip components that were not removed.
            // Skip components that don't have their INF open (like unsupported
            // components that get removed during GUI setup.)
            //
            if (FIsEnumerated (pComponent->Class()) ||
                pNetConfig->Core.Components.FComponentInList (pComponent) ||
                !pComponent->GetCachedInfFile())
            {
                continue;
            }

            g_pDiagCtx->Printf (ttidBeDiag,
                "   %S  [%S]\n", pComponent->PszGetPnpIdOrInfId(),
                                 pComponent->m_strRemoveSection.c_str());

            (VOID) HrCiInstallFromInfSection(
                        pComponent->GetCachedInfFile(),
                        pComponent->m_strRemoveSection.c_str(),
                        NULL, NULL, SPINST_FILES);
        }
    }


/*
    //+-----------------------------------------------------------------------
    // Step 11: Reconfigure moved bindings
    //
    // If we changed binding order, Send PnP RECONFIGURE for all dirty
    // components that are neither installed nor removed so we
    // pickup these order changes.
    //
    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Skip components that have been newly installed or removed.
        //
        if (!pNetConfig->Core.Components.FComponentInList (pComponent) ||
            !m_CoreStartedWith.Components.FComponentInList (pComponent))
        {
            continue;
        }

        // Note: send RECONFIGURE
    }
*/
}

HRESULT
CModifyContext::HrEnableOrDisableBindPath (
    IN DWORD dwChangeFlag,
    IN CBindPath* pBindPath,
    IN INetCfgBindingPath* pIPath OPTIONAL)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    CNetConfig* pNetConfig;
    UINT CountBefore;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert ((dwChangeFlag == NCN_ENABLE) || (dwChangeFlag == NCN_DISABLE));
    Assert (pBindPath);

    hr = S_OK;
    pNetConfig = PNetConfig();

    // Get the count of bindpaths currently disabled.  If it changes
    // after we enable/disable this one, we'll inform notify objects
    // about it.  If the count does not change, it means the state
    // of the bindpath has not changed.
    //
    CountBefore = pNetConfig->Core.DisabledBindings.CountBindPaths();

    if (NCN_ENABLE == dwChangeFlag)
    {
        pNetConfig->Core.EnableBindPath (pBindPath);
        Assert (S_OK == hr);
    }
    else
    {
        hr = pNetConfig->Core.HrDisableBindPath (pBindPath);
    }

    if ((S_OK == hr) &&
        (pNetConfig->Core.DisabledBindings.CountBindPaths() != CountBefore))
    {
        // Note: Need to protect against bad notify objects that
        // switch the state of a bindpath we are notifying for.
        // This could cause an infinite loop.  Solve by adding a
        // recursion count and bindset to the modify context dedicated
        // to bindpath enabling/disabling.  When the count is zero,
        // we clear the bindingset, add the bindpath we are about to
        // notify for, increment the recursion count and call
        // NotifyBindPath.  When the call returns, we decrement the
        // recursion count, remove the bindpath from the binding set,
        // and return.  Before we call NotifyBindPath when the recursion
        // count is non-zero, if the bindpath is already in the
        // bindingset, we don't call.
        //

        pNetConfig->Notify.NotifyBindPath (dwChangeFlag, pBindPath, pIPath);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrEnableOrDisableBindPath");
   return hr;
}

VOID
CModifyContext::InstallOrRemoveRequiredComponents (
    IN CComponent* pComponent,
    IN IOR_ACTION Action)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    HKEY hkeyInstance;
    PWSTR pszRequiredList;
    const WCHAR szDelims[] = L", ";

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (pComponent);
    Assert ((IOR_INSTALL == Action) || (IOR_REMOVE == Action));

    pszRequiredList = NULL;

    // Open the instance key of the component and read the RequireAll value.
    // This value may not exist, which is okay, it means we have nothing
    // to do.
    //
    hr = pComponent->HrOpenInstanceKey (KEY_READ, &hkeyInstance, NULL, NULL);

    if (S_OK == hr)
    {
        HKEY hkeyNdi;

        hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

        if (S_OK == hr)
        {
            hr = HrRegQuerySzWithAlloc (hkeyNdi, L"RequiredAll",
                    &pszRequiredList);

            RegCloseKey (hkeyNdi);
        }

        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
            Assert (!pszRequiredList);
        }

        RegCloseKey (hkeyInstance);
    }

    // If we have a list of required components, install or remove them.
    //
    if ((S_OK == hr) && pszRequiredList)
    {
        CNetConfig* pNetConfig;
        INetCfgComponent* pIComp;

        pNetConfig = PNetConfig();

        hr = pComponent->HrGetINetCfgComponentInterface (
                pNetConfig->Notify.PINetCfg(),
                &pIComp);

        if (S_OK == hr)
        {
            PCWSTR pszInfId;
            PWSTR pszNextInfId;
            OBO_TOKEN OboToken;
            CComponent* pComponentToRemove;
            WCHAR szInfFile [_MAX_PATH];

            ZeroMemory (&OboToken, sizeof(OboToken));
            OboToken.Type = OBO_COMPONENT;
            OboToken.pncc = pIComp;

            // For each INF ID in the comma separate list of required
            // components...
            //
            for (pszInfId = GetNextStringToken (pszRequiredList, szDelims, &pszNextInfId);
                 pszInfId && *pszInfId;
                 pszInfId = GetNextStringToken (NULL, szDelims, &pszNextInfId))
            {
                if (IOR_INSTALL == Action)
                {
                    NETWORK_INSTALL_PARAMS nip;
                    COMPONENT_INSTALL_PARAMS Params;

                    ZeroMemory (&Params, sizeof(Params));

                    // Get the Class corresponding to the INF ID.
                    //
                    m_hr = HrCiGetClassAndInfFileOfInfId (
                            pszInfId, &Params.Class, szInfFile);
                    if (S_OK != m_hr)
                    {
                        break;
                    }

                    //$REVIEW:Should we stick the filename in the
                    // COMPONENT_INSTALL_PARAMS so that we don't grovel
                    // the INF directory to find it again?
                    // If so, store the filename buffer in the modify
                    // context so we don't take up stack space or heap space.
                    // Just need to be sure that we use it to install the
                    // component before we recurse and overwrite it.

                    // Pack the network install parameters and call the common
                    // function.
                    //
                    //$REVIEW: we probably need dwSetupFlags and dwUpgradeFromBuildNo
                    // in the modify context saved when it was called at
                    // recursion depth 0.  Otherwise, things installed here
                    // during GUI setup will have wrong parameters.
                    //
                    nip.dwSetupFlags         = 0;
                    nip.dwUpgradeFromBuildNo = 0;
                    nip.pszAnswerFile        = NULL;
                    nip.pszAnswerSection     = NULL;

                    // Setup the component install parameters.
                    //
                    Params.pszInfId   = pszInfId;
                    Params.pszInfFile = szInfFile;
                    Params.pOboToken  = FIsEnumerated (Params.Class)
                                            ? NULL : &OboToken;
                    Params.pnip       = &nip;

                    //
                    // THIS MAY CAUSE RECURSION
                    //
                    // (just using pComponentToRemove as a placeholder
                    // for a required parameter.)
                    //
                    HrInstallNewOrReferenceExistingComponent (
                        Params, &pComponentToRemove);
                    if (S_OK != m_hr)
                    {
                        break;
                    }
                }
                else
                {
                    Assert (IOR_REMOVE == Action);

                    // Search for the component to remove using its INF ID.
                    //
                    pComponentToRemove = pNetConfig->Core.Components.
                                    PFindComponentByInfId (pszInfId, NULL);

                    if (pComponentToRemove)
                    {
                        //
                        // THIS MAY CAUSE RECURSION
                        //
                        HrRemoveComponentIfNotReferenced (
                            pComponentToRemove,
                            FIsEnumerated (pComponentToRemove->Class())
                                    ? NULL
                                    : &OboToken,
                            NULL);
                        if (S_OK != m_hr)
                        {
                            break;
                        }
                    }
                }
            }

            ReleaseObj (pIComp);
        }

        MemFree (pszRequiredList);
    }
}

//----------------------------------------------------------------------------
// Update a component.  Do this by generating the bindings which involve
// the component and noting them as 'OldBindPaths'.  The stack entries which
// involve the component are removed and re-generated and the bindings which
// involve the component are again noted as 'NewBindPaths'.  The old bindings
// are compared to the new bindings and the differences are notified to
// notify objects as either being removed or added.  For any removed bindings,
// we also remove them from the core's disabled set if they happen to exist
// there too.
//
// Assumptions:
//  The INF for pComponent has already been re-run so that the potentially
//  new values for UpperRange, LowerRange, etc. are present in the registry.
//
//  pComponent has had its external data loaded already.
//
HRESULT
CModifyContext::HrUpdateComponent (
    IN CComponent* pComponent,
    IN DWORD dwSetupFlags,
    IN DWORD dwUpgradeFromBuildNo)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    CNetConfig* pNetConfig;
    CBindingSet OldBindPaths;
    CBindingSet NewBindPaths;
    CBindPath* pScan;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (pComponent);

    pNetConfig = PNetConfig();

    // Now that we actually are going to modify something, push a new
    // recursion depth.
    //
    PushRecursionDepth();
    Assert (S_OK == m_hr);

    // Generate the "old" bindings by noting those which involve the
    // component.
    //
    hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                pComponent,
                GBF_ONLY_WHICH_CONTAIN_COMPONENT,
                &OldBindPaths);
    if (S_OK != hr)
    {
        goto finished;
    }

    // Reload the external data so we pickup what the possibly updated
    // INF has changed.
    //
    hr = pComponent->Ext.HrReloadExternalData ();

    if (S_OK != hr)
    {
        goto finished;
    }

    // Update the stack table entries for the component.
    //

    hr = pNetConfig->Core.StackTable.HrUpdateEntriesForComponent (
                pComponent,
                &pNetConfig->Core.Components,
                INS_SORTED);
    if (S_OK != hr)
    {
        // This is not good.  We ripped out the stack entries and failed
        // putting them back in.  The stack table now has no entries for
        // this component.  Prevent this from being applied by setting the
        // modify context's HRESULT to the error.
        //
        m_hr = hr;
        goto finished;
    }

    // Generate the "new" bindings by noting those which involve the
    // component.
    //
    hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                pComponent,
                GBF_ONLY_WHICH_CONTAIN_COMPONENT,
                &NewBindPaths);
    if (S_OK != hr)
    {
        // Probably out of memory.  Prevent apply by setting the modify
        // context's HRESULT to the error.
        //
        m_hr = hr;
        goto finished;
    }

    // Notify any bindpaths which have been removed.
    //
    for (pScan  = OldBindPaths.begin();
         pScan != OldBindPaths.end();
         pScan++)
    {
        if (NewBindPaths.FContainsBindPath (pScan))
        {
            continue;
        }

        m_DeletedBindPaths.HrAddBindPath (pScan, INS_IGNORE_IF_DUP | INS_APPEND);
        pNetConfig->Core.DisabledBindings.RemoveBindPath (pScan);
        pNetConfig->Notify.NotifyBindPath (NCN_REMOVE, pScan, NULL);
    }

    // Notify any bindpaths which have been added.
    //
    for (pScan  = NewBindPaths.begin();
         pScan != NewBindPaths.end();
         pScan++)
    {
        if (OldBindPaths.FContainsBindPath (pScan))
        {
            continue;
        }

        m_AddedBindPaths.HrAddBindPath (pScan, INS_IGNORE_IF_DUP | INS_APPEND);
        pNetConfig->Notify.NotifyBindPath (NCN_ADD | NCN_ENABLE, pScan, NULL);
    }

    // Notify that the component has been updated.
    //
    pNetConfig->Notify.ComponentUpdated (pComponent,
                    dwSetupFlags,
                    dwUpgradeFromBuildNo);

finished:

    hr = HrPopRecursionDepth();

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrUpdateComponent (%S)",
        pComponent->PszGetPnpIdOrInfId());
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ncwins.cpp ===
//
// File:    ncwins.cpp
//
// Purpose: Manage the creation and maintanence of the Winsock service.
//
// Entry Point:
//          HrAddOrRemoveWinsockDependancy
//
// Changes: 18-Mar-97 Created scottbri
//
#include "pch.h"
#pragma hdrstop
#include "nceh.h"
#include "ncxbase.h"
#include "ncinf.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "resource.h"
#include <winsock2.h>
#include <ws2spi.h>

extern "C"
{
#include <wsasetup.h>
}

extern const WCHAR c_szBackslash[];
extern const WCHAR c_szParameters[];

static const WCHAR c_szWinsockName[]        = L"Winsock";
static const WCHAR c_szLibraryName[]        = L"LibraryPath";
static const WCHAR c_szDisplayString[]      = L"DisplayString";
static const WCHAR c_szSupportedNameSpace[] = L"SupportedNameSpace";
static const WCHAR c_szProviderId[]         = L"ProviderId";
static const WCHAR c_szVersion[]            = L"Version";
static const WCHAR c_szTransportService[]   = L"TransportService";
static const WCHAR c_szHelperDllName[]      = L"HelperDllName";
static const WCHAR c_szMaxSockAddrLength[]  = L"MaxSockAddrLength";
static const WCHAR c_szMinSockAddrLength[]  = L"MinSockAddrLength";
static const WCHAR c_szWinsockMapping[]     = L"Mapping";
static const WCHAR c_szErrorControl[]       = L"ErrorControl";
static const WCHAR c_szStartType[]          = L"Start";
static const WCHAR c_szServiceType[]        = L"Type";
static const WCHAR c_szTransports[]         = L"Transports";
static const WCHAR c_szAFDServiceName[]     = L"AFD";
static const WCHAR c_szTDI[]                = L"TDI";
static const WCHAR c_szAddSecLabel[]        = L"AddSock";
static const WCHAR c_szRemoveSecLabel[]     = L"DelSock";
static const WCHAR c_szServices[]           = L"System\\CurrentControlSet\\Services";
static const WCHAR c_szAfdSrvImagePath[]    = L"\\SystemRoot\\System32\\drivers\\afd.sys";

typedef struct {
    PCWSTR      pszVal;
    DWORD       dwData;
} WRITEREGDW;

// Begin - Stolen from nt\private\inc\wsahelp.h
// Not exposed in public sdk header files, only documented in MSDN
// so the structure is unlikely to change
typedef struct _WINSOCK_MAPPING {
    DWORD Rows;
    DWORD Columns;
    struct {
        DWORD AddressFamily;
        DWORD SocketType;
        DWORD Protocol;
    } Mapping[1];
} WINSOCK_MAPPING, *PWINSOCK_MAPPING;

typedef
DWORD
(WINAPI * PWSH_GET_WINSOCK_MAPPING) (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    );

DWORD
WINAPI
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    );
// End - Stolen from nt\private\inc\wsahelp.h


HRESULT HrRunWinsock2Migration()
{
    HRESULT hr;

    NC_TRY
    {
        WSA_SETUP_DISPOSITION Disposition;
        DWORD dwErr = MigrateWinsockConfiguration (&Disposition, NULL, 0);
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrRunWinsock2Migration");
    return hr;
}

//
// Function:    HrRemoveNameSpaceProvider
//
// Purpose:     Remove a Winsock namespace
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrRemoveNameSpaceProvider (
    const GUID *pguidProvider)
{
    DWORD dwErr;

    // Ignore any WSAEINVAL error.  It occurs when the name space provider was
    // already removed.
    //
    dwErr = WSCUnInstallNameSpace((GUID *)pguidProvider);
    if ((0 != dwErr) && (WSAEINVAL != GetLastError()))
    {
        TraceError("HrRemoveNameSpaceProvider", HrFromLastWin32Error());
        return HrFromLastWin32Error();
    }

#ifdef _WIN64
    // Uninstall 32 bit name space as well.
    //
    dwErr = WSCUnInstallNameSpace32((GUID *)pguidProvider);
    if ((0 != dwErr) && (WSAEINVAL != GetLastError()))
    {
        TraceError("HrRemoveNameSpaceProvider", HrFromLastWin32Error());
        return HrFromLastWin32Error();
    }
#endif
    return S_OK;
}

//
// Function:    HrAddNameSpaceProvider
//
// Purpose:     Create a Winsock namespace
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrAddNameSpaceProvider (
    PCWSTR pszDisplayName,
    PCWSTR pszPathDLLName,
    DWORD  dwNameSpace,
    BOOL   fSchemaSupport,
    const GUID * pguidProvider)
{
    // Call the Winsock API to create a namespace
    if (WSCInstallNameSpace((PWSTR)pszDisplayName, (PWSTR)pszPathDLLName,
                                dwNameSpace, fSchemaSupport,
                                (GUID *)pguidProvider))
    {
        // They namespace provider may already be registered
        TraceTag(ttidNetcfgBase, "HrAddNameSpaceProvider - "
            "Name space provider may already be registered.");
        TraceTag(ttidNetcfgBase, "HrAddNameSpaceProvider - "
            "Trying to unregister and then re-register.");

        // Try unregistering it, and then give one more try at registering it.
        HrRemoveNameSpaceProvider(pguidProvider);

        if (WSCInstallNameSpace((PWSTR)pszDisplayName, (PWSTR)pszPathDLLName,
                                dwNameSpace, fSchemaSupport,
                                (GUID *)pguidProvider))
        {
            TraceError("HrAddNameSpaceProvider - Second attempt failed, returning error", HrFromLastWin32Error());
            return HrFromLastWin32Error();
        }
    }

#ifdef _WIN64
    // Call the Winsock API to create a 32 namespace
    if (WSCInstallNameSpace32((PWSTR)pszDisplayName, (PWSTR)pszPathDLLName,
                                dwNameSpace, fSchemaSupport,
                                (GUID *)pguidProvider))
    {
        // They namespace provider may already be registered
        TraceTag(ttidNetcfgBase, "HrAddNameSpaceProvider - "
            "32 bit Name space provider may already be registered.");
        TraceTag(ttidNetcfgBase, "HrAddNameSpaceProvider - "
            "Trying to unregister and then re-register 32 bit name space.");

        // Try unregistering it, and then give one more try at registering it.
        // Use direct call to ws2_32 to avoid unregistering 64 bit provider.
        WSCUnInstallNameSpace32((GUID *)pguidProvider);

        if (WSCInstallNameSpace32((PWSTR)pszDisplayName, (PWSTR)pszPathDLLName,
                                dwNameSpace, fSchemaSupport,
                                (GUID *)pguidProvider))
        {
            TraceError("HrAddNameSpaceProvider - Second attempt failed (32 bit), returning error", HrFromLastWin32Error());
            return HrFromLastWin32Error();
        }
    }
#endif

    return S_OK;
}

//
// Function:    HrInstallWinsock
//
// Purpose:     Copy winsock and afd related files, and setup the appropriate
//              registry values
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK if afd and winsock are installed successfully
//
HRESULT HrInstallWinsock()
{
    DWORD           dwDisposition;
    HKEY            hkeyParameters = NULL;
    HKEY            hkeyWinsock = NULL;
    HRESULT         hr;
    INT             i;
    WRITEREGDW      regdata[3];
    tstring         strBuf;
    CService        srvc;
    CServiceManager sm;

    hr = sm.HrCreateService( &srvc, c_szAFDServiceName,
                             SzLoadIds(IDS_NETCFG_AFD_SERVICE_DESC),
                             0x1, 0x2, 0x1, c_szAfdSrvImagePath,
                             NULL, c_szTDI, NULL, SERVICE_ALL_ACCESS,
                             NULL, NULL, NULL);
    if (SUCCEEDED(hr))
    {
        // For VadimE, start AFD as soon as it is installed
        //
        (VOID)sm.HrStartServiceNoWait(c_szAFDServiceName);

        srvc.Close();
    }

    // Close the service control manager.
    sm.Close();

    if (FAILED(hr) && (HRESULT_FROM_WIN32 (ERROR_SERVICE_EXISTS) != hr))
    {
        goto Done;
    }

    // Create/Open the Services\Winsock key
    strBuf = c_szServices;
    strBuf += c_szBackslash;
    strBuf += c_szWinsockName;
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, strBuf.c_str(),
                            REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                            &hkeyWinsock, &dwDisposition);
    if (S_OK != hr)
    {
        goto Done;
    }

    // Create/Open the Services\Winsock\Parameters key
    strBuf += c_szBackslash;
    strBuf += c_szParameters;
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, strBuf.c_str(),
                            REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                            &hkeyParameters, &dwDisposition);
    if (S_OK != hr)
    {
        goto Done;
    }

    // Populate the Winsock key
    regdata[0].pszVal  = c_szErrorControl;
    regdata[0].dwData = 0x1;                // ErrorControl
    regdata[1].pszVal  = c_szStartType;
    regdata[1].dwData = 0x3;                // Start Type
    regdata[2].pszVal  = c_szServiceType;
    regdata[2].dwData = 0x4;                // Service Type

    // Write the data to the components Winsock subkey
    for (i=0; i<3; i++)
    {
        hr = HrRegSetDword(hkeyWinsock, regdata[i].pszVal, regdata[i].dwData);
        if (S_OK != hr)
        {
            goto Done;
        }
    }

Done:
    TraceError("HrInstallWinsock",hr);
    RegSafeCloseKey(hkeyParameters);
    RegSafeCloseKey(hkeyWinsock);
    return hr;
}

//
// Function:    FIsWinsockInstalled
//
// Purpose:     Verify whether winsock is installed
//
// Parameters:  pfInstalled [OUT] - Contains TRUE if Winsock is currently installed
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrIsWinsockInstalled (
    BOOL * pfInstalled)
{
    HRESULT hr;
    HKEY    hkey;
    tstring strBuf;

    strBuf = c_szServices;
    strBuf += c_szBackslash;
    strBuf += c_szWinsockName;
    strBuf += c_szBackslash;
    strBuf += c_szParameters;

    hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE, strBuf.c_str(), KEY_READ,
                           &hkey );
    if (S_OK == hr)
    {
        RegCloseKey(hkey);

        // Now check to make sure AFD is installed
        strBuf = c_szServices;
        strBuf += c_szBackslash;
        strBuf += c_szAFDServiceName;
        hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE, strBuf.c_str(), KEY_READ,
                               &hkey );
        if (S_OK == hr)
        {
            RegCloseKey(hkey);
            *pfInstalled = TRUE;
        }
    }

    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
        *pfInstalled = FALSE;
    }

    TraceError("HrIsWinsockInstalled", hr);
    return hr;
}

//
// Function:    HrUpdateWinsockTransportList
//
// Purpose:     Update the contents of Winsock's Transport property by
//              adding/removing the specified transport
//
// Parameters:  pszTransport [IN] - Name of the transport to add/remove
//              fInstall    [IN] - If TRUE, install, otherwise remove
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrUpdateWinsockTransportList (
    PCWSTR pszTransport,
    BOOL fInstall)
{
    HKEY    hkey = NULL;
    HRESULT hr;
    tstring strBuf;

    strBuf = c_szServices;
    strBuf += c_szBackslash;;
    strBuf += c_szWinsockName;
    strBuf += c_szBackslash;
    strBuf += c_szParameters;

    hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE, strBuf.c_str(),
                           KEY_READ_WRITE, &hkey );
    if (S_OK != hr)
    {
        // Handle registry key not found.  When installing a component with
        // a winsock dependancy an in memory state can exist such that winsock
        // is not literally installed yet (Apply has not been pressed).  If
        // the user removes this added component, the current removal code
        // processes the services removal section, which includes winsock
        // removal.  Since we haven't actually gotten as a far as installing
        // winsock yet accessing the winsock parameters key is not possible.
        // Safely consume the error.
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
        goto Done;
    }

    if (fInstall)
    {
        hr = HrRegAddStringToMultiSz(pszTransport, hkey, NULL, c_szTransports,
                                       STRING_FLAG_ENSURE_AT_END, 0);
    }
    else
    {
        hr = HrRegRemoveStringFromMultiSz(pszTransport, hkey, NULL,
                                            c_szTransports,
                                            STRING_FLAG_REMOVE_ALL);
    }

Done:
    RegSafeCloseKey(hkey);
    TraceError("HrUpdateWinsockTransport", hr);
    return hr;
}

#define WSHWINSOCKMAPPING "WSHGetWinsockMapping"
#define WSH_MAX_MAPPING_DATA 8192

//
// Function:    HrWriteWinsockMapping
//
// Purpose:     To extract the magic binary data from the winsock helper dll.
//              This code was extracted from nt\private\net\ui\ncpa1.1\netcfg\setup.cpp
//
// Parameters:  pszDllName - Name of the Winsock helper DLL
//              hkey - Key where the "Mapping" value is to be written
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrWriteWinsockMapping (
    PCWSTR pszDllName,
    HKEY hkey)
{
    INT                      cb;
    DWORD                    cbMapping;
    HRESULT                  hr;
    HMODULE                  hDll = NULL;
    PWSH_GET_WINSOCK_MAPPING pMapFunc = NULL;
    PWINSOCK_MAPPING         pMapTriples = NULL;
    WCHAR                    tchExpandedName [MAX_PATH+1];

    do  // Pseudo-loop
    {
        pMapTriples = (PWINSOCK_MAPPING) MemAlloc(WSH_MAX_MAPPING_DATA);

        if ( pMapTriples == NULL)
        {
            hr = E_OUTOFMEMORY;
            break ;
        }

        //  Expand any environment strings in the DLL path string.
        cb = ExpandEnvironmentStrings( pszDllName,
                                       tchExpandedName,
                                       MAX_PATH+1 ) ;

        if ( cb == 0 || cb > (MAX_PATH+1) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            break ;
        }

        // Located the mapping function
        hr = HrLoadLibAndGetProc(tchExpandedName, WSHWINSOCKMAPPING, &hDll,
                                 reinterpret_cast<FARPROC*>(&pMapFunc));
        //  Bind to the DLL
        if (FAILED(hr))
        {
            break ;
        }

        //  Call the export to return the mapping table
        cbMapping = (*pMapFunc)( pMapTriples, WSH_MAX_MAPPING_DATA ) ;
        if ( cbMapping > WSH_MAX_MAPPING_DATA )
        {
            hr = E_OUTOFMEMORY;
            break ;
        }

        // Store the mapping info into the Registry
        hr = HrRegSetBinary(hkey, c_szWinsockMapping,
                              (LPBYTE) pMapTriples, cbMapping);
    }
    while (FALSE);

    MemFree(pMapTriples);

    if (hDll)
    {
        FreeLibrary(hDll);
    }

    TraceError("HrWriteWinsockMapping",hr);
    return hr;
}

//
// Function:    HrWriteWinsockInfo
//
// Purpose:     Commit the Winsock information to the component's Winsock
//              section, and also to the Winsock section.
//
// Parameters:  strTransport - Name of the transport to be installed
//              strDllHelper - Name of the Winsock helper dll
//              dwMaxSockAddrLength - ?
//              dwMinSockAddrLength - ?
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrWriteWinsockInfo (
    tstring& strTransport,
    tstring& strDllHelper,
    DWORD dwMaxSockAddrLength,
    DWORD dwMinSockAddrLength)
{
    DWORD      dwDisposition;
    HKEY       hkey;
    HRESULT    hr;
    int        i;
    WRITEREGDW regdata[2];
    tstring    strBuf;

    // Create/Open the component's Winsock Key
    // Verify we don't need an intermediate step to create the key
    strBuf = c_szServices;
    strBuf += c_szBackslash;
    strBuf += strTransport;
    strBuf += c_szBackslash;
    strBuf += c_szParameters;
    strBuf += c_szBackslash;
    strBuf += c_szWinsockName;
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, strBuf.c_str(),
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ_WRITE, NULL, &hkey, &dwDisposition);
    if (S_OK != hr)
    {
        goto Done;
    }

    // Initialize the information to write
    hr = HrRegSetValueEx(hkey, c_szHelperDllName, REG_EXPAND_SZ,
                           (LPBYTE)(LPBYTE)strDllHelper.c_str(),
                           strDllHelper.length() * sizeof(WCHAR));
    if (S_OK != hr)
    {
        goto Done;
    }

    // Initialize the information to write
    regdata[0].pszVal  = c_szMaxSockAddrLength;
    regdata[0].dwData = dwMaxSockAddrLength;
    regdata[1].pszVal  = c_szMinSockAddrLength;
    regdata[1].dwData = dwMinSockAddrLength;

    // Write the data to the components Winsock subkey
    for (i=0; i<celems(regdata); i++)
    {
        hr = HrRegSetDword(hkey, regdata[i].pszVal, regdata[i].dwData);
        if (S_OK != hr)
        {
            goto Done;
        }
    }


    // Write the Winsock DLL Mapping information
    hr = HrWriteWinsockMapping(strDllHelper.c_str(), hkey);
    if (S_OK != hr)
    {
        goto Done;
    }

    // Update the Winsock transport list
    hr = HrUpdateWinsockTransportList(strTransport.c_str(), TRUE);

Done:
    RegSafeCloseKey(hkey);
    TraceError("HrWriteWinsockInfo",hr);
    return hr;
}

//
// Function:    HrInstallWinsockDependancy
//
// Purpose:     Examine the current components .inf file and determine whether
//              or not a winsock dependancy exists.  If the current component
//              requires interaction with Winsock, this code will first verify
//              if Winsock is already installed.  If it is not, then both the
//              Winsock and afd services will be installed via a call to the
//              function FInstallWinsock.  Once that is accomplished, the code
//              will update Winsock to be aware of this component and will
//              write Winsock specific info to this components Services
//              registry section via the function FWriteWinsockInfo.  If the
//              current component does not have a Winsock dependancy no action
//              is taken.
//
// Parameters:  hinfInstallFile [IN] - Handle to the current component's
//                                     .inf file.
//              szSectionName   [IN] - The name of the install/remove section
//
// Returns:     HRESULT, S_OK if the component had a Winsock dependancy and
//              the registry was updated successfully with the information.
//
HRESULT
HrInstallWinsockDependancy (
    HINF hinfInstallFile,
    PCWSTR pszSectionName)
{
    DWORD       dwMaxSockAddrLength;
    DWORD       dwMinSockAddrLength;
    DWORD       dwSupportedNameSpace;
    DWORD       dwVersion = 1;
    tstring     strDllHelper;
    tstring     strTransport;
    tstring     strLibraryPath;
    tstring     strDisplayString;
    tstring     strProviderId;
    BOOL        fSuccess = FALSE;
    BOOL        fWinsockInstalled;
    BOOL        fWinsockInfoComplete = FALSE;
    BOOL        fNamespaceInfoComplete = FALSE;
    HRESULT     hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );

    // Search for the "TransportService" property.
    hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                             c_szTransportService, &strTransport);
    if (S_OK == hr)
    {
        // Retrieve the path to the helper DLL
        hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                                     c_szHelperDllName, &strDllHelper);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve the MaxSockAddrLength
        hr = HrSetupGetFirstDword(hinfInstallFile, pszSectionName,
                                c_szMaxSockAddrLength, &dwMaxSockAddrLength);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve the MinSockAddrLength
        hr = HrSetupGetFirstDword(hinfInstallFile, pszSectionName,
                              c_szMinSockAddrLength, &dwMinSockAddrLength);
        if (FAILED(hr))
        {
            goto Error;
        }

        fWinsockInfoComplete = TRUE;
    }
    else if ((SPAPI_E_SECTION_NOT_FOUND != hr) && (SPAPI_E_LINE_NOT_FOUND != hr))
    {
        goto Error;
    }

    // Retrieve the Provider ID, if not present then don't registry a
    // namespace provider
    hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                             c_szProviderId, &strProviderId);
    if (S_OK == hr)
    {
        // Retrieve the path to Library
        hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                                 c_szLibraryName, &strLibraryPath);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve the transport providers display string
        hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                                 c_szDisplayString, &strDisplayString);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve the ID of the supported namespace
        hr = HrSetupGetFirstDword(hinfInstallFile, pszSectionName,
                              c_szSupportedNameSpace, &dwSupportedNameSpace);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve Version (optional, defaults to 1)
        (VOID)HrSetupGetFirstDword(hinfInstallFile, pszSectionName,
                                c_szVersion, &dwVersion);

        fNamespaceInfoComplete = TRUE;
    }
    else if ((SPAPI_E_SECTION_NOT_FOUND != hr) && (SPAPI_E_LINE_NOT_FOUND != hr))
    {
        goto Error;
    }

    // Check for Winsock installation (if required)
    if (fWinsockInfoComplete || fNamespaceInfoComplete)
    {
        // Check if winsock is installed
        hr = HrIsWinsockInstalled(&fWinsockInstalled);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Is Winsock already installed?  If not, install
        // the bloke...
        if (!fWinsockInstalled)
        {
            hr = HrInstallWinsock();
            if (FAILED(hr))
            {
                goto Error;
            }
        }
    }

    // Write the data we've collect to the correct
    // spots in the registry
    if (fWinsockInfoComplete)
    {
        hr = HrWriteWinsockInfo(strTransport, strDllHelper,
                                dwMaxSockAddrLength, dwMinSockAddrLength);
        if (FAILED(hr))
        {
            goto Error;
        }
    }

    // Write the namespace provider information if we read the namespace
    // provider information
    if (fNamespaceInfoComplete)
    {
        IID guid;

        hr = IIDFromString((PWSTR)strProviderId.c_str(), &guid);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrAddNameSpaceProvider(strDisplayString.c_str(),
                                      strLibraryPath.c_str(),
                                      dwSupportedNameSpace,
                                      dwVersion,
                                      &guid);
        if (FAILED(hr))
        {
            goto Error;
        }
    }

    if (fWinsockInfoComplete || fNamespaceInfoComplete)
    {
        (void)HrRunWinsock2Migration();
    }

Error:
    TraceError("HrInstallWinsockDependancy",hr);
    return hr;
}

//
// Function:    HrRemoveWinsockDependancy
//
// Purpose:     Remove the current component from the Winsock
//              transport list, if present.
//
// Parameters:  hinfInstallFile [IN] - Handle to the current component's
//                                     .inf file.
//              pszSectionName   [IN] - The name of the install/remove section
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrRemoveWinsockDependancy(HINF hinfInstallFile,
                                  PCWSTR pszSectionName)
{
    HRESULT     hr;
    tstring     str;
    tstring     strTransport;
    BOOL        fRunWinsockMigration = FALSE;

    // Search for the "TransportService" property
    hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                             c_szTransportService, &strTransport);
    if (S_OK == hr)
    {
        HKEY        hkey;

        // Remove the Transport from the Winsock transport list
        hr = HrUpdateWinsockTransportList(strTransport.c_str(), FALSE);
        if (FAILED(hr))
        {
            goto Error;
        }

        fRunWinsockMigration = TRUE;

        // Remove the Winsock subkey under the specified transport
        // But ignore failures, as we're just trying to be tidy
        str = c_szServices;
        str += c_szBackslash;
        str += strTransport.c_str();
        str += c_szBackslash;
        str += c_szParameters;
        if (S_OK == HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, str.c_str(),
                                   KEY_READ_WRITE_DELETE, &hkey))
        {
            HrRegDeleteKeyTree(hkey, c_szWinsockName);
            RegCloseKey(hkey);
        }
    }
    else if ((SPAPI_E_SECTION_NOT_FOUND != hr) && (SPAPI_E_LINE_NOT_FOUND != hr))
    {
        goto Error;
    }

    // Remove the Winsock Namespace provider
    hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                             c_szProviderId, &str);
    if (S_OK == hr)
    {
        IID guid;

        hr = IIDFromString((PWSTR)str.c_str(), &guid);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Don't fail, the name space may not have been successfully registered.
        // Especially if the component installation failed.
        HrRemoveNameSpaceProvider(&guid);

        fRunWinsockMigration = TRUE;
    }
    else if ((SPAPI_E_SECTION_NOT_FOUND != hr) && (SPAPI_E_LINE_NOT_FOUND != hr))
    {
        goto Error;
    }

    if (fRunWinsockMigration)
    {
        (void)HrRunWinsock2Migration();
    }

    hr = S_OK;      // Normalize return

Error:
    TraceError("HrRemoveWinsockDependancy",hr);
    return hr;
}


//
// Function:    HrAddOrRemoveWinsockDependancy
//
// Purpose:     To add or remove Winsock dependancies for components
//
// Parameters:  hinfInstallFile [IN] - The handle to the inf file to install
//                                      from
//              pszSectionName  [IN] - The Base install section name.
//                                    (The prefix for the .Services section)
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrAddOrRemoveWinsockDependancy (
    HINF hinfInstallFile,
    PCWSTR pszSectionName)
{
    Assert(IsValidHandle(hinfInstallFile));

    HRESULT     hr;

    hr = HrProcessInfExtension(hinfInstallFile, pszSectionName,
                               c_szWinsockName, c_szAddSecLabel,
                               c_szRemoveSecLabel, HrInstallWinsockDependancy,
                               HrRemoveWinsockDependancy);

    if (SPAPI_E_LINE_NOT_FOUND == hr)
    {
        // .Winsock section is not required
        hr = S_OK;
    }

    TraceError("HrAddOrRemoveWinsockDependancy",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\ncwins.h ===
//
// File:    ncwins.h
//
// Purpose: Declare and define public constants and entry-points
//          for use in configuring Winsock dependancies.
//
// Author:  27-Mar-97 created scottbri
//
#pragma once

//
// Function:    HrAddOrRemoveWinsockDependancy
//
// Purpose:     To add or remove Winsock dependancies for components
//
// Parameters:  nccObject      [IN] - Current configuration object
//              pszSectionName [IN] - The Base install section name.
//                                    (The prefix for the .Services section)
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrAddOrRemoveWinsockDependancy(
    HINF hinfInstallFile,
    PCWSTR pszSectionName);


HRESULT
HrRunWinsock2Migration(
    VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\notify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N O T I F Y . C P P
//
//  Contents:   Implements the interface to a component's optional notify
//              object.  The object defined here is meant to be a member
//              of CComponent.  This object encapsulates all of its internal
//              data in a separate allocation made only if the component
//              actually has a notify object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "diagctx.h"
#include "ibind.h"
#include "inetcfg.h"
#include "nceh.h"
#include "ncmisc.h"
#include "ncprsht.h"
#include "netcfg.h"
#include "notify.h"


//+---------------------------------------------------------------------------
// CNotifyObjectInterface -
//

HRESULT
CNotifyObjectInterface::HrEnsureNotifyObjectInitialized (
    IN CImplINetCfg* pINetCfg,
    IN BOOL fInstalling)
{
    Assert (pINetCfg);

    // If we've already been through initialization, return immediately.
    //
    if (m_fInitialized)
    {
        return S_OK;
    }

    // Only perform initialization once, regardless of whether it succeeds
    // or not.
    //
    m_fInitialized = TRUE;

    // Get our containing component pointer so we can ask it what the
    // CLSID for the notify object is.  (If it has one.)
    //
    CComponent* pThis;
    pThis = CONTAINING_RECORD (this, CComponent, Notify);

    // Don't bother if we can't have a notify object.  Bailing here saves
    // uneccesarily loading the external data for netclass components only
    // to find that they won't have a notify object below.
    //
    if (FIsEnumerated (pThis->Class()))
    {
        return S_OK;
    }

    HRESULT hrRet;

    // Since the notify object clsid is part of the components external data,
    // we have to make sure we've loaded this data.
    //
    hrRet = pThis->Ext.HrEnsureExternalDataLoaded ();
    if (S_OK != hrRet)
    {
        goto finished;
    }

    // Don't bother if we don't have a notify object.
    //
    if (!pThis->Ext.FHasNotifyObject())
    {
        return S_OK;
    }

    // The component claims to have a notify object.  Let's CoCreate it
    // and see what we get.
    //
    HRESULT hr;
    INetCfgComponentControl* pCc;

    hr = pINetCfg->HrCoCreateWrapper (
            *(pThis->Ext.PNotifyObjectClsid()),
            NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_INetCfgComponentControl,
            (PVOID*)&pCc);

    if (S_OK == hr)
    {
        // So far so good.  The notify object implements the required
        // INetCfgComponentControl interface.
        //
        // We now must get the INetCfgComponent interface that we'll
        // pass to the notify object during Initialize below.
        //
        INetCfgComponent* pIComp;
        hrRet = pThis->HrGetINetCfgComponentInterface (pINetCfg, &pIComp);
        if (S_OK == hrRet)
        {
            // Allocate space for the various notify interfaces and QI for
            // them.
            //
            hrRet = E_OUTOFMEMORY;
            m_pNod = (NOTIFY_OBJECT_DATA*) MemAlloc (sizeof(NOTIFY_OBJECT_DATA));
            if (m_pNod)
            {
                hrRet = S_OK;
                ZeroMemory (m_pNod, sizeof(NOTIFY_OBJECT_DATA));

                AddRefObj (pCc);
                m_pNod->pCc = pCc;

                pCc->QueryInterface (IID_INetCfgComponentNotifyBinding,
                        (PVOID*)&m_pNod->pNb);

                pCc->QueryInterface (IID_INetCfgComponentPropertyUi,
                        (PVOID*)&m_pNod->pCp);

                pCc->QueryInterface (IID_INetCfgComponentSetup,
                        (PVOID*)&m_pNod->pCs);

                pCc->QueryInterface (IID_INetCfgComponentUpperEdge,
                        (PVOID*)&m_pNod->pUe);

                pCc->QueryInterface (IID_INetCfgComponentNotifyGlobal,
                        (PVOID*)&m_pNod->pNg);
                if (m_pNod->pNg)
                {
                    // Since it supports INetCfgComponentNotifyGlobal,
                    // get the mask that indicates which global notifications
                    // it is interested in.
                    //
                    hr = m_pNod->pNg->GetSupportedNotifications(
                            &m_pNod->dwNotifyGlobalFlags);
                    if (FAILED(hr))
                    {
                        m_pNod->dwNotifyGlobalFlags = 0;
                    }
                }

                // We now need to initialize the notify object and indicate
                // if we are installing its component or not.
                //
                pINetCfg->RaiseRpl (RPL_DISALLOW);
                    NC_TRY
                    {
                        Assert (pIComp);
                        Assert (pINetCfg);
                        (VOID) pCc->Initialize (pIComp, pINetCfg, fInstalling);
                    }
                    NC_CATCH_ALL
                    {
                        ;   // ignored
                    }
                pINetCfg->LowerRpl (RPL_DISALLOW);
            }

            ReleaseObj (pIComp);
        }

        ReleaseObj (pCc);
    }

finished:
    TraceHr (ttidError, FAL, hrRet, FALSE,
        "CNotifyObjectInterface::HrEnsureNotifyObjectInitialized");
    return hrRet;
}

VOID
CNotifyObjectInterface::ApplyPnpChanges (
    IN CImplINetCfg* pINetCfg,
    OUT BOOL* pfNeedReboot) const
{
    HRESULT hr;

    Assert (pINetCfg);
    Assert (pfNeedReboot);
    Assert (m_fInitialized);

    *pfNeedReboot = FALSE;

    if (!m_pNod)
    {
        return;
    }

    Assert (m_pNod->pCc);

    CComponent* pThis;
    pThis = CONTAINING_RECORD (this, CComponent, Notify);

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            g_pDiagCtx->Printf (ttidBeDiag,
                "      calling %S->ApplyPnpChanges\n",
                pThis->m_pszInfId);

            hr = m_pNod->pCc->ApplyPnpChanges (pINetCfg);

            if (FAILED(hr) || (NETCFG_S_REBOOT == hr))
            {
                *pfNeedReboot = TRUE;
            }
        }
        NC_CATCH_ALL
        {
            *pfNeedReboot = TRUE;
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);
}

VOID
CNotifyObjectInterface::ApplyRegistryChanges (
    IN CImplINetCfg* pINetCfg,
    OUT BOOL* pfNeedReboot) const
{
    HRESULT hr;

    Assert (pINetCfg);
    Assert (pfNeedReboot);
    Assert (m_fInitialized);

    *pfNeedReboot = FALSE;

    if (!m_pNod)
    {
        return;
    }

    Assert (m_pNod->pCc);

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            hr = m_pNod->pCc->ApplyRegistryChanges ();

            if (FAILED(hr) || (NETCFG_S_REBOOT == hr))
            {
                *pfNeedReboot = TRUE;
            }
        }
        NC_CATCH_ALL
        {
            *pfNeedReboot = TRUE;
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);
}

HRESULT
CNotifyObjectInterface::HrGetInterfaceIdsForAdapter (
    IN CImplINetCfg* pINetCfg,
    IN const CComponent* pAdapter,
    OUT DWORD* pcInterfaces,
    OUT GUID** ppguidInterfaceIds) const
{
    HRESULT hr;

    Assert (pAdapter);
    Assert (pcInterfaces);

    Assert (m_fInitialized);

    *pcInterfaces = 0;
    if (ppguidInterfaceIds)
    {
        *ppguidInterfaceIds = NULL;
    }

    if (!m_pNod || !m_pNod->pUe)
    {
        return S_FALSE;
    }

    Assert (pAdapter->GetINetCfgComponentInterface());

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            hr = m_pNod->pUe->GetInterfaceIdsForAdapter (
                    pAdapter->GetINetCfgComponentInterface(),
                    pcInterfaces, ppguidInterfaceIds);

            if (S_FALSE == hr)
            {
                *pcInterfaces = 0;
                if (ppguidInterfaceIds)
                {
                    *ppguidInterfaceIds = NULL;
                }
            }
        }
        NC_CATCH_ALL
        {
            ;   // ignored
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CNotifyObjectInterface::HrGetInterfaceIdsForAdapter");
    return hr;
}

HRESULT
CNotifyObjectInterface::HrQueryPropertyUi (
    IN CImplINetCfg* pINetCfg,
    IN IUnknown* punkContext OPTIONAL)
{
    HRESULT hr;
    CComponent* pThis;

    Assert (this);
    Assert (pINetCfg);
    Assert (m_fInitialized);

    if (!m_pNod || !m_pNod->pCp)
    {
        return S_FALSE;
    }

    pThis = CONTAINING_RECORD (this, CComponent, Notify);
    Assert (pThis);

    if (!(pThis->m_dwCharacter & NCF_HAS_UI))
    {
        return S_FALSE;
    }

    hr = S_OK;

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            Assert (m_pNod && m_pNod->pCp);

            hr = m_pNod->pCp->QueryPropertyUi (punkContext);
        }
        NC_CATCH_ALL
        {
            hr = E_UNEXPECTED;
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNotifyObjectInterface::HrQueryPropertyUi");
    return hr;
}

HRESULT
CNotifyObjectInterface::HrShowPropertyUi (
    IN CImplINetCfg* pINetCfg,
    IN HWND hwndParent,
    IN IUnknown* punkContext OPTIONAL)
{
    HRESULT hr;
    DWORD cDefPages;
    UINT cPages;
    HPROPSHEETPAGE* ahpsp;
    PCWSTR pszStartPage;

    Assert (this);
    Assert (pINetCfg);
    Assert (m_fInitialized);

    if (!m_pNod || !m_pNod->pCp)
    {
        return E_NOINTERFACE;
    }

    Assert (m_pNod && m_pNod->pCp);

    // If given a context, let the notify object know what it is.
    //
    if (punkContext)
    {
        SetUiContext (pINetCfg, punkContext);
    }

    hr = S_OK;
    cDefPages = 0;
    ahpsp = NULL;
    cPages = 0;
    pszStartPage = NULL;

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            hr = m_pNod->pCp->MergePropPages (
                    &cDefPages,
                    (BYTE**)&ahpsp,
                    &cPages,
                    hwndParent,
                    &pszStartPage);
        }
        NC_CATCH_ALL
        {
            hr = E_UNEXPECTED;
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);

    if ((S_OK == hr) && cPages)
    {
        PROPSHEETHEADER psh;
        CAPAGES caPages;
        CAINCP cai;
        CComponent* pThis;

        pThis = CONTAINING_RECORD (this, CComponent, Notify);
        Assert (pThis);

        ZeroMemory(&psh, sizeof(psh));
        ZeroMemory(&caPages, sizeof(caPages));
        ZeroMemory(&cai, sizeof(cai));

        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_PROPTITLE | PSH_NOAPPLYNOW;
        psh.hwndParent = hwndParent;
        psh.hInstance = _Module.GetModuleInstance();
        psh.pszCaption = pThis->Ext.PszDescription();

        caPages.nCount = cPages;
        caPages.ahpsp = ahpsp;

        cai.nCount = 1;
        cai.apncp = &m_pNod->pCp;

        hr = HrNetCfgPropertySheet (&psh, caPages, pszStartPage, cai);

        // S_FALSE is returned if no changes were made.
        //
        if (S_OK == hr)
        {
            if (pINetCfg->m_WriteLock.FIsOwnedByMe ())
            {
                pINetCfg->m_pNetConfig->ModifyCtx.HrBeginBatchOperation ();
            }

            BOOL bCommitNow = FALSE;

            // Call ApplyProperties
            //
            pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);
                NC_TRY
                {
                    hr = m_pNod->pCp->ApplyProperties ();
                    if(NETCFG_S_COMMIT_NOW == hr)
                    {
                        bCommitNow = TRUE;
                    }
                }
                NC_CATCH_ALL
                {
                    hr = E_UNEXPECTED;
                }
            pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);

            if (pINetCfg->m_WriteLock.FIsOwnedByMe ())
            {
                // Set this component as dirty so we call its Apply method
                // if INetCfg is applied.
                //
                hr = pINetCfg->m_pNetConfig->ModifyCtx.HrDirtyComponent(
                        pThis);

                // Notify other components that this component changed.
                //
                pINetCfg->m_pNetConfig->Notify.NgSysNotifyComponent (
                    NCN_PROPERTYCHANGE,
                    pThis);

                hr = pINetCfg->m_pNetConfig->ModifyCtx.
                    HrEndBatchOperation (bCommitNow ? EBO_COMMIT_NOW : EBO_DEFER_COMMIT_UNTIL_APPLY);
            }
        }
        else
        {
            // Don't overwrite hr.  It is what we need to return.
            //
            // Call CancelProperties
            //
            pINetCfg->RaiseRpl (RPL_DISALLOW);
                NC_TRY
                {
                    (VOID) m_pNod->pCp->CancelProperties ();
                }
                NC_CATCH_ALL
                {
                    hr = E_UNEXPECTED;
                }
            pINetCfg->LowerRpl (RPL_DISALLOW);
        }
    }

    // This is outside the above if in case a notify object actually
    // allocates it but returns zero pages.
    //
    CoTaskMemFree (ahpsp);

    // If given a context, let the notify object know it is no longer valid.
    //
    if (punkContext)
    {
        SetUiContext (pINetCfg, NULL);
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr),
        "CNotifyObjectInterface::HrShowPropertyUi");
    return hr;
}

VOID
CNotifyObjectInterface::SetUiContext (
    IN CImplINetCfg* pINetCfg,
    IN IUnknown* punkContext)
{
    Assert (m_fInitialized);
    Assert (m_pNod && m_pNod->pCp);

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            (VOID) m_pNod->pCp->SetContext (punkContext);
        }
        NC_CATCH_ALL
        {
            ;   // ignored
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);
}

VOID
CNotifyObjectInterface::NbQueryOrNotifyBindingPath (
    IN CImplINetCfg* pINetCfg,
    IN QN_FLAG Flag,
    IN DWORD dwChangeFlag,
    IN INetCfgBindingPath* pIPath,
    OUT BOOL* pfDisabled)
{
    RPL_FLAGS RplFlag;

    Assert (pINetCfg);
    Assert ((QN_QUERY == Flag) || (QN_NOTIFY == Flag));
    Assert (pIPath);
    Assert (FImplies(QN_QUERY == Flag, pfDisabled));

    Assert (m_fInitialized);

    if (pfDisabled)
    {
        *pfDisabled = FALSE;
    }

    if (m_pNod && m_pNod->pNb)
    {
        RplFlag = (QN_NOTIFY == Flag) ? RPL_ALLOW_INSTALL_REMOVE
                                      : RPL_DISALLOW;

        pINetCfg->RaiseRpl (RplFlag);
            NC_TRY
            {
                if (QN_QUERY == Flag)
                {
                    HRESULT hr;

                    hr = m_pNod->pNb->QueryBindingPath (dwChangeFlag, pIPath);

                    if (NETCFG_S_DISABLE_QUERY == hr)
                    {
                        *pfDisabled = TRUE;
                    }
                }
                else
                {
                    (VOID) m_pNod->pNb->NotifyBindingPath (dwChangeFlag, pIPath);
                }
            }
            NC_CATCH_ALL
            {
                ;   // ignored
            }
        pINetCfg->LowerRpl (RplFlag);
    }
}

HRESULT
CNotifyObjectInterface::QueryNotifyObject (
    IN CImplINetCfg* pINetCfg,
    IN REFIID riid,
    OUT VOID** ppvObject)
{
    HRESULT hr;

    *ppvObject = NULL;

    hr = HrEnsureNotifyObjectInitialized (pINetCfg, FALSE);
    if (S_OK == hr)
    {
        if (m_pNod && m_pNod->pCc)
        {
            hr = m_pNod->pCc->QueryInterface (riid, ppvObject);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CNotifyObjectInterface::QueryNotifyObject");
    return hr;
}

VOID
CNotifyObjectInterface::ReleaseNotifyObject (
    IN CImplINetCfg* pINetCfg,
    IN BOOL fCancel)
{
    Assert (FIff(pINetCfg, fCancel));

    if (m_pNod)
    {
        // Tell the notify object to cancel if requested.
        //
        if (fCancel)
        {
            pINetCfg->RaiseRpl (RPL_DISALLOW);
                NC_TRY
                {
                    (VOID) m_pNod->pCc->CancelChanges ();
                }
                NC_CATCH_ALL
                {
                    ;   // ignored
                }
            pINetCfg->LowerRpl (RPL_DISALLOW);
        }

        // Release all of the interfaces we are holding.
        //
        ReleaseObj (m_pNod->pCc);
        ReleaseObj (m_pNod->pNb);
        ReleaseObj (m_pNod->pCp);
        ReleaseObj (m_pNod->pCs);
        ReleaseObj (m_pNod->pUe);
        ReleaseObj (m_pNod->pNg);

        MemFree (m_pNod);
        m_pNod = NULL;
    }
    m_fInitialized = FALSE;
}

HRESULT
CNotifyObjectInterface::NewlyAdded (
    IN CImplINetCfg* pINetCfg,
    IN const NETWORK_INSTALL_PARAMS* pnip)
{
    HRESULT hr;

    //$REVIEW: Calling HrEnsureNotifyObjectInitialized is probably not needed
    // because when we have the write lock and call notify objects, we always
    // ensure they are loaded before we get here.
    //
    hr = HrEnsureNotifyObjectInitialized (pINetCfg, TRUE);
    if ((S_OK == hr) && m_pNod && m_pNod->pCs)
    {
        // Inform the notify object that its component is being installed
        // and tell it to read the answerfile if we are using one.
        //
        DWORD dwSetupFlags;

        if (pnip)
        {
            dwSetupFlags = pnip->dwSetupFlags;
        }
        else
        {
            dwSetupFlags = FInSystemSetup() ? NSF_PRIMARYINSTALL
                                            : NSF_POSTSYSINSTALL;
        }

        // Raise the reentrancy protection level to only allow
        // install or remove before calling the notify object's Install
        // method.
        //
        pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);
            NC_TRY
            {
                hr = m_pNod->pCs->Install (dwSetupFlags);

                if (SUCCEEDED(hr) && pnip &&
                    pnip->pszAnswerFile &&
                    pnip->pszAnswerSection)
                {
                    // Raise the reentrancy protection level to disallow
                    // all reentrancy before calling the notify object's
                    // ReadAnswerFile method.
                    //
                    pINetCfg->RaiseRpl (RPL_DISALLOW);
                    NC_TRY
                    {
                        hr = m_pNod->pCs->ReadAnswerFile (
                                pnip->pszAnswerFile,
                                pnip->pszAnswerSection);
                    }
                    NC_FINALLY
                    {
                        pINetCfg->LowerRpl (RPL_DISALLOW);
                    }
                }
            }
            NC_CATCH_ALL
            {
                ;
            }
        pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);

        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNotifyObjectInterface::NewlyAdded");
    return hr;
}

VOID
CNotifyObjectInterface::Removed (
    IN CImplINetCfg* pINetCfg)
{
    Assert (m_fInitialized);

    if (!m_pNod || !m_pNod->pCs)
    {
        return;
    }

    // Raise the reentrancy protection level to only allow
    // install or remove before calling the notify object's Install
    // method.
    //
    pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);
        NC_TRY
        {
            // Inform the notify object that its component is being removed.
            //
            (VOID) m_pNod->pCs->Removing ();
        }
        NC_CATCH_ALL
        {
            ;
        }
    pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);
}

VOID
CNotifyObjectInterface::Updated (
    IN CImplINetCfg* pINetCfg,
    IN DWORD dwSetupFlags,
    IN DWORD dwUpgradeFromBuildNo)
{
    Assert (m_fInitialized);

    if (!m_pNod || !m_pNod->pCs)
    {
        return;
    }

    // Raise the reentrancy protection level to only allow
    // install or remove before calling the notify object's Install
    // method.
    //
    pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);
        NC_TRY
        {
            HRESULT hrNotify;

            // Inform the notify object that its component is being updated.
            //
            hrNotify = m_pNod->pCs->Upgrade (dwSetupFlags,
                    dwUpgradeFromBuildNo);

            // If Upgrade returns S_OK, it means they recognized and
            // handled the event and are now dirty because of it.
            //
            if (S_OK == hrNotify)
            {
                CComponent* pThis;

                pThis = CONTAINING_RECORD (this, CComponent, Notify);
                Assert (pThis);

                (VOID) pINetCfg->m_pNetConfig->ModifyCtx.
                            HrDirtyComponent (pThis);
            }
        }
        NC_CATCH_ALL
        {
            ;
        }
    pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);
}

//+---------------------------------------------------------------------------
// CGlobalNotifyInterface -
//

VOID
CGlobalNotifyInterface::HoldINetCfg (
    CImplINetCfg* pINetCfg)
{
    AssertH (pINetCfg);
    AssertH (!m_pINetCfg);

    AddRefObj (pINetCfg->GetUnknown());
    m_pINetCfg = pINetCfg;
}

VOID
CGlobalNotifyInterface::ReleaseAllNotifyObjects (
    IN CComponentList& Components,
    IN BOOL fCancel)
{
    CComponentList::iterator iter;
    CComponent* pComponent;
    CImplINetCfg* pINetCfg;

    // We need to pass a non-NULL pINetCfg if we are not cancelling.
    //
    pINetCfg = (fCancel) ? m_pINetCfg : NULL;

    for (iter  = Components.begin();
         iter != Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        pComponent->Notify.ReleaseNotifyObject (pINetCfg, fCancel);
    }

    m_fInitialized = FALSE;
}

VOID
CGlobalNotifyInterface::ReleaseINetCfg ()
{
    // If we have a cached INetCfg interface, we need to tell it
    // that we no longer exist.  Then we need to release the interface,
    // of course.
    //
    if (m_pINetCfg)
    {
        // Get our containing CNetConfig pointer.
        //
        CNetConfig* pThis;
        pThis = CONTAINING_RECORD(this, CNetConfig, Notify);

        Assert (pThis == m_pINetCfg->m_pNetConfig);
        m_pINetCfg->m_pNetConfig = NULL;
        ReleaseObj (m_pINetCfg->GetUnknown());
        m_pINetCfg = NULL;
    }
}

HRESULT
CGlobalNotifyInterface::HrEnsureNotifyObjectsInitialized ()
{
    // If we've already been through initialization, return immediately.
    //
    if (m_fInitialized)
    {
        return S_OK;
    }

    // Only perform initialization once, regardless of whether it succeeds
    // or not.
    //
    m_fInitialized = TRUE;

    // Get our containing CNetConfig pointer so we can enumerate all components.
    //
    CNetConfig* pThis;
    pThis = CONTAINING_RECORD(this, CNetConfig, Notify);

    HRESULT hr = S_OK;

    // If we don't have an INetCfg interface pointer yet, it means we are
    // creating one instead of it creating CNetConfig.  If we had one, it
    // would have been handed to us via HoldINetCfg which is called when
    // CNetConfig is created by CImplINetCfg.
    //
    if (!m_pINetCfg)
    {
        hr = CImplINetCfg::HrCreateInstance (pThis, &m_pINetCfg);
        Assert (!m_pINetCfg->m_fOwnNetConfig);
    }

    if (S_OK == hr)
    {
        Assert (m_pINetCfg);

        CComponentList::iterator iter;
        CComponent* pComponent;
        for (iter  = pThis->Core.Components.begin();
             iter != pThis->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            hr = pComponent->Notify.HrEnsureNotifyObjectInitialized (m_pINetCfg, FALSE);
            if (S_OK != hr)
            {
                break;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::HrEnsureNotifyObjectsInitialized");
    return hr;
}

VOID
CGlobalNotifyInterface::NgSysQueryOrNotifyBindingPath (
    IN QN_FLAG Flag,
    IN DWORD dwChangeFlag,
    IN INetCfgBindingPath* pIPath,
    IN BOOL* pfDisabled)
{
    RPL_FLAGS RplFlag;
    CNetConfig* pThis;
    CComponentList::iterator iter;
    CComponent* pComponent;

    Assert (m_pINetCfg);
    Assert ((QN_QUERY == Flag) || (QN_NOTIFY == Flag));
    Assert (pIPath);
    Assert (FImplies(QN_QUERY == Flag, pfDisabled));

    Assert (m_fInitialized);

    if (pfDisabled)
    {
        *pfDisabled = FALSE;
    }

    // Get our containing CNetConfig pointer so we can enumerate
    // all components.
    //
    pThis = CONTAINING_RECORD(this, CNetConfig, Notify);

    RplFlag = (QN_NOTIFY == Flag) ? RPL_ALLOW_INSTALL_REMOVE
                                  : RPL_DISALLOW;

    m_pINetCfg->RaiseRpl (RplFlag);

    for (iter  = pThis->Core.Components.begin();
         iter != pThis->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pComponent->Notify.m_pNod ||
            !pComponent->Notify.m_pNod->pNg ||
            !(pComponent->Notify.m_pNod->dwNotifyGlobalFlags & NCN_BINDING_PATH))
        {
            continue;
        }

        // If the component has not registered for what we are changing,
        // (NCN_ADD, NCN_REMOVE, NCN_ENABLE, NCN_DISABLE) then
        // skip it.
        //
        if (!(pComponent->Notify.m_pNod->dwNotifyGlobalFlags & dwChangeFlag))
        {
            continue;
        }

        NC_TRY
        {
            HRESULT hr;

            if (QN_QUERY == Flag)
            {
                hr = pComponent->Notify.m_pNod->pNg->
                        SysQueryBindingPath (dwChangeFlag, pIPath);

                if (NETCFG_S_DISABLE_QUERY == hr)
                {
                    *pfDisabled = TRUE;
                    break;
                }
            }
            else
            {
                hr = pComponent->Notify.m_pNod->pNg->
                        SysNotifyBindingPath (dwChangeFlag, pIPath);

                // If SysNotifyBindingPath returns S_OK, it means they
                // recognized and handled the event and are now dirty
                // because of it.  Because some notify objects let
                // success codes such as NETCFG_S_REBOOT slip through,
                // consider them dirty if they don't return S_FALSE.
                //
                if (S_FALSE != hr)
                {
                    hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                            HrDirtyComponent(pComponent);
                }
            }
        }
        NC_CATCH_ALL
        {
            ;
        }
    }

    m_pINetCfg->LowerRpl (RplFlag);
}

HRESULT
CGlobalNotifyInterface::NgSysNotifyComponent (
    IN DWORD dwChangeFlag,
    IN CComponent* pComponentOfInterest)
{
    HRESULT hr;
    INetCfgComponent* pICompOfInterest;

    // We should have called HrEnsureNotifyObjectsInitialized by now.
    //
    Assert (m_fInitialized);

    // If the component of interest has not had its data loaded successfully,
    // we shouldn't bother sending the notification.  The notify objects are
    // just going to call back on the interface to the component and fail
    // if they call a method that requires this data.
    //
    if (!pComponentOfInterest->Ext.FLoadedOkayIfLoadedAtAll())
    {
        return S_OK;
    }

    hr = pComponentOfInterest->HrGetINetCfgComponentInterface (
            m_pINetCfg, &pICompOfInterest);

    if (S_OK == hr)
    {
        DWORD dwMask = 0;
        NETCLASS Class = pComponentOfInterest->Class();
        CNetConfig* pThis;
        CComponentList::iterator iter;
        CComponent* pComponent;

        if (FIsConsideredNetClass(Class))
        {
            dwMask = NCN_NET;
        }
        else if (NC_NETTRANS == Class)
        {
            dwMask = NCN_NETTRANS;
        }
        else if (NC_NETCLIENT == Class)
        {
            dwMask = NCN_NETCLIENT;
        }
        else if (NC_NETSERVICE == Class)
        {
            dwMask = NCN_NETSERVICE;
        }

        // Get our containing CNetConfig pointer so we can enumerate
        // all components.
        //
        pThis = CONTAINING_RECORD(this, CNetConfig, Notify);

        // Raise the reentrancy protection level to only allow
        // install or remove before calling the notify object's
        // SysNotifyComponent method.
        //
        m_pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);

        for (iter  = pThis->Core.Components.begin();
             iter != pThis->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            if (!pComponent->Notify.m_pNod ||
                !pComponent->Notify.m_pNod->pNg)
            {
                continue;
            }

            // If the component has not registered for one of NCN_NET,
            // NCN_NETTRANS, etc. then skip it.
            //
            if (!(pComponent->Notify.m_pNod->dwNotifyGlobalFlags & dwMask))
            {
                continue;
            }

            // If the component has not registered for what we are changing,
            // (NCN_ADD, NCN_REMOVE, NCN_UPDATE, NCN_PROPERTYCHANGE) then
            // skip it.
            //
            if (!(pComponent->Notify.m_pNod->dwNotifyGlobalFlags & dwChangeFlag))
            {
                continue;
            }

            NC_TRY
            {
                HRESULT hrNotify;

                hrNotify = pComponent->Notify.m_pNod->pNg->SysNotifyComponent (
                            dwMask | dwChangeFlag,
                            pICompOfInterest);

                // If SysNotifyComponent returns S_OK, it means they
                // recognized and handled the event and are now dirty
                // because of it.  Because some notify objects let
                // success codes such as NETCFG_S_REBOOT slip through,
                // consider them dirty if they don't return S_FALSE.
                //
                if (S_FALSE != hrNotify)
                {
                    hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                            HrDirtyComponent(pComponent);
                }
            }
            NC_CATCH_ALL
            {
                ;
            }
        }

        m_pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);

        ReleaseObj (pICompOfInterest);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::NgSysNotifyComponent");
    return hr;
}

HRESULT
CGlobalNotifyInterface::ComponentAdded (
    IN CComponent* pComponent,
    IN const NETWORK_INSTALL_PARAMS* pnip)
{
    HRESULT hr;

    Assert (pComponent);

    // Initialize the notify object for the component and call
    // its Install method followed by ReadAnswerFile if we are installing
    // with one.
    //
    hr = pComponent->Notify.NewlyAdded (m_pINetCfg, pnip);
    if (S_OK == hr)
    {
        // Notify all notify objects that are interested in component
        // additions.
        //
        hr = NgSysNotifyComponent(NCN_ADD, pComponent);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::ComponentAdded");
    return hr;
}

HRESULT
CGlobalNotifyInterface::ComponentRemoved (
    IN CComponent* pComponent)
{
    HRESULT hr;

    Assert (pComponent);

    pComponent->Notify.Removed (m_pINetCfg);

    hr = NgSysNotifyComponent(NCN_REMOVE, pComponent);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::ComponentRemoved");
    return hr;
}

HRESULT
CGlobalNotifyInterface::ComponentUpdated (
    IN CComponent* pComponent,
    IN DWORD dwSetupFlags,
    IN DWORD dwUpgradeFromBuildNo)
{
    HRESULT hr;

    Assert (pComponent);

    pComponent->Notify.Updated (m_pINetCfg,
            dwSetupFlags, dwUpgradeFromBuildNo);

    hr = NgSysNotifyComponent(NCN_UPDATE, pComponent);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::ComponentUpdated");
    return hr;
}

VOID
CGlobalNotifyInterface::NotifyBindPath (
    IN DWORD dwChangeFlag,
    IN CBindPath* pBindPath,
    IN INetCfgBindingPath* pIPath OPTIONAL)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;
    CComponent* pOwner;
    BOOL fReleasePath;

    Assert (m_fInitialized);
    Assert ((dwChangeFlag & NCN_ADD) ||
            (dwChangeFlag & NCN_REMOVE) ||
            (dwChangeFlag & NCN_ENABLE) ||
            (dwChangeFlag & NCN_DISABLE));
    Assert (FImplies(dwChangeFlag & NCN_REMOVE, !(dwChangeFlag & NCN_DISABLE)));
    Assert (FImplies(dwChangeFlag & NCN_ADD,    !(dwChangeFlag & NCN_REMOVE)));
    Assert (FImplies(dwChangeFlag & NCN_REMOVE, !(dwChangeFlag & NCN_ADD)));
    Assert (pBindPath);

    hr = S_OK;
    pINetCfg = PINetCfg();
    pOwner = pBindPath->POwner();
    fReleasePath = FALSE;

    // Create an INetCfgBindingPath representation of the path for
    // the notify objects if we were not given one.
    //
    if (!pIPath)
    {
        // If the bindpath contains components that have had a problem
        // loading, we shouldn't bother sending the notification.
        // The notify objects are just going to call back on the interface
        // to the component and fail if they call a method that requires
        // this data.
        //
        if (!pBindPath->FAllComponentsLoadedOkayIfLoadedAtAll())
        {
            return;
        }

        hr = CImplINetCfgBindingPath::HrCreateInstance (
                pINetCfg, pBindPath, &pIPath);

        fReleasePath = TRUE;
    }

    if (S_OK == hr)
    {
        Assert (pIPath);

        // If adding...
        //
        if (dwChangeFlag & NCN_ADD)
        {
            BOOL fDisabled;

            fDisabled = FALSE;

            // First, query the owner of the bindpath to see if he wants
            // it disabled.
            //
            pOwner->Notify.NbQueryOrNotifyBindingPath (
                pINetCfg,
                QN_QUERY,
                dwChangeFlag,
                pIPath,
                &fDisabled);

            // If the owner doesn't want it disabled, see if any global
            // notify objects do.
            //
            if (!fDisabled)
            {
                NgSysQueryOrNotifyBindingPath (
                    QN_QUERY,
                    dwChangeFlag,
                    pIPath,
                    &fDisabled);
            }

            // If someone wants it disabled, adjust the change flag
            // for notify and add the bindpath to our disabled list.
            //
            if (fDisabled)
            {
                dwChangeFlag = NCN_ADD | NCN_DISABLE;

                (VOID)pINetCfg->m_pNetConfig->Core.HrDisableBindPath (pBindPath);
            }
        }

        //if (g_pDiagCtx->Flags() & DF_SHOW_CONSOLE_OUTPUT)
        {
            WCHAR pszBindPath [1024];
            ULONG cch;

            cch = celems(pszBindPath) - 1;
            if (pBindPath->FGetPathToken (pszBindPath, &cch))
            {
                g_pDiagCtx->Printf (ttidBeDiag, "   %S (%s)\n",
                    pszBindPath,
                    (dwChangeFlag & NCN_ENABLE)
                        ? "enabled"
                        : (dwChangeFlag & NCN_DISABLE)
                            ? "disabled"
                            : "removed");
            }
        }

        pOwner->Notify.NbQueryOrNotifyBindingPath (
            pINetCfg,
            QN_NOTIFY,
            dwChangeFlag,
            pIPath,
            NULL);

        NgSysQueryOrNotifyBindingPath (
            QN_NOTIFY,
            dwChangeFlag,
            pIPath,
            NULL);

        if (fReleasePath)
        {
            ReleaseObj (pIPath);
        }
    }
}

HRESULT
CGlobalNotifyInterface::QueryAndNotifyBindPaths (
    IN DWORD dwBaseChangeFlag,
    IN CBindingSet* pBindSet,
    IN UINT cSkipFirstBindPaths)
{
    CBindPath* pBindPath;
    DWORD dwChangeFlag;
    PCSTR pszDiagMsg;

    // We should have called HrEnsureNotifyObjectsInitialized by now.
    //
    Assert (m_fInitialized);
    Assert ((dwBaseChangeFlag & NCN_ADD) || (dwBaseChangeFlag & NCN_REMOVE));

    if (dwBaseChangeFlag & NCN_ADD)
    {
        dwChangeFlag = NCN_ADD | NCN_ENABLE;
        pszDiagMsg = "Query and notify the following bindings:\n";
    }
    else
    {
        dwChangeFlag = NCN_REMOVE;
        pszDiagMsg = "Notify the following bindings are removed:\n";
    }

    g_pDiagCtx->Printf (ttidBeDiag, pszDiagMsg);

    // Iterate the newly added bindpaths by picking up where the
    // previous set ended and going to the end of the binding set.
    // Note, because this may recurse, pBindSet may change during
    // iteration, so a simple pointer increment through begin() to end()
    // may fail if the bindset is reallocated or grown.
    // Note too that we save off the current count of bindpaths in
    // iStopAtBindPath.  If we did not, when we come out of a recursion where
    // the binding set grew, we'd re-notify the newly added bindpaths
    // if we used a direct comparison of 'i < pBindSet->CountBindPaths()'.
    //
    UINT iStopAtBindPath = pBindSet->CountBindPaths();

    for (UINT i = cSkipFirstBindPaths; i < iStopAtBindPath; i++)
    {
        pBindPath = pBindSet->PGetBindPathAtIndex(i);

        NotifyBindPath (dwChangeFlag, pBindPath, NULL);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\netcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N E T C F G . C P P
//
//  Contents:   The main set of routines for dealing with the network
//              binding engine.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "diagctx.h"
#include "inetcfg.h"
#include "persist.h"
#include "netcfg.h"
#include "util.h"

// Called after a component has been removed.  In case this component
// is still listed in any other component's references, we remove those
// references.  This can happen if a notify object installs something
// on behalf of its component, but forgets to remove it.
//
VOID
CNetConfigCore::EnsureComponentNotReferencedByOthers (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetcfgBase);

    CComponentList::iterator iter;
    CComponent* pScan;

    for (iter  = Components.begin();
         iter != Components.end();
         iter++)
    {
        pScan = *iter;
        Assert (pScan);

        if (pScan->Refs.FIsReferencedByComponent (pComponent))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %S is still referenced by %S.  "
                "Removing the refernce.\n",
                pScan->PszGetPnpIdOrInfId(),
                pComponent->PszGetPnpIdOrInfId());

            pScan->Refs.RemoveReferenceByComponent (pComponent);
        }
    }
}

HRESULT
CNetConfigCore::HrCopyCore (
    IN const CNetConfigCore* pSourceCore)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;

    hr = Components.HrCopyComponentList (&pSourceCore->Components);
    if (S_OK != hr)
    {
        goto finished;
    }

    hr = StackTable.HrCopyStackTable (&pSourceCore->StackTable);
    if (S_OK != hr)
    {
        goto finished;
    }

    hr = DisabledBindings.HrCopyBindingSet (&pSourceCore->DisabledBindings);
    if (S_OK != hr)
    {
        goto finished;
    }

finished:
    if (S_OK != hr)
    {
        Clear ();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CNetConfigCore::HrCopyCore");
    return hr;
}

VOID
CNetConfigCore::Clear ()
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (this);

    DisabledBindings.Clear();
    StackTable.Clear();
    Components.Clear();
}

VOID
CNetConfigCore::Free ()
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (this);

    FreeCollectionAndItem (Components);
}

BOOL
CNetConfigCore::FIsEmpty () const
{
    TraceFileFunc(ttidNetcfgBase);

    return Components.FIsEmpty () &&
           StackTable.FIsEmpty () &&
           DisabledBindings.FIsEmpty ();
}

BOOL
CNetConfigCore::FContainsFilterComponent () const
{
    TraceFileFunc(ttidNetcfgBase);

    CComponentList::const_iterator iter;
    const CComponent* pComponent;

    for (iter  = Components.begin();
         iter != Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (pComponent->FIsFilter())
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
CNetConfigCore::FIsBindPathDisabled (
    IN const CBindPath* pBindPath,
    IN DWORD dwFlags /* IBD_FLAGS */) const
{
    TraceFileFunc(ttidNetcfgBase);
    const CBindPath* pScan;

    Assert (this);
    Assert (pBindPath);
    Assert ((dwFlags & IBD_EXACT_MATCH_ONLY) ||
            (dwFlags & IBD_MATCH_SUBPATHS_TOO));

    DbgVerifyBindingSet (&DisabledBindings);

    // The bindpath is disabled if it matches one of the bindpaths in
    // the disabled set or if one of the bindpaths in the disabled set
    // is a subpath of it.
    //
    // IBD_EXACT_MATCH_ONLY is used when writing bindings to the registry.
    //   We only neglect writing a disabled binding for the components
    //   which directly have the disabled binding.  i.e. if
    //   netbt>-tcpip->adapter is disabled, we only negect to write the
    //   binding for netbt.  We still write binding for components above
    //   netbt (server, client) as if they were bound.  We do this because
    //   1) it doesn't matter that the upper components have these written
    //   2) it means we don't have to involve these upper components in
    //      PnP notifications when then binding is enabled/disabled.
    //
    // IBD_MATCH_SUBPATHS_TOO is used when reporting bindpaths as enabled
    //   or disabled through the INetCfg interface.  To clients, a binding
    //   is disabled if any of its subpaths are disabled.  It has to be
    //   because there is no way that connectivity along the entire path
    //   will happen if any of the subpaths are cut-off (disabled).
    //
    for (pScan  = DisabledBindings.begin();
         pScan != DisabledBindings.end();
         pScan++)
    {
        if (pScan->FIsSameBindPathAs (pBindPath))
        {
            return TRUE;
        }

        if (dwFlags & IBD_MATCH_SUBPATHS_TOO)
        {
            if (pScan->FIsSubPathOf (pBindPath))
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

// An alternate way to check if a bindpath is disabled when you have
// just the two components in question and you know that they are expected
// to be bound to one another.  Using this method as opposed to
// FIsBindPathDisabled is better when you don't have the binpath allocated
// and don't want to allocate one just to check it.  Thus, this method
// allocates no memory and doesn't need to check subpaths because a bindpath
// of length 2 can have no subpaths.  This method is used primarily when
// seeing if a filter is bound to an adapter.
//
BOOL
CNetConfigCore::FIsLength2BindPathDisabled (
    IN const CComponent* pUpper,
    IN const CComponent* pLower) const
{
    TraceFileFunc(ttidNetcfgBase);
    const CBindPath* pScan;

    Assert (this);
    Assert (pUpper);
    Assert (pLower);

    DbgVerifyBindingSet (&DisabledBindings);

    for (pScan  = DisabledBindings.begin();
         pScan != DisabledBindings.end();
         pScan++)
    {
        if (pScan->CountComponents() != 2)
        {
            continue;
        }

        if ((pScan->POwner() == pUpper) &&
            (pScan->PLastComponent() == pLower))
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
CNetConfigCore::HrDisableBindPath (
    IN const CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;

    Assert (this);
    Assert (pBindPath);

    hr = DisabledBindings.HrAddBindPath (
            pBindPath, INS_IGNORE_IF_DUP | INS_APPEND);

    DbgVerifyBindingSet (&DisabledBindings);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNetConfigCore::HrDisableBindPath");
    return hr;
}

HRESULT
CNetConfigCore::HrGetComponentBindings (
    IN const CComponent* pComponent,
    IN DWORD dwFlags /* GB_FLAGS */,
    OUT CBindingSet* pBindSet)
{
    TraceFileFunc(ttidNetcfgBase);
    GBCONTEXT Ctx;

    Assert (pComponent);
    Assert (pBindSet);

    DbgVerifyData();

    // Initialize the output parameter.
    //
    if (!(dwFlags & GBF_ADD_TO_BINDSET))
    {
        pBindSet->Clear();
    }

    // Initialize the members of our context structure for recursion.
    // We set the append bindpath flags to assert if a duplicate is inserted
    // because we know that GetBindingsBelowComponent will not insert
    // duplicates under normal conditions.
    //
    ZeroMemory (&Ctx, sizeof(Ctx));
    Ctx.pCore                   = this;
    Ctx.pBindSet                = pBindSet;
    Ctx.pSourceComponent        = pComponent;
    Ctx.fPruneDisabledBindings  = (dwFlags & GBF_PRUNE_DISABLED_BINDINGS);
    Ctx.dwAddBindPathFlags      = (dwFlags & GBF_ADD_TO_BINDSET)
                                        ? INS_IGNORE_IF_DUP
                                        : INS_ASSERT_IF_DUP;

    GetBindingsBelowComponent (pComponent, &Ctx);

    // Verify the bindset we are about to return is valid.
    // (Checked builds only.)
    //
    if (S_OK == Ctx.hr)
    {
        DbgVerifyBindingSet (pBindSet);
    }

    TraceHr (ttidError, FAL, Ctx.hr, FALSE,
        "CNetConfigCore::HrGetComponentBindings");
    return Ctx.hr;
}

HRESULT
CNetConfigCore::HrGetComponentUpperBindings (
    IN const CComponent* pComponent,
    IN DWORD dwFlags,
    OUT CBindingSet* pBindSet)
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr = S_OK;
    CBindPath BindPath;
    const CStackEntry* pScan;
    DWORD dwAddBindPathFlags;

    Assert (pComponent);
    Assert (FIsEnumerated(pComponent->Class()));
    Assert ((GBF_DEFAULT == dwFlags) ||
            (dwFlags & GBF_ADD_TO_BINDSET) ||
            (dwFlags & GBF_PRUNE_DISABLED_BINDINGS));
    Assert (pBindSet);

    DbgVerifyData();

    dwAddBindPathFlags = INS_APPEND | INS_IGNORE_IF_DUP;

    // Initialize the output parameter.
    //
    if (!(dwFlags & GBF_ADD_TO_BINDSET))
    {
        pBindSet->Clear();
        dwAddBindPathFlags = INS_APPEND | INS_ASSERT_IF_DUP;
    }

    hr = BindPath.HrReserveRoomForComponents (2);

    if (S_OK == hr)
    {
        // This won't fail because we've reserved enough room above.
        //
        hr = BindPath.HrInsertComponent (pComponent);
        Assert (S_OK == hr);
        Assert (1 == BindPath.CountComponents());

        // For all rows in the stack table where the lower component
        // is the one passed in...
        //
        for (pScan  = StackTable.begin();
             pScan != StackTable.end();
             pScan++)
        {
            if (pComponent != pScan->pLower)
            {
                continue;
            }

            // Continue if this length-2 bindpath is disabled.
            //
            if (dwFlags & GBF_PRUNE_DISABLED_BINDINGS)
            {
                if (FIsLength2BindPathDisabled (pScan->pUpper, pScan->pLower))
                {
                    continue;
                }
            }

            // This won't fail because we've reserved enough room above.
            //
            hr = BindPath.HrInsertComponent (pScan->pUpper);
            Assert (S_OK == hr);

            Assert (2 == BindPath.CountComponents());
            hr = pBindSet->HrAddBindPath (&BindPath, dwAddBindPathFlags);
            if (S_OK != hr)
            {
                break;
            }

            BindPath.RemoveFirstComponent();
        }

        // Verify the bindset we are about to return is valid.
        // (Checked builds only.)
        //
        DbgVerifyBindingSet (pBindSet);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNetConfigCore::HrGetComponentUpperBindings");
    return hr;
}

HRESULT
CNetConfigCore::HrGetBindingsInvolvingComponent (
    IN const CComponent* pComponent,
    IN DWORD dwFlags,
    IN OUT CBindingSet* pBindSet)
{
    TraceFileFunc(ttidNetcfgBase);
    GCCONTEXT Ctx;
    CComponentList ComponentsAbove;
    UINT cExistingBindPaths;

    Assert (pComponent);
    Assert ((GBF_DEFAULT == dwFlags) ||
            (dwFlags & GBF_ADD_TO_BINDSET) ||
            (dwFlags & GBF_PRUNE_DISABLED_BINDINGS) ||
            (dwFlags & GBF_ONLY_WHICH_CONTAIN_COMPONENT));
    Assert (pBindSet);
    DbgVerifyData();

    // Initialize the output parameter.
    //
    if (!(dwFlags & GBF_ADD_TO_BINDSET))
    {
        pBindSet->Clear();
    }

    // Since we may be adding to the bindset, be sure to exclude the existing
    // bindpaths from our scans below.
    //
    cExistingBindPaths = pBindSet->CountBindPaths();

    // Initialize the members of our context structure for recursion.
    //
    ZeroMemory (&Ctx, sizeof(Ctx));
    Ctx.pStackTable = &StackTable;
    Ctx.pComponents = &ComponentsAbove;
    Ctx.fIgnoreDontExposeLower = TRUE;

    GetComponentsAboveComponent (pComponent, &Ctx);

    if (S_OK == Ctx.hr)
    {
        // First get the bindings below the component.
        //
        Ctx.hr = HrGetComponentBindings (
                    pComponent,
                    dwFlags | GBF_ADD_TO_BINDSET,
                    pBindSet);

        if (S_OK == Ctx.hr)
        {
            CComponentList::const_iterator iter;
            const CComponent* pComponentAbove;

            // Now get the bindings below each of the components
            // above the component and add them to the bindset.
            //
            for (iter  = ComponentsAbove.begin();
                 iter != ComponentsAbove.end();
                 iter++)
            {
                pComponentAbove = *iter;
                Assert (pComponentAbove);

                Ctx.hr = HrGetComponentBindings (
                            pComponentAbove,
                            dwFlags | GBF_ADD_TO_BINDSET,
                            pBindSet);

                if (S_OK != Ctx.hr)
                {
                    break;
                }

                // Verify the bindset we are about to return is valid.
                // (Checked builds only.)
                //
                DbgVerifyBindingSet (pBindSet);
            }
        }

        // Now remove any bindings that don't involve the component.
        // If the component is enumerated, leave bindings that end in
        // NCF_DONTEXPOSELOWER components, because they are indirectly
        // involved in the bindings associated with the adapter.
        //
        if (S_OK == Ctx.hr)
        {
            CBindPath* pScan;
            BOOL fIsEnumerated;

            fIsEnumerated = FIsEnumerated(pComponent->Class());

            if (fIsEnumerated || !(dwFlags & GBF_ONLY_WHICH_CONTAIN_COMPONENT))
            {
                // fDelBoundToComponent means "is there a NCF_DONTEXPOSELOWER
                // component bound to pComponent".  If there is not, we will
                // be setting GBF_ONLY_WHICH_CONTAIN_COMPONENT to force the
                // removal of any NCF_DONTEXPOSELOWER components from
                // the bind set below.
                //
                BOOL fDelBoundToComponent = FALSE;

                for (pScan  = pBindSet->PGetBindPathAtIndex (cExistingBindPaths);
                     pScan != pBindSet->end();
                     pScan++)
                {
                    if ((pScan->PLastComponent() == pComponent) &&
                        (pScan->POwner()->m_dwCharacter & NCF_DONTEXPOSELOWER))
                    {
                        fDelBoundToComponent = TRUE;
                        break;
                    }
                }

                if (!fDelBoundToComponent)
                {
                    dwFlags |= GBF_ONLY_WHICH_CONTAIN_COMPONENT;
                }
            }

            pScan = pBindSet->PGetBindPathAtIndex (cExistingBindPaths);
            while (pScan != pBindSet->end())
            {
                if (pScan->FContainsComponent (pComponent))
                {
                    pScan++;
                    continue;
                }

                // At this point, we know that the bindpath does not
                // contain pComponent.  See if we should erase it or keep it.
                //

                // If the component is not an adpater or if the caller wants
                // only bindpaths which contain the adapter, erase it.
                //
                if (!fIsEnumerated ||
                    (dwFlags & GBF_ONLY_WHICH_CONTAIN_COMPONENT))
                {
                    pBindSet->erase (pScan);
                    continue;
                }

                // Otherwise, (pComponent is an adpater and the caller wants
                // indirect bindings involved with that adpater) we'll
                // erase the bindpath only if the last component is not an
                // NCF_DONTEXPOSELOWER component.  We need to keep these
                // bindpaths so that the LAN UI (which shows components
                // involved in bindpaths that involve an adapter) can
                // display these NCF_DONTEXPOSELOWER components too.
                //
                else
                {
                    CComponent* pLast = pScan->PLastComponent();

                    if (!(pLast->m_dwCharacter & NCF_DONTEXPOSELOWER))
                    {
                        pBindSet->erase (pScan);
                        continue;
                    }
                }

                pScan++;
            }
        }
    }

    TraceHr (ttidError, FAL, Ctx.hr, FALSE,
        "CNetConfigCore::HrGetBindingsInvolvingComponent");
    return Ctx.hr;
}

HRESULT
CNetConfigCore::HrGetFiltersEnabledForAdapter (
    IN const CComponent* pAdapter,
    OUT CComponentList* pFilters)
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr;
    const CStackEntry* pScan;

    Assert (this);
    Assert (pAdapter);
    Assert (FIsEnumerated(pAdapter->Class()));
    Assert (pFilters);

    // Initialize the output parameter.
    //
    pFilters->Clear();

    // Scan the stack table looking for lower component matches to pAdapter.
    // When found, and if the upper component is a filter, and if the
    // direct bindpath is not disabled, add the filter to the output list.
    //
    for (pScan = StackTable.begin(); pScan != StackTable.end(); pScan++)
    {
        // Looking for lower component matches to the adapter where
        // the upper component is a filter.  Ignore all others.
        //
        if ((pScan->pLower != pAdapter) || !pScan->pUpper->FIsFilter())
        {
            continue;
        }

        Assert (pScan->pUpper->FIsFilter());
        Assert (pScan->pLower == pAdapter);

        // If the bindpath is not disabled, add the filter to the list.
        //
        if (!FIsLength2BindPathDisabled (pScan->pUpper, pScan->pLower))
        {
            // Assert if a duplicate because the same filter can't be bound
            // to the same adapter more than once.
            // No need to sort when we insert because the class of all of
            // the components in this list will be the same.
            //
            hr = pFilters->HrInsertComponent (pScan->pUpper,
                    INS_ASSERT_IF_DUP | INS_NON_SORTED);

            if (S_OK != hr)
            {
                return hr;
            }
        }
    }

    return S_OK;
}

// (Takes ownership of pComponent)
//
HRESULT
CNetConfigCore::HrAddComponentToCore (
    IN CComponent* pComponent,
    IN DWORD dwFlags /* INS_FLAGS */)
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr;

    Assert (pComponent);
    Assert ((INS_SORTED == dwFlags) || (INS_NON_SORTED == dwFlags));

    DbgVerifyExternalDataLoadedForAllComponents ();
    pComponent->Ext.DbgVerifyExternalDataLoaded ();

    // Make sure we are not trying to insert a component with a PnpId that
    // is the same as one already in the core.  Note that we do not perform
    // this check inside of CComponentList::HrInsertComponent because it is
    // not appropriate for all component lists.  Specifically, the dirty
    // component list may end up having two different components with the
    // same PnpId for the case when we are asked to install an adapter that
    // is pending removal.  In this case the new adapter will get the same
    // PnpId as the one that was removed.  We'll remove the old one from
    // core to insert the new one so the dirty component list will have
    // both components with the same PnpId.
    //
    if (FIsEnumerated(pComponent->Class()) &&
        Components.PFindComponentByPnpId (pComponent->m_pszPnpId))
    {
        AssertSz (FALSE, "Asked to add a component with a duplicate PnpId!");
        return E_INVALIDARG;
    }

    // Insert the component into the list.  This should only fail if we
    // are out of memory.
    //
    hr = Components.HrInsertComponent (
            pComponent, dwFlags | INS_ASSERT_IF_DUP);

    if (S_OK == hr)
    {
        // Insert the appropriate stack entries for pComponent based on
        // how it binds with the other components.
        //
        hr = StackTable.HrInsertStackEntriesForComponent (
                pComponent, &Components, dwFlags);

        // If we failed to insert the stack entries, undo the insertion
        // into the component list.
        //
        if (S_OK != hr)
        {
            Components.RemoveComponent (pComponent);
        }
    }

    // Error or not, we should still have a valid core.
    //
    DbgVerifyData();

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNetConfigCore::HrAddComponentToCore");
    return hr;
}

VOID
CNetConfigCore::RemoveComponentFromCore (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetcfgBase);
    Assert (this);
    Assert (pComponent);

    Components.RemoveComponent (pComponent);
    StackTable.RemoveEntriesWithComponent (pComponent);
    DisabledBindings.RemoveBindPathsWithComponent (pComponent);

#if DBG
    // We set m_fRemovedAComponent so that when subsequent
    // DbgVerifyBindingSet calls are made, we don't assert on components
    // that are in the binding set but not in the core.  This is a natural
    // occurance for the m_DeletedBindings we build up during removal of
    // components.
    //
    m_fRemovedAComponent = TRUE;

    // Note: need to find a convenient time during Apply where
    // we set this flag back to FALSE.
#endif
}


// static
HRESULT
CNetConfig::HrCreateInstance (
    IN class CImplINetCfg* pINetCfg,
    OUT CNetConfig** ppNetConfig)
{
    TraceFileFunc(ttidNetcfgBase);
    Assert (pINetCfg);

    HRESULT hr = E_OUTOFMEMORY;

    CNetConfig* pObj;
    pObj = new CNetConfig;
    if (pObj)
    {
        // Load the configuration binary.  If we have have the write lock,
        // request write access, otherwise, request read access.
        // Requesting write access means this will only succeed if the
        // volatile key indicating we need a reboot does not exist.
        //
        hr = HrLoadNetworkConfigurationFromRegistry (
                (pINetCfg->m_WriteLock.FIsOwnedByMe ())
                    ? KEY_WRITE : KEY_READ,
                pObj);

        if (S_OK == hr)
        {
            pObj->Core.DbgVerifyData();
            pObj->Notify.HoldINetCfg (pINetCfg);
            *ppNetConfig = pObj;
        }
        else
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CNetConfig::HrCreateInstance");
    return hr;
}

CNetConfig::~CNetConfig ()
{
    TraceFileFunc(ttidNetcfgBase);
    Core.Free ();
}

HRESULT
CNetConfig::HrEnsureExternalDataLoadedForAllComponents ()
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr;
    HRESULT hrRet;
    CComponentList::iterator iter;
    CComponent* pComponent;

    hrRet = S_OK;

    // This is a while loop instead of a for loop because of the
    // potential for conditional advancement of the iterator.  If we
    // remove a component from the core while looping, we don't increment
    // the iterator for the next iteration.
    //
    iter = Core.Components.begin();
    while (iter != Core.Components.end())
    {
        pComponent = *iter;
        Assert (pComponent);

        hr = pComponent->Ext.HrEnsureExternalDataLoaded ();

        if ((SPAPI_E_NO_SUCH_DEVINST == hr) ||
            (SPAPI_E_KEY_DOES_NOT_EXIST == hr))
        {
            g_pDiagCtx->Printf (ttidBeDiag,
                "Removing %s from the core because its external data is missing\n",
                pComponent->PszGetPnpIdOrInfId());

            Core.RemoveComponentFromCore (pComponent);
            delete pComponent;
            hr = S_OK;

            // Because we removed this component from the core, the
            // list has been adjusted and the next component is now this
            // iter.  Therefore, just continue without incrementing iter.
            //
            continue;
        }

        // Remember the first error as our return code, but keep going.
        // Like the name says, we are to load data for all components so
        // don't stop just because one fails.
        //
        if ((S_OK != hr) && (S_OK == hrRet))
        {
            hrRet = hr;
        }

        iter++;
    }

    TraceHr (ttidError, FAL, hrRet, FALSE,
        "CNetConfig::HrEnsureExternalDataLoadedForAllComponents");
    return hrRet;
}


#if DBG

VOID
CNetConfigCore::DbgVerifyData () const
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr;

    CComponentList::const_iterator iter;
    const CComponent* pComponent;
    const CStackEntry*  pStackEntry;
    const CComponent* pUpper;
    const CComponent* pLower;
    CHAR szBuffer [512];

    for (pStackEntry  = StackTable.begin();
         pStackEntry != StackTable.end();
         pStackEntry++)
    {
        pUpper = pStackEntry->pUpper;
        pLower = pStackEntry->pLower;

        Assert (pUpper);
        Assert (pLower);
        Assert (pUpper != pLower);

        // Can't access upper and lower range if the external data isn't
        // loaded.
        //
        if (pUpper->Ext.DbgIsExternalDataLoaded() &&
            pLower->Ext.DbgIsExternalDataLoaded())
        {
            if (!pUpper->FCanDirectlyBindTo (pLower, NULL, NULL))
            {
                wsprintfA (szBuffer, "%S should not bind to %S.  They are in the "
                    "stack table as if they do.  (Likely upgrade problem.)",
                    pUpper->PszGetPnpIdOrInfId(),
                    pLower->PszGetPnpIdOrInfId());
                AssertSzFn (szBuffer, FAL);
            }
        }

        if (!FIsEnumerated (pUpper->Class()))
        {
            if (pUpper != Components.PFindComponentByInfId (
                                        pUpper->m_pszInfId, NULL))
            {
                wsprintfA (szBuffer, "%S is an upper component in the stack "
                    "table, but was not found in the component list.",
                    pUpper->m_pszInfId);
                AssertSzFn (szBuffer, FAL);
            }
        }
        else
        {
            if (pUpper != Components.PFindComponentByPnpId (
                                        pUpper->m_pszPnpId))
            {
                wsprintfA (szBuffer, "%S is an upper component in the stack "
                    "table, but was not found in the component list.",
                    pUpper->m_pszInfId);
                AssertSzFn (szBuffer, FAL);
            }
        }

        if (!FIsEnumerated (pLower->Class()))
        {
            if (pLower != Components.PFindComponentByInfId (
                                        pLower->m_pszInfId, NULL))
            {
                wsprintfA (szBuffer, "%S is a lower component in the stack "
                    "table, but was not found in the component list.",
                    pLower->m_pszInfId);
                AssertSzFn (szBuffer, FAL);
            }
        }
        else
        {
            if (pLower != Components.PFindComponentByPnpId (
                                        pLower->m_pszPnpId))
            {
                wsprintfA (szBuffer, "%S is a lower component in the stack "
                    "table, but was not found in the component list.",
                    pLower->m_pszInfId);
                AssertSzFn (szBuffer, FAL);
            }
        }

        if (pUpper != Components.PFindComponentByInstanceGuid (&pUpper->m_InstanceGuid))
        {
            wsprintfA (szBuffer, "%S is an upper component in the stack "
                "table, but was not found in the component list by GUID.",
                pUpper->PszGetPnpIdOrInfId());
            AssertSzFn (szBuffer, FAL);
        }

        if (pLower != Components.PFindComponentByInstanceGuid (&pLower->m_InstanceGuid))
        {
            wsprintfA (szBuffer, "%S is a lower component in the stack "
                "table, but was not found in the component list by GUID.",
                pLower->PszGetPnpIdOrInfId());
            AssertSzFn (szBuffer, FAL);
        }
    }
}

VOID
CNetConfigCore::DbgVerifyExternalDataLoadedForAllComponents () const
{
    TraceFileFunc(ttidNetcfgBase);
    CComponentList::const_iterator iter;
    const CComponent* pComponent;

    for (iter  = Components.begin();
         iter != Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        pComponent->Ext.DbgVerifyExternalDataLoaded();
    }
}

VOID
CNetConfigCore::DbgVerifyBindingSet (
    const CBindingSet* pBindSet) const
{
    TraceFileFunc(ttidNetcfgBase);
    const CBindPath* pPath;
    const CBindPath* pOtherPath;
    CBindPath::const_iterator iter;
    const CComponent* pComponent;

    Assert (pBindSet);

    // First make sure every component in the set is in our component
    // list.  We only do this if we're not in the state where a component
    // has been removed from the core.  For this case, its okay if those
    // components still exist in binding sets.
    //
    if (!m_fRemovedAComponent)
    {
        for (pPath  = pBindSet->begin();
             pPath != pBindSet->end();
             pPath++)
        {
            for (iter  = pPath->begin();
                 iter != pPath->end();
                 iter++)
            {
                pComponent = *iter;

                Assert (Components.FComponentInList (pComponent));
            }
        }
    }

    // Make sure there are no duplicate bindpaths in the set.
    //
    for (pPath  = pBindSet->begin();
         pPath != pBindSet->end();
         pPath++)
    {
        Assert (!pPath->FIsEmpty());

        for (pOtherPath  = pBindSet->begin();
             pOtherPath != pBindSet->end();
             pOtherPath++)
        {
            if (pPath == pOtherPath)
            {
                continue;
            }

            Assert (!pPath->FIsSameBindPathAs (pOtherPath));
        }
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\notify.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N O T I F Y . H
//
//  Contents:   Implements the interface to a component's optional notify
//              object.  The object defined here is meant to be a member
//              of CComponent.  This object encapsulates all of its internal
//              data in a separate allocation made only if the component
//              actually has a notify object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgn.h"
#include "netcfgx.h"
#include "ncnetcfg.h"

class CBindPath;
class CBindingSet;
class CComponent;
class CImplINetCfg;

struct NOTIFY_OBJECT_DATA
{
    INetCfgComponentControl*        pCc;
    INetCfgComponentNotifyBinding*  pNb;
    INetCfgComponentPropertyUi*     pCp;
    INetCfgComponentSetup*          pCs;
    INetCfgComponentUpperEdge*      pUe;
    INetCfgComponentNotifyGlobal*   pNg;
    DWORD                           dwNotifyGlobalFlags;
};

enum QN_FLAG
{
    QN_QUERY,
    QN_NOTIFY
};

// CComponent has a member called Notify that is of this type.
//
// pComponent = CONTAINING_RECORD(this, CComponent, Notify)
//
class CNotifyObjectInterface
{
friend class CGlobalNotifyInterface;
friend class CImplINetCfgComponent;

private:
    NOTIFY_OBJECT_DATA* m_pNod;
    BOOLEAN             m_fInitialized;

public:
    ~CNotifyObjectInterface ()
    {
        ReleaseNotifyObject (NULL, FALSE);
        AssertH (!m_pNod);
        AssertH (!m_fInitialized);
    }

    VOID
    ApplyPnpChanges (
        IN CImplINetCfg* pINetCfg,
        OUT BOOL* pfNeedReboot) const;

    VOID
    ApplyRegistryChanges (
        IN CImplINetCfg* pINetCfg,
        OUT BOOL* pfNeedReboot) const;

    HRESULT
    HrGetInterfaceIdsForAdapter (
        IN CImplINetCfg* pINetCfg,
        IN const CComponent* pAdapter,
        OUT DWORD* pcInterfaces,
        OUT GUID** ppguidInterfaceIds) const;

    HRESULT
    HrQueryPropertyUi (
        IN CImplINetCfg* pINetCfg,
        IN IUnknown* punkContext OPTIONAL);

    HRESULT
    HrShowPropertyUi (
        IN CImplINetCfg* pINetCfg,
        IN HWND hwndParent,
        IN IUnknown* punkContext OPTIONAL);

    HRESULT
    QueryNotifyObject (
        IN CImplINetCfg* pINetCfg,
        IN REFIID riid,
        OUT VOID** ppvObject);

    VOID
    ReleaseNotifyObject (
        IN CImplINetCfg* pINetCfg,
        IN BOOL fCancel);

private:
    // If not m_fInitialized, looks under component's instance key
    // for CLSID and, if found, CoCreates it and initializes m_pNod.
    //
    HRESULT
    HrEnsureNotifyObjectInitialized (
        IN CImplINetCfg* pINetCfg,
        IN BOOL fInstalling);

    VOID
    SetUiContext (
        IN CImplINetCfg* pINetCfg,
        IN IUnknown* punkContext);

    VOID
    NbQueryOrNotifyBindingPath (
        IN CImplINetCfg* pINetCfg,
        IN QN_FLAG Flag,
        IN DWORD dwChangeFlag,
        IN INetCfgBindingPath* pIPath,
        OUT BOOL* pfDisabled);

    HRESULT
    NewlyAdded (
        IN CImplINetCfg* pINetCfg,
        IN const NETWORK_INSTALL_PARAMS* pnip);

    VOID
    Removed (
        IN CImplINetCfg* pINetCfg);

    VOID
    Updated (
        IN CImplINetCfg* pINetCfg,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo);
};


// CNetCfg has a member called GlobalNotify that is of this type.
//
// pConfig = CONTAINING_RECORD(this, CNetConfig, GlobalNotify)
//
class CGlobalNotifyInterface
{
friend class CNotifyObjectInterface;
friend class CNetCfgInternalDiagnostic;

private:
    // TRUE if all notify objects have been loaded and QI'd for
    // INetCfgComponentNotifyGlobal.
    //
    BOOL            m_fInitialized;

    // A pointer to INetCfg is needed because we hand this to notify objects.
    //
    CImplINetCfg*   m_pINetCfg;

private:
    // INetCfgComponentNotifyGlobal
    //
    // (each method calls HrEnsureNotifyObjectsInitialized and then
    // for each component in CNetCfg that has non-NULL Notify.m_pNod,
    // calls through Notify.m_pNod->pNg)
    //
    VOID
    NgSysQueryOrNotifyBindingPath (
        IN QN_FLAG Flag,
        IN DWORD dwChangeFlag,
        IN INetCfgBindingPath* pIPath,
        IN BOOL* pfDisabled);

    // Called when a component is added, removed, updated, or has its
    // properties changed.
    //
    HRESULT
    NgSysNotifyComponent (
        IN DWORD dwChangeFlag,
        IN CComponent* pComponent);

    HRESULT
    QueryAndNotifyBindPaths (
        IN DWORD dwBaseChangeFlag,
        IN CBindingSet* pBindSet,
        IN UINT cSkipFirstBindPaths);

public:
    ~CGlobalNotifyInterface ()
    {
        ReleaseINetCfg ();
        AssertH (!m_pINetCfg);
    }

    VOID
    HoldINetCfg (
        CImplINetCfg* pINetCfg);

    VOID
    ReleaseINetCfg ();

    CImplINetCfg*
    PINetCfg ()
    {
        AssertH (m_pINetCfg);
        return m_pINetCfg;
    }

    // If not m_fInitialized, calls into CNetConfig to load every component's
    // notify object.
    //
    HRESULT
    HrEnsureNotifyObjectsInitialized ();

    HRESULT
    ComponentAdded (
        IN CComponent* pComponent,
        IN const NETWORK_INSTALL_PARAMS* pnip);

    HRESULT
    ComponentRemoved (
        IN CComponent* pComponent);

    HRESULT
    ComponentUpdated (
        IN CComponent* pComponent,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo);

    HRESULT
    NotifyRemovedBindPaths (
        IN CBindingSet* pBindSet,
        IN UINT cSkipFirstBindPaths)
    {
        return QueryAndNotifyBindPaths (NCN_REMOVE, pBindSet, cSkipFirstBindPaths);
    }

    HRESULT
    QueryAndNotifyForAddedBindPaths (
        IN CBindingSet* pBindSet,
        IN UINT cSkipFirstBindPaths)
    {
        return QueryAndNotifyBindPaths (NCN_ADD, pBindSet, cSkipFirstBindPaths);
    }

    VOID
    NotifyBindPath (
        IN DWORD dwChangeFlag,
        IN CBindPath* pBindPath,
        IN INetCfgBindingPath* pIPath);

    VOID
    ReleaseAllNotifyObjects (
        IN CComponentList& Components,
        IN BOOL fCancel);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\obotoken.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       O B O T O K E N . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "obotoken.h"
#include "icomp.h"
#include "ncvalid.h"

BOOL
FOboTokenValidForClass (
    IN const OBO_TOKEN* pOboToken,
    IN NETCLASS Class )
{
    // OboTokens must be specified for anything other than adapters.
    //
    if (!pOboToken && !FIsEnumerated (Class))
    {
        return FALSE;
    }
    return TRUE;
}

HRESULT
HrProbeOboToken (
    IN const OBO_TOKEN* pOboToken)
{
    // Only probe if pOboToken was specified.
    //
    if (!pOboToken)
    {
        return S_OK;
    }

    HRESULT hr = S_OK;

    if (FBadInPtr (pOboToken))
    {
        hr = E_POINTER;
    }
    else
    {
        switch (pOboToken->Type)
        {
        case OBO_USER:
            hr = S_OK;
            break;

        case OBO_COMPONENT:
            hr = E_POINTER;
            if (!FBadInPtr (pOboToken->pncc))
            {
                hr = HrIsValidINetCfgComponent (pOboToken->pncc);
            }
            break;

        case OBO_SOFTWARE:
            if (FBadInPtr (pOboToken->pszwManufacturer) ||
                FBadInPtr (pOboToken->pszwProduct)      ||
                FBadInPtr (pOboToken->pszwDisplayName))
            {
                hr = E_POINTER;
            }
            else if (!*pOboToken->pszwManufacturer ||
                     !*pOboToken->pszwProduct ||
                     !*pOboToken->pszwDisplayName)
            {
                hr = E_INVALIDARG;
            }
            break;

        default:
            hr = E_INVALIDARG;
        }
    }
    TraceError ("HrProbeOboToken", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <regstr.h>
#include <setupapi.h>
#include <stdio.h>
#include <wchar.h>
#include <shlwapi.h>
#include <shlwapip.h>	// for SHLoadRegUIString

#include "stlalgor.h"
#include "stllist.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\obotoken.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       O B O T O K E N . H
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "compdefs.h"
#include "netcfgx.h"

BOOL
FOboTokenValidForClass (
    IN const OBO_TOKEN* pOboToken,
    IN NETCLASS Class);

HRESULT
HrProbeOboToken (
    IN const OBO_TOKEN* pOboToken);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\netcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N E T C F G . H
//
//  Contents:   Defines the overall datatype for representing the network
//              bindings engine.  This datatype, CNetConfig, is a
//              collection of components and their binding relationships
//              to each other.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "complist.h"
#include "diagctx.h"
#include "install.h"
#include "notify.h"
#include "stable.h"
#include "util.h"

// Flags for HrGetBindingsXXX.
//
enum GB_FLAGS
{
    GBF_DEFAULT                         = 0x00000000,
    GBF_ADD_TO_BINDSET                  = 0x00000001,
    GBF_PRUNE_DISABLED_BINDINGS         = 0x00000002,
    GBF_ONLY_WHICH_CONTAIN_COMPONENT    = 0x00000004,
};

// Flags for FIsBindPathDisabled.
//
enum IBD_FLAGS
{
    IBD_EXACT_MATCH_ONLY        = 0x00000001,
    IBD_MATCH_SUBPATHS_TOO      = 0x00000002,
};

class CNetConfigCore
{
public:
    CComponentList  Components;
    CStackTable     StackTable;
    CBindingSet     DisabledBindings;

#if DBG
private:
    BOOL    m_fRemovedAComponent;
#endif

public:
    VOID Clear ();
    VOID Free ();
    BOOL FIsEmpty () const;

    BOOL
    FContainsFilterComponent () const;

    BOOL
    FIsBindPathDisabled (
        IN const CBindPath* pBindPath,
        IN DWORD dwFlags /* IBD_FLAGS */) const;

    BOOL
    FIsLength2BindPathDisabled (
        IN const CComponent* pUpper,
        IN const CComponent* pLower) const;

    VOID
    EnableBindPath (
        IN const CBindPath* pBindPath)
    {
        TraceFileFunc(ttidNetCfgBind);

        DisabledBindings.RemoveBindPath (pBindPath);
        DbgVerifyBindingSet (&DisabledBindings);
    }

    VOID
    EnsureComponentNotReferencedByOthers (
        IN const CComponent* pComponent);

    HRESULT
    HrDisableBindPath (
        IN const CBindPath* pBindPath);

    HRESULT
    HrCopyCore (
        IN const CNetConfigCore* pSourceCore);

    HRESULT
    HrGetBindingsInvolvingComponent (
        IN const CComponent* pComponent,
        IN DWORD dwFlags,
        IN OUT CBindingSet* pBindSet);

    HRESULT
    HrGetComponentBindings (
        IN const CComponent* pComponent,
        IN DWORD dwFlags /* GB_FLAGS */,
        OUT CBindingSet* pBindSet);

    HRESULT
    HrGetComponentUpperBindings (
        IN const CComponent* pComponent,
        IN DWORD dwFlags,
        OUT CBindingSet* pBindSet);

    HRESULT
    HrGetFiltersEnabledForAdapter (
        IN const CComponent* pAdapter,
        OUT CComponentList* pFilters);

    HRESULT
    HrAddComponentToCore (
        IN CComponent* pComponent,
        IN DWORD dwFlags /* INS_FLAGS */);

    VOID
    RemoveComponentFromCore (
        IN const CComponent* pComponent);

#if DBG
    VOID DbgVerifyData () const;
    VOID DbgVerifyExternalDataLoadedForAllComponents () const;
    VOID DbgVerifyBindingSet (
        const CBindingSet* pBindSet) const;
#else
    VOID DbgVerifyData () const {}
    VOID DbgVerifyExternalDataLoadedForAllComponents () const {}
    VOID DbgVerifyBindingSet (
        const CBindingSet* /*pBindSet*/) const {}
#endif
};


class CNetConfig;
class CFilterDevices;


class CRegistryBindingsContext
{
private:
    CNetConfig*     m_pNetConfig;
    CBindingSet     m_BindSet;
    CDynamicBuffer  m_BindValue;
    CDynamicBuffer  m_ExportValue;
    CDynamicBuffer  m_RouteValue;

public:
    HRESULT
    HrPrepare (
        IN CNetConfig* pNetConfig);

    HRESULT
    HrGetAdapterUpperBindValue (
        IN const CComponent* pAdapter);

    HRESULT
    HrWriteBindingsForComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrWriteBindingsForFilterDevices (
        IN CFilterDevices* pFilterDevices);

    HRESULT
    HrDeleteBindingsForComponent (
        IN const CComponent* pComponent);

    VOID
    PnpBindOrUnbindBindPaths (
        IN UINT unOperation,
        IN const CBindingSet* pBindSet,
        OUT BOOL* pfRebootNeeded);
};


enum IOR_ACTION
{
    IOR_INSTALL,
    IOR_REMOVE,
};

enum EBO_FLAG
{
    EBO_COMMIT_NOW = 1,
    EBO_DEFER_COMMIT_UNTIL_APPLY,
};

class CModifyContext
{
public:
    // This is the core data we started with before the modification began.
    // In the event the modification fails, we will revert to this data.
    // We also use this data when we apply the changes.  We compare what
    // we started with to what we have as a result of the modification and
    // the differences represent the things we need to change.
    //
    CNetConfigCore  m_CoreStartedWith;

    // These bindings are the added bindpaths (due to adding components)
    // These represent bindings that have been queried and notified to
    // notify objects.
    //
    CBindingSet     m_AddedBindPaths;

    // These bindings are the deleted bindpaths (due to removing components)
    // These represent bindings that have been notified to notify objects.
    //
    CBindingSet     m_DeletedBindPaths;

    // These components are all the components involved in m_AddedBindPaths
    // and m_DeletedBindPaths.  As such, they are the components we need
    // to visit during Apply to write bindings for, delete bindings for,
    // or finish removal of depending on whether the components exist in
    // the core we started with.  Components can get in this list if they
    // have had their bind order changed, or if they were involved in a
    // binding that has been enabled or disabled.
    //
    CComponentList  m_DirtyComponents;

    // The purpose of the binding context is just to allow us to make one
    // allocation (and use it over and over) for the buffer which holds the
    // bind strings that get written to the registry.  We make this allocation
    // up front when the modify context is prepared.  Doing so minimizes the
    // risk of getting half-way through apply and then finding out we are so
    // low on memory that we cannot allocate a buffer to write the registry
    // bindings with.
    //
    CRegistryBindingsContext    m_RegBindCtx;

    ULONG           m_ulRecursionDepth;
    HRESULT         m_hr;
    BOOLEAN         m_fPrepared;

    // Set when a notify object says they need to reboot in order for changes
    // to take affect.  Setting this will not REQUIRE us to reboot, it will
    // only cause NETCFG_S_REBOOT to be returned from the install or remove
    // operation.
    //
    BOOLEAN         m_fRebootRecommended;

    // Set when a component that is being removed fails to stop.  When it
    // does, its service will be marked as 'pending delete'.  We cannot allow
    // any other config changes to happen when we are in this state because
    // if that service ever needs to be re-installed, we will fail.
    //
    BOOLEAN         m_fRebootRequired;

#if DBG
    // This flag indicates that we've dirtied a component outside of
    // ApplyChanges.  We will do this when bind order changes, and when
    // INetCfgComponentPrivate::SetDirty or
    // INetCfgComponentPrivate::NotifyUpperEdgeConfigChange are called.
    // If this flag is TRUE, m_fDirtyComponents will not be empty upon
    // entering ApplyChanges.  Normally, when this flag is FALSE,
    // m_fDirtyComponents should be empty when entering ApplyChanges.
    // If it were not, it would probably mean we forgot to empty it after
    // the last Apply or Cancel and are now risking applying changes to
    // components which really are not dirty.
    //
    BOOLEAN         m_fComponentExplicitlyDirtied;
#endif

private:
    VOID
    PushRecursionDepth ();

    HRESULT
    HrPopRecursionDepth ();

    VOID
    ApplyChanges ();

    VOID
    InstallAndAddAndNotifyComponent (
        IN const COMPONENT_INSTALL_PARAMS& Params,
        OUT CComponent** ppComponent);

    VOID
    InstallConvenienceComponentsForUser (
        IN const CComponent* pComponent);

    VOID
    InstallOrRemoveRequiredComponents (
        IN CComponent* pComponent,
        IN IOR_ACTION Action);

    VOID
    NotifyAndRemoveComponent (
        IN CComponent* pComponent);

    HRESULT
    HrProcessWinsockRemove (
        IN const CComponent* pComponent);

public:
    CNetConfig*
    PNetConfig ();

    HRESULT
    HrBeginBatchOperation ();

    HRESULT
    HrEndBatchOperation (
        IN EBO_FLAG Flag);

    HRESULT
    HrDirtyComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrDirtyComponentAndComponentsAbove (
        IN const CComponent* pComponent);

    HRESULT
    HrApplyIfOkOrCancel (
        IN BOOL fApply);

    HRESULT
    HrPrepare ();

    HRESULT
    HrEnableOrDisableBindPath (
        IN DWORD dwChangeFlag,
        IN CBindPath* pBindPath,
        IN INetCfgBindingPath* pIPath OPTIONAL);

    HRESULT
    HrInstallNewOrReferenceExistingComponent (
        IN const COMPONENT_INSTALL_PARAMS& Params,
        OUT CComponent** ppComponent);

    HRESULT
    HrRemoveComponentIfNotReferenced (
        IN CComponent* pComponent,
        IN OBO_TOKEN* pOboToken OPTIONAL,
        OUT PWSTR* ppmszwRefs OPTIONAL);

    HRESULT
    HrUpdateComponent (
        IN CComponent* pComponent,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo);
};


class CNetConfig
{
public:
    // This is the core data managed by this object.  The reason it
    // is encapsulated by NETCFG_CORE is so that we can save it away before
    // we being any modify operation.  (We save it into
    // CModifyContext.m_StartedWith.)  In the event of a failure to modify
    // we restore the core data from what we started with.
    //
    CNetConfigCore          Core;

    // The interface to all notify objects representing the components.
    //
    CGlobalNotifyInterface  Notify;

    CModifyContext          ModifyCtx;

public:
    CNetConfig ()
    {
        TraceFileFunc(ttidNetcfgBase);
        ZeroMemory (this, sizeof(*this));
    }

    ~CNetConfig ();

    HRESULT
    HrEnsureExternalDataLoadedForAllComponents ();

    static HRESULT
    HrCreateInstance (
        IN class CImplINetCfg* pINetCfg,
        OUT CNetConfig** ppNetConfig);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\persist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P E R S I S T . C P P
//
//  Contents:   Module repsonsible for persistence of the network
//              configuration information.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "persist.h"
#include "ncreg.h"

#if defined (_X86_)
inline BOOL IsRunningOnWow64()
{
    static DWORD dwCachedWow64 = DWORD_MAX;
    if (DWORD_MAX == dwCachedWow64)
    {
        BOOL fTempWow64;
        if (IsWow64Process(GetCurrentProcess(), &fTempWow64))
        {
            dwCachedWow64 = fTempWow64;
        }
        else
        {
            AssertSz(FALSE, "Could not determine whether this is a WOW64 process.");
            return FALSE;
        }
    }

    return dwCachedWow64;
}

inline size_t ALIGNUP(size_t nSize)
{
    // If we are a 32-bit app running on a 64-bit O/S we need to use 64-bit alignment when reading or writing from the registry.
    if (IsRunningOnWow64())
    {
        return ((nSize + (sizeof(DWORD64) - 1)) & ~(sizeof(DWORD64) - 1));
    }
    else
    {
        return nSize;
    }
}

#elif defined (_WIN64) 
    #define ALIGNUP(x) ((x + (sizeof(PVOID) - 1)) & ~(sizeof(PVOID) - 1))

#else
    #error Please define an ALIGNUP implementation for this architecture.

#endif

#define alignedsizeof(x) ALIGNUP(sizeof(x))

const DWORD CURRENT_VERSION = 0;

HRESULT
HrLoadNetworkConfigurationFromBuffer (
    IN const BYTE* pbBuf,
    IN ULONG cbBuf,
    OUT CNetConfig* pNetConfig)
{
    HRESULT hr;
    DWORD dwVersion;
    ULONG cComponents;
    ULONG cStackEntries;
    ULONG cBindPaths;
    ULONG unUpperIndex;
    ULONG unLowerIndex;
    ULONG unComponentIndex;
    BOOL fRefByUser;
    BASIC_COMPONENT_DATA Data;
    CComponentList* pComponents;
    CComponent* pComponent;
    CStackEntry StackEntry;
    CBindPath BindPath;
    PCWSTR pszString;

    // We should be starting clean.
    //
    Assert (pNetConfig->Core.FIsEmpty());

    hr = S_OK;

    // Load the version marker.
    //
    dwVersion = *(DWORD32*)pbBuf;
    pbBuf += alignedsizeof(DWORD32);

    if (dwVersion > CURRENT_VERSION)
    {
        hr = E_UNEXPECTED;
        goto finished;
    }

    // Load the component list.
    //
    cComponents = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    while (cComponents--)
    {
        ZeroMemory (&Data, sizeof(Data));

        Data.InstanceGuid = *(GUID*)pbBuf;
        pbBuf += alignedsizeof(GUID);

        Data.Class = *(NETCLASS*)pbBuf;
        pbBuf += alignedsizeof(NETCLASS);

        Data.dwCharacter = *(DWORD32*)pbBuf;
        pbBuf += alignedsizeof(DWORD32);

        Data.pszInfId = (PCWSTR)pbBuf;
        Assert (*Data.pszInfId);
        pbBuf += ALIGNUP(CbOfSzAndTerm (Data.pszInfId));

        pszString = (PCWSTR)pbBuf;
        pbBuf += ALIGNUP(CbOfSzAndTerm (pszString));
        if (*pszString)
        {
            Data.pszPnpId = pszString;
        }

        hr = CComponent::HrCreateInstance (
                &Data,
                CCI_DEFAULT,
                NULL,
                &pComponent);
        if (S_OK == hr)
        {
            hr = pNetConfig->Core.Components.HrInsertComponent (
                    pComponent, INS_ASSERT_IF_DUP | INS_NON_SORTED);
        }

        if (S_OK != hr)
        {
            goto finished;
        }
    }

    // Load the stack table.
    //
    pComponents = &pNetConfig->Core.Components;

    pNetConfig->Core.StackTable.m_fWanAdaptersFirst = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    cStackEntries = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    while (cStackEntries--)
    {
        ZeroMemory (&StackEntry, sizeof(StackEntry));

        unUpperIndex = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        unLowerIndex = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        StackEntry.pUpper = pComponents->PGetComponentAtIndex (
                                unUpperIndex);

        StackEntry.pLower = pComponents->PGetComponentAtIndex (
                                unLowerIndex);

        // Insert in the order we persisted.  If we used ISE_SORT here, we'd
        // blow away whatever bind order we saved.
        //
        hr = pNetConfig->Core.StackTable.HrInsertStackEntry (
                &StackEntry, INS_NON_SORTED);
        if (S_OK != hr)
        {
            goto finished;
        }
    }

    // Load the disabled bindpaths.
    //
    cBindPaths = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    while (cBindPaths--)
    {
        cComponents = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        BindPath.Clear();

        while (cComponents--)
        {
            unComponentIndex = *(ULONG32*)pbBuf;
            pbBuf += alignedsizeof(ULONG32);

            pComponent = pComponents->PGetComponentAtIndex (unComponentIndex);
            Assert (pComponent);

            hr = BindPath.HrAppendComponent (pComponent);
            if (S_OK != hr)
            {
                goto finished;
            }
        }

        hr = pNetConfig->Core.DisabledBindings.HrAddBindPath (
                &BindPath, INS_ASSERT_IF_DUP | INS_APPEND);

        if (S_OK != hr)
        {
            goto finished;
        }
    }

    // Load the component references.
    //
    cComponents = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    while (cComponents--)
    {
        unComponentIndex = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        pComponent = pComponents->PGetComponentAtIndex (unComponentIndex);
        Assert (pComponent);

        fRefByUser = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        if (fRefByUser)
        {
            hr = pComponent->Refs.HrAddReferenceByUser ();
            if (S_OK != hr)
            {
                goto finished;
            }
        }

        // Load the count of components that reference this component.
        //
        ULONG CountRefdBy = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        // Load the indicies of the components that reference this component.
        //
        for (UINT i = 0; i < CountRefdBy; i++)
        {
            unComponentIndex = *(ULONG32*)pbBuf;
            pbBuf += alignedsizeof(ULONG32);

            CComponent* pRefdBy;
            pRefdBy = pComponents->PGetComponentAtIndex (unComponentIndex);
            Assert (pRefdBy);

            hr = pComponent->Refs.HrAddReferenceByComponent (pRefdBy);
            if (S_OK != hr)
            {
                goto finished;
            }
        }

        // Load the count of strings that represent external software
        // that reference this component.
        //
        CountRefdBy = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        // Load the strings that represent external software that
        // references this component.
        //
        for (i = 0; i < CountRefdBy; i++)
        {
            pszString = (PCWSTR)pbBuf;
            pbBuf += ALIGNUP(CbOfSzAndTerm (pszString));

            hr = pComponent->Refs.HrAddReferenceBySoftware (pszString);
            if (S_OK != hr)
            {
                goto finished;
            }
        }
    }

finished:
    if (S_OK != hr)
    {
        pNetConfig->Core.DisabledBindings.Clear ();
        pNetConfig->Core.StackTable.Clear ();
        FreeCollectionAndItem (pNetConfig->Core.Components);
    }
    return hr;
}

HRESULT
HrLoadNetworkConfigurationFromRegistry (
    IN REGSAM samDesired,
    OUT CNetConfig* pNetConfig)
{
    HRESULT hr;
    HKEY hkeyNetwork;

    Assert ((KEY_READ == samDesired) || (KEY_WRITE == samDesired));

    hr = HrOpenNetworkKey (KEY_READ, &hkeyNetwork);

    if (S_OK == hr)
    {
        BYTE* pbBuf;
        ULONG cbBuf;

        hr = HrRegQueryBinaryWithAlloc (
                hkeyNetwork,
                L"Config",
                &pbBuf, &cbBuf);

        // If we read the config binary, use it to initialize pNetConfig.
        //
        if (S_OK == hr)
        {
            hr = HrLoadNetworkConfigurationFromBuffer (pbBuf, cbBuf,
                    pNetConfig);

            if (S_OK == hr)
            {
                pNetConfig->Core.DbgVerifyData ();
            }

            MemFree (pbBuf);
        }
        // Otherwise, if we couldn't read the config binary, we'll have
        // to construct what we can by grovelling the registry.
        //
        else
        {
            hr = HrLoadNetworkConfigurationFromLegacy (pNetConfig);

            if (S_OK == hr)
            {
                hr = HrSaveNetworkConfigurationToRegistry (pNetConfig);
            }
        }

        RegCloseKey (hkeyNetwork);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadNetworkConfigurationFromRegistry");
    return hr;
}

ULONG
CountComponentsReferencedByOthers (
    IN CNetConfig* pNetConfig)
{
    ULONG cComponents;
    CComponentList::iterator iter;
    CComponent* pComponent;

    cComponents = 0;

    for (iter  = pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (pComponent->Refs.FIsReferencedByOthers ())
        {
            cComponents++;
        }
    }

    return cComponents;
}

HRESULT
HrSaveNetworkConfigurationToBuffer (
    IN CNetConfig* pNetConfig,
    IN BYTE* pbBuf,
    IN OUT ULONG* pcbBuf)
{
    HRESULT hr;
    ULONG cbBuf;
    ULONG cbBufIn;
    ULONG unIndex;
    ULONG Count;
    CComponentList* pComponents;
    CComponent* pComponent;
    CStackEntry* pStackEntry;
    CBindPath* pBindPath;
    PCWSTR pszString;

    Assert (pNetConfig);
    pNetConfig->Core.DbgVerifyData ();
    Assert (pcbBuf);

    cbBufIn = *pcbBuf;
    cbBuf = 0;
    pComponents = &pNetConfig->Core.Components;

    // Save the version number.
    //
    cbBuf += alignedsizeof(DWORD32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(DWORD32*)pbBuf = CURRENT_VERSION;
        pbBuf += alignedsizeof(DWORD32);
    }

    // Save the component list.
    //
    Count = pComponents->Count();
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = Count;
        pbBuf += alignedsizeof(ULONG32);
    }

    for (unIndex = 0; unIndex < Count; unIndex++)
    {
        pComponent = pComponents->PGetComponentAtIndex (unIndex);
        Assert (pComponent);

        pszString = (pComponent->m_pszPnpId) ? pComponent->m_pszPnpId : L"";

        ULONG cbInfIdUnpad = CbOfSzAndTerm (pComponent->m_pszInfId);
        ULONG cbPnpIdUnpad = CbOfSzAndTerm (pszString);

        ULONG cbInfId = ALIGNUP(cbInfIdUnpad);
        ULONG cbPnpId = ALIGNUP(cbPnpIdUnpad);

        cbBuf += alignedsizeof(GUID) + alignedsizeof(NETCLASS) + alignedsizeof(DWORD32) +
                 cbInfId +
                 cbPnpId;

        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(GUID*)pbBuf = pComponent->m_InstanceGuid;
            pbBuf += alignedsizeof(GUID);

            *(NETCLASS*)pbBuf = pComponent->Class();
            pbBuf += alignedsizeof(NETCLASS);

            *(DWORD32*)pbBuf = pComponent->m_dwCharacter;
            pbBuf += alignedsizeof(DWORD32);

            CopyMemory(pbBuf, pComponent->m_pszInfId, cbInfIdUnpad);
            pbBuf += cbInfId;

            CopyMemory(pbBuf, pszString, cbPnpIdUnpad);
            pbBuf += cbPnpId;
        }
    }

    // Save the stack table.
    //
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = pNetConfig->Core.StackTable.m_fWanAdaptersFirst;
        pbBuf += alignedsizeof(ULONG32);
    }

    Count = pNetConfig->Core.StackTable.CountEntries();
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = Count;
        pbBuf += alignedsizeof(ULONG32);
    }

    for (pStackEntry  = pNetConfig->Core.StackTable.begin();
         pStackEntry != pNetConfig->Core.StackTable.end();
         pStackEntry++)
    {
        cbBuf += alignedsizeof(ULONG32) + alignedsizeof(ULONG32);

        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = pComponents->UnGetIndexOfComponent (pStackEntry->pUpper);
            pbBuf += alignedsizeof(ULONG32);

            *(ULONG32*)pbBuf = pComponents->UnGetIndexOfComponent (pStackEntry->pLower);
            pbBuf += alignedsizeof(ULONG32);
        }
    }

    // Save the disabled bindpaths.
    //
    Count = pNetConfig->Core.DisabledBindings.CountBindPaths();
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = Count;
        pbBuf += alignedsizeof(ULONG32);
    }
    for (pBindPath  = pNetConfig->Core.DisabledBindings.begin();
         pBindPath != pNetConfig->Core.DisabledBindings.end();
         pBindPath++)
    {
        Count = pBindPath->CountComponents();
        cbBuf += alignedsizeof(ULONG32) + (Count * alignedsizeof(ULONG32));
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = Count;
            pbBuf += alignedsizeof(ULONG32);

            CBindPath::iterator iter;
            for (iter  = pBindPath->begin();
                 iter != pBindPath->end();
                 iter++)
            {
                pComponent = *iter;
                *(ULONG32*)pbBuf = pComponents->UnGetIndexOfComponent (pComponent);
                pbBuf += alignedsizeof(ULONG32);
            }
        }

    }

    // Save the component references.
    //
    Count = CountComponentsReferencedByOthers (pNetConfig);
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = Count;
        pbBuf += alignedsizeof(ULONG32);
    }

    for (unIndex = 0; unIndex < pComponents->Count(); unIndex++)
    {
        pComponent = pComponents->PGetComponentAtIndex (unIndex);
        Assert (pComponent);

        if (!pComponent->Refs.FIsReferencedByOthers ())
        {
            continue;
        }

        // Index of component with the references.
        //
        cbBuf += alignedsizeof(ULONG32);
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = unIndex;
            pbBuf += alignedsizeof(ULONG32);
        }

        // Save whether the component is refernced by the user or not.
        //
        cbBuf += alignedsizeof(ULONG32);
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = pComponent->Refs.FIsReferencedByUser() ? 1 : 0;
            pbBuf += alignedsizeof(ULONG32);
        }

        // Save the count of components that reference this component.
        //
        ULONG CountRefdBy = pComponent->Refs.CountComponentsReferencedBy ();
        cbBuf += alignedsizeof(ULONG32);
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = CountRefdBy;
            pbBuf += alignedsizeof(ULONG32);
        }

        // Save the indicies of the components that reference this component.
        //
        for (UINT i = 0; i < CountRefdBy; i++)
        {
            CComponent* pRefdBy;
            pRefdBy = pComponent->Refs.PComponentReferencedByAtIndex(i);
            Assert (pRefdBy);

            cbBuf += alignedsizeof(ULONG32);
            if (pbBuf && (cbBuf <= cbBufIn))
            {
                *(ULONG32*)pbBuf = pComponents->UnGetIndexOfComponent (pRefdBy);
                pbBuf += alignedsizeof(ULONG32);
            }
        }

        // Save the count of strings that represent external software
        // that reference this component.
        //
        CountRefdBy = pComponent->Refs.CountSoftwareReferencedBy ();
        cbBuf += alignedsizeof(ULONG32);
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = CountRefdBy;
            pbBuf += alignedsizeof(ULONG32);
        }

        // Save the strings that represent external software that
        // reference this component.
        //
        for (i = 0; i < CountRefdBy; i++)
        {
            const CWideString* pStr;
            pStr = pComponent->Refs.PSoftwareReferencedByAtIndex(i);
            Assert (pStr);

            ULONG cb = (pStr->length() + 1) * sizeof(WCHAR);

            cbBuf += ALIGNUP(cb);
            if (pbBuf && (cbBuf <= cbBufIn))
            {
                CopyMemory (pbBuf, pStr->c_str(), cb);
                pbBuf += ALIGNUP(cb);
            }
        }
    }


    *pcbBuf = cbBuf;
    if (cbBuf <= cbBufIn)
    {
        hr = S_OK;
    }
    else
    {
        hr = (pbBuf) ? HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) : S_OK;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrSaveNetworkConfigurationToBuffer");
    return hr;
}

HRESULT
HrSaveNetworkConfigurationToBufferWithAlloc (
    IN CNetConfig* pNetConfig,
    OUT BYTE** ppbBuf,
    OUT ULONG* pcbBuf)
{
    HRESULT hr;

    Assert (pNetConfig);
    Assert (ppbBuf);
    Assert (pcbBuf);

    *ppbBuf = NULL;
    *pcbBuf = 0;

    ULONG cbBuf;
    hr = HrSaveNetworkConfigurationToBuffer (pNetConfig, NULL, &cbBuf);
    if (S_OK == hr)
    {
        hr = E_OUTOFMEMORY;
        *ppbBuf = (BYTE*)MemAlloc (cbBuf);
        if (*ppbBuf)
        {
            hr = HrSaveNetworkConfigurationToBuffer (
                    pNetConfig, *ppbBuf, &cbBuf);
            if (S_OK == hr)
            {
                *pcbBuf = cbBuf;
            }
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrSaveNetworkConfigurationToBufferWithAlloc");
    return hr;
}

HRESULT
HrSaveNetworkConfigurationToRegistry (
    IN  CNetConfig* pNetConfig)
{
    HRESULT hr;
    HKEY hkeyNetwork;

    Assert (pNetConfig);
    pNetConfig->Core.DbgVerifyData ();

    hr = HrOpenNetworkKey (KEY_WRITE, &hkeyNetwork);

    if (S_OK == hr)
    {
        BYTE* pbBuf;
        ULONG cbBuf;

        hr = HrSaveNetworkConfigurationToBufferWithAlloc (
                pNetConfig, &pbBuf, &cbBuf);

        if (S_OK == hr)
        {
            hr = HrRegSetBinary (hkeyNetwork, L"Config", pbBuf, cbBuf);

            MemFree (pbBuf);

            // Permission from the Perf team to call this.  We need to ensure
            // that the configuration we just wrote will be available on
            // next boot in the case that we crash.
            //
            RegFlushKey (hkeyNetwork);
        }

        RegCloseKey (hkeyNetwork);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrSaveNetworkConfigurationToRegistry");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\pnpbind.h ===
#pragma once
#include "bindings.h"

UINT
GetPnpLayerForBindPath (
    IN const CBindPath* pBindPath);

HRESULT
HrPnpUnloadDriver (
    IN UINT Layer,
    IN PCWSTR pszComponentBindName);

VOID
PruneNdisWanBindPathsIfActiveRasConnections (
    IN CBindingSet* pBindSet,
    OUT BOOL* pfRebootNeeded);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\persist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P E R S I S T . H
//
//  Contents:   Module repsonsible for persistence of the network
//              configuration information.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfg.h"

HRESULT
HrLoadNetworkConfigurationFromBuffer (
    IN const BYTE* pbBuf,
    IN ULONG cbBuf,
    OUT CNetConfig* pNetConfig);

HRESULT
HrLoadNetworkConfigurationFromLegacy (
    OUT CNetConfig* pNetConfig);

HRESULT
HrLoadNetworkConfigurationFromRegistry (
    IN REGSAM samDesired,
    OUT CNetConfig* pNetConfig);


HRESULT
HrSaveNetworkConfigurationToBuffer (
    IN CNetConfig* pNetConfig,
    IN BYTE* pbBuf,
    OUT ULONG* pcbBuf);

HRESULT
HrSaveNetworkConfigurationToBufferWithAlloc (
    IN CNetConfig* pNetConfig,
    OUT BYTE** ppbBuf,
    OUT ULONG* pcbBuf);

HRESULT
HrSaveNetworkConfigurationToRegistry (
    IN CNetConfig* pNetConfig);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\provider.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       P R O V I D E R . C P P
//
//  Contents:   Net component installer functions for Net providers.
//
//  Notes:
//
//  Author:     billbe   22 Mar 1997
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "provider.h"
#include "winspool.h"
#include "ncmisc.h"

// constants
//

extern const WCHAR c_szDevice[];
extern const WCHAR c_szProviderOrder[];
extern const WCHAR c_szRegKeyCtlNPOrder[];
extern const WCHAR c_szRegKeyServices[];

const WCHAR c_chComma                       = L',';
const WCHAR c_szDeviceName[]                = L"DeviceName";
const WCHAR c_szDisplayName[]               = L"DisplayName";
const WCHAR c_szInfKeyPrintProviderDll[]    = L"PrintProviderDll";
const WCHAR c_szInfSubKeyPrintProvider[]    = L"PrintProvider";
const WCHAR c_szNetworkProvider[]           = L"NetworkProvider";
const WCHAR c_szPrintProviderName[]         = L"PrintProviderName";
const WCHAR c_szRegKeyPrintProviders[]      = L"System\\CurrentControlSet\\Control\\Print\\Providers";
const WCHAR c_szRegKeyShortName[]           = L"System\\CurrentControlSet\\Control\\NetworkProvider\\ShortName";
const WCHAR c_szRegValueName[]              = L"Name";
const WCHAR c_szRegValueOrder[]             = L"Order";
const WCHAR c_szShortName[]                 = L"ShortName";


// Functions
//
HRESULT
HrCiCreateShortNameValueIfNeeded(HINF hinf, HKEY hkeyNetworkProvider,
                                 const tstring& strSection,
                                 tstring* pstrShortName);

HRESULT
HrCiSetDeviceName(HINF hinf, HKEY hkeyNetworkProvider,
                  const tstring& strSection, const tstring& strServiceName);

HRESULT
HrCiWritePrintProviderInfoIfNeeded(HINF hinfFile, const tstring& strSection,
                                   HKEY hkeyInstance, DWORD dwPrintPosition);

HRESULT
HrCiAddPrintProvider(const tstring& strName, const tstring& strDllName,
                     const tstring& strDisplayName, DWORD dwPrintPosition);

HRESULT
HrCiDeletePrintProviderIfNeeded(HKEY hkeyInstance, DWORD* pdwProviderPosition);


//+--------------------------------------------------------------------------
//
//  Function:   HrCiAddNetProviderInfo
//
//  Purpose:    Adds the current component to the list of network
//                  providers and also adds it as a print provider if
//                  necessary.
//
//  Arguments:
//      hinf                    [in] Handle to component's inf file
//      strSection              [in] Main inf section
//      hkeyInstance            [in] Component's instance key
//      fPreviouslyInstalled    [in] TRUE if this component is being
//                                      reinstalled, FALSE otherwise
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise
//
//  Author:     billbe   22 Mar 1997
//              updated  7 Oct 1997
//
//  Notes:
//
HRESULT
HrCiAddNetProviderInfo(HINF hinf, PCWSTR pszSection,
                       HKEY hkeyInstance, BOOL fPreviouslyInstalled)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);
    Assert(hkeyInstance);

    //tstring strServiceName;
    DWORD   dwNetworkPosition = 0; // default position is the front.
    DWORD   dwPrintPosition = 0; // default position is the front.

    if (fPreviouslyInstalled)
    {
        // Because the inf may contain modifications to the print provider.
        // e.g. Display name change, dll name change, etc.  We delete it
        // then readd.  We would like to just update the information
        // but the print provider api doesn't support it yet.  Until
        // then, we need to delete and readd to pick up changes.
        //
        (void) HrCiDeleteNetProviderInfo(hkeyInstance, &dwNetworkPosition,
                &dwPrintPosition);
        TraceTag(ttidClassInst, "Upgrading provider info. Net Prov Pos %d "
                 "Print Prov Pos %d", dwNetworkPosition, dwPrintPosition);
    }

    // Get the service name for this component
    WCHAR szServiceName[MAX_SERVICE_NAME_LEN];
    DWORD cbServiceName = MAX_SERVICE_NAME_LEN * sizeof(WCHAR);

    HKEY hkeyNdi;
    HRESULT hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

    if (S_OK == hr)
    {
        hr = HrRegQuerySzBuffer (
            hkeyNdi,
            L"Service",
            szServiceName,
            &cbServiceName);
        RegCloseKey (hkeyNdi);
    }

    if (S_OK == hr)
    {
        // If this is Webclient we need to make sure it is after
        // lanmanworkstation in the ordering.  This should be temporary
        // until mpr.dll is updated to return the union of provider
        // information.  Right now a server can source smb shares and
        // webclient shares but only one set can be retrieved via the mpr.
        // Since smb shares are more common, lanmanworkstation needs to be
        // before webclient.  When mpr.dll changes, both sets will be returned
        // and ordering shouldn't matter (expect for performance).
        //
        if (0 == lstrcmpiW(szServiceName, L"WebClient"))
        {
            HKEY hkeyNP;
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyCtlNPOrder,
                KEY_READ, &hkeyNP);
            if (S_OK == hr)
            {
                PWSTR Order;
                hr = HrRegQuerySzWithAlloc(hkeyNP, c_szProviderOrder, &Order);

                if (S_OK == hr)
                {
                    DWORD dwPosition;
                    if (FFindStringInCommaSeparatedList(L"LanmanWorkstation",
                            Order, NC_IGNORE, &dwPosition))
                    {
                        dwNetworkPosition = dwPosition + 1;
                    }
                    delete [] Order;
                }
                RegCloseKey(hkeyNP);
            }
        }

        TraceTag(ttidClassInst, "Adding %S to the network provider "
                 "order at position %d\n", szServiceName, dwNetworkPosition);

        // Add it to the list of network providers
        hr = HrRegAddStringToSz(szServiceName, HKEY_LOCAL_MACHINE,
                c_szRegKeyCtlNPOrder, c_szProviderOrder,
                c_chComma, STRING_FLAG_ENSURE_AT_INDEX, dwNetworkPosition);

        if (S_OK == hr)
        {
            tstring strNetworkProvider = c_szRegKeyServices;
            strNetworkProvider.append(L"\\");
            strNetworkProvider.append(szServiceName);
            strNetworkProvider.append(L"\\");
            strNetworkProvider.append(c_szNetworkProvider);

            // Open the NetworkProvider key under the component's
            // service key
            //
            HKEY hkey;
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    strNetworkProvider.c_str(), KEY_SET_VALUE | KEY_READ,
                    &hkey);

            if (S_OK == hr)
            {
                // Check if shortname is needed.
                // by looking for it in the option
                // <main install section>.NetworkProvider section
                //
                tstring strNetworkSection(pszSection);
                strNetworkSection += L'.';
                strNetworkSection += c_szNetworkProvider;

                tstring strShortName;
                HRESULT hr = HrCiCreateShortNameValueIfNeeded(hinf,
                        hkey, strNetworkSection, &strShortName);

                if (S_OK == hr)
                {
                    // If shortname was created then we need to
                    // also store it under the instance
                    // key so we can remove it when the component
                    // is removed
                    (void) HrRegSetString(hkeyInstance,
                            c_szShortName, strShortName);
                }

                // Set the device name in the NetworkProvider key
                // under the componet's service key
                //
                if (SUCCEEDED(hr))
                {
                    hr = HrCiSetDeviceName(hinf, hkey, strNetworkSection,
                            szServiceName);
                }

                RegCloseKey(hkey);
            }
        }
    }

    // Write out any print provider information if the inf file specifies it
    //
    if (S_OK == hr)
    {
        hr = HrCiWritePrintProviderInfoIfNeeded(hinf, pszSection,
                hkeyInstance, dwPrintPosition);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiAddNetProviderInfo");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiDeleteNetProviderInfo
//
//  Purpose:    Deletes the current component from the list of network
//                  providers and also deletes it as a print provider if
//                  necessary.
//
//  Arguments:
//      hkeyInstance       [in] The handle to the component's isntance key.
//      pdwNetworkPosition [out] Optional. The positon pf this component in
//                               the network provider order before removal.
//      pdwPrintPosition   [out] Optional. The positon of this component in
//                               the print provider order before removal.
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise
//
//  Author:     billbe   22 Mar 1997
//              updated  7 Oct 1997
//
//  Notes:
//
HRESULT
HrCiDeleteNetProviderInfo(HKEY hkeyInstance, DWORD* pdwNetworkPosition,
        DWORD* pdwPrintPosition)
{
    Assert(hkeyInstance);

    // Initialize out param.
    if (pdwNetworkPosition)
    {
        *pdwNetworkPosition = 0;
    }

    // Initialize out param.
    if (pdwPrintPosition)
    {
        *pdwPrintPosition = 0;
    }

    WCHAR szServiceName[MAX_SERVICE_NAME_LEN];
    DWORD cbServiceName = MAX_SERVICE_NAME_LEN * sizeof(WCHAR);
    // Get the service name for this component.

    HKEY hkeyNdi;
    HRESULT hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

    if (S_OK == hr)
    {
        hr = HrRegQuerySzBuffer (
            hkeyNdi,
            L"Service",
            szServiceName,
            &cbServiceName);
        RegCloseKey(hkeyNdi);
    }

    if (S_OK == hr)
    {
        // Open the network provider key.
        //
        HKEY hkeyNetProvider;
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyCtlNPOrder,
                KEY_READ_WRITE, &hkeyNetProvider);

        if (S_OK == hr)
        {
            PWSTR pszOrder = NULL;
            PWSTR pszNewOrder;
            DWORD dwNetPos;

            // Get the current list of providers.
            //
            hr = HrRegQuerySzWithAlloc(hkeyNetProvider,
                    c_szProviderOrder, &pszOrder);

            // If we managed to get the list and the provider we are
            // removing is in the list...
            //
            if ((S_OK == hr) && FFindStringInCommaSeparatedList(
                    szServiceName, pszOrder,
                    NC_IGNORE, &dwNetPos))
            {
                // Remove the provider from the list.
                hr = HrRemoveStringFromDelimitedSz(szServiceName,
                        pszOrder, c_chComma, STRING_FLAG_REMOVE_ALL,
                        &pszNewOrder);

                if (S_OK == hr)
                {
                    // Set the new provider list back in the registry.
                    (void) HrRegSetSz(hkeyNetProvider, c_szProviderOrder,
                            pszNewOrder);
                    MemFree (pszNewOrder);
                }

                // If the out param was specified, set the position.
                //
                if (pdwNetworkPosition)
                {
                    *pdwNetworkPosition = dwNetPos;
                }
            }
            MemFree(pszOrder);
            RegCloseKey(hkeyNetProvider);
        }


        if (S_OK == hr)
        {
            // If short name was used, we need to remove it
            //
            tstring strShortName;
            hr = HrRegQueryString(hkeyInstance, c_szShortName, &strShortName);

            if (S_OK == hr)
            {
                // ShortName was used so remove it
                //
                HKEY hkey;
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyShortName,
                        KEY_SET_VALUE, &hkey);

                if (S_OK == hr)
                {
                    hr = HrRegDeleteValue(hkey, strShortName.c_str());

                    // delete from our instance key as well
                    // Note: we do this because if this component is being
                    // reinstalled, the new inf might not have shortname so
                    // we don't want the old value lying around
                    (void) HrRegDeleteValue(hkeyInstance, c_szShortName);

                    RegCloseKey(hkey);
                }

            }

            // If the value wasn't there (in the driver key or the ShortName key,
            // then there is nothing to delete and everything is okay
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }
        }
    }


    // Delete this component as a print provider if necessary
    //
    if (S_OK == hr)
    {
        hr = HrCiDeletePrintProviderIfNeeded(hkeyInstance, pdwPrintPosition);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiDeleteNetProviderInfo");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiCreateShortNameValueIfNeeded
//
//  Purpose:    Creates the short name value for the component under
//                  the c_szRegKeyShortName registry key if short name is
//                  present in the inf.  The short name value is set to the
//                  display name as found in the NetworkProvider key under
//                  the component's service key
//
//  Arguments:
//      hinf                    [in]  Handle to the component's inf
//      hkeyNetworkProvider     [in]  The hkey to the NetworkProvider
//                                      key under the component's service
//                                      key
//      strSection              [in]  The section name where ShortName
//                                       would be located
//      pstrShortName           [out] The short name found in the inf
//
//  Returns:    HRESULT. S_OK if shortname found, S_FALSE if no shortname was
//                  found, or error code otherwise.
//
//  Author:     billbe  7 Oct 1997
//
//  Notes:
//
HRESULT
HrCiCreateShortNameValueIfNeeded(HINF hinf, HKEY hkeyNetworkProvider,
                                 const tstring& strSection,
                                 tstring* pstrShortName)
{
    Assert(IsValidHandle(hinf));
    Assert(hkeyNetworkProvider);
    Assert(!strSection.empty());
    Assert(pstrShortName);

    INFCONTEXT ctx;

    // Look for optional shortname
    HRESULT hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
            c_szShortName, &ctx);

    if (SUCCEEDED(hr))
    {
        // Get the shortname value
        hr = HrSetupGetStringField(ctx, 1, pstrShortName);

        if (SUCCEEDED(hr))
        {
            HKEY hkey;
            // Create the ShortName key
            hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                    c_szRegKeyShortName, REG_OPTION_NON_VOLATILE,
                    KEY_SET_VALUE, NULL, &hkey, NULL);

            if (SUCCEEDED(hr))
            {
                // Get the provider name to set the short name value
                //
                tstring strProviderName;
                hr = HrRegQueryString(hkeyNetworkProvider, c_szRegValueName,
                        &strProviderName);

                if (SUCCEEDED(hr))
                {
                    // create the component's short name value under
                    // the ShortName key and set it to the component's
                    // display name
                    hr = HrRegSetString(hkey, pstrShortName->c_str(),
                            strProviderName);
                }
                RegCloseKey(hkey);
            }
        }
    }

    // The line and section were optional so if it didn't exists return S_FALSE
    if ((SPAPI_E_LINE_NOT_FOUND == hr) ||
            (SPAPI_E_BAD_SECTION_NAME_LINE == hr))
    {
        hr = S_FALSE;
    }

    // On failure, initialize the out param
    if (FAILED(hr))
    {
        pstrShortName->erase();
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
            "HrCiCreateShortNameValueIfNeeded");
    return hr;

}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiSetDeviceName
//
//  Purpose:    Creates the device name value for the component under
//                  the NetworkProvider key located in the component's
//                  service key. The device name by default is
//                  \Device\<component's service name> unless the inf
//                  specifies a new device name.
//
//  Arguments:
//      hinf                    [in]  Handle to the component's inf
//      hkeyNetworkProvider     [in]  The hkey to the NetworkProvider
//                                      key under the component's service
//                                      key
//      strSection              [in]  The section name where ShortName
//                                       would be located
//      strServiceName          [in]  The component's service name
//
//  Returns:    HRESULT. S_OK if successful, or error code otherwise.
//
//  Author:     billbe  7 Oct 1997
//
//  Notes:
//
HRESULT
HrCiSetDeviceName(HINF hinf, HKEY hkeyNetworkProvider,
                  const tstring& strSection, const tstring& strServiceName)
{
    Assert(IsValidHandle(hinf));
    Assert(hkeyNetworkProvider);

    INFCONTEXT ctx;
    tstring strDeviceName = c_szDevice;

    // Look for optional DeviceName
    HRESULT hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
            c_szDeviceName, &ctx);

    if (SUCCEEDED(hr))
    {
        tstring strName;
        // Get the DeviceName value
        hr = HrSetupGetStringField(ctx, 1, &strName);

        if (SUCCEEDED(hr))
        {
            // append it to the current value
            strDeviceName.append(strName);
        }
    }

    // If the device name line was not found in the inf (or the
    // section name wasn't found), use the service name
    //
    if ((SPAPI_E_LINE_NOT_FOUND == hr) ||
            (SPAPI_E_BAD_SECTION_NAME_LINE == hr))
    {
        strDeviceName.append(strServiceName);
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        // Now set the device name value in the service's networkprovider key
        hr = HrRegSetString(hkeyNetworkProvider, c_szDeviceName,
                strDeviceName);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiSetDeviceName");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetPrintProviderInfoFromInf
//
//  Purpose:    This function gets the display name and dll name from
//                  the print provider section strSection.
//
//  Arguments:
//      hinf            [in] handle to inf file. See SetupApi for more info
//      strSection      [in]  The print provider section name
//      pstrName        [out] The print provider name found in the inf
//      pstrDll         [out] The dll name found in the inf
//      pstrDisplayName [out] The localized display name found in the inf
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe  24 Oct 1997
//
//  Notes:
HRESULT
HrCiGetPrintProviderInfoFromInf(HINF hinf, tstring strSection, tstring* pstrName,
                                tstring* pstrDll, tstring* pstrDisplayName)
{
    Assert(!strSection.empty());
    Assert(pstrName);
    Assert(pstrDll);
    Assert(pstrDisplayName);

    INFCONTEXT ctx;

    // find the line containing non-localized ProviderName
    HRESULT hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
            c_szPrintProviderName, &ctx);

    if (S_OK == hr)
    {
        // Get the ProviderName
        hr = HrSetupGetStringField(ctx, 1, pstrName);

        if (S_OK == hr)
        {
            // Now find and get the PrintProviderDll value
            //
            hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
                    c_szInfKeyPrintProviderDll, &ctx);

            if (S_OK == hr)
            {
                hr = HrSetupGetStringField(ctx, 1, pstrDll);

                if (S_OK == hr)
                {
                    // find the line containing DisplayName
                    hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
                            c_szDisplayName, &ctx);

                    if (S_OK == hr)
                    {
                        // Get the DisplayName
                        hr = HrSetupGetStringField(ctx, 1, pstrDisplayName);
                    }
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetPrintProviderInfoFromInf");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiWritePrintProviderInfoIfNeeded
//
//  Purpose:    This function updates necessary registry entries for
//                  NETCLIENT class components that are print providers.
//
//  Arguments:
//      hinf            [in] handle to inf file. See SetupApi for more info.
//      strSection      [in] The main section name.
//      hkeyInstance    [in] The hkey to the component's instance key.
//      dwPrintPosition [in] The position to place the print provider when
//                           it is added to the list.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   22 Mar 1997
//              updated   7 Oct 1997
//
//  Notes:
HRESULT
HrCiWritePrintProviderInfoIfNeeded(HINF hinf, const tstring& strSection,
                                   HKEY hkeyInstance, DWORD dwPrintPosition)
{
    Assert(IsValidHandle(hinf));
    Assert(!strSection.empty());
    Assert(hkeyInstance);

    HRESULT     hr = S_OK;
    INFCONTEXT  ctx;
    tstring     strDisplayName;
    tstring     strName;
    tstring     strPrintProviderDll;
    tstring     strPrintSection(strSection);

    strPrintSection.append(L".");
    strPrintSection.append(c_szInfSubKeyPrintProvider);

    // First we check for the PrintProvider inf section
    hr = HrSetupFindFirstLine(hinf, strPrintSection.c_str(),  NULL,
            &ctx);

    if (S_OK == hr)
    {
        // Get the print provider information from the inf
        hr = HrCiGetPrintProviderInfoFromInf(hinf, strPrintSection,
                &strName, &strPrintProviderDll, &strDisplayName);

        if (S_OK == hr)
        {
            // Add the component as a print provider
            hr = HrCiAddPrintProvider(strName, strPrintProviderDll,
                    strDisplayName, dwPrintPosition);

            // Now write the Provider name under our instance key
            // so we can remove this provider when asked
            if (S_OK == hr)
            {
                (void) HrRegSetString(hkeyInstance,
                        c_szPrintProviderName, strName);
            }
        }
    }
    else
    {
        // The section is optional so this is not an error
        if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            hr = S_OK;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiWritePrintProviderInfoIfNeeded");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   MoveProviderToIndex
//
//  Purpose:    This function moves the pszProviderName to the position
//              specified.
//
//  Arguments:
//      pszProviderName [in] Name of the print provider (used in call to
//                           AddPrintProvidor.
//      dwPrintPosition [in] The index to place this provider in the
//                           provider order.
//
//  Returns:    nothing
//
//  Author:     billbe   6 Oct 1998
//
//  Notes:
//
VOID
MoveProviderToIndex (
    IN PCWSTR pszProviderName,
    IN DWORD dwPrintPosition)
{
    PROVIDOR_INFO_2  p2info;

    // Open the print provider key
    //
    HKEY hkey;
    HRESULT hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyPrintProviders,
            KEY_READ, &hkey);

    if (S_OK == hr)
    {
        // Retrieve the current order
        //
        PWSTR pmszOrder;
        hr = HrRegQueryMultiSzWithAlloc(hkey, c_szRegValueOrder, &pmszOrder);

        if (S_OK == hr)
        {
            PWSTR pmszNewOrder;
            BOOL fChanged;

            // Move the provider to the front
            //
            hr = HrAddSzToMultiSz(pszProviderName, pmszOrder,
                    STRING_FLAG_ENSURE_AT_INDEX, dwPrintPosition,
                    &pmszNewOrder, &fChanged);

            if ((S_OK == hr) && fChanged)
            {
                // Notify Spooler that we want to change the order
                //
                p2info.pOrder = pmszNewOrder;
                if (!AddPrintProvidor(NULL, 2, (LPBYTE)&p2info))
                {
                    hr = HrFromLastWin32Error();
                    // If we removed duplicates, the last call to
                    // AddPrintProvidor may have failed with
                    // ERROR_INVALID_PARAMETER.  Trying again will correct
                    // the problem.
                    //
                    if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hr)
                    {
                        AddPrintProvidor(NULL, 2,
                                reinterpret_cast<LPBYTE>(&p2info));
                    }

                    TraceHr (ttidError, FAL, hr, FALSE,
                            "AddPrintProvider(class 2) returned an error");
                }

                MemFree(pmszNewOrder);
            }

            MemFree(pmszOrder);
        }
        TraceHr (ttidError, FAL, hr, FALSE, "MoveProviderToIndex");

        RegCloseKey(hkey);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiAddPrintProvider
//
//  Purpose:    This function calls the AddPrintProvidor [sic] function
//                  to add the current component as a provider.
//
//  Arguments:
//      strName         [in] Name of the print provider (used in call to
//                           AddPrintProvidor.
//      strDllName      [in] Dll name of the print provider.
//      strDisplayName  [in] Localized Display Name.
//      dwPrintPosition [in] The position to place this provider when it
//                           is added to the list.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   22 Mar 1997
//              updated   7 Oct 1997
//
//  Notes: See AddPrintProvidor Win32 fcn for more info
HRESULT
HrCiAddPrintProvider(
    const tstring& strName,
    const tstring& strDllName,
    const tstring& strDisplayName,
    DWORD dwPrintPosition)
{
    Assert(!strName.empty());
    Assert(!strDllName.empty());

    PROVIDOR_INFO_1 pi1;
    HRESULT hr=S_OK;

    // Fill the structure with the relevant info
    //
    pi1.pEnvironment = NULL;
    pi1.pDLLName = (PWSTR)strDllName.c_str();
    pi1.pName = (PWSTR)strName.c_str();

    hr = HrEnableAndStartSpooler();
    if (S_OK == hr)
    {
        if (!AddPrintProvidor(NULL, 1, reinterpret_cast<LPBYTE>(&pi1)))
        {
            // convert the error
            hr = HrFromLastWin32Error();
        }
    }

    if (S_OK == hr)
    {
        // AddPrintProvidor adds the print provider to the end of list.
        // 99% of the time, the goal is to have the provider be somewhere
        // else.  We will attempt to move it to the position given to us. This
        // is either the beginning of the list or the previous position of
        // this provider (i.e. if we are reinstalling)  If it fails we can
        // still go on.
        (void) MoveProviderToIndex(pi1.pName, dwPrintPosition);

        tstring strPrintProvider = c_szRegKeyPrintProviders;
        strPrintProvider.append(L"\\");
        strPrintProvider.append(strName);

        HKEY hkey;
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                strPrintProvider.c_str(),
                KEY_SET_VALUE, &hkey);

        if (S_OK == hr)
        {
            // Write DisplayName in the new key created by the
            // AddPrintProvidor [sic] call.
            // Not sure who the consumer of this value is but
            // the NT4 code did this
            hr = HrRegSetString(hkey, c_szDisplayName, strDisplayName);
            RegCloseKey(hkey);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiAddPrintProvider");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiDeletePrintProviderIfNeeded
//
//  Purpose:    This function calls the DeletePrintProvidor [sic] function
//                  if this component was a print provider
//
//  Arguments:
//      hkeyInstance        [in] The hkey for the component's instance key.
//      pdwProviderPosition [out] Optional. The position of the print
//                                provider in the order list before it was
//                                deleted.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   22 Mar 1997
//              updated   7 Oct 1997
//
//  Notes: See DeletePrintProvidor Win32 fcn for more info
//
HRESULT
HrCiDeletePrintProviderIfNeeded(HKEY hkeyInstance, DWORD* pdwProviderPosition)
{
    // Check if this component is a print provider
    //
    tstring strName;
    HRESULT hr = HrRegQueryString(hkeyInstance, c_szPrintProviderName,
            &strName);

    if (SUCCEEDED(hr))
    {
        // If the out param was specified, we may need to get the current position of this print provider
        // in the list of providers
        if (pdwProviderPosition)
        {
            *pdwProviderPosition = 0;

            // Open the print key
            //
            HKEY hkeyPrint;
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyPrintProviders,
                    KEY_READ, &hkeyPrint);

            if (SUCCEEDED(hr))
            {
                // Get the current order of providers
                //
                PWSTR pmszOrder;
                hr = HrRegQueryMultiSzWithAlloc(hkeyPrint,
                        c_szRegValueOrder, &pmszOrder);

                if (S_OK == hr)
                {
                    // Get this provider's current position
                    (void) FGetSzPositionInMultiSzSafe(
                            strName.c_str(), pmszOrder, pdwProviderPosition,
                            NULL, NULL);

                    MemFree(pmszOrder);
                }
                RegCloseKey(hkeyPrint);
            }
        }

        // The component was a print provider so we need to delete it as such
        //
        DeletePrintProvidor(NULL, NULL, (PWSTR)strName.c_str());

        // delete from our instance key as well
        // Note: we do this because if this component is being
        // reinstalled, the new inf might not have a providername so
        // we don't want the old value lying around
        (void) HrRegDeleteValue(hkeyInstance, c_szPrintProviderName);

    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // This component was not a print provider so there
        // is nothing to remove
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiDeletePrintProviderIfNeeded");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\pszarray.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P S Z A R R A Y . H
//
//  Contents:   Implements the basic datatype for a collection of pointers
//              to strings.
//
//  Notes:
//
//  Author:     shaunco   9 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

class CPszArray : public vector<PCWSTR>
{
public:
    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    Count () const
    {
        return size();
    }

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    HRESULT
    HrAddPointer (
        IN PCWSTR psz);

    HRESULT
    HrReserveRoomForPointers (
        IN UINT cPointers);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\pszarray.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P S Z A R R A Y . C P P
//
//  Contents:   Implements the basic datatype for a collection of pointers
//              to strings.
//
//  Notes:
//
//  Author:     shaunco   9 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "nceh.h"
#include "pszarray.h"

HRESULT
CPszArray::HrAddPointer (
    IN PCWSTR psz)
{
    HRESULT hr;

    Assert (this);
    Assert (psz);

    NC_TRY
    {
        push_back (psz);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CPszArray::HrAddPointer");
    return hr;
}

HRESULT
CPszArray::HrReserveRoomForPointers (
    IN UINT cPointers)
{
    HRESULT hr;

    NC_TRY
    {
        reserve (cPointers);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CPszArray::HrReserveRoomForPointers");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\pnpbind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P N P B I N D . C P P
//
//  Contents:   This module is responsible for sending BIND, UNBIND, UNLOAD
//              and RECONFIGURE PnP notifications to NDIS and TDI drivers.
//
//  Notes:
//
//  Author:     shaunco   17 Feb 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nceh.h"
#include "ncras.h"
#include "ndispnp.h"
#include "netcfg.h"

UINT
GetPnpLayerForBindPath (
    IN const CBindPath* pBindPath)
{
    const CComponent* pComponent;
    UINT Layer;

    // Get the component below the component we would be sending the
    // BIND or UNBIND to.
    //
    Assert (pBindPath->CountComponents() > 1);

    pComponent = *(pBindPath->begin() + 1);

    if (FIsEnumerated(pComponent->Class()))
    {
        Layer = NDIS;
    }
    else
    {
        Layer = TDI;
    }

    Assert ((NDIS == Layer) || (TDI == Layer));
    return Layer;
}

HRESULT
HrPnpBindOrUnbind (
    IN UINT Layer,
    IN UINT Operation,
    IN PCWSTR pszComponentBindName,
    IN PCWSTR pszBindString)
{
    HRESULT hr;
    UNICODE_STRING LowerString;
    UNICODE_STRING UpperString;
    UNICODE_STRING BindList;

    Assert ((NDIS == Layer) || (TDI == Layer));
    Assert ((BIND == Operation) || (UNBIND == Operation));
    Assert (pszComponentBindName && *pszComponentBindName);
    Assert (pszBindString && *pszBindString);

    hr = S_OK;

    TraceTag (ttidNetCfgPnp, "PnP Event: %s %s %S - %S",
        (NDIS == Layer) ? "NDIS" : "TDI",
        (BIND == Operation) ? "BIND" : "UNBIND",
        pszComponentBindName,
        pszBindString);

    g_pDiagCtx->Printf (ttidBeDiag, "   PnP Event: %s %s %S - %S\n",
        (NDIS == Layer) ? "NDIS" : "TDI",
        (BIND == Operation) ? "BIND" : "UNBIND",
        pszComponentBindName,
        pszBindString);

    RtlInitUnicodeString (&LowerString, pszBindString);
    RtlInitUnicodeString (&UpperString, pszComponentBindName);

    // Special case for NetBIOS until it can change its bind handler.
    // It blindly dereferences the bind list so we need to make sure it
    // gets down there with a valid (but empty) buffer.  For some reason,
    // the buffer doesn't make it down to kernel mode unless .Length is
    // non-zero.  .MaximumLength is the same as .Length in this case which
    // seems odd.  (The old binding engine sent it this way.)
    //
    // RtlInitUnicodeString (&BindList, L"");  (doesn't work because it
    //  sets .Length to zero.)
    //
    BindList.Buffer = L"";
    BindList.Length = sizeof(WCHAR);
    BindList.MaximumLength = sizeof(WCHAR);

    NC_TRY
    {
        if (!(g_pDiagCtx->Flags() & DF_DONT_DO_PNP_BINDS) ||
            (BIND != Operation))
        {
            BOOL fOk;
            fOk = NdisHandlePnPEvent (
                    Layer,
                    Operation,
                    &LowerString,
                    &UpperString,
                    &BindList,
                    NULL, 0);

            if (!fOk)
            {
                DWORD dwError = GetLastError();

                // Map TDI's version of file not found to the right error.
                //
                if ((TDI == Layer) && (ERROR_GEN_FAILURE == dwError))
                {
                    dwError = ERROR_FILE_NOT_FOUND;
                }

                // ERROR_FILE_NOT_FOUND for UNBIND means it it wasn't
                // bound to begin with.  This is okay.
                //
                // ERROR_FILE_NOT_FOUND for BIND means one of the drivers
                // (above or below) wasn't started.  This is okay too.
                //
                if (ERROR_FILE_NOT_FOUND == dwError)
                {
                    Assert (S_OK == hr);
                }
                else
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "      ^^^ Error = %d\n", dwError);
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
        }
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrPnpBindOrUnbind: %s %s %S - %S\n",
        (NDIS == Layer) ? "NDIS" : "TDI",
        (BIND == Operation) ? "BIND" : "UNBIND",
        pszComponentBindName,
        pszBindString);
    return hr;
}

HRESULT
HrPnpUnloadDriver (
    IN UINT Layer,
    IN PCWSTR pszComponentBindName)
{
    HRESULT hr;
    UNICODE_STRING LowerString;
    UNICODE_STRING UpperString;
    UNICODE_STRING BindList;

    Assert ((NDIS == Layer) || (TDI == Layer));
    Assert (pszComponentBindName && *pszComponentBindName);

    hr = S_OK;

    TraceTag (ttidNetCfgPnp, "PnP Event: UNLOAD %S",
        pszComponentBindName);

    g_pDiagCtx->Printf (ttidBeDiag, "   PnP Event: UNLOAD %S\n",
        pszComponentBindName);

    RtlInitUnicodeString (&LowerString, NULL);
    RtlInitUnicodeString (&UpperString, pszComponentBindName);
    RtlInitUnicodeString (&BindList, NULL);

    NC_TRY
    {
        BOOL fOk;
        fOk = NdisHandlePnPEvent (
                Layer,
                UNLOAD,
                &LowerString,
                &UpperString,
                &BindList,
                NULL, 0);

        if (!fOk)
        {
            DWORD dwError = GetLastError();

            // ERROR_GEN_FAILURE for UNLOAD means the driver does not
            // support UNLOAD.  This is okay.
            //
            if (ERROR_GEN_FAILURE == dwError)
            {
                g_pDiagCtx->Printf (ttidBeDiag, "      %S does not support UNLOAD. "
                    "(Okay)\n",
                    pszComponentBindName);

                Assert (S_OK == hr);
            }
            else
            {
                g_pDiagCtx->Printf (ttidBeDiag, "      ^^^ Error = %d\n", dwError);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }

    // UNLOADs are informational, so we do not trace any errors.
    //
    //TraceHr (ttidError, FAL, hr, FALSE,
    //    "HrPnpUnloadDriver: UNLOAD %S\n",
    //    pszComponentBindName);
    return hr;
}

VOID
CRegistryBindingsContext::PnpBindOrUnbindBindPaths (
    IN UINT Operation,
    IN const CBindingSet* pBindSet,
    OUT BOOL* pfRebootNeeded)
{
    HRESULT hr;
    const CBindPath* pBindPath;
    CBindPath::const_iterator iter;
    const CComponent* pComponent;
    WCHAR szBind [_MAX_BIND_LENGTH];
    UINT Layer;

    Assert ((BIND == Operation) || (UNBIND == Operation));
    Assert (pBindSet);
    Assert (pfRebootNeeded);

    *pfRebootNeeded = FALSE;

    for (pBindPath  = pBindSet->begin();
         pBindPath != pBindSet->end();
         pBindPath++)
    {
        Assert (pBindPath->CountComponents() > 1);

        // Special case for multiple interfaces.  Unless this is the
        // length 2 bindpath of protocol to adapter (e.g. tcpip->ndiswanip),
        // check to see if the adapter on this bindpath expose multiple
        // interfaces from its protocol.  If it does, we're going to skip
        // sending bind notifications.
        //
        // The reason we only do this for bindpaths of length greater than
        // two is because the protocol exposes multiple-interfaces but does
        // not deal with them in its direct binding (i.e. length 2) to the
        // adapter.
        //
        // Note: in future versions, we may not want to skip it.  We do so
        // for now because the legacy binding engine skips them and these
        // bindings aren't active until RAS calls are made anyhow.
        //
        if (pBindPath->CountComponents() > 2)
        {
            const CComponent* pAdapter;
            DWORD cInterfaces;

            // Get the last component in the bindpath and the component
            // just above that.  The last component is the adapter,
            // and the one above the adapter is the protocol.
            //
            iter = pBindPath->end();
            Assert (iter - 2 > pBindPath->begin());

            pComponent = *(iter - 2);
            pAdapter   = *(iter - 1);
            Assert (pComponent);
            Assert (pAdapter);
            Assert (pAdapter == pBindPath->PLastComponent());

            // Calling HrGetInterfaceIdsForAdapter requires the INetCfgComponent
            // interface for the adapter.  If we don't have it, it is likely
            // because the adapter has been removed in which case we don't
            // need to bother asking about how many interfaces it supports.
            //
            if (pComponent->m_pIComp && pAdapter->m_pIComp)
            {
                hr = pComponent->Notify.HrGetInterfaceIdsForAdapter (
                        m_pNetConfig->Notify.PINetCfg(),
                        pAdapter,
                        &cInterfaces,
                        NULL);

                // If multiple interfaces supported for the adapter,
                // continue to the next bindpath.
                //
                if (S_OK == hr)
                {
                    continue;
                }

                // On S_FALSE or an error, continue below.
                hr = S_OK;
            }
        }

        wcscpy (szBind, L"\\Device\\");

        // Skip the first component in each path because it is the
        // component we are issuing the BIND/UNBIND for.
        //
        for (iter  = pBindPath->begin() + 1;
             iter != pBindPath->end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // Assert there is enough room in the bind buffer.
            //
            Assert (wcslen(szBind) + 1 + wcslen(pComponent->Ext.PszBindName())
                        < celems(szBind));

            // If this isn't the first component to come after \Device\,
            // add underscores to seperate the components.
            //
            if (iter != (pBindPath->begin() + 1))
            {
                wcscat (szBind, L"_");
            }

            wcscat (szBind, pComponent->Ext.PszBindName());
        }

        Layer = GetPnpLayerForBindPath (pBindPath);

        hr = HrPnpBindOrUnbind (
                Layer,
                Operation,
                pBindPath->POwner()->Ext.PszBindName(),
                szBind);

        if (S_OK != hr)
        {
            *pfRebootNeeded = TRUE;
        }
    }
}

VOID
PruneNdisWanBindPathsIfActiveRasConnections (
    IN CBindingSet* pBindSet,
    OUT BOOL* pfRebootNeeded)
{
    CBindPath* pBindPath;
    UINT Layer;
    BOOL fExistActiveRasConnections;

    Assert (pBindSet);
    Assert (pfRebootNeeded);

    *pfRebootNeeded = FALSE;

    // Special case for binding/unbinding from ndiswan miniports while
    // active RAS connections exist.  (Don't do it.)  (BUG 344504)
    // (Binding will be to the NDIS layer, the bindpath will have two
    // components, and the service of the last component will be NdisWan.
    // (These are ndiswan miniport devices that behave badly if we
    // unbind them while active connections exist.  Binding them also
    // can disconnect any connections they might be running.)
    // Order of the if is to do the inexpensive checks first.
    //

    if (!FExistActiveRasConnections ())
    {
        return;
    }

    pBindPath  = pBindSet->begin();
    while (pBindPath != pBindSet->end())
    {
        Assert (pBindPath->CountComponents() > 1);

        Layer = GetPnpLayerForBindPath (pBindPath);

        if ((2 == pBindPath->CountComponents()) &&
            (NDIS == Layer) &&
            (0 == _wcsicmp (L"NdisWan", pBindPath->back()->Ext.PszService())))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   Skipping PnP BIND/UNBIND for  %S -> %S  (active RAS connections)\n",
                pBindPath->POwner()->Ext.PszBindName(),
                pBindPath->back()->Ext.PszBindName());

            *pfRebootNeeded = TRUE;

            pBindSet->erase (pBindPath);
        }
        else
        {
            pBindPath++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\provider.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       P R O V I D E R . H
//
//  Contents:   NetClient class installer functions
//
//  Notes:
//
//  Author:     billbe  22 Mar 1997
//
//---------------------------------------------------------------------------

#pragma once

HRESULT
HrCiAddNetProviderInfo(HINF hinf, PCWSTR pszSection,
        HKEY hkeyInstance, BOOL fPreviouslyInstalled);


HRESULT
HrCiDeleteNetProviderInfo(HKEY hkeyInstance, DWORD* pdwNetworkPosition,
        DWORD* pdwPrintPosition);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\regbind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       R E G B I N D . C P P
//
//  Contents:   This module is responsible for writing bindings to the
//              registry so that they may be consumed by NDIS and TDI.
//
//  Notes:
//
//  Author:     shaunco   1 Feb 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "filtdevs.h"
#include "lanamap.h"
#include "netcfg.h"
#include "ncreg.h"
#include "ndispnp.h"


HRESULT
HrRegSetMultiSzAndLogDifference (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN PCWSTR pmszValue,
    IN const CComponent* pComponent
)
{
    // Only log the difference if we're operating under the appropriate
    // diagnostic context.
    //
    if (g_pDiagCtx->Flags() & DF_REPAIR_REGISTRY_BINDINGS)
    {
        HRESULT hr;
        DWORD cbCurrent;
        PWSTR pmszCurrent = (PWSTR)g_pDiagCtx->GetScratchBuffer(&cbCurrent);

        // Read the current value into the diagnostic context's scratch
        // buffer.
        //
        hr = HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_MULTI_SZ,
                                     pmszCurrent, &cbCurrent);

        // Grow the scratch buffer and retry if the value is bigger than
        // than will fit.
        //
        if ((HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr) ||
            ((NULL == pmszCurrent) && (S_OK == hr)))
        {
            pmszCurrent = (PWSTR)g_pDiagCtx->GrowScratchBuffer(&cbCurrent);
            if (pmszCurrent)
            {
                hr = HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_MULTI_SZ,
                                             pmszCurrent, &cbCurrent);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            DWORD cbValue = CbOfMultiSzAndTermSafe(pmszValue);

            // Compare the values and log if they are different.
            //
            if ((cbValue != cbCurrent) ||
                (memcmp(pmszValue, pmszCurrent, cbCurrent)))
            {
                FILE *LogFile = g_pDiagCtx->LogFile();

                fprintf(LogFile,
                        "reset   Linkage\\%S for %S.  bad value was:\n",
                        pszValueName, pComponent->PszGetPnpIdOrInfId());

                fprintf(LogFile, "            REG_MULTI_SZ =\n");
                if (*pmszCurrent)
                {
                    while (*pmszCurrent)
                    {
                        fprintf(LogFile, "                %S\n", pmszCurrent);
                        pmszCurrent += wcslen(pmszCurrent) + 1;
                    }
                }
                else
                {
                    fprintf(LogFile, "                <empty>\n");
                }
                fprintf(LogFile, "\n");
            }
            else
            {
                // The value is correct.  No need to write it.
                //
                return S_OK;
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            fprintf(g_pDiagCtx->LogFile(),
                    "added   Linkage\\%S for %S\n",
                    pszValueName, pComponent->PszGetPnpIdOrInfId());
        }
    }

    // N.B. success or failure of the diagnostic portion of this routine
    // (above) should NOT affect the return value of this routine.
    //
    return HrRegSetMultiSz (hkey, pszValueName, pmszValue);
}

HRESULT
HrCreateLinkageKey (
    IN const CComponent* pComponent,
    IN CFilterDevice* pDevice,
    IN HDEVINFO hdi,
    OUT HKEY* phKey)
{
    HRESULT hr = E_UNEXPECTED;
    HKEY hkeyParent = NULL;
    CONST REGSAM samDesired = KEY_READ | KEY_WRITE;

    Assert (pComponent || pDevice);
    Assert (!(pComponent && pDevice));
    Assert (FIff(pDevice, hdi));
    Assert (phKey);

    if (pComponent)
    {
        // Open the parent of the linkage key.  This is the instance key if
        // the component is enumerated or does not have a service.
        //
        if (FIsEnumerated (pComponent->Class()) || !pComponent->FHasService())
        {
            hr = pComponent->HrOpenInstanceKey (samDesired,
                    &hkeyParent,
                    NULL, NULL);

            if ((S_OK == hr) && FIsEnumerated (pComponent->Class()))
            {
                // Write out the netcfg instance id. Connections will use
                // this to determine if the device is known by net config
                // and will create the <instance guid> key under network
                // to store its connection info. We only need to do this
                // for enumerated components.
                //
                hr = HrRegSetGuidAsSz (hkeyParent, L"NetCfgInstanceId",
                        pComponent->m_InstanceGuid);
            }
        }
        else
        {
            hr = pComponent->HrOpenServiceKey (samDesired, &hkeyParent);
        }
    }
    else
    {
        Assert (pDevice);
        Assert (hdi);

        hr = HrSetupDiOpenDevRegKey (
                hdi,
                &pDevice->m_deid,
                DICS_FLAG_GLOBAL,
                0,
                DIREG_DRV,
                samDesired,
                &hkeyParent);
    }

    if (S_OK == hr)
    {
        Assert (hkeyParent);

        hr = HrRegCreateKeyEx (
                hkeyParent,
                L"Linkage",
                REG_OPTION_NON_VOLATILE,
                samDesired,
                NULL,
                phKey,
                NULL);

        RegCloseKey (hkeyParent);
    }

    TraceHr (ttidError, FAL, hr,
        (SPAPI_E_NO_SUCH_DEVINST == hr),
        "HrCreateLinkageKey");
    return hr;
}

HRESULT
HrWriteLinkageValues (
    IN const CComponent* pComponent,
    IN PCWSTR pmszBind,
    IN PCWSTR pmszExport,
    IN PCWSTR pmszRoute)
{
    HRESULT hr;
    HKEY hkeyLinkage;
    PCWSTR pmsz;

    Assert (pmszBind);
    Assert (pmszExport);
    Assert (pmszRoute);

    g_pDiagCtx->Printf (ttidBeDiag, "   %S  (%S)\n",
        pComponent->Ext.PszBindName(),
        pComponent->PszGetPnpIdOrInfId());

    if (FIsEnumerated (pComponent->Class()))
    {
        g_pDiagCtx->Printf (ttidBeDiag, "      UpperBind:\n");
    }
    else
    {
        g_pDiagCtx->Printf (ttidBeDiag, "      Bind:\n");
    }

    pmsz = pmszBind;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }

    g_pDiagCtx->Printf (ttidBeDiag, "      Export:\n");
    pmsz = pmszExport;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }
    g_pDiagCtx->Printf (ttidBeDiag, "\n");

    hr = HrCreateLinkageKey (pComponent, NULL, NULL, &hkeyLinkage);

    if (S_OK == hr)
    {
        // For enumerated components, write RootDevice, UpperBind, and Export.
        // For non-enumerated components, write Bind and Export.
        //
        if (FIsEnumerated (pComponent->Class()))
        {
            // Create the root device multi-sz from the bindname.
            //
            WCHAR mszRootDevice [_MAX_PATH];
            wcscpy (mszRootDevice, pComponent->Ext.PszBindName());
            mszRootDevice [wcslen(mszRootDevice) + 1] = 0;

            hr = HrRegSetMultiSzAndLogDifference (
                    hkeyLinkage, L"RootDevice", mszRootDevice, pComponent);

            if (S_OK == hr)
            {
                hr = HrRegSetMultiSzAndLogDifference (
                        hkeyLinkage, L"UpperBind", pmszBind, pComponent);
            }
        }
        else
        {
            hr = HrRegSetMultiSzAndLogDifference (
                    hkeyLinkage, L"Bind", pmszBind, pComponent);

            if (S_OK == hr)
            {
                hr = HrRegSetMultiSzAndLogDifference (
                        hkeyLinkage, L"Route", pmszRoute, pComponent);
            }
        }

        if ((S_OK == hr) && *pmszExport)
        {
            hr = HrRegSetMultiSzAndLogDifference (
                    hkeyLinkage, L"Export", pmszExport, pComponent);
        }

        RegCloseKey (hkeyLinkage);
    }

    TraceHr (ttidError, FAL, hr,
        (SPAPI_E_NO_SUCH_DEVINST == hr),
        "HrWriteLinkageValues");
    return hr;
}

HRESULT
HrWriteFilterDeviceLinkage (
    IN CFilterDevice* pDevice,
    IN HDEVINFO hdi,
    IN PCWSTR pmszExport,
    IN PCWSTR pmszRootDevice,
    IN PCWSTR pmszUpperBind)
{
    HRESULT hr;
    HKEY hkeyLinkage;
    PCWSTR pmsz;

    g_pDiagCtx->Printf (ttidBeDiag, "   %S filter over %S adapter\n",
        pDevice->m_pFilter->m_pszInfId,
        pDevice->m_pAdapter->m_pszPnpId);

    g_pDiagCtx->Printf (ttidBeDiag, "      Export:\n");
    pmsz = pmszExport;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }

    g_pDiagCtx->Printf (ttidBeDiag, "      RootDevice:\n");
    pmsz = pmszRootDevice;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }

    g_pDiagCtx->Printf (ttidBeDiag, "      UpperBind:\n");
    pmsz = pmszUpperBind;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }
    g_pDiagCtx->Printf (ttidBeDiag, "\n");

    hr = HrCreateLinkageKey (NULL, pDevice, hdi, &hkeyLinkage);

    if (S_OK == hr)
    {
        hr = HrRegSetMultiSz (hkeyLinkage, L"Export", pmszExport);

        if (S_OK == hr)
        {
            hr = HrRegSetMultiSz (hkeyLinkage, L"RootDevice", pmszRootDevice);
        }

        if (S_OK == hr)
        {
            hr = HrRegSetMultiSz (hkeyLinkage, L"UpperBind", pmszUpperBind);
        }

        // Delete values used by the previous binding engine that are
        // not needed any longer.
        //
        RegDeleteValue (hkeyLinkage, L"BindPath");
        RegDeleteValue (hkeyLinkage, L"Bind");
        RegDeleteValue (hkeyLinkage, L"Route");
        RegDeleteKey   (hkeyLinkage, L"Disabled");

        RegCloseKey (hkeyLinkage);
    }

    // Now write to the standard filter parameter registry layout under
    // the filter's service key.
    //

    if (pDevice->m_pFilter->Ext.PszService())
    {
        HKEY hkeyAdapterParams;
        WCHAR szRegPath [_MAX_PATH];

        Assert (pDevice->m_pFilter->Ext.PszService());
        Assert (pDevice->m_pAdapter->Ext.PszBindName());

        wsprintfW (
            szRegPath,
            L"System\\CurrentControlSet\\Services\\%s\\Parameters\\Adapters\\%s",
            pDevice->m_pFilter->Ext.PszService(),
            pDevice->m_pAdapter->Ext.PszBindName());

        hr = HrRegCreateKeyEx (
                HKEY_LOCAL_MACHINE,
                szRegPath,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,
                &hkeyAdapterParams,
                NULL);

        if (S_OK == hr)
        {
            // UpperBindings is a REG_SZ, not a REG_MULTI_SZ.
            //
            hr = HrRegSetSz (hkeyAdapterParams, L"UpperBindings", pmszExport);

            RegCloseKey (hkeyAdapterParams);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrWriteFilterDeviceLinkage");
    return hr;
}

HRESULT
HrWriteFilteredAdapterUpperBind (
    IN const CComponent* pAdapter,
    IN PCWSTR pmszUpperBind)
{
    HRESULT hr;
    HKEY hkeyLinkage;

    hr = HrCreateLinkageKey (pAdapter, NULL, NULL, &hkeyLinkage);

    if (S_OK == hr)
    {
        hr = HrRegSetMultiSz (hkeyLinkage, L"UpperBind", pmszUpperBind);

        RegCloseKey (hkeyLinkage);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrWriteFilteredAdapterUpperBind");
    return hr;
}

HRESULT
CRegistryBindingsContext::HrPrepare (
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;

    Assert (pNetConfig);
    m_pNetConfig = pNetConfig;

    hr = m_BindValue.HrReserveBytes (4096);
    if (S_OK != hr)
    {
        return hr;
    }

    hr = m_ExportValue.HrReserveBytes (4096);
    if (S_OK != hr)
    {
        return hr;
    }

    hr = m_RouteValue.HrReserveBytes (4096);
    if (S_OK != hr)
    {
        return hr;
    }

    // Ensure all of the external data for all components is loaded.
    //
    hr = m_pNetConfig->HrEnsureExternalDataLoadedForAllComponents ();
    if (S_OK != hr)
    {
        return hr;
    }

    // Ensure all of the notify objects have been initialized.
    //
    hr = m_pNetConfig->Notify.HrEnsureNotifyObjectsInitialized ();
    if (S_OK != hr)
    {
        return hr;
    }

    return S_OK;
}

HRESULT
CRegistryBindingsContext::HrDeleteBindingsForComponent (
    IN const CComponent* pComponent)
{
    return HrWriteLinkageValues (pComponent, L"", L"", L"");
}

HRESULT
CRegistryBindingsContext::HrGetAdapterUpperBindValue (
    IN const CComponent* pAdapter)
{
    HRESULT hr;
    const CBindPath* pBindPath;

    m_BindValue.Clear();

    // Get the upper bindings of the component.  This returns a bindset
    // with binpaths only 2 levels deep.  That is, the bindpaths begin
    // with the components one level above pComponent.
    //
    hr = m_pNetConfig->Core.HrGetComponentUpperBindings (
            pAdapter,
            GBF_PRUNE_DISABLED_BINDINGS,
            &m_BindSet);

    if (S_OK == hr)
    {
        for (pBindPath  = m_BindSet.begin();
             pBindPath != m_BindSet.end();
             pBindPath++)
        {
            // Don't put filters in the UpperBind of an adapter.
            //
            if (pBindPath->POwner()->FIsFilter())
            {
                continue;
            }

            hr = m_BindValue.HrCopyString (
                    pBindPath->POwner()->Ext.PszBindName());
            if (S_OK != hr)
            {
                break;
            }
        }

        hr = m_BindValue.HrCopyString (L"");
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRegistryBindingsContext::HrGetAdapterUpperBindValue");
    return hr;
}

HRESULT
CRegistryBindingsContext::HrWriteBindingsForComponent (
    IN const CComponent* pComponent)
{
    HRESULT hr;
    const CBindPath* pBindPath;
    CBindPath::const_iterator iter;
    const CComponent* pUpper;
    const CComponent* pLower;
    WCHAR szBind [_MAX_BIND_LENGTH];
    WCHAR szExport [_MAX_BIND_LENGTH];
    WCHAR szRoute [_MAX_BIND_LENGTH];
    PWCHAR pchBind;
    PWCHAR pchExport;

    Assert (pComponent);
    pComponent->Ext.DbgVerifyExternalDataLoaded ();

    // If the component is not bindable, we have nothing to do.
    //
    if (!pComponent->FIsBindable())
    {
        return S_OK;
    }

    m_BindValue.Clear ();
    m_ExportValue.Clear ();
    m_RouteValue.Clear ();

    wcscpy (szExport, L"\\Device\\");
    wcscat (szExport, pComponent->Ext.PszBindName());
    hr = m_ExportValue.HrCopyString (szExport);
    Assert (S_OK == hr);
    hr = m_ExportValue.HrCopyString (L"");
    Assert (S_OK == hr);

    if (FIsEnumerated (pComponent->Class()))
    {
        // UpperBind
        //
        hr = HrGetAdapterUpperBindValue (pComponent);
    }
    else
    {
        // Bind, Export
        //
        hr = m_pNetConfig->Core.HrGetComponentBindings (
                pComponent,
                GBF_PRUNE_DISABLED_BINDINGS,
                &m_BindSet);

        if ((S_OK == hr) && (m_BindSet.CountBindPaths() > 0))
        {
            // Since the component has bindings, it's export value will be
            // different from the default one we initialized with above.
            //
            m_ExportValue.Clear ();

            for (pBindPath  = m_BindSet.begin();
                 pBindPath != m_BindSet.end();
                 pBindPath++)
            {
                Assert (pBindPath->CountComponents() > 1);

                wcscpy (szBind,   L"\\Device\\");
                wcscpy (szExport, L"\\Device\\");
                *szRoute = 0;

                for (iter  = pBindPath->begin();
                     iter != pBindPath->end();
                     iter++)
                {
                    pUpper = *iter;
                    Assert (pUpper);

                    // For the bind value, skip the first component in each
                    // path because it is the component we are writing the
                    // bindings for.
                    //
                    if (iter != pBindPath->begin())
                    {
                        Assert (wcslen(szBind) + 1 +
                                wcslen(pUpper->Ext.PszBindName())
                                    < celems(szBind));

                        // If this isn't the first component to come after
                        // \Device\, add underscores to seperate the
                        // components.
                        //
                        if (iter != (pBindPath->begin() + 1))
                        {
                            wcscat (szBind, L"_");
                            wcscat (szRoute, L" ");
                        }
                        wcscat (szBind, pUpper->Ext.PszBindName());

                        wcscat (szRoute, L"\"");
                        wcscat (szRoute, pUpper->Ext.PszBindName());
                        wcscat (szRoute, L"\"");
                    }

                    Assert (wcslen(szExport) + 1 +
                            wcslen(pUpper->Ext.PszBindName())
                                < celems(szExport));

                    // If this isn't the first component to come after
                    // \Device\, add underscores to seperate the
                    // components.
                    //
                    if (iter != pBindPath->begin())
                    {
                        wcscat (szExport, L"_");
                    }
                    wcscat (szExport, pUpper->Ext.PszBindName());

                    // If the next component in the bindpath is the last
                    // component, it is an adapter (by convention).  Check
                    // to see if there are multiple interfaces to be expanded
                    // for the current component over this adapter.
                    //
                    if ((iter + 1) == (pBindPath->end() - 1))
                    {
                        DWORD cInterfaces;
                        GUID* pguidInterfaceIds;

                        pLower = *(iter + 1);

                        hr = pUpper->Notify.HrGetInterfaceIdsForAdapter (
                                m_pNetConfig->Notify.PINetCfg(),
                                pLower,
                                &cInterfaces,
                                &pguidInterfaceIds);

                        if (FAILED(hr))
                        {
                            break;
                        }

                        if (cInterfaces)
                        {
                            Assert (pguidInterfaceIds);

                            if (iter != pBindPath->begin())
                            {
                                wcscat (szBind, L"_");
                                pchBind = szBind + wcslen(szBind);
                                Assert (wcslen(szBind) +
                                    c_cchGuidWithTerm < celems(szBind));
                            }
                            else
                            {
                                // The first component in the bindpath is
                                // one that has multiple interfaces over the
                                // adapter.  The bind value should be as
                                // normal, the export value will have the
                                // expand interfaces.
                                //
                                Assert (wcslen(szBind) +
                                        wcslen(pLower->Ext.PszBindName())
                                            < celems(szBind));

                                wcscat (szBind, pLower->Ext.PszBindName());

                                hr = m_BindValue.HrCopyString (szBind);
                                if (S_OK != hr)
                                {
                                    break;
                                }
                            }

                            wcscat (szExport, L"_");
                            pchExport = szExport + wcslen(szExport);
                            Assert (wcslen(szExport) +
                                c_cchGuidWithTerm < celems(szExport));

                            for (UINT i = 0; i < cInterfaces; i++)
                            {
                                if (iter != pBindPath->begin())
                                {
                                    StringFromGUID2 (
                                        pguidInterfaceIds[i],
                                        pchBind, c_cchGuidWithTerm);

                                    hr = m_BindValue.HrCopyString (szBind);
                                    if (S_OK != hr)
                                    {
                                        break;
                                    }
                                }

                                StringFromGUID2 (
                                    pguidInterfaceIds[i],
                                    pchExport, c_cchGuidWithTerm);

                                hr = m_ExportValue.HrCopyString (szExport);
                                if (S_OK != hr)
                                {
                                    break;
                                }
                            }

                            CoTaskMemFree (pguidInterfaceIds);

                            if (iter != pBindPath->begin())
                            {
                                wcscat (szRoute, L" ");
                            }
                            wcscat (szRoute, L"\"");
                            wcscat (szRoute, pLower->Ext.PszBindName());
                            wcscat (szRoute, L"\"");

                            hr = m_RouteValue.HrCopyString (szRoute);
                            if (S_OK != hr)
                            {
                                break;
                            }

                            // We only allow one component in a bindpath
                            // to support mutliple interfaces and it always
                            // comes at the end of the bindpath.  Therefore,
                            // after expanding them, we are done with the
                            // bindpath and proceed to the next.  (Hence, the
                            // 'break').
                            //
                            break;
                        }
                    }
                }

                // If we exited the loop because we traversed the entire
                // bindpath (as opposed to expanding multiple interfaces,
                // where we would have stopped short), then add the bind
                // and export strings for this bindpath to the buffer and
                // proceed to the next bindpath.
                //
                if (iter == pBindPath->end())
                {
                    hr = m_BindValue.HrCopyString (szBind);
                    if (S_OK != hr)
                    {
                        break;
                    }

                    hr = m_ExportValue.HrCopyString (szExport);
                    if (S_OK != hr)
                    {
                        break;
                    }

                    hr = m_RouteValue.HrCopyString (szRoute);
                    if (S_OK != hr)
                    {
                        break;
                    }
                }
            }

            // The bind and export values are multi-sz, so make sure they
            // are double null-terminiated.
            //
            hr = m_BindValue.HrCopyString (L"");
            if (S_OK == hr)
            {
                hr = m_ExportValue.HrCopyString (L"");
            }
            if (S_OK == hr)
            {
                hr = m_RouteValue.HrCopyString (L"");
            }
        }

        // Special case: NCF_DONTEXPOSELOWER
        //
        if ((S_OK == hr) &&
            ((pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER) ||
             (0 == wcscmp(L"ms_nwspx", pComponent->m_pszInfId))))
        {
            wcscpy (szExport, L"\\Device\\");
            wcscat (szExport, pComponent->Ext.PszBindName());

            m_ExportValue.Clear ();
            hr = m_ExportValue.HrCopyString (szExport);
            Assert (S_OK == hr);
            hr = m_ExportValue.HrCopyString (L"");
            Assert (S_OK == hr);
        }
        // End Special case
    }

    if (S_OK == hr)
    {
        // Need to write out lanamap before writing new bindings since
        // we need the old binding information to persist lana numbers.
        //
        if (0 == wcscmp (pComponent->m_pszInfId, L"ms_netbios"))
        {
            (VOID) HrUpdateLanaConfig (
                    m_pNetConfig->Core.Components,
                    (PCWSTR)m_BindValue.PbBuffer(),
                    m_BindSet.CountBindPaths());
        }

        hr = HrWriteLinkageValues (
                pComponent,
                (PCWSTR)m_BindValue.PbBuffer(),
                (PCWSTR)m_ExportValue.PbBuffer(),
                (PCWSTR)m_RouteValue.PbBuffer());

        if(S_OK == hr)
        {
            // mbend June 20, 2000
            // RAID 23275: Default gateway isn't respecting the adapter order specified under connections->advanced->properties
            // Notify NDIS when the binding list for a component changes.
            //
            UNICODE_STRING LowerComponent;
            UNICODE_STRING UpperComponent;
            UNICODE_STRING BindList;

            BOOL bOk = TRUE;
            if (FIsEnumerated(pComponent->Class()))
            {
                RtlInitUnicodeString(&BindList, NULL);
                RtlInitUnicodeString(&LowerComponent, NULL);
                RtlInitUnicodeString(&UpperComponent, pComponent->Ext.PszBindName());
                bOk = NdisHandlePnPEvent(
                        NDIS,
                        BIND_LIST,
                        &LowerComponent,
                        &UpperComponent,
                        &BindList,
                        const_cast<PBYTE>(m_BindValue.PbBuffer()),
                        m_BindValue.CountOfBytesUsed());

            }
            else
            {
                RtlInitUnicodeString(&BindList, NULL);
                RtlInitUnicodeString(&LowerComponent, NULL);
                RtlInitUnicodeString(&UpperComponent, pComponent->Ext.PszBindName());

                TraceTag(ttidBeDiag, "BindName (TDI Client): %S", pComponent->Ext.PszBindName());

                bOk = NdisHandlePnPEvent(
                      TDI,
                      RECONFIGURE,
                      &LowerComponent,
                      &UpperComponent,
                      &BindList,
                      const_cast<PBYTE>(m_BindValue.PbBuffer()),
                      m_BindValue.CountOfBytesUsed());
            }

            if(!bOk)
            {
//                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRegistryBindingsContext::HrWriteBindingsForComponent");
    return hr;
}

HRESULT
CRegistryBindingsContext::HrWriteBindingsForFilterDevices (
    IN CFilterDevices* pFilterDevices)
{
    HRESULT hr;
    CFilterDevices::iterator iter;
    CFilterDevices::iterator next;
    CFilterDevice* pDevice;
    CFilterDevice* pNextDevice;
    CFilterDevice* pPrevDevice;
    PCWSTR pmszRootDevice;
    PCWSTR pmszUpperBind;

    #define SZ_DEVICE_LEN 8     // characters in L"\\Device\\"
    WCHAR mszExport [SZ_DEVICE_LEN + c_cchGuidWithTerm + 1];
    WCHAR* const pchExportGuid = mszExport + SZ_DEVICE_LEN;

    // Pre-fill the beginning of the Export string.
    // Set the terminating NULL for the mutli-sz too.
    //
    wcscpy (mszExport, L"\\Device\\");
    Assert (SZ_DEVICE_LEN == wcslen(mszExport));
    mszExport[celems(mszExport) - 1] = 0;

    hr = S_OK;

    // Sort the filter devices by pAdapter and then by
    // pFilter->m_dwFilterClassOrdinal.  We will then iterate all filter
    // devices to write the bindings.  Because of the sort, we'll iterate
    // all filter devices for a given adapter in class order from smallest
    // to largest.  (Smaller class ordinals have affinity for the protocol.)
    //
    pFilterDevices->SortForWritingBindings ();

    pPrevDevice = NULL;

    for (iter  = pFilterDevices->begin();
         iter != pFilterDevices->end();
         iter++)
    {
        pDevice = *iter;
        Assert (pDevice);

        // Generate the rest of the Export string.
        // \Device\{GUID}
        //
        Assert ((c_cchGuidWithTerm - 1) == wcslen(pDevice->m_szInstanceGuid));

        wcscpy (pchExportGuid, pDevice->m_szInstanceGuid);

        // If this device's adapter is different than the previous device's
        // adapter, we are dealing with the top of a new chain.  We need
        // to initialize RootDevice which will be the multi-sz of all
        // bindnames in the chain including the adapter.
        //
        if (!pPrevDevice ||
            (pDevice->m_pAdapter != pPrevDevice->m_pAdapter))
        {
            // Compute RootDevice.
            // We'll use m_ExportValue as the buffer.
            //
            m_ExportValue.Clear();
            m_ExportValue.HrCopyString (pDevice->m_szInstanceGuid);

            for (next = iter + 1;
                 next != pFilterDevices->end();
                 next++)
            {
                pNextDevice = *next;
                Assert (pNextDevice);

                // We're done when we reach the next filter chain.
                //
                if (pNextDevice->m_pAdapter != pDevice->m_pAdapter)
                {
                    break;
                }

                m_ExportValue.HrCopyString (pNextDevice->m_szInstanceGuid);
            }

            m_ExportValue.HrCopyString (pDevice->m_pAdapter->Ext.PszBindName());
            m_ExportValue.HrCopyString (L"");
            pmszRootDevice = (PCWSTR)m_ExportValue.PbBuffer();
            Assert (*pmszRootDevice);

            // Compute UpperBind.
            // We'll use m_BindValue as the buffer.
            //
            hr = HrGetAdapterUpperBindValue (pDevice->m_pAdapter);
        }
        // We're continuing in the filter chain and this device is not
        // the topmost. (not closest to the protocol).
        //
        else
        {
            // Since RootDevice was built up for the top device in the chain,
            // each successive device just needs to skip past the next
            // string in the mutli-sz.
            //
            Assert (*pmszRootDevice);
            pmszRootDevice += wcslen(pmszRootDevice) + 1;

            // UpperBind is the previous device's filter's bind name.
            //
            m_BindValue.Clear();
            m_BindValue.HrCopyString (pPrevDevice->m_pFilter->Ext.PszBindName());
            m_BindValue.HrCopyString (L"");
        }

        pmszUpperBind = (PCWSTR)m_BindValue.PbBuffer();

        // We now have:
        //   Export in mszExport
        //   RootDevice at pmszRootDevice (in m_ExportValue)
        //   UpperBind at pmszUpperBind (in m_BindValue)
        //
        hr = HrWriteFilterDeviceLinkage (
                pDevice, pFilterDevices->m_hdi,
                mszExport, pmszRootDevice, pmszUpperBind);

        // If this is the last device in the chain, we need to write
        // the UpperBind of the adapter to be this filter device.
        //
        next = iter + 1;
        if ((next == pFilterDevices->end()) ||
            (*next)->m_pAdapter != pDevice->m_pAdapter)
        {
            // UpperBind is this last device's filter's bind name.
            //
            m_BindValue.Clear();
            m_BindValue.HrCopyString (pDevice->m_pFilter->Ext.PszBindName());
            m_BindValue.HrCopyString (L"");
            pmszUpperBind = (PCWSTR)m_BindValue.PbBuffer();

            hr = HrWriteFilteredAdapterUpperBind (
                    pDevice->m_pAdapter,
                    pmszUpperBind);
        }

        // Remember the previous device so that when we go to the next
        // device, we'll know we're dealing with a different chain if
        // the next device's adapter is different than this one.
        //
        pPrevDevice = pDevice;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRegistryBindingsContext::HrWriteBindingsForFilterDevices");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\remove.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       R E M O V E . C P P
//
//  Contents:   Implements actions related to removing components.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncreg.h"
#include "netcfg.h"


VOID
CModifyContext::NotifyAndRemoveComponent (
    IN CComponent* pComponent)
{
    CNetConfig* pNetConfig;
    UINT cPreviousDeletedBindPaths;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (pComponent);

    pNetConfig = PNetConfig();

    // Note the number of bindpaths currently in m_DeletedBindPaths.
    // We need this so that when we add to the set, we only notify
    // for the ones we add.
    //
    cPreviousDeletedBindPaths = m_DeletedBindPaths.CountBindPaths ();

    // Get the bindpaths that involve the component we are removing.
    // Add these to the deleted bindpaths we are keeping track of.
    //
    m_hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                pComponent,
                GBF_ADD_TO_BINDSET | GBF_ONLY_WHICH_CONTAIN_COMPONENT,
                &m_DeletedBindPaths);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Remove the component from the core.
    //
    pNetConfig->Core.RemoveComponentFromCore (pComponent);

    // Notify that these bindpaths are being removed.  We only need to do
    // so if we added any new ones to the set.  Existing ones in the set
    // have already been notified.
    //
    // THIS MAY CAUSE RECURSION
    //
    if (m_DeletedBindPaths.CountBindPaths() > cPreviousDeletedBindPaths)
    {
        m_hr = pNetConfig->Notify.NotifyRemovedBindPaths (
                    &m_DeletedBindPaths,
                    cPreviousDeletedBindPaths);
        if (S_OK != m_hr)
        {
            Assert(FAILED(m_hr));
            return;
        }
    }

    // Notify the component's notify object it is being removed.
    // This also sends global notifications to other notify objects
    // who may be interested.
    //
    // THIS MAY CAUSE RECURSION
    //
    m_hr = pNetConfig->Notify.ComponentRemoved (pComponent);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // If we have a cached INetCfgComponent interface, we need to tell it
    // that the component it represents is no longer valid.
    //
    pComponent->ReleaseINetCfgComponentInterface ();

    // Remove (if not referenced) any components that this component
    // required.
    //
    // THIS MAY CAUSE RECURSION
    //
    InstallOrRemoveRequiredComponents (pComponent, IOR_REMOVE);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Now that we've given a chance to notify objects to remove references
    // to the component being removed, we need to ensure it is not
    // referenced by anyone else.
    // Check to see if the component we just removed is still
    // referencing other components.  If it is, it means it forgot
    // to remove those components.  We'll print what they are and
    // remove the bogus reference (but not the components themselves)
    // so that when we save the configuration binary we don't
    // barf trying to lookup the index of this component we just
    // removed.)
    //
    pNetConfig->Core.EnsureComponentNotReferencedByOthers (pComponent);
}

HRESULT
CModifyContext::HrRemoveComponentIfNotReferenced (
    IN CComponent* pComponent,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    OUT PWSTR* ppmszwRefs OPTIONAL)
{
    CNetConfig* pNetConfig;
    BOOL fStillReferenced;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (pComponent);

    // If the caller is requesting removal on behalf of an obo token,
    // (and its not obo the user) make sure the component is actually
    // referenced by that obo token.  If it is not, consider it an
    // invalid argument.
    //
    // The reason we don't consider the obo user case is because the UI
    // will show anything that is installed and allow the user to try to
    // remove them.  If the user hasn't actually installed it, we don't
    // want to treat this as an invalid argument, rather, we want to let
    // the code fall through to the case where we will return the multi-sz
    // of descriptions of components still referencing the component.
    //
    // However, if there are no references (which can happen if we delete
    // the configuration binary and then re-create it) we'll go ahead and
    // allow removals by anyone).  This is a safety-net.
    //
    // The overall purpose of the following 'if' is to catch programatic
    // removals that are on behalf of other components or software that
    // have previously installed the component being removed.
    //
    if (pOboToken &&
        (OBO_USER != pOboToken->Type) &&
        !pComponent->Refs.FIsReferencedByOboToken (pOboToken) &&
        (pComponent->Refs.CountTotalReferencedBy() > 0))
    {
        return E_INVALIDARG;
    }

    pNetConfig = PNetConfig();
    fStillReferenced = TRUE;

    // Now that we actually are going to modify something, push a new
    // recursion depth.
    //
    PushRecursionDepth ();
    Assert (S_OK == m_hr);

    // If the component is NOT in the list of components we started with,
    // it means someone had previously installed it during this modify
    // context and now wants to remove it.  This is tricky and should
    // probably be implemented later.  For now, return an error and throw
    // up an assert so we can see who needs to do this.
    //
    if (!m_CoreStartedWith.Components.FComponentInList (pComponent))
    {
        AssertSz (FALSE, "Whoa.  Someone is trying to remove a "
            "component that was previously installed during this same "
            "modify context.  We need to decide if we can support this.");
        m_hr = E_UNEXPECTED;
    }

    if (pOboToken && (S_OK == m_hr))
    {
        m_hr = pComponent->Refs.HrRemoveReferenceByOboToken (pOboToken);
    }

    // If no obo token, or we removed the reference from it, actually
    // remove it if it is not still referenced by anything else.
    //
    if (S_OK == m_hr)
    {
        if (0 == pComponent->Refs.CountTotalReferencedBy())
        {
            fStillReferenced = FALSE;

            NotifyAndRemoveComponent (pComponent);
        }
        else if (ppmszwRefs)
        {
            ULONG cb;

            // Need to return the multi-sz of descriptions still referencing
            // the component the caller tried to remove.
            //

            // Size the data first.
            //
            cb = 0;
            pComponent->Refs.GetReferenceDescriptionsAsMultiSz (
                NULL, &cb);

            Assert (cb);

            // Allocate room to return the multi-sz.
            //
            Assert (S_OK == m_hr);

            m_hr = HrCoTaskMemAlloc (cb, (VOID**)ppmszwRefs);
            if (S_OK == m_hr)
            {
                // Now get the multi-sz.
                //
                pComponent->Refs.GetReferenceDescriptionsAsMultiSz (
                    (BYTE*)(*ppmszwRefs), &cb);

                Assert (fStillReferenced);
            }
        }
    }

    HRESULT hr;

    hr = HrPopRecursionDepth ();

    if (fStillReferenced && SUCCEEDED(hr))
    {
        // Still reference return code overrides other success codes like
        // need reboot.
        //
        hr = NETCFG_S_STILL_REFERENCED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\stable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       S T A B L E . C P P
//
//  Contents:   Implements operations that are valid on stack entries and
//              stack tables.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nceh.h"
#include "netcfg.h"
#include "stable.h"

BOOL
CStackTable::FStackEntryInTable (
    IN const CComponent*  pUpper,
    IN const CComponent*  pLower) const
{
    const CStackEntry*  pStackEntry;

    Assert (this);
    Assert (pUpper);
    Assert (pLower);

    for (pStackEntry = begin(); pStackEntry != end(); pStackEntry++)
    {
        if ((pUpper == pStackEntry->pUpper) &&
            (pLower == pStackEntry->pLower))
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
CStackTable::RemoveStackEntry(
        IN const CComponent*  pUpper,
        IN const CComponent*  pLower)
{
    CStackEntry*  pStackEntry;

    Assert (this);
    Assert (pUpper);
    Assert (pLower);

    for (pStackEntry = begin(); pStackEntry != end(); pStackEntry++)
    {
        if ((pUpper == pStackEntry->pUpper) &&
            (pLower == pStackEntry->pLower))
        {
            erase(pStackEntry);
            break;
        }
    }
}

HRESULT
CStackTable::HrCopyStackTable (
    IN const CStackTable* pSourceTable)
{
    HRESULT hr;

    Assert (this);
    Assert (pSourceTable);

    NC_TRY
    {
        *this = *pSourceTable;
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CStackTable::HrCopyStackTable");
    return hr;
}

HRESULT
CStackTable::HrInsertStackEntriesForComponent (
    IN const CComponent* pComponent,
    IN const CComponentList* pComponents,
    IN DWORD dwFlags /* INS_FLAGS */)
{
    HRESULT hr;
    CStackEntry StackEntry;
    CComponentList::const_iterator iter;
    const CComponent* pScan;

    Assert (this);
    Assert (pComponent);
    Assert (pComponents);

    hr = S_OK;

    // Insert the stack entries for other components which bind with this one.
    //
    for (iter  = pComponents->begin();
         iter != pComponents->end();
         iter++)
    {
        pScan = *iter;
        Assert (pScan);

        if (pScan == pComponent)
        {
            continue;
        }

        if (pScan->FCanDirectlyBindTo (pComponent, NULL, NULL))
        {
            StackEntry.pUpper = pScan;
            StackEntry.pLower = pComponent;
        }
        else if (pComponent->FCanDirectlyBindTo (pScan, NULL, NULL))
        {
            StackEntry.pUpper = pComponent;
            StackEntry.pLower = pScan;
        }
        else
        {
            continue;
        }

        // Insert the stack entry.  This should only fail if we are
        // out of memory.
        //
        hr = HrInsertStackEntry (&StackEntry, dwFlags);

        // If we fail to insert the entry, undo all of the previous
        // insertions of this component and return.
        //
        if (S_OK != hr)
        {
            RemoveEntriesWithComponent (pComponent);
            break;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CStackTable::HrInsertStackEntriesForComponent");
    return hr;
}

HRESULT
CStackTable::HrInsertStackEntry (
    IN const CStackEntry* pStackEntry,
    IN DWORD dwFlags)
{
    HRESULT hr;

    Assert (this);
    Assert (pStackEntry);
    Assert (dwFlags);
    Assert ((INS_SORTED == dwFlags) || (INS_NON_SORTED == dwFlags));

    const CComponent* pUpper = pStackEntry->pUpper;
    const CComponent* pLower = pStackEntry->pLower;

    Assert (pUpper && pLower && (pUpper != pLower));
    Assert (!FStackEntryInTable (pUpper, pLower));

    CStackEntry* pScan = end();

    if (dwFlags & INS_SORTED)
    {
        CStackEntry* pFirstInClass = NULL;
        CStackEntry* pFirstSameUpper = NULL;

        // Find the beginning of the group of entries belonging to the
        // same class or lower as the one we are inserting.
        //
        for (pScan = begin(); pScan != end(); pScan++)
        {
            if ((UINT)pUpper->Class() >= (UINT)pScan->pUpper->Class())
            {
                pFirstInClass = pScan;
                break;
            }
        }

        // Find the first entry with the same pUpper (if there is one).
        //
        for (; pScan != end(); pScan++)
        {
            if (pUpper == pScan->pUpper)
            {
                pFirstSameUpper = pScan;
                break;
            }
        }

        // If we found the first entry with a matching pUpper, find the
        // specific entry to insert before.
        //
        if (pFirstSameUpper)
        {
            BOOL fLowerIsNetBt;

            // This may seem ugly, but will save a lot of code in a
            // notify object.  If inserting pLower of netbt, make sure
            // it comes after netbt_smb.
            //
            fLowerIsNetBt = (0 == wcscmp (pLower->m_pszInfId, L"ms_netbt"));
            if (fLowerIsNetBt)
            {
                while ((pScan != end()) && (pUpper == pScan->pUpper))
                {
                    pScan++;
                }
            }
            else if (pLower->FIsWanAdapter() && !m_fWanAdaptersFirst)
            {
                // For WAN adapters, either insert them before or after
                // all other adapters as determined by m_fWanAdaptersFirst.
                // If they don't come first, they come last, so scan
                // to the end of the group with the same upper.
                //
                while ((pScan != end()) && (pUpper == pScan->pUpper))
                {
                    pScan++;
                }
            }
        }

        // Otherwise, (if we didn't find any entry with the same upper),
        // but we did find the beginning of the class group, set pScan
        // to the class marker because that is where we will insert.
        //
        else if (pFirstInClass)
        {
            pScan = pFirstInClass;
        }
        else
        {
            Assert (pScan == end());
        }
    }

    // Now insert the entry before the element we found as appropriate.
    //
    NC_TRY
    {
        insert (pScan, *pStackEntry);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CStackTable::HrInsertStackEntry");
    return hr;
}

HRESULT
CStackTable::HrMoveStackEntries (
    IN const CStackEntry* pSrc,
    IN const CStackEntry* pDst,
    IN MOVE_FLAG Flag,
    IN CModifyContext* pModifyCtx)
{
    CStackEntry* pScanSrc;
    CStackEntry* pScanDst;

    // Search for the matching source entry in the table.  We need
    // the pointer to the entry in the table so we can remove it before
    // we re-insert it before or after pDst.
    //
    pScanSrc = find (begin(), end(), *pSrc);

    // If we didn't find the entry, the caller has passed us an invalid
    // argument.
    //
    if (pScanSrc == end())
    {
        return E_INVALIDARG;
    }

    if (pDst)
    {
        // pDst is optional, but if it is specified, it have the same upper
        // but different lower than pSrc.
        //
        if ((pSrc->pUpper != pDst->pUpper) ||
            (pSrc->pLower == pDst->pLower))
        {
            return E_INVALIDARG;
        }

        pScanDst = find (begin(), end(), *pDst);

        // If we didn't find the entry, the caller has passed us an invalid
        // argument.
        //
        if (pScanDst == end())
        {
            return E_INVALIDARG;
        }

        // Since we only have an insert operation, moving after is the
        // same as inserting before the element following pScanDst.
        //
        if ((MOVE_AFTER == Flag) && (pScanDst != end()))
        {
            pScanDst++;
        }
    }
    else
    {
        // Find the first or last in the group with the same upper
        // as pScanSrc.
        //
        pScanDst = pScanSrc;

        if (MOVE_AFTER == Flag)
        {
            // Find the last in the group and insert after that.
            //
            while (pScanDst->pUpper == pScanSrc->pUpper)
            {
                pScanDst++;
                if (pScanDst == end())
                {
                    break;
                }
            }
        }
        else
        {
            // Find the first in the group and insert before that.
            //
            while (1)
            {
                pScanDst--;

                if (pScanDst == begin())
                {
                    break;
                }

                // If we've stepped out of the group, we need to point
                // back at the first element since we are inserting.
                //
                if (pScanDst->pUpper != pScanSrc->pUpper)
                {
                    pScanDst++;
                    break;
                }
            }
        }
    }

    // Remove pScanSrc and insert it pSrc before pScanDst.
    //
    Assert ((pScanSrc >= begin()) && pScanSrc < end());
    erase (pScanSrc);

    // Erasing pScanSrc will move everything that follows it up.
    // If pScanDst comes after pScanSrc, we need to back it up by one.
    //
    Assert ((pScanDst >= begin()) && pScanSrc <= end());
    if (pScanSrc < pScanDst)
    {
        pScanDst--;
    }

    Assert ((pScanDst >= begin()) && pScanSrc <= end());
    insert (pScanDst, *pSrc);

    // We now need to add pSrc->pUpper and all components above
    // it to the modify context's dirty component list.  This will
    // allow us to rewrite the newly ordered bindings during ApplyChanges.
    //
    HRESULT hr = pModifyCtx->HrDirtyComponentAndComponentsAbove (pSrc->pUpper);

    TraceHr (ttidError, FAL, hr, FALSE, "CStackTable::HrMoveStackEntries");
    return hr;
}

HRESULT
CStackTable::HrReserveRoomForEntries (
    IN UINT cEntries)
{
    HRESULT hr;

    NC_TRY
    {
        reserve (cEntries);
        hr = S_OK;
    }
    NC_CATCH_ALL
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CStackTable::HrReserveRoomForEntries");
    return hr;
}

VOID
CStackTable::RemoveEntriesWithComponent (
    IN const CComponent* pComponent)
{
    CStackEntry*  pStackEntry;

    Assert (this);
    Assert (pComponent);

    pStackEntry = begin();
    while (pStackEntry != end())
    {
        if ((pComponent == pStackEntry->pUpper) ||
            (pComponent == pStackEntry->pLower))
        {
            erase (pStackEntry);
        }
        else
        {
            pStackEntry++;
        }
    }
}

HRESULT
CStackTable::HrUpdateEntriesForComponent (
    IN const CComponent* pComponent,
    IN const CComponentList* pComponents,
    IN DWORD dwFlags)
{
    HRESULT hr;
    CStackEntry StackEntry;
    CComponentList::const_iterator iter;
    const CComponent* pScan;
    CStackTable NewStackEntries;
    CStackEntry*  pStackEntry = NULL;

    Assert (this);
    Assert (pComponent);
    Assert (pComponents);

    hr = S_OK;

    TraceTag(ttidBeDiag, 
            "UpdateBindingInterfaces for %S",
            pComponent->PszGetPnpIdOrInfId());
    
    // Save the stack entries for other components which bind with this one.
    //
    for (iter  = pComponents->begin();
         iter != pComponents->end();
         iter++)
    {
        pScan = *iter;
        Assert (pScan);

        if (pScan == pComponent)
        {
            continue;
        }

        if (pScan->FCanDirectlyBindTo (pComponent, NULL, NULL))
        {
            StackEntry.pUpper = pScan;
            StackEntry.pLower = pComponent;
        }
        else if (pComponent->FCanDirectlyBindTo (pScan, NULL, NULL))
        {
            StackEntry.pUpper = pComponent;
            StackEntry.pLower = pScan;
        }
        else
        {
            continue;
        }

        // Save the stack entry for comparation later
        NewStackEntries.push_back(StackEntry);

    }

    //Check whether the current stack entry table is consist with NewStackEntries
    //if not, then update the current stack entry table
    pStackEntry = begin();
    while (pStackEntry != end())
    {
        if ((pComponent == pStackEntry->pUpper) ||
            (pComponent == pStackEntry->pLower))
        {
            if (!NewStackEntries.FStackEntryInTable(pStackEntry->pUpper, pStackEntry->pLower))
            {
                //if the stack entry is not in the new component binding entry list, remove it 
                //from the current stack entry list
                erase (pStackEntry);

                TraceTag(ttidBeDiag, 
                    "erasing binding interface Uppper %S - Lower %S",
                    pStackEntry->pUpper->PszGetPnpIdOrInfId(),
                    pStackEntry->pLower->PszGetPnpIdOrInfId());

                //dont need to increase the iterator since we just removed the current one 
                continue;
            }
            else
            {
                //if the stack entry is also in NewStackEntries, just keep it untouched 
                //in current entry list. Remove that entry from NewStackEntries so that we don't add
                // it again to the current entry list later
                NewStackEntries.RemoveStackEntry(pStackEntry->pUpper, pStackEntry->pLower);
                TraceTag(ttidBeDiag, 
                    "Keep the binding interface untouched: Uppper %S - Lower %S",
                    pStackEntry->pUpper->PszGetPnpIdOrInfId(),
                    pStackEntry->pLower->PszGetPnpIdOrInfId());
            }
        }
        
        pStackEntry++;
    }

    //At this step, the NewStackEntries only contains the stack entries that are in the new binding list
    //but are NOT in the current entry list. So add them in.
    pStackEntry = NewStackEntries.begin();
    while (pStackEntry != NewStackEntries.end())
    {
        Assert(!FStackEntryInTable(pStackEntry->pUpper, pStackEntry->pLower));
        TraceTag(ttidBeDiag, 
                    "Adding the bind interface: Uppper %S - Lower %S",
                    pStackEntry->pUpper->PszGetPnpIdOrInfId(),
                    pStackEntry->pLower->PszGetPnpIdOrInfId());
        hr = HrInsertStackEntry(pStackEntry, dwFlags);
        if (S_OK != hr)
        {
            break;
        }
        
        pStackEntry++;
    }

    // If we fail to insert the entry, undo all of the previous
    // insertions of this component and return.
    //
    if (S_OK != hr)
    {
        RemoveEntriesWithComponent (pComponent);
    }

    TraceError("UpdateEntriesWithComponent", hr);
    return hr;
}

VOID
CStackTable::SetWanAdapterOrder (
    IN BOOL fWanAdaptersFirst)
{
    m_fWanAdaptersFirst = fWanAdaptersFirst;

    // Note: TODO - reorder table
}

VOID
GetComponentsAboveComponent (
    IN const CComponent* pComponent,
    IN OUT GCCONTEXT* pCtx)
{
    const CStackEntry* pStackEntry;

    // For all rows in the stack table where the lower component
    // is the one passed in...
    //
    for (pStackEntry  = pCtx->pStackTable->begin();
         pStackEntry != pCtx->pStackTable->end();
         pStackEntry++)
    {
        if (pComponent != pStackEntry->pLower)
        {
            continue;
        }

        pCtx->hr = pCtx->pComponents->HrInsertComponent (
                    pStackEntry->pUpper, INS_IGNORE_IF_DUP | INS_SORTED);

        // Special case: NCF_DONTEXPOSELOWER
        // If the upper component has the NCF_DONTEXPOSELOWER characteristic,
        // don't recurse.
        //
        if (!pCtx->fIgnoreDontExposeLower &&
            (pStackEntry->pUpper->m_dwCharacter & NCF_DONTEXPOSELOWER))
        {
            continue;
        }
        // End Special case

        // Recurse on the upper component...
        //
        GetComponentsAboveComponent (pStackEntry->pUpper, pCtx);
        if (S_OK != pCtx->hr)
        {
            return;
        }
    }
}

VOID
GetBindingsBelowComponent (
    IN const CComponent* pComponent,
    IN OUT GBCONTEXT* pCtx)
{
    BOOL fFoundOne = FALSE;
    const CStackEntry* pStackEntry;

    // Append this component to the end of the context's working bindpath.
    //
    pCtx->hr = pCtx->BindPath.HrAppendComponent (pComponent);
    if (S_OK != pCtx->hr)
    {
        return;
    }

    // Special case: NCF_DONTEXPOSELOWER
    // If this is not the original component we are asked to find the
    // component for (i.e. not the top-level call) and if the component
    // has the NCF_DONTEXPOSELOWER characteristic, stop recursion since
    // this means we don't get to see components below it.
    //
    if ((pComponent != pCtx->pSourceComponent) &&
        (pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER))
    {
        ;
    }
    // End Special case

    else
    {
        // For all rows in the stack table where the upper component
        // is the one passed in...
        //
        for (pStackEntry  = pCtx->pCore->StackTable.begin();
             pStackEntry != pCtx->pCore->StackTable.end();
             pStackEntry++)
        {
            if (pComponent != pStackEntry->pUpper)
            {
                continue;
            }

            // Detect circular bindings.  If the lower component of this
            // stack entry is already on the bindpath we are building, we
            // have a circular binding.  Break it now, by not recursing any
            // further.
            //
            if (pCtx->BindPath.FContainsComponent (pStackEntry->pLower))
            {
                g_pDiagCtx->Printf (ttidBeDiag, "Circular binding detected...\n");
                continue;
            }

            fFoundOne = TRUE;

            // Recurse on the lower component...
            //
            GetBindingsBelowComponent (pStackEntry->pLower, pCtx);
            if (S_OK != pCtx->hr)
            {
                return;
            }
        }
    }

    // If we didn't find any rows with pComponent as an upper, it
    // means we hit the depth of the bindpath.  Time to add it to
    // the binding set as a complete path unless this is the orignal
    // component we were asked to find the bindpath for.
    //
    if (!fFoundOne && (pComponent != pCtx->pSourceComponent))
    {
        // Add the bindpath to the bindset if we're not pruning disabled
        // bindings or the bindpath isn't disabled.
        //
        if (!pCtx->fPruneDisabledBindings ||
            !pCtx->pCore->FIsBindPathDisabled (&pCtx->BindPath,
                            IBD_EXACT_MATCH_ONLY))
        {
            pCtx->hr = pCtx->pBindSet->HrAddBindPath (&pCtx->BindPath,
                                        INS_APPEND | pCtx->dwAddBindPathFlags);
        }
    }

    const CComponent* pRemoved;

    pRemoved = pCtx->BindPath.RemoveLastComponent();

    // This should be the component we appened above.
    //
    Assert (pRemoved == pComponent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\upgrade.cpp ===
#include <pch.h>
#pragma hdrstop
#include "persist.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "util.h"

HRESULT HrAddOrRemoveWinsockDependancy(
    IN HINF hinfInstallFile,
    IN PCWSTR pszSectionName);


HRESULT
HrLoadAndAddComponentFromInstanceKey (
    IN HKEY hkey,
    IN const GUID* pInstanceGuid,
    IN NETCLASS Class,
    IN PCWSTR pszPnpId OPTIONAL,
    IN OUT CNetConfig* pNetConfig)
{
    HRESULT hr;
    BASIC_COMPONENT_DATA Data;
    CComponent* pComponent;
    WCHAR szInfId [_MAX_PATH];
    WCHAR szMiniportId [_MAX_PATH];
    ULONG cbInfId;

    Assert (hkey);
    Assert (pInstanceGuid);
    Assert (FIsValidNetClass (Class));
    Assert (FImplies(pszPnpId, *pszPnpId));
    Assert (pNetConfig);

    ZeroMemory (&Data, sizeof(Data));

    hr = HrRegQueryDword (hkey, L"Characteristics", &Data.dwCharacter);
    if (S_OK == hr)
    {
        // If the component is a filter, copy Ndi\MiniportId to
        // Ndi\FilterDeviceInfId.
        //
        if (Data.dwCharacter & NCF_FILTER)
        {
            HKEY hkeyNdi;

            hr = HrRegOpenKeyEx (
                    hkey,
                    L"Ndi",
                    KEY_READ | KEY_WRITE,
                    &hkeyNdi);

            if (S_OK == hr)
            {
                HKEY hkeyInterfaces;
                DWORD cbMiniportId = sizeof(szMiniportId);

                hr = HrRegQuerySzBuffer (
                        hkeyNdi,
                        L"MiniportId",
                        szMiniportId,
                        &cbMiniportId);

                if (S_OK == hr)
                {
                    (VOID) HrRegSetSz (
                                hkeyNdi,
                                L"FilterDeviceInfId",
                                szMiniportId);
                }

                if (FInSystemSetup())
                {
                    // Need to update LowerExclude for filters (the only one
                    // being PSched) so we prevent PSched from binding to
                    // every adapter on the machine.  This only needs to
                    // happen during GUI setup and when we detect no Config
                    // binary because this happens way before INFs get re-run.)
                    //
                    hr = HrRegOpenKeyEx (
                            hkeyNdi,
                            L"Interfaces",
                            KEY_WRITE,
                            &hkeyInterfaces);

                    if (S_OK == hr)
                    {
                        (VOID) HrRegSetSz (
                                    hkeyInterfaces,
                                    L"LowerExclude",
                                    L"ndiscowan, ndiswan, ndiswanasync, "
                                    L"ndiswanipx, ndiswannbf");

                        RegCloseKey (hkeyInterfaces);
                    }
                }

                RegCloseKey (hkeyNdi);
                hr = S_OK;
            }
        }

        cbInfId = sizeof(szInfId);
        hr = HrRegQuerySzBuffer (hkey, L"ComponentId", szInfId, &cbInfId);
        if (S_OK == hr)
        {
            // Wanarp needs its refcounts key deleted in case we are
            // loaded before netupgrd.inf is run.
            //
            if (0 == _wcsicmp(L"ms_wanarp", szInfId))
            {
                (VOID)HrRegDeleteKey (hkey, L"RefCounts");
            }

            Data.InstanceGuid = *pInstanceGuid;
            Data.Class = Class;
            Data.pszInfId = szInfId;
            Data.pszPnpId = pszPnpId;

            // It is important to make sure we can load the external data
            // for two reasons:
            //  1) If we have a failure reading critical data that we
            //     need in order to function, we want to know about it
            //     now, before we add it to the component list.
            //  2) For filter devices which will be subsequently upgraded,
            //     we need to search for specific components by BindForm
            //     and BindName which are external data loaded by the
            //     following call.
            //
            hr = CComponent::HrCreateInstance (
                    &Data,
                    CCI_ENSURE_EXTERNAL_DATA_LOADED,
                    NULL,
                    &pComponent);
            if (S_OK == hr)
            {
                // Add the component and the stack entries, but don't
                // send any notifications to notify objects.
                //
                hr = pNetConfig->Core.HrAddComponentToCore (
                        pComponent, INS_SORTED);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadAndAddComponentFromInstanceKey");
    return hr;
}

BOOL
FUpgradeFilterDeviceInstanceKey (
    IN CNetConfig* pNetConfig,
    IN HKEY hkeyInstance,
    IN PCWSTR pszFilterName)
{
    CComponent* pFilter;

    // The new binding engine uses FilterInfId located in under the instance
    // key instead of FilterName under Ndi.
    //
    pFilter = pNetConfig->Core.Components.PFindComponentByBindForm (
                NC_NETSERVICE, pszFilterName);

    if (pFilter)
    {
        (VOID) HrRegSetSz (hkeyInstance, L"FilterInfId", pFilter->m_pszInfId);

        return TRUE;
    }
    return FALSE;
}

HRESULT
HrLoadComponentReferencesFromLegacy (
    IN OUT CNetConfig* pNetConfig)
{
    HRESULT hr = S_OK;
    CComponentList::iterator iter;
    CComponent* pComponent;
    HKEY hkeyInstance;

    Assert (pNetConfig);

    for (iter  = pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        hr = pComponent->HrOpenInstanceKey (KEY_READ,
                &hkeyInstance, NULL, NULL);

        if (S_OK == hr)
        {
            HKEY hkeyRefCounts;

            hr = HrRegOpenKeyEx (hkeyInstance, L"RefCounts",
                    KEY_READ, &hkeyRefCounts);

            if (S_OK == hr)
            {
                DWORD dwIndex;
                WCHAR szValueName [_MAX_PATH];
                DWORD cchValueName;
                DWORD dwType;
                DWORD dwRefCount;
                DWORD cbData;
                CComponent* pRefdByComponent;
                GUID InstanceGuid;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    cchValueName = celems(szValueName);
                    cbData = sizeof(dwRefCount);

                    hr = HrRegEnumValue (hkeyRefCounts, dwIndex,
                            szValueName, &cchValueName, &dwType,
                            (LPBYTE)&dwRefCount, &cbData);

                    if (S_OK == hr)
                    {
                        if (0 == _wcsicmp (L"User", szValueName))
                        {
                            hr = pComponent->Refs.HrAddReferenceByUser ();
                        }
                        else if ((L'{' == *szValueName) &&
                                 (S_OK == IIDFromString (szValueName, &InstanceGuid)) &&
                                 (NULL != (pRefdByComponent = pNetConfig->Core.Components.PFindComponentByInstanceGuid(&InstanceGuid))))
                        {
                            hr = pComponent->Refs.HrAddReferenceByComponent (
                                    pRefdByComponent);
                        }
                        else if (NULL != (pRefdByComponent = pNetConfig->
                                    Core.Components.PFindComponentByInfId (
                                            szValueName, NULL)))
                        {
                            hr = pComponent->Refs.HrAddReferenceByComponent (
                                    pRefdByComponent);
                        }
                        else
                        {
                            hr = pComponent->Refs.HrAddReferenceBySoftware (
                                    szValueName);
                        }
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                RegCloseKey (hkeyRefCounts);
            }

            RegCloseKey (hkeyInstance);
        }
    }

    // If the instance key or the refcounts key don't exist, there is not
    // much we can do about it.  Don't fail for these reasons.
    //
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadComponentReferencesFromLegacy");
    return hr;
}

VOID
UpgradeConnection (
    IN const GUID& InstanceGuid,
    IN PCWSTR pszPnpId)
{
    HRESULT hr;
    WCHAR szPath[_MAX_PATH];
    HKEY hkeyConn;

    Assert (pszPnpId && *pszPnpId);

    // Connections uses a pnp id value as their back pointer to the pnp
    // tree.
    //
    CreateInstanceKeyPath (NC_NET, InstanceGuid, szPath);
    wcscat (szPath, L"\\Connection");
    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, szPath, KEY_READ_WRITE,
            &hkeyConn);

    if (S_OK == hr)
    {
        HrRegSetSz (hkeyConn, L"PnpInstanceId", pszPnpId);
    }

    RegCloseKey(hkeyConn);
}

HRESULT
HrLoadNetworkConfigurationFromLegacy (
    OUT CNetConfig* pNetConfig)
{
    HRESULT hr;
    NETCLASS Class;
    PCWSTR pszSubtree;
    HKEY hkeySubtree;
    DWORD dwIndex;
    HKEY hkeyInstance;
    GUID InstanceGuid;
    UINT PassNumber;

    // Get the value for whether WAN adapters comes first or last in
    // adapter order.  We need to give this to the stack table so it will
    // know which way to order things.
    //
    Assert (FALSE == pNetConfig->Core.StackTable.m_fWanAdaptersFirst);

    hr = HrOpenNetworkKey (
            KEY_READ,
            &hkeySubtree);

    if (S_OK == hr)
    {
        DWORD dwValue;

        hr = HrRegQueryDword (hkeySubtree, L"WanAdaptersFirst", &dwValue);

        if (S_OK == hr)
        {
            pNetConfig->Core.StackTable.m_fWanAdaptersFirst = !!dwValue;
        }

        RegCloseKey (hkeySubtree);
    }

    // We need two passes to correctly upgrade everything.  Since filter
    // devices reference an adapter, we need to have already read the
    // information for all adapters before we can read information about
    // a filter device and create a memory representation for it which
    // references the memory representation of the adapter which it filters.
    //
    // The following structure should make this more clear.  For each
    // element in this array, we enumerate components in the specified
    // class.  Note that NC_NET is reference twice -- once for pass one
    // and once for pass two.  The code below uses the pass number to
    // know whether it should be ignoring filter devices (in pass one)
    // or ignoring adapters (in pass two, because they were already handled
    // in pass one.)  If it isn't clear by now, don't touch this code. ;-)
    //
    static const struct
    {
        NETCLASS    Class;
        UINT        PassNumber;
    } aPassInfo [] =
    {
        { NC_NET,        1 },
        { NC_INFRARED,   1 },
        { NC_NETTRANS,   1 },
        { NC_NETCLIENT,  1 },
        { NC_NETSERVICE, 1 },
        { NC_NET,        2 },
    };

    for (UINT i = 0; i < celems(aPassInfo); i++)
    {
        Class      = aPassInfo[i].Class;
        PassNumber = aPassInfo[i].PassNumber;

        Assert (FIsValidNetClass(Class));

        pszSubtree = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];

        if (!FIsEnumerated (Class))
        {
            hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, pszSubtree,
                    KEY_READ, &hkeySubtree);

            if (S_OK == hr)
            {
                DWORD cchGuid;
                WCHAR szInstanceGuid [c_cchGuidWithTerm];
                FILETIME ftLastWrite;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    cchGuid = celems(szInstanceGuid);

                    hr = HrRegEnumKeyEx (
                            hkeySubtree, dwIndex, szInstanceGuid, &cchGuid,
                            NULL, NULL, &ftLastWrite);

                    if ((S_OK == hr) && ((c_cchGuidWithTerm-1) == cchGuid))
                    {
                        hr = IIDFromString (szInstanceGuid, &InstanceGuid);
                        if (S_OK == hr)
                        {
                            hr = HrRegOpenKeyEx (
                                    hkeySubtree,
                                    szInstanceGuid,
                                    KEY_READ,
                                    &hkeyInstance);

                            if (S_OK == hr)
                            {
                                hr = HrLoadAndAddComponentFromInstanceKey (
                                        hkeyInstance,
                                        &InstanceGuid,
                                        Class,
                                        NULL,
                                        pNetConfig);

                                RegCloseKey (hkeyInstance);
                            }
                        }
                        else
                        {
                            // Delete the key?
                        }

                        // Ignore any errors during the loop
                        hr = S_OK;
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                RegCloseKey (hkeySubtree);
            }
        }
        else
        {
            HDEVINFO hdi;

            hr = HrSetupDiGetClassDevs (MAP_NETCLASS_TO_GUID[Class],
                    NULL, NULL, DIGCF_PROFILE, &hdi);

            if (S_OK == hr)
            {
                SP_DEVINFO_DATA deid;
                WCHAR szPnpId [2 * _MAX_PATH];
                WCHAR szFilterName [_MAX_PATH];
                BOOL fr;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    hr = HrSetupDiEnumDeviceInfo (hdi, dwIndex, &deid);

                    if (S_OK == hr)
                    {
                        fr = SetupDiGetDeviceInstanceId (
                                hdi, &deid,
                                szPnpId, celems(szPnpId), NULL);

                        if (fr)
                        {
                            // We open with KEY_WRITE because we will be
                            // adding a new value to filter devices we
                            // upgrade.
                            //
                            hr = HrSetupDiOpenDevRegKey (
                                    hdi, &deid,
                                    DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                                    KEY_WRITE | KEY_READ, &hkeyInstance);

                            if (S_OK == hr)
                            {
                                LONG lr;
                                ULONG cbGuid = sizeof(GUID);

                                lr = RegQueryGuid (
                                        hkeyInstance,
                                        L"NetCfgInstanceId",
                                        &InstanceGuid,
                                        &cbGuid);

                                if (!lr)
                                {
                                    BOOL fIsFilterDevice;
                                    HKEY hkeyNdi;

                                    fIsFilterDevice = FALSE;

                                    hr = HrRegOpenKeyEx (
                                            hkeyInstance,
                                            L"Ndi",
                                            KEY_READ,
                                            &hkeyNdi);

                                    if (S_OK == hr)
                                    {
                                        DWORD cbFilterName = sizeof(szFilterName);

                                        hr = HrRegQuerySzBuffer (
                                                hkeyNdi,
                                                L"FilterName",
                                                szFilterName,
                                                &cbFilterName);

                                        if (S_OK == hr)
                                        {
                                            fIsFilterDevice = TRUE;
                                        }

                                        RegCloseKey (hkeyNdi);
                                    }

                                    // If it's a filter device, ignore it in
                                    // pass one and handle it in pass two.
                                    //
                                    if (fIsFilterDevice && (2 == PassNumber))
                                    {
                                        FUpgradeFilterDeviceInstanceKey (
                                                pNetConfig,
                                                hkeyInstance,
                                                szFilterName);
                                    }

                                    // If it's not a filter device, handle it
                                    // in pass one and ignore it in pass two.
                                    //
                                    else if (!fIsFilterDevice && (1 == PassNumber))
                                    {
                                        UpgradeConnection (InstanceGuid,
                                                szPnpId);

                                        hr = HrLoadAndAddComponentFromInstanceKey (
                                                hkeyInstance,
                                                &InstanceGuid,
                                                Class,
                                                szPnpId,
                                                pNetConfig);
                                    }
                                }

                                RegCloseKey (hkeyInstance);
                            }
                        }

                        // Ignore any errors during the loop
                        hr = S_OK;
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                SetupDiDestroyDeviceInfoList (hdi);
            }
        }
    }

    if (S_OK == hr)
    {
        hr = HrLoadComponentReferencesFromLegacy (pNetConfig);
    }

    if (S_OK == hr)
    {
        CComponentList::iterator iter;
        CComponent* pComponent;
        CBindPath BindPath;
        CBindingSet BindSet;
        HKEY hkeyParent;
        HKEY hkeyDisabled;

        // Upgrade disabled bindings.
        //
        for (iter  = pNetConfig->Core.Components.begin();
             iter != pNetConfig->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // Open the parent of the linkage key depending on what type
            // of component this is.
            //
            if (FIsEnumerated (pComponent->Class()) || !pComponent->FHasService())
            {
                hr = pComponent->HrOpenInstanceKey (KEY_READ, &hkeyParent,
                        NULL, NULL);
            }
            else
            {
                hr = pComponent->HrOpenServiceKey (KEY_READ, &hkeyParent);
            }

            // Open the Linkage\Disabled key.
            //
            if (S_OK == hr)
            {
                hr = HrRegOpenKeyEx (hkeyParent, L"Linkage\\Disabled",
                        KEY_READ,
                        &hkeyDisabled);

                if (S_OK == hr)
                {
                    PWSTR pmszBindPath;

                    hr = HrRegQueryMultiSzWithAlloc (
                            hkeyDisabled,
                            L"BindPath",
                            &pmszBindPath);

                    if (S_OK == hr)
                    {
                        PWSTR pszBindPath;
                        PCWSTR pszBindName;
                        PWSTR pszNext;
                        CComponent* pOther;

                        // Get the components current bindings as they
                        // exist in the new engine.  We won't disable
                        // any bindings that don't exist in this set.
                        //
                        (VOID) pNetConfig->Core.HrGetComponentBindings (
                                pComponent,
                                GBF_DEFAULT,
                                &BindSet);

                        // Iterate the multi-sz of disabled bindpaths.
                        //
                        for (pszBindPath = pmszBindPath;
                             *pszBindPath;
                             pszBindPath += wcslen(pszBindPath) + 1)
                        {
                            // The bindpath will start with this component
                            // that has the disabled bindings.
                            //
                            BindPath.Clear();
                            BindPath.HrAppendComponent (pComponent);

                            for (pszBindName = GetNextStringToken (pszBindPath, L"_", &pszNext);
                                 pszBindName && *pszBindName;
                                 pszBindName = GetNextStringToken (NULL, L"_", &pszNext))
                            {
                                pOther = pNetConfig->Core.Components.
                                            PFindComponentByBindName (
                                                NC_INVALID, pszBindName);

                                if (!pOther)
                                {
                                    break;
                                }

                                BindPath.HrAppendComponent (pOther);
                            }

                            // If the bindpath is valid, disable it.
                            //
                            if (BindSet.FContainsBindPath (&BindPath))
                            {
                                pNetConfig->Core.HrDisableBindPath (&BindPath);
                            }
                        }

                        MemFree (pmszBindPath);
                    }

                    RegCloseKey (hkeyDisabled);
                }

                RegCloseKey (hkeyParent);
            }
        }

        // If we can't upgrade disabled bindings, no biggee.
        //
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadNetworkConfigurationFromLegacy");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\stable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       S T A B L E . H
//
//  Contents:   Defines the datatypes to represent stack entries and stack
//              tables.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "bindings.h"
#include "comp.h"

class CStackEntry
{
public:
    const CComponent*  pUpper;
    const CComponent*  pLower;

public:
    BOOL
    operator== (
        const CStackEntry& Other) const
    {
        return (pUpper == Other.pUpper) && (pLower == Other.pLower);
    }
};


class CModifyContext;

enum MOVE_FLAG
{
    MOVE_BEFORE = 1,
    MOVE_AFTER = 2,
};

class CStackTable : public vector<CStackEntry>
{
public:
    // This flag indicates how WAN adapters are inserted into the stack
    // table.  If TRUE, they are inserted before any LAN adapters.  If
    // FALSE, they are inserted after any LAN adapters.
    //
    BOOL    m_fWanAdaptersFirst;

public:
    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    CountEntries ()
    {
        return size();
    }

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    BOOL
    FStackEntryInTable (
        IN const CComponent*  pUpper,
        IN const CComponent*  pLower) const;

    HRESULT
    HrCopyStackTable (
        IN const CStackTable* pSourceTable);

    HRESULT
    HrInsertStackEntriesForComponent (
        IN const CComponent* pComponent,
        IN const CComponentList* pComponents,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrUpdateEntriesForComponent (
        IN const CComponent* pComponent,
        IN const CComponentList* pComponents,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrInsertStackEntry (
        IN const CStackEntry* pStackEntry,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrMoveStackEntries (
        IN const CStackEntry* pSrc,
        IN const CStackEntry* pDst,
        IN MOVE_FLAG Flag,
        IN CModifyContext* pModifyCtx);

    HRESULT
    HrReserveRoomForEntries (
        IN UINT cEntries);

    VOID
    RemoveEntriesWithComponent (
        IN const CComponent* pComponent);

    VOID
    SetWanAdapterOrder (
        IN BOOL fWanAdaptersFirst);

    VOID
    RemoveStackEntry(
        IN const CComponent*  pUpper,
        IN const CComponent*  pLower);
};


class CNetConfigCore;

// Context structure for recursive function GetBindingsBelowComponent.
//
struct GBCONTEXT
{
    // The core to reference for generating the binding set.
    //
    IN const CNetConfigCore*    pCore;

    // The binding set to generate based on pSourceComponent.
    //
    IN OUT  CBindingSet*        pBindSet;

    // The component to start with when generating the binding set.
    //
    IN      const CComponent*   pSourceComponent;

    // If TRUE, do not add those bindpaths to pBindSet that exist in
    // pCore->DisabledBindings.  This feature is used when we generate the
    // bindings that get written to the registry.
    //
    IN      BOOL                fPruneDisabledBindings;

    // Special case: NCF_DONTEXPOSELOWER
    //
    IN      DWORD               dwAddBindPathFlags;

    // The result of the operation.
    //
    OUT     HRESULT             hr;

    // This is the bindpath that is built up via recursion.  It is
    // added to the binding set when recursion finishes.
    //
    OUT     CBindPath           BindPath;
};


// Context structure for recursive functions:
//   GetComponentsAboveComponent
//
struct GCCONTEXT
{
    // The stack table to reference for generating the component list.
    //
    IN      const CStackTable*  pStackTable;

    // The component list to generate.
    //
    IN OUT  CComponentList*     pComponents;

    // If TRUE, don't stop recursing at NCF_DONTEXPOSELOWER components.
    //
    IN      BOOL                fIgnoreDontExposeLower;

    // The result of the operation.
    //
    OUT     HRESULT             hr;
};

VOID
GetComponentsAboveComponent (
    IN const CComponent* pComponent,
    IN OUT GCCONTEXT* pCtx);

VOID
GetBindingsBelowComponent (
    IN      const CComponent*   pComponent,
    IN OUT  GBCONTEXT*            pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\resource.h ===
#include <ncres.h>

#define IDS_NETCFG_AFD_SERVICE_DESC             (IDS_NC_NETCFG +  2)
#define IDS_SELECTDEVICEADAPTERINSTRUCTIONS     (IDS_NC_NETCFG +  3)
#define IDS_SELECTDEVICEADAPTERLISTLABEL        (IDS_NC_NETCFG +  4)
#define IDS_SELECTDEVICEADAPTERSUBTITLE         (IDS_NC_NETCFG +  5)
#define IDS_SELECTDEVICEADAPTERTITLE            (IDS_NC_NETCFG +  6)
#define IDS_SELECTDEVICECLIENTINSTRUCTIONS      (IDS_NC_NETCFG +  7)
#define IDS_SELECTDEVICECLIENTLISTLABEL         (IDS_NC_NETCFG +  8)
#define IDS_SELECTDEVICECLIENTTITLE             (IDS_NC_NETCFG +  9)
#define IDS_SELECTDEVICEINFRAREDINSTRUCTIONS    (IDS_NC_NETCFG + 10)
#define IDS_SELECTDEVICEINFRAREDLISTLABEL       (IDS_NC_NETCFG + 11)
#define IDS_SELECTDEVICEINFRAREDSUBTITLE        (IDS_NC_NETCFG + 12)
#define IDS_SELECTDEVICEINFRAREDTITLE           (IDS_NC_NETCFG + 13)
#define IDS_SELECTDEVICEPROTOCOLINSTRUCTIONS    (IDS_NC_NETCFG + 14)
#define IDS_SELECTDEVICEPROTOCOLLISTLABEL       (IDS_NC_NETCFG + 15)
#define IDS_SELECTDEVICEPROTOCOLTITLE           (IDS_NC_NETCFG + 16)
#define IDS_SELECTDEVICESERVICEINSTRUCTIONS     (IDS_NC_NETCFG + 17)
#define IDS_SELECTDEVICESERVICELISTLABEL        (IDS_NC_NETCFG + 18)
#define IDS_SELECTDEVICESERVICETITLE            (IDS_NC_NETCFG + 19)
#define IDS_HAVEDISK_INSTRUCTIONS               (IDS_NC_NETCFG + 20)
#define IDS_INVALID_NT_INF                      (IDS_NC_NETCFG + 21)
#define IDS_WARNING_CAPTION                     (IDS_NC_NETCFG + 22)
#define IDS_ACTIVE_RAS_CONNECTION_WARNING       (IDS_NC_NETCFG + 23)
#define IDS_POWER_MESSAGE_WAKE                  (IDS_NC_NETCFG + 24)

// Bug# 310358 
// MUI enabled HelpText for network components
// format: IDS_ComponentId_HELP_TEXT
// IDS_NC_COMP_HELP_TEXT is #define'ed as 50000. DON'T change this numbers 
// because inx files located in %sdxroot%\net\config\netcfg\inf depend on 
// these resource ids.
// Note: For component with Characteristics of NCF_HIDDEN, they don't need
//       to be MUI enabled. 
#define IDS_MS_TCPIP_HELP_TEXT                  (IDS_NC_COMP_HELP_TEXT + 1) 
#define IDS_MS_MSCLIENT_HELP_TEXT               (IDS_NC_COMP_HELP_TEXT + 2) 
#define IDS_MS_SERVER_HELP_TEXT                 (IDS_NC_COMP_HELP_TEXT + 3)
#define IDS_MS_ATMARPS_HELP_TEXT                (IDS_NC_COMP_HELP_TEXT + 4)
#define IDS_MS_APPLETALK_HELP_TEXT              (IDS_NC_COMP_HELP_TEXT + 5)
#define IDS_MS_ATMUNI_HELP_TEXT                 (IDS_NC_COMP_HELP_TEXT + 6)
#define IDS_MS_RELAYAGENT_HELP_TEXT             (IDS_NC_COMP_HELP_TEXT + 7)
#define IDS_MS_ATMELAN_HELP_TEXT                (IDS_NC_COMP_HELP_TEXT + 9)
#define IDS_MS_ATMLANE_HELP_TEXT                (IDS_NC_COMP_HELP_TEXT + 10)
#define IDS_MS_NWCLIENT_HELP_TEXT               (IDS_NC_COMP_HELP_TEXT + 12)
#define IDS_MS_NWIPX_HELP_TEXT                  (IDS_NC_COMP_HELP_TEXT + 13)
#define IDS_MS_NWNB_HELP_TEXT                   (IDS_NC_COMP_HELP_TEXT + 14)
#define IDS_MS_PSCHED_HELP_TEXT                 (IDS_NC_COMP_HELP_TEXT + 15)
#define IDS_MS_NWSAPAGENT_HELP_TEXT             (IDS_NC_COMP_HELP_TEXT + 16)
#define IDS_MS_FPNW_HELP_TEXT                   (IDS_NC_COMP_HELP_TEXT + 17)
#define IDS_MS_ISOTPSYS_HELP_TEXT               (IDS_NC_COMP_HELP_TEXT + 18)
#define IDS_MS_WLBS_HELP_TEXT                   (IDS_NC_COMP_HELP_TEXT + 19)
#define IDS_MS_NETMON_HELP_TEXT                 (IDS_NC_COMP_HELP_TEXT + 20)


// Do not change this number since external clients access this resource
#define IDI_INFRARED_ICON                       1401
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\util.h ===
#pragma once

#include "compdefs.h"
#include "comp.h"

BOOL
FIsFilterDevice (HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);

BOOL
FSubstringMatch (
    IN PCWSTR pStr1,
    IN PCWSTR pStr2,
    OUT const WCHAR** ppStart,
    OUT ULONG* pcch);

PWSTR
GetNextStringToken (
    IN OUT PWSTR pszString,
    IN PCWSTR pszDelims,
    OUT PWSTR* ppszNextToken);

HRESULT
HrOpenNetworkKey (
    IN REGSAM samDesired,
    OUT HKEY* phkey);

HRESULT
HrRegCreateKeyWithWorldAccess (
    HKEY hkey,
    PCWSTR pszSubkey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkey,
    LPDWORD pdwDisposition);

LONG
RegQueryValueType (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    OUT BYTE* pbData OPTIONAL,
    IN OUT DWORD* pcbData);

LONG
RegQueryGuid (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    OUT GUID* pguidData OPTIONAL,
    IN OUT DWORD* pcbData
    );

VOID
SignalNetworkProviderLoaded (
    VOID);

VOID
CreateInstanceKeyPath (
    NETCLASS Class,
    const GUID& InstanceGuid,
    PWSTR pszPath);

VOID
AddOrRemoveDontExposeLowerCharacteristicIfNeeded (
    IN OUT CComponent* pComponent);

class CDynamicBuffer
{
private:
    PBYTE   m_pbBuffer;
    ULONG   m_cbConsumed;
    ULONG   m_cbAllocated;
    ULONG   m_cbGranularity;

    BOOL
    FGrowBuffer (
        ULONG cbGrow);

public:
    CDynamicBuffer ()
    {
        ZeroMemory (this, sizeof(*this));
    }
    ~CDynamicBuffer ()
    {
        MemFree (m_pbBuffer);
    }

    VOID
    Clear ()
    {
        // Most of the time, the buffer is treated as a string.  Setting
        // the buffer to an empty string is a convienence for callers who
        // clear the buffer then try to use it as a string.  This way, they
        // don't have to check the CountOfBytesUsed before accessing the
        // buffer contents.
        //
        AssertH (m_pbBuffer);
        AssertH (m_cbAllocated > sizeof(WCHAR));
        *((PWCHAR)m_pbBuffer) = 0;

        m_cbConsumed = 0;
    }

    ULONG
    CountOfBytesUsed ()
    {
        return m_cbConsumed;
    }

    const BYTE*
    PbBuffer ()
    {
        AssertH (m_pbBuffer);
        return m_pbBuffer;
    }

    VOID
    SetGranularity (
        ULONG cbGranularity)
    {
        m_cbGranularity = cbGranularity;
    }

    HRESULT
    HrReserveBytes (
        ULONG cbReserve);

    HRESULT
    HrCopyBytes (
        const BYTE* pbSrc,
        ULONG cbSrc);

    HRESULT
    HrCopyString (
        PCWSTR pszSrc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\util.cpp ===
#include <pch.h>
#pragma hdrstop
#include "comp.h"
#include "nccom.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "util.h"

VOID
CreateInstanceKeyPath (
    NETCLASS Class,
    const GUID& InstanceGuid,
    PWSTR pszPath)
{
    PCWSTR pszNetworkSubtreePath;

    Assert (pszPath);

    pszNetworkSubtreePath = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];
    AssertSz (pszNetworkSubtreePath,
        "This class does not use the network subtree.");

    wcscpy (pszPath, pszNetworkSubtreePath);
    wcscat (pszPath, L"\\");

    INT cch = StringFromGUID2 (
                InstanceGuid,
                pszPath + wcslen(pszPath),
                c_cchGuidWithTerm);
    Assert (c_cchGuidWithTerm == cch);
}

HRESULT
HrOpenDeviceInfo (
    IN NETCLASS Class,
    IN PCWSTR pszPnpId,
    OUT HDEVINFO* phdiOut,
    OUT SP_DEVINFO_DATA* pdeidOut)
{
    HRESULT hr;

    Assert (FIsEnumerated(Class));
    Assert (pszPnpId && *pszPnpId);
    Assert (phdiOut);
    Assert (pdeidOut);

    hr = HrSetupDiCreateDeviceInfoList (
            NULL,
            NULL,
            phdiOut);

    if (S_OK == hr)
    {
        hr = HrSetupDiOpenDeviceInfo (
                *phdiOut,
                pszPnpId,
                NULL,
                0,
                pdeidOut);

        // On failure, cleanup the hdevinfo.
        //
        if (S_OK != hr)
        {
            SetupDiDestroyDeviceInfoList (*phdiOut);
            *phdiOut = NULL;
        }
    }


    TraceHr (ttidError, FAL, hr, SPAPI_E_NO_SUCH_DEVINST == hr,
            "HrOpenDeviceInfo (%S)", pszPnpId);
    return hr;
}


HRESULT
HrOpenComponentInstanceKey (
    IN NETCLASS Class,
    IN const GUID& InstanceGuid, OPTIONAL
    IN PCWSTR pszPnpId, OPTIONAL
    IN REGSAM samDesired,
    OUT HKEY* phkey,
    OUT HDEVINFO* phdiOut OPTIONAL,
    OUT SP_DEVINFO_DATA* pdeidOut OPTIONAL)
{
    HRESULT hr;
    WCHAR szInstanceKeyPath [_MAX_PATH];

    Assert (FIsValidNetClass(Class));
    Assert (FImplies(FIsConsideredNetClass(Class), pszPnpId && *pszPnpId));
    Assert (phkey);
    Assert ((phdiOut && pdeidOut) || (!phdiOut && !pdeidOut));

    *phkey = NULL;

    if (phdiOut)
    {
        *phdiOut = NULL;
    }

    // Non-enumerated components have there instance key under the Network
    // tree.
    //
    if (!FIsEnumerated (Class))
    {
        CreateInstanceKeyPath(Class, InstanceGuid, szInstanceKeyPath);

        hr = HrRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                szInstanceKeyPath,
                samDesired,
                phkey);

        TraceHr (ttidError, FAL, hr, FALSE, "HrOpenInstanceKey (%S)",
            szInstanceKeyPath);
    }

    // For enumerated components, we get the instance key from PnP.
    //
    else
    {
        Assert (pszPnpId);

        HDEVINFO hdi;
        SP_DEVINFO_DATA deid;
        SP_DEVINFO_DATA* pdeid;

        pdeid = (pdeidOut) ? pdeidOut : &deid;

        hr = HrOpenDeviceInfo (Class, pszPnpId, &hdi, pdeid);

        if (S_OK == hr)
        {
            hr = HrSetupDiOpenDevRegKey (
                    hdi,
                    pdeid,
                    DICS_FLAG_GLOBAL,
                    0,
                    DIREG_DRV,
                    samDesired,
                    phkey);

            if (S_OK == hr)
            {
                if (phdiOut)
                {
                    *phdiOut = hdi;
                }
            }

            // On error, or if the caller doesn't want the HDEVINFO, free it.
            //
            if (!phdiOut || (S_OK != hr))
            {
                SetupDiDestroyDeviceInfoList (hdi);
            }
        }
        else if ((SPAPI_E_NO_SUCH_DEVINST == hr) && (KEY_READ == samDesired))
        {
            // The instance key may not exist for the case when the
            // class installer is called to remove an enumerated
            // component and then notifies us to remove its bindings.
            // For this case, the class installer has created a
            // temporary key under the Network subtree that we can use
            // to read a limited set of the data (namely LowerRange and
            // UpperRange) we'll need to finish off the removal.
            //
            // We only do this for KEY_READ since there is no point in
            // allowing anyone else to write to this key.  This prevents
            // HrCreateLinkageKey in particular from trying to write
            // to this key.
            //
            wcscpy (szInstanceKeyPath,
                    c_szTempNetcfgStorageForUninstalledEnumeratedComponent);

            INT cch = StringFromGUID2 (
                        InstanceGuid,
                        szInstanceKeyPath + wcslen(szInstanceKeyPath),
                        c_cchGuidWithTerm);
            Assert (c_cchGuidWithTerm == cch);

            hr = HrRegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    szInstanceKeyPath,
                    KEY_READ,
                    phkey);

            if (S_OK != hr)
            {
                hr = SPAPI_E_NO_SUCH_DEVINST;
            }
        }

        TraceHr (ttidError, FAL, hr,
            (SPAPI_E_NO_SUCH_DEVINST == hr),
            "HrOpenInstanceKey (%S)", pszPnpId);
    }

    return hr;
}

HRESULT
HrOpenNetworkKey (
    IN REGSAM samDesired,
    OUT HKEY* phkey)
{
    HRESULT hr;

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\Network",
            samDesired,
            phkey);

    TraceHr (ttidError, FAL, hr, FALSE, "HrOpenNetworkKey");
    return hr;
}

HRESULT
HrRegCreateKeyWithWorldAccess (
    HKEY hkey,
    PCWSTR pszSubkey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkey,
    LPDWORD pdwDisposition)
{
    HRESULT hr;
    SECURITY_ATTRIBUTES sa = {0};
    PSECURITY_DESCRIPTOR pSd;

    // Create the correct descriptor. If this fails, we'll still
    // create the key, it's just that if a service running as
    // localsystem is creating this key, and a user process tries
    // to open it, it will fail.
    //
    hr = HrAllocateSecurityDescriptorAllowAccessToWorld (&pSd);

    if (S_OK == hr)
    {
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle = FALSE;
    }
    else
    {
        Assert (!pSd);
        TraceHr (ttidError, FAL, hr, FALSE,
            "HrAllocateSecurityDescriptorAllowAccessToWorld "
            "failed in HrRegCreateKeyWithWorldAccess");
    }

    hr = HrRegCreateKeyEx (
            hkey,
            pszSubkey,
            dwOptions,
            samDesired,
            (pSd) ? &sa : NULL,
            phkey,
            pdwDisposition);

    MemFree (pSd);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRegCreateKeyWithWorldAccess");
    return hr;
}

PWSTR
GetNextStringToken (
    IN OUT PWSTR pszString,
    IN PCWSTR pszDelims,
    OUT PWSTR* ppszNextToken)
{
    const WCHAR* pchDelim;
    PWSTR pszToken;

    Assert (pszDelims);
    Assert (ppszNextToken);

    // If pszString is NULL, continue with the previous string.
    //
    if (!pszString)
    {
        pszString = *ppszNextToken;
        Assert (pszString);
    }

    // Find the beginning of the token by skipping over the leading
    // delimiters.  Note that there is no token if and only if this loop
    // sets pszString to point to the terminating NULL.
    //
    while (*pszString)
    {
        pchDelim = pszDelims;
        while (*pchDelim && (*pchDelim != *pszString))
        {
             pchDelim++;
        }

        if (!*pchDelim)
        {
            // Current string character is not a delimiter, so it must
            // be part of the token.  Break the loop and go find the
            // whole token.
            //
            break;
        }

        pszString++;
    }

    pszToken = pszString;

    // Find the end of the token.  If it is not the end of the string,
    // put a NULL there.
    //
    while (*pszString)
    {
        pchDelim = pszDelims;
        while (*pchDelim && (*pchDelim != *pszString))
        {
             pchDelim++;
        }

        if (*pchDelim)
        {
            // Found a delimiter so this ends the token.  Advance
            // pszString so that we'll set *ppszNextToken for next time.
            //
            *pszString = 0;
            pszString++;
            break;
        }

        pszString++;
    }

    // Remember where we left off for the next token.
    //
    *ppszNextToken = pszString;

    // Return the token if we found it.
    //
    if (pszToken == pszString)
    {
        return NULL;
    }
    else
    {
        return pszToken;
    }
}

#define GetNextCommaSeparatedToken(pStart, pEnd, cch)                   \
    pStart = pEnd;                                                      \
    while (*pStart && (*pStart == L' ' || *pStart == L','))   \
    {                                                                   \
        pStart++;                                                       \
    }                                                                   \
                                                                        \
    pEnd = pStart;                                                      \
    while (*pEnd && *pEnd != L' ' && *pEnd != L',')           \
    {                                                                   \
        pEnd++;                                                         \
    }                                                                   \
                                                                        \
    cch = pEnd - pStart;


BOOL
FSubstringMatch (
    PCTSTR          pStr1,
    PCTSTR          pStr2,
    const WCHAR**   ppStart,
    ULONG*          pcch)
{
    const WCHAR*    p1Start;
    const WCHAR*    p1End;
    const WCHAR*    p2Start;
    const WCHAR*    p2End;
    ULONG           cch1;
    ULONG           cch2;

    if (ppStart)
    {
        *ppStart = NULL;
    }
    if (pcch)
    {
        *pcch = NULL;
    }

    p1End = pStr1;
    while (1)
    {
        GetNextCommaSeparatedToken(p1Start, p1End, cch1);
        if (!cch1)
        {
            break;
        }

        p2End = pStr2;
        while (1)
        {
            GetNextCommaSeparatedToken(p2Start, p2End, cch2);
            if (!cch2)
            {
                break;
            }

            if (cch1 == cch2)
            {
                if (0 == memcmp(p1Start, p2Start, cch1 * sizeof(WCHAR)))
                {
                    if (ppStart)
                    {
                        *ppStart = p1Start;
                    }
                    if (pcch)
                    {
                        *pcch = cch1;
                    }

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

VOID
SignalNetworkProviderLoaded (
    VOID)
{
    HANDLE Event;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttr;
    NTSTATUS Status;

    RtlInitUnicodeString (
        &EventName,
        L"\\Security\\NetworkProviderLoad");

    InitializeObjectAttributes (
        &EventAttr,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        NULL, NULL);

    Status = NtOpenEvent (
                &Event,
                EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
                &EventAttr);

    if (NT_SUCCESS(Status))
    {
        SetEvent (Event);
        CloseHandle (Event);
    }
    else
    {
        ULONG Win32Error;

        Win32Error = RtlNtStatusToDosError(Status);
        SetLastError(Win32Error);

        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "SignalNetworkProviderLoaded");
    }
}

BOOL
CDynamicBuffer::FGrowBuffer (
    ULONG cbGrow)
{
    PBYTE pbNew;

    // If it hasn't been set, use a default of 4096.
    if (!m_cbGranularity)
    {
        m_cbGranularity = 4096;
    }

    if (cbGrow % m_cbGranularity)
    {
        cbGrow = (cbGrow + m_cbGranularity) - (cbGrow % m_cbGranularity);
    }

    pbNew = (PBYTE)MemAlloc (m_cbAllocated + cbGrow);

    if (pbNew)
    {
#ifdef ENABLETRACE
        if (m_pbBuffer)
        {
            TraceTag (ttidDefault, "Dynamic buffer grown.  New size = %d.",
                m_cbAllocated + cbGrow);
        }
#endif

        CopyMemory (pbNew, m_pbBuffer, m_cbConsumed);
        MemFree (m_pbBuffer);
        m_pbBuffer = pbNew;
        m_cbAllocated += cbGrow;
    }

    return !!pbNew;
}

HRESULT
CDynamicBuffer::HrReserveBytes (
    ULONG cbReserve)
{
    if (cbReserve > m_cbAllocated)
    {
        return (FGrowBuffer(cbReserve)) ? S_OK : E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT
CDynamicBuffer::HrCopyBytes (
    const BYTE* pbSrc,
    ULONG cbSrc)
{
    Assert (pbSrc);
    Assert (m_cbAllocated >= m_cbConsumed);

    if (cbSrc > m_cbAllocated - m_cbConsumed)
    {
        if (!FGrowBuffer (cbSrc))
        {
            return E_OUTOFMEMORY;
        }
    }

    CopyMemory (m_pbBuffer + m_cbConsumed, pbSrc, cbSrc);
    m_cbConsumed += cbSrc;

    return S_OK;
}

HRESULT
CDynamicBuffer::HrCopyString (
    PCWSTR pszSrc)
{
    ULONG cbSrc;

    cbSrc = CbOfSzAndTermSafe(pszSrc);

    return HrCopyBytes ((const BYTE*)pszSrc, cbSrc);
}

BOOL
FIsFilterDevice (HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    WCHAR szFilterInfId[_MAX_PATH];
    BOOL fIsFilterDevice = FALSE;
    HKEY hkeyInstance;
    HRESULT hr;

    // Open the device's driver key.
    //
    hr = HrSetupDiOpenDevRegKey (
            hdi, pdeid,
            DICS_FLAG_GLOBAL, 0, DIREG_DRV,
            KEY_READ, &hkeyInstance);

    if (S_OK == hr)
    {
        // Get the filterinfid value.  If present, then
        // this device is a filter device.
        //
        DWORD cbFilterInfId = sizeof(szFilterInfId);

        hr = HrRegQuerySzBuffer (
                hkeyInstance,
                L"FilterInfId",
                szFilterInfId,
                &cbFilterInfId);

        if (S_OK == hr)
        {
            fIsFilterDevice = TRUE;
        }

        RegCloseKey (hkeyInstance);
    }

    return fIsFilterDevice;
}

VOID
AddOrRemoveDontExposeLowerCharacteristicIfNeeded (
    IN OUT CComponent* pComponent)
{

    ASSERT (pComponent);

    // Special case: NCF_DONTEXPOSELOWER
    // SPX has erroneously set this characteristic. It's not really
    // needed as nothing binds with SPX.  Having it set means that
    // two components above IPX have this characteristic set.  (NWNB
    // is the other.  The code to generate bindpaths by recursing
    // the stack table is only setup to handle at most one component
    // with this characteristic per pass.  Turning it off for SPX
    // solves this in the simplest way.
    //
    // Furthermore, enforce that only IPX and NWNB have this
    // characteristic set..
    //
    //
    if ((0 == wcscmp(L"ms_nwnb",  pComponent->m_pszInfId)) ||
        (0 == wcscmp(L"ms_nwipx", pComponent->m_pszInfId)))
    {
        pComponent->m_dwCharacter |= NCF_DONTEXPOSELOWER;
    }
    else
    {
        pComponent->m_dwCharacter &= ~NCF_DONTEXPOSELOWER;
    }
    // End Special case
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\wrlock.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       W R L O C K . C P P
//
//  Contents:   Defines the interface to the netcfg write lock used to
//              protect the network configuration information from being
//              modified by more than one writer at a time.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "nccom.h"
#include "ncreg.h"
#include "util.h"
#include "wrlock.h"

#define MUTEX_NAME          L"Global\\NetCfgWriteLock"
#define LOCK_HOLDER_SUBKEY  L"NetCfgLockHolder"


CWriteLock::~CWriteLock ()
{
    // If we have the mutex created, release it if we own it
    // and close its handle.
    //
    if (m_hMutex)
    {
        ReleaseIfOwned ();
        CloseHandle (m_hMutex);
    }
}

HRESULT
CWriteLock::HrEnsureMutexCreated ()
{
    if (m_hMutex)
    {
        return S_OK;
    }

    // Ensure the mutex has been created.  It is important to create it
    // with a security descriptor that allows access to the world because
    // we may be running under the localsystem account and someone else
    // may be running under a user account.  If we didn't give the world
    // explicit access, the user account clients would get access denied
    // because the mutex would have inherited the security level of our
    // process.
    //
    HRESULT hr;
    Assert (!m_hMutex);
    Assert (!m_fOwned);

    hr = HrCreateMutexWithWorldAccess (
            MUTEX_NAME,
            FALSE, // not initially owned,
            NULL,
            &m_hMutex);

    TraceHr (ttidError, FAL, hr, FALSE, "CWriteLock::HrEnsureMutexCreated");
    return hr;
}

BOOL
CWriteLock::WaitToAcquire (
    IN DWORD dwMilliseconds,
    IN PCWSTR pszNewOwnerDesc,
    OUT PWSTR* ppszCurrentOwnerDesc OPTIONAL)
{
    HRESULT hr;
    BOOL fAcquired = FALSE;

    hr = HrEnsureMutexCreated ();
    if (S_OK == hr)
    {
        // Now wait for the mutext to become available.  (Pump messages while
        // waiting so we don't hang the clients UI.)
        //
        while (1)
        {
            DWORD dwWait;

            dwWait = MsgWaitForMultipleObjects (
                        1, &m_hMutex, FALSE,
                        dwMilliseconds, QS_ALLINPUT);

            if ((WAIT_OBJECT_0 + 1) == dwWait)
            {
                // We have messages to pump.
                //
                MSG msg;
                while (PeekMessage (&msg, NULL, NULL, NULL, PM_REMOVE))
                {
                    DispatchMessage (&msg);
                }
            }
            else
            {
                if (WAIT_OBJECT_0 == dwWait)
                {
                    fAcquired = TRUE;
                }
                else if (WAIT_ABANDONED_0 == dwWait)
                {
                    fAcquired = TRUE;
                    TraceTag (ttidError, "NetCfg write lock was abandoned!");
                }
                else if (WAIT_TIMEOUT == dwWait)
                {
                    hr = HRESULT_FROM_WIN32 (ERROR_TIMEOUT);
                }
                else
                {
                    hr = HrFromLastWin32Error ();
                    TraceHr (ttidError, FAL, hr, FALSE,
                        "MsgWaitForMultipleObjects");
                }

                // If we acquired the mutex, set the new owner.
                //
                if (fAcquired)
                {
                    m_fOwned = TRUE;
                    SetOrQueryLockHolder (TRUE,
                        pszNewOwnerDesc, ppszCurrentOwnerDesc);
                }
                else if (ppszCurrentOwnerDesc)
                {
                    // Query the lock holder description.
                    //
                    SetOrQueryLockHolder (FALSE,
                        NULL, ppszCurrentOwnerDesc);
                }

                break;
            }
        }
    }

    return fAcquired;
}

BOOL
CWriteLock::FIsLockedByAnyone (
    OUT PWSTR* ppszCurrentOwnerDesc OPTIONAL)
{
    // It's locked if we own it.
    //
    BOOL fLocked = m_fOwned;

    // If we don't own it, check to see if some other process does.
    //
    if (!fLocked)
    {
        HRESULT hr;

        hr = HrEnsureMutexCreated ();
        if (S_OK == hr)
        {
            DWORD dw;

            // Wait for the mutex, but with a zero timeout.  This is
            // equivalent to a quick check.  (But we still need to release
            // it if we acquire ownership.  If we timeout, it means that
            // someone else owns it.
            //
            dw = WaitForSingleObject (m_hMutex, 0);

            if (WAIT_OBJECT_0 == dw)
            {
                ReleaseMutex (m_hMutex);
            }
            else if (WAIT_TIMEOUT == dw)
            {
                // Someone else owns it.
                //
                fLocked = TRUE;
            }
        }
    }

    if (fLocked)
    {
        // Query the lock holder description.
        //
        SetOrQueryLockHolder (FALSE, NULL, ppszCurrentOwnerDesc);
    }

    return fLocked;
}

VOID
CWriteLock::ReleaseIfOwned ()
{
    if (m_fOwned)
    {
        Assert (m_hMutex);

        // Clear the lock holder now that no one is about to own it.
        //
        SetOrQueryLockHolder (TRUE, NULL, NULL);

        ReleaseMutex (m_hMutex);
        m_fOwned = FALSE;
    }
}

VOID
CWriteLock::SetOrQueryLockHolder (
    IN BOOL fSet,
    IN PCWSTR pszNewOwnerDesc OPTIONAL,
    OUT PWSTR* ppszCurrentOwnerDesc OPTIONAL)
{
    HRESULT hr;
    HKEY hkeyNetwork;
    HKEY hkeyLockHolder;
    REGSAM samDesired;
    BOOL fClear;

    // We're clearing the value if we're asked to set it to NULL.
    //
    fClear = fSet && !pszNewOwnerDesc;

    // Initialize the output parameter if specified.
    //
    if (ppszCurrentOwnerDesc)
    {
        *ppszCurrentOwnerDesc = NULL;
    }

    // If we're setting the lock holder, we need write access.  Otherwise,
    // we only need read access.
    //
    samDesired = (fSet) ? KEY_READ_WRITE_DELETE : KEY_READ;

    hr = HrOpenNetworkKey (samDesired, &hkeyNetwork);

    if (S_OK == hr)
    {
        // The lock holder is represented by the default value of a
        // volatile subkey under the Network subtree.
        //

        if (fClear)
        {
            RegDeleteKey (hkeyNetwork, LOCK_HOLDER_SUBKEY);
        }
        else if (fSet)
        {
            DWORD dwDisposition;

            Assert (pszNewOwnerDesc);

            hr = HrRegCreateKeyWithWorldAccess (
                    hkeyNetwork,
                    LOCK_HOLDER_SUBKEY,
                    REG_OPTION_VOLATILE,
                    KEY_WRITE,
                    &hkeyLockHolder,
                    &dwDisposition);

            // Set the lock holder and close the key.
            //
            if (S_OK == hr)
            {
                (VOID) HrRegSetSz (hkeyLockHolder, NULL, pszNewOwnerDesc);

                RegCloseKey (hkeyLockHolder);
            }
        }
        else
        {
            // Query for the lock holder by opening the key (if it exists)
            // and reading the default value.  We return the string
            // allocated with CoTaskMemAlloc because we use this
            // directly from the COM implementation.
            //
            Assert (ppszCurrentOwnerDesc);

            hr = HrRegOpenKeyEx (
                    hkeyNetwork,
                    LOCK_HOLDER_SUBKEY,
                    KEY_READ,
                    &hkeyLockHolder);

            if (S_OK == hr)
            {
                PWSTR pszLockHolder;

                hr = HrRegQuerySzWithAlloc (
                        hkeyLockHolder,
                        NULL,
                        &pszLockHolder);

                if (S_OK == hr)
                {
                    hr = HrCoTaskMemAllocAndDupSz (
                            pszLockHolder, ppszCurrentOwnerDesc);

                    MemFree (pszLockHolder);
                }
                RegCloseKey (hkeyLockHolder);
            }
        }

        RegCloseKey (hkeyNetwork);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\wrlock.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       W R L O C K . H
//
//  Contents:   Defines the interface to the netcfg write lock used to
//              protect the network configuration information from being
//              modified by more than one writer at a time.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once

// This is the interface to the write lock that INetCfg uses.
//
class CWriteLock
{
private:
    HANDLE  m_hMutex;
    BOOL    m_fOwned;

private:
    HRESULT
    HrEnsureMutexCreated ();

    VOID
    SetOrQueryLockHolder (
        IN BOOL fSet,
        IN PCWSTR pszNewOwnerDesc,
        OUT PWSTR* ppszCurrentOwnerDesc);

public:
    CWriteLock ()
    {
        m_hMutex = NULL;
        m_fOwned = FALSE;
    }

    ~CWriteLock ();

    BOOL
    WaitToAcquire (
        IN DWORD dwMilliseconds,
        IN PCWSTR pszNewOwnerDesc,
        OUT PWSTR* ppszCurrentOwnerDesc);

    BOOL
    FIsLockedByAnyone (
        OUT PWSTR* ppszCurrentOwnerDesc OPTIONAL);

    BOOL
    FIsOwnedByMe ()
    {
        AssertH (FImplies(m_fOwned, m_hMutex));
        return m_fOwned;
    }

    VOID
    ReleaseIfOwned ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\wscfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       W S C F G . H
//
//  Contents:   Winsock configuration routines.
//
//  Notes:
//
//  Author:     shaunco   15 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

HRESULT
HrMigrateWinsockConfiguration (
    VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\engine\wscfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       W S C F G . C P P
//
//  Contents:   Winsock configuration routines.
//
//  Notes:
//
//  Author:     shaunco   15 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "nceh.h"
#include "wscfg.h"
extern "C"
{
#include <wsasetup.h>
}

HRESULT
HrMigrateWinsockConfiguration (
    VOID)
{
    HRESULT hr;

    NC_TRY
    {
        WSA_SETUP_DISPOSITION Disposition;
        DWORD dwErr = MigrateWinsockConfiguration (&Disposition, NULL, 0);
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMigrateWinsockConfiguration");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\ipctrl.h ===
//-------------------------------------------------------------------
// I P C T R L . H
//
// IP Address control helper class declaration
//-------------------------------------------------------------------

#pragma once
#include "ncstring.h"

class IpControl
{
public:
    IpControl();
    ~IpControl();

// Implementation
public:
    BOOL Create(HWND hParent, UINT nId);
    operator HWND() {AssertH(m_hIpAddress); return m_hIpAddress;}

    BOOL IsBlank();
    void SetFocusField(DWORD dwField);
    void SetFieldRange(DWORD dwField, DWORD dwMin, DWORD dwMax);
    void ClearAddress();

    void SetAddress(DWORD adwAddress[4]);
    void SetAddress(DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4);
    void SetAddress(PCWSTR szString);

    void GetAddress(DWORD adwAddress[4]);
    void GetAddress(DWORD * dw1, DWORD * dw2, DWORD * dw3, DWORD * dw4);
    void GetAddress(tstring * pstrAddress);

    LRESULT SendMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HWND m_hIpAddress;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\ncxbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C X B A S E . H
//
//  Contents:   Base include file for netcfgx.dll.  Defines globals.
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#include "ncatl.h"
#include "ncstring.h"
#include "ncnetcfg.h"
#include "ncxclsid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\atmcommon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       A T M C O M M O N . H
//
//  Contents:   Common ATM functions
//
//  Notes:
//
//  Author:     tongl   10 Mar 1998
//
//----------------------------------------------------------------------------

#pragma once

// maximum valid address lenght in characters
//
const INT MAX_ATM_ADDRESS_LENGTH = 40;

BOOL FIsValidAtmAddress(PCWSTR szAtmAddress, INT * piErrCharPos, INT * pnId);

BOOL fIsSameVstr(const vector<tstring *> vstr1, const vector<tstring *> vstr2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\ncxclsid.h ===
#include <guiddef.h>

DEFINE_GUID(CLSID_CALaneCfg,    0x295789F0,0x0949,0x11D1,0xB9,0x0C,0x00,0xAA,0x00,0x4A,0xB1,0x2A);
DEFINE_GUID(CLSID_CATlkObj,     0x525609F4,0xD232,0x11D0,0xB7,0x6F,0x00,0xC0,0x4F,0xC9,0xBC,0xC4);
DEFINE_GUID(CLSID_CArpsCfg,     0x962FFCF3,0x965F,0x11D0,0xA8,0x81,0x00,0xC0,0x4F,0xC9,0x9C,0x9C);
DEFINE_GUID(CLSID_CAtmUniCfg,   0x674D3E3D,0xA1A8,0x11D0,0xA8,0x86,0x00,0xC0,0x4F,0xC9,0x9C,0x9C);
DEFINE_GUID(CLSID_CBridgeObj,   0xa5fda055,0x899d,0x4895,0x97,0xae,0x0c,0xc4,0xfe,0x4e,0x97,0x7f);
DEFINE_GUID(CLSID_CDHCPServer,  0xAA9BB1E0,0x9FE2,0x11D0,0xB2,0x57,0x00,0xC0,0x4F,0xC9,0xE2,0x92);
DEFINE_GUID(CLSID_CMSClient,    0x57C06EAA,0x8784,0x11D0,0x83,0xD4,0x00,0xA0,0xC9,0x11,0xE5,0xDF);
DEFINE_GUID(CLSID_CNbfObj,      0xA28D553A,0xA703,0x11D0,0x9C,0xEC,0x00,0xC0,0x4F,0xC9,0xBC,0xC4);
DEFINE_GUID(CLSID_CNWClient,    0x5BEDF7DE,0x98CF,0x11D0,0xB2,0x55,0x00,0xC0,0x4F,0xC9,0xE2,0x92);
DEFINE_GUID(CLSID_CNwlnkIPX,    0xC59938DA,0x9B20,0x11D0,0x9C,0xE3,0x00,0xC0,0x4F,0xC9,0xBC,0xC4);
DEFINE_GUID(CLSID_CNwlnkNB,     0x050DA15F,0x9F13,0x11D0,0x9C,0xE5,0x00,0xC0,0x4F,0xC9,0xBC,0xC4);
DEFINE_GUID(CLSID_CRasCli,      0x6E65CBC0,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CRasSrv,      0x6E65CBC1,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CNdisWan,     0x6E65CBC3,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CL2tp,        0x6E65CBC6,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CPptp,        0x6E65CBC4,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CSteelhead,   0x6E65CBC5,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CSAPCfg,      0xB45AFEC0,0x2AE6,0x11D1,0x85,0x9E,0x00,0xC0,0x4F,0xC9,0xE2,0x92);
DEFINE_GUID(CLSID_CSrvrcfg,     0x7F368827,0x9516,0x11D0,0x83,0xD9,0x00,0xA0,0xC9,0x11,0xE5,0xDF);
DEFINE_GUID(CLSID_CTcpipcfg,    0xA907657F,0x6FDF,0x11D0,0x8E,0xFB,0x00,0xC0,0x4F,0xD9,0x12,0xB2);
DEFINE_GUID(CLSID_CWLBS,        0xbf0eaea8,0xc122,0x11d2,0x94,0xf4,0x00,0xc0,0x4f,0x72,0xd8,0xc4);
DEFINE_GUID(CLSID_CPppoe,       0xe949da38,0xc39d,0x4460,0x8e,0xa7,0xa3,0x91,0x52,0xc5,0x68,0x36);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\netcomm.h ===
#pragma once

BOOL
ProcessAnswerFile(
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSections,
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid);



VOID
UpdateAdvancedParametersIfNeeded(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\netpages.h ===
#pragma once

HRESULT
HrGetAdvancedPage(HDEVINFO hdi,
                  PSP_DEVINFO_DATA pdeid,
                  HPROPSHEETPAGE* phpsp);

HRESULT
HrGetIsdnPage(HDEVINFO hdi,
              PSP_DEVINFO_DATA pdeid,
              HPROPSHEETPAGE* phpsp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOIME
#define NOMCX
#define NOMDI
#define NOMETAFILE
#define NOSOUND
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>
#include <wchar.h>

#include "stllist.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\ncres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E S . H
//
//  Contents:   Resource ID ranges
//
//  Notes:
//
//  Author:     shaunco   23 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once

#define IDC_STATIC          -1

#define IDS_NC_ATMCFG       10000
#define IDS_NC_DHCPCFG      11000
#define IDS_NC_MSCLICFG     12000
#define IDS_NC_NBFCFG       13000
#define IDS_NC_NETCFG       14000
#define IDS_NC_NETCOMM      15000
#define IDS_NC_NWCLICFG     16000
#define IDS_NC_NWLNKCFG     17000
#define IDS_NC_RASCFG       19000
#define IDS_NC_SAPCFG       20000
#define IDS_NC_SFNCFG       21000
#define IDS_NC_SRVRCFG      22000
#define IDS_NC_TCPIPCFG     23000
#define IDS_NC_COMMON       24000
#define IDS_NC_ATLKCFG      25000
#define IDS_NC_STRMCFG      26000
#define IDS_NC_ISDNCFG      27000
#define IDS_NC_ALANECFG     28000
#define IDS_NC_COMP_HELP_TEXT       50000  // component help text

// ATL Registration IDs
//
#define IDR_REG_ALANECFG            31000
#define IDR_REG_ARPSCFG             31001
#define IDR_REG_ATLKCFG             31002
#define IDR_REG_AUNICFG             31003
#define IDR_REG_DHCPSCFG            31004
#define IDR_REG_L2TP                31005
#define IDR_REG_MSCLICFG            31006
#define IDR_REG_NBFCFG              31007
#define IDR_REG_NDISWAN             31008
#define IDR_REG_NETCFG              31009
#define IDR_REG_NWCLICFG            31011
#define IDR_REG_NWLNKIPX            31012
#define IDR_REG_NWLNKNB             31013
#define IDR_REG_PPTP                31014
#define IDR_REG_RASCLI              31017
#define IDR_REG_RASSRV              31019
#define IDR_REG_SAPCFG              31020
#define IDR_REG_SRVRCFG             31021
#define IDR_REG_STEELHEAD           31022
#define IDR_REG_TCPIPCFG            31024
#define IDR_REG_PPPOE               31025


#define IDS_CAPTION_NETCFG              (IDS_NC_COMMON + 1)
#define IDS_COMMONDLG_TEXT              (IDS_NC_COMMON + 2)
#define IDS_TEXT_WITH_WIN32_ERROR       (IDS_NC_COMMON + 4)
#define IDS_UNKNOWN_NETWORK_CARD        (IDS_NC_COMMON + 5)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inc\rasexp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S E X P . H
//
//  Contents:   Prototypes for APIs used to implement exported APIs from
//              netcfgx.dll for RAS.
//
//  Notes:
//
//  Author:     shaunco   5 Feb 1998
//
//----------------------------------------------------------------------------

#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\sld\sld.inc ===
MISCFILES=\
	..\sld\netaarps_inf_{CB31957E-4E73-48F8-AB4F-89F96B49AF84}.sld \
	..\sld\netauni_inf_{B1783B9D-DFDB-4657-B8EB-696291C737F3}.sld \
	..\sld\netdhcpr_inf_{752BC0F8-4224-4FB4-A370-1C4F3CC058CC}.sld \
	..\sld\netdhcps_inf_{E239A24B-73D1-45B7-803D-7C2F18FA2068}.sld \
	..\sld\netgpc_inf_{FFF2E30A-4713-4E38-98F5-60EBE5FA2249}.sld \
	..\sld\netirda_inf_{498B83C9-939E-4E91-8CBF-DA82E84BE6D8}.sld \
	..\sld\netlanep_inf_{E8E396ED-ACF9-4FA7-8455-BF711D9D6AD0}.sld \
	..\sld\netmscli_inf_{AFD02F3B-F8DA-4421-B5A4-F7CD888CF5AA}.sld \
	..\sld\netnbf_inf_{E47A0FEB-90E5-44F4-A855-B4741E792A07}.sld \
	..\sld\netnb_inf_{CDF9CE98-AE64-4325-92BF-6FBC06D5BC0B}.sld \
	..\sld\netnwcli_inf_{384C9BF8-40C0-4EDF-93E1-CEDF8CD0169B}.sld \
	..\sld\netpschd_inf_{91E2599F-6DAF-480E-BB61-BC1D26F10A4D}.sld \
	..\sld\netrasa_inf_{BEF9D3FC-7F1F-49FE-88DC-0105BB0B9948}.sld \
	..\sld\netrass_inf_{6B1C5CEF-CF09-4221-B8EB-ED83AE1E9EE2}.sld \
	..\sld\netrast_inf_{BF4A3961-FD05-48B4-9012-5EDD0C1D859A}.sld \
	..\sld\netrsvp_inf_{D5290FD7-378B-4DB7-BD1A-29235D79E45E}.sld \
	..\sld\netrwan_inf_{2B9AF37D-4BD8-4928-8D30-48BFDC8660AD}.sld \
	..\sld\netsap_Inf_{21D0D674-BC8A-4F3D-9BAA-7635F4A1ADCC}.sld \
	..\sld\netserv_inf_{B30E1EB8-AF04-4D13-9660-8927CDEB0745}.sld \
	..\sld\netsfn_inf_{91F11A43-5259-458E-844A-E18A647EAD7F}.sld \
	..\sld\nettcpip_inf_{14D83BFF-5169-423A-A9D3-FF8BA8A4469E}.sld \
	..\sld\netwlbsm_inf_{42A62121-E51B-4863-8E66-AB3358B6389E}.sld \
	..\sld\netwlbs_inf_{E96E3D6F-83D7-4104-8DB3-35DC9FC97F47}.sld \
	..\sld\netwlnk_inf_{BF7DF840-4FE8-4568-A659-988EB56F0458}.sld \
	..\sld\netwzc_inf_{59705601-27FA-47CF-B713-D26B829389C4}.sld
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\sources.inc ===
TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=NOTARGET

SOURCES=

NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\makefile.inc ===
#
# This file is designed to be included from 1 level below
# (ie, srv, wks).
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IF "$(ALT_PROJECT)" == "NEC_98"
PLATFORM_SWITCH=n
!ELSEIF "$(TARGET_DIRECTORY)"=="i386"  || "$(TARGET_DIRECTORY)"=="I386"
PLATFORM_SWITCH=i
!ELSEIF "$(TARGET_DIRECTORY)"=="alpha" || "$(TARGET_DIRECTORY)"=="ALPHA"
PLATFORM_SWITCH=a
!ELSEIF "$(TARGET_DIRECTORY)"=="ia64"  || "$(TARGET_DIRECTORY)"=="IA64"
PLATFORM_SWITCH=m
!ELSEIF "$(TARGET_DIRECTORY)"=="amd64" || "$(TARGET_DIRECTORY)"=="AXP64"
PLATFORM_SWITCH=x
!ELSE
! ERROR Invalid Platform Switch for infs
!ENDIF

_LNG=..\$(LANGUAGE)
_INX=..
_INF=obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)
STAMP=stampinf -f $@ -d date -v

make_infs:\
    $(_INF)\netaarps.inf    \
!IF "$(PRODSWITCH)" == "s"
    $(_INF)\netatlk.inf     \
!ENDIF
    $(_INF)\netauni.inf     \
    $(_INF)\netcis.inf      \
    $(_INF)\netdhoc.inf     \
    $(_INF)\netdhcps.inf    \
    $(_INF)\netdns.inf      \
    $(_INF)\netiprip.inf    \
    $(_INF)\netgpc.inf      \
    $(_INF)\netias.inf      \
    $(_INF)\netlanem.inf    \
    $(_INF)\netlanep.inf    \
    $(_INF)\netlpd.inf      \
!IF $(386)
    $(_INF)\netmacpr.inf    \
!ENDIF
    $(_INF)\netmacsv.inf    \
    $(_INF)\netmscli.inf    \
    $(_INF)\netnb.inf       \
!IF "$(PLATFORM_SWITCH)" == "i"
    $(_INF)\netnwcli.inf    \
    $(_INF)\netnwlnk.inf    \
!ENDIF
    $(_INF)\netoc.inf       \
    $(_INF)\netrasa.inf     \
    $(_INF)\netrass.inf     \
    $(_INF)\netrast.inf     \
    $(_INF)\netrsvp.inf     \
    $(_INF)\netrwan.inf     \
    $(_INF)\netpsa.inf      \
    $(_INF)\netpschd.inf    \
    $(_INF)\netnbf.inf      \
!IF "$(PLATFORM_SWITCH)" == "i"
    $(_INF)\netsap.inf      \
!ENDIF
    $(_INF)\netserv.inf     \
    $(_INF)\netsfn.inf      \
    $(_INF)\netsfnt.inf     \
    $(_INF)\netsnmp.inf     \
    $(_INF)\nettcpip.inf    \
    $(_INF)\nettpsmp.inf    \
    $(_INF)\netwins.inf     \
    $(_INF)\netupg.inf      \
    $(_INF)\netupnp.inf     \
    $(_INF)\netupnph.inf     \
    $(_INF)\netcm.inf       \
    $(_INF)\netirda.inf     \
    $(_INF)\netwlbs.inf     \
    $(_INF)\netwlbsm.inf    \
    $(_INF)\netwzc.inf

#
# different binplace destinations for different platforms (wks, srv and ent)
#
# NOTE: Set BINPLACE_CMD_NWS as empty in ent flavor to avoid binplace conflict 
# when building Srv and Ent simultaneously on mulitple processor build machines
#

!IFDEF BINPLACE_CMD
!IFDEF SERVERINF
BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
BINPLACE_CMD_NWS=$(BINPLACE_CMD:binplace -b srvinf=binplace -b nws)
!ELSE
!IFDEF ENTERPRISEINF
BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf)
BINPLACE_CMD_NWS=
!ELSE
!IFDEF PERSONALINF
BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf)
BINPLACE_CMD_NWS=
!ELSE
BINPLACE_CMD_NWS=$(BINPLACE_CMD)
!ENDIF
!ENDIF
!ENDIF
!ENDIF

#
# Explicit dependencies. We do it this way instead of trying to use rules
# because !#@&^$#% nmake doesn't allow multiple 'source' extensions
# when defining a rule, and we need to express a dependency between
# .txt OR .inx to the final .inf.
#

#
# 'Standard' (win95-style) infs. The rules are all the same.
#

$(_INF)\netupg.inf: $(_INX)\netupg.inx $(_LNG)\netupg.txt
     copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     $(STAMP)
     $(BINPLACE_CMD)

$(_INF)\netaarps.inf: $(_INX)\netaarps.inx $(_LNG)\netaarps.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

#
#$(_INF)\netacs.inf: $(_INX)\netacs.inx $(_LNG)\netacs.txt
#    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
#    $(STAMP)
#    $(BINPLACE_CMD)
#

$(_INF)\netatlk.inf: $(_INX)\netatlk.inx $(_LNG)\netatlk.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netauni.inf: $(_INX)\netauni.inx $(_LNG)\netauni.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netcis.inf: $(_INX)\netcis.inx $(_LNG)\netcis.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netdhoc.inf: $(_INX)\netdhoc.inx $(_LNG)\netdhoc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netdhcps.inf: $(_INX)\netdhcps.inx $(_LNG)\netdhcps.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netdns.inf: $(_INX)\netdns.inx $(_LNG)\netdns.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netgpc.inf: $(_INX)\netgpc.inx $(_LNG)\netgpc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netias.inf: $(_INX)\netias.inx $(_LNG)\netias.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netiprip.inf: $(_INX)\netiprip.inx $(_LNG)\netiprip.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netlpd.inf: $(_INX)\netlpd.inx $(_LNG)\netlpd.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netmacpr.inf: $(_INX)\netmacpr.inx $(_LNG)\netmacpr.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netmacsv.inf: $(_INX)\netmacsv.inx $(_LNG)\netmacsv.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netmscli.inf: $(_INX)\netmscli.inx $(_LNG)\netmscli.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netnb.inf: $(_INX)\netnb.inx $(_LNG)\netnb.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

!IF "$(PLATFORM_SWITCH)" == "i"

$(_INF)\netnwcli.inf: $(_INX)\netnwcli.inx $(_LNG)\netnwcli.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netnwlnk.inf: $(_INX)\netnwlnk.inx $(_LNG)\netnwlnk.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

!ENDIF

$(_INF)\netoc.inf: $(_INX)\netoc.inx $(_LNG)\netoc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netrsvp.inf: $(_INX)\netrsvp.inx $(_LNG)\netrsvp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netrwan.inf: $(_INX)\netrwan.inx $(_LNG)\netrwan.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netrasa.inf: $(_INX)\netrasa.inx $(_LNG)\netrasa.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netrass.inf: $(_INX)\netrass.inx $(_LNG)\netrass.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netrast.inf: $(_INX)\netrast.inx $(_LNG)\netrast.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netpsa.inf: $(_INX)\netpsa.inx $(_LNG)\netpsa.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netpschd.inf: $(_INX)\netpschd.inx $(_LNG)\netpschd.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netnbf.inf: $(_INX)\netnbf.inx $(_LNG)\netnbf.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

!IF "$(PLATFORM_SWITCH)" == "i"

$(_INF)\netsap.inf: $(_INX)\netsap.inx $(_LNG)\netsap.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

!ENDIF

$(_INF)\netserv.inf: $(_INX)\netserv.inx $(_LNG)\netserv.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netsfn.inf: $(_INX)\netsfn.inx $(_LNG)\netsfn.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(BINPLACE_CMD_NWS)

$(_INF)\netsfnt.inf: $(_INX)\netsfnt.inx $(_LNG)\netsfnt.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(BINPLACE_CMD_NWS)

$(_INF)\netsnmp.inf: $(_INX)\netsnmp.inx $(_LNG)\netsnmp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\nettcpip.inf: $(_INX)\nettcpip.inx $(_LNG)\nettcpip.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\nettpsmp.inf: $(_INX)\nettpsmp.inx $(_LNG)\nettpsmp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netwins.inf: $(_INX)\netwins.inx $(_LNG)\netwins.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netlanem.inf: $(_INX)\netlanem.inx $(_LNG)\netlanem.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netlanep.inf: $(_INX)\netlanep.inx $(_LNG)\netlanep.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netupnp.inf: $(_INX)\netupnp.inx $(_LNG)\netupnp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netupnph.inf: $(_INX)\netupnph.inx $(_LNG)\netupnph.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\netirda.inf: $(_INX)\netirda.inx $(_LNG)\netirda.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

!IF $(386)

$(_INF)\netcm.inf: $(_INX)\netcmx.inx $(_LNG)\netcm.txt
     copy $(_INX)\netcmx.inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
     prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     @del $(@B).tmp2
     $(STAMP)
     $(BINPLACE_CMD)

!ELSE

$(_INF)\netcm.inf: $(_INX)\netcma.inx $(_LNG)\netcm.txt
     copy $(_INX)\netcma.inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
     prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     @del $(@B).tmp2
     $(STAMP)
     $(BINPLACE_CMD)

!ENDIF

$(_INF)\netwlbs.inf: $(_INX)\netwlbs.inx $(_LNG)\netwlbs.txt
     copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     $(STAMP)
     $(BINPLACE_CMD)

$(_INF)\netwlbsm.inf: $(_INX)\netwlbsm.inx $(_LNG)\netwlbsm.txt
     copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     $(STAMP)
     $(BINPLACE_CMD)


$(_INF)\netwzc.inf: $(_INX)\netwzc.inx $(_LNG)\netwzc.txt
     copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     $(STAMP)
     $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\wks\makefile.inc ===
PRODSWITCH=w
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdnpage.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N P A G E . C P P
//
//  Contents:   Contains the isdn page for enumerated net class devices
//
//  Notes:
//
//  Author:     BillBe 9 Sep 1997
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "isdnpage.h"
#include "isdnshts.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"

CIsdnPage::CIsdnPage()
:   m_fDirty(FALSE),
    m_hkeyDriver(NULL),
    m_hdi(NULL),
    m_pdeid(NULL),
    m_pisdnci(NULL)
{
}

CIsdnPage::~CIsdnPage()
{
    if (m_pisdnci)
    {
        // Free the structure. This was allocated by
        // HrReadIsdnPropertiesInfo.
        //
        FreeIsdnPropertiesInfo(m_pisdnci);
    }
    RegSafeCloseKey(m_hkeyDriver);
}

//+--------------------------------------------------------------------------
//
//  Member:     CIsdnPage::CreatePage
//
//  Purpose:    Creates the Isdn page only if there the device is an isdn
//                  adapter
//
//  Arguments:
//      hdi    [in] SetupApi HDEVINFO for device
//      pdeid  [in] SetupApi PSP_DEVINFO_DATA for device
//
//  Returns:    HPROPSHEETPAGE
//
//  Author:     billbe 9 Sep 1997
//
//  Notes:
//
HPROPSHEETPAGE
CIsdnPage::CreatePage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(INVALID_HANDLE_VALUE != hdi);
    Assert(hdi);
    Assert(pdeid);

    HPROPSHEETPAGE hpsp = NULL;

    // Open the device's instance key
    HRESULT     hr = HrSetupDiOpenDevRegKey(hdi, pdeid,
                        DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ALL_ACCESS,
                        &m_hkeyDriver);

    // If the key was opened and this adapter is ISDN
    if (SUCCEEDED(hr) && FShowIsdnPages(m_hkeyDriver))
    {
        // read the adapter's properties from the registry
        hr = HrReadIsdnPropertiesInfo(m_hkeyDriver, hdi, pdeid, &m_pisdnci);
        if (SUCCEEDED(hr))
        {
            m_hdi = hdi;
            m_pdeid = pdeid;

            hpsp = CPropSheetPage::CreatePage(IDP_ISDN_SWITCH_TYPE, 0);
        }
    }

    return hpsp;
}

//+--------------------------------------------------------------------------
//
//  Member:     CIsdnPage::OnInitDialog
//
//  Purpose:    Handler for the WM_INITDIALOG window message.  Initializes
//              the dialog window.
//
//  Author:     BillBe   09 Sep 1997
//
//  Notes:
//
//
LRESULT
CIsdnPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                BOOL& bHandled)
{
    // Populate the switch types from the multi-sz that we read
    PopulateIsdnSwitchTypes(m_hWnd, IDC_CMB_SwitchType, m_pisdnci);
    SetSwitchType(m_hWnd, IDC_CMB_SwitchType, m_pisdnci->dwCurSwitchType);

    // Note the current selections
    //
    m_pisdnci->nOldBChannel = SendDlgItemMessage(IDC_LBX_Variant,
                                                 LB_GETCURSEL, 0, 0);
    m_pisdnci->nOldDChannel = SendDlgItemMessage(IDC_LBX_Line,
                                                 LB_GETCURSEL, 0, 0);
    return 0;
}

LRESULT
CIsdnPage::OnSwitchType(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled)
{
    if (wNotifyCode == CBN_SELCHANGE)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }

    return 0;
}

//+--------------------------------------------------------------------------
//
//  Member:     CIsdnPage::OnApply
//
//  Purpose:    Handler for the PSN_APPLY message
//
//  Author:     BillBe   10 Sep 1997
//
//  Notes:
//
//
LRESULT
CIsdnPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{

    // only do something if data has changed.
    if (m_fDirty)
    {
        // Update the switch type
        m_pisdnci->dwCurSwitchType = DwGetSwitchType(m_hWnd, m_pisdnci,
                                                     IDC_CMB_SwitchType);

        // Write the parameters back out into the registry.
        (void) HrWriteIsdnPropertiesInfo(m_hkeyDriver, m_pisdnci);

        // Notify the UI that its display might need updating
        //
        SP_DEVINSTALL_PARAMS deip;
        // Try to get the current params
        (void) HrSetupDiGetDeviceInstallParams(m_hdi, m_pdeid, &deip);
        deip.FlagsEx |= DI_FLAGSEX_PROPCHANGE_PENDING;
        // Try to set the new params. If it fails, it is not
        // catastrophic so we ignore return values
        (void) HrSetupDiSetDeviceInstallParams(m_hdi, m_pdeid, &deip);

        // Changes have been applied so clear our dirty flag
        m_fDirty = FALSE;
    }

    return 0;
}

LRESULT
CIsdnPage::OnConfigure(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                       BOOL& bHandled)
{
    DWORD   dwSwitchType;

    dwSwitchType = DwGetSwitchType(m_hWnd, m_pisdnci, IDC_CMB_SwitchType);

    switch (dwSwitchType)
    {
    case ISDN_SWITCH_ATT:
    case ISDN_SWITCH_NI1:
    case ISDN_SWITCH_NI2:
    case ISDN_SWITCH_NTI:
        if (m_pisdnci->fIsPri)
        {
            // PRI adapters use the EAZ page instead
            DoEazDlg();
        }
        else
        {
            DoSpidsDlg();
        }
        break;

    case ISDN_SWITCH_INS64:
        DoJapanDlg();
        break;

    case ISDN_SWITCH_1TR6:
    case ISDN_SWITCH_AUTO:
        DoEazDlg();
        break;

    case ISDN_SWITCH_VN3:
    case ISDN_SWITCH_DSS1:
    case ISDN_SWITCH_AUS:
    case ISDN_SWITCH_BEL:
    case ISDN_SWITCH_VN4:
    case ISDN_SWITCH_SWE:
    case ISDN_SWITCH_ITA:
    case ISDN_SWITCH_TWN:
        DoMsnDlg();
        break;

    default:
        AssertSz(FALSE, "Where do we go from here.. now that all of our "
                 "children are growin' up?");
        break;
    }

    return 0;
}

VOID CIsdnPage::DoSpidsDlg()
{
    CSpidsDlg   dlg(m_pisdnci);
    INT         nRet;

    m_pisdnci->idd = dlg.IDD;
    nRet = dlg.DoModal(m_hWnd);
    if (nRet)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }
}

VOID CIsdnPage::DoJapanDlg()
{
    CJapanDlg   dlg(m_pisdnci);
    INT         nRet;

    m_pisdnci->idd = dlg.IDD;
    nRet = dlg.DoModal(m_hWnd);
    if (nRet)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }
}

VOID CIsdnPage::DoEazDlg()
{
    CEazDlg     dlg(m_pisdnci);
    INT         nRet;

    m_pisdnci->idd = dlg.IDD;
    nRet = dlg.DoModal(m_hWnd);
    if (nRet)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }
}

VOID CIsdnPage::DoMsnDlg()
{
    CMsnDlg     dlg(m_pisdnci);
    INT         nRet;

    m_pisdnci->idd = dlg.IDD;
    nRet = dlg.DoModal(m_hWnd);
    if (nRet)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }
}

static const CONTEXTIDMAP c_adwContextIdMap[] =
{
    { IDC_LBX_Line,           2003230,  2003230 },
    { IDC_LBX_Variant,        2003240,  2003240 },
    { IDC_EDT_PhoneNumber,    2003250,  2003255 },
    { IDC_EDT_SPID,           2003265,  2003260 },
    { IDC_EDT_MSN,            2003270,  2003270 },
    { IDC_PSB_ADD,            2003280,  2003280 },
    { IDC_LBX_MSN,            2003290,  2003290 },
    { IDC_PSB_REMOVE,         2003300,  2003300 },
    { IDC_CMB_SwitchType,     2003310,  2003310 },
    { IDC_PSB_Configure,      2003320,  2003320 },
    { 0,                      0,        0 },        // end marker
};

LRESULT CIsdnPage::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                          BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}

LRESULT CIsdnPage::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                                BOOL& bHandled)
{
	HELPINFO  hi;

	HMENU h = CreatePopupMenu();
	POINT pScreen;
	TCHAR szWhat[MAX_PATH];

    if (h == NULL)
	{
		return FALSE;
	}

	LoadString(_Module.GetResourceInstance(), IDS_ISDN_WHATS_THIS, szWhat, MAX_PATH);

	InsertMenu(h, -1, MF_BYPOSITION, 777, szWhat);

	pScreen.x = ((int)(short)LOWORD(lParam));
	pScreen.y = ((int)(short)HIWORD(lParam));

	int n;
	switch(n = TrackPopupMenu(h, TPM_NONOTIFY | TPM_RETURNCMD, pScreen.x, pScreen.y, 0, m_hWnd, NULL))
	{
	case 777:
		hi.iContextType = HELPINFO_WINDOW;
		hi.iCtrlId = ::GetWindowLong((HWND)wParam, GWL_ID);

		OnHelpGeneric(m_hWnd, &hi, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);
		break;
	}

    DestroyMenu(h);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetIsdnPage
//
//  Purpose:    Creates the Isdn page for enumerated net devices.
//                  This function is called by the NetPropPageProvider fcn.
//
//  Arguments:
//      hdi     [in]   See SetupApi for info
//      pdeid   [in]   See SetupApi for for info
//      phpsp   [out]  Pointer to the handle to the isdn property page
//
//  Returns:
//
//  Author:     billbe 9 Sep 1997
//
//  Notes:
//
HRESULT
HrGetIsdnPage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
              HPROPSHEETPAGE* phpsp)
{
    Assert(hdi);
    Assert(pdeid);
    Assert(phpsp);

    HRESULT hr;
    HPROPSHEETPAGE hpsp;

    CIsdnPage* pisdn = new CIsdnPage();

	if (pisdn == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // create the isdn page
    hpsp = pisdn->CreatePage(hdi, pdeid);

    // if successful, set the out param
    if (hpsp)
    {
        *phpsp = hpsp;
        hr = S_OK;
    }
    else
    {
        // Either there is no isdn page to display or there
        // was an error.
        hr = E_FAIL;
        *phpsp = NULL;
        delete pisdn;
    }

    TraceErrorOptional("HrGetIsdnPage", hr, E_FAIL == hr);
    return (hr);
}

LRESULT CSpidsDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled)
{
    OnIsdnInfoPageTransition(m_hWnd, m_pisdnci);
    EndDialog(TRUE);

    return 0;
}

LRESULT CSpidsDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                            BOOL& bHandled)
{
    EndDialog(FALSE);

    return 0;
}

LRESULT CSpidsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                BOOL& bHandled)
{
    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(m_hWnd, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, m_pisdnci);

    ::SetFocus(GetDlgItem(IDC_EDT_PhoneNumber));

    // Note the current selections
    //
    m_pisdnci->nOldBChannel = SendDlgItemMessage(IDC_LBX_Variant,
                                                 LB_GETCURSEL, 0, 0);
    m_pisdnci->nOldDChannel = SendDlgItemMessage(IDC_LBX_Line,
                                                 LB_GETCURSEL, 0, 0);

    SendDlgItemMessage(IDC_EDT_SPID, EM_LIMITTEXT, c_cchMaxSpid, 0);
    SendDlgItemMessage(IDC_EDT_PhoneNumber, EM_LIMITTEXT, c_cchMaxOther, 0);

    return FALSE;
}

LRESULT CSpidsDlg::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                               BOOL& bHandled)
{
    if (wNotifyCode == LBN_SELCHANGE)
    {
        OnIsdnInfoPageSelChange(m_hWnd, m_pisdnci);
    }

    return 0;
}

LRESULT CSpidsDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                          BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}

//
// CEazDlg Implementation
//

LRESULT CEazDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                              BOOL& bHandled)
{
    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(m_hWnd, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, m_pisdnci);

    ::SetFocus(GetDlgItem(IDC_EDT_PhoneNumber));

    // Note the current selections
    //
    m_pisdnci->nOldBChannel = SendDlgItemMessage(IDC_LBX_Variant,
                                                 LB_GETCURSEL, 0, 0);
    m_pisdnci->nOldDChannel = SendDlgItemMessage(IDC_LBX_Line,
                                                 LB_GETCURSEL, 0, 0);

    SendDlgItemMessage(IDC_EDT_PhoneNumber, EM_LIMITTEXT, c_cchMaxOther, 0);

    return FALSE;
}

LRESULT CEazDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                      BOOL& bHandled)
{
    OnIsdnInfoPageTransition(m_hWnd, m_pisdnci);
    EndDialog(TRUE);

    return 0;
}

LRESULT CEazDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled)
{
    EndDialog(FALSE);

    return 0;
}

LRESULT CEazDlg::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                             BOOL& bHandled)
{
    if (wNotifyCode == LBN_SELCHANGE)
    {
        OnIsdnInfoPageSelChange(m_hWnd, m_pisdnci);
    }

    return 0;
}

LRESULT CEazDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                        BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}

//
// CMsnDlg Implementation
//

LRESULT CMsnDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                              BOOL& bHandled)
{
    OnMsnPageInitDialog(m_hWnd, m_pisdnci);

    // Note the current selections
    //
    m_pisdnci->nOldDChannel = SendDlgItemMessage(IDC_LBX_Line,
                                                 LB_GETCURSEL, 0, 0);

    SendDlgItemMessage(IDC_EDT_MSN, EM_LIMITTEXT, c_cchMaxOther, 0);

    return FALSE;
}

LRESULT CMsnDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled)
{
    INT     iCurSel;

    iCurSel = SendDlgItemMessage(IDC_LBX_Line, LB_GETCURSEL, 0, 0);
    if (iCurSel != LB_ERR)
    {
        GetDataFromListBox(iCurSel, m_hWnd, m_pisdnci);
    }

    EndDialog(TRUE);

    return 0;
}

LRESULT CMsnDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                            BOOL& bHandled)
{
    EndDialog(FALSE);

    return 0;
}

LRESULT CMsnDlg::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                       BOOL& bHandled)
{
    OnMsnPageAdd(m_hWnd, m_pisdnci);
    return 0;
}

LRESULT CMsnDlg::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled)
{
    OnMsnPageRemove(m_hWnd, m_pisdnci);
    return 0;
}

LRESULT CMsnDlg::OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled)
{
    OnMsnPageEditSelChange(m_hWnd, m_pisdnci);

    return 0;
}

LRESULT CMsnDlg::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                             BOOL& bHandled)
{
    if (wNotifyCode == LBN_SELCHANGE)
    {
        OnMsnPageSelChange(m_hWnd, m_pisdnci);
    }

    return 0;
}

LRESULT CMsnDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                        BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}

//
// CJapanDlg Implementation
//

LRESULT CJapanDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                BOOL& bHandled)
{
    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(m_hWnd, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, m_pisdnci);

    ::SetFocus(GetDlgItem(IDC_EDT_PhoneNumber));

    // Note the current selections
    //
    m_pisdnci->nOldBChannel = SendDlgItemMessage(IDC_LBX_Variant,
                                                 LB_GETCURSEL, 0, 0);
    m_pisdnci->nOldDChannel = SendDlgItemMessage(IDC_LBX_Line,
                                                 LB_GETCURSEL, 0, 0);

    SendDlgItemMessage(IDC_EDT_PhoneNumber, EM_LIMITTEXT, c_cchMaxOther, 0);
    SendDlgItemMessage(IDC_EDT_SPID, EM_LIMITTEXT, c_cchMaxOther, 0);

    return FALSE;
}

LRESULT CJapanDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled)
{
    OnIsdnInfoPageTransition(m_hWnd, m_pisdnci);
    EndDialog(TRUE);

    return 0;
}

LRESULT CJapanDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                            BOOL& bHandled)
{
    EndDialog(FALSE);

    return 0;
}

LRESULT CJapanDlg::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                               BOOL& bHandled)
{
    if (wNotifyCode == LBN_SELCHANGE)
    {
        OnIsdnInfoPageSelChange(m_hWnd, m_pisdnci);
    }

    return 0;
}

LRESULT CJapanDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                          BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdncfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N C F G . H
//
//  Contents:   ISDN Wizard/PropertySheet configuration structures
//
//  Notes:
//
//  Author:     jeffspr   14 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "ncsetup.h"
#include <ras.h>

// ISDN Switch type flags
const DWORD ISDN_SWITCH_NONE    = 0x00000000;
const DWORD ISDN_SWITCH_AUTO    = 0x00000001;
const DWORD ISDN_SWITCH_ATT     = 0x00000002;
const DWORD ISDN_SWITCH_NI1     = 0x00000004;
const DWORD ISDN_SWITCH_NTI     = 0x00000008;
const DWORD ISDN_SWITCH_INS64   = 0x00000010;
const DWORD ISDN_SWITCH_1TR6    = 0x00000020;
const DWORD ISDN_SWITCH_VN3     = 0x00000040;
const DWORD ISDN_SWITCH_NET3    = 0x00000080; // retained for backward compatibility
const DWORD ISDN_SWITCH_DSS1    = 0x00000080;
const DWORD ISDN_SWITCH_AUS     = 0x00000100;
const DWORD ISDN_SWITCH_BEL     = 0x00000200;
const DWORD ISDN_SWITCH_VN4     = 0x00000400;
const DWORD ISDN_SWITCH_NI2     = 0x00000800;
const DWORD ISDN_SWITCH_SWE     = 0x00001000;
const DWORD ISDN_SWITCH_ITA     = 0x00002000;
const DWORD ISDN_SWITCH_TWN     = 0x00004000;

//---[ Structures for ISDN Config info ]--------------------------------------

// Configuration structure for an ISDN B Channel
//
struct _ISDNBChannel
{
    WCHAR   szSpid[RAS_MaxPhoneNumber + 1];
    WCHAR   szPhoneNumber[RAS_MaxPhoneNumber + 1];
    WCHAR   szSubaddress[RAS_MaxPhoneNumber + 1];
};

typedef struct _ISDNBChannel    ISDN_B_CHANNEL;
typedef struct _ISDNBChannel *  PISDN_B_CHANNEL;

// Configuration structure for an ISDN D Channel. Can contain multiple
// B Channel structures
//
struct _ISDNDChannel
{
    DWORD           dwNumBChannels;
    PWSTR          mszMsnNumbers;
    PISDN_B_CHANNEL pBChannel;
};

typedef struct _ISDNDChannel    ISDN_D_CHANNEL;
typedef struct _ISDNDChannel *  PISDN_D_CHANNEL;

// Overall configuration for an ISDN adapter. Can contain multiple
// D Channel structures
//
struct _ISDNConfigInfo
{
    DWORD           dwWanEndpoints;
    DWORD           dwNumDChannels;
    DWORD           dwSwitchTypes;
    DWORD           dwCurSwitchType;
    INT             nOldDChannel;
    INT             nOldBChannel;
    BOOL            fIsPri;             // TRUE if this is a PRI adapter
    BOOL            fSkipToEnd;         // TRUE if we should skip the rest
                                        // of the wizard pages
    UINT            idd;                // Dialog resource ID of wizard page
                                        // we used
    PISDN_D_CHANNEL pDChannel;
    HDEVINFO        hdi;
    PSP_DEVINFO_DATA pdeid;
};

typedef struct _ISDNConfigInfo      ISDN_CONFIG_INFO;
typedef struct _ISDNConfigInfo *    PISDN_CONFIG_INFO;

//---[ Prototypes ]-----------------------------------------------------------

// Read the ISDN registry structure into the config info
//
HRESULT
HrReadIsdnPropertiesInfo(HKEY hkeyISDNBase, HDEVINFO hdi,
                         PSP_DEVINFO_DATA pdeid,
                         PISDN_CONFIG_INFO * ppISDNConfig);

// Write the ISDN config info back into the registry
//
HRESULT
HrWriteIsdnPropertiesInfo(HKEY hkeyISDNBase,
                          PISDN_CONFIG_INFO pISDNConfig);

// Free the structure allocated by HrReadISDNPropertiesInfo
//
VOID
FreeIsdnPropertiesInfo( PISDN_CONFIG_INFO   pISDNConfig);

BOOL
FAdapterIsIsdn(HKEY hkeyDriver);
BOOL
FShowIsdnPages(HKEY hkey);

// Set the next, back and cancel buttons depending if we are in GUI setup mode or stand-alone
//
VOID 
SetWizardButtons(HWND hWnd, BOOLEAN bFirstPage, PISDN_CONFIG_INFO pISDNConfig);

const DWORD c_cchMaxDChannelName = 3;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdnpage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N P A G E . H
//
//  Contents:   Isdn property page for Net Adapters
//
//  Notes:
//
//  Author:     BillBe   9 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "isdncfg.h"
#include <ncxbase.h>
#include "ncatlps.h"
#include "resource.h"

class CIsdnPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CIsdnPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        COMMAND_ID_HANDLER(IDC_CMB_SwitchType, OnSwitchType)
        COMMAND_ID_HANDLER(IDC_PSB_Configure, OnConfigure)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    END_MSG_MAP()

    CIsdnPage ();
    ~CIsdnPage();

    VOID DestroyPageCallbackHandler()
    {
        delete this;
    }

    HPROPSHEETPAGE
    CreatePage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);

    // ATL message handlers
    LRESULT
    OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT
    OnConfigure(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT
    OnSwitchType(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT
    OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    BOOL                m_fDirty;
    HKEY                m_hkeyDriver;
    HDEVINFO            m_hdi;
    PSP_DEVINFO_DATA    m_pdeid;
    PISDN_CONFIG_INFO   m_pisdnci;

    VOID DoSpidsDlg(VOID);
    VOID DoJapanDlg(VOID);
    VOID DoEazDlg(VOID);
    VOID DoMsnDlg(VOID);
};

//
// SPIDS dialog
//

class CSpidsDlg : public CDialogImpl<CSpidsDlg>
{
public:
    BEGIN_MSG_MAP(CSpidsDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDOK, OnOk)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDC_LBX_Variant, OnSelChange)
        COMMAND_ID_HANDLER(IDC_LBX_Line, OnSelChange)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
    END_MSG_MAP()

    enum {IDD = IDD_ISDN_SPIDS};

    CSpidsDlg(PISDN_CONFIG_INFO pisdnci)
    {
        m_pisdnci = pisdnci;
    }

    ~CSpidsDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                         BOOL& bHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    PISDN_CONFIG_INFO   m_pisdnci;
};

//
// EAZ Dialog
//

class CEazDlg : public CDialogImpl<CEazDlg>
{
public:
    BEGIN_MSG_MAP(CEazDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDOK, OnOk)
        COMMAND_ID_HANDLER(IDC_LBX_Variant, OnSelChange)
        COMMAND_ID_HANDLER(IDC_LBX_Line, OnSelChange)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
    END_MSG_MAP()

    enum {IDD = IDD_ISDN_EAZ};

    CEazDlg(PISDN_CONFIG_INFO pisdnci)
    {
        m_pisdnci = pisdnci;
    }

    ~CEazDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                         BOOL& bHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    PISDN_CONFIG_INFO   m_pisdnci;
};

//
// Multi-subscriber number dialog
//

class CMsnDlg : public CDialogImpl<CMsnDlg>
{
public:
    BEGIN_MSG_MAP(CMsnDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDOK, OnOk)
        COMMAND_ID_HANDLER(IDC_PSB_ADD, OnAdd)
        COMMAND_ID_HANDLER(IDC_PSB_REMOVE, OnRemove)
        COMMAND_ID_HANDLER(IDC_LBX_Line, OnSelChange)
        COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
    END_MSG_MAP()

    enum {IDD = IDD_ISDN_MSN};

    CMsnDlg(PISDN_CONFIG_INFO pisdnci)
    {
        m_pisdnci = pisdnci;
        m_iItemOld = 0;
    }

    ~CMsnDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                         BOOL& bHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    PISDN_CONFIG_INFO   m_pisdnci;
    INT                 m_iItemOld;
};

//
// Logical terminal dialog
//

class CJapanDlg : public CDialogImpl<CJapanDlg>
{
public:
    BEGIN_MSG_MAP(CJapanDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDOK, OnOk)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDC_LBX_Variant, OnSelChange)
        COMMAND_ID_HANDLER(IDC_LBX_Line, OnSelChange)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
    END_MSG_MAP()

    enum {IDD = IDD_ISDN_JAPAN};

    CJapanDlg(PISDN_CONFIG_INFO pisdnci)
    {
        m_pisdnci = pisdnci;
    }

    ~CJapanDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                         BOOL& bHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    PISDN_CONFIG_INFO   m_pisdnci;
};

const WCHAR c_szIsdnHelpFile[] = L"devmgr.hlp";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdnhook.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N H O O K . C P P
//
//  Contents:   Hook for the ISDN wizard, from the netdi.cpp class installer
//
//  Notes:
//
//  Author:     jeffspr   14 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "isdncfg.h"
#include "isdnwiz.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncstring.h"

//---[ Constants ]------------------------------------------------------------

extern const WCHAR c_szRegKeyInterfacesFromInstance[];
extern const WCHAR c_szRegValueLowerRange[];


//+--------------------------------------------------------------------------
//
//  Function:   FAdapterIsIsdn
//
//  Purpose:    Checks information under the adapters driver's key to
//                  determine if the adapter is ISDN
//
//  Arguments:
//      hkeyDriver [in] The driver key for the adapter
//
//  Returns:    BOOL. TRUE if the adapter is ISDN, FALSE otherwise
//
//  Author:     billbe   09 Sep 1997
//
//  Notes:
//
BOOL
FAdapterIsIsdn(HKEY hkeyDriver)
{
    Assert(hkeyDriver);

    const WCHAR c_szIsdn[]  = L"isdn";
    HKEY hkey;
    BOOL fIsIsdn = FALSE;

    // Open the Interfaces key under the driver key
    HRESULT hr = HrRegOpenKeyEx(hkeyDriver,
            c_szRegKeyInterfacesFromInstance, KEY_READ, &hkey);

    if (SUCCEEDED(hr))
    {
        PWSTR szRange;
        // Get the lower range of interfaces
        hr = HrRegQuerySzWithAlloc(hkey, c_szRegValueLowerRange, &szRange);

        if (SUCCEEDED(hr))
        {
            // Look for ISDN in the lower range
            fIsIsdn = FFindStringInCommaSeparatedList(c_szIsdn, szRange,
                    NC_IGNORE, NULL);
            MemFree(szRange);
        }
        RegCloseKey(hkey);
    }

    return fIsIsdn;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddIsdnWizardPagesIfAppropriate
//
//  Purpose:    Adds the ISDN wizard pages to the hardware wizard if the
//              bindings dictate such. We look to see if they have a lower
//              binding of "isdn", and if so, then add the pages.
//
//  Arguments:
//      hdi   [in] See Device Installer Api for more info
//      pdeid [in]
//
//  Returns:    S_OK if successful or valid Win32 error
//
//  Author:     jeffspr   17 Jun 1997
//
//  Notes:
//
HRESULT HrAddIsdnWizardPagesIfAppropriate(HDEVINFO hdi,
                                          PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // Open the adapter's driver key
    //
    HKEY    hkeyInstance = NULL;
    HRESULT hr = HrSetupDiOpenDevRegKey(hdi, pdeid, DICS_FLAG_GLOBAL, 0,
            DIREG_DRV, KEY_READ, &hkeyInstance);


    // Don't do anything if its not an ISDN adapter.
    if (SUCCEEDED(hr) && FShowIsdnPages(hkeyInstance))
    {
        // Read the ISDN registry structure into the config info
        //
        PISDN_CONFIG_INFO pisdnci;
        hr = HrReadIsdnPropertiesInfo(hkeyInstance, hdi, pdeid, &pisdnci);
        if (SUCCEEDED(hr))
        {
            Assert(pisdnci);

            if (pisdnci->dwCurSwitchType == ISDN_SWITCH_NONE)
            {
                // Add the wizard pages to the device's class install params.
                //
                hr = HrAddIsdnWizardPagesToDevice(hdi, pdeid, pisdnci);
            }
            else
            {
                TraceTag(ttidISDNCfg, "Not adding wizard pages because we "
                         "found a previous switch type for this device.");
            }
        }
    }

    RegSafeCloseKey(hkeyInstance);

    TraceError("HrAddIsdnWizardPagesIfAppropriate", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdnreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N R E G . C P P
//
//  Contents:   ISDN Wizard/PropertySheet registry functions
//
//  Notes:
//
//  Author:     VBaliga   14 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "isdncfg.h"
#include "ncreg.h"

#define NUM_D_CHANNELS_ALLOWED  16
#define NUM_B_CHANNELS_ALLOWED  50

// Reg key value names

// For each ISDN card instance
static const WCHAR c_szWanEndpoints[]       = L"WanEndpoints";
static const WCHAR c_szIsdnNumDChannels[]   = L"IsdnNumDChannels";
static const WCHAR c_szIsdnSwitchTypes[]    = L"IsdnSwitchTypes";

// For each D-channel
static const WCHAR c_szIsdnSwitchType[]     = L"IsdnSwitchType";
static const WCHAR c_szIsdnNumBChannels[]   = L"IsdnNumBChannels";

// For each B-channel
static const WCHAR c_szIsdnSpid[]           = L"IsdnSpid";
static const WCHAR c_szIsdnPhoneNumber[]    = L"IsdnPhoneNumber";
static const WCHAR c_szIsdnSubaddress[]     = L"IsdnSubaddress";
static const WCHAR c_szIsdnMultiNumbers[]   = L"IsdnMultiSubscriberNumbers";

/*

Function:
    HrReadNthDChannelInfo

Returns:
    HRESULT

Description:
    Read the information for the dwIndex'th D-channel into pDChannel. If this
    function succeeds, it allocates pDChannel->pBChannel, which has to be freed
    by calling LocalFree().

    If there is an error in reading IsdnSwitchType, this function returns
    S_FALSE.

    If there is an error in opening the a B-channel key, or there is an error
    in reading IsdnSpid or IsdnPhoneNumber, this function returns S_FALSE, but
    with empty strings in pBChannel->szSpid and pBChannel->szPhoneNumber for
    that B-channel.

*/

HRESULT
HrReadNthDChannelInfo(
    HKEY            hKeyIsdnBase,
    DWORD           dwDChannelIndex,
    PISDN_D_CHANNEL pDChannel
)
{
    WCHAR           szKeyName[20];      // _itow() uses only 17 wchars
    HKEY            hKeyDChannel        = NULL;
    HKEY            hKeyBChannel        = NULL;
    DWORD           dwBChannelIndex;
    PISDN_B_CHANNEL pBChannel;
    HRESULT         hr                  = E_FAIL;
    BOOL            fReturnSFalse       = FALSE;
    DWORD           cbData;

    Assert(NULL == pDChannel->pBChannel);

    _itow(dwDChannelIndex, szKeyName, 10 /* radix */);

    hr = HrRegOpenKeyEx(hKeyIsdnBase, szKeyName, KEY_READ, &hKeyDChannel);

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error opening D-channel %d. hr: %d",
            dwDChannelIndex, hr);
        goto LDone;
    }

    hr = HrRegQueryMultiSzWithAlloc(hKeyDChannel, c_szIsdnMultiNumbers,
                                    &pDChannel->mszMsnNumbers);

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d. hr: %d",
                 c_szIsdnMultiNumbers, dwDChannelIndex, hr);

        // Initialize to empty string
        //
        pDChannel->mszMsnNumbers = new WCHAR[1];

		if (pDChannel->mszMsnNumbers == NULL)
		{
			return(ERROR_NOT_ENOUGH_MEMORY);
		}

        *pDChannel->mszMsnNumbers = 0;

        // May not be present
        hr = S_OK;
    }

    hr = HrRegQueryDword(hKeyDChannel, c_szIsdnNumBChannels,
            &(pDChannel->dwNumBChannels));

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d. hr: %d",
            c_szIsdnNumBChannels, dwDChannelIndex, hr);
        goto LDone;
    }

    if (NUM_B_CHANNELS_ALLOWED < pDChannel->dwNumBChannels ||
        0 == pDChannel->dwNumBChannels)
    {
        // Actually, dwNumBChannels <= 23. We are protecting ourselves from
        // a corrupt registry.

        TraceTag(ttidISDNCfg, "%S in D-channel %d has invalid value: %d",
            c_szIsdnNumBChannels, dwDChannelIndex, pDChannel->dwNumBChannels);

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto LDone;
    }

    pDChannel->pBChannel = (PISDN_B_CHANNEL)
        LocalAlloc(LPTR, sizeof(ISDN_B_CHANNEL) * pDChannel->dwNumBChannels);

    if (NULL == pDChannel->pBChannel)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidISDNCfg, "Couldn't allocate memory. hr: %d", hr);
        goto LDone;
    }

    ZeroMemory(pDChannel->pBChannel, sizeof(ISDN_B_CHANNEL) *
                                     pDChannel->dwNumBChannels);

    for (dwBChannelIndex = 0;
         dwBChannelIndex < pDChannel->dwNumBChannels;
         dwBChannelIndex++)
    {
        pBChannel = pDChannel->pBChannel + dwBChannelIndex;
        _itow(dwBChannelIndex, szKeyName, 10 /* radix */);

        hr = HrRegOpenKeyEx(hKeyDChannel, szKeyName, KEY_READ, &hKeyBChannel);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error opening B-channel %d in D-channel "
                     "%d. hr: %d", dwBChannelIndex, dwDChannelIndex, hr);
            goto LForEnd;
        }

        cbData = sizeof(pBChannel->szSpid);

        hr = HrRegQuerySzBuffer(hKeyBChannel, c_szIsdnSpid, pBChannel->szSpid,
                &cbData);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d, "
                     "B-channel %d. hr: %d", c_szIsdnSpid,
                     dwDChannelIndex, dwBChannelIndex, hr);

            // May not be present
            hr = S_OK;
        }

        cbData = sizeof(pBChannel->szPhoneNumber);

        hr = HrRegQuerySzBuffer(hKeyBChannel, c_szIsdnPhoneNumber,
                pBChannel->szPhoneNumber, &cbData);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d, "
                     "B-channel %d. hr: %d", c_szIsdnPhoneNumber,
                     dwDChannelIndex, dwBChannelIndex, hr);

            // May not be present
            hr = S_OK;
        }

        cbData = sizeof(pBChannel->szSubaddress);

        hr = HrRegQuerySzBuffer(hKeyBChannel, c_szIsdnSubaddress,
                                pBChannel->szSubaddress, &cbData);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d, "
                     "B-channel %d. hr: %d", c_szIsdnSubaddress,
                     dwDChannelIndex, dwBChannelIndex, hr);

            // May not be present
            hr = S_OK;
        }

LForEnd:

        if (FAILED(hr))
        {
            fReturnSFalse = TRUE;
            hr = S_OK;
            pBChannel->szSpid[0] = L'\0';
            pBChannel->szPhoneNumber[0] = L'\0';
        }

        RegSafeCloseKey(hKeyBChannel);
    }

LDone:

    RegSafeCloseKey(hKeyDChannel);

    if (FAILED(hr))
    {
        LocalFree(pDChannel->pBChannel);
        pDChannel->pBChannel = NULL;
    }

    if (SUCCEEDED(hr) && fReturnSFalse)
    {
        TraceTag(ttidISDNCfg, "HrReadNthDChannelInfo(%d) returning S_FALSE",
            dwDChannelIndex);
        hr = S_FALSE;
    }

    TraceError("HrReadNthDChannelInfo", (S_FALSE == hr) ? S_OK: hr);
    return(hr);
}

/*

Function:
    HrReadDChannelsInfo

Returns:
    HRESULT

Description:
    Read the D-channel information into *ppDChannel. If the function fails,
    *ppDChannel will be NULL.

*/

HRESULT
HrReadDChannelsInfo(
    HKEY                hKeyISDNBase,
    DWORD               dwNumDChannels,
    PISDN_D_CHANNEL*    ppDChannel
)
{
    HRESULT         hr              = E_FAIL;
    BOOL            fReturnSFalse   = FALSE;
    PISDN_D_CHANNEL pDChannel;
    DWORD           dwIndex;

    pDChannel = (PISDN_D_CHANNEL)
                LocalAlloc(LPTR, sizeof(ISDN_D_CHANNEL) * dwNumDChannels);

    if (NULL == pDChannel)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidISDNCfg, "Couldn't allocate memory. hr: %d", hr);
        goto LDone;
    }

    // If there is an error, we will free these variables if they are not NULL.
    for (dwIndex = 0; dwIndex < dwNumDChannels; dwIndex++)
    {
        Assert(NULL == pDChannel[dwIndex].pBChannel);
    }

    for (dwIndex = 0; dwIndex < dwNumDChannels; dwIndex++)
    {
        hr = HrReadNthDChannelInfo(hKeyISDNBase, dwIndex, pDChannel + dwIndex);

        if (FAILED(hr))
        {
            goto LDone;
        }

        if (S_FALSE == hr)
        {
            fReturnSFalse = TRUE;
        }
    }

LDone:

    if (FAILED(hr))
    {
        if (NULL != pDChannel)
		{
			for (dwIndex = 0; dwIndex < dwNumDChannels; dwIndex++)
			{
				LocalFree(pDChannel[dwIndex].pBChannel);
			}

			LocalFree(pDChannel);

			*ppDChannel = NULL;
		}
    }
    else
    {
        *ppDChannel = pDChannel;
    }

    if (SUCCEEDED(hr) && fReturnSFalse)
    {
        TraceTag(ttidISDNCfg, "HrReadDChannelsInfo() returning S_FALSE");
        hr = S_FALSE;
    }

    TraceError("HrReadDChannelsInfo", (S_FALSE == hr) ? S_OK : hr);
    return(hr);
}

/*

Function:
    HrReadISDNPropertiesInfo

Returns:
    HRESULT

Description:
    Read the ISDN registry structure into the config info. If the function
    fails, *ppISDNConfig will be NULL. Else, *ppISDNConfig has to be freed
    by calling FreeISDNPropertiesInfo().

*/

HRESULT
HrReadIsdnPropertiesInfo(
    HKEY                hKeyIsdnBase,
    HDEVINFO            hdi,
    PSP_DEVINFO_DATA    pdeid,
    PISDN_CONFIG_INFO*  ppIsdnConfig
)
{
    HRESULT             hr              = E_FAIL;
    PISDN_CONFIG_INFO   pIsdnConfig;
    DWORD               dwIndex;

    pIsdnConfig = (PISDN_CONFIG_INFO)
                  LocalAlloc(LPTR, sizeof(ISDN_CONFIG_INFO));

    if (NULL == pIsdnConfig)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidISDNCfg, "Couldn't allocate memory. hr: %d", hr);
        goto LDone;
    }

    ZeroMemory(pIsdnConfig, sizeof(ISDN_CONFIG_INFO));

    pIsdnConfig->hdi = hdi;
    pIsdnConfig->pdeid = pdeid;

    // If there is an error, we will free these variables if they are not NULL.
    Assert(NULL == pIsdnConfig->pDChannel);

    hr = HrRegQueryDword(hKeyIsdnBase, c_szWanEndpoints,
            &(pIsdnConfig->dwWanEndpoints));

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S. hr: %d", c_szWanEndpoints,
            hr);
        goto LDone;
    }

    hr = HrRegQueryDword(hKeyIsdnBase, c_szIsdnNumDChannels,
            &(pIsdnConfig->dwNumDChannels));

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S. hr: %d", c_szIsdnNumDChannels,
            hr);
        goto LDone;
    }

    if (NUM_D_CHANNELS_ALLOWED < pIsdnConfig->dwNumDChannels ||
        0 == pIsdnConfig->dwNumDChannels)
    {
        // Actually, dwNumDChannels <= 8. We are protecting ourselves from
        // a corrupt registry.

        TraceTag(ttidISDNCfg, "%S has invalid value: %d", c_szIsdnNumDChannels,
            pIsdnConfig->dwNumDChannels);

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        // Setting dwNumDChannels to 0 will help us when we try to free the
        // allocated ISDN_B_CHANNEL's

        pIsdnConfig->dwNumDChannels = 0;

        goto LDone;
    }

    hr = HrRegQueryDword(hKeyIsdnBase, c_szIsdnSwitchTypes,
                         &pIsdnConfig->dwSwitchTypes);

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S. hr: %d", c_szIsdnSwitchTypes,
                 hr);
        goto LDone;
    }

    hr = HrReadDChannelsInfo(hKeyIsdnBase, pIsdnConfig->dwNumDChannels,
            &(pIsdnConfig->pDChannel));

    if (FAILED(hr))
    {
        goto LDone;
    }

    // A PRI adapter is one that has more than 2 B channels per D channel.
    // Since all D channels should have the same number of B channels, the
    // safest thing to do is pick the first D channel
    //
    pIsdnConfig->fIsPri = (pIsdnConfig->pDChannel[0].dwNumBChannels > 2);

#if DBG
    if (pIsdnConfig->fIsPri)
    {
        TraceTag(ttidISDNCfg, "This is a PRI adapter!");
    }
#endif

    hr = HrRegQueryDword(hKeyIsdnBase, c_szIsdnSwitchType,
                         &(pIsdnConfig->dwCurSwitchType));

    if (FAILED(hr))
    {
        Assert(ISDN_SWITCH_NONE == pIsdnConfig->dwCurSwitchType);

        TraceTag(ttidISDNCfg, "Error reading %S. If this is a new install, "
                 "then this is expected. hr: %d", c_szIsdnSwitchType,
                 hr);

        // Switch type won't exist on a new install of the card so this is ok
        hr = S_OK;
    }

LDone:

    if (FAILED(hr))
    {
        if (NULL != pIsdnConfig)
		{
			if (NULL != pIsdnConfig->pDChannel)
			{
				for (dwIndex = 0;
					 dwIndex < pIsdnConfig->dwNumDChannels;
					 dwIndex++)
				{
					LocalFree(pIsdnConfig->pDChannel[dwIndex].pBChannel);
				}

				LocalFree(pIsdnConfig->pDChannel);
			}

			LocalFree(pIsdnConfig);
			*ppIsdnConfig = NULL;
        }
    }
    else
    {
        *ppIsdnConfig = pIsdnConfig;
    }

    TraceError("HrReadIsdnPropertiesInfo", hr);
    return(hr);
}

/*

Function:
    HrWriteIsdnPropertiesInfo

Returns:
    HRESULT

Description:
    Write the ISDN config info back into the registry.

*/

HRESULT
HrWriteIsdnPropertiesInfo(
    HKEY                hKeyIsdnBase,
    PISDN_CONFIG_INFO   pIsdnConfig
)
{
    WCHAR           szKeyName[20];      // _itow() uses only 17 wchars
    HRESULT         hr                  = E_FAIL;
    HKEY            hKeyDChannel        = NULL;
    HKEY            hKeyBChannel        = NULL;
    DWORD           dwDChannelIndex;
    DWORD           dwBChannelIndex;
    PISDN_D_CHANNEL pDChannel;
    PISDN_B_CHANNEL pBChannel;

    Assert(NUM_D_CHANNELS_ALLOWED >= pIsdnConfig->dwNumDChannels);

    hr = HrRegSetDword(hKeyIsdnBase, c_szIsdnSwitchType,
                       pIsdnConfig->dwCurSwitchType);
    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error writing %S. hr: %d",
                 c_szIsdnSwitchType, hr);
        goto LOuterForEnd;
    }

    for (dwDChannelIndex = 0;
         dwDChannelIndex < pIsdnConfig->dwNumDChannels;
         dwDChannelIndex++)
    {
        pDChannel = pIsdnConfig->pDChannel + dwDChannelIndex;
        _itow(dwDChannelIndex, szKeyName, 10 /* radix */);

        hr = HrRegOpenKeyEx(hKeyIsdnBase, szKeyName, KEY_WRITE,
                            &hKeyDChannel);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error opening D-channel %d. hr: %d",
                dwDChannelIndex, hr);
            goto LOuterForEnd;
        }

        hr = HrRegSetMultiSz(hKeyDChannel, c_szIsdnMultiNumbers,
                             pDChannel->mszMsnNumbers);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error writing %S. hr: %d",
                     c_szIsdnMultiNumbers, hr);
            goto LOuterForEnd;
        }

        Assert(NUM_B_CHANNELS_ALLOWED >= pDChannel->dwNumBChannels);

        for (dwBChannelIndex = 0;
             dwBChannelIndex < pDChannel->dwNumBChannels;
             dwBChannelIndex++)
        {
            pBChannel = pDChannel->pBChannel + dwBChannelIndex;
            _itow(dwBChannelIndex, szKeyName, 10 /* radix */);

            hr = HrRegCreateKeyEx(hKeyDChannel, szKeyName,
                    REG_OPTION_NON_VOLATILE, KEY_WRITE,
                    NULL, &hKeyBChannel, NULL);

            if (FAILED(hr))
            {
                TraceTag(ttidISDNCfg, "Error opening B-channel %d in "
                         "D-channel %d. hr: %d", dwBChannelIndex,
                         dwDChannelIndex, hr);
                goto LInnerForEnd;
            }

            hr = HrRegSetSz(hKeyBChannel, c_szIsdnSpid, pBChannel->szSpid);

            if (FAILED(hr))
            {
                TraceTag(ttidISDNCfg, "Error writing %S in D-channel %d, "
                         "B-channel %d. hr: %d", c_szIsdnSpid,
                         dwDChannelIndex, dwBChannelIndex, hr);
                goto LInnerForEnd;
            }

            hr = HrRegSetSz(hKeyBChannel, c_szIsdnPhoneNumber,
                            pBChannel->szPhoneNumber);

            if (FAILED(hr))
            {
                TraceTag(ttidISDNCfg, "Error writing %S in D-channel %d, "
                         "B-channel %d. hr: %d", c_szIsdnPhoneNumber,
                         dwDChannelIndex, dwBChannelIndex, hr);
                goto LInnerForEnd;
            }

            hr = HrRegSetSz(hKeyBChannel, c_szIsdnSubaddress,
                            pBChannel->szSubaddress);

            if (FAILED(hr))
            {
                TraceTag(ttidISDNCfg, "Error writing %S in D-channel %d, "
                         "B-channel %d. hr: %d", c_szIsdnSubaddress,
                         dwDChannelIndex, dwBChannelIndex, hr);
                goto LInnerForEnd;
            }

LInnerForEnd:

            RegSafeCloseKey(hKeyBChannel);

            if (FAILED(hr))
            {
                goto LOuterForEnd;
            }
        }

LOuterForEnd:

        RegSafeCloseKey(hKeyDChannel);

        if (FAILED(hr))
        {
            goto LDone;
        }
    }

LDone:

    TraceError("HrWriteIsdnPropertiesInfo", hr);
    return(hr);
}

/*

Function:
    FreeIsdnPropertiesInfo

Returns:
    HRESULT

Description:
    Free the structure allocated by HrReadIsdnPropertiesInfo.

*/

VOID
FreeIsdnPropertiesInfo(
    PISDN_CONFIG_INFO   pIsdnConfig
)
{
    DWORD   dwIndex;

    if (NULL == pIsdnConfig)
    {
        return;
    }

    if (NULL != pIsdnConfig->pDChannel)
    {
        for (dwIndex = 0; dwIndex < pIsdnConfig->dwNumDChannels; dwIndex++)
        {
            LocalFree(pIsdnConfig->pDChannel[dwIndex].pBChannel);
            delete [] pIsdnConfig->pDChannel[dwIndex].mszMsnNumbers;
        }

        LocalFree(pIsdnConfig->pDChannel);
    }

    LocalFree(pIsdnConfig);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdnshts.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N S H T S . C P P
//
//  Contents:   Dialog procs for the ISDN Property sheets and wizard pages
//
//  Notes:
//
//  Author:     danielwe    9 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <ncui.h>
#include "ncreg.h"
#include "isdncfg.h"
#include "isdnshts.h"
#include "resource.h"
#include "ncmisc.h"

#ifndef IDD_NetDevSelect
#define IDD_NetDevSelect               21013
#endif


//---[ Constants ]------------------------------------------------------------

const DWORD c_iMaxChannelName  =   3;      // For the channel listbox

struct SWITCH_TYPE_MASK_INFO
{
    DWORD   dwMask;
    UINT    idsSwitchType;
};

//
// Switch type masks.
//
// Maps the switch type to a description string.
//
static const SWITCH_TYPE_MASK_INFO c_astmi[] =
{
    {ISDN_SWITCH_AUTO,  IDS_ISDN_SWITCH_AUTO},
    {ISDN_SWITCH_ATT,   IDS_ISDN_SWITCH_ATT},
    {ISDN_SWITCH_NI1,   IDS_ISDN_SWITCH_NI1},
    {ISDN_SWITCH_NI2,   IDS_ISDN_SWITCH_NI2},
    {ISDN_SWITCH_NTI,   IDS_ISDN_SWITCH_NTI},
    {ISDN_SWITCH_INS64, IDS_ISDN_SWITCH_INS64},
    {ISDN_SWITCH_1TR6,  IDS_ISDN_SWITCH_1TR6},
    {ISDN_SWITCH_VN3,   IDS_ISDN_SWITCH_VN3},
//    {ISDN_SWITCH_NET3,  IDS_ISDN_SWITCH_DSS1},
    {ISDN_SWITCH_DSS1,  IDS_ISDN_SWITCH_DSS1},
    {ISDN_SWITCH_AUS,   IDS_ISDN_SWITCH_AUS},
    {ISDN_SWITCH_BEL,   IDS_ISDN_SWITCH_BEL},
    {ISDN_SWITCH_VN4,   IDS_ISDN_SWITCH_VN4},
    {ISDN_SWITCH_SWE,   IDS_ISDN_SWITCH_SWE},
    {ISDN_SWITCH_TWN,   IDS_ISDN_SWITCH_TWN},
    {ISDN_SWITCH_ITA,   IDS_ISDN_SWITCH_ITA},
};

static const INT c_cstmi = celems(c_astmi);

static const WCHAR c_szIsdnShowPages[] = L"ShowIsdnPages";

//+---------------------------------------------------------------------------
//
//  Function:   FShowIsdnPages
//
//  Purpose:    Determines whether the ISDN wizard property page or wizard
//              pages should be shown.
//
//  Arguments:
//      hkey [in]   Driver instance key for ISDN device
//
//  Returns:    If the ShowIsdnPages value is:
//
//              not present:            TRUE, if adapter has ISDN in lower
//                                            range
//              present and zero:       FALSE
//              present and non-zero:   TRUE, unconditionally
//
//  Author:     danielwe   15 Dec 1998
//
//  Notes:
//
BOOL FShowIsdnPages(HKEY hkey)
{
    DWORD   dwValue;

    if (SUCCEEDED(HrRegQueryDword(hkey, c_szIsdnShowPages, &dwValue)))
    {
        if (!dwValue)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    else
    {
        return FAdapterIsIsdn(hkey);
    }
}

//
// Switch Type page functions
//

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnSwitchTypeInit
//
//  Purpose:    Called when the switch type page is initialized
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnSwitchTypeInit(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    // Populate the switch types from the multi-sz that we read
    //
    PopulateIsdnSwitchTypes(hwndDlg, IDC_CMB_SwitchType, pisdnci);

    pisdnci->nOldDChannel = SendDlgItemMessage(hwndDlg, IDC_LBX_Line,
                                               LB_GETCURSEL, 0, 0);
    pisdnci->nOldBChannel = SendDlgItemMessage(hwndDlg, IDC_LBX_Variant,
                                    LB_GETCURSEL, 0, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckShowPagesFlag
//
//  Purpose:    Checks a special registry flag to see if a vendor wishes to
//              suppress the ISDN wizard from appearing upon installation of
//              their device.
//
//  Arguments:
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   15 Dec 1998
//
//  Notes:
//
VOID CheckShowPagesFlag(PISDN_CONFIG_INFO pisdnci)
{
    // Open the adapter's driver key
    //
    HKEY    hkeyInstance = NULL;
    HRESULT hr = S_OK;

    hr = HrSetupDiOpenDevRegKey(pisdnci->hdi, pisdnci->pdeid,
                                DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                                KEY_READ, &hkeyInstance);
    if (SUCCEEDED(hr))
    {
        if (!FShowIsdnPages(hkeyInstance))
        {
            TraceTag(ttidISDNCfg, "Skipping all ISDN wizard pages because"
                     "the %S value was present and zero", c_szIsdnShowPages);

            pisdnci->fSkipToEnd = TRUE;
        }
        else
        {
            TraceTag(ttidISDNCfg, "Showing all ISDN wizard pages...");
        }

        RegCloseKey(hkeyInstance);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnSwitchTypeSetActive
//
//  Purpose:    Called when the switch type page is made active.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    DWL_MSGRESULT
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
LONG OnIsdnSwitchTypeSetActive(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    // For bug #265745: Some vendors will want to suppress the ISDN wizard
    // in the case where their card is multifunction. The coinstaller for that
    // device will ask the user if they want the card configured for ISDN and
    // if they say 'no' then we shouldn't show the ISDN wizard. The following
    // function checks the registry to see if the user essentially chose 'no'.
    CheckShowPagesFlag(pisdnci);

    if (pisdnci->fSkipToEnd)
    {
        return -1;
    }
    else
    {
        // Set the button states.
        //
        SetWizardButtons(GetParent(hwndDlg),TRUE, pisdnci);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetWizardButtons
//
//  Purpose:    Sets the next, back and cancel buttons depending what property 
//              page we are in and if we are in GUI mode setup or stand-alone mode.
//
//  Arguments:
//      hwndDlg    [in]    Handle to property page
//      bFirstPage [in]    Indicates if the property page is the first page.
//                         If it is the first page and we are in stand-alone 
//                         the back button is disabled
//
//  Returns:    void
//
//  Author:     omiller   15 May 2000
//
//  Notes:      Next and Back are enabled in GUI setup mode. The cancel button
//              is not displayed in GUI setup mode.
//              In stand-alone mode the next button and cancel button are enabled.
//
VOID SetWizardButtons(HWND hwndDlg, BOOLEAN bFirstPage, PISDN_CONFIG_INFO pisdnci)
{
    // Determine if we are in GUI mode setup or running stand-alone
    //
    if( FInSystemSetup() )
    {
        // We are GUI Setup mode. There is a property page before us and after us. 
        // Therefore we have to enable the next and/or back buttons. There is no 
        // cancel button for this property page in GUI setup mode.
        //

        DWORD  dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
        int    iIndex;
        HWND   hwndFirstPage;

        if ( pisdnci )
        {
            iIndex = PropSheet_IdToIndex( hwndDlg, IDD_NetDevSelect );

            if ( iIndex != -1 )
            {
                hwndFirstPage = PropSheet_IndexToHwnd( hwndDlg, iIndex );

                if ( hwndFirstPage )
                {
                    if (SendMessage(hwndFirstPage, WM_SELECTED_ALL, (WPARAM)0,
                                     (LPARAM)pisdnci->pdeid->DevInst) )
                    {
                        dwFlags = PSWIZB_NEXT;
                    }
                }
            }
        }

        PropSheet_SetWizButtons(hwndDlg, dwFlags);
    }
    else
    {
        // We are running in stand-alone mode. This means that we are the first property 
        // sheet. Therefore the back button should be disabled, the next button enabled.
        // and the cancel button should be enabled. The cancel button does not appear in 
        // GUI setup mode.
        //
        HWND hCancel;
        

        // Get the handle to the cancel button and enable the button.
        //
        hCancel=GetDlgItem(hwndDlg,IDCANCEL);
        EnableWindow(hCancel,TRUE);

        if( bFirstPage )
        {
            // Enable the next button.
            PropSheet_SetWizButtons(hwndDlg,PSWIZB_NEXT);
        }
        else
        {
            // Enable the next button.
           PropSheet_SetWizButtons(hwndDlg,PSWIZB_BACK | PSWIZB_NEXT);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DwGetSwitchType
//
//  Purpose:    Takes the selected switch type in the dropdown list and
//              returns the actual value that will be stored in the registry.
//
//  Arguments:
//      hwndDlg     [in]    HWND of dialog
//      pisdnci     [in]    Configuration information as read from the
//                          registry
//      iDialogItem [in]    Item ID of switch type dropdown list
//
//  Returns:
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
DWORD DwGetSwitchType(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci,
                      INT iDialogItem)
{
    INT     iCurSel;
    INT     iSwitchType;

    iCurSel = SendDlgItemMessage(hwndDlg, iDialogItem, CB_GETCURSEL, 0, 0);

    // Switch type index should be the item data for the selected switch
    // type
    iSwitchType = SendDlgItemMessage(hwndDlg, iDialogItem, CB_GETITEMDATA,
                                     iCurSel, 0);

    AssertSz(iSwitchType >= 0 && iSwitchType < c_cstmi, "Switch type item data"
             " is bad!");

    return c_astmi[iSwitchType].dwMask;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnSwitchTypeWizNext
//
//  Purpose:    Called when the switch type page is advanced in the forward
//              direction.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnSwitchTypeWizNext(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT     idd = 0;

    pisdnci->dwCurSwitchType = DwGetSwitchType(hwndDlg, pisdnci,
                                               IDC_CMB_SwitchType);

    switch (pisdnci->dwCurSwitchType)
    {
    case ISDN_SWITCH_ATT:
    case ISDN_SWITCH_NI1:
    case ISDN_SWITCH_NI2:
    case ISDN_SWITCH_NTI:
        if (pisdnci->fIsPri)
        {
            // PRI adapters use the EAZ page instead
            idd = IDW_ISDN_EAZ;
        }
        else
        {
            idd = IDW_ISDN_SPIDS;
        }
        break;

    case ISDN_SWITCH_INS64:
        idd = IDW_ISDN_JAPAN;
        break;

    case ISDN_SWITCH_AUTO:
    case ISDN_SWITCH_1TR6:
        idd = IDW_ISDN_EAZ;
        break;

    case ISDN_SWITCH_VN3:
    case ISDN_SWITCH_VN4:
    case ISDN_SWITCH_DSS1:
    case ISDN_SWITCH_AUS:
    case ISDN_SWITCH_BEL:
    case ISDN_SWITCH_SWE:
    case ISDN_SWITCH_TWN:
    case ISDN_SWITCH_ITA:
        idd = IDW_ISDN_MSN;
        break;

    default:
        AssertSz(FALSE, "Where do we go from here.. now that all of our "
                 "children are growin' up?");
        break;
    }

    // Save away the dialog we used so we can make decisions later on about
    // what to call things, etc...
    //
    pisdnci->idd = idd;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsdnSwitchTypeProc
//
//  Purpose:    Dialog proc handler for switch type page.
//
//  Arguments:
//      hwndDlg  []
//      uMessage []
//      wparam   []
//      lparam   []
//
//  Returns:
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
INT_PTR
CALLBACK
IsdnSwitchTypeProc(HWND hwndDlg, UINT uMessage,
                                 WPARAM wparam, LPARAM lparam)
{
    LPNMHDR             lpnmhdr    = NULL;
    PISDN_CONFIG_INFO   pisdnci;
    PROPSHEETPAGE *     ppsp;

    pisdnci = (PISDN_CONFIG_INFO)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch (uMessage)
    {
        case WM_INITDIALOG:
            PAGE_DATA * pPageData;

            ppsp = (PROPSHEETPAGE *) lparam;

            // Set the per-page data for this particular page. See the
            // comments above about why we use the per-page data.
            //
            AssertSz(!pisdnci, "This should not have been set yet");

            pPageData = (PAGE_DATA *)ppsp->lParam;
            pisdnci = pPageData->pisdnci;

            // Set this data in the window long for user-data
            //
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pisdnci);

            // Call the init handler function
            //
            OnIsdnSwitchTypeInit(hwndDlg, pisdnci);
            break;

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *)lparam;
            // Handle all of the notification messages
            //
            switch (lpnmhdr->code)
            {
                case PSN_SETACTIVE:
                {
                    LONG l = OnIsdnSwitchTypeSetActive(hwndDlg, pisdnci);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, l);
                    return TRUE;
                }
                case PSN_APPLY:
                    break;
                case PSN_WIZBACK:
                    break;
                case PSN_WIZNEXT:
                    OnIsdnSwitchTypeWizNext(hwndDlg, pisdnci);
                    break;
                case PSN_WIZFINISH:
                    AssertSz(FALSE, "You can't finish from this page!");
                    break;
                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   PopulateIsdnSwitchTypes
//
//  Purpose:    Fills in the drop-down list for the switch type page
//
//  Arguments:
//      hwndDlg     [in]    Handle to page
//      iDialogItem [in]    Item ID of drop-down list
//      pisdnci     [in]    Configuration information as read from the
//                          registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID PopulateIsdnSwitchTypes(HWND hwndDlg, INT iDialogItem,
                             PISDN_CONFIG_INFO pisdnci)
{
    INT     iCurrentIndex   = 0;
    INT     iSetItemData    = 0;
    DWORD   dwSwitchType    = 0;
    DWORD   nCountry;
    INT     istmi;

    Assert(hwndDlg);
    Assert(pisdnci);
    Assert(pisdnci->dwSwitchTypes);

    nCountry = DwGetCurrentCountryCode();

    // Loop through the list of switch types and add them to the combo box
    //
    for (istmi = 0; istmi < c_cstmi; istmi++)
    {
        if (pisdnci->dwSwitchTypes & c_astmi[istmi].dwMask)
        {
            // Add the string
            //
            iCurrentIndex = SendDlgItemMessage(hwndDlg, iDialogItem,
                       CB_ADDSTRING,
                       0, (LPARAM) SzLoadIds(c_astmi[istmi].idsSwitchType));

            Assert(iCurrentIndex != CB_ERR);

            // Set the item data, so we know the index into the switch type
            // array that we're dealing with.
            //
            iSetItemData = SendDlgItemMessage(hwndDlg, iDialogItem,
                                              CB_SETITEMDATA, iCurrentIndex,
                                              istmi);

            if (FIsDefaultForLocale(nCountry, c_astmi[istmi].dwMask))
            {
                // Save index to find default item to select later
                dwSwitchType = c_astmi[istmi].dwMask;
            }
            else if (!dwSwitchType)
            {
                // If no default has been set, set one now.
                dwSwitchType = c_astmi[istmi].dwMask;
            }

            Assert(iSetItemData != CB_ERR);
        }
    }

        SetSwitchType(hwndDlg, IDC_CMB_SwitchType, dwSwitchType);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSwitchType
//
//  Purpose:    Given a switch type mask, selects the item in the combo box
//              that corresponds to that switch type.
//
//  Arguments:
//      hwndDlg         [in]    Dialog handle.
//      iItemSwitchType [in]    Item ID of switch type combo box.
//      dwSwitchType    [in]    Switch type mask to select.
//
//  Returns:    Nothin'
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID SetSwitchType(HWND hwndDlg, INT iItemSwitchType, DWORD dwSwitchType)
{
    INT     iItem;
    INT     cItems;

    cItems = SendDlgItemMessage(hwndDlg, iItemSwitchType, CB_GETCOUNT, 0, 0);
    for (iItem = 0; iItem < cItems; iItem++)
    {
        INT     istmiCur;

        istmiCur = SendDlgItemMessage(hwndDlg, iItemSwitchType,
                                      CB_GETITEMDATA, iItem, 0);
        if (c_astmi[istmiCur].dwMask == dwSwitchType)
        {
            // Select switch type
            //
            SendDlgItemMessage(hwndDlg, iItemSwitchType, CB_SETCURSEL,
                               iItem, 0);
            break;
        }
    }
}

//
// Info page functions
//

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageInit
//
//  Purpose:    Called when the info (second) page of the wizard is
//              initialized.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageInit(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, pisdnci);

    SetFocus(GetDlgItem(hwndDlg, IDC_EDT_PhoneNumber));
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageSetActive
//
//  Purpose:    Called when the second page of the wizard is activated
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
LONG OnIsdnInfoPageSetActive(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    if (pisdnci->idd == (UINT)GetWindowLongPtr(hwndDlg, DWLP_USER) &&
        !pisdnci->fSkipToEnd)
    {
        // Set the button states.
        //
        SetWizardButtons(GetParent(hwndDlg),FALSE, NULL);

        SetFocus(GetDlgItem(hwndDlg, IDC_EDT_PhoneNumber));

        // Note the current selections
        //
        pisdnci->nOldBChannel = SendDlgItemMessage(hwndDlg, IDC_LBX_Variant,
                                                   LB_GETCURSEL, 0, 0);
        pisdnci->nOldDChannel = SendDlgItemMessage(hwndDlg, IDC_LBX_Line,
                                                   LB_GETCURSEL, 0, 0);
    }
    else
    {
        return -1;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageApply
//
//  Purpose:    Called when the info (second) page is applied
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageApply(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    // Open the adapter's driver key and store the info
    //
    HRESULT hr;
    HKEY    hkey;

    hr = HrSetupDiOpenDevRegKey(pisdnci->hdi, pisdnci->pdeid, DICS_FLAG_GLOBAL,
                                0, DIREG_DRV, KEY_ALL_ACCESS, &hkey);
    if (SUCCEEDED(hr))
    {
        // Write the parameters back out into the registry.
        //
        hr = HrWriteIsdnPropertiesInfo(hkey, pisdnci);
        if (SUCCEEDED(hr))
        {
            hr = HrSetupDiSendPropertyChangeNotification(pisdnci->hdi,
                                                         pisdnci->pdeid,
                                                         DICS_PROPCHANGE,
                                                         DICS_FLAG_GLOBAL,
                                                         0);
        }

        RegCloseKey(hkey);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageWizNext
//
//  Purpose:    Called when the info (second) page is advanced in the
//              forward direction.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageWizNext(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    if (pisdnci->idd == (UINT)GetWindowLongPtr(hwndDlg, DWLP_USER))
    {
        OnIsdnInfoPageTransition(hwndDlg, pisdnci);
        OnIsdnInfoPageApply(hwndDlg, pisdnci);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageTransition
//
//  Purpose:    Called when the info (second) page is advanced in either the
//              forward or backward directions.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   5 May 1998
//
//  Notes:
//
VOID OnIsdnInfoPageTransition(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    Assert(hwndDlg);

    if (pisdnci->idd == IDW_ISDN_MSN)
    {
        INT     iCurSel;

        iCurSel = SendDlgItemMessage(hwndDlg, IDC_LBX_Line, LB_GETCURSEL, 0, 0);
        if (iCurSel != LB_ERR)
        {
            GetDataFromListBox(iCurSel, hwndDlg, pisdnci);
        }
    }
    else
    {
        DWORD   dwDChannel;
        DWORD   dwBChannel;

        Assert(pisdnci);
        Assert(pisdnci->pDChannel);

        dwDChannel = SendDlgItemMessage(hwndDlg, IDC_LBX_Line,
                                        LB_GETCURSEL, 0, 0);

        Assert(pisdnci->dwNumDChannels >= dwDChannel);

        dwBChannel = SendDlgItemMessage(hwndDlg, IDC_LBX_Variant,
                                        LB_GETCURSEL, 0, 0);

        // Update the channel info for the currently selected channel from
        // the SPID/Phone Number edit controls
        //
        SetModifiedIsdnChannelInfo(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                                   IDC_LBX_Variant, dwBChannel, pisdnci);

        // Retrieve all of the ISDN B-Channel info from the listbox item-data,
        // and update the config info.
        //
        RetrieveIsdnChannelInfo(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                                IDC_LBX_Variant, pisdnci, dwDChannel,
                                dwBChannel);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageWizBack
//
//  Purpose:    Called when the info (second) page is advanced in the reverse
//              direction.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageWizBack(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    OnIsdnInfoPageTransition(hwndDlg, pisdnci);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageSelChange
//
//  Purpose:    Called when the selection changes in either the D-channel or
//              B-channel listboxes.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT     nDChannel;
    INT     nBChannel;

    Assert(hwndDlg);
    Assert(pisdnci);
    Assert(pisdnci->pDChannel);

    nDChannel = SendDlgItemMessage(hwndDlg, IDC_LBX_Line,
                                   LB_GETCURSEL, 0, 0);
    Assert(LB_ERR != nDChannel);

    Assert(pisdnci->dwNumDChannels >= (DWORD)nDChannel);

    nBChannel = SendDlgItemMessage(hwndDlg, IDC_LBX_Variant,
                                   LB_GETCURSEL, 0, 0);
    Assert(LB_ERR != nBChannel);

    if ((LB_ERR != nDChannel) &&
        (LB_ERR != nBChannel) &&
        ((nBChannel != pisdnci->nOldBChannel) ||
         (nDChannel != pisdnci->nOldDChannel)))
    {
        PISDN_D_CHANNEL pisdndc;

        // Get the channel info for the selection that's going away, and update
        // it's listbox item data.
        //
        SetModifiedIsdnChannelInfo(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                                   IDC_LBX_Variant, pisdnci->nOldBChannel,
                                   pisdnci);

        pisdndc = &(pisdnci->pDChannel[nDChannel]);

        Assert(pisdndc);

        // Update item data to reflect new line (d channel)
        //
        for (DWORD dwChannel = 0;
             dwChannel < pisdndc->dwNumBChannels;
             dwChannel++)
        {
            SendDlgItemMessage(hwndDlg, IDC_LBX_Variant, LB_SETITEMDATA,
                               dwChannel,
                               (LPARAM) (&pisdndc->pBChannel[dwChannel]));
        }

        // Update the edit controls for the newly selected listbox item (channel)
        //
        SetCurrentIsdnChannelSelection(hwndDlg, IDC_EDT_SPID,
                                       IDC_EDT_PhoneNumber, IDC_LBX_Variant,
                                       pisdnci, nDChannel, &nBChannel);

        pisdnci->nOldBChannel = nBChannel;
        pisdnci->nOldDChannel = nDChannel;

        SetFocus(GetDlgItem(hwndDlg, IDC_EDT_PhoneNumber));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDataFromListBox
//
//  Purpose:    On the MSN page, this takes the contents of the listbox and
//              saves it in memory.
//
//  Arguments:
//      iItem   [in]    Selected item in channel listbox
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID GetDataFromListBox(INT iItem, HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT             cItems;
    INT             iItemCur;
    PISDN_D_CHANNEL pisdndc;
    INT             cchText = 0;

    Assert(pisdnci);
    Assert(pisdnci->pDChannel);

    pisdndc = &(pisdnci->pDChannel[iItem]);

    Assert(pisdndc);

    cItems = SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETCOUNT, 0, 0);

    // First calculate length of multi-sz
    //
    for (iItemCur = 0; iItemCur < cItems; iItemCur++)
    {
        cchText += (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETTEXTLEN,
                                           iItemCur, 0) + 1;
    }

    // Include final Null
    cchText++;

    // Free the old one
    delete [] pisdndc->mszMsnNumbers;
    pisdndc->mszMsnNumbers = new WCHAR[cchText];

	if (pisdndc->mszMsnNumbers == NULL)
	{
		return;
	}

    WCHAR *     pchMsn = pisdndc->mszMsnNumbers;

    for (iItemCur = 0; iItemCur < cItems; iItemCur++)
    {
        AssertSz(pchMsn - pisdndc->mszMsnNumbers < cchText, "Bad buffer for "
                 "MSN string!");
        SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETTEXT, iItemCur,
                           (LPARAM)pchMsn);
        pchMsn += lstrlenW(pchMsn) + 1;
    }

    *pchMsn = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDataToListBox
//
//  Purpose:    Sets the contents of the MSN listbox based on the passed in
//              selected item from the channel listbox.
//
//  Arguments:
//      iItem   [in]    Selected item in channel listbox
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID SetDataToListBox(INT iItem, HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    PISDN_D_CHANNEL pisdndc;

    Assert(pisdnci);
    Assert(pisdnci->pDChannel);

    pisdndc = &(pisdnci->pDChannel[iItem]);

    Assert(pisdndc);

    SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_RESETCONTENT, 0, 0);

    WCHAR *     szMsn = pisdndc->mszMsnNumbers;

    while (*szMsn)
    {
        SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_ADDSTRING, 0,
                           (LPARAM)szMsn);
        szMsn += lstrlenW(szMsn) + 1;
    }

    // Select first item
    SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_SETCURSEL, 0, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageInitDialog
//
//  Purpose:    Called on initialization of the MSN dialog
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageInitDialog(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT     cItems;

    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, pisdnci);

    SetDataToListBox(0, hwndDlg, pisdnci);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_ADD), FALSE);
    SendDlgItemMessage(hwndDlg, IDC_EDT_MSN, EM_LIMITTEXT,
                       RAS_MaxPhoneNumber, 0);
    cItems = SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETCOUNT , 0, 0);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_REMOVE), !!cItems);

    SetFocus(GetDlgItem(hwndDlg, IDC_EDT_MSN));
    SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_EDT_MSN), GWLP_USERDATA, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageSelChange
//
//  Purpose:    Called when the listbox selection changes
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT iItemNew;
    INT iItemOld = GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_EDT_MSN),
                                    GWLP_USERDATA);

    iItemNew = SendDlgItemMessage(hwndDlg, IDC_LBX_Line, LB_GETCURSEL, 0, 0);

    if ((iItemNew != LB_ERR) && (iItemNew != iItemOld))
    {
        GetDataFromListBox(iItemOld, hwndDlg, pisdnci);
        SetDataToListBox(iItemNew, hwndDlg, pisdnci);
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_EDT_MSN), GWLP_USERDATA,
                         iItemNew);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageAdd
//
//  Purpose:    Called when the Add button is pressed
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageAdd(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    WCHAR   szItem[RAS_MaxPhoneNumber + 1];
    INT     iItem;

    GetDlgItemText(hwndDlg, IDC_EDT_MSN, szItem, celems(szItem));
    iItem = SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_ADDSTRING, 0,
                               (LPARAM)szItem);
    // Select the item after adding it
    SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_SETCURSEL, iItem, 0);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_REMOVE), TRUE);
    SetDlgItemText(hwndDlg, IDC_EDT_MSN, c_szEmpty);
    SetFocus(GetDlgItem(hwndDlg, IDC_EDT_MSN));
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageRemove
//
//  Purpose:    Called when the remove button is pressed
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageRemove(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT     iSel;

    iSel = SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETCURSEL, 0, 0);
    if (iSel != LB_ERR)
    {
        INT     cItems;

        cItems = SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_DELETESTRING,
                                    iSel, 0);
        if (cItems)
        {
            if (iSel == cItems)
            {
                iSel--;
            }

            SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_SETCURSEL, iSel, 0);
        }
        else
        {
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_REMOVE), FALSE);
            ::SetFocus(GetDlgItem(hwndDlg, IDC_EDT_MSN));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageEditSelChange
//
//  Purpose:    Called when the edit control contents change
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageEditSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    LRESULT     lres;

    // Make the old default button normal again
    lres = SendMessage(hwndDlg, DM_GETDEFID, 0, 0);
    if (HIWORD(lres) == DC_HASDEFID)
    {
        SendDlgItemMessage(hwndDlg, LOWORD(lres), BM_SETSTYLE,
                           BS_PUSHBUTTON, TRUE);
    }

    // Disable Add button based on whether text is present in the edit control
    //
    if (GetWindowTextLength(GetDlgItem(hwndDlg, IDC_EDT_MSN)))
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_ADD), TRUE);

        // Make this the default button as well
        SendMessage(hwndDlg, DM_SETDEFID, IDC_PSB_ADD, 0);
        SendDlgItemMessage(hwndDlg, IDC_PSB_ADD, BM_SETSTYLE,
                           BS_DEFPUSHBUTTON, TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_ADD), FALSE);

        // Make the OK button the default
        SendMessage(hwndDlg, DM_SETDEFID, IDOK, 0);
        SendDlgItemMessage(hwndDlg, IDOK, BM_SETSTYLE,
                           BS_DEFPUSHBUTTON, TRUE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsdnInfoPageProc
//
//  Purpose:    Dialog proc handler for info (second) page.
//
//  Arguments:
//      hwndDlg  [in]
//      uMessage [in]
//      wparam   [in]
//      lparam   [in]
//
//  Returns:
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
INT_PTR CALLBACK
IsdnInfoPageProc(HWND hwndDlg, UINT uMessage, WPARAM wparam, LPARAM lparam)
{
    LPNMHDR             lpnmhdr    = NULL;
    PISDN_CONFIG_INFO   pisdnci;
    PROPSHEETPAGE *     ppsp;

    // We have to do this in this fashion because it's very likely that we'll
    // have multiple instances of this dlg proc active at one time. This means
    // that we can't use the single pipipd as a static, as it would get
    // overwritten everytime we hit the WM_INITDIALOG on a new instance.
    //
    pisdnci = (PISDN_CONFIG_INFO)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch (uMessage)
    {
    case WM_INITDIALOG:
        PAGE_DATA * pPageData;

        ppsp = (PROPSHEETPAGE *) lparam;

        // Set the per-page data for this particular page. See the
        // comments above about why we use the per-page data.
        //
        AssertSz(!pisdnci, "This should not have been set yet");

        pPageData = (PAGE_DATA *)ppsp->lParam;
        pisdnci = pPageData->pisdnci;

        // Set this data in the window long for user-data
        //
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pisdnci);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pPageData->idd);

        Assert(pisdnci);

        // Call the init handler function
        //
        if (pisdnci->idd == IDW_ISDN_MSN)
        {
            OnMsnPageInitDialog(hwndDlg, pisdnci);
        }
        else
        {
            OnIsdnInfoPageInit(hwndDlg, pisdnci);
        }

        // Limit text in the edit controls
        switch (pisdnci->idd)
        {
        case IDW_ISDN_SPIDS:
            SendDlgItemMessage(hwndDlg, IDC_EDT_SPID, EM_LIMITTEXT,
                               c_cchMaxSpid, 0);
            SendDlgItemMessage(hwndDlg, IDC_EDT_PhoneNumber, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            break;

        case IDW_ISDN_MSN:
            SendDlgItemMessage(hwndDlg, IDC_EDT_MSN, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            break;

        case IDW_ISDN_JAPAN:
            SendDlgItemMessage(hwndDlg, IDC_EDT_SPID, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            SendDlgItemMessage(hwndDlg, IDC_EDT_PhoneNumber, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            break;

        case IDW_ISDN_EAZ:
            SendDlgItemMessage(hwndDlg, IDC_EDT_PhoneNumber, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            break;
        }

        break;

    case WM_NOTIFY:
        lpnmhdr = (NMHDR FAR *)lparam;
        // Handle all of the notification messages
        //
        switch (lpnmhdr->code)
        {
        case PSN_SETACTIVE:
            {
                LONG l = OnIsdnInfoPageSetActive(hwndDlg, pisdnci);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, l);
                return TRUE;
            }
        case PSN_APPLY:
            OnIsdnInfoPageApply(hwndDlg, pisdnci);
            break;
        case PSN_WIZBACK:
            OnIsdnInfoPageWizBack(hwndDlg, pisdnci);
            break;
        case PSN_WIZNEXT:
            OnIsdnInfoPageWizNext(hwndDlg, pisdnci);
            break;
        default:
            break;
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDC_PSB_ADD:
            OnMsnPageAdd(hwndDlg, pisdnci);
            break;

        case IDC_PSB_REMOVE:
            OnMsnPageRemove(hwndDlg, pisdnci);
            break;

        case IDC_EDT_MSN:
            if (HIWORD(wparam) == EN_CHANGE)
            {
                OnMsnPageEditSelChange(hwndDlg, pisdnci);
            }
            break;

        case IDC_LBX_Variant:
        case IDC_LBX_Line:
            if (HIWORD(wparam) == LBN_SELCHANGE)
            {
                if (pisdnci->idd == IDW_ISDN_MSN)
                {
                    OnMsnPageSelChange(hwndDlg, pisdnci);
                }
                else
                {
                    OnIsdnInfoPageSelChange(hwndDlg, pisdnci);
                }
            }

            break;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   RetrieveIsdnChannelInfo
//
//  Purpose:    Stores the state of the edit controls into the in-memory
//              state for the currently selected D-channel and B-channel.
//
//  Arguments:
//      hwndDlg         [in]    Handle to dialog.
//      iSpidControl    [in]    Item ID of "spid" edit control
//      iPhoneControl   [in]    Item ID of "Phone number" edit control
//      iChannelLB      [in]    Item ID of "Channel" or "Terminal" listbox
//      pisdnci         [in]    Configuration information as read from the
//                              registry
//      dwDChannel      [in]    Currently selected D-channel in listbox
//      iCurrentChannel [in]    Currently selected B-channel in listbox
//
//  Returns:
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID RetrieveIsdnChannelInfo(HWND hwndDlg, INT iSpidControl,
                             INT iPhoneControl, INT iChannelLB,
                             PISDN_CONFIG_INFO pisdnci, DWORD dwDChannel,
                             INT iCurrentChannel)
{
    DWORD   dwItemCount     = 0;
    DWORD   dwItemLoop      = 0;
    INT     iCharsReturned  = 0;

    WCHAR   szBChannelName[c_iMaxChannelName+1];

    Assert(hwndDlg);
    Assert(iSpidControl);
    Assert(iPhoneControl);
    Assert(iChannelLB);
    Assert(pisdnci);
    Assert(pisdnci->pDChannel);
    Assert(pisdnci->dwNumDChannels >= dwDChannel);

    // Make sure that the current selection has been propogated back to the
    // channel data
    //
    SetModifiedIsdnChannelInfo(hwndDlg, iSpidControl, iPhoneControl,
            iChannelLB, iCurrentChannel, pisdnci);

    // Get the item from from the listbox
    //
    dwItemCount = SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETCOUNT, 0, 0L);
    if (dwItemCount != pisdnci->pDChannel[dwDChannel].dwNumBChannels)
    {
        AssertSz(FALSE, "Count of items in LB != number of B Channels");
        goto Exit;
    }

    // Loop through the items and get the channel names. Convert those to channel
    // numbers, and propogate the data back to the appropriate B Channel in the
    // config info.
    //
    for (dwItemLoop = 0; dwItemLoop < dwItemCount; dwItemLoop++)
    {
        DWORD           dwChannelNumber = 0;
        PISDN_B_CHANNEL pisdnbc         = NULL;
        INT_PTR         iItemData       = 0;

        // Get the length of the channel name.
        //
        iCharsReturned = SendDlgItemMessage(hwndDlg, iChannelLB,
                LB_GETTEXTLEN, dwItemLoop, 0L);

        AssertSz(iCharsReturned != LB_ERR,
                 "No reason that we should have gotten a failure for LB_GETTEXTLEN "
                 "on the Channel LB");

        if (iCharsReturned > c_iMaxChannelName)
        {
            AssertSz(iCharsReturned <= c_iMaxChannelName, "Channel name too long for buffer");
            goto Exit;
        }

        // Get the channel name.
        //
        iCharsReturned = SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETTEXT,
                dwItemLoop, (LPARAM) szBChannelName);
        AssertSz(iCharsReturned != LB_ERR,
                 "Failed on LB_GETTEXT on the Channel LB. Strange");

        // Convert to a channel num from display # (using radix 10), then subtract 1 (base 0)
        //
        dwChannelNumber = wcstoul(szBChannelName, NULL, 10) - 1;
        if (dwChannelNumber >= pisdnci->pDChannel[dwDChannel].dwNumBChannels)
        {
            AssertSz(FALSE, "dwChannelNumber out of the range of valid B Channels");
            goto Exit;
        }

        // Get the item data for that particular channel. This will be the stored SPID and
        // phone numbers (a PISDN_B_CHANNEL).
        //
        iItemData = SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETITEMDATA,
                                       dwItemLoop, (LPARAM)0);
        AssertSz(iItemData != (INT_PTR)LB_ERR, "LB_ERR returned from LB_GETITEMDATA on Channel LB. Bogus.");

        // It's valid data, so cast it to the struct form.
        //
        pisdnbc = reinterpret_cast<PISDN_B_CHANNEL>(iItemData);

        // Copy the phone number and spid data between the saved list box data and the
        // full config info
        //
        lstrcpyW(pisdnci->pDChannel[dwDChannel].pBChannel[dwChannelNumber].szSpid,
                pisdnbc->szSpid);
        lstrcpyW(pisdnci->pDChannel[dwDChannel].pBChannel[dwChannelNumber].szPhoneNumber,
                pisdnbc->szPhoneNumber);
    }

Exit:
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetCurrentIsdnChannelSelection
//
//  Purpose:    Retrives the information from the in-memory representation of
//              the current D-channel and B-channel information and sets
//              the edit controls with this information.
//
//  Arguments:
//      hwndDlg         [in]    Handle to dialog.
//      iSpidControl    [in]    Item ID of "spid" edit control
//      iPhoneControl   [in]    Item ID of "Phone number" edit control
//      iChannelLB      [in]    Item ID of "Channel" or "Terminal" listbox
//      pisdnci         [in]    Configuration information as read from the
//                              registry
//      dwDChannel      [in]    Currently selected D-channel in listbox
//      pnBChannel      [out]   Returns currently selected B-channel in list
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID SetCurrentIsdnChannelSelection(HWND hwndDlg, INT iSpidControl,
                                    INT iPhoneControl, INT iChannelLB,
                                    PISDN_CONFIG_INFO pisdnci,
                                    DWORD dwDChannel, INT *pnBChannel)
{
    INT             iIndex      = 0;
    INT_PTR         iItemData   = 0;
    PISDN_B_CHANNEL pisdnbc     = NULL;

    // Get the current selection
    //
    iIndex = SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETCURSEL, 0, 0L);
    AssertSz(iIndex != LB_ERR,
            "Should have been able to get a selection in SetCurrentIsdnChannelSelection");

    *pnBChannel = iIndex;

    // Get the item data for the current selection
    //
    iItemData = SendDlgItemMessage(hwndDlg, iChannelLB,
                                   LB_GETITEMDATA, iIndex, (LPARAM)0);
    AssertSz(iItemData != (INT_PTR)LB_ERR, "LB_ERR returned from LB_GETITEMDATA on "
             "Channel LB. Bogus.");

    // It's valid data, so cast it to the struct form.
    // Note: Use the cost new casting operators.
    //
    pisdnbc = (PISDN_B_CHANNEL) iItemData;

    // Populate the edit controls with the newly selected data.
    //
    SetDataToEditControls(hwndDlg, iPhoneControl, iSpidControl, pisdnci,
                          pisdnbc);
}

//+---------------------------------------------------------------------------
//
//  Function:   PopulateIsdnChannels
//
//  Purpose:    Fills in the channel listboxes and edit controls for the
//              second page of the wizard.
//
//  Arguments:
//      hwndDlg       [in]  Handle to dialog
//      iSpidControl  [in]  Item ID of "spid" edit control
//      iPhoneControl [in]  Item ID of "Phone number" edit control
//      iLineLB       [in]  Item ID of "Line" listbox
//      iChannelLB    [in]  Item ID of "Channel" or "Terminal" listbox
//      pisdnci       [in]  Configuration information as read from the
//                          registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID PopulateIsdnChannels(HWND hwndDlg, INT iSpidControl, INT iPhoneControl,
                          INT iLineLB, INT iChannelLB,
                          PISDN_CONFIG_INFO pisdnci)
{
    DWORD           iBChannel = 0;
    PISDN_D_CHANNEL pisdndc = NULL;
    DWORD           iDChannel;
    WCHAR           szChannelName[c_iMaxChannelName + 1];

    Assert(hwndDlg);
    Assert(iSpidControl);
    Assert(iPhoneControl);
    Assert(iLineLB);
    Assert(iChannelLB);
    Assert(pisdnci);

    // Set the maximum lengths of the SPID and Phone number controls
    //
    SendDlgItemMessage(hwndDlg, iSpidControl, EM_SETLIMITTEXT,
                       RAS_MaxPhoneNumber, 0L);
    SendDlgItemMessage(hwndDlg, iPhoneControl, EM_SETLIMITTEXT,
                       RAS_MaxPhoneNumber, 0L);

    SendDlgItemMessage(hwndDlg, iLineLB, LB_RESETCONTENT, 0, 0);

    // Loop thru the D channels (lines)
    for (iDChannel = 0; iDChannel < pisdnci->dwNumDChannels; iDChannel++)
    {
        // Create the string for the channel display. The user will see them
        // enumerated from 1, even though in memory and in the registry, they are
        // enumerated from 0.
        //
        wsprintfW(szChannelName, L"%d", iDChannel + 1);

        // Insert the text
        //
        SendDlgItemMessage(hwndDlg, iLineLB, LB_ADDSTRING, 0,
                           (LPARAM) szChannelName);
    }

    // Get the pointer to the first D Channel's data
    //
    pisdndc = &(pisdnci->pDChannel[0]);

    // Loop through the B channels, and fill the listbox with the channel numbers.
    // Also, fill the channel information for the first B Channel
    //
    SendDlgItemMessage(hwndDlg, iChannelLB, LB_RESETCONTENT, 0, 0);
    for (iBChannel = 0; iBChannel < pisdndc->dwNumBChannels; iBChannel++)
    {
        INT             iInsertionIndex = 0;
        PISDN_B_CHANNEL pisdnbc;

        // Create the string for the channel display. The user will see them
        // enumerated from 1, even though in memory and in the registry, they are
        // enumerated from 0.
        //
        wsprintfW(szChannelName, L"%d", iBChannel + 1);

        // Insert the text
        //
        iInsertionIndex = SendDlgItemMessage(hwndDlg, iChannelLB,
                                             LB_ADDSTRING, 0,
                                             (LPARAM) szChannelName);
        if (iInsertionIndex == LB_ERR)
        {
            AssertSz(FALSE, "Unable to add channel name to listbox in "
                     "PopulateIsdnChannels");
            goto Exit;
        }

        pisdnbc = &pisdndc->pBChannel[iBChannel];

        // Init the item data with the first D channel's information
        //
        SendDlgItemMessage(hwndDlg, iChannelLB, LB_SETITEMDATA,
                           iInsertionIndex, (LPARAM) pisdnbc);

        // If we're on the 0'th member, then we want to fill in the edit controls
        // for that particular channel,
        //
        if (iBChannel == 0)
        {
            SetDataToEditControls(hwndDlg, iPhoneControl, iSpidControl,
                                  pisdnci, pisdnbc);
        }
    }

    // Select first item in each list box
    //
    SendDlgItemMessage(hwndDlg, iChannelLB, LB_SETCURSEL, 0, 0L);
    SendDlgItemMessage(hwndDlg, iLineLB, LB_SETCURSEL, 0, 0L);

Exit:
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDataToEditControls
//
//  Purpose:    Sets the in-memory state information to the page's edit
//              controls.
//
//  Arguments:
//      hwndDlg       [in]  Handle to dialog
//      iSpidControl  [in]  Item ID of "spid" edit control
//      iPhoneControl [in]  Item ID of "Phone number" edit control
//      pisdnci       [in]  Configuration information as read from the
//                          registry
//      pisdnbc       [in]  Currently selected B-channel's data
//
//  Returns:    Nothing
//
//  Author:     danielwe   16 Mar 1998
//
//  Notes:
//
VOID SetDataToEditControls(HWND hwndDlg, INT iPhoneControl, INT iSpidControl,
                           PISDN_CONFIG_INFO pisdnci, PISDN_B_CHANNEL pisdnbc)
{
    switch (pisdnci->idd)
    {
    case IDW_ISDN_SPIDS:
    case IDD_ISDN_SPIDS:
        SetDlgItemText(hwndDlg, iSpidControl, pisdnbc->szSpid);
        SetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber);
        break;
    case IDW_ISDN_EAZ:
    case IDD_ISDN_EAZ:
        SetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber);
        break;
    case IDW_ISDN_JAPAN:
    case IDD_ISDN_JAPAN:
        SetDlgItemText(hwndDlg, iSpidControl, pisdnbc->szSubaddress);
        SetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber);
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDataFromEditControls
//
//  Purpose:    Retrieves contents of the edit controls into the in-memory
//              state for the given B-channel.
//
//  Arguments:
//      hwndDlg       [in]  Handle to dialog
//      iSpidControl  [in]  Item ID of "spid" edit control
//      iPhoneControl [in]  Item ID of "Phone number" edit control
//      pisdnci       [in]  Configuration information as read from the
//                          registry
//      pisdnbc       [in]  Currently selected B-channel's data
//
//  Returns:    Nothing
//
//  Author:     danielwe   16 Mar 1998
//
//  Notes:
//
VOID GetDataFromEditControls(HWND hwndDlg, INT iPhoneControl, INT iSpidControl,
                             PISDN_CONFIG_INFO pisdnci,
                             PISDN_B_CHANNEL pisdnbc)
{
    switch (pisdnci->idd)
    {
    case IDW_ISDN_SPIDS:
    case IDD_ISDN_SPIDS:
        GetDlgItemText(hwndDlg, iSpidControl, pisdnbc->szSpid,
                       celems(pisdnbc->szSpid));
        GetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber,
                       celems(pisdnbc->szPhoneNumber));
        break;
    case IDW_ISDN_EAZ:
    case IDD_ISDN_EAZ:
        GetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber,
                       celems(pisdnbc->szPhoneNumber));
        break;
    case IDW_ISDN_JAPAN:
    case IDD_ISDN_JAPAN:
        GetDlgItemText(hwndDlg, iSpidControl, pisdnbc->szSubaddress,
                       celems(pisdnbc->szSubaddress));
        GetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber,
                       celems(pisdnbc->szPhoneNumber));
        break;
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   SetModifiedIsdnChannelInfo
//
//  Purpose:    Stores the contents of the
//
//  Arguments:
//      hwndDlg         [in]    Handle to dialog.
//      iSpidControl    [in]    Item ID of "spid" edit control
//      iPhoneControl   [in]    Item ID of "Phone number" edit control
//      iChannelLB      [in]    Item ID of "Channel" or "Terminal" listbox
//      iCurrentChannel [in]    Currently selected B-channel
//      pisdnci         [in]    ISDN config info
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID SetModifiedIsdnChannelInfo(HWND hwndDlg, INT iSpidControl,
                                INT iPhoneControl, INT iChannelLB,
                                INT iCurrentChannel,
                                PISDN_CONFIG_INFO pisdnci)
{
    INT_PTR         iSelectionData      = 0;
    PISDN_B_CHANNEL pisdnbc             = NULL;

    // Get the item data from the current selection
    //
    iSelectionData = SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETITEMDATA,
                                        iCurrentChannel, (LPARAM)0);
    AssertSz(iSelectionData != (INT_PTR)LB_ERR,
             "We should not have failed to get the item data from the Channel LB");

    // Convert the item data to the real structure
    //
    pisdnbc = (PISDN_B_CHANNEL) iSelectionData;

    AssertSz(pisdnbc,
            "Someone forgot to set the item data. Bad someone!...Bad!");

    GetDataFromEditControls(hwndDlg, iPhoneControl, iSpidControl, pisdnci,
                            pisdnbc);
}

//
// Helper functions
//

//+---------------------------------------------------------------------------
//
//  Function:   DwGetCurrentCountryCode
//
//  Purpose:    Returns current country code for the system
//
//  Arguments:
//      (none)
//
//  Returns:    Country code from winnls.h (CTRY_*)
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
DWORD DwGetCurrentCountryCode()
{
    WCHAR   szCountry[10];

    GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_ICOUNTRY, szCountry,
                  celems(szCountry));

    return wcstoul(szCountry, NULL, 10);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsDefaultForLocale
//
//  Purpose:    Determines if the given switch type is the default switch
//              type for the given locale.
//
//  Arguments:
//      nCountry     [in]   Country code from winnls.h (CTRY_*)
//      dwSwitchType [in]   Switch type mask ISDN_SWITCH_* (from above)
//
//  Returns:    TRUE if switch type is the default, FALSE if not
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
BOOL FIsDefaultForLocale(DWORD nCountry, DWORD dwSwitchType)
{
    switch (nCountry)
    {
    case CTRY_UNITED_STATES:
        return ((dwSwitchType == ISDN_SWITCH_NI1) ||
                (dwSwitchType == ISDN_SWITCH_NI2));

    case CTRY_JAPAN:
        return (dwSwitchType == ISDN_SWITCH_INS64);

    case CTRY_TAIWAN:
    case CTRY_PRCHINA:
    case CTRY_NEW_ZEALAND:
    case CTRY_AUSTRALIA:
    case CTRY_ARMENIA:
    case CTRY_AUSTRIA:
    case CTRY_BELGIUM:
    case CTRY_BULGARIA:
    case CTRY_CROATIA:
    case CTRY_CZECH:
    case CTRY_DENMARK:
    case CTRY_FINLAND:
    case CTRY_FRANCE:
    case CTRY_GERMANY:
    case CTRY_GREECE:
    case CTRY_HONG_KONG:
    case CTRY_HUNGARY:
    case CTRY_ICELAND:
    case CTRY_IRELAND:
    case CTRY_ITALY:
    case CTRY_LITHUANIA:
    case CTRY_LUXEMBOURG:
    case CTRY_MACEDONIA:
    case CTRY_NETHERLANDS:
    case CTRY_NORWAY:
    case CTRY_ROMANIA:
    case CTRY_SERBIA:
    case CTRY_SLOVAK:
    case CTRY_SLOVENIA:
    case CTRY_SPAIN:
    case CTRY_SWEDEN:
    case CTRY_SWITZERLAND:
    case CTRY_UNITED_KINGDOM:
        return (dwSwitchType == ISDN_SWITCH_DSS1);

    default:
        return FALSE;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DestroyWizardData
//
//  Purpose:    Callback for the all wizard pages.  Cleans up when page is
//              being destroyed.
//
//  Arguments:
//      hwnd    [in]   See win32 SDK for property page callback
//      uMsg    [in]
//      ppsp    [in]
//
//  Returns:    1 (See win32 sdk)
//
//  Author:     BillBe   22 Apr 1998
//
//  Notes:
//
UINT CALLBACK
DestroyWizardData(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    if (PSPCB_RELEASE == uMsg)
    {
        PAGE_DATA *     pPageData;

        pPageData = (PAGE_DATA *)ppsp->lParam;

        if (pPageData->idd == IDW_ISDN_SWITCH_TYPE)
        {
            PISDN_CONFIG_INFO   pisdnci;

            // If this is the switch type dialog being destroyed, we'll
            // destroy the ISDN info. Since it's shared among all pages,
            // we should only do this for one of the pages.
            //
            pisdnci = pPageData->pisdnci;
            FreeIsdnPropertiesInfo(pisdnci);
        }

        delete pPageData;
    }

    return 1;
}

static const CONTEXTIDMAP c_adwContextIdMap[] =
{
    { IDC_LBX_Line,           2003230,  2003230 },
    { IDC_LBX_Variant,        2003240,  2003240 },
    { IDC_EDT_PhoneNumber,    2003250,  2003255 },
    { IDC_EDT_SPID,           2003265,  2003260 },
    { IDC_EDT_MSN,            2003270,  2003270 },
    { IDC_PSB_ADD,            2003280,  2003280 },
    { IDC_LBX_MSN,            2003290,  2003290 },
    { IDC_PSB_REMOVE,         2003300,  2003300 },
    { IDC_CMB_SwitchType,     2003310,  2003310 },
    { IDC_PSB_Configure,      2003320,  2003320 },
};

static const DWORD c_cdwContextIdMap = celems(c_adwContextIdMap);

//+---------------------------------------------------------------------------
//
//  Function:   DwContextIdFromIdc
//
//  Purpose:    Converts the given control ID to a context help ID
//
//  Arguments:
//      idControl [in]  Control ID to convert
//
//  Returns:    Context help ID for that control (mapping comes from help
//              authors)
//
//  Author:     danielwe   27 May 1998
//
//  Notes:
//
DWORD DwContextIdFromIdc(PISDN_CONFIG_INFO pisdnci, INT idControl)
{
    DWORD   idw;

    for (idw = 0; idw < c_cdwContextIdMap; idw++)
    {
        if (idControl == c_adwContextIdMap[idw].idControl)
        {
            if (pisdnci->idd == IDD_ISDN_JAPAN)
            {
                return c_adwContextIdMap[idw].dwContextIdJapan;
            }
            else
            {
                return c_adwContextIdMap[idw].dwContextId;
            }
        }
    }

    // Not found, just return 0
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnHelpGeneric
//
//  Purpose:    Handles help generically
//
//  Arguments:
//      hwnd   [in]     HWND of parent window
//      lParam [in]     lParam of the WM_HELP message
//
//  Returns:    Nothing
//
//  Author:     danielwe   27 May 1998
//
//  Notes:
//
VOID OnHelpGeneric(PISDN_CONFIG_INFO pisdnci, HWND hwnd, LPARAM lParam)
{
    LPHELPINFO  lphi;

    static const WCHAR c_szIsdnHelpFile[] = L"devmgr.hlp";

    lphi = reinterpret_cast<LPHELPINFO>(lParam);

    Assert(lphi);

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
        if (lphi->iCtrlId != IDC_STATIC)
        {
            WinHelp(hwnd, c_szIsdnHelpFile, HELP_CONTEXTPOPUP,
                    DwContextIdFromIdc(pisdnci, lphi->iCtrlId));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdnwiz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N W I Z . C P P
//
//  Contents:   Wizard pages and helper functions for the ISDN Wizard
//
//  Notes:
//
//  Author:     jeffspr   15 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "isdncfg.h"
#include "resource.h"
#include "isdnshts.h"
#include "isdncfg.h"
#include "isdnwiz.h"
#include "ncsetup.h"

//+---------------------------------------------------------------------------
//
//  Function:   AddWizardPage
//
//  Purpose:    Adds a wizard page to the hardware wizard's new device
//                  wizard structure
//
//  Arguments:
//      ppsp  [in]    PropSheetPage structure of page to add
//      pndwd [inout] New device wizard structure to add pages to
//
//  Returns:    None
//
//  Author:     BillBe  24 Apr 1998
//
//  Notes:
//
void inline
AddWizardPage(PROPSHEETPAGE* ppsp, PSP_NEWDEVICEWIZARD_DATA pndwd)
{
    // Don't add pages to the new deice wizard if there is no more room
    //
    if (pndwd->NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES)
    {
        // Add the handle to the array
        pndwd->DynamicPages[pndwd->NumDynamicPages] =
                CreatePropertySheetPage(ppsp);

        // If we were successful, increment the count of pages
        //
        if (pndwd->DynamicPages[pndwd->NumDynamicPages])
        {
            pndwd->NumDynamicPages++;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FillInIsdnWizardPropertyPage
//
//  Purpose:    Fills in the given PROPSHEETPAGE structure
//
//  Arguments:
//      psp        []   PropSheetPage structure to fill
//      iDlgID     []   DialogID to use.
//      pszTitle   []   Title of the prop sheet page
//      pfnDlgProc []   Dialog Proc to use.
//      pPageData  []   Pointer to structure for the individual page proc
//
//  Returns:    None
//
//  Author:     jeffspr   15 Jun 1997
//
//  Notes:
//
VOID FillInIsdnWizardPropertyPage(  HINSTANCE          hInst,
                                    PROPSHEETPAGE *    psp,
                                    INT                iDlgID,
                                    PCWSTR             pszTitle,
                                    DLGPROC            pfnDlgProc,
                                    PCWSTR             pszHeaderTitle,
                                    PCWSTR             pszHeaderSubTitle,
                                    LPVOID             pPageData)
{
    // Initialize all of the psp parameters, including the ones that
    // we're not going to use.
    psp->dwSize             = sizeof(PROPSHEETPAGE);
    psp->dwFlags            = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE |
                              PSP_USETITLE;
    psp->hInstance          = hInst;
    psp->pszTemplate        = MAKEINTRESOURCE(iDlgID);
    psp->pszIcon            = NULL;
    psp->pfnDlgProc         = pfnDlgProc;
    psp->pszTitle           = (PWSTR) pszTitle;
    psp->lParam             = (LPARAM) pPageData;
    psp->pszHeaderTitle     = (PWSTR) pszHeaderTitle;
    psp->pszHeaderSubTitle  = (PWSTR) pszHeaderSubTitle;

    // Unused data
    //
    psp->pfnCallback        = NULL;
    psp->pcRefParent        = NULL;
}

struct WIZ_PAGE_INFO
{
    UINT        uiResId;
    UINT        idsPageTitle;
    UINT        idsPageDesc;
    DLGPROC     pfnDlgProc;
};

static const WIZ_PAGE_INFO  c_aPages[] =
{
    {IDW_ISDN_SWITCH_TYPE,
        IDS_ISDN_SWITCH_TYPE_TITLE,
        IDS_ISDN_SWITCH_TYPE_SUBTITLE,
        IsdnSwitchTypeProc},
    {IDW_ISDN_SPIDS,
        IDS_ISDN_SPIDS_TITLE,
        IDS_ISDN_SPIDS_SUBTITLE,
        IsdnInfoPageProc},
    {IDW_ISDN_JAPAN,
        IDS_ISDN_JAPAN_TITLE,
        IDS_ISDN_JAPAN_SUBTITLE,
        IsdnInfoPageProc},
    {IDW_ISDN_EAZ,
        IDS_ISDN_EAZ_TITLE,
        IDS_ISDN_EAZ_SUBTITLE,
        IsdnInfoPageProc},
    {IDW_ISDN_MSN,
        IDS_ISDN_MSN_TITLE,
        IDS_ISDN_MSN_SUBTITLE,
        IsdnInfoPageProc},
};

static const INT c_cPages = celems(c_aPages);

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateIsdnWizardPages
//
//  Purpose:    Creates the various pages for the ISDN wizard
//
//  Arguments:
//      hwndParent [in]     Parent window
//      pisdnci    [in]     Configuration information as read from the
//                          registry
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
HRESULT HrAddIsdnWizardPagesToDevice(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                     PISDN_CONFIG_INFO pisdnci)
{
    HRESULT             hr = S_OK;
    PROPSHEETPAGE       psp = {0};
    HINSTANCE           hInst = _Module.GetResourceInstance();
    INT                 iPage;

    AssertSz(pisdnci, "HrCreateIsdnWizardPages - the CONFIG_INFO struct is"
             " NULL");
    AssertSz(pisdnci->dwWanEndpoints, "No WanEndpoints? What does this adapter"
             " DO, anyway?");
    AssertSz(pisdnci->dwNumDChannels, "No D Channels. No Shoes. No Service");
    AssertSz(pisdnci->dwSwitchTypes, "Switch types was NULL. We need a list"
             ", eh?");


    SP_NEWDEVICEWIZARD_DATA ndwd;

    hr = HrSetupDiGetFixedSizeClassInstallParams(hdi, pdeid,
            reinterpret_cast<PSP_CLASSINSTALL_HEADER>(&ndwd), sizeof(ndwd));

    if (SUCCEEDED(hr))
    {
        PWSTR       pszTitle = NULL;
        PWSTR       pszDesc = NULL;

        hr = HrSetupDiGetDeviceName(hdi, pdeid, &pszDesc);
        if (SUCCEEDED(hr))
        {
            DwFormatStringWithLocalAlloc(SzLoadIds(IDS_ISDN_WIZARD_TITLE),
                                         &pszTitle, pszDesc);

            for (iPage = 0; iPage < c_cPages; iPage++)
            {
                PAGE_DATA *     pPageData;

                pPageData = new PAGE_DATA;

				if (pPageData == NULL)
				{
					return(ERROR_NOT_ENOUGH_MEMORY);
				}

                pPageData->pisdnci = pisdnci;
                pPageData->idd = c_aPages[iPage].uiResId;

                // Fill in the propsheet page data
                //
                FillInIsdnWizardPropertyPage(hInst, &psp,
                                             c_aPages[iPage].uiResId,
                                             pszTitle,
                                             c_aPages[iPage].pfnDlgProc,
                                             SzLoadIds(c_aPages[iPage].idsPageTitle),
                                             SzLoadIds(c_aPages[iPage].idsPageDesc),
                                             pPageData);

                // The last page gets the job of cleaning up
                if ((c_cPages - 1) == iPage)
                {
                    psp.dwFlags |= PSP_USECALLBACK;
                    psp.pfnCallback = DestroyWizardData;
                }

                AddWizardPage(&psp, &ndwd);
            }

            LocalFree(pszTitle);
            MemFree(pszDesc);
        }

        hr = HrSetupDiSetClassInstallParams(hdi, pdeid,
                reinterpret_cast<PSP_CLASSINSTALL_HEADER>(&ndwd),
                sizeof(ndwd));
    }

    TraceError("HrAddIsdnWizardPagesToDevice", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdnshts.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N S H T S . H
//
//  Contents:   Prototypes for the ISDN property sheets and wizard pages
//              dialog procs
//
//  Notes:
//
//  Author:     jeffspr   15 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _ISDNSHTS_H_
#define _ISDNSHTS_H_

//---[ Prototypes ]-----------------------------------------------------------

VOID SetSwitchType(HWND hwndDlg, INT iItemSwitchType, DWORD dwSwitchType);
DWORD DwGetSwitchType(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci,
                      INT iDialogItem);
VOID PopulateIsdnSwitchTypes(HWND hwndDlg, INT iDialogItem,
                             PISDN_CONFIG_INFO pisdnci);
DWORD DwGetCurrentCountryCode(VOID);
BOOL FIsDefaultForLocale(DWORD nCountry, DWORD dwSwitchType);
VOID PopulateIsdnChannels(HWND hwndDlg, INT iSpidControl, INT iPhoneControl,
                          INT iLineLB, INT iChannelLB,
                          PISDN_CONFIG_INFO pisdnci);
LONG OnIsdnInfoPageSetActive(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnSwitchTypeInit(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageInit(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID SetModifiedIsdnChannelInfo(HWND hwndDlg, INT iSpidControl,
                                INT iPhoneControl, INT iChannelLB,
                                INT iCurrentChannel,
                                PISDN_CONFIG_INFO pisdnci);
VOID RetrieveIsdnChannelInfo(HWND hwndDlg, INT iSpidControl, INT iPhoneControl,
                             INT iChannelLB, PISDN_CONFIG_INFO pisdnci,
                             DWORD dwDChannel, INT iCurrentChannel);
VOID OnIsdnInfoPageApply(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageWizNext(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageWizFinish(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageWizBack(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageTransition(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID SetCurrentIsdnChannelSelection(HWND hwndDlg, INT iSpidControl,
                                    INT iPhoneControl, INT iChannelLB,
                                    PISDN_CONFIG_INFO pisdnci,
                                    DWORD dwDChannel, INT * nBChannel);
VOID SetDataToEditControls(HWND hwndDlg, INT iPhoneControl, INT iSpidControl,
                           PISDN_CONFIG_INFO pisdnci, PISDN_B_CHANNEL pisdnbc);
VOID GetDataFromEditControls(HWND hwndDlg, INT iPhoneControl, INT iSpidControl,
                             PISDN_CONFIG_INFO pisdnci,
                             PISDN_B_CHANNEL pisdnbc);
LONG OnIsdnSwitchTypeSetActive(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnSwitchTypeWizNext(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);

VOID OnIsdnInfoPageSelChange(HWND hwndDlg, PISDN_CONFIG_INFO   pisdnci);

INT_PTR CALLBACK
IsdnInfoPageProc(HWND hDlg, UINT uMessage, WPARAM wparam, LPARAM lparam);

INT_PTR CALLBACK
IsdnSwitchTypeProc(HWND hwndDlg, UINT uMessage, WPARAM wparam, LPARAM lparam);

VOID OnMsnPageSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID SetDataToListBox(INT iItem, HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID GetDataFromListBox(INT iItem, HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnMsnPageAdd(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnMsnPageRemove(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnMsnPageEditSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnMsnPageInitDialog(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);

VOID CheckShowPagesFlag(PISDN_CONFIG_INFO pisdnci);
UINT CALLBACK DestroyWizardData(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

struct PAGE_DATA
{
    PISDN_CONFIG_INFO       pisdnci;
    UINT                    idd;
};

const INT c_cchMaxSpid = 20;     // Maximum length of SPID
const INT c_cchMaxOther = 30;    // Maximum length of other fields

#endif // _ISDNSHTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\isdnwiz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N W I Z . H
//
//  Contents:   Prototypes for the ISDN Wizard functionality
//
//  Notes:
//
//  Author:     jeffspr   15 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _ISDNWIZ_H_
#define _ISDNWIZ_H_

HRESULT HrAddIsdnWizardPagesToDevice(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                     PISDN_CONFIG_INFO pisdnci );

#endif  // _ISDNWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\isdncfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by isdncfg.rc
//
#define IDS_ISDN_WIZARD_TITLE           1
#define IDS_ISDN_SPIDS_TITLE            2
#define IDS_ISDN_SPIDS_SUBTITLE         3
#define IDS_ISDN_JAPAN_TITLE            4
#define IDS_ISDN_JAPAN_SUBTITLE         5
#define IDS_ISDN_MSN_TITLE              6
#define IDS_ISDN_MSN_SUBTITLE           7
#define IDS_ISDN_EAZ_TITLE              8
#define IDS_ISDN_EAZ_SUBTITLE           9
#define IDS_ISDN_SWITCH_TYPE_TITLE      10
#define IDS_ISDN_SWITCH_TYPE_SUBTITLE   11
#define IDS_ISDN_SWITCH_AUTO            12
#define IDS_ISDN_SWITCH_ATT             13
#define IDS_ISDN_SWITCH_NI1             14
#define IDS_ISDN_SWITCH_NTI             15
#define IDS_ISDN_SWITCH_INS64           16
#define IDS_ISDN_SWITCH_1TR6            17
#define IDS_ISDN_SWITCH_VN3             18
#define IDS_ISDN_SWITCH_DSS1            19
#define IDS_ISDN_SWITCH_AUS             20
#define IDS_ISDN_SWITCH_BEL             21
#define IDS_ISDN_SWITCH_UNKNOWN         22
#define IDS_ISDN_SWITCH_NI2             23
#define IDS_ISDN_SWITCH_VN4             24
#define IDS_ISDN_SWITCH_SWE             25
#define IDS_ISDN_SWITCH_ITA             26
#define IDS_ISDN_SWITCH_TWN             27
#define IDS_ISDN_WHATS_THIS             28
#define IDC_CMB_SwitchType              1000
#define IDC_EDIT1                       1001
#define IDC_EDT_MSN                     1001
#define IDC_BUTTON1                     1002
#define IDC_PSB_ADD                     1002
#define IDC_BUTTON2                     1003
#define IDC_PSB_REMOVE                  1003
#define IDC_LBX_Line                    1005
#define IDC_EDT_PhoneNumber             1008
#define IDC_LBX_Variant                 1010
#define IDC_PSB_Configure               1011
#define IDC_LBX_MSN                     1014
#define IDD_ISDN_SPIDS                  1407
#define IDC_LBX_CHANNEL                 14101
#define IDC_LBX_CHANNEL2                14102
#define IDC_EDT_SPID                    14103
#define IDC_EDT_PHONE_NUMBER            14105
#define IDC_EDT_PHONE_NUMBER2           14106
#define IDC_EDT_SubAddress              14106
#define IDW_ISDN_SPIDS                  14112
#define IDW_ISDN_JAPAN                  14113
#define IDW_ISDN_MSN                    14114
#define IDW_ISDN_EAZ                    14115
#define IDP_ISDN_SWITCH_TYPE            14116
#define IDD_ISDN_EAZ                    14117
#define IDD_ISDN_JAPAN                  14118
#define IDD_ISDN_MSN                    14119
#define IDW_ISDN_SWITCH_TYPE            14120
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\msclidlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M S C L I D L G . C P P
//
//  Contents:   Dialog box handling for the MSCLient object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "msclidlg.h"

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrSetupPropSheets
//
//  Purpose:    Inits the prop sheet page objects and creates the pages to be
//              returned to the installer object.
//
//  Arguments:
//      pahpsp [out]    Array of handles to property sheet pages.
//      cPages [in]     Number of pages to create.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   28 Feb 1997
//
//  Notes:
//
HRESULT CMSClient::HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages)
{
    HRESULT         hr = S_OK;
    HPROPSHEETPAGE *ahpsp = NULL;

    Assert(pahpsp);

    *pahpsp = NULL;

    // Allocate a buffer large enough to hold the handles to all of our
    // property pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                             * cPages);
    if (!ahpsp)
    {
        hr = E_OUTOFMEMORY;
        goto err;
    }

    if (!m_apspObj[0])
    {
        // Allocate each of the CPropSheetPage objects
        m_apspObj[0] = new CRPCConfigDlg(this);
    }
#ifdef DBG
    else
    {
        // Don't bother creating new classes if they already exist.
        AssertSz(m_apspObj[0], "Not all prop page objects are non-NULL!");

    }
#endif

    // Create the actual PROPSHEETPAGE for each object.
    // This needs to be done regardless of whether the classes existed before.
    ahpsp[0] = m_apspObj[0]->CreatePage(DLG_RPCConfig, 0);

    Assert(SUCCEEDED(hr));

    *pahpsp = ahpsp;

cleanup:
    TraceError("HrSetupPropSheets", hr);
    return hr;

err:
    CoTaskMemFree(ahpsp);
    goto cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::CleanupPropPages
//
//  Purpose:    Loop thru each of the pages and free the objects associated
//              with them.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   28 Feb 1997
//
//  Notes:
//
VOID CMSClient::CleanupPropPages()
{
    INT     ipage;

    for (ipage = 0; ipage < c_cPages; ipage++)
    {
        delete m_apspObj[ipage];
        m_apspObj[ipage] = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\msclidlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M S C L I D L G . H
//
//  Contents:   Dialog box handling for the MSCLient object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#ifndef _MSCLIDLG_H
#define _MSCLIDLG_H
#pragma once
#include "mscliobj.h"

//
// RPC Configuration Dialog
//
class CRPCConfigDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CRPCConfigDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
        COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
    END_MSG_MAP()

    CRPCConfigDlg(CMSClient *pmsc): m_pmsc(pmsc), m_isel(-1) {};
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& Handled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                      LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnChange(WORD wNotifyCode, WORD wID,
                    HWND hWndCtl, BOOL& bHandled)
    {
       SetState();
       SetChangedFlag();
       return 0;
    };

private:
    HRESULT HrGetDCEProvider(VOID);
    HRESULT HrOpenRegKeys(VOID);
    HRESULT HrValidateRpcData(VOID);
    VOID SetState(VOID);

    INT         m_isel;
    CMSClient * m_pmsc;
};

BOOL FIsValidDomainName(PCWSTR szName);

#endif //!_MSCLIDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\browsdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       B R O W S D L G . C P P
//
//  Contents:   Dialog box handling for Browser configuration.
//
//  Notes:
//
//  Author:     danielwe   3 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <lm.h>
#include <icanon.h>

#include "mscliobj.h"
#include "ncreg.h"
#include "ncui.h"

static const WCHAR c_szWksParams[] = L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters";
static const WCHAR c_szBrowserParams[] = L"System\\CurrentControlSet\\Services\\Browser\\Parameters";
static const WCHAR c_szOtherDomains[] = L"OtherDomains";

//+---------------------------------------------------------------------------
//
//  Function:   FIsValidDomainName
//
//  Purpose:    Returns TRUE if the given domain name is a valid NetBIOS name.
//
//  Arguments:
//      pszName [in]     Domain name to validate
//
//  Returns:    TRUE if the name is valid, FALSE otherwise.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:      $REVIEW (danielwe): Use new netsetup function instead?
//
BOOL FIsValidDomainName(PCWSTR pszName)
{
    NET_API_STATUS  nerr;

    // Make sure the given name is a valid domain name
    nerr = NetpNameValidate(NULL, const_cast<PWSTR>(pszName),
                            NAMETYPE_DOMAIN, 0L);

    return !!(NERR_Success == nerr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrGetBrowserRegistryInfo
//
//  Purpose:    Read data from the registry into an in-memory copy.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
HRESULT CMSClient::HrGetBrowserRegistryInfo()
{
    HRESULT     hr = S_OK;
    HKEY        hkeyWksParams = NULL;

    Assert(!m_szDomainList);

    // Open LanmanWorkstation Parameters key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWksParams,
                        KEY_READ, &hkeyWksParams);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
        {
            // Optional value. Ok if not there.
            hr = S_OK;
        }
        else
        {
            goto err;
        }
    }

    if (hkeyWksParams)
    {
        hr = HrRegQueryMultiSzWithAlloc(hkeyWksParams, c_szOtherDomains,
                                        &m_szDomainList);
        if (FAILED(hr))
        {
            if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
            {
                AssertSz(!m_szDomainList, "Call failed, so why is this not "
                         "still NULL?");
                // No problem if value is not there.
                hr = S_OK;
            }
            else
            {
                goto err;
            }
        }
    }

    Assert(SUCCEEDED(hr));

    // If we didn't get a domain list yet, make a new default one.
    if (!m_szDomainList)
    {
        // Allocate space for empty string
        m_szDomainList = new WCHAR[1];

		if (m_szDomainList != NULL)
		{
            *m_szDomainList = 0;
		}
    }

err:
    RegSafeCloseKey(hkeyWksParams);
    TraceError("CMSClient::HrGetBrowserRegistryInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrSetBrowserRegistryInfo
//
//  Purpose:    Write what we have saved in memory into the registry.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
HRESULT CMSClient::HrSetBrowserRegistryInfo()
{
    HRESULT     hr = S_OK;

    if (m_fBrowserChanges)
    {
        HKEY    hkeyBrowserParams = NULL;

        // Verify that the Browser Parameters key exists. If not, we can't
        // continue.
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szBrowserParams,
                            KEY_ALL_ACCESS, &hkeyBrowserParams);
        if (SUCCEEDED(hr))
        {
            HKEY    hkeyWksParams = NULL;

            // Open LanmanWorkstation Parameters key
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWksParams,
                                KEY_ALL_ACCESS, &hkeyWksParams);
            if (SUCCEEDED(hr))
            {
                hr = HrRegSetMultiSz(hkeyWksParams, c_szOtherDomains,
                                     m_szDomainList);
                RegSafeCloseKey(hkeyWksParams);
            }
            RegSafeCloseKey(hkeyBrowserParams);
        }
    }

    TraceError("CMSClient::HrSetBrowserRegistryInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::SetBrowserDomainList
//
//  Purpose:    Replace the current domain list with a new copy (obtained from
//              the dialog).
//
//  Arguments:
//      pszNewList [in]  New domain list in MULTI_SZ format.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
VOID CMSClient::SetBrowserDomainList(PWSTR pszNewList)
{
    delete [] m_szDomainList;
    m_szDomainList = pszNewList;
    m_fBrowserChanges = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\mscapply.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M S C A P P L Y . C P P
//
//  Contents:   Functions called when MSClient is applied.
//
//  Notes:
//
//  Author:     danielwe   25 Feb 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "ncnetcfg.h"
#include "mscliobj.h"
#include "ncmisc.h"
#include "ncsvc.h"

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrApplyChanges
//
//  Purpose:    Writes out changes that occurred during the lifetime of our
//              object.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      This will do several things.
//              1) Set info for the RPC nameservice and security service that
//                 was indicated by the UI for the RPC config dialog.
//              2) Set the parameters for the browser configuration to the
//                 registry.
//
//              If no changes were detected, this will do nothing.
//
HRESULT CMSClient::HrApplyChanges()
{
    HRESULT hr;

    // Write out any changes to RPC info
    hr = HrSetRPCRegistryInfo();
    if (SUCCEEDED(hr))
    {
        // Write out any changes to Browser info
        hr = HrSetBrowserRegistryInfo();
    }

    if (SUCCEEDED(hr) && (m_fOneTimeInstall || m_fUpgradeFromWks))
    {
        // Note: This function will do the workstation/server detection,
        // and won't install if we're running the workstation build.
        //
        hr = HrInstallDfs();
    }

    TraceError("CMSClient::HrApplyChanges", hr);
    return hr;
}

static const CHAR   c_szaDfsCheck[]     = "DfsCheckForOldDfsService";
static const CHAR   c_szaDfsSetupDfs[]  = "DfsSetupDfs";
static const WCHAR  c_szDfsSetupDll[]   = L"dfssetup.dll";

typedef BOOLEAN (APIENTRY *PDFSCHECKFOROLDDFSSERVICE)(void);
typedef DWORD (APIENTRY *PDFSSETUPDFS)(DWORD, PSTR, PSTR *);

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallDfs
//
//  Purpose:    Take care of installation of DFS components
//
//  Arguments:
//      (none)
//
//  Returns:    Win32 HRESULT if failure.
//
//  Author:     danielwe   23 Jul 1997
//
//  Notes:      Shortcut creation is handled by this function and not
//              the netmscli.inf file because it is conditional on whether
//              the DFS components are installed.
//
HRESULT HrInstallDfs()
{
    HRESULT         hr = S_OK;
    PRODUCT_FLAVOR  pf;                     // Server/Workstation

    // Get the product flavor (PF_WORKSTATION or PF_SERVER). Use this
    // to decide whether or not we need to install DFS.
    //
    GetProductFlavor(NULL, &pf);
    if (PF_SERVER == pf)
    {
        PDFSCHECKFOROLDDFSSERVICE pfnDfsCheckForOldDfsService = NULL;
        HMODULE     hMod = NULL;

        TraceTag(ttidMSCliCfg, "Attempting to install DFS, since we're in a "
                 "server install");

        hr = HrLoadLibAndGetProc(c_szDfsSetupDll, c_szaDfsCheck, &hMod,
                                 reinterpret_cast<FARPROC *>(&pfnDfsCheckForOldDfsService));
        if (SUCCEEDED(hr))
        {
            NC_TRY
            {
                AssertSz(hMod, "Module handle cannot be NULL!");
                BOOL fDFSInstalled = pfnDfsCheckForOldDfsService();

                // If DFS is not installed, go ahead and install it now.
                if (!fDFSInstalled)
                {
                    PDFSSETUPDFS    pfnDfsSetupDfs = NULL;
                    hr = HrGetProcAddress(hMod, c_szaDfsSetupDfs,
                                          reinterpret_cast<FARPROC *>(&pfnDfsSetupDfs));
                    if (SUCCEEDED(hr))
                    {
                        PSTR   szResult = NULL;

                        if (!pfnDfsSetupDfs(0, NULL, &szResult))
                        {
                            // DFS setup failed!

                            hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
                            TraceError("HrInstallDfs - pfnDfsSetupDfs", hr);
                        }
                    }
                }
            }
            NC_CATCH_ALL
            {
                TraceTag(ttidError, "Caught an exception from %S. Would "
                          "the owner kindly keep it from crashing?",
                          c_szDfsSetupDll);
            }

            FreeLibrary(hMod);
        }
    }
    else
    {
        TraceTag(ttidMSCliCfg, "Not attempting to install DFS, since we're in a "
                 "workstation install");
    }

    TraceError("HrInstallDfs", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableBrowserService
//
//  Purpose:    Enables the 'Browser' service
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, WIN32 error if not
//
//  Author:     danielwe   9 Sep 1998
//
//  Notes:
//
HRESULT HrEnableBrowserService()
{
    HRESULT         hr;
    CServiceManager sm;
    CService        srv;

    hr = sm.HrOpenService(&srv, L"Browser");
    if (SUCCEEDED(hr))
    {
        DWORD       dwStartType;

        hr = srv.HrQueryStartType(&dwStartType);
        if (SUCCEEDED(hr) && (dwStartType != SERVICE_DISABLED))
        {
            // Change the Browser StartType registry setting back to auto start
            hr = srv.HrSetStartType(SERVICE_AUTO_START);
        }
    }

    TraceError("HrEnableBrowserService",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDisableBrowserService
//
//  Purpose:    Disables the 'Browser' service
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, WIN32 error if not
//
//  Author:     danielwe   9 Sep 1998
//
//  Notes:
//
HRESULT HrDisableBrowserService()
{
    HRESULT         hr;
    CServiceManager sm;
    CService        srv;

    hr = sm.HrOpenService(&srv, L"Browser");
    if (SUCCEEDED(hr))
    {
        DWORD       dwStartType;

        hr = srv.HrQueryStartType(&dwStartType);
        if (SUCCEEDED(hr) && (dwStartType != SERVICE_DISABLED))
        {
            // Change the Browser StartType registry setting to demand start
            hr = srv.HrSetStartType(SERVICE_DEMAND_START);
            if (SUCCEEDED(hr))
            {
                hr = sm.HrStopServiceNoWait(L"Browser");
            }
        }
    }

    TraceError("CNbfObj::HrDisableNetBEUI",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\msclihlp.h ===
//This file is used by msclicfg.rc
//
// Generated by Melissa Simmons, 4-6-99

#define IDH_CMB_NameService 80000000
#define IDH_EDT_NetAddress 80000001
#define IDH_DISABLEHELP ((DWORD)-1)



const DWORD g_aHelpIDs_DLG_RPCConfig[]=
{
	IDC_STATIC, IDH_DISABLEHELP,
	CMB_NameService,IDH_CMB_NameService,
	IDC_TXT_NetAddress, IDH_EDT_NetAddress,
	EDT_NetAddress,IDH_EDT_NetAddress,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\mscliobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       M S C L I O B J . C P P
//
//  Contents:   Implementation of the CMSClient notify object model
//
//  Notes:
//
//  Author:     danielwe   22 Feb 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <ncsvc.h>
#include "mscliobj.h"
#include "nb30.h"
#include "ncerror.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include <ntsecapi.h>
#include <lm.h>

static const WCHAR c_szBrowseDomains[] = L"BrowseDomains";
static const WCHAR c_szNameServiceNetAddr[] = L"NameServiceNetworkAddress";
static const WCHAR c_szNameServiceProt[] = L"NameServiceProtocol";

extern const WCHAR c_szInfId_MS_NetBIOS[];
extern const WCHAR c_szInfId_MS_Server[];


// Defined in rpcdlg.cpp
extern const WCHAR c_szDefNetAddr[];
extern const WCHAR c_szProtWinNT[];

// Registry paths
static const WCHAR c_szRegKeyBrowser[]      = L"System\\CurrentControlSet\\Services\\Browser\\Parameters";
static const WCHAR c_szRegKeyNetLogon[]     = L"System\\CurrentControlSet\\Services\\NetLogon\\Parameters";

// Answer file constants
static const WCHAR c_szNetLogonParams[]     = L"NetLogon.Parameters";
static const WCHAR c_szBrowserParams[]      = L"Browser.Parameters";

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::CMSClient
//
//  Purpose:    Constructs the CMSClient object.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
CMSClient::CMSClient()
:   m_pncc(NULL),
    m_pnc(NULL),
    m_fBrowserChanges(FALSE),
    m_fRPCChanges(FALSE),
    m_fOneTimeInstall(FALSE),
    m_fUpgrade(FALSE),
    m_fRemoving(FALSE),
    m_hkeyRPCName(NULL),
    m_eSrvState(eSrvNone),
    m_fUpgradeFromWks(FALSE),
    m_szDomainList(NULL)
{
    ZeroMemory(&m_rpcData, sizeof(RPC_CONFIG_DATA));
    ZeroMemory(&m_apspObj, sizeof(m_apspObj));
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::~CMSClient
//
//  Purpose:    Destructs the CMSClient object.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
CMSClient::~CMSClient()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);

    RegSafeCloseKey(m_hkeyRPCName);

    m_rpcData.strProt.erase();
    m_rpcData.strNetAddr.erase();
    m_rpcData.strEndPoint.erase();

    CleanupPropPages();

#ifdef DBG
        {
            INT     ipage;

            for (ipage = 0; ipage < c_cPages; ipage++)
            {
                AssertSz(!m_apspObj[ipage], "Prop page object not cleaned up!");
            }
        }

#endif

    delete [] m_szDomainList;
}

//
// INetCfgComponentControl
//

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::Initialize
//
//  Purpose:    Initializes the notify object.
//
//  Arguments:
//      pnccItem    [in]    INetCfgComponent that we are handling
//                          notifications for.
//      pnc         [in]    INetCfg master object.
//      fInstalling [in]    TRUE if we are being installed, FALSE if not.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::Initialize(INetCfgComponent *pnccItem, INetCfg *pnc,
                                   BOOL fInstalling)
{
    HRESULT             hr = S_OK;
    INetCfgComponent *  pnccServer = NULL;

    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "Component object is NULL!");
    AssertSz(m_pnc, "INetCfg object is NULL!");

    // We're hanging on to these, so AddRef 'em.
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    // Check to see if MS_SERVER is installed. If not, set the browser service
    // to be disabled.
    //
    hr = m_pnc->FindComponent(c_szInfId_MS_Server, &pnccServer);
    if (S_FALSE == hr)
    {
        // Server component is not present. Set browser to be disabled on
        // apply
        m_eSrvState = eSrvDisable;
    }
    else if (S_OK == hr)
    {
        ReleaseObj(pnccServer);
    }

    if (SUCCEEDED(hr))
    {
        // Read in data for the RPC config dialog from the registry
        hr = HrGetRPCRegistryInfo();
        if (SUCCEEDED(hr))
        {
            // Read in data for the browser config dialog from the registry
            hr = HrGetBrowserRegistryInfo();
        }
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CMSClient::Initialize", hr);
    return hr;
}

STDMETHODIMP CMSClient::Validate()
{
    return S_OK;
}

STDMETHODIMP CMSClient::CancelChanges()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::ApplyRegistryChanges
//
//  Purpose:    Called when changes to this component should be applied.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if successful, S_FALSE if no changes occurred,
//              NETCFG_S_REBOOT if a reboot is required, otherwise a NETCFG_E
//              error code.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::ApplyRegistryChanges()
{
    TraceFileFunc(ttidMSCliCfg);
    HRESULT     hr = S_OK;

    if (m_fUpgrade)
    {
        m_fUpgrade = FALSE;

        hr = HrRestoreRegistry();
        if (FAILED(hr))
        {
            TraceError("CMSClient::ApplyRegistryChanges - HrRestoreRegistry - non-fatal",
                       hr);
            hr = S_OK;
        }
    }

    // Do we need to enable or disable the browser service??
    //
    switch (m_eSrvState)
    {
    case eSrvEnable:
        TraceTag(ttidMSCliCfg, "Enabling the Browser service...");
        hr = HrEnableBrowserService();
        if (FAILED(hr))
        {
            TraceError("CMSClient::ApplyRegistryChanges - HrEnableBrowserService failed."
                       " non-fatal.", hr);
            hr = S_OK;
        }
        break;

    case eSrvDisable:
        TraceTag(ttidMSCliCfg, "Disabling the Browser service...");
        hr = HrDisableBrowserService();
        if (FAILED(hr))
        {
            TraceError("CMSClient::ApplyRegistryChanges - HrDisableBrowserService failed."
                       " non-fatal.", hr);
            hr = S_OK;
        }
        break;
    }

    if (m_fRPCChanges || m_fBrowserChanges ||
        m_fOneTimeInstall || m_fUpgradeFromWks)
    {
        hr = HrApplyChanges();
        if (SUCCEEDED(hr))
        {
            m_fRPCChanges = FALSE;
            m_fBrowserChanges = FALSE;
            m_fOneTimeInstall = FALSE;

            // Make NetLogon dependend on LanmanServer for Domain Controllers, and Automatic start for Domain Members
            hr = HrSetNetLogonDependencies();
        }
    }
    else
    {
        // No relevant changes were detected (netbios changes do not affect
        // netcfg so we can return S_FALSE even if things changed
        hr = S_FALSE;
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CMSClient::ApplyRegistryChanges", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CMSClient::ApplyPnpChanges (
    IN INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr;

    hr = S_OK;

    if (m_fRemoving)
    {
        // Make sure Mrxsmb and Rdbss have been removed.  (They are stopped
        // when LanmanWorkstation stops, but the binding engine has no idea
        // that Mrxsmb and Rdbss are part of this component.  Hence, the
        // status of the DeleteService that is performed as part of the INF
        // is not communicated back out.)  We make sure that these services
        // do not exist here, and if they do, we report that we need a
        // reboot.
        //
        CServiceManager scm;
        CService svc;

        TraceTag(ttidMSCliCfg, "Checking to see that Mrxsmb and Rdbss "
            "are stopped and removed");

        hr = scm.HrOpenService (&svc, L"Mrxsmb",
                    NO_LOCK, SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);

        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) != hr)
        {
            TraceHr(ttidMSCliCfg, FAL, hr, FALSE, "OpenService(MrxSmb)");
            TraceTag(ttidMSCliCfg, "Mrxsmb still exists");
            hr = NETCFG_S_REBOOT;
        }
        else
        {
            // Mrxsmb does not exist.  Now check Rdbss.
            //
            hr = scm.HrOpenService (&svc, L"Rdbss",
                        NO_LOCK, SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);

            if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) != hr)
            {
                TraceHr(ttidMSCliCfg, FAL, hr, FALSE, "OpenService(Rdbss)");
                TraceTag(ttidMSCliCfg, "Rdbss still exists");
                hr = NETCFG_S_REBOOT;
            }
            else
            {
                // Rdbss does not exist.  This is good.
                //
                hr = S_OK;
            }
        }
    }

    return hr;
}

//
// INetCfgComponentSetup
//

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::Install
//
//  Purpose:    Called when this component is being installed
//
//  Arguments:
//      dwSetupFlags [in] Flags that describe the type of setup
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::Install(DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    m_fRPCChanges = TRUE;
    m_fBrowserChanges = TRUE;
    m_fOneTimeInstall = TRUE;

    if ((NSF_WINNT_WKS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SBS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SVR_UPGRADE & dwSetupFlags))
    {
        m_fUpgrade = TRUE;
    }

    // Install the NetBIOS sub-component
    hr = HrInstallComponentOboComponent(m_pnc, NULL,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_NetBIOS,
            m_pncc,
            NULL);

    TraceError("CMSClient::Install", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::Upgrade
//
//  Purpose:    Called when this component is upgraded
//
//  Arguments:
//      dwSetupFlags        [in] Flags describing setup
//      dwUpgradeFomBuildNo [in] Build number from which we are upgrading
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::Upgrade(DWORD dwSetupFlags,
                                DWORD dwUpgradeFomBuildNo)
{
    if (dwSetupFlags & NSF_WINNT_WKS_UPGRADE)
    {
        TraceTag(ttidMSCliCfg, "Upgrading from workstation...");
        m_fUpgradeFromWks = TRUE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::ReadAnswerFile
//
//  Purpose:    Reads the appropriate fields from the given answer file into
//              our in-memory state.
//
//  Arguments:
//      pszAnswerFile     [in] File name of answer file
//      pszAnswerSection   [in] Section of answer file to look in
//
//  Returns:    S_OK if successful, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:      IMPORTANT: During install or upgrade, this MUST be called
//              *before* Upgrade() or Install()! (see bug #100995)
//
STDMETHODIMP CMSClient::ReadAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    HRESULT     hr = S_OK;

    if (pszAnswerSection && pszAnswerFile)
    {
        // There's an answer file. We must process it now.
        hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
        if (FAILED(hr))
        {
            TraceError("CMSClient::ReadAnswerFile- Answer file has "
                       "errors. Defaulting all information as if "
                       "answer file did not exist.",
                       NETSETUP_E_ANS_FILE_ERROR);
            hr = S_OK;
        }
    }

    TraceError("CMSClient::ReadAnswerFile", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::Removing
//
//  Purpose:    Called whent this component is being removed
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK of success, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::Removing()
{
    m_fRemoving = TRUE;

    // Remove the NetBIOS service. This doesn't actually remove the
    // component, it simply marks it as needing to be removed, and in
    // Apply() it will be fully removed.
    HRESULT hr = HrRemoveComponentOboComponent(m_pnc,
                                       GUID_DEVCLASS_NETSERVICE,
                                       c_szInfId_MS_NetBIOS,
                                       m_pncc);

    TraceError("CMSClient::Removing", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrRestoreRegistry
//
//  Purpose:    Restores the registry settings for various services on upgrade
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, WIN32 error otherwise
//
//  Author:     danielwe   8 Aug 1997
//
//  Notes:
//
HRESULT CMSClient::HrRestoreRegistry()
{
    HRESULT             hr = S_OK;
    HKEY                hkey;
    TOKEN_PRIVILEGES *  ptpRestore = NULL;
    static const WCHAR c_szSvcDLLName[]     = L"%SystemRoot%\\System32\\browser.dll";
    static const WCHAR c_szServiceDll[]     = L"ServiceDll";

    if (!m_strBrowserParamsRestoreFile.empty() ||
        !m_strNetLogonParamsRestoreFile.empty())
    {
        hr = HrEnableAllPrivileges(&ptpRestore);
        if (SUCCEEDED(hr))
        {
            if (!m_strBrowserParamsRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyBrowser,
                                    KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey,
                                         m_strBrowserParamsRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CMSClient::HrRestoreRegistry - "
                                   "HrRestoreRegistry for Browser Parameters",
                                   hr);
                        hr = S_OK;
                    }

                    hr = HrRegSetValueEx(hkey, c_szServiceDll, REG_EXPAND_SZ, (const BYTE *)c_szSvcDLLName, (wcslen(c_szSvcDLLName) + 1) * sizeof(TCHAR));
                    if (FAILED(hr))
                    {
                        TraceError("CMSClient::HrRestoreRegistry - HrRestoreRegistry for "
                                "ServiceDll", hr);
                                hr = S_OK;
                    }
                    RegSafeCloseKey(hkey);
                }
            }

            if (!m_strNetLogonParamsRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNetLogon,
                                    KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey,
                                         m_strNetLogonParamsRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CMSClient::HrRestoreRegistry - "
                                   "HrRestoreRegistry for NetLogon Parameters",
                                   hr);
                        hr = S_OK;
                    }

                    RegCloseKey(hkey);
                }
            }

            hr = HrRestorePrivileges(ptpRestore);

            delete [] reinterpret_cast<BYTE *>(ptpRestore);
        }
    }

    TraceError("CMSClient::HrRestoreRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrProcessAnswerFile
//
//  Purpose:    Processes the answer file. Any parameters that have been set
//              are read into our in-memory state.
//
//  Arguments:
//      pszAnswerFile     [in]     Filename of answer file.
//      pszAnswerSection [in]     Comma-separated list of sections in the
//                                  file appropriate to this component.
//
//  Returns:    S_OK if successful, NETCFG error code otherwise.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:      Errors returned from this function should be ignored so as to
//              prevent blocking the rest of network install.
//
HRESULT CMSClient::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    HRESULT         hr = S_OK;
    CSetupInfFile   csif;
    PWSTR           mszDomainList = NULL;

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
        goto err;

    if (m_fUpgrade)
    {
        // Restore portions of the registry based on file names from the answer
        // file

        // Get restore file for "Parameters" key
        hr = csif.HrGetString(pszAnswerSection, c_szNetLogonParams,
                              &m_strNetLogonParamsRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CMSClient::HrProcessAnswerFile - Error reading "
                       "NetLogon.Parameters from answer file", hr);

            // oh well, just continue
            hr = S_OK;
        }

        // Get restore file for "Parameters" key
        hr = csif.HrGetString(pszAnswerSection, c_szBrowserParams,
                              &m_strBrowserParamsRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CMSClient::HrProcessAnswerFile - Error reading "
                       "Browser.Parameters from answer file", hr);

            // oh well, just continue
            hr = S_OK;
        }
    }

    // Get the BrowseDomains field.
    hr = HrSetupGetFirstMultiSzFieldWithAlloc(csif.Hinf(),
                                              pszAnswerSection,
                                              c_szBrowseDomains,
                                              &mszDomainList);
    if (FAILED(hr))
    {
        // ignore line not found errors
        if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        {
            hr = S_OK;
        }

        TraceError("HrProcessAnswerFile - Error on BrowseDomains field. "
                   "Using default value", hr);
    }
    else
    {
        // Set the new domain list.
        SetBrowserDomainList(mszDomainList);
    }

    // Get the NameServiceNetworkAddress value
    hr = csif.HrGetString(pszAnswerSection,
                          c_szNameServiceNetAddr,
                          &m_rpcData.strNetAddr);
    if (FAILED(hr))
    {
        // ignore line not found errors
        if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        {
            hr = S_OK;
        }

        TraceError("HrProcessAnswerFile - Error on NetworkAddress field. "
                   "Defaulting value", hr);
        m_rpcData.strNetAddr = c_szDefNetAddr;
    }
    else
    {
        m_fRPCChanges = TRUE;
    }

    // Get the NameServiceProtocol value.
    hr = csif.HrGetString(pszAnswerSection,
                          c_szNameServiceProt,
                          &m_rpcData.strProt);
    if (FAILED(hr))
    {
        // ignore line not found errors
        if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        {
            hr = S_OK;
        }

        TraceError("HrProcessAnswerFile - Error on NameServiceProtocol field. "
                   "Defaulting value", hr);
        m_rpcData.strProt = c_szProtWinNT;
    }
    else
    {
        m_fRPCChanges = TRUE;
    }

err:
    TraceError("CMSClient::HrProcessAnswerFile", hr);
    return hr;
}

//
// INetCfgProperties
//

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::MergePropPages
//
//  Purpose:    Called when this component's properties are about to be
//              brought up.
//
//  Arguments:
//      pdwDefPages   [out] Number of default pages to show.
//      pahpspPrivate [out] Array of property sheet handles to pages that this
//                          component will show.
//      pcPrivate     [out] Number of pages in array.
//      hwndParent    [in]  Parent window for any UI.
//      pszStartPage  [out] Pointer to start page.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::MergePropPages(
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    HPROPSHEETPAGE *ahpsp = NULL;
    HRESULT hr = HrSetupPropSheets(&ahpsp, c_cPages);
    if (SUCCEEDED(hr))
    {
        *pahpspPrivate = (LPBYTE)ahpsp;

        // We don't want any default pages to be shown
        *pdwDefPages = 0;
        *pcPages = c_cPages;
    }

    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CMSClient::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CMSClient::ValidateProperties(HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CMSClient::CancelProperties()
{
    return S_OK;
}

STDMETHODIMP CMSClient::ApplyProperties()
{
    return S_OK;
}

//
// INetCfgSystemNotify
//
STDMETHODIMP CMSClient::GetSupportedNotifications (DWORD* pdwNotificationFlag)
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications(pdwNotificationFlag);

    *pdwNotificationFlag = NCN_NETTRANS | NCN_NETSERVICE |
                           NCN_ENABLE | NCN_DISABLE |
                           NCN_ADD | NCN_REMOVE;

    return S_OK;
}

STDMETHODIMP CMSClient::SysQueryBindingPath (DWORD dwChangeFlag,
                                             INetCfgBindingPath* pncbp)
{
    return S_OK;
}

STDMETHODIMP CMSClient::SysQueryComponent (DWORD dwChangeFlag,
                                           INetCfgComponent* pncc)
{
    return S_OK;
}

STDMETHODIMP CMSClient::SysNotifyBindingPath (DWORD dwChangeFlag,
                                              INetCfgBindingPath* pncbpItem)
{
    return S_FALSE;
}

STDMETHODIMP CMSClient::SysNotifyComponent(DWORD dwChangeFlag,
                                           INetCfgComponent* pncc)
{
    HRESULT hr;

    Validate_INetCfgSystemNotify_SysNotifyComponent(dwChangeFlag, pncc);

    // Assume we won't be dirty as a result of this notification.
    //
    hr = S_FALSE;

    if (dwChangeFlag & (NCN_ADD | NCN_REMOVE))
    {
        if (FIsComponentId(c_szInfId_MS_Server, pncc))
        {
            if (dwChangeFlag & NCN_ADD)
            {
                m_eSrvState = eSrvEnable;
                hr = S_OK;
            }
            else if (dwChangeFlag & NCN_REMOVE)
            {
                m_eSrvState = eSrvDisable;
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT CMSClient::HrSetNetLogonDependencies(VOID)
{
    static const WCHAR c_szLanmanServer[]   = L"LanmanServer";
    static const WCHAR c_szNetLogon[]       = L"NetLogon";
    
    HRESULT hr = S_OK;
    NT_PRODUCT_TYPE   ProductType;
    if (RtlGetNtProductType(&ProductType))
    {
        if (NtProductLanManNt == ProductType)
        {
            // If domain controller, make NetLogon wait for LanmanServer
            CServiceManager sm;
            CService        svc;
            hr = sm.HrOpen();
            if (SUCCEEDED(hr))
            {
                hr = sm.HrAddServiceDependency(c_szNetLogon, c_szLanmanServer);
                sm.Close();
            }
            if (FAILED(hr))
            {
                TraceError("CMSClient::HrSetNetLogonDependencies - "
                    "Creating dependency of NetLogon on LanmanServer",
                    hr);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        LSA_HANDLE h=0;
        POLICY_PRIMARY_DOMAIN_INFO* ppdi;
        LSA_OBJECT_ATTRIBUTES loa;
        ZeroMemory (&loa, sizeof(loa));
        loa.Length = sizeof(LSA_OBJECT_ATTRIBUTES);

        NTSTATUS ntstatus;
        ntstatus = LsaOpenPolicy(NULL, &loa, POLICY_VIEW_LOCAL_INFORMATION, &h);
        if (FALSE != LSA_SUCCESS(ntstatus))
        {
            ntstatus = LsaQueryInformationPolicy(h, PolicyPrimaryDomainInformation, (VOID **) &ppdi);
            if (LSA_SUCCESS(ntstatus))
            {
                if (ppdi->Sid > 0) // Domain Member
                {
                    hr = HrChangeServiceStartType(c_szNetLogon, SERVICE_AUTO_START);
                    if (FAILED(hr))
                    {
                        TraceError("CMSClient::HrSetNetLogonDependencies - "
                            "Install for Start - NetLogon",
                            hr);
                    }

                }
                LsaFreeMemory(ppdi);
            }
            LsaClose(h);
        }
    }

    TraceError("CMSClient::HrSetNetLogonDependencies",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\resource.h ===
#include <ncres.h>

#define STR_DCELocator                  IDS_NC_MSCLICFG +  1
#define STR_DCESecurity                 IDS_NC_MSCLICFG +  2
#define STR_ErrorCaption                IDS_NC_MSCLICFG +  3
#define STR_InvalidDomainName           IDS_NC_MSCLICFG +  6
#define STR_InvalidNetAddress           IDS_NC_MSCLICFG +  7
#define STR_NTLocator                   IDS_NC_MSCLICFG +  9
#define STR_NTSecurity                  IDS_NC_MSCLICFG + 10
#define STR_Route                       IDS_NC_MSCLICFG + 11

#define DLG_RPCConfig                   1202

#define CMB_NameService                 215
#define EDT_NetAddress                  216
#define CMB_SecService                  217
#define IDC_TXT_NetAddress              220
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nbfcfg\resource.h ===
#include <ncres.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nbfcfg\nbfobj.h ===
#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"


/////////////////////////////////////////////////////////////////////////////
// Netnbf

class ATL_NO_VTABLE CNbfObj :
    public CComObjectRoot,
    public CComCoClass<CNbfObj, &CLSID_CNbfObj>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal
{
public:
    CNbfObj();
    ~CNbfObj();

    BEGIN_COM_MAP(CNbfObj)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNbfObj)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NBFCFG)

// Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActConfig, eActInstall, eActRemove};
    enum NBFSTATE      {eStateNoChange, eStateDisable, eStateEnable};

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Removing)            ();

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

private:
    HRESULT HrEnableNetBEUI();
    HRESULT HrDisableNetBEUI();
    HRESULT HrUpdateNetBEUI();

private:
    INetCfgComponent* m_pNCC;
    INetCfg*          m_pNetCfg;
    BOOL              m_fFirstTimeInstall;
    BOOL              m_fRebootNeeded;
    NBFSTATE          m_eNBFState;
    INSTALLACTION     m_eInstallAction;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\mscliobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M S C L I O B J . H
//
//  Contents:   Declaration of CMSClient and helper functions.
//
//  Notes:
//
//  Author:     danielwe   25 Feb 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include <ncatlps.h>
#include "resource.h"

// constant defined in MSDN
static const c_cchMaxNetAddr = 80;

struct RPC_CONFIG_DATA
{
    tstring strProt;
    tstring strNetAddr;
    tstring strEndPoint;
};

/////////////////////////////////////////////////////////////////////////////
// MSClient

class ATL_NO_VTABLE CMSClient :
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal,
    public INetCfgComponentPropertyUi,
    public CComObjectRoot,
    public CComCoClass<CMSClient,&CLSID_CMSClient>
{
public:
    CMSClient();
    ~CMSClient();

    BEGIN_COM_MAP(CMSClient)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CMSClient)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_MSCLICFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFomBuildNo);
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Removing)            ();


// INetCfgComponentNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk) {return S_OK;}
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

public:

    // Accessors for RPC data
    const RPC_CONFIG_DATA *RPCData() const
        {return (const RPC_CONFIG_DATA *)&m_rpcData;};
    RPC_CONFIG_DATA *RPCDataRW() {return &m_rpcData;};

    // Accessors for Browser data
    PCWSTR SzGetBrowserDomainList()
        {return const_cast<PCWSTR>(m_szDomainList);};
    VOID SetBrowserDomainList(PWSTR szNewList);

    // Dirty bit functions
    VOID SetRPCDirty() {m_fRPCChanges = TRUE;};
    VOID SetBrowserDirty() {m_fBrowserChanges = TRUE;};

    // RPC config dialog members
    RPC_CONFIG_DATA     m_rpcData;          // data used to handle the RPC
                                            // configuration dialog
// Private state info
private:
    enum ESRVSTATE
    {
        eSrvNone = 0,
        eSrvEnable = 1,
        eSrvDisable = 2,
    };

    INetCfgComponent    *m_pncc;            // Place to keep my component
                                            // object
    INetCfg             *m_pnc;             // Place to keep my INetCfg object
    BOOL                m_fRPCChanges;      // TRUE if RPC config settings have
                                            // changed (dialog)
    BOOL                m_fBrowserChanges;  // Same for browser dialog
    BOOL                m_fOneTimeInstall;  // TRUE if need to perform one-time
                                            // install tasks
    BOOL                m_fUpgrade;         // TRUE if upgrading with answer
                                            // file
    BOOL                m_fUpgradeFromWks;  // TRUE if we are upgrading from WKS
    BOOL                m_fRemoving;        // TRUE we are being removed
    ESRVSTATE           m_eSrvState;

    HKEY                m_hkeyRPCName;      // NameService key

    // Browser config dialog members
    PWSTR              m_szDomainList;     // null-separated, double null
                                            // terminated list of OtherDomains

    // number of property sheet pages
    enum PAGES
    {
        c_cPages = 1
    };

    // Generic dialog data
    CPropSheetPage *    m_apspObj[c_cPages];// pointer to each of the prop
                                            // sheet page objects

    tstring             m_strBrowserParamsRestoreFile;
    tstring             m_strNetLogonParamsRestoreFile;

    HRESULT HrApplyChanges(VOID);
    HRESULT HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages);
    VOID CleanupPropPages(VOID);
    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection);
    HRESULT HrRestoreRegistry(VOID);
    HRESULT HrSetNetLogonDependencies(VOID);

    // Dialog access functions for RPC config
    HRESULT HrGetRPCRegistryInfo(VOID);
    HRESULT HrSetRPCRegistryInfo(VOID);

    // Dialog access functions for Browser config
    HRESULT HrGetBrowserRegistryInfo(VOID);
    HRESULT HrSetBrowserRegistryInfo(VOID);

    // Help function used by NotifyBindingPath
    BOOL FIsComponentOnPath(INetCfgBindingPath * pncbp, PCWSTR szCompId);
};

HRESULT HrInstallDfs(VOID);
HRESULT HrEnableBrowserService(VOID);
HRESULT HrDisableBrowserService(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\msclicfg\rpcdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R P C D L G . C P P
//
//  Contents:   Dialog box handling for RPC configuration.
//
//  Notes:
//
//  Author:     danielwe   3 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "mscliobj.h"
#include "msclidlg.h"
#include "ncatlui.h"
#include "ncerror.h"
#include "ncreg.h"
#include "ncui.h"
#include "msclihlp.h"

//
// Name service provider struct. Just holds some data used by the dialog.
//
struct NSP
{
    PCWSTR      pszProtocol;
    PCWSTR      pszEndPoint;
    WCHAR       szNetAddr[c_cchMaxNetAddr];
    BOOL        fUsesNetAddr;
};

static const WCHAR c_szRegKeyNameSvc[]  = L"Software\\Microsoft\\Rpc\\NameService";
static const WCHAR c_szNetAddress[]     = L"NetworkAddress";
static const WCHAR c_szSrvNetAddress[]  = L"ServerNetworkAddress";
static const WCHAR c_szProtocol[]       = L"Protocol";
static const WCHAR c_szValueEndPoint[]  = L"Endpoint";
static const WCHAR c_szProtDCE[]        = L"ncacn_ip_tcp";
static const WCHAR c_szEndPoint[]       = L"\\pipe\\locator";

// Used externally
extern const WCHAR c_szDefNetAddr[]     = L"\\\\.";
extern const WCHAR c_szProtWinNT[]      = L"ncacn_np";

// Helpfile
extern const WCHAR c_szNetCfgHelpFile[];


//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrGetRPCRegistryInfo
//
//  Purpose:    Reads the current state of the RPC configuration from the
//              registry into an in-memory struct. All changes occur to the
//              struct until Apply() is called at which time all changes are
//              written from the struct to the registry. Any values that
//              cannot be obtained are given reasonable defaults.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
HRESULT CMSClient::HrGetRPCRegistryInfo()
{
    HRESULT     hr = S_OK;

    // This key *will* be there because it's in the system hive.
    hr = HrRegOpenKeyBestAccess(HKEY_LOCAL_MACHINE, c_szRegKeyNameSvc,
                                &m_hkeyRPCName);
    if (FAILED(hr))
    {
        goto err;
    }

    // Find out what protocol the current name service provider is using.
    // This will allow us to set the default selection for the combo box.
    hr = HrRegQueryString(m_hkeyRPCName, c_szProtocol,
                          &m_rpcData.strProt);
    if (FAILED(hr))
    {
        goto err;
    }

    // Get the current value of the end point
    hr = HrRegQueryString(m_hkeyRPCName, c_szValueEndPoint,
                          &m_rpcData.strEndPoint);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // Use default value
            m_rpcData.strEndPoint = c_szEndPoint;
            hr = S_OK;
        }
        else
        {
            goto err;
        }
    }

    // If the name service provider uses a network address, we need to get it
    // too so we can fill in that nice little edit box with it.
    hr = HrRegQueryString(m_hkeyRPCName, c_szNetAddress,
                          &m_rpcData.strNetAddr);
    if (FAILED(hr))
    {
        goto err;
    }

err:
    TraceError("CMSClient::HrGetRPCRegistryInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrSetRPCRegistryInfo
//
//  Purpose:    Write out changes to the data structure (if there were any) to
//              the registry.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
HRESULT CMSClient::HrSetRPCRegistryInfo()
{
    HRESULT     hr = S_OK;

    struct REG_SET
    {
        PCWSTR          pszValue;
        const tstring * pstrData;
    };

    const REG_SET     aregs[] =
    {
        {c_szNetAddress,    &m_rpcData.strNetAddr},
        {c_szSrvNetAddress, &m_rpcData.strNetAddr},
        {c_szValueEndPoint, &m_rpcData.strEndPoint},
        {c_szProtocol,      &m_rpcData.strProt},
    };
    static const INT cregs = celems(aregs);

    if (m_fRPCChanges)
    {
        INT     iregs;

        for (iregs = 0; iregs < cregs; iregs++)
        {
            Assert(aregs[iregs].pstrData);
            hr = HrRegSetString(m_hkeyRPCName, aregs[iregs].pszValue,
                                *aregs[iregs].pstrData);
            if (FAILED(hr))
            {
                goto err;
            }
        }
    }
err:
    TraceError("CMSClient::HrSetRPCRegistryInfo", hr);
    return hr;
}


//
// Dialog handlers
//

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::OnInitDialog
//
//  Purpose:    Called when this dialog is first brought up.
//
//  Arguments:
//      uMsg     [in]
//      wParam   [in] See the ATL documentation for params.
//      lParam   [in]
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
LRESULT CRPCConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
    PCWSTR      pszCBItem;
    NSP *       pnspNT = NULL;
    NSP *       pnspDCE = NULL;
    INT         iItem;
    INT         cItems;

    const RPC_CONFIG_DATA * prpcData;

    // Make sure selection is always undetermined when the dialog is invoked.
    m_isel = -1;

    prpcData = m_pmsc->RPCData();
    Assert(prpcData);

    // Allocate some structs to associate with item data.
    pnspNT = new NSP;
    pnspDCE = new NSP;

	if ((pnspNT == NULL) ||
		(pnspDCE == NULL))
	{
		return(E_OUTOFMEMORY);
	}

    pnspNT->pszProtocol = c_szProtWinNT;
    pnspNT->pszEndPoint = c_szEndPoint;

    // This field is unused by NT name service. Just zero it out. When it
    // comes time to save the network address, we'll see that fUsesNetAddr is
    // FALSE and the szNetAddr string is empty and just save a hardcoded
    // net address.
    *pnspNT->szNetAddr = 0;
    pnspNT->fUsesNetAddr = FALSE;

    pnspDCE->pszProtocol = c_szProtDCE;
    pnspDCE->pszEndPoint = L"";
    *pnspDCE->szNetAddr = 0;
    pnspDCE->fUsesNetAddr = TRUE;

    //
    // Setup Name Service combo box
    //

    pszCBItem = SzLoadIds(STR_NTLocator);
    iItem = SendDlgItemMessage(CMB_NameService, CB_ADDSTRING, 0,
                               (LPARAM)pszCBItem);
    SendDlgItemMessage(CMB_NameService, CB_SETITEMDATA, iItem,
                       (LPARAM)pnspNT);

    pszCBItem = SzLoadIds(STR_DCELocator);
    iItem = SendDlgItemMessage(CMB_NameService, CB_ADDSTRING, 0,
                               (LPARAM)pszCBItem);
    SendDlgItemMessage(CMB_NameService, CB_SETITEMDATA, iItem,
                       (LPARAM)pnspDCE);

    cItems = SendDlgItemMessage(CMB_NameService, CB_GETCOUNT);

    // Find the item in the list that has the same protocol as the one from
    // the registry and make it the current selection.
    for (iItem = 0; iItem < cItems; iItem++)
    {
        NSP *pnsp = (NSP *)SendDlgItemMessage(CMB_NameService,
                                              CB_GETITEMDATA, iItem, 0);
        Assert(pnsp);
        if (!lstrcmpiW (pnsp->pszProtocol, prpcData->strProt.c_str()))
        {
            lstrcpyW (pnsp->szNetAddr, prpcData->strNetAddr.c_str());
            SendDlgItemMessage (CMB_NameService, CB_SETCURSEL, iItem, 0);
            break;
        }
    }

    AssertSz(iItem != cItems, "Protocol not found!");

    // Limit the edit box to the maximum length of a network address.
    SendDlgItemMessage(EDT_NetAddress, EM_LIMITTEXT, c_cchMaxNetAddr, 0);

    SetState();

    TraceError("CRPCConfigDlg::OnInitDialog", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Method: CRPCConfigDlg::OnContextMenu
//
//  Desc:   Bring up context-sensitive help
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
LRESULT
CRPCConfigDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (g_aHelpIDs_DLG_RPCConfig != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)g_aHelpIDs_DLG_RPCConfig);
    }
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Method: CRPCConfigDlg::OnHelp
//
//  Desc:   Bring up context-sensitive help when dragging ? icon over a control
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
//
LRESULT
CRPCConfigDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((g_aHelpIDs_DLG_RPCConfig != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_DLG_RPCConfig);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::SetState
//
//  Purpose:    Set the state of the edit control when selection changes.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
VOID CRPCConfigDlg::SetState()
{
    INT     iItem;
    NSP *   pnsp;
    NSP *   pnspOld = NULL;
    HWND    hwndEdit = GetDlgItem(EDT_NetAddress);

    iItem = SendDlgItemMessage(CMB_NameService, CB_GETCURSEL, 0, 0);
    Assert(iItem != CB_ERR);

    // If the selection hasn't changed, just return
    if (iItem == m_isel)
        return;

    if (m_isel != -1)
    {
        // Get the item data of the previous selection
        pnspOld = (NSP *)SendDlgItemMessage(CMB_NameService,
                                         CB_GETITEMDATA, m_isel, 0);
    }

    m_isel = iItem;

    // Get the item data of the new selection
    pnsp = (NSP *)SendDlgItemMessage(CMB_NameService,
                                     CB_GETITEMDATA, iItem, 0);
    Assert(pnsp);

    if (pnsp->fUsesNetAddr)
    {
        // This provider uses the NetAddress field. Set the edit control with
        // its text.
        ::SetWindowText(hwndEdit, pnsp->szNetAddr);
    }
    else
    {
        // Doesn't use NetAddress. Blank it out and save the old one.
        if (pnspOld)
        {
            ::GetWindowText(hwndEdit, pnspOld->szNetAddr, c_cchMaxNetAddr);
        }
        ::SetWindowText(hwndEdit, L"");
    }

    // Disable the edit box for name service providers that don't use the
    // network address field.
    ::EnableWindow(hwndEdit, pnsp->fUsesNetAddr);
    ::EnableWindow(GetDlgItem(IDC_TXT_NetAddress), pnsp->fUsesNetAddr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::HrValidateRpcData
//
//  Purpose:    Ensures that the RPC data entered in the dialog is valid.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK, if no errors, or NETCFG_E_PSNRET_INVALID_NCPAGE if there
//              were errors.
//
//  Author:     danielwe   21 Apr 1997
//
//  Notes:
//
HRESULT CRPCConfigDlg::HrValidateRpcData()
{
    HRESULT     hr = S_OK;
    INT         iItem;
    NSP *       pnsp;
    HWND        hwndEdit = GetDlgItem(EDT_NetAddress);

    iItem = SendDlgItemMessage(CMB_NameService, CB_GETCURSEL, 0, 0);
    if (iItem != CB_ERR)
    {
        // Get current name service info.
        pnsp = (NSP *)SendDlgItemMessage(CMB_NameService, CB_GETITEMDATA,
                                         iItem, 0);
        Assert(pnsp);

        if (pnsp->fUsesNetAddr)
        {
            INT     cch;

            // This name service uses the network address field. Make sure it
            // is not empty
            cch = ::GetWindowTextLength(hwndEdit);
            if (!cch)
            {
                // DCE doesn't allow empty network addresses
                NcMsgBox(m_hWnd, STR_ErrorCaption, STR_InvalidNetAddress,
                             MB_OK | MB_ICONEXCLAMATION);
                ::SetFocus(hwndEdit);
                hr = NETCFG_E_PSNRET_INVALID_NCPAGE;
            }
        }
    }

    TraceError("CRPCConfigDlg::HrValidateRpcData", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::OnKillActive
//
//  Purpose:    Called when the current page is switched away from or the
//              property sheet is closed.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []     See the ATL documentation for return results.
//      bHandled []
//
//  Returns:    S_OK, if no errors, or NETCFG_E_PSNRET_INVALID_NCPAGE if there
//              were errors.
//
//  Author:     danielwe   21 Apr 1997
//
//  Notes:
//
LRESULT CRPCConfigDlg::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;

    hr = HrValidateRpcData();

    TraceError("CRPCConfigDlg::OnKillActive", hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed.
//
//  Arguments:
//      idCtrl   [in]
//      pnmh     [in]   See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
LRESULT CRPCConfigDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT             hr = S_OK;
    INT                 iItem;
    NSP *               pnsp;
    HWND                hwndEdit = GetDlgItem(EDT_NetAddress);
    RPC_CONFIG_DATA *   prpcData;

    // Get a read-write version of the in-memory RPC data
    prpcData = m_pmsc->RPCDataRW();
    Assert(prpcData);

    iItem = SendDlgItemMessage(CMB_NameService, CB_GETCURSEL, 0, 0);
    Assert(iItem != CB_ERR);

    pnsp = (NSP *)SendDlgItemMessage(CMB_NameService,
                                     CB_GETITEMDATA, iItem, 0);
    Assert(pnsp);

    if (pnsp->fUsesNetAddr)
    {
#ifdef DBG
        INT     cch;

        cch = ::GetWindowTextLength(hwndEdit);
        AssertSz(cch, "I though we validated this was not empty!");
#endif
        // obtain network address from edit control
        ::GetWindowText(hwndEdit, pnsp->szNetAddr, c_cchMaxNetAddr);
    }
    else
    {
        // copy in a default network address
        lstrcpyW (pnsp->szNetAddr, c_szDefNetAddr);
    }

    // Set the in-memory RPC data
    prpcData->strNetAddr = pnsp->szNetAddr;
    prpcData->strEndPoint = pnsp->pszEndPoint;
    prpcData->strProt = pnsp->pszProtocol;
    m_pmsc->SetRPCDirty();

    TraceError("CRPCConfigDlg::OnOk", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::OnDestroy
//
//  Purpose:    Called when the dialog is destroyed.
//
//  Arguments:
//      uMsg     [in]
//      wParam   [in]   See the ATL documentation for params.
//      lParam   [in]
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
LRESULT CRPCConfigDlg::OnDestroy(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    INT     iItem;
    INT     cItems;
    NSP *   pnsp;

    // Walk the list of name service providers and free the NSP structs we
    // allocated before.
    cItems = SendDlgItemMessage(CMB_NameService, CB_GETCOUNT, 0, 0);
    for (iItem = 0; iItem < cItems; iItem++)
    {
        pnsp = (NSP *)SendDlgItemMessage(CMB_NameService,
                                         CB_GETITEMDATA, iItem, 0);
        AssertSz(pnsp, "This should not be NULL!");
        delete pnsp;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nbfcfg\nbfobj.cpp ===
// Nbfobj.cpp : Implementation of CNbfObj

#include "pch.h"
#pragma hdrstop
#include "nbfobj.h"
#include "ncsvc.h"

static const WCHAR c_szNbfServiceName[] = L"Nbf";

/////////////////////////////////////////////////////////////////////////////
//

//
// Function:    CNbfObj::CNbfObj
//
// Purpose:     ctor for the CNbfObj class
//
// Parameters:  none
//
// Returns:     none
//
CNbfObj::CNbfObj() : m_pNetCfg(NULL),
             m_pNCC(NULL),
             m_fFirstTimeInstall(FALSE),
             m_eNBFState(eStateNoChange),
             m_eInstallAction(eActConfig)
{
}

//
// Function:    CNbfObj::CNbfObj
//
// Purpose:     dtor for the CNbfObj class
//
// Parameters:  none
//
// Returns:     none
//
CNbfObj::~CNbfObj()
{
    ReleaseObj(m_pNetCfg);
    ReleaseObj(m_pNCC);
}


// INetCfgNotify
STDMETHODIMP CNbfObj::Initialize ( INetCfgComponent* pnccItem,
    INetCfg* pNetCfg, BOOL fInstalling )
{
    Validate_INetCfgNotify_Initialize(pnccItem, pNetCfg, fInstalling);

    ReleaseObj(m_pNCC);
    m_pNCC    = pnccItem;
    AddRefObj(m_pNCC);
    ReleaseObj(m_pNetCfg);
    m_pNetCfg = pNetCfg;
    AddRefObj(m_pNetCfg);
    m_fFirstTimeInstall = fInstalling;

    INetCfgComponent* pncc = NULL;

    // See if DNS is already installed.  If it is we need to be disabled
    if (S_OK == pNetCfg->FindComponent( L"MS_DNSServer", &pncc))
    {
        m_eNBFState = eStateDisable;
        ReleaseObj(pncc);
    }

    return S_OK;
}

STDMETHODIMP CNbfObj::ReadAnswerFile (PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection )
{
    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile, pszAnswerSection );
    return S_OK;
}

STDMETHODIMP CNbfObj::Install (DWORD)
{
    m_eInstallAction = eActInstall;

    return S_OK;
}

STDMETHODIMP CNbfObj::Removing ()
{
    m_eInstallAction = eActRemove;
    return S_OK;
}

STDMETHODIMP CNbfObj::Validate ()
{
    return S_OK;
}

STDMETHODIMP CNbfObj::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CNbfObj::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    switch(m_eInstallAction)
    {
    case eActInstall:
        hr = HrUpdateNetBEUI();
        break;

    case eActRemove:
        hr = S_OK;
        break;

    default:
        // Update NetBEUI's state if necessary
        hr = HrUpdateNetBEUI();
        break;
    }

    TraceError("CNbfObj::ApplyRegistryChanges", hr);
    return hr;
}

STDMETHODIMP CNbfObj::ApplyPnpChanges (
    IN INetCfgPnpReconfigCallback* pICallback )
{
    HRESULT             hr = S_OK;
    CServiceManager     sm;
    CService            service;

    // RAID #336321: (danielwe) Query the RemoteAccess service to see if
    // it's running and if so, return that a reboot is necessary (assumimg we
    // are installing or removing Nbf)
    //
    hr = sm.HrOpenService(&service, L"RemoteAccess");
    if (SUCCEEDED(hr))
    {
        DWORD   dwState;

        hr = service.HrQueryState(&dwState);
        if (SUCCEEDED(hr) &&
            (SERVICE_STOPPED != dwState) && (SERVICE_STOP_PENDING != dwState) &&
            ((m_eInstallAction == eActRemove) ||
             (m_eInstallAction == eActInstall)))
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    TraceError("CNbfObj::ApplyPnpChanges", hr);
    return hr;
}


// INetCfgSystemNotify
STDMETHODIMP CNbfObj::GetSupportedNotifications (
    DWORD* pdwNotificationFlag )
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications(pdwNotificationFlag);

    // Want to know when DNS comes and goes
    *pdwNotificationFlag = NCN_NETSERVICE | NCN_ADD | NCN_REMOVE;

    return S_OK;
}

STDMETHODIMP CNbfObj::SysQueryBindingPath ( DWORD dwChangeFlag,
    INetCfgBindingPath* pncbpItem )
{
    Validate_INetCfgSystemNotify_SysQueryBindingPath(dwChangeFlag,
                             pncbpItem);
    return S_OK;
}

STDMETHODIMP CNbfObj::SysQueryComponent ( DWORD dwChangeFlag,
    INetCfgComponent* pnccItem )
{
    Validate_INetCfgSystemNotify_SysQueryComponent(dwChangeFlag,
                           pnccItem);
    return S_OK;
}

STDMETHODIMP CNbfObj::SysNotifyBindingPath ( DWORD dwChangeFlag,
    INetCfgBindingPath* pncbpItem )
{
    Validate_INetCfgSystemNotify_SysNotifyBindingPath(dwChangeFlag,
                              pncbpItem);
    return S_FALSE;
}

STDMETHODIMP CNbfObj::SysNotifyComponent ( DWORD dwChangeFlag,
    INetCfgComponent* pnccItem )
{
    HRESULT hr;

    Validate_INetCfgSystemNotify_SysNotifyComponent(dwChangeFlag, pnccItem);

    // Assume we won't be dirty as a result of this notification.
    //
    hr = S_FALSE;

    if (FIsComponentId(L"MS_DnsServer", pnccItem))
    {
        // Disable/Enable NetBEUI when DNS is Added/Removed
        if (dwChangeFlag & NCN_ADD)
        {
            // Disable NetBEUI, and shutdown NetBEUI
            m_eNBFState = eStateDisable;
            hr = S_OK;
        }
        else if (dwChangeFlag & NCN_REMOVE)
        {
            // Re-enable NetBEUI
            m_eNBFState = eStateEnable;
            hr = S_OK;
        }
    }

    return hr;
}

//
// Function:    CNbfObj::HrEnableNetBEUI
//
// Purpose:     Enable NetBEUI
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CNbfObj::HrEnableNetBEUI()
{
    HRESULT         hr;
    CServiceManager sm;
    CService        srv;

    hr = sm.HrOpenService(&srv, c_szNbfServiceName);
    if (SUCCEEDED(hr))
    {
        // Change the Nbf StartType registry setting back to demand_start
        hr = srv.HrSetStartType(SERVICE_DEMAND_START);
    }

    // TODO: LogError any errors
    TraceError("CNbfObj::HrEnableNetBEUI",hr);
    return hr;
}

//
// Function:    CNbfObj::HrDisableNetBEUI
//
// Purpose:     Disable NetBEUI and shut down the service if it is running
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CNbfObj::HrDisableNetBEUI()
{
    HRESULT         hr;
    CServiceManager sm;
    CService        srv;

    hr = sm.HrOpenService(&srv, c_szNbfServiceName);
    if (SUCCEEDED(hr))
    {
    // Note: (shaunco) 8 Jan 1998: Need the SCM to be locked.

        // Change the Nbf StartType registry setting to disabled
        hr = srv.HrSetStartType(SERVICE_DISABLED);
        if (SUCCEEDED(hr))
        {
            hr = sm.HrStopServiceNoWait(c_szNbfServiceName);
        }
    }

    // TODO: LogError any errors
    TraceError("CNbfObj::HrDisableNetBEUI",hr);
    return hr;
}

//
// Function:    CNbfObj::HrUpdateNetBEUI
//
// Purpose:     Enable, Disable, or no nothing to NetBEUI
//              based on the presence of DNS Server
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CNbfObj::HrUpdateNetBEUI()
{
    HRESULT hr = S_OK;

    switch(m_eNBFState)
    {
    case eStateDisable:
        hr = HrDisableNetBEUI();
        break;
    case eStateEnable:
        hr = HrEnableNetBEUI();
        break;
    default:
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\advstrs.cpp ===
#include "pch.h"
#pragma hdrstop
#include "advstrs.h"

const WCHAR c_szRegKeyParamsFromInstance[]     = L"Ndi\\Params";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\advanced.h ===
#pragma once
#include "netcfgx.h"
#include "global.h"
#include "param.h"

class CAdvancedParams
{
public:

    CAdvancedParams ();
    ~CAdvancedParams ();
    HRESULT HrInit(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);
    BOOL FValidateAllParams(BOOL fDisplayUI, HWND hwndParent);
    BOOL FSave();
    VOID UseAnswerFile(const WCHAR *, const WCHAR *);

protected:
    HKEY                m_hkRoot;   // instance root
    CParam *            m_pparam;   // current param
    int                 m_nCurSel;  // current item
    CValue              m_vCurrent; // control param value
    BOOL                m_fInit;
    HDEVINFO            m_hdi;
    PSP_DEVINFO_DATA    m_pdeid;

    vector<CParam*> m_listpParam;

    // protected methods
    BOOL FList(WORD codeNotify);
    VOID FillParamList(HKEY hkRoot, HKEY hk);
    VOID SetParamRange();
    int EnumvalToItem(const PWSTR psz);
    int ItemToEnumval(int iItem, PWSTR psz, UINT cb);
    VOID BeginEdit();
    BOOL FValidateCurrParam();
    BOOL FValidateSingleParam(CParam * pparam, BOOL fDisplayUI,
            HWND hwndParent);
    BOOL FSetParamValue(const WCHAR * szName, const WCHAR * const szValue);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\advanced.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "advanced.h"
#include "advstrs.h"
#include "kkcwinf.h"
#include "ncatlui.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"
#include "resource.h"

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::CAdvancedParams (constructor)
//
//  Purpose:    Init some variables.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      The bulk of the setting up occurs in FInit().
//
CAdvancedParams::CAdvancedParams()
:   m_hkRoot(NULL),
    m_pparam(NULL),
    m_nCurSel(0),
    m_fInit(FALSE),
    m_hdi(NULL),
    m_pdeid(NULL)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::HrInit
//
//  Purpose:    Initializes the class.
//
//  Arguments:
//      pnccItem [in]       ptr to my INetCfgComponent interface.
//
//  Returns:    TRUE if initialization was okay, FALSE if couldn't init.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      We needed to separate this from the constructor since the
//              initialization can fail.
//
HRESULT CAdvancedParams::HrInit(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    HKEY hkNdiParamKey;

    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // Open the device's instance key
    HRESULT hr = HrSetupDiOpenDevRegKey(hdi, pdeid,
            DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ALL_ACCESS,
            &m_hkRoot);

    if (SUCCEEDED(hr))
    {
        hr = HrRegOpenKeyEx(m_hkRoot, c_szRegKeyParamsFromInstance,
                KEY_READ | KEY_SET_VALUE, &hkNdiParamKey);
        // populate the parameter list
        if (SUCCEEDED(hr))
        {
            FillParamList(m_hkRoot, hkNdiParamKey);
            RegSafeCloseKey(hkNdiParamKey);
            m_fInit = TRUE;
            m_hdi = hdi;
            m_pdeid = pdeid;
            hr = S_OK;
        }
    }

    TraceErrorOptional("CAdvancedParams::HrInit", hr,
                       HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
    return hr;
}


CAdvancedParams::~CAdvancedParams()
{
    vector<CParam *>::iterator ppParam;

    // delete everything from the list
    for (ppParam = m_listpParam.begin(); ppParam != m_listpParam.end();
         ppParam++)
    {
        delete *ppParam;
    }

    RegSafeCloseKey(m_hkRoot);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::FSave
//
//  Purpose:    Saves values from InMemory storage to the registry.
//
//  Returns:    TRUE if something was changed; FALSE if nothig changed
//              registry.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
BOOL CAdvancedParams::FSave()
{
    vector<CParam *>::iterator ppParam;
    BOOL    fErrorOccurred = FALSE;

    // Save any changed params
    BOOL fDirty = FALSE;
    for (ppParam = m_listpParam.begin(); ppParam != m_listpParam.end();
         ppParam++)
    {
        Assert(ppParam);
        Assert(*ppParam);
        if ((*ppParam)->FIsModified())
        {
            fDirty = TRUE;
            TraceTag(ttidNetComm, "Parameter %S has changed",
                    (*ppParam)->SzGetKeyName());
            if (!(*ppParam)->Apply())
            {
                fErrorOccurred = TRUE;
            }
        }
    }

    if (fErrorOccurred)
    {
        TraceTag(ttidError, "An error occurred saving adapter's %S "
                "parameter.", (*ppParam)->GetDesc());
    }

    return fDirty;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::FillParamList
//
//  Purpose:    Populates the internal parameter list (m_listpParam) with
//              values from the registry.
//
//  Arguments:
//      hk  [in]    The key from which to enumerate the parameters.
//                  Normally obtained from a call to INCC->OpenNdiParamKey().
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvancedParams::FillParamList(HKEY hkRoot, HKEY hk)
{
    DWORD       iValue;
    CParam     *pParam;
    WCHAR       szRegValue[_MAX_PATH];
    DWORD       cchRegValue;
    HRESULT     hr = S_OK;
    FILETIME    ft;

    // Initialize the list.
    m_listpParam.erase(m_listpParam.begin(), m_listpParam.end());

    iValue = 0;

    for (iValue = 0; SUCCEEDED(hr); iValue++)
    {
        cchRegValue = celems(szRegValue);

        hr = HrRegEnumKeyEx(hk, iValue, szRegValue, &cchRegValue,
                            NULL,NULL,&ft);

        if (SUCCEEDED(hr))
        {
            // Create the param structure
            pParam = new CParam;

			if (pParam == NULL)
			{
				return;
			}

            if (pParam->FInit(hkRoot, hk,szRegValue))
            {
                // Add parameter to list.
                m_listpParam.push_back(pParam);
            }
            else
            {
                // couldn't Create() it...
                delete pParam;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::FValidateAllParams
//
//  Purpose:    Validates values of all parameters.  Displays optional
//              error UI.
//
//  Arguments:
//      fDisplayUI  [in]    TRUE - on error, focus is set to offending
//                          parameter and the error message box is displayed.
//                          FALSE - don't do any UI thing on error.  Useful
//                          when the dialog has not been initialized.
//  Returns:    TRUE - everything validated okay.
//              FALSE - error with one of the parameters.  If (fDisplayUI),
//              then the currently displayed parameter is the offending one.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      Calls FValidateSingleParam() for each parameter.
//
BOOL CAdvancedParams::FValidateAllParams(BOOL fDisplayUI, HWND hwndParent)
{
    BOOL fRetval = TRUE;
    for (size_t i = 0; i < m_listpParam.size(); i++)
    {
        if (!FValidateSingleParam(m_listpParam[i], fDisplayUI, hwndParent))
        {
            TraceTag(ttidError, "NetComm : %S parameter failed validation",
                    m_listpParam[i]->GetDesc());
            fRetval = FALSE;
            break;
        }
    }
    return fRetval;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::FValidateSingleParam
//
//  Purpose:    Validates a single parameter.  Displaying an optional
//              error UI.
//
//  Arguments:
//      pparam     [in]     ptr to the param to be validated.  If
//                          (fDisplayUI), then this must be the currently
//                          displayed parameter.
//      fDisplayUI [in]     TRUE - error UI is to be displayed.
//                          FALSE - no error UI is to be displayed.
//
//  Returns:    TRUE - parameter validated okay; FALSE - error in parameter.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      If fDisplayUI, then pparam must be the currently displayed
//              param, since the error box will pop up indicating the error.
//
BOOL CAdvancedParams::FValidateSingleParam(CParam * pparam, BOOL fDisplayUI, HWND hwndParent)
{
    BOOL fRetval = FALSE;
    WCHAR szMin[c_cchMaxNumberSize];
    WCHAR szMax[c_cchMaxNumberSize];
    WCHAR szStep[c_cchMaxNumberSize];

    // ensure we're the currently displayed param if fDisplayUI
    AssertSz(FImplies(fDisplayUI, m_pparam == pparam),
             "Not the currently displayed param.");

    switch (pparam->Validate())
    {
        case VALUE_OK:
            fRetval = TRUE;
            break;

        case VALUE_BAD_CHARS:
            if (fDisplayUI)
            {
                NcMsgBox(hwndParent, IDS_ERROR_CAPTION, IDS_ERR_VALUE_BAD_CHARS,
                         MB_ICONWARNING);
            }
            break;

        case VALUE_EMPTY:
            if (fDisplayUI)
            {
                NcMsgBox(hwndParent, IDS_ERROR_CAPTION, IDS_ERR_VALUE_EMPTY,
                         MB_ICONWARNING);
            }
            break;

        case VALUE_OUTOFRANGE:
            Assert(pparam->GetValue()->IsNumeric());
            pparam->GetMin()->ToString(szMin, celems(szMin));
            pparam->GetMax()->ToString(szMax, celems(szMax));
            if (fDisplayUI)
            {
                // need to select between two dialogs depending on the step size.
                if (pparam->GetStep()->GetNumericValueAsDword() == 1)
                {
                    // no step
                    NcMsgBox(hwndParent, IDS_ERROR_CAPTION, IDS_PARAM_RANGE,
                             MB_ICONWARNING, szMin, szMax);
                }
                else
                {
                    pparam->GetStep()->ToString(szStep, celems(szStep));
                    NcMsgBox(hwndParent, IDS_ERROR_CAPTION, IDS_PARAM_RANGE_STEP,
                             MB_ICONWARNING, szMin, szMax, szStep);
                }
            }
            else
            {
                TraceTag(ttidNetComm, "The parameter %S was out of range. "
                        "Attempting to correct.", pparam->SzGetKeyName());
                // Since we can't bring up UI, we will try to correct the
                // error for the user
                //
                if (pparam->GetMin() > pparam->GetValue())
                {
                    // Try to set to the minimum value.  If it fails, we must still
                    // continue
                    (void) FSetParamValue(pparam->SzGetKeyName(), szMin);
                }

                if (pparam->GetMax() < pparam->GetValue())
                {
                    // Try to set to the maximum value.  If it fails, we must still
                    // continue
                    (void) FSetParamValue(pparam->SzGetKeyName(), szMax);
                }
            }
            break;
        default:
            AssertSz(FALSE,"Hit the default on a switch");
    }

    return fRetval;
}



//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::UseAnswerFile
//
//  Purpose:    Get adapter specific params from the answerfile
//
//  Arguments:
//      szAnswerFile  [in]       path of answerfile
//      szSection     [in]       section within answerfile
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvancedParams::UseAnswerFile(const WCHAR * szAnswerFile,
                              const WCHAR * szSection)
{
    CWInfFile AnswerFile;
    CWInfSection* pSection;
    const WCHAR* szAFKeyName;
    const WCHAR* szAFKeyValue;
    const WCHAR* szAdditionalParamsSection;

    // initialize answer file class
	if (AnswerFile.Init() == FALSE)
	{
        AssertSz(FALSE,"CAdvancedParams::UseAnswerFile - Failed to initialize CWInfFile");
		return;
	}
	
	// Open the answerfile and find the desired section.
    AnswerFile.Open(szAnswerFile);
    pSection = AnswerFile.FindSection(szSection);

    if (pSection)
    {

        // go through all the keys in this section.
        CWInfKey * pInfKey;

        // Now, go to AdditionalParams section and read key values from there
        szAdditionalParamsSection =
                pSection->GetStringValue(L"AdditionalParams", L"");
        Assert(szAdditionalParamsSection);
        if (lstrlenW(szAdditionalParamsSection) < 1)
        {
            TraceTag(ttidNetComm, "No additional params section");
        }
        else
        {
            pSection = AnswerFile.FindSection(szAdditionalParamsSection);
            if (!pSection)
            {
                TraceTag(ttidNetComm, "Specified AdditionalParams section not "
                        "found.");
            }
            else
            {
                for (pInfKey = pSection->FirstKey();
                    pInfKey;
                    pInfKey = pSection->NextKey())
                {
                    // get key name
                    szAFKeyName = pInfKey->Name();
                    szAFKeyValue = pInfKey->GetStringValue(L"");
                    Assert(szAFKeyName && szAFKeyValue);
                    if (!FSetParamValue(szAFKeyName, szAFKeyValue))
                    {
                        TraceTag(ttidNetComm, "Key %S not in ndi\\params. "
                                "Assuming it is a static parameter.",
                                szAFKeyName);
                    }
                } // for
            } // if
        } // if
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::SetParamValue
//
//  Purpose:    Sets a parameter's value
//
//  Arguments:
//      szName    [in]       Name of parameter.
//      szValue   [in]       value (in text) to give param (from Answerfile)
//
//  Returns:    TRUE if szName was found.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
BOOL
CAdvancedParams::FSetParamValue (
    const WCHAR* pszName,
    const WCHAR* const pszValue)
{
    for (size_t i = 0; i < m_listpParam.size(); i++)
    {
        if (0 == lstrcmpiW (pszName, m_listpParam[i]->SzGetKeyName()))
        {
            // found the param
            // set it's current value
            m_listpParam[i]->GetValue()->FromString (pszValue);
            m_listpParam[i]->SetModified (TRUE);
            return TRUE; // found
        }
    }
    return FALSE; // not found
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\advpage.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A D V P A G E . C P P
//
//  Contents:   Contains the advanced page for enumerated net class devices
//
//  Notes:
//
//  Author:     nabilr   16 Mar 1997
//
//  History:    BillBe (24 June 1997) Took over ownership
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "advpage.h"
#include "pagehelp.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"

const DWORD c_cchMaxRegStrLen = 256;

// name of Answerfile section that contains our Additional (adapter-specific)
// parameters.
static const WCHAR c_szDevMgrHelpFile[] = L"devmgr.hlp";

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::CAdvanced (constructor)
//
//  Purpose:    Init some variables.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      The bulk of the setting up occurs in FInit().
//
CAdvanced::CAdvanced()
:   m_plbParams(NULL),
    m_pedtEdit(NULL),
    m_pcbxDrop(NULL),
    m_pbmPresent(NULL),
    m_pbmNotPresent(NULL),
    m_hwndSpin(NULL),
    m_hwndPresentText(NULL),
    m_nCurSel(0),
    m_ctlControlType(CTLTYPE_UNKNOWN),
    m_fInitializing(FALSE)
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CAdvanced::CreatePage
//
//  Purpose:    Creates the advanced page only if there is information
//                  to populate the ui
//
//  Arguments:
//      hdi    [in] SetupApi HDEVINFO for device
//      pdeid  [in] SetupApi PSP_DEVINFO_DATA for device
//
//  Returns:    HPROPSHEETPAGE
//
//  Author:     billbe 1 Jul 1997
//
//  Notes:
//
HPROPSHEETPAGE
CAdvanced::CreatePage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HPROPSHEETPAGE hpsp = NULL;

    if (SUCCEEDED(HrInit(hdi, pdeid)))
    {
        hpsp = CPropSheetPage::CreatePage(DLG_PARAMS, 0);
    }

    return hpsp;

}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::OnInitDialog
//
//  Purpose:    Handler for the WM_INITDIALOG windows message.  Initializes
//              the dialog window.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
//
LRESULT CAdvanced::OnInitDialog(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    const       WCHAR * szText;

    // We are initializing the property page
    m_fInitializing = TRUE;

    // Control Pointers
    m_plbParams = new CListBox(m_hWnd, IDD_PARAMS_LIST);

    if (m_plbParams == NULL)
	{
		return(0);
	}

    m_pedtEdit = new CEdit(m_hWnd, IDD_PARAMS_EDIT);
    m_pcbxDrop = new CComboBox(m_hWnd, IDD_PARAMS_DROP);

    m_pbmPresent = new CButton(m_hWnd, IDD_PARAMS_PRESENT);
    m_pbmNotPresent = new CButton(m_hWnd, IDD_PARAMS_NOT_PRESENT);

    m_hwndSpin        = GetDlgItem(IDD_PARAMS_SPIN);
    Assert(m_hwndSpin);
    m_hwndPresentText = GetDlgItem(IDD_PARAMS_PRESENT_TEXT);
    Assert(m_hwndPresentText);

    // Fill the parameter list box
    FillParamListbox();

    // No current selection
    m_pparam = NULL;

    // Clear the initial params value
    m_vCurrent.Init(VALUETYPE_INT,0);

    // Check if there are any parameters
    if (m_plbParams->GetCount() > 0)
    {
        // Select the first item
        m_plbParams->SetCurSel(0);
        SelectParam();
    }

    m_fInitializing = FALSE;
    return 0;
}


LRESULT CAdvanced::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    if (FValidateCurrParam())
    {
        // Show the saved value
        UpdateParamDisplay();

        Apply();
    }

    TraceError("CAdvanced::OnApply",hr);
    return LresFromHr(hr);
}

LRESULT CAdvanced::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    if (!FValidateCurrParam())
    {
        // Problems with validation.  Keep page from deactivating.
        hr = E_FAIL;
    }

    TraceError("CAdvanced::OnKillActive",hr);
    return LresFromHr(hr);
}


LRESULT CAdvanced::OnEdit(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    // If the edit box contents have changed, call BeginEdit
    if (wNotifyCode == EN_CHANGE)
    {
        BeginEdit();
    }

    TraceError("CAdvanced::OnEdit", hr);
    return LresFromHr(hr);
}


LRESULT CAdvanced::OnDrop(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    // If the combo box contents have changed and we are not initializing
    // (i.e. the user changed it, we didn't) then notify the property
    // sheet
    if ((wNotifyCode == CBN_SELCHANGE) && !m_fInitializing)
    {
        // selection in dropdownbox has changed
        SetChangedFlag();
        BeginEdit();
    }

    TraceError("CAdvanced::OnDrop", hr);
    return LresFromHr(hr);
}


LRESULT CAdvanced::OnPresent(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    if ((wID == IDD_PARAMS_PRESENT && !m_pbmPresent->GetCheck()) ||
        (wID == IDD_PARAMS_NOT_PRESENT && !m_pbmNotPresent->GetCheck() ))
    {
        // selection has changed
        // change the value
        if (wID == IDD_PARAMS_PRESENT)
        {
            m_vCurrent.SetPresent(TRUE);
        }
        else
        {
            GetParamValue();
            m_vCurrent.SetPresent(FALSE);
        }

        // Update the value
        UpdateParamDisplay();

    }

    TraceError("CAdvanced::OnPresent", hr);
    return LresFromHr(hr);
}

LRESULT CAdvanced::OnList(WORD wNotifyCode, WORD wID,
                          HWND hWndCtl, BOOL& fHandled)
{
    LRESULT lr = 0;

    // Changes the listbox selection.  If current value is not
    // valid, then the selection is not changed.
    // Work to do only if selection changes
    if (wNotifyCode == LBN_SELCHANGE)
    {
        // Accept the current value.
        // If it isn't valid, change the selection back
        if (!FValidateCurrParam())
        {
            m_plbParams->SetCurSel(m_plbParams->FindItemData(0, m_pparam));
            // We handled things so set lr to 1;
            lr = 1;
        }
        else
        {
            // Select the new param
            SelectParam();
        }
    }

    return lr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::OnDestroy
//
//  Purpose:    Handles the WM_DESTROY message.  Does general memory
//              releasing and registry key closing.  See ATL docs.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
LRESULT CAdvanced::OnDestroy(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    HRESULT hr = S_OK;
    int cItems, iItem;
    WCHAR *  sz;

    // Clean up memory from list boxes
    AssertSz(m_pcbxDrop, "Combo box should have been created!");
    cItems = m_pcbxDrop->GetCount();
    for (iItem=0; iItem < cItems; iItem++)
    {
        sz = static_cast<WCHAR *>(m_pcbxDrop->GetItemData(iItem));
        delete sz;
    }
    m_pcbxDrop->ResetContent();


    // Clean up
    m_vCurrent.Destroy();

    // Clean up window elements
    delete m_plbParams;
    m_plbParams = NULL;
    delete m_pedtEdit;
    m_pedtEdit = NULL;
    delete m_pcbxDrop;
    m_pcbxDrop = NULL;
    delete m_pbmPresent;
    m_pbmPresent = NULL;
    delete m_pbmNotPresent;
    m_pbmNotPresent = NULL;

    TraceError("CAdvanced::OnDestroy",hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::OnHelp
//
//  Purpose:    Handler for the WM_HELP windows message.
//
//  Author:     BillBe   01 Jul 1998
//
//  Notes:
//
//
LRESULT CAdvanced::OnHelp(UINT uMsg, WPARAM wParam,
                          LPARAM lParam, BOOL& fHandled)
{
    LRESULT lr = 0;
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), c_szDevMgrHelpFile,
                HELP_WM_HELP, reinterpret_cast<UINT_PTR>(g_aHelpIds));
        lr = 1;
    }

    return lr;
}

LRESULT CAdvanced::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                 BOOL& fHandled)
{
    ::WinHelp(reinterpret_cast<HWND>(wParam), c_szDevMgrHelpFile,
            HELP_CONTEXTMENU, reinterpret_cast<UINT_PTR>(g_aHelpIds));

    return TRUE;
}

CAdvanced::~CAdvanced()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::Apply
//
//  Purpose:    Applies values from InMemory storage. to the registry
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::Apply()
{
    if (FSave())
    {
        SP_DEVINSTALL_PARAMS deip;
        // Set the properties change flag in the device info to
        // let the property page host know that the property change function
        // shuld be sent to the driver
        // We can't let any failures here stop us so we ignore
        // return values
        (void) HrSetupDiGetDeviceInstallParams(m_hdi, m_pdeid, &deip);
        deip.FlagsEx |= DI_FLAGSEX_PROPCHANGE_PENDING;
        (void) HrSetupDiSetDeviceInstallParams(m_hdi, m_pdeid, &deip);
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::FillParamListbox
//
//  Purpose:    Populates the UI's parameter listbox using the parameters
//              from m_listpParam.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::FillParamListbox()
{
    vector<CParam *>::iterator ppParam;
    INT        iItem;
    WCHAR      szRegValue[c_cchMaxRegStrLen];

    m_plbParams->ResetContent();

    for (ppParam = m_listpParam.begin(); ppParam != m_listpParam.end();
         ppParam++)
    {
        Assert (*ppParam != NULL);

        // Get text string
        (*ppParam)->GetDescription(szRegValue,celems(szRegValue));

        // Add the description string to the listbox
        iItem = m_plbParams->AddString(szRegValue);
        if (iItem >= 0)
        {
            m_plbParams->SetItemData(iItem,*ppParam);
        }
    }
}


//
//  FValidateCurrParam
//
//  Purpose:
//      Validates the current parameter.  Displays UI and reverts back to
//      original value on error.
//
//  Parameters:
//      None - validates the param currently being edited.
//
//  Notes:
//      How is this different from FValidateSingleParam?  This function
//      is intended to be used when the user is interacting with the
//      current param.  If there's an error with the current parameter,
//      the parameter is reverted back to it's old value (before the user's
//      changes).
//$ REVIEW (t-nabilr) Is it good to revert the user's changes on error?
//                      (see above)
//
BOOL CAdvanced::FValidateCurrParam()
{
    CValue   vPrevious;
    BOOL    fRetval = FALSE;

    // Save the previous param value - so we can restore it
    // if the control value is invalid
    vPrevious.InitNotPresent(m_pparam->GetType());
    vPrevious.Copy(m_pparam->GetValue());

    // Get the current control value and validate it
    GetParamValue();
    m_pparam->GetValue()->Copy(&m_vCurrent);

    if (FValidateSingleParam(m_pparam, TRUE, m_hWnd))
    {
        // Update the modified bit
        m_pparam->SetModified(
            (m_pparam->GetValue()->Compare(m_pparam->GetInitial()) != 0));

        fRetval = TRUE;
    }

    // Restore the original value if there was an error
    if (!fRetval)
        m_pparam->GetValue()->Copy(&vPrevious);
    // Cleanup
    vPrevious.Destroy();

    return fRetval;
}

//  UpdateDisplay
//
//  Purpose:
//      Sets up the screen to display -- and displays -- the current param.
//      Changes the UI's control type, etc.
//
VOID CAdvanced::UpdateDisplay()
{
    int cItems;
    WCHAR * psz;
    // Clean up memory from list boxes
    cItems = m_pcbxDrop->GetCount();
    for (int iItem=0; iItem < cItems; iItem++)
    {
        psz = (WCHAR *)m_pcbxDrop->GetItemData(iItem);
        delete psz;
    }
    m_pcbxDrop->ResetContent();

    // set appropriate Control Type
    switch (m_pparam->GetType())
    {
    case VALUETYPE_ENUM:
        m_ctlControlType = CTLTYPE_DROP;
        break;

    case VALUETYPE_EDIT:
        m_ctlControlType = CTLTYPE_EDIT;
        break;

    case VALUETYPE_DWORD:
        // The spin control only fits up to signed 32-bit values
        // So we must use an edit control for larger numbers
        if (m_pparam->GetMax()->GetDword() > LONG_MAX)
        {
            m_ctlControlType = CTLTYPE_EDIT;
        }
        else
        {
            m_ctlControlType = CTLTYPE_SPIN;
        }
        break;

    case VALUETYPE_KONLY:
        m_ctlControlType = CTLTYPE_NONE;
        break;

    default:
        m_ctlControlType = CTLTYPE_SPIN;
    }
    // Hide all controls
    m_pedtEdit->Show(FALSE);
    m_pcbxDrop->Show(FALSE);
    ::ShowWindow(m_hwndSpin,SW_HIDE);
    ::ShowWindow(m_hwndPresentText,SW_HIDE);
    // Show the appropriate control
    switch (m_ctlControlType)
    {
    case CTLTYPE_EDIT:
        m_pedtEdit->Show(TRUE);
        break;

    case CTLTYPE_DROP:
        m_pcbxDrop->Show(TRUE);
        break;

    case CTLTYPE_SPIN:
        m_pedtEdit->Show(TRUE);
        ::ShowWindow(m_hwndSpin,SW_NORMAL);
        break;

    case CTLTYPE_NONE:
        ::ShowWindow(m_hwndPresentText,SW_NORMAL);
        break;

    default:
        AssertSz(FALSE, "Invalid Control Type");
    }

    // Show the "optional" radio buttons
    if (m_pparam->FIsOptional())
    {
        m_pbmPresent->Show(TRUE);
        m_pbmNotPresent->Show(TRUE);
    }
    else
    {
        m_pbmPresent->Show(FALSE);
        m_pbmNotPresent->Show(FALSE);
    }

    SetParamRange();
    // show the param's value
    UpdateParamDisplay();
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::SelectParam
//
//  Purpose:    Takes the parameter selection from the listbox
//              and makes it the current parameter.  The display is updated
//              to show the newly selected parameter.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::SelectParam()
{
    int         nCurSel;
    register    CParam *pparam;
    int         cItems, iItem;
    PSTR        psz;


    // Determine the new parameter list selection
    nCurSel = m_plbParams->GetCurSel();
    if (nCurSel >= 0)
    {
        // Get the new current parameter
        pparam = (CParam *)m_plbParams->GetItemData(nCurSel);
        Assert(pparam != NULL);

        // only do work if it's not the same parameter.
        if (pparam != m_pparam)
        {
            m_pparam = pparam;
            m_vCurrent.Destroy();
            m_vCurrent.InitNotPresent(m_pparam->GetType());
            m_vCurrent.Copy(m_pparam->GetValue());
            // show the param
            UpdateDisplay();
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::SetParamRange
//
//  Purpose:
//      Sets "range" values for the current param, depending on it's type.
//      For enum values, it reads the enums into a dropbox.
//      For spin control, it sets the min/max and acceleration values.
//      For edit box, it sets the edit style.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::SetParamRange()
{
    DWORD       cbValue;
    DWORD       dwType;
    DWORD       dwStyle;
    DWORD       iValue;
    int         iItem;
    #define     NUM_UDACCELS 3
    UDACCEL     aUDAccel[NUM_UDACCELS];
    UINT        uBase;
    WCHAR *     pszValueName;
    WCHAR       szRegValueName[c_cchMaxRegStrLen];
    DWORD       cchRegValueName;
    WCHAR       szRegValue[c_cchMaxRegStrLen];
    HRESULT hr = S_OK;

    // We are initializing so we need to set a flag so the UI doesn't think
    // it's the user who is changing things
    m_fInitializing = TRUE;

    switch (m_ctlControlType)
    {
    case CTLTYPE_DROP:

        // Reset the combobox
        m_pcbxDrop->ResetContent();

        for (iValue = 0; SUCCEEDED(hr); iValue++)
        {
            cchRegValueName = celems(szRegValueName);
            cbValue = sizeof(szRegValue);

            hr = HrRegEnumValue(m_pparam->GetEnumKey(), iValue, szRegValueName,
                                &cchRegValueName,
                                &dwType, (BYTE *)szRegValue, &cbValue);

            if (SUCCEEDED(hr) && dwType == REG_SZ)
            {
                TraceTag(ttidNetComm, "Enum String %S index %d",
                         szRegValueName, iValue);

                // Got the next registry value, and it's a string.
                pszValueName = new WCHAR[wcslen(szRegValueName) + 1];

				if (pszValueName == NULL)
				{
					break;
				}

                lstrcpyW(pszValueName,szRegValueName);

                // Add the text string
                iItem = m_pcbxDrop->AddString(szRegValue);

                if (iItem >= 0)
                {
                    m_pcbxDrop->SetItemData(iItem,pszValueName);
                }
                else
                {
                    delete pszValueName;
                }
            }
        }
        break;

    case CTLTYPE_SPIN:
        int     nStep;
        int     nMin;
        int     nMax;

        // Set the numeric base
        uBase = m_pparam->GetValue()->IsHex() ? 16 : 10;
        ::SendMessage(m_hwndSpin,UDM_SETBASE,(WPARAM)uBase,0L);

        nStep = m_pparam->GetStep()->GetNumericValueAsDword();
        nMin = m_pparam->GetMin()->GetNumericValueAsSignedInt();
        nMax = m_pparam->GetMax()->GetNumericValueAsSignedInt();

        ::SendMessage(m_hwndSpin,UDM_SETRANGE32, nMin, nMax);

        // Set the range-accelerator values
        aUDAccel[0].nSec = 0;
        aUDAccel[0].nInc = nStep;
        aUDAccel[1].nSec = 1;
        aUDAccel[1].nInc = 2 * nStep;
        aUDAccel[2].nSec = 3;
        aUDAccel[2].nInc = uBase * nStep;

        ::SendMessage(m_hwndSpin, UDM_SETACCEL,NUM_UDACCELS,
                      (LPARAM)(LPUDACCEL)aUDAccel);

        break;


    case CTLTYPE_EDIT:

        m_pedtEdit->LimitText(m_pparam->GetLimitText());

        dwStyle = m_pedtEdit->GetStyle();
        if (m_pparam->FIsUppercase())
            dwStyle |= ES_UPPERCASE;
        else
            dwStyle &= ~ES_UPPERCASE;
        if (m_pparam->FIsOEMText())
            dwStyle |= ES_OEMCONVERT;
        else
            dwStyle &= ~ES_OEMCONVERT;
        if (m_pparam->FIsReadOnly())
            dwStyle |= ES_READONLY;
        else
            dwStyle &= ~ES_READONLY;
        m_pedtEdit->SetStyle(dwStyle);
        break;

    case CTLTYPE_NONE:
        break;

    default:
        AssertSz(FALSE,"Hit default case in CAdvanced::SetParamRange");
    }
    m_fInitializing = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::UpdateParamDisplay
//
//  Purpose:    Updates the value of the parameter on the UI.  Used when
//              the param value has progmatically changed, and needs to be
//              updated on the UI.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      You could use UpdateDisplay to refresh the param value, but
//              UpdateDisplay() does a lot of extra work such as setting
//              the control type.  (BTW, UpdateDisplay calls
//              UpdateParamDisplay().)
//
VOID CAdvanced::UpdateParamDisplay()  // was SetParam
{
    WCHAR   szValue[VALUE_SZMAX];
    int     iItem;

    // We are initializing so we need to set a flag so the UI doesn't think
    // it's the user who is changing things
    m_fInitializing = TRUE;

    // Set present/not present radio button.
    // If an optional value is not present, clear the control and return.
    Assert(m_pparam);
    if (m_pparam->FIsOptional())
    {
        m_pbmPresent->SetCheck(m_vCurrent.IsPresent());
        m_pbmNotPresent->SetCheck(!m_vCurrent.IsPresent());
    }

    // Show/Hide the parameter
    if (!m_pparam->FIsOptional() || m_vCurrent.IsPresent())
    {
        // Show the value
        switch (m_ctlControlType)
        {
        case CTLTYPE_SPIN:
            {
                // The spin control message UDM_SETPOS only handles 16-bit
                // numbers even though the control can handle 32 bit ranges.
                // This means we need to set the number by using the buddy
                // window.
                //
                WCHAR szNumber[c_cchMaxNumberSize];
                m_vCurrent.ToString(szNumber, c_cchMaxNumberSize);
                HWND hwndBuddy = reinterpret_cast<HWND>(::SendMessage(m_hwndSpin,
                                                                 UDM_GETBUDDY,
                                                                 0,
                                                                 0));
                ::SetWindowText(hwndBuddy, szNumber);
            }
            break;

        case CTLTYPE_DROP:
            iItem = EnumvalToItem(m_vCurrent.GetPsz());
            m_pcbxDrop->SetCurSel(iItem);
            break;

        case CTLTYPE_EDIT:
            m_vCurrent.ToString(szValue,VALUE_SZMAX);
            m_pedtEdit->SetText(szValue);
            break;

        case CTLTYPE_NONE:
            break;

        default:
            AssertSz(FALSE,"Invalid control type in function UpdateParamDisplay");
        }
    }
    else
    {
        // Hide the value
        switch (m_ctlControlType)
        {
        case CTLTYPE_EDIT:
        case CTLTYPE_SPIN:
            m_pedtEdit->SetText(L"");
            break;

        case CTLTYPE_DROP:
            m_pcbxDrop->SetCurSel(CB_ERR);
            break;

        case CTLTYPE_NONE:
            break;

        default:
            Assert(FALSE); //DEBUG_TRAP;
        }
    }

    // Remove inhibition
    m_fInitializing = FALSE;

}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::GetParamValue
//
//  Purpose:    Gets the value of the current parameter from the UI and puts
//              in in m_vCurrent.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::GetParamValue()
{
    WCHAR    szValue[VALUE_SZMAX];
    int     iItem;

    // Get the "present" value for an optional param
    if (m_pparam->FIsOptional() && !m_pbmPresent->GetCheck())
    {
        m_vCurrent.SetPresent(FALSE);

        // Not present - don't read the control value
        return;
    }

    // The value is present
    m_vCurrent.SetPresent(TRUE);

    // Get the control value
    switch (m_ctlControlType)
    {

    case CTLTYPE_SPIN:
        {
            // The spin control can handle 32-bit ranges but the message
            // UDM_GETPOS will only return a 16-bit number.  This means we
            // should get the number from the buddy window if we want the
            // exact value.
            //
            WCHAR szBuffer[c_cchMaxNumberSize];
            HWND hwndBuddy = reinterpret_cast<HWND>(::SendMessage(m_hwndSpin,
                                                             UDM_GETBUDDY,
                                                             0,
                                                             0));
            ::GetWindowText(hwndBuddy, szBuffer, c_cchMaxNumberSize);
            m_vCurrent.FromString(szBuffer);
        }
        break;


    case CTLTYPE_EDIT:
        m_pedtEdit->GetText(szValue, VALUE_SZMAX);
        m_vCurrent.FromString(szValue);
        break;

    case CTLTYPE_DROP:
        iItem = m_pcbxDrop->GetCurSel();
        if (iItem == CB_ERR)
            break;
        ItemToEnumval(iItem,szValue,VALUE_SZMAX);
        m_vCurrent.FromString(szValue);
        break;

    case CTLTYPE_NONE:
        break;              // No data to return (present/not present is all were interested in)

    default:
       Assert(FALSE);// DEBUG_TRAP;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::EnumvalToItem
//
//  Purpose:    Converts a combobox string into an integer representing the
//              location withing the drop down combobox (for enums).
//
//  Arguments:
//      psz      [in]       string to look for.
//
//  Returns:    Combobox item number where this string can be found.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
int CAdvanced::EnumvalToItem(const PWSTR psz)
{
    int     cItems;
    int     iItem;
    PWSTR   pszValueName;

    Assert(m_pparam->GetType() == VALUETYPE_ENUM);
    cItems = m_pcbxDrop->GetCount();
    for (iItem = 0; iItem < cItems; iItem++)
    {
        pszValueName = (PWSTR)m_pcbxDrop->GetItemData (iItem);
        if (lstrcmpiW (pszValueName,psz) == 0)
        {
            return iItem;
        }
    }

    // Not found.
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::ItemToEnumval
//
//  Purpose:    Converts the item number within the combobox dropdown
//              into a string.
//
//  Arguments:
//      iItem    [in]       item number within combobox.
//      psz      [out]      ptr to string to populate
//      cch      [in]       length (characters) of psz buffer.
//
//  Returns:    length of string (# of characters) put in psz.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
int CAdvanced::ItemToEnumval(int iItem, PWSTR psz, UINT cch)
{
    PWSTR    pszValueName;

    pszValueName = (PWSTR)m_pcbxDrop->GetItemData (iItem);
    if ((PWSTR)CB_ERR == pszValueName)
    {
        return 0;
    }
    lstrcpynW (psz,pszValueName,cch);
    return lstrlenW (psz);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::
//
//  Purpose:
//
//  Arguments:
//      nID      [in]       ID of thingy.
//      fInstall [in]       TRUE if installing, FALSE otherwise.
//      ppv      [in,out]   Old value is freed and this returns new value.
//
//  Returns:
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//


VOID CAdvanced::BeginEdit()
{
    // Check if we need to update the radio buttons
    if (!m_fInitializing)
    {
        SetChangedFlag();
        if (m_vCurrent.IsPresent() == FALSE)
        {
            // we've begun editing, so select the present radiobutton
            m_vCurrent.SetPresent(TRUE);
            m_pbmPresent->SetCheck(1);
            m_pbmNotPresent->SetCheck(0);
        }
    }

}



//+---------------------------------------------------------------------------
//
//  Function:   HrGetAdvancedPage
//
//  Purpose:    Creates the advanced page for enumerated net devices
//                  This is called by NetPropPageProvider
//
//  Arguments:
//      hdi     [in]   See SetupApi for info
//      pdeid   [in]   See SetupApi for for info
//      phpsp   [out]  Pointer to the handle to the advanced property page
//
//  Returns:
//
//  Author:     billbe 24 June 1997
//
//  Notes:
//
HRESULT
HrGetAdvancedPage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                  HPROPSHEETPAGE* phpsp)
{
    Assert(hdi);
    Assert(pdeid);
    Assert(phpsp);

    HRESULT hr;
    HPROPSHEETPAGE hpsp;

    CAdvanced* padv = new CAdvanced();

    // create the advanced page
    hpsp = padv->CreatePage(hdi, pdeid);

    // if successful set the out param
    if (hpsp)
    {
        *phpsp = hpsp;
        hr = S_OK;
    }
    else
    {
        // Either there is no advanced page to display or there
        // was an error.
        hr = E_FAIL;
        *phpsp = NULL;
        delete padv;
    }

    TraceErrorOptional("HrGetAdvancedPage", hr, E_FAIL == hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\advstrs.h ===
#pragma once

extern const WCHAR c_szRegKeyParamsFromInstance[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\advpage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A D V P A G E . H
//
//  Contents:   Advanced property page for Net Adapters
//
//  Notes:
//
//  Author:     nabilr   11 Mar 1997
//
//  History:    BillBe (24 June 1997) took over ownership
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include "advanced.h"
#include "param.h"
#include "listbox.h"
#include "ncatlps.h"
#include "resource.h"

// WM_USER message to call OnValidate method
static const UINT c_msgValidate  = WM_USER;

enum CTLTYPE    // ctl
{
    CTLTYPE_UNKNOWN,
    CTLTYPE_SPIN,
    CTLTYPE_DROP,
    CTLTYPE_EDIT,
    CTLTYPE_NONE    // use the present radio buttons only..
};


class CAdvanced: public CPropSheetPage, public CAdvancedParams
{
public:
    BEGIN_MSG_MAP(CAdvanced)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        COMMAND_ID_HANDLER(IDD_PARAMS_EDIT, OnEdit)
        COMMAND_ID_HANDLER(IDD_PARAMS_DROP, OnDrop)
        COMMAND_ID_HANDLER(IDD_PARAMS_PRESENT, OnPresent)
        COMMAND_ID_HANDLER(IDD_PARAMS_NOT_PRESENT, OnPresent)
        COMMAND_ID_HANDLER(IDD_PARAMS_LIST, OnList)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
    END_MSG_MAP()

    CAdvanced ();
    ~CAdvanced();
    VOID DestroyPageCallbackHandler()
    {
        delete this;
    }

    BOOL FValidateAllParams(BOOL fDisplayUI);
    VOID Apply();
    HPROPSHEETPAGE CreatePage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);

    // ATL message handlers
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam,
                          BOOL& fHandled);
    LRESULT OnEdit(WORD wNotifyCode, WORD wID,
                   HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDrop(WORD wNotifyCode, WORD wID,
                   HWND hWndCtl, BOOL& fHandled);
    LRESULT OnPresent(WORD wNotifyCode, WORD wID,
                      HWND hWndCtl, BOOL& fHandled);
    LRESULT OnList(WORD wNotifyCode, WORD wID,
                   HWND hWndCtl, BOOL& fHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

private:
    // UI controls
    CListBox *    m_plbParams;   // see listbox.h for class defn
    CEdit *       m_pedtEdit;    // see listbox.h for class defn
    CComboBox *   m_pcbxDrop;    // see listbox.h for class defn
    CButton *     m_pbmPresent;  // present radio button
    CButton *     m_pbmNotPresent; // not present radio button
    HWND          m_hwndSpin;       // spin control
    HWND          m_hwndPresentText; // Text for use with KeyOnly type

    HKEY          m_hkRoot;        // instance root
    int           m_nCurSel;        // current item
    CTLTYPE       m_ctlControlType;       // control type
    CValue        m_vCurrent;         // control param value
    BOOL          m_fInitializing;

    // private methods
    VOID FillParamListbox();
    VOID SelectParam();
    VOID SetParamRange();
    VOID UpdateParamDisplay();
    VOID UpdateDisplay();
    VOID GetParamValue();
    int EnumvalToItem(const PWSTR psz);
    int ItemToEnumval(int iItem, PWSTR psz, UINT cb);
    VOID BeginEdit();
    BOOL FValidateCurrParam();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\global.h ===
#pragma once

// default parameter values
static const WCHAR c_szRegParamDefault[] =  L"Default";

// Required param info
static const WCHAR c_szRegParamDesc[] =  L"ParamDesc";
static const WCHAR c_szRegParamType[] =  L"Type";

// Values for "Type"
static const WCHAR c_szRegParamTypeInt[] =     L"int";
static const WCHAR c_szRegParamTypeLong[] =    L"long";
static const WCHAR c_szRegParamTypeWord[] =    L"word";
static const WCHAR c_szRegParamTypeDword[] =   L"dword";
static const WCHAR c_szRegParamTypeEnum[] =    L"enum";
static const WCHAR c_szRegParamTypeEdit[] =    L"edit";
static const WCHAR c_szRegParamTypeKeyonly[] = L"keyonly";

// General parameter info
static const WCHAR c_szRegParamOptional[] =   L"Optional";
static const WCHAR c_szRegParamHelpFile[] =   L"HelpFile";
static const WCHAR c_szRegParamHelpContext[] = L"HelpContext";

// Ranges for numeric types
static const WCHAR c_szRegParamBase[] =       L"Base";
static const WCHAR c_szRegParamStep[] =       L"Step";
static const WCHAR c_szRegParamMin[] =        L"Min";
static const WCHAR c_szRegParamMax[] =        L"Max";
static const WCHAR c_szRegParamMultiplier[] = L"";
static const WCHAR c_szRegParamParagraph[] =  L"Paragraph";

// Styles for edit types
static const WCHAR c_szRegParamLimitText[] = L"LimitText";
static const WCHAR c_szRegParamOEMText[] =   L"OEMText";
static const WCHAR c_szRegParamUppercase[] = L"Uppercase";
static const WCHAR c_szRegParamReadOnly[] =  L"ReadOnly";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\hwres.h ===
#pragma once
#include "netcfgx.h"
#include "global.h"
#include "param.h"

const int c_nMaxLCStrLen = 128;
const int c_nMaxResStrLen = 50;
const int c_nMaxResCtls = 4;

// Holds a possible IRQ value.
typedef struct tagIRQ_LIST_ELEMENT {
    DWORD dwIRQ;      // A possible value for the IRQ.
    BOOL  fConflict;  // Is there a conflict with another device?
    BOOL  fAllocated; // Is this the IRQ we're currently allocated?
} IRQ_LIST_ELEMENT, *PIRQ_LIST_ELEMENT;

// Holds a possible DMA value.
typedef struct tagDMA_LIST_ELEMENT {
    DWORD dwDMA;      // A possible value for the DMA.
    BOOL  fConflict;  // Is there a conflict with another device?
    BOOL  fAllocated; // Is this the IRQ we're currently allocated?
} DMA_LIST_ELEMENT, *PDMA_LIST_ELEMENT;

// Holds a possible IO base/end pair.
typedef struct tagIO_LIST_ELEMENT {
    DWORD dwIO_Base;
    DWORD dwIO_End;
    BOOL fConflict;
    BOOL fAllocated;
} IO_LIST_ELEMENT, *PIO_LIST_ELEMENT;

// Holds a possible Mem base/end pair.
typedef struct tagMEM_LIST_ELEMENT {
    DWORD dwMEM_Base;
    DWORD dwMEM_End;
    BOOL fConflict;
    BOOL fAllocated;
} MEM_LIST_ELEMENT, *PMEM_LIST_ELEMENT;


// Define the different types of lists.
typedef vector<PIRQ_LIST_ELEMENT>  IRQ_LIST;
typedef IRQ_LIST* PIRQ_LIST;
typedef vector<PDMA_LIST_ELEMENT> DMA_LIST;
typedef DMA_LIST* PDMA_LIST;
typedef vector<PIO_LIST_ELEMENT> IO_LIST;
typedef IO_LIST* PIO_LIST;
typedef vector<PMEM_LIST_ELEMENT> MEM_LIST;
typedef MEM_LIST* PMEM_LIST;


typedef struct {
    RESOURCEID ResourceType;
    RES_DES ResDes;
    union {
        PIRQ_LIST pIRQList;  // These really are STL vectors
        PDMA_LIST pDMAList;
        PIO_LIST  pIOList;
        PMEM_LIST pMEMList;
    };
    size_t pos;  // current index within vector
    size_t applied_pos; // pos that was last applied (the "in-memory" state);
} RESOURCE, *PRESOURCE;

typedef struct tagCONFIGURATION {
    LOG_CONF LogConf;
    BOOL fBoot;
    BOOL fAlloc;
    RESOURCE aResource[c_nMaxResCtls];
    UINT cResource; // number of elements in aResource;
} CONFIGURATION, *PCONFIGURATION;

typedef vector<PCONFIGURATION> CONFIGURATION_LIST;


class CHwRes {
public:

    CHwRes();
    ~CHwRes();
    HRESULT HrInit(const DEVNODE& devnode);
    VOID UseAnswerFile(const WCHAR * const szAnswerfile,
                       const WCHAR * const szSection);
    HRESULT HrValidateAnswerfileSettings(BOOL fDisplayUI);
    BOOL FCommitAnswerfileSettings();


private:
    CONFIGURATION_LIST   m_ConfigList;
    RESOURCE             m_Resource[c_nMaxResCtls];

    // Config Manager stuff
    DEVNODE              m_DevNode;  // devnode for this netcard

    // COM stuff
    INetCfgComponent* m_pnccItem;

    // state flags
    BOOL m_fInitialized;
    BOOL m_fHrInitCalled;
    BOOL m_fDirty;     // Do we need to save?

    // holds answerfile values
    CValue m_vAfDma;
    CValue m_vAfIrq;
    CValue m_vAfMem;
    CValue m_vAfIo;
    CValue m_vAfMemEnd;
    CValue m_vAfIoEnd;

private:
    HRESULT HrInitConfigList ();
    BOOL FInitResourceList(PCONFIGURATION pConfiguration);
    VOID InitIRQList(PIRQ_LIST* ppIRQList, PIRQ_RESOURCE pIRQResource);
    VOID InitDMAList(PDMA_LIST* ppDMAList, PDMA_RESOURCE pDMAResource);
    VOID InitMEMList(PMEM_LIST* ppMEMList, PMEM_RESOURCE pMEMResource);
    VOID InitIOList(PIO_LIST* ppIOList, PIO_RESOURCE pIOResource);
    VOID GetNextElement(PRESOURCE pResource, PVOID *ppeList, BOOL fNext);
    BOOL FValidateAnswerfileResources();
    BOOL FCreateBootConfig(
        CValue * pvMEM,
        CValue * pvMEMEnd,
        CValue * pvIO,
        CValue * pvIOEnd,
        CValue * pvDMA,
        CValue * pvIRQ);
    BOOL FValidateIRQ(PCONFIGURATION pConfig, ULONG ulIRQ);
    BOOL FValidateDMA(PCONFIGURATION pConfig, ULONG ulDMA);
    BOOL FGetIOEndPortGivenBasePort(PCONFIGURATION pConfig, DWORD dwBase,
                                   DWORD* pdwEnd);
    BOOL FGetMEMEndGivenBase(PCONFIGURATION pConfig, DWORD dwBase,
                            DWORD* pdwEnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\listbox.h ===
#pragma once

// Hungarian: lb
class CListBox
{
private:
    HWND m_hDlgItem;

public:
    CListBox(HWND hDlg, INT nIDDlgItem)
    {
        m_hDlgItem = GetDlgItem(hDlg, nIDDlgItem);
    }

    INT GetCount()
    {
        return (int)SendMessage(m_hDlgItem, LB_GETCOUNT, 0L, 0L);
    }

    VOID ResetContent()
    {
        SendMessage(m_hDlgItem, LB_RESETCONTENT, 0L, 0L);
    }

    INT AddString(WCHAR * psz)
    {
        return (int)SendMessage(m_hDlgItem, LB_ADDSTRING, 0L, (LPARAM)psz);
    }

    VOID * GetItemData(INT index)
    {
        return (VOID *)SendMessage(m_hDlgItem, LB_GETITEMDATA, (WPARAM)index, 0L);
    }

    VOID SetItemData(INT index, VOID * data)
    {
        SendMessage(m_hDlgItem, LB_SETITEMDATA, (WPARAM)index, (LPARAM)(data));
    }

    INT FindItemData(INT indexStart, VOID * data)
    {
        // Go through each list item and compare its item data with
        // the data parameter.  Return the index if found or -1 if not
        //
        int nCount = SendMessage(m_hDlgItem, LB_GETCOUNT, 0, 0);

        for (int i = indexStart ; i < nCount; i++)
        {
            if (GetItemData(i) == data)
            {
                return i;
            }
        }

        return -1;
    }

    INT GetCurSel()
    {
        return (int)SendMessage(m_hDlgItem, LB_GETCURSEL, 0L, 0L);
    }

    VOID SetCurSel(int index)
    {
        SendMessage(m_hDlgItem, LB_SETCURSEL, (WPARAM)index, 0L);
    }

};

// Hungarian: bm
class CButton
{
private:
    HWND m_hDlgItem;

public:
    CButton(HWND hDlg, INT nIDDlgItem)
    {
        m_hDlgItem = GetDlgItem(hDlg, nIDDlgItem);
    }

    VOID Show(BOOL fShow)
    {
        ShowWindow(m_hDlgItem, fShow ? SW_SHOW : SW_HIDE);
    }

    BOOL GetCheck()
    {
        return SendMessage(m_hDlgItem, BM_GETCHECK, 0L, 0L);
    }

    VOID SetCheck(BOOL fCheck)
    {
        SendMessage(m_hDlgItem, BM_SETCHECK, (WPARAM)(fCheck), 0L);
    }
};


// Hungarian: cbx
class CComboBox
{
private:
    HWND m_hDlgItem;

public:
    CComboBox(HWND hDlg, INT nIDDlgItem)
    {
        m_hDlgItem = GetDlgItem(hDlg, nIDDlgItem);
    }

    VOID Show(BOOL fShow)
    {
        ShowWindow(m_hDlgItem, fShow ? SW_SHOW : SW_HIDE);
    }

    INT GetCount()
    {
        return (int)SendMessage(m_hDlgItem, CB_GETCOUNT, 0L, 0L);
    }

    VOID ResetContent()
    {
        SendMessage(m_hDlgItem, CB_RESETCONTENT, 0L, 0L);
    }

    VOID * GetItemData(INT index)
    {
        return (void *)SendMessage(m_hDlgItem, CB_GETITEMDATA,
                                  (WPARAM)index, 0L);
    }

    VOID SetItemData(INT index, VOID *data)
    {
        SendMessage(m_hDlgItem, CB_SETITEMDATA, (WPARAM)index, (LPARAM)data);
    }

    INT AddString(WCHAR *psz)
    {
        return (INT)SendMessage(m_hDlgItem, CB_ADDSTRING, 0L, (LPARAM)psz);
    }

    INT GetCurSel()
    {
        return SendMessage(m_hDlgItem, CB_GETCURSEL, 0L, 0L);
    }

    VOID SetCurSel(int index)
    {
        SendMessage(m_hDlgItem, CB_SETCURSEL, (WPARAM)index, 0L);
    }
};


// Hungarian: edt
class CEdit
{
private:
    HWND m_hDlgItem;

public:
    CEdit(HWND hDlg, INT nIDDlgItem)
    {
        m_hDlgItem = GetDlgItem(hDlg, nIDDlgItem);
    }

    VOID Show(BOOL fShow)
    {
        ShowWindow(m_hDlgItem, fShow ? SW_SHOW : SW_HIDE);
    }

    VOID SetStyle(LONG lStyle)
    {
        SetWindowLong(m_hDlgItem, GWL_STYLE, (LPARAM)lStyle);
    }

    LONG GetStyle()
    {
        return GetWindowLong(m_hDlgItem, GWL_STYLE);
    }

    VOID LimitText(INT cchMax)
    {
        SendMessage(m_hDlgItem, EM_LIMITTEXT, (WPARAM)(cchMax), 0L);
    }

    INT GetText(WCHAR * psz, INT cchMax)
    {
        return GetWindowText(m_hDlgItem, psz, cchMax);
    }

    VOID SetText(WCHAR * psz)
    {
        SetWindowText(m_hDlgItem, psz);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\hwres.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "hwres.h"
#include "kkcwinf.h"
#include "ncreg.h"

extern const WCHAR c_szAfIoAddr[];
extern const WCHAR c_szAfIrq[];
extern const WCHAR c_szAfDma[];
extern const WCHAR c_szAfMem[];
extern const WCHAR c_szBusType[];

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::CHwRes
//
//  Purpose:    Class constructor.  (Variable initialization)
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:      Doesn't do much.  Just some member variable initialization.
//              Bulk of the init work is done in HrInit().
//
CHwRes::CHwRes()
:   m_DevNode(NULL),
    m_pnccItem(NULL),
    m_fInitialized(FALSE),
    m_fHrInitCalled(FALSE),
    m_fDirty(FALSE)
{
    m_vAfDma.InitNotPresent(VALUETYPE_DWORD);
    m_vAfIrq.InitNotPresent(VALUETYPE_DWORD);
    m_vAfMem.InitNotPresent(VALUETYPE_DWORD);
    m_vAfMemEnd.InitNotPresent(VALUETYPE_DWORD);
    m_vAfIo.InitNotPresent(VALUETYPE_DWORD);
    m_vAfIoEnd.InitNotPresent(VALUETYPE_DWORD);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::HrInit
//
//  Purpose:    Initialize class
//
//  Arguments:
//      hInst    [in]       Handle to our instance.
//      pnccItem [in]       Our INetCfgComponent.
//
//  Returns:    S_OK - init successfull;
//              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) - no config
//              info for device; E_FAIL - other failure (device not found,etc)
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:      - should initialize all non-ui stuff
//              - initialize configuration and resource lists.
//
HRESULT CHwRes::HrInit(const DEVNODE& devnode)
{
    HRESULT hr = E_FAIL;

    m_fHrInitCalled = TRUE;


    // use the config manager to get devnode
    // Since the devnode might have a problem, e.g. resources not set
    // correctly, we need to retrieve possible phantoms
    //
    CONFIGRET crRet = ERROR_SUCCESS;
    HKEY hkey;

    // We only do work on Isa adapters so we need to get the bustype
    // value from the driver (software) key
    crRet = CM_Open_DevNode_Key(devnode, KEY_READ, 0,
            RegDisposition_OpenExisting, &hkey, CM_REGISTRY_SOFTWARE);

    if (CR_SUCCESS == crRet)
    {
        // Get BusType
        ULONG ulBusType;
        hr = HrRegQueryStringAsUlong(hkey, c_szBusType, c_nBase10,
                &ulBusType);

        RegCloseKey(hkey);

        // If Isa, than we can continue
        if (SUCCEEDED(hr) && (Isa == ulBusType))
        {
            m_DevNode = devnode;
            // read configuration current config info
            hr = HrInitConfigList();
        }
        else
        {
            hr = S_FALSE;
        }

    }

    if (S_OK == hr)
    {
        m_fInitialized = TRUE;
    }

    TraceError("CHwRes::HrInit",
        (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr ||
        S_FALSE == hr) ? S_OK : hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::GetNextElement
//
//  Purpose:    Gets the next (or prev) element in a resource list
//
//  Arguments:
//      pResource [in]       resource list to traverse.
//      ppeList   [out]      the "next" element is returned.
//      fNext     [in]       TRUE - moving fwd in list; FALSE - move bkwrds.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::GetNextElement(PRESOURCE pResource, PVOID *ppeList, BOOL fNext)
{
    UINT size = 0;

    AssertSz(m_fInitialized,
             "GetNextElement called before CHwRes is HrInit'ed");

    Assert(pResource != NULL);
    // get the vector size (dependant on resource type)
    switch (pResource->ResourceType) {
    case ResType_IRQ:
        size = pResource->pIRQList->size();
        break;
    case ResType_DMA:
        size = pResource->pDMAList->size();
        break;
    case ResType_IO:
        size = pResource->pIOList->size();
        break;
    case ResType_Mem:
        size = pResource->pMEMList->size();
        break;
    default:
        Assert(FALSE);
        break;
    }

    // increment/decrement current position within vector
    if (fNext)
    {
        pResource->pos++;
    }
    else
    {
        pResource->pos--;
    }
    // Check for wrapping
    if ((int)(pResource->pos) < 0)
    {
        Assert(pResource->pos == -1);
        Assert(!fNext);  // we're going backwards
        pResource->pos = size-1;
    }
    else if (pResource->pos >= size)
    {
        Assert(pResource->pos == size);
        Assert(fNext);
        pResource->pos = 0;
    }

    // return the current vector element (dependant on res type)
    // REVIEW: do we ever use the element that's gathered below?
    switch (pResource->ResourceType) {
    case ResType_IRQ:
        *ppeList = (*pResource->pIRQList)[pResource->pos];
        break;
    case ResType_DMA:
        *ppeList = (*pResource->pDMAList)[pResource->pos];
        break;
    case ResType_IO:
        *ppeList = (*pResource->pIOList)[pResource->pos];
        break;
    case ResType_Mem:
        *ppeList = (*pResource->pMEMList)[pResource->pos];
        break;
    default:
        Assert(FALSE);
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::HrInitConfigList
//
//  Purpose:    Initialize m_ConfigList (the internal vector of
//              configurations.)
//
//  Returns:    S_OK - init successful;
//              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if no device configs
//              found; E_FAIL otherwise (invalid device, etc.)
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:      "Lists" are actually implemented as STL vectors.
//
HRESULT CHwRes::HrInitConfigList() {
    HRESULT hr = S_OK;
    PCONFIGURATION pConfiguration;
    CONFIGRET ConfigRet;
    LOG_CONF lcCurrent, lcNext;
    UINT iBasicConfig;
    BOOL fFoundConfig = FALSE;

    Assert(NULL != m_DevNode);

    // erase all elements
    m_ConfigList.erase(m_ConfigList.begin(), m_ConfigList.end());

    // Boot Configuration
    if (CM_Get_First_Log_Conf(&lcCurrent, m_DevNode, BOOT_LOG_CONF)
            == CR_SUCCESS)
    {
        TraceTag(ttidNetComm, "Boot config already exists");
        hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
    }

    if (SUCCEEDED(hr))
    {
        // Basic Configurations (may be more than one)
        iBasicConfig = 0;
        ConfigRet = CM_Get_First_Log_Conf(&lcCurrent, m_DevNode, BASIC_LOG_CONF);

#ifdef ENABLETRACE
if (CR_SUCCESS != ConfigRet)
{
    TraceTag(ttidNetComm, "CM_Get_First_Log_conf returned %lX", ConfigRet);
}
#endif // ENABLETRACE
        while (CR_SUCCESS == ConfigRet)
        {
            pConfiguration = new CONFIGURATION;

			if (pConfiguration == NULL)
			{
                TraceError("pConfiguration == NULL", E_FAIL);
                goto error;
			}

            pConfiguration->LogConf = lcCurrent;
            pConfiguration->fBoot = FALSE;
            pConfiguration->fAlloc = FALSE;

            if (!FInitResourceList(pConfiguration))
            {
                hr = E_FAIL;
                TraceError("CHwRes::FInitResourceList",hr);
                goto error;
            }

            m_ConfigList.push_back(pConfiguration);

            // Move on to the next basic config
            iBasicConfig++;
            ConfigRet = CM_Get_Next_Log_Conf(&lcNext, lcCurrent, 0);
            lcCurrent = lcNext;
            fFoundConfig = TRUE;
        }

        if (!fFoundConfig)
        {
            TraceTag(ttidNetComm, "No basic configs");

            // if no config entries found, return ERROR_FILE_NOT_FOUND.
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }

error:
    // ERROR_FILE_NOT_FOUND is an okay error message.
    TraceError("CHwRes::HrInitConfigList",
               (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ||
                HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr ) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FInitResourceList
//
//  Purpose:    Initializes the resource list for a given logical config.
//
//  Arguments:
//      pConfiguration  [in]    configuration who's resource list is to
//                              be initialized.
//
//  Returns:    TRUE if init sucessful; FALSE otherwise.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:      Requires pConfiguration->LogConf to be initialized.
//
BOOL CHwRes::FInitResourceList(PCONFIGURATION pConfiguration)
{
    RES_DES rdCurrent;
    RES_DES rdNext;
    RESOURCEID ResType;
    UINT iResource;
    #define RESOURCE_BUFFER_SIZE 4096
    BYTE Buffer[RESOURCE_BUFFER_SIZE];
    ULONG ulDataSize;
    RESOURCE * pRes;
    CONFIGRET cr;

    Assert(pConfiguration->LogConf);
    rdCurrent = (RES_DES) pConfiguration->LogConf;
    iResource = 0;
    while ((cr = CM_Get_Next_Res_Des(&rdNext, rdCurrent,
                               ResType_All, &ResType, 0)) == CR_SUCCESS)
    {
        rdCurrent = rdNext;
        // Only process this resource if the ignore bit is not set
        if (ResType_Ignored_Bit != ResType)
        {
            pRes = &(pConfiguration->aResource[iResource]);
            pRes->ResDes = rdCurrent;
            pRes->ResourceType = ResType;
            cr = CM_Get_Res_Des_Data_Size(&ulDataSize, rdCurrent, 0);
            if (CR_SUCCESS != cr)
            {
                TraceTag (ttidDefault, "CM_Get_Res_Des_Data_Size returned 0x%08x", cr);
                goto error;
            }

            AssertSz (ulDataSize, "CM_Get_Res_Des_Data_Size returned 0!");
            AssertSz (ulDataSize <= sizeof(Buffer), "CHwRes::FInitResourceList: buffer is too small.");;

            cr = CM_Get_Res_Des_Data(rdCurrent, Buffer, sizeof(Buffer), 0);
            if (CR_SUCCESS != cr)
            {
                TraceTag (ttidDefault, "CM_Get_Res_Des_Data returned 0x%08x", cr);
                goto error;
            }

            // Depending on the ResType, we have to initialize our resource list.
            switch (ResType)
            {
            case ResType_Mem:
                InitMEMList(&(pRes->pMEMList), (PMEM_RESOURCE)Buffer);
                break;
            case ResType_IO:
                InitIOList(&(pRes->pIOList), (PIO_RESOURCE)Buffer);
                break;
            case ResType_DMA:
                InitDMAList(&(pRes->pDMAList), (PDMA_RESOURCE)Buffer);
                break;
            case ResType_IRQ:
                InitIRQList(&(pRes->pIRQList), (PIRQ_RESOURCE)Buffer);
                break;
            default:
                AssertSz (ResType_None != ResType, "ResType_None hit caught in CHwRes::FInitResourceList.");
                break;
            }
            // set the list position to the first element;
            // applied_pos will get copied to pos when dialog box is created.
            pRes->applied_pos = 0;

            iResource++;
            pConfiguration->cResource = iResource;
            if (iResource >= c_nMaxResCtls)
            {
                break; // we're done.
            }
        }
    } //while
    if ((CR_SUCCESS != cr) && (CR_NO_MORE_RES_DES != cr))
    {
        TraceTag (ttidDefault, "CM_Get_Next_Res_Des returned 0x%08x", cr);
        goto error;
    }

    return TRUE;
error:
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::InitIRQList
//
//  Purpose:    Initialize an IRQ resource vector given a config manager
//              resource structure.
//
//  Arguments:
//      ppIRQList    [out]    returns IRQ_LIST that will be created.
//      pIRQResource [in]     IRQ_RESOURCE structure from config manager.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::InitIRQList(PIRQ_LIST* ppIRQList, PIRQ_RESOURCE pIRQResource) {
    PIRQ_DES pIRQHeader;
    PIRQ_RANGE pIRQData;
    PIRQ_LIST_ELEMENT pIRQListElement;

    pIRQHeader = &(pIRQResource->IRQ_Header);
    pIRQData = &(pIRQResource->IRQ_Data[0]);

    // Create a new list.
    *ppIRQList = new IRQ_LIST;

	if (*ppIRQList == NULL)
	{
		return;
	}

    ULONG iData;
    ULONG iIRQ;

    for (iData = 0; iData < pIRQHeader->IRQD_Count; iData++) 
	{
        for (iIRQ = pIRQData[iData].IRQR_Min;
                iIRQ <= pIRQData[iData].IRQR_Max;
                iIRQ++) 
		{
            // For each IRQ that falls within the given range,
            // create new IRQ List Element, populate its fields and insert
            // it into the m_IRQList.
            pIRQListElement = new IRQ_LIST_ELEMENT;

			if (pIRQListElement == NULL)
			{
				continue;
			}

            pIRQListElement->dwIRQ = iIRQ;
            pIRQListElement->fConflict = FALSE;
            pIRQListElement->fAllocated = FALSE;
            (*ppIRQList)->push_back(pIRQListElement);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::InitDMAList
//
//  Purpose:    Initialize a DMA resource vector given a config manager
//              resource structure.
//
//  Arguments:
//      ppDMAList    [out]    returns DMA_LIST that will be created.
//      pDMAResource [in]     DMA_RESOURCE structure from config manager.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::InitDMAList(PDMA_LIST* ppDMAList, PDMA_RESOURCE pDMAResource) {
    PDMA_DES pDMAHeader;
    PDMA_RANGE pDMAData;
    PDMA_LIST_ELEMENT peDMAList;

    pDMAHeader = &(pDMAResource->DMA_Header);
    pDMAData = &(pDMAResource->DMA_Data[0]);

    // Create a new list.
    *ppDMAList = new DMA_LIST;

	if (*ppDMAList == NULL)
	{
		return;
	}

    ULONG iData;  // index of DMA_Range structure we're looking at.
    ULONG iDMA;   // current DMA number we're adding to the list.

    // Go through all the DMA_Range structures, and all DMAs in the
    // specified range to the list.

    for (iData = 0; iData < pDMAHeader->DD_Count; iData++)
    {
        for (iDMA = pDMAData[iData].DR_Min;
                iDMA <= pDMAData[iData].DR_Max;
                iDMA++)
        {
            // For each DMA that falls within the given range,
            // create new DMA List Element, populate its fields and insert
            // it into the DMAList.
            peDMAList = new DMA_LIST_ELEMENT;

			if (peDMAList == NULL)
			{
				continue;
			}

            peDMAList->dwDMA = iDMA;
            peDMAList->fConflict = FALSE;
            peDMAList->fAllocated = FALSE;
            (*ppDMAList)->push_back(peDMAList);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::InitMEMList
//
//  Purpose:    Initialize a MEM resource vector given a config manager
//              resource structure.
//
//  Arguments:
//      ppMEMList    [out]    returns MEM_LIST that will be created.
//      pMEMResource [in]     MEM_RESOURCE structure from config manager.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::InitMEMList(PMEM_LIST* ppMEMList, PMEM_RESOURCE pMEMResource) 
{
    PMEM_DES pMEMHeader;
    PMEM_RANGE pMEMData;
    PMEM_LIST_ELEMENT peMEMList;

    // For easy access
    pMEMHeader = &(pMEMResource->MEM_Header);
    pMEMData = pMEMResource->MEM_Data;

    // Create a new list.
    *ppMEMList = new MEM_LIST;

	if (*ppMEMList == NULL)
	{
		return;
	}
	
    ULONG iData;  // index of MEM_Range structure we're looking at.
    DWORDLONG MEMBase;   // current MEM Base we're adding to the list.
    ULONG cMEMBytes;  // number of bytes required.
    DWORDLONG MEMAlign;

    // Go through all the MEM_Range structures, and all MEMs in the
    // specified range to the list.

    for (iData = 0; iData < pMEMHeader->MD_Count; iData++) 
	{
        MEMAlign = pMEMData[iData].MR_Align;
        cMEMBytes = pMEMData[iData].MR_nBytes;

        // do sanity checks
        if (0 == MEMAlign)
        {
            TraceTag(ttidNetComm, "CHwRes::InitMEMList() - Bogus alignment "
                    "field while processing info from Config Manager.");
            break;
        }

        if (0 == cMEMBytes)
        {
            TraceTag(ttidNetComm, "CHwRes::InitMEMList() - Bogus membytes "
                    "field while processing info from Config Manager.");
            break;
        }

        for (MEMBase = pMEMData[iData].MR_Min;
                MEMBase+cMEMBytes-1 <= pMEMData[iData].MR_Max;
                MEMBase += ~MEMAlign + 1) 
		{
            // For each MEM that falls within the given range,
            // create new MEM List Element, populate its fields and insert
            // it into the MEMList.
            peMEMList = new MEM_LIST_ELEMENT;

			if (peMEMList == NULL)
			{
				continue;
			}

            peMEMList->dwMEM_Base = MEMBase;
            peMEMList->dwMEM_End = MEMBase + cMEMBytes - 1;
            peMEMList->fConflict = FALSE;
            peMEMList->fAllocated = FALSE;
            (*ppMEMList)->push_back(peMEMList);

            // Check for wrapping.
            if (MEMBase >= MEMBase + ~MEMAlign + 1)
            {
                TraceTag(ttidError, "Memory base is greater than Memory "
                        "end!!!");
                break;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::InitIOList
//
//  Purpose:    Initialize an IO resource vector given a config manager
//              resource structure.
//
//  Arguments:
//      ppIOList    [out]    returns IO_LIST that will be created.
//      pIOResource [in]     IO_RESOURCE structure from config manager.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::InitIOList(PIO_LIST* ppIOList, PIO_RESOURCE pIOResource)
{
    PIO_DES pIOHeader;
    PIO_RANGE pIOData;
    PIO_LIST_ELEMENT peIOList;

    // For easy access
    pIOHeader = &(pIOResource->IO_Header);
    pIOData = pIOResource->IO_Data;

    // Create a new list.
    *ppIOList = new IO_LIST;

	if (*ppIOList == NULL)
	{
		return;
	}

    ULONG iData;  // index of IO_Range structure we're looking at.
    DWORDLONG IOBase;   // current IO Base we're adding to the list.
    ULONG cIOBytes;  // number of bytes required.
    DWORDLONG IOAlign;

    // Go through all the IO_Range structures, and all IOs in the
    // specified range to the list.

    for (iData = 0; iData < pIOHeader->IOD_Count; iData++) 
	{
        IOAlign = pIOData[iData].IOR_Align;
        cIOBytes = pIOData[iData].IOR_nPorts;

        // Perform sanity checks.
        if (0 == IOAlign)
        {
            TraceTag(ttidError, "CHwRes::InitIOList - Bogus alignment field "
                    "while processing data from Config Manager.");
            break;
        }

        if (0 == cIOBytes)
        {
            TraceTag(ttidError, "CHwRes::InitIOList - Bogus IObytes field "
                "while processing data from Config Manager.");
            break;
        }

        for (IOBase = pIOData[iData].IOR_Min;
                IOBase+cIOBytes-1 <= pIOData[iData].IOR_Max;
                IOBase += ~IOAlign + 1) 
		{
            // For each IO that falls within the given range,
            // create new IO List Element, populate its fields and insert
            // it into the IOList.
            peIOList = new IO_LIST_ELEMENT;

			if (peIOList == NULL)
			{
				continue;
			}

            peIOList->dwIO_Base = IOBase;
            peIOList->dwIO_End = IOBase + cIOBytes-1;
            peIOList->fConflict = FALSE;
            peIOList->fAllocated = FALSE;
            (*ppIOList)->push_back(peIOList);

            // Check for wrapping.
            if (IOBase >= IOBase + ~IOAlign+1)
            {
                TraceTag(ttidError, "IO base is greater than IO end!!!");
                break;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::UseAnswerFile
//
//  Purpose:    Reads in settings from answerfile and puts them into m_vAf*
//              member variables.
//
//  Arguments:
//      szAnswerFile  [in]     Path to answerfile.
//      szSection     [in]     Section to read within answerfile
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::UseAnswerFile(const WCHAR * const szAnswerFile, const WCHAR * const szSection) {
    CWInfFile       AnswerFile;
    PCWInfSection   pSection;

    DWORD   dw;

    AssertSz(m_fInitialized,
             "UseAnswerFile called before CHwRes class HrInit'ed");

    // initialize answer file class
	if (AnswerFile.Init() == FALSE)
	{
        AssertSz(FALSE,"CHwRes::UseAnswerFile - Failed to initialize CWInfFile");
		return;
	}

    // Open the answerfile and find the desired section.
    AnswerFile.Open(szAnswerFile);
    pSection = AnswerFile.FindSection(szSection);

    // If the answer file section specified is missing
    // we should skip trying to read
    //
    if (pSection)
    {
        // Get the hardware resource keys
        if (pSection->GetIntValue(c_szAfIoAddr, &dw))
        {
            // set this only if the value isn't obviously wrong (i.e. <= 0)
            if (dw > 0)
            {
                m_vAfIo.SetDword(dw);
                m_vAfIo.SetPresent(TRUE);
            }
        }
        if (pSection->GetIntValue(c_szAfIrq, &dw))
        {
            // set this only if the value isn't obviously wrong (i.e. <= 0)
            if (dw > 0)
            {
                m_vAfIrq.SetDword(dw);
                m_vAfIrq.SetPresent(TRUE);
            }
        }
        if (pSection->GetIntValue(c_szAfDma, &dw))
        {
            // set this only if the value isn't obviously wrong (i.e. <= 0)
            if (dw > 0)
            {
                m_vAfDma.SetDword(dw);
                m_vAfDma.SetPresent(TRUE);
            }
        }
        if (pSection->GetIntValue(c_szAfMem, &dw))
        {
            // set this only if the value isn't obviously wrong (i.e. <= 0)
            if (dw > 0)
            {
                m_vAfMem.SetDword(dw);
                m_vAfMem.SetPresent(TRUE);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FValidateAnswerfileSettings
//
//  Purpose:
//      Ensures that the hw resource settings read in from the answerfile
//      are valid.  It will, optionally, raise UI if the properties
//      are invalid.
//
//  Arguments:
//      fDisplayUI    [in]    TRUE, if an error UI is to be displayed if the
//                            answerfile settings are invalid
//
//  Returns:  HRESULT. S_OK if the answerfile settings are valid, S_FALSE if there
//                      are no resources to set, an error code otherwise
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//      Will set the m_vAfMemEnd and m_vAfIoEnd to correspond to
//      m_vAfMem and m_vAfIo.
//
HRESULT
CHwRes::HrValidateAnswerfileSettings(BOOL fDisplayUI)
{
    HRESULT hr = S_OK;

    AssertSz(m_fInitialized, "FValidateAnswerfileSettings called before "
             "CHwRes class HrInit'ed");

    // override current resource settings
    if (!m_vAfDma.IsPresent() &&
        !m_vAfIrq.IsPresent() &&
        !m_vAfIo.IsPresent() &&
        !m_vAfMem.IsPresent())
    {
        // no resources found...
        TraceTag(ttidNetComm, "No Hardware Resources found in answerfile.");
        hr = S_FALSE;
    }
    else
    {
        if (!FValidateAnswerfileResources())
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            TraceError("Error setting adapter resources from "
                    "answerfile.", hr);
        }
        else
        {
            // m_vAfMemEnd and m_vAfIoEnd were set by
            // FValidateAnswerfileResources()
            Assert(FImplies(m_vAfMem.IsPresent(), m_vAfMemEnd.IsPresent()));
            Assert(FImplies(m_vAfIo.IsPresent(), m_vAfIoEnd.IsPresent()));
        }
    }
    TraceError("CHwRes::HrValidateAnswerfileSettings",
        (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FCommitAnswerfileSettings
//
//  Purpose:
//      Commits (to the config manager) the hw resource settings read
//      in from the Answerfile.
//
//  Returns:    FALSE if there were problems writing the BootConfig entry.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FCommitAnswerfileSettings()
{
    AssertSz(m_fInitialized, "FCommitAnswerfileSettings called before "
             "CHwRes class HrInit'ed");

    Assert(FImplies(m_vAfIo.IsPresent(), m_vAfIoEnd.IsPresent()));
    Assert(FImplies(m_vAfMem.IsPresent(), m_vAfMemEnd.IsPresent()));

    // write out forced config entry to the config manager
    BOOL f;
    f = FCreateBootConfig(&m_vAfMem, &m_vAfMemEnd,
                            &m_vAfIo, &m_vAfIo,
                            &m_vAfDma,
                            &m_vAfIrq);
    return f;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FValidateAnswerfileResources
//
//  Purpose:    Validates the resource requirements read in from Answerfile.
//
//  Arguments:
//      nID       [out]       ID of thingy.
//      fInstall [in]       TRUE if installing, FALSE otherwise.
//      ppv      [in,out]   Old value is freed and this returns new value.
//
//  Returns:    TRUE, if resource requirement are valid.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//      Implementation note:  We have a set of resource requirements from
//      the answerfile (stored in m_vAf*).  This method iterates through
//      every logical config (execept alloc or boot ones) and tests to see
//      if the resource requirements are valid in the logical config.
//      If they are, then we can use the resource requirements.  If they're
//      not all valid in any logical config, then we return FALSE.
//
BOOL CHwRes::FValidateAnswerfileResources()
{
    DWORD dwMemEnd;
    DWORD dwIoEnd;
    BOOL fResourceValid;

    AssertSz(m_fInitialized, "FValidateAnswerfileResources called before "
             "CHwRes class HrInit'ed");

    // Configuration List should be initialized
    Assert(0 != m_ConfigList.size());
    PRESOURCE pResource;
    for (size_t iConfig = 0; iConfig < m_ConfigList.size(); iConfig++)
    {
        // we only want Basic configurations, so skip alloc or boot.
        if (m_ConfigList[iConfig]->fBoot || m_ConfigList[iConfig]->fAlloc)
        {
            continue;
        }

        fResourceValid = TRUE;
        if (m_vAfDma.IsPresent())
        {
            if (!FValidateDMA(m_ConfigList[iConfig], m_vAfDma.GetDword()))
            {
                fResourceValid = FALSE;
            }
        }
        if (m_vAfIrq.IsPresent())
        {
            if (!FValidateIRQ(m_ConfigList[iConfig], m_vAfIrq.GetDword()))
            {
                fResourceValid = FALSE;
            }
        }
        if (m_vAfIo.IsPresent())
        {
            if (!FGetIOEndPortGivenBasePort(m_ConfigList[iConfig],
                                           m_vAfIo.GetDword(), &dwIoEnd))
            {
                m_vAfIoEnd.SetPresent(FALSE);
                fResourceValid = FALSE;
            }
            else
            {
                m_vAfIoEnd.SetDword(dwIoEnd);
                m_vAfIoEnd.SetPresent(TRUE);
            }
        }
        if (m_vAfMem.IsPresent())
        {
            if (!FGetMEMEndGivenBase(m_ConfigList[iConfig],
                                    m_vAfMem.GetDword(), &dwMemEnd))
            {
                m_vAfMemEnd.SetPresent(FALSE);
                fResourceValid = FALSE;
            }
            else
            {
                m_vAfMemEnd.SetDword(dwMemEnd);
                m_vAfMemEnd.SetPresent(TRUE);
            }
        }
        if (fResourceValid) break; // found valid one.
    }
    // something has to be present (otherwise don't call this function!)
    Assert(m_vAfIo.IsPresent() || m_vAfIrq.IsPresent() ||
           m_vAfDma.IsPresent() || m_vAfMem.IsPresent());
    return fResourceValid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FCreateBootConfig
//
//  Purpose:    Create and insert a Boot Config entry into the Config
//              Manager.
//
//  Arguments:
//      pvMem     [in]   Memory range base
//      pvMemEnd  [in]   Memory range end
//      pvIo      [in]   Io range base
//      pvIoEnd   [in]   Io range end
//      pvDma     [in]   Dma resource required.
//      pvIrq     [in]   Irq resource required.
//
//  Returns:    TRUE if creation of forced config was successful.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FCreateBootConfig(
    CValue * pvMem,
    CValue * pvMemEnd,
    CValue * pvIo,
    CValue * pvIoEnd,
    CValue * pvDma,
    CValue * pvIrq)
{
    DMA_RESOURCE DMARes;
    IO_RESOURCE IORes;
    MEM_RESOURCE MEMRes;
    IRQ_RESOURCE IRQRes;
    LOG_CONF lcLogConf = NULL;

    AssertSz(pvMem && pvMemEnd && pvIo && pvIoEnd && pvDma && pvIrq,
             "One of the pointer parameters passed to CHwRes::FCreate"
             "BootConfig() is null.");
    AssertSz(m_fInitialized, "FCreateBootConfig called before "
             "CHwRes class HrInit'ed");


    TraceTag(ttidNetComm, "In FCreateBootConfig");

    // Create a boot config
    //
    if (CM_Add_Empty_Log_Conf(&lcLogConf, m_DevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF)
        != CR_SUCCESS)
    {
        TraceTag(ttidNetComm, "Unable to create BOOT_LOG_CONF");
        return FALSE;
    }

    if (pvDma->IsPresent())
    {
        Assert(pvDma->GetDword() > 0);
        // fill out DMAResource structure's header
        ZeroMemory(&DMARes, sizeof(DMARes));
        DMARes.DMA_Header.DD_Count = 0;
        DMARes.DMA_Header.DD_Type = DType_Range;
        DMARes.DMA_Header.DD_Flags = 0;
        DMARes.DMA_Header.DD_Alloc_Chan = pvDma->GetDword();
        // add to boot conf
        CM_Add_Res_Des(NULL, lcLogConf, ResType_DMA, &DMARes,
                       sizeof(DMARes), 0);
        TraceTag(ttidNetComm, "added Dma resource %lX", pvDma->GetDword());
    }
    if (pvIrq->IsPresent())
    {
        Assert(pvIrq->GetDword() > 0);
        // IRQResource structure
        ZeroMemory(&IRQRes, sizeof(IRQRes));
        IRQRes.IRQ_Header.IRQD_Count = 0;
        IRQRes.IRQ_Header.IRQD_Type = IRQType_Range;
        IRQRes.IRQ_Header.IRQD_Flags |=  fIRQD_Edge;
        IRQRes.IRQ_Header.IRQD_Alloc_Num = pvIrq->GetDword();
        IRQRes.IRQ_Header.IRQD_Affinity = 0;
        // add to boot conf
        CM_Add_Res_Des(NULL, lcLogConf, ResType_IRQ, &IRQRes,
                       sizeof(IRQRes), 0);
        TraceTag(ttidNetComm, "added IRQ resource %lX", pvIrq->GetDword());
    }
    if (pvIo->IsPresent()) {
        Assert(pvIo->GetDword() > 0);
        Assert(pvIoEnd->GetDword() > 0);
        ZeroMemory(&IORes, sizeof(IORes));
        IORes.IO_Header.IOD_Count = 0;
        IORes.IO_Header.IOD_Type = IOType_Range;
        IORes.IO_Header.IOD_Alloc_Base = pvIo->GetDword();
        IORes.IO_Header.IOD_Alloc_End = pvIoEnd->GetDword();
        IORes.IO_Header.IOD_DesFlags = fIOD_10_BIT_DECODE;
        // add to boot conf
        CM_Add_Res_Des(NULL, lcLogConf, ResType_IO, &IORes, sizeof(IORes), 0);
        TraceTag(ttidNetComm, "added IO resource %lX-%lX", pvIo->GetDword(),
                pvIoEnd->GetDword());
    }

    if (pvMem->IsPresent()) {
        Assert(pvMem->GetDword() > 0);
        Assert(pvMemEnd->GetDword() > 0);
        ZeroMemory(&MEMRes, sizeof(MEMRes));
        MEMRes.MEM_Header.MD_Count = 0;
        MEMRes.MEM_Header.MD_Type = MType_Range;
        MEMRes.MEM_Header.MD_Alloc_Base = pvMem->GetDword();
        MEMRes.MEM_Header.MD_Alloc_End = pvMemEnd->GetDword();
        MEMRes.MEM_Header.MD_Flags = 0;
        // add to boot conf
        CM_Add_Res_Des(NULL, lcLogConf, ResType_Mem, &MEMRes,
                       sizeof(MEMRes), 0);
        TraceTag(ttidNetComm, "added Memory resource %lX - %lX",
                pvMem->GetDword(), pvMemEnd->GetDword());
    }

    CM_Free_Log_Conf_Handle(lcLogConf);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FValidateIRQ
//
//  Purpose:    Validates that the IRQ given is valid in the given config.
//
//  Arguments:
//      pConfig  [in]    Config to use.
//      dwIRQ    [in]    irq setting to validate.
//
//  Returns:    TRUE if irq setting is valid.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FValidateIRQ(PCONFIGURATION pConfig, ULONG dwIRQ)
{
    PIRQ_LIST pIRQList;

    AssertSz(m_fInitialized, "FValidateIRQ called before "
             "CHwRes class HrInit'ed");

    Assert(pConfig != NULL);
    Assert(dwIRQ > 0);
    // For each IRQ resource in the given config
    //     go through list of valid IRQ looking for given one
    //         if found, return TRUE
    for (size_t iRes = 0; iRes < pConfig->cResource; iRes++)
    {
        if (pConfig->aResource[iRes].ResourceType != ResType_IRQ)
            continue;

        pIRQList = pConfig->aResource[iRes].pIRQList; // for easy access
        for (size_t iIRQ = 0; iIRQ < pIRQList->size(); iIRQ++)
        {
            if ((*pIRQList)[iIRQ]->dwIRQ == dwIRQ)
            {
                return TRUE;  // found it.
            }
        }
    }

    TraceTag(ttidNetComm, "IRQ %lX is not valid for this device", dwIRQ);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FValidateDMA
//
//  Purpose:    Validate that given DMA is valid in given config.
//
//  Arguments:
//      pConfig  [in]   configuration to use
//      dwDMA    [in]   dma setting to validate
//
//  Returns:    TRUE if dma setting is valid
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FValidateDMA(PCONFIGURATION pConfig, ULONG dwDMA)
{
    PDMA_LIST pDMAList;

    AssertSz(m_fInitialized, "FValidateDMA called before "
             "CHwRes class HrInit'ed");

    Assert(pConfig != NULL);
    Assert(dwDMA > 0);
    // For each dma resource in the given config
    //     go through list of valid dma looking for given one
    //         if found, return TRUE
    for (size_t iRes = 0; iRes < pConfig->cResource; iRes++)
    {
        if (pConfig->aResource[iRes].ResourceType != ResType_DMA)
            continue;

        pDMAList = pConfig->aResource[iRes].pDMAList; // for easy access
        for (size_t iDMA = 0; iDMA < pDMAList->size(); iDMA++)
        {
            if ((*pDMAList)[iDMA]->dwDMA == dwDMA)
            {
                return TRUE;
            }
        }
    }

    TraceTag(ttidNetComm, "DMA %lX is not valid for this device", dwDMA);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FGetIOEndPortGivenBasePort
//
//  Purpose:    Get an IO Range given only the BasePort
//
//  Arguments:
//      pConfig  [in]       configuration to use.
//      dwBase   [in]       Io base
//      pdwEnd   [out]      Io end is returned
//
//  Returns:    TRUE if Io base is valid in given config.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FGetIOEndPortGivenBasePort(PCONFIGURATION pConfig, DWORD dwBase,
                               DWORD * pdwEnd)
{
    PIO_LIST pIOList;

    AssertSz(m_fInitialized, "FGetIOEndPortGivenBasePort called before "
             "CHwRes class HrInit'ed");

    Assert(pConfig != NULL);
    Assert(dwBase > 0);
    // For each resource in the given configuration
    //     if it's an IO Resource
    //         Go through the list of valid IO resources looking for
    //          a matching base port
    //              if found, then set the corresponding end port, return TRUE;
    for (size_t iRes = 0; iRes < pConfig->cResource; iRes++)
    {
        // ensure we're looking at an IO type
        if (pConfig->aResource[iRes].ResourceType != ResType_IO)
            continue;

        pIOList = pConfig->aResource[iRes].pIOList; // for easy access
        // go through all IO Elements in this list
        for (size_t iIO = 0; iIO < pIOList->size();  iIO++)
        {
            if ((*pIOList)[iIO]->dwIO_Base == dwBase)
            {
                // found matching IO base port
                *pdwEnd = (*pIOList)[iIO]->dwIO_End;
                return TRUE;
            }
        }
    }
    TraceTag(ttidNetComm, "IO %lX is not valid for this device", dwBase);
    return FALSE; // not found
}


//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FGetMEMEndGivenBase
//
//  Purpose:    Get a MEM range given the Mem base and config.
//
//  Arguments:
//      pConfig  [in]       configuration to use
//      dwBase   [in]       mem base
//      pdwEnd   [out]      mem end is returned.
//
//  Returns:    TRUE if the dwBase is a valid mem setting.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FGetMEMEndGivenBase(PCONFIGURATION pConfig, DWORD dwBase,
                        DWORD * pdwEnd)
{
    PMEM_LIST pMEMList;

    AssertSz(m_fInitialized, "FGetMEMEndGivenBase called before "
             "CHwRes class HrInit'ed");

    Assert(pConfig != NULL);
    Assert(dwBase > 0);
    // For each resource in the given configuration
    //     if it's an MEM Resource
    //         Go through the list of valid MEM resources looking for
    //         a matching base port
    //              if found, then set the corresponding end port,return TRUE;
    for (size_t iRes = 0; iRes < pConfig->cResource; iRes++)
    {
        // ensure we're looking at an MEM type
        if (pConfig->aResource[iRes].ResourceType != ResType_Mem)
            continue;

        pMEMList = pConfig->aResource[iRes].pMEMList; // for easy access
        // go through all MEM Elements in this list
        for (size_t iMEM = 0; iMEM < pMEMList->size();  iMEM++)
        {
            if ((*pMEMList)[iMEM]->dwMEM_Base == dwBase)
            {
                // found matching MEM base addr
                *pdwEnd = (*pMEMList)[iMEM]->dwMEM_End;
                return TRUE;
            }
        }
    }
    TraceTag(ttidNetComm, "Memory %lX is not valid for this device", dwBase);
    return FALSE; // not found
}

//$REVIEW (t-pkoch) this function isn't yet in our custom STL...
//    it can be removed later (when it causes errors)

template<class T> void os_release(vector<T> & v)
{
    for(vector<T>::iterator iterDelete = v.begin() ; iterDelete != v.end() ;
        ++iterDelete)
        delete *iterDelete;
}


CHwRes::~CHwRes()
{
    AssertSz(m_fHrInitCalled, "CHwRes destructor called before "
             "CHwRes::HrInit() called");

    vector<CONFIGURATION *>::iterator ppConfig;
    RESOURCE *  pRes;

    // Delete everything from m_ConfigList.
    for (ppConfig = m_ConfigList.begin(); ppConfig != m_ConfigList.end();
         ppConfig++)
    {
        for (size_t iRes = 0; iRes < (*ppConfig)->cResource; iRes++)
        {
            pRes = &((*ppConfig)->aResource[iRes]);
            switch(pRes->ResourceType)
            {
            case ResType_IRQ:
                os_release(*(pRes->pIRQList));
                delete pRes->pIRQList;
                break;
            case ResType_DMA:
                os_release(*(pRes->pDMAList));
                delete pRes->pDMAList;
                break;
            case ResType_IO:
                os_release(*(pRes->pIOList));
                delete pRes->pIOList;
                break;
            case ResType_Mem:
                os_release(*(pRes->pMEMList));
                delete pRes->pMEMList;
                break;
            }
        }
        delete *ppConfig;
    }


    ReleaseObj(m_pnccItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\pagehelp.h ===
// IDs for the advanced tab in device manager snap-in
// Created 2/19/98 by WGruber NTUA and BillBe NTDEV

#define IDH_NOHELP  (DWORD(-1))
#define IDH_devmgr_advanced_property_list   1101    // list box
#define IDH_devmgr_advanced_editbox     1102    // edit box
#define IDH_devmgr_advanced_drop        1103    // dropdown
#define IDH_devmgr_advanced_spin        1104    // spinner control
#define IDH_devmgr_advanced_present     1105    // option button
#define IDH_devmgr_advanced_not_present     1106    // option button


const DWORD g_aHelpIds[]=
{
    IDD_PARAMS_LIST,    IDH_devmgr_advanced_property_list,  // listBox
    IDD_PARAMS_EDIT,    IDH_devmgr_advanced_editbox,    // edit box
    IDD_PARAMS_DROP,    IDH_devmgr_advanced_drop,   // dropdown
    IDD_PARAMS_SPIN,    IDH_devmgr_advanced_spin,   // spinner control
    IDD_PARAMS_PRESENT, IDH_devmgr_advanced_present,    // option button
    IDD_PARAMS_NOT_PRESENT, IDH_devmgr_advanced_not_present,// option button
    IDD_ADVANCED_TEXT,  IDH_NOHELP, // static text
    IDD_PARAMS_PRESENT_TEXT,IDH_NOHELP,     // static text
    IDD_PARAMS_VALUE,   IDH_NOHELP, // static text
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\param.h ===
#pragma once
#include "value.h"

class CParam
{
public:
    CParam();
    ~CParam();
    BOOL FInit(HKEY hkRoot, HKEY hkNdiParam, PWSTR pszSubKey);
    BOOL Apply(); // Applies from Temp storage to In-Memory storage.
    UINT Validate();
    VOID GetDescription(WCHAR *sz, UINT cch);
    VOID GetHelpFile(WCHAR *sz, UINT cch);
    VOID AlertPrintfRange(HWND hDlg);

    // Data accessors
    VALUETYPE GetType() {return m_eType;}
    BOOL FIsOptional() {return m_fOptional;};
    BOOL FIsModified() {return m_fModified;}
    BOOL FIsReadOnly() {return m_fReadOnly;}
    BOOL FIsOEMText()  {return m_fOEMText;}
    BOOL FIsUppercase() {return m_fUppercase;}

    CValue * GetInitial() {return &m_vInitial;}
    CValue * GetValue() {return &m_vValue;}
    CValue * GetMin() {return &m_vMin;}
    CValue * GetMax() {return &m_vMax;}
    CValue * GetStep() {return &m_vStep;}

    HKEY GetEnumKey()
    {
        AssertH(VALUETYPE_ENUM == m_eType);
        return m_hkEnum;
    }

    UINT GetLimitText()
    {
        AssertH((VALUETYPE_EDIT == m_eType) || (VALUETYPE_DWORD == m_eType)
                || (VALUETYPE_LONG == m_eType));
        return m_uLimitText;
    }
    WCHAR * GetDesc()
    {
        return m_pszDesc;
    }

    PCWSTR SzGetKeyName()
    {
        return m_pszKeyName;
    }


    VOID SetModified(BOOL f) {m_fModified = f;}


    // Values
    CValue      m_vValue;         // current control value
    CValue      m_vInitial;       // initial value read in

    // Range info (type-specific)
    CValue      m_vMin;           // numeric types - minimum value
    CValue      m_vMax;           // numeric types - maximum value
    CValue      m_vStep;          // numeric types - step value

private:
    VOID InitParamType(PTSTR lpszType);

    BOOL        m_fInit;

    // General info
    VALUETYPE   m_eType;           // value type
    HKEY        m_hkRoot;         // instance root
    WCHAR *     m_pszKeyName;     // Name of subkey for this parameter.
    WCHAR *     m_pszDesc;        // value description
    WCHAR *     m_pszHelpFile;    // help file
    DWORD       m_dwHelpContext;  // help context id

    UINT        m_uLimitText;     // edit type - max chars
    HKEY        m_hkEnum;         // enum type - registry param enum subkey

    // Flags
    BOOL        m_fOptional;    // optional paramter
    BOOL        m_fModified;    // param has been modified
    BOOL        m_fReadOnly;    // edit type - read-only
    BOOL        m_fOEMText;     // edit type - oem convert
    BOOL        m_fUppercase;   // edit type - uppercase
};

const DWORD c_cchMaxNumberSize = 16;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\param.cpp ===
#include "pch.h"
#pragma hdrstop
#include "global.h"
#include "ncreg.h"
#include "ncstring.h"
#include "ncxbase.h"
#include "param.h"
#include "resource.h"
#include "util.h"

CParam::CParam ()
:   m_fInit(FALSE),
    m_eType(VALUETYPE_UNKNOWN),
    m_hkRoot(NULL),
    m_pszKeyName(NULL),
    m_pszDesc(NULL),
    m_pszHelpFile(NULL),
    m_dwHelpContext(0),
    m_uLimitText(0),
    m_hkEnum(NULL),
    m_fOptional(FALSE),
    m_fModified(FALSE),
    m_fReadOnly(FALSE),
    m_fOEMText(FALSE),
    m_fUppercase(FALSE)
{
}

BOOL CParam::FInit(HKEY hkRoot, HKEY hkNdiParam, PWSTR pszSubKey)
{
    HRESULT hr = S_OK;
    DWORD   cbBuf;
    BYTE    szBuf[VALUE_SZMAX];
    UINT    uTemp;
    DWORD   dwType;
    HKEY    hkParamInfo;

    // store hkRoot, pszSubKey for future reference
    m_hkRoot = hkRoot;
    m_pszKeyName = new WCHAR[lstrlenW (pszSubKey) + 1];

	if (m_pszKeyName == NULL)
	{
		return(FALSE);
	}

    lstrcpyW (m_pszKeyName, pszSubKey);

    hr = HrRegOpenKeyEx(hkNdiParam, pszSubKey, KEY_READ,
                        &hkParamInfo);
    if (FAILED(hr))
    {
        hkParamInfo = NULL;
        goto error;
    }

    // Get the parameter type, use EDIT if none specified
    // range values (etc.) for the type. If 'type' is empty
    // or invalid, the "int" type is returned.
    cbBuf = sizeof(szBuf);
    hr = HrRegQueryValueEx(hkParamInfo,c_szRegParamType,&dwType,szBuf,&cbBuf);
    if (SUCCEEDED(hr))
    {
        AssertSz(REG_SZ == dwType,
                 "Expecting REG_SZ type but got something else.");
    }
    else
    {
        ((PWCHAR)szBuf)[0] = L'\0';
    }

    InitParamType((PTSTR)szBuf);

    // Get the description text
    cbBuf = sizeof(szBuf);
    hr = HrRegQueryValueEx(hkParamInfo,c_szRegParamDesc,&dwType,szBuf,&cbBuf);
    if (SUCCEEDED(hr))
    {
        AssertSz(REG_SZ == dwType,
                 "Expecting REG_SZ type but got something else.");
    }
    else
    {
        // No description string
        lstrcpyW((WCHAR *)szBuf, SzLoadIds (IDS_NO_DESCRIPTION));
    }

    // allocate and store description
    m_pszDesc = new WCHAR[lstrlenW((WCHAR *)szBuf) + 1];

	if (m_pszDesc == NULL)
	{
		return(FALSE);
	}

    lstrcpyW(m_pszDesc, (WCHAR *)szBuf);

    // Optional parameter
    m_fOptional = FALSE;
    uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamOptional,0);

    if (uTemp != 0)
    {
        m_fOptional = TRUE;
    }

    // Help file info
    m_pszHelpFile = NULL;
    m_dwHelpContext = 0;
    cbBuf = sizeof(szBuf);
    hr = HrRegQueryValueEx(hkParamInfo,c_szRegParamHelpFile,&dwType,
                           szBuf,&cbBuf);
    if (SUCCEEDED(hr))
    {
        AssertSz(REG_SZ == dwType,
                 "Expecting REG_SZ type but got something else.");
        m_pszHelpFile = new WCHAR[lstrlenW((WCHAR *)szBuf)+1];

		if (m_pszHelpFile == NULL)
		{
			return(FALSE);
		}

        lstrcpyW(m_pszHelpFile, (WCHAR *)szBuf);
        m_dwHelpContext = Reg_QueryInt(hkParamInfo,c_szRegParamHelpContext,0);
    }

    // Numeric Type Info
    if (m_vValue.IsNumeric())
    {
        // if no step value in registry, default to 1 (default already
        // set in FInitParamType() )
        m_vStep.FLoadFromRegistry(hkParamInfo,c_szRegParamStep);
        if (m_vStep.GetNumericValueAsDword() == 0)
        {
            m_vStep.SetNumericValue(1);
        }

        // get m_vMix and m_vMax from registry (no effect if doesn't exist,
        // defaults were set in FInitParamType() )
        (VOID) m_vMin.FLoadFromRegistry(hkParamInfo,c_szRegParamMin);
        (VOID) m_vMax.FLoadFromRegistry(hkParamInfo,c_szRegParamMax);
    }

    // Edit type info
    else if (m_eType == VALUETYPE_EDIT)
    {
        // Limit text
        m_uLimitText = VALUE_SZMAX-1;
        uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamLimitText,m_uLimitText);
        if ((uTemp > 0) && (uTemp < VALUE_SZMAX))
        {
            m_uLimitText = uTemp;
        }

        // Read-only
        m_fReadOnly = FALSE;
        uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamReadOnly,0);
        if (uTemp != 0)
        {
            m_fReadOnly = TRUE;
        }

        // OEMText
        m_fOEMText = FALSE;
        uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamOEMText,0);
        if (uTemp != 0)
        {
            m_fOEMText = TRUE;
        }

        // Uppercase
        m_fUppercase = FALSE;
        uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamUppercase,0);
        if (uTemp != 0)
        {
            m_fUppercase = TRUE;
        }
    }

    // Enum type info
    else if (m_eType == VALUETYPE_ENUM)
    {
        hr = HrRegOpenKeyEx(hkParamInfo,c_szRegParamTypeEnum,KEY_READ,
                            &m_hkEnum);
        if (FAILED(hr))
        {
            m_hkEnum = NULL;
        }
    }

    // Current Value
    m_fModified = FALSE;
    if (!m_vValue.FLoadFromRegistry(m_hkRoot,m_pszKeyName,hkParamInfo))
    {
        // Use default value (current value not in registry)
        if (!m_vValue.FLoadFromRegistry(hkParamInfo,c_szRegParamDefault))
        {
            // If no default in registry, assume a decent value
            if (m_vValue.IsNumeric())
            {
                m_vValue.Copy(&m_vMin);
            }
            else
            {
                m_vValue.FromString(L"");
            }
        }

        // Keep not-present state of optional parameters.
        // Mark required parameters modified since we read the default.
        if (m_fOptional)
        {
            m_vValue.SetPresent(FALSE);
        }
        else
        {
            m_fModified = TRUE;
        }
    }

    // Save initial value for comparison in Param_Validate
    // The initial value is always valid - in case the user hand-mucks
    // it to something outside the specified range.
    m_vInitial.Copy(&m_vValue);

    m_fInit = TRUE;
    RegSafeCloseKey(hkParamInfo);
    return TRUE;

error:
    // Cleanup done by destructor.
    return FALSE;

}


VOID CParam::InitParamType(PTSTR pszType)
{
    typedef struct tagPTABLE
    {
        const WCHAR * pszToken;
        VALUETYPE        type;
        DWORD       dwMin;
        DWORD       dwMax;
    } PTABLE;
    static PTABLE ptable[] =
    {
        // 1st entry is default if pszType is invalid or unknown
        {c_szRegParamTypeEdit,  VALUETYPE_EDIT,  NULL,           NULL},
        {c_szRegParamTypeInt,   VALUETYPE_INT,   SHRT_MIN, SHRT_MAX},
        {c_szRegParamTypeLong,  VALUETYPE_LONG,  LONG_MIN,(DWORD)LONG_MAX},
        {c_szRegParamTypeWord,  VALUETYPE_WORD,  0,              USHRT_MAX},
        {c_szRegParamTypeDword, VALUETYPE_DWORD, 0,              ULONG_MAX},
        {c_szRegParamTypeEnum,  VALUETYPE_ENUM,  NULL,           NULL},
        {c_szRegParamTypeKeyonly, VALUETYPE_KONLY, NULL,           NULL}
    };

    UINT    i;
    PTABLE* pt;

    Assert(pszType != NULL);

    // Lookup token in param table
    for (i=0; i < celems(ptable); i++)
    {
        pt = &ptable[i];
        if (lstrcmpiW(pt->pszToken,pszType) == 0)
        {
            break;
        }
    }
    if (i >= celems(ptable))
    {
        pt = &ptable[0];
    }

    // Table default values
    m_eType = pt->type;
    m_vValue.Init(pt->type,0);
    m_vInitial.Init(pt->type,0);

    if (m_vValue.IsNumeric())
    {
        m_vMin.Init(pt->type,pt->dwMin);
        m_vMax.Init(pt->type,pt->dwMax);
        m_vStep.Init(pt->type,1);
    }
    else
    {
        m_vMin.Init(pt->type,NULL);
        m_vMax.Init(pt->type,NULL);
        m_vStep.Init(pt->type,0);
    }
}

// Notes: Don't close m_hkRoot since other's may have copies of it.
//        ~CAdvanced will close it.
//
CParam::~CParam()
{
    // Close the enum subkey
    RegSafeCloseKey(m_hkEnum);

    // free strings
    delete m_pszKeyName;
    delete m_pszDesc;
    delete m_pszHelpFile;

    // free values
    m_vValue.Destroy();
    m_vInitial.Destroy();
    m_vMin.Destroy();
    m_vMax.Destroy();
    m_vStep.Destroy();
}

// Applies from In-Memory storage to registry
BOOL CParam::Apply() {
    AssertSz(m_fInit,"CParam not FInit()'ed.");
    if (!FIsModified())
    {
        return TRUE;  // not modified, don't save.
    }
    Assert(0 == m_vValue.Compare(&m_vValue));
    m_fModified = FALSE;
    m_vInitial.Copy(&m_vValue);
    return m_vValue.FSaveToRegistry(m_hkRoot,m_pszKeyName);

}


UINT CParam::Validate()
{
    AssertSz(m_fInit, "CParam not FInit()'ed.");
    // Equal to the initial value is ok
    if (m_vValue.Compare(&m_vInitial) == 0)
    {
        return VALUE_OK;
    }

    // Unpresent-optional value is ok
    if (FIsOptional() && !m_vValue.IsPresent())
    {
        return VALUE_OK;
    }

    // Invalid characters
    if (m_vValue.IsInvalidChars())
    {
        return VALUE_BAD_CHARS;
    }

    // Empty required field
    if (m_vValue.IsEmptyString() && m_vValue.IsPresent() && (m_vValue.GetType() != VALUETYPE_KONLY))
    {
        return VALUE_EMPTY;
    }

    // Numeric range
    if (m_vValue.IsNumeric())
    {
        // If value is < min, out of range
        if (m_vValue.Compare(&m_vMin) < 0)
        {
            return VALUE_OUTOFRANGE;
        }

        // If value is > max, out of range
        if (m_vValue.Compare(&m_vMax) > 0)
        {
            return VALUE_OUTOFRANGE;
        }

        // Step-range
        Assert(m_vStep.GetNumericValueAsDword() != 0);

        if (((m_vValue.GetNumericValueAsDword() -
             m_vMin.GetNumericValueAsDword())
             % m_vStep.GetNumericValueAsDword()) != 0)
        {
            return VALUE_OUTOFRANGE;
        }
    }

    return VALUE_OK;
}


VOID CParam::GetDescription(WCHAR * sz, UINT cch)
{
    AssertSz(m_fInit, "CParam not FInit()'ed.");
    lstrcpynW(sz, m_pszDesc, cch);
}

VOID CParam::GetHelpFile(WCHAR * sz, UINT cch)
{
    AssertSz(m_fInit, "CParam not FInit()'ed.");
    lstrcpynW(sz, m_pszHelpFile, cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\resource.h ===
#include <ncres.h>

// Error strings
#define IDS_PARAM_RANGE             IDS_NC_NETCOMM + 0
#define IDS_PARAM_RANGE_STEP        IDS_NC_NETCOMM + 1
#define IDS_NO_DESCRIPTION          IDS_NC_NETCOMM + 2
#define IDS_ERR_VALUE_BAD_CHARS     IDS_NC_NETCOMM + 3
#define IDS_ERR_VALUE_EMPTY         IDS_NC_NETCOMM + 4
#define IDS_ERROR_CAPTION           IDS_NC_NETCOMM + 5


// Advanced Property Page
#define DLG_PARAMS                  1505
#define IDD_PARAMS_LIST             1101
#define IDD_PARAMS_EDIT             1102
#define IDD_PARAMS_DROP             1103
#define IDD_PARAMS_SPIN             1104
#define IDD_PARAMS_PRESENT          1105
#define IDD_PARAMS_NOT_PRESENT      1106
#define IDD_ADVANCED_TEXT           1110
#define IDD_PARAMS_PRESENT_TEXT     1111  // Used for "KeyOnly" Type
#define IDD_PARAMS_VALUE            1112
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\netobj.cpp ===
#include "pch.h"
#pragma hdrstop
#include "advanced.h"
#include "hwres.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netcomm.h"
#include "netsetup.h"


HRESULT
HrDoOemUpgradeProcessing(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                         PCWSTR pszAnswerFile, PCWSTR pszAnswerSections)
{
    // Open the driver key
    //
    HKEY hkey;
    HRESULT hr = HrSetupDiOpenDevRegKey(hdi, pdeid,
            DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ALL_ACCESS,
            &hkey);

    if (S_OK == hr)
    {
        TraceTag(ttidNetComm, "Calling OEM Upgrade Code");
        hr = HrOemUpgrade (hkey, pszAnswerFile, pszAnswerSections);
        RegCloseKey(hkey);
    }

    TraceError("HrDoOemUpgradeProcessing", hr);
    return hr;
}

VOID
UpdateAdvancedParametersIfNeeded(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    CAdvancedParams Advanced;

    // initialize advanced params class.  This will load parameters and check
    // if current values exist.  For each parameter with no current value,
    // a modifed flag is set which will cause the default to be written
    // as the current value on FSave.
    //
    if (SUCCEEDED(Advanced.HrInit(hdi, pdeid)))
    {
        // Save any modified values.
        (void) Advanced.FSave();
    }
}

BOOL
ProcessAnswerFile(
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSections,
    HDEVINFO hdi,
    PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    CAdvancedParams Advanced;
    BOOL fAdvanced = FALSE;
    BOOL fResources = FALSE;
    BOOL fModified = FALSE;

    if (pszAnswerFile && pszAnswerSections)
    {
        CHwRes Resources;

        HRESULT hr = Resources.HrInit(pdeid->DevInst);

        // Only continue to use the HwRes class if S_OK is returned.
        //
        if (S_OK == hr)
        {
            Resources.UseAnswerFile(pszAnswerFile, pszAnswerSections);
            fResources = TRUE;
        }
        else
        {
            hr = S_OK;
        }

        // initialize
        if (SUCCEEDED(Advanced.HrInit(hdi, pdeid)))
        {
            // We need the advanced params class.
            fAdvanced = TRUE;
        }


        // If the device has advanced paramters, have the advanced class
        // read the parameters from the answerfile.
        if (fAdvanced)
        {
            Advanced.UseAnswerFile(pszAnswerFile, pszAnswerSections);
        }

        hr = HrDoOemUpgradeProcessing(hdi, pdeid, pszAnswerFile,
                pszAnswerSections);

        if (S_OK == hr)
        {
            fModified = TRUE;
        }

        if (fResources)
        {
            // Validate answerfile params for pResources (hardware resources)
            // and apply if validated.
            hr = Resources.HrValidateAnswerfileSettings(FALSE);
            if (S_OK == hr)
            {
                Resources.FCommitAnswerfileSettings();
                fModified = TRUE;
            }
#ifdef ENABLETRACE
            else
            {
                TraceTag(ttidNetComm, "Error in answerfile concerning "
                        "hardware resources. Base section %S",
                        pszAnswerSections);
            }
#endif
        }

        // Validate the advanced parameters from the answerfile
        // This will attempt to correct bad params.  Even though an
        // error status is returned, it shouldn't stop us and we should
        // still apply changes.
        //
        if (fAdvanced)
        {
            (void) Advanced.FValidateAllParams(FALSE, NULL);
            // Save any advanced params
            fModified = Advanced.FSave();
        }

        TraceError("Netcomm::HrUpdateAdapterParameters",
                (S_FALSE == hr) ? S_OK : hr);
    }

    return fModified;
}

BOOL
FUpdateAdapterParameters(PCWSTR pszAnswerFile,
                         PCWSTR pszAnswerSection,
                         HDEVINFO hdi,
                         PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    CAdvancedParams Advanced;
    BOOL            fAdvanced = FALSE;
    BOOL            fResources = FALSE;

    // initialize
    if (SUCCEEDED(Advanced.HrInit(hdi, pdeid)))
    {
        // We need the advanced params class
        fAdvanced = TRUE;
    }

    if (pszAnswerFile && pszAnswerSection)
    {
        CHwRes Resources;

        HRESULT hr = Resources.HrInit(pdeid->DevInst);

        // Only continue to use the HwRes class if S_OK is returned,
        // otherwise set a flag to ignore the class (Note: ignore the
        // class on S_FALSE as well)
        if (S_OK == hr)
        {
            Resources.UseAnswerFile(pszAnswerFile, pszAnswerSection);
            fResources = TRUE;
        }
        else
        {
            hr = S_OK;
        }

        // If the device has advanced paramters, have the advanced class
        // read the parameters from the answerfile
        if (fAdvanced)
        {
            Advanced.UseAnswerFile(pszAnswerFile, pszAnswerSection);
        }

        hr = HrDoOemUpgradeProcessing(hdi, pdeid, pszAnswerFile,
                pszAnswerSection);

        if (fResources)
        {
            // Validate answerfile params for pResources (hardware resources)
            // and apply if validated
            hr = Resources.HrValidateAnswerfileSettings(FALSE);
            if (S_OK == hr)
            {
                Resources.FCommitAnswerfileSettings();
            }
#ifdef ENABLETRACE
            else
            {
                TraceTag(ttidNetComm, "Error in answerfile concerning "
                        "hardware resources. Base section %S",
                        pszAnswerSection);
            }
#endif
        }

        // Validate the advanced parameters from the answerfile
        // This will attempt to correct bad params.  Even though an
        // error status is returned, it shouldn't stop us and we should
        // still apply changes
        //
        if (fAdvanced)
        {
            (void) Advanced.FValidateAllParams(FALSE, NULL);
        }

        TraceError("Netcomm::HrUpdateAdapterParameters",
                (S_FALSE == hr) ? S_OK : hr);
    }

    // Save any advanced params
    // Note: we have to do this even if there was no answerfile
    // Since the parameters might have defaults
    if (fAdvanced)
    {
        Advanced.FSave();
    }

    // return TRUE if we had advanced parameters or resources updated
    return (fAdvanced || fResources);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\util.h ===
VOID StripSpaces(PWSTR buf);
UINT Reg_QueryInt(HKEY hk, const WCHAR * pszValueName, UINT uDefault);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\value.h ===
#pragma once

enum VALUETYPE
{
    VALUETYPE_UNKNOWN,
    VALUETYPE_INT,
    VALUETYPE_LONG,
    VALUETYPE_WORD,
    VALUETYPE_DWORD,
    VALUETYPE_ENUM,
    VALUETYPE_EDIT,
    VALUETYPE_KONLY
};

#define VALUE_SZMAX     256

#define VALUE_OK            0
#define VALUE_BAD_CHARS     1
#define VALUE_EMPTY         2
#define VALUE_OUTOFRANGE    3

class CValue
{
public:
    CValue();
    ~CValue();
    VOID Init(VALUETYPE type, DWORD value);
    VOID InitNotPresent(VALUETYPE type);
    VOID Destroy();

    BOOL FromString(const WCHAR * const pszValue);
    BOOL ToString(PWSTR psz, UINT cb);

    VOID Copy(CValue *pvSrc);
    int Compare(CValue *v2);

    BOOL FLoadFromRegistry(HKEY hk, const WCHAR * pszValueName, HKEY hkParam = (HKEY)INVALID_HANDLE_VALUE);
    BOOL FSaveToRegistry(HKEY hk, const WCHAR* pszValueName);

    // Value Property accessors
    VOID SetType(VALUETYPE e)
    {
        AssertH(m_fInit);
        m_eType = e;
    }
    VALUETYPE GetType()
    {
        AssertH(m_fInit);
        return m_eType;
    }
    BOOL IsNumeric()
    {
        AssertH(m_fInit);
        return m_fNumeric;
    }
    VOID SetNumeric(BOOL f)
    {
        AssertH(m_fInit);
        m_fNumeric = f;
    }
    BOOL IsHex()
    {
        AssertH(m_fInit);
        return m_fHex;
    }
    VOID SetHex(BOOL f)
    {
        AssertH(m_fInit);
        m_fHex = f;
    }
    BOOL IsPresent()
    {
        AssertH(m_fInit);
        return m_fPresent;
    }
    VOID SetPresent(BOOL f)
    {
        AssertH(m_fInit);
        m_fPresent = f;
    }
    BOOL IsInvalidChars()
    {
        AssertH(m_fInit);
        return m_fInvalidChars;
    }
    VOID SetInvalidChars(BOOL f)
    {
        AssertH(m_fInit);
        m_fInvalidChars = f;
    }
    BOOL IsEmptyString()
    {
        AssertH(m_fInit);
        return m_fEmptyString;
    }
    VOID SetEmptyString(BOOL f)
    {
        AssertH(m_fInit);
        m_fEmptyString = f;
    }

    // Data Accessors
    WORD GetWord()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH (VALUETYPE_WORD == m_eType);
        return m_w;
    }
    VOID SetWord(WORD w)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_WORD == m_eType);
        m_w = w;
    }
    LONG GetLong()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH(VALUETYPE_LONG == m_eType);
        return m_l;
    }
    VOID SetLong(LONG l)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_LONG == m_eType);
        m_l = l;
    }
    short GetShort()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH(VALUETYPE_INT == m_eType);
        return m_n;
    }
    VOID SetShort(short n)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_INT == m_eType);
        m_n = n;
    }
    DWORD GetDword()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH(VALUETYPE_DWORD == m_eType);
        return m_dw;
    }
    VOID SetDword(DWORD dw)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_DWORD == m_eType);
        m_dw = dw;
    }
    int GetNumericValueAsSignedInt();

    DWORD GetNumericValueAsDword();

    VOID SetNumericValue(DWORD dw);
    PWSTR GetPsz()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH(VALUETYPE_EDIT == m_eType || VALUETYPE_ENUM == m_eType);
        return m_psz;
    }
    VOID SetPsz(PWSTR psz)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_EDIT == m_eType || VALUETYPE_ENUM == m_eType);
        m_psz = psz;
    }

private:
    BOOL        m_fInit;
    VALUETYPE   m_eType;
    BOOL        m_fNumeric;
    BOOL        m_fHex;
    BOOL        m_fPresent;
    BOOL        m_fInvalidChars;
    BOOL        m_fEmptyString;
    union {
        DWORD       m_dw;
        LONG        m_l;
        short       m_n;
        WORD        m_w;
        PWSTR       m_psz;
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\util.cpp ===
#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncstring.h"

VOID StripSpaces(WCHAR * buf)
{
    WCHAR *   pch = buf;

    Assert(buf);

    // Find first non-space
    while( (*pch) == L' ' )
    {
        pch++;
    }
    MoveMemory(buf, pch, CbOfSzAndTerm(pch));

    if (lstrlenW(buf) > 0) {
        // Do this only if there's at least one character in string
        pch = buf + lstrlenW(buf);  // Point to null (at end of string)
        Assert(*pch == L'\0');
        pch--;  // Go back one character.

        // As long as character is ' ' go to prev char
        while( (pch >= buf) && (*pch == L' ') )
        {
            pch--;
        }
        Assert (pch >= buf);
        Assert (*pch != L' ');

        // Next position after last char
        pch++;

        // null terminate at last byte
        *pch = L'\0';
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//  Reg_QueryInt
//
/////////////////////////////////////////////////////////////////////////////

UINT Reg_QueryInt(HKEY hk, const WCHAR * pszValueName, UINT uDefault)
{
    DWORD cbBuf;
    BYTE szBuf[32];
    DWORD dwType;
    HRESULT hr;

    cbBuf = sizeof(szBuf);
    hr = HrRegQueryValueEx(hk, pszValueName, &dwType, szBuf, &cbBuf);
    if (SUCCEEDED(hr))
    {
        Assert(dwType == REG_SZ);
        return (UINT)_wtoi((WCHAR *)szBuf);
    }
    else
    {
        return uDefault;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwclicfg\nwclidef.h ===
// Only allow single inclusion of this file.
#pragma once

// Name of the NetWare Config file.
#define NW_CONFIG_DLL_NAME      L"nwcfg.dll"
#define NW_AUTH_PACKAGE_NAME    L"nwprovau"
#define NW_RDR_PERF_DLL_NAME    L"perfnw.dll"
#define NW_RDR_PERF_OPEN        L"OpenNetWarePerformanceData"
#define NW_RDR_PERF_COLLECT     L"CollectNetWarePerformanceData"
#define NW_RDR_PERF_CLOSE       L"CloseNetWarePerformanceData"

// Key values for the NWCWorkstation parameters subkeys
//
#define NW_NWC_PARAM_OPTION_KEY \
    L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\Option"

#define NW_NWC_PARAM_LOGON_KEY  \
    L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\Logon"

#define NW_RDR_SERVICE_PERF_KEY \
    L"System\\CurrentControlSet\\Services\\NWRdr\\Performance"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\netcomm\value.cpp ===
#include "pch.h"
#pragma hdrstop
#include "global.h"
#include "value.h"
#include "util.h"
#include "ncreg.h"
#include "ncstring.h"

static const int c_valueSzMax;

CValue::CValue()
:   m_fInit(FALSE),
    m_eType(VALUETYPE_UNKNOWN),
    m_fNumeric(FALSE),
    m_fHex(FALSE),
    m_fPresent(FALSE),
    m_fInvalidChars(FALSE),
    m_fEmptyString(FALSE),
    m_psz(0)
{
}

CValue::~CValue()
{
#ifdef DBG
    if (!m_fNumeric)
    {
        AssertSz(!m_psz, "m_psz not deallocated before ~CValue called.");
    }
#endif
}

VOID CValue::Init(VALUETYPE type, DWORD value)
{
    Assert(m_fInit == FALSE);
    m_fInit = TRUE;
    SetType(type);
    SetPresent(TRUE);
    SetInvalidChars(FALSE);
    SetEmptyString(FALSE);
    if ((GetType() == VALUETYPE_EDIT) ||
        (GetType() == VALUETYPE_ENUM) ||
        (GetType() == VALUETYPE_KONLY))
    {
        m_fNumeric = FALSE;
        m_psz = NULL;
        FromString(NULL);
    }
    else
    {
        m_fNumeric = TRUE;
        m_dw = value;
    }
}

VOID CValue::InitNotPresent(VALUETYPE type)
{
    Init(type, 0);
    SetPresent(FALSE);
}

VOID CValue::Destroy()
{
    AssertSz(m_fInit, "CValue class not Init'ed");
    if (!IsNumeric())
    {
        delete m_psz;
        m_psz = NULL;
    }
    m_dw = NULL;  // since all other values are a union, this'll clear
                  // out everything.
    m_fInit = FALSE;
}

// copies into current object
VOID CValue::Copy(CValue *pvSrc)
{
    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(pvSrc != NULL);
    AssertSz(m_eType == pvSrc->m_eType,
             "Can't copy from different value types.");
    // Clear out the destination value
    Destroy();
    AssertSz( ! m_psz, "Memory should have been deallocated by Destroy()");

    // Copy contents of source value
    *this = *pvSrc;

    // Reallocate string
    if ( ! pvSrc->IsNumeric())
    {
        if (pvSrc->m_psz)
        {
            // allocate and copy string.
            m_psz = new WCHAR[lstrlenW(pvSrc->m_psz) + 1];

			if (m_psz == NULL)
			{
				Assert(0);
				return;
			}

            lstrcpyW(m_psz,pvSrc->m_psz);
        }
    }
}

VOID CValue::SetNumericValue(DWORD dw)
{
    Assert(m_fInit);
    Assert(m_fNumeric);
    switch(m_eType)
    {
    case VALUETYPE_DWORD:
        SetDword(dw);
        break;
    case VALUETYPE_LONG:
        SetLong(dw);
        break;
    case VALUETYPE_WORD:
        Assert(dw <= USHRT_MAX);
        SetWord(static_cast<WORD>(dw));
        break;
    case VALUETYPE_INT:
        Assert(dw <= SHRT_MAX);
        Assert(dw >= SHRT_MIN);
        SetShort(static_cast<short>(dw));
        break;
    default:
        AssertSz(FALSE, "Invalid numeric type for this value");
        break;
    }
}

BOOL CValue::FromString(const WCHAR * const pszValue)
{
    UINT    uBase;
    PWSTR   pszEnd;
    PWSTR   psz;
    WCHAR   szTemp[VALUE_SZMAX];

    AssertSz(m_fInit, "CValue class not Init'ed");

    // Fixup string
    if (!pszValue)
    {
        szTemp[0] = L'\0';
    }
    else
    {
        lstrcpynW(szTemp,pszValue, celems(szTemp));
        StripSpaces(szTemp);
    }
    psz = szTemp;

    // Get numeric base
    uBase = IsHex() ? 16 : 10;

    // Initialize to valid
    SetInvalidChars(FALSE);
    SetEmptyString(FALSE);

    if ( ! *psz)
    {
        SetEmptyString(TRUE);
    }

    // Convert
    switch (GetType())
    {
        default:
        case VALUETYPE_INT:
            SetShort((short)wcstol(psz,&pszEnd,uBase));

            if (*pszEnd != L'\0')
			{
                SetInvalidChars(TRUE);
			}

            break;

        case VALUETYPE_LONG:
            SetLong(wcstol(psz,&pszEnd,uBase));

            if (*pszEnd != L'\0')
			{
                SetInvalidChars(TRUE);
			}

            break;

        case VALUETYPE_WORD:
            SetWord((WORD)wcstoul(psz,&pszEnd,uBase));

            if (*pszEnd != L'\0')
			{
                SetInvalidChars(TRUE);
			}

            break;

        case VALUETYPE_DWORD:
            SetDword(wcstoul(psz,&pszEnd,uBase));

            if (*pszEnd != L'\0')
			{
                SetInvalidChars(TRUE);
			}

            break;

        case VALUETYPE_ENUM:
        case VALUETYPE_EDIT:
            if (m_psz) 
			{
                delete m_psz;
                m_psz = NULL;
            }

            m_psz = new WCHAR[lstrlenW(psz) + 1];

			if (m_psz == NULL)
			{
				return(FALSE);
			}

            lstrcpyW(m_psz,psz);
            break;

        case VALUETYPE_KONLY:
            break;
    }

    return TRUE;
}

BOOL CValue::ToString(WCHAR * sz, UINT cch)
{
    UINT len;

    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(sz != NULL);

    switch (GetType())
    {
    case VALUETYPE_INT:
        len = (UINT)wsprintfW(sz,L"%d",GetShort());
        Assert(len+1 <= cch); // verify that we allocated enough space
        break;

    case VALUETYPE_LONG:
        len = (UINT)wsprintfW(sz,L"%ld",GetLong());
        Assert(len+1 <= cch);
        break;

    case VALUETYPE_WORD:
        if (IsHex()) {
            len = (UINT)wsprintfW(sz,L"%-2X",GetWord());
        } else {
            len = (UINT)wsprintfW(sz,L"%u",GetWord());
        }
        Assert(len+1 <= cch);
        break;

    case VALUETYPE_DWORD:
        if (IsHex()) {
            len = (UINT)wsprintfW(sz,L"%-2lX",GetDword());
        } else {
            len = (UINT)wsprintfW(sz,L"%lu",GetDword());
        }
        Assert(len+1 <= cch);
        break;

    case VALUETYPE_ENUM:
    case VALUETYPE_EDIT:
        lstrcpynW (sz, m_psz, cch);
        break;

    case VALUETYPE_KONLY:
        Assert(cch >= 2);
        lstrcpynW (sz, L"1", cch);  // If present, store a "1" in the registry.
        break;
    }

    return TRUE;
}

// Compares the current object to another object
// Return values: 0 = both objs are the same
//               <0 = cur obj is less then the other obj
//               >0 = cur obj is greater than the other obj
int CValue::Compare(CValue *pv2)
{
    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(pv2 != NULL);
    Assert(GetType() == pv2->GetType());

    // Present/not present (present is greater than not present)
    if (!IsPresent() && !pv2->IsPresent())
    {
        return 0;
    }
    if (!IsPresent() && pv2->IsPresent())
    {
        return -1;
    }
    if (IsPresent() && !pv2->IsPresent())
    {
        return 1;
    }

    // Compare
    switch (GetType())
    {
    case VALUETYPE_INT:
        if (GetShort() == pv2->GetShort())
        {
            return 0;
        }
        return (GetShort() < pv2->GetShort()) ? -1 : 1;
    case VALUETYPE_LONG:
        if (GetLong() == pv2->GetLong())
        {
            return 0;
        }
        return (GetLong() < pv2->GetLong())? -1 : 1;
    case VALUETYPE_WORD:
        if (GetWord() == pv2->GetWord())
        {
            return 0;
        }
        return (GetWord() < pv2->GetWord())? -1 : 1;
    case VALUETYPE_DWORD:
        if (GetDword() == pv2->GetDword())
        {
            return 0;
        }
        return (GetDword() < pv2->GetDword())? -1 : 1;
    case VALUETYPE_ENUM:
    case VALUETYPE_EDIT:
        if ((GetPsz() != NULL) && (pv2->GetPsz() != NULL))
        {
            return lstrcmpW(GetPsz(),pv2->GetPsz());
        }
        else
        {
            return -2; // REVIEW: what does -2 mean?
        }
    case VALUETYPE_KONLY:
        return 1;
    default:
        Assert(FALSE);
        return 1;  // to stop compiler warning.
    }
}

// if false, then value doesn't change.
BOOL CValue::FLoadFromRegistry(HKEY hk, const WCHAR * pszValueName, HKEY hkParam /* = INVALID_HANDLE_VALUE */)
{
    DWORD   cbBuf;
    WCHAR   szBuf[VALUE_SZMAX];
    DWORD   dwType;
    HRESULT hr = S_OK;
    HKEY    hkTemp;

    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(hk);
    Assert(pszValueName);

    // determine base
    SetHex(FALSE);

    if (hkParam != (HKEY)INVALID_HANDLE_VALUE)
        hkTemp = hkParam;
    else
        hkTemp = hk;

    if (Reg_QueryInt(hkTemp, c_szRegParamBase,10) == 16)
    {
        SetHex(TRUE);
    }

    cbBuf = sizeof(szBuf);

    hr = HrRegQueryValueEx(hk,pszValueName,&dwType,(BYTE*)szBuf,&cbBuf);
    if (SUCCEEDED(hr))
    {
        AssertSz(REG_SZ == dwType,
                 "Expecting REG_SZ, but got something else.");
    }
    if (FAILED(hr) || !szBuf[0])
    {
        return FALSE;
    }

    m_fPresent = TRUE;
    return FromString(szBuf);
}

BOOL CValue::FSaveToRegistry(HKEY hk, const WCHAR * pszValueName)
{
    DWORD   cbBuf;
    WCHAR   szBuf[VALUE_SZMAX];

    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(hk);
    Assert(pszValueName);
    if (!IsPresent())
    {
        RegDeleteValue(hk,pszValueName);
        return TRUE;
    }

    ToString(szBuf,celems(szBuf));
    cbBuf = CbOfSzAndTerm(szBuf);
    return (RegSetValueEx(
                hk,
                pszValueName,
                NULL,
                REG_SZ,
                (LPBYTE)
                szBuf,
                cbBuf)
            == ERROR_SUCCESS);
}

int CValue::GetNumericValueAsSignedInt()
{
    Assert(m_fInit);
    Assert(m_fPresent);
    Assert(m_fNumeric);

    int nret = 0;
    switch (m_eType)
    {
    case VALUETYPE_DWORD:
        nret = GetDword();
        break;
    case VALUETYPE_LONG:
        nret = GetLong();
        break;
    case VALUETYPE_WORD:
        nret = GetWord();
        break;
    case VALUETYPE_INT:
        nret = GetShort();
        break;
    default:
        Assert("Hit default case in GetNumericValueAsSignedInt");
        break;
    }

    return nret;
}

DWORD CValue::GetNumericValueAsDword()
{
    AssertH(m_fInit);
    AssertH(m_fPresent);
    AssertH(m_fNumeric);

    DWORD dwret = 0;
    switch (m_eType)
    {
    case VALUETYPE_DWORD:
        dwret = GetDword();
        break;
    case VALUETYPE_LONG:
        dwret = GetLong();
        break;
    case VALUETYPE_WORD:
        dwret = GetWord();
        break;
    case VALUETYPE_INT:
        dwret = GetShort();
        break;
    default:
        Assert("Hit default case in GetNumericValueAsSignedInt");
        break;
    }

    return dwret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwclicfg\nwcliinf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N W C L I I N F . C P P
//
//  Contents:   NetWare client configuration notify object.
//              Functionality from old INF
//
//  Notes:
//
//  Author:     jeffspr   24 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "lmerr.h"
#include "lmcons.h"
#include "lmserver.h"
#include "ncreg.h"
#include "nwclidef.h"
#include "nwcliobj.h"

extern const WCHAR c_szRegKeyCtlLsa[];

//---[ Constants ]------------------------------------------------------------

const WCHAR c_szConfigDLLName[]         = NW_CONFIG_DLL_NAME;
const WCHAR c_szAuthPackageName[]       = NW_AUTH_PACKAGE_NAME;
const WCHAR c_szParamOptionKeyPath[]    = NW_NWC_PARAM_OPTION_KEY;
const WCHAR c_szParamLogonKeyPath[]     = NW_NWC_PARAM_LOGON_KEY;

const WCHAR c_szNwDocGWHelpName[]       = L"nwdocgw.hlp";
const WCHAR c_szNwDocGWCNTName[]        = L"nwdocgw.cnt";
const WCHAR c_szNwDocHelpName[]         = L"nwdoc.hlp";
const WCHAR c_szNwDocCNTName[]          = L"nwdoc.cnt";

const DWORD c_dwOptionKeyPermissions    = KEY_SET_VALUE | KEY_CREATE_SUB_KEY;

//---[ Prototypes ]-----------------------------------------------------------

// See the function headers for descriptions
//
HRESULT HrAppendNetwareToAuthPackages();
HRESULT HrCreateParametersSubkeys();
HRESULT HrMungeAutoexecNT();
BOOL    FMoveSzToEndOfFile( PSTR pszAutoexecName, PSTR pszMatch);
HRESULT HrAddNetWareToWOWKnownList();
HRESULT HrUpdateLanmanSharedDrivesValue();
HRESULT HrRemoveNetwareFromAuthPackages();
HRESULT HrRemoveNetWareFromWOWKnownList();
HRESULT HrDeleteParametersSubkeys();
HRESULT HrRenameNWDocFiles();



//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrLoadConfigDLL
//
//  Purpose:    Load nwcfg.dll, so we can call some of the functions within.
//              Also, do the GetProcAddress calls for all of the functions
//              that we might need.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT CNWClient::HrLoadConfigDLL()
{
    HRESULT     hr                              = S_OK;

    AssertSz(!m_hlibConfig, "This should not be getting initialized twice");

    TraceTag(ttidNWClientCfgFn, ">> CNWClient::HrLoadConfigDLL");

    m_hlibConfig = LoadLibrary(c_szConfigDLLName);
    if (!m_hlibConfig)
    {
        DWORD dwLastError = GetLastError();

        TraceLastWin32Error("HrLoadConfigDLL() failed");

        // More specific info
        //
        TraceTag(ttidNWClientCfg,
                "HrLoadConfigDLL() - LoadLibrary failed on %S, Err: %d",
                c_szConfigDLLName, dwLastError);

        hr = E_FAIL;
        goto Exit;
    }

    // $$REVIEW: We probably won't need all of these, so make sure that we've
    // cut out the ones that we're no longer using (or have never used).
    //
    m_pfnAppendSzToFile                 = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "AppendSzToFile");
    m_pfnRemoveSzFromFile               = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "RemoveSzFromFile");
    m_pfnGetKernelVersion               = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "GetKernelVersion");
    m_pfnSetEverybodyPermission         = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "SetEverybodyPermission");
    m_pfnlodctr                         = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "lodctr");
    m_pfnunlodctr                       = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "unlodctr");
    m_pfnDeleteGatewayPassword          = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "DeleteGatewayPassword");
    m_pfnSetFileSysChangeValue          = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "SetFileSysChangeValue");
    m_pfnCleanupRegistryForNWCS         = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "CleanupRegistryForNWCS");
    m_pfnSetupRegistryForNWCS           = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "SetupRegistryForNWCS");

    if (!m_pfnAppendSzToFile            || !m_pfnRemoveSzFromFile               ||
        !m_pfnGetKernelVersion          || !m_pfnSetEverybodyPermission         ||
        !m_pfnlodctr                    || !m_pfnunlodctr                       ||
        !m_pfnDeleteGatewayPassword     || !m_pfnSetFileSysChangeValue          ||
        !m_pfnCleanupRegistryForNWCS    || !m_pfnSetupRegistryForNWCS)
    {
        TraceLastWin32Error("HrLoadConfigDLL() - GetProcAddress failed");
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    TraceTag(ttidNWClientCfgFn, "<< CNWClient::HrLoadConfigDLL");
    TraceError("HrLoadConfigDLL", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::FreeConfigDLL
//
//  Purpose:    Free nwcfg.dll, and NULL out the function pointers.
//
//  Arguments:
//      (none)
//
//  Returns:    No return (VOID)
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
VOID CNWClient::FreeConfigDLL()
{
    TraceTag(ttidNWClientCfgFn, ">> CNWClient::FreeConfigDLL()");

    // If we successfully loaded the library, free it.
    if (m_hlibConfig)
    {
        // Free up the library resources.
        FreeLibrary(m_hlibConfig);
        m_hlibConfig = NULL;

        m_pfnAppendSzToFile                 = NULL;
        m_pfnRemoveSzFromFile               = NULL;
        m_pfnGetKernelVersion               = NULL;
        m_pfnSetEverybodyPermission         = NULL;
        m_pfnlodctr                         = NULL;
        m_pfnunlodctr                       = NULL;
        m_pfnDeleteGatewayPassword          = NULL;
        m_pfnSetFileSysChangeValue          = NULL;
        m_pfnCleanupRegistryForNWCS         = NULL;
        m_pfnSetupRegistryForNWCS           = NULL;
    }

    TraceTag(ttidNWClientCfgFn, "<< CNWClient::FreeConfigDLL()");
}

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrInstallCodeFromOldINF
//
//  Purpose:    This contains all of the logic from the old oemnsvnw.inf, or
//              at least calls to helper functions that perform all of the
//              logic. This runs pretty much straight through the old
//              installadapter code.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT CNWClient::HrInstallCodeFromOldINF()
{
    HRESULT hr              = S_OK;
    BOOL    fResult         = FALSE;

    // Get result from NWCFG functions. We won't use it though.
    PWSTR   pszDummy        = NULL;

    TraceTag(ttidNWClientCfgFn, ">> CNWClient::HrInstallCodeFromOldINF()");

    hr = HrLoadConfigDLL();
    if (FAILED(hr))
    {
        // Error traced in the call itself.
        goto Exit;
    }

    // Call the NWCFG function that does (their comment):
    //      "set the FileSysChangeValue to please NETWARE.DRV.
    //       also set win.ini parameter so wfwnet.drv knows we are there."

    fResult = m_pfnSetupRegistryForNWCS(0, NULL, &pszDummy);
    if (!fResult)
    {
        TraceTag(ttidNWClientCfg, "HrInstallCodeFromOldINF() - m_pfnSetupRegistryForNWCS failed");
        goto Exit;
    }

    // Append our name to the Lsa Authentication packages reg value.
    hr = HrAppendNetwareToAuthPackages();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    // Create the required subkeys under the services\NWCWorkstation\parameters
    // key
    //
    hr = HrCreateParametersSubkeys();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    // Munge the autoexec.nt (or autoexec.tmp) file. Pass the function pointers
    // to the munge that will allow it to manipulate the autoexec.nt
    hr = HrMungeAutoexecNT();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    hr = HrAddNetWareToWOWKnownList();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    // If this is the gateway that we're installing, do the work that will
    // allow us to share a redirected resource.
    //
    if (PF_SERVER == m_pf)
    {
        hr = HrUpdateLanmanSharedDrivesValue();
        if (FAILED(hr))
        {
            // Error traced within the function itself.
            //
            goto Exit;
        }

        // On the server build, rename nwdocgw.* to nwdoc.*
        hr = HrRenameNWDocFiles();
        if (FAILED(hr))
        {
            goto Exit;
        }

    }

Exit:
    // This will work even if the handle is NULL.
    FreeConfigDLL();

    TraceTag(ttidNWClientCfgFn, "<< CNWClient::HrInstallCodeFromOldINF()");
    TraceError("CNWClient::HrInstallCodeFromOldINF()", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrRemoveCodeFromOldINF
//
//  Purpose:    This contains all of the remove logic from the old
//              oemnsvnw.inf, or at least calls to helper functions that
//              perform all of the logic. This runs pretty much straight
//              through the old removeadapter code.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT CNWClient::HrRemoveCodeFromOldINF()
{
    HRESULT hr              = S_OK;
    BOOL    fResult         = FALSE;

    // Get result from NWCFG functions. We won't use it though.
    PWSTR   pszDummy        = NULL;

    TraceTag(ttidNWClientCfgFn, ">> CNWClient::HrRemoveCodeFromOldINF()");

    hr = HrLoadConfigDLL();
    if (FAILED(hr))
    {
        // Error traced in the call itself.
        goto Exit;
    }

    // Call the NWCFG function that does (their comment):
    //      "set the FileSysChangeValue to please NETWARE.DRV.
    //       also set win.ini parameter so wfwnet.drv knows we are there."

    fResult = m_pfnCleanupRegistryForNWCS(0, NULL, &pszDummy);
    if (!fResult)
    {
        TraceTag(ttidNWClientCfg, "HrRemoveCodeFromOldINF() - m_pfnCleanupRegistryForNWCS failed");
        goto Exit;
    }

    // Remove our name from the Lsa Authentication packages reg value.
    hr = HrRemoveNetwareFromAuthPackages();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    // Delete the NWC subkeys under the services\NWCWorkstation\parameters
    // key
    //
    hr = HrDeleteParametersSubkeys();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    hr = HrRemoveNetWareFromWOWKnownList();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

Exit:
    // This will work even if the handle is NULL.
    FreeConfigDLL();

    TraceTag(ttidNWClientCfgFn, "<< CNWClient::HrRemoveCodeFromOldINF()");
    TraceError("CNWClient::HrRemoveCodeFromOldINF()", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAppendNetwareToAuthPackages
//
//  Purpose:    Helper function for HrCodeFromOldINF() - Appends the netware
//              authentication provider name to the end of the LSA
//              authentication packages value.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 Error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrAppendNetwareToAuthPackages()
{
    HRESULT     hr              = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrAppendNetwareToAuthPackages");

    // Call the cool new AddString... function
    //
    hr = HrRegAddStringToMultiSz(
            (PWSTR) c_szAuthPackageName,
            HKEY_LOCAL_MACHINE,
            c_szRegKeyCtlLsa,
            L"Authentication Packages",
            STRING_FLAG_ENSURE_AT_END,
            0);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrAppendNetwareToAuthPackages() - Failed to "
                 "Add string to multi-sz 'Authentication Packages' in key: %S",
                 c_szRegKeyCtlLsa);
        goto Exit;

    }

Exit:
    TraceTag(ttidNWClientCfgFn, "<< HrAppendNetwareToAuthPackages");
    TraceError("HrAppendNetwareToAuthPackages", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveNetwareFromAuthPackages
//
//  Purpose:    Helper function for HrCodeFromOldINF() - Appends the netware
//              authentication provider name to the end of the LSA
//              authentication packages value.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 Error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrRemoveNetwareFromAuthPackages()
{
    HRESULT     hr              = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrRemoveNetwareFromAuthPackages");

    // Call the cool new AddString... function
    //
    hr = HrRegRemoveStringFromMultiSz(
            (PWSTR) c_szAuthPackageName,
            HKEY_LOCAL_MACHINE,
            c_szRegKeyCtlLsa,
            L"Authentication Packages",
            STRING_FLAG_REMOVE_ALL);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrRemoveNetwareFromAuthPackages() - Failed to "
                 "Remove string to multi-sz 'Authentication Packages' in key: %S",
                 c_szRegKeyCtlLsa);
        goto Exit;

    }

Exit:
    TraceTag(ttidNWClientCfgFn, "<< HrRemoveNetwareFromAuthPackages");
    TraceError("HrRemoveNetwareFromAuthPackages", hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrNwLibSetEverybodyPermission
//
//  Purpose:    Set the registry key to everybody "Set Value" (or whatever
//              the caller want.)
//
//  Arguments:
//      hKey         [] The handle of the registry key to set security on
//      dwPermission [] The permission to add to "everybody"
//
//  Returns:
//
//  Author:     jeffspr   18 Jun 1997
//
//  Notes:
//
HRESULT HrNwLibSetEverybodyPermission(  IN HKEY     hKey,
                                        IN DWORD    dwPermission)
{
    LONG err;                           // error code
    PSECURITY_DESCRIPTOR psd = NULL;    // related SD
    PSID pSid = NULL;                   // original SID
    PACL pDacl = NULL;                  // Absolute DACL
    PACL pSacl = NULL;                  // Absolute SACL
    PSID pOSid = NULL;                  // Absolute Owner SID
    PSID pPSid = NULL;                  // Absolute Primary SID

    do {  // Not a loop, just for breaking out of error
        //
        // Initialize all the variables...
        //
                                                        // world sid authority
        SID_IDENTIFIER_AUTHORITY SidAuth= SECURITY_WORLD_SID_AUTHORITY;
        DWORD cbSize=0;                                 // Security key size
        PACL pAcl;                                      // original ACL
        BOOL fDaclPresent;
        BOOL fDaclDefault;
        SECURITY_DESCRIPTOR absSD;                      // Absolute SD
        DWORD AbsSize = sizeof(SECURITY_DESCRIPTOR);    // Absolute SD size
        DWORD DaclSize;                                 // Absolute DACL size
        DWORD SaclSize;                                 // Absolute SACL size
        DWORD OSidSize;                                 // Absolute OSID size
        DWORD PSidSize;                                 // Absolute PSID size

        // Get the original DACL list

        RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION, NULL, &cbSize);

        psd = (PSECURITY_DESCRIPTOR *)LocalAlloc(LMEM_ZEROINIT, cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID));
        pDacl = (PACL)LocalAlloc(LMEM_ZEROINIT, cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID));
        pSacl = (PACL)LocalAlloc(LMEM_ZEROINIT, cbSize);
        pOSid = (PSID)LocalAlloc(LMEM_ZEROINIT, cbSize);
        pPSid = (PSID)LocalAlloc(LMEM_ZEROINIT, cbSize);
        DaclSize = cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID);
        SaclSize = cbSize;
        OSidSize = cbSize;
        PSidSize = cbSize;

        if (( NULL == psd) ||
            ( NULL == pDacl) ||
            ( NULL == pSacl) ||
            ( NULL == pOSid) ||
            ( NULL == pPSid))
        {
            err = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if ( (err = RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION, psd, &cbSize )) != ERROR_SUCCESS )
        {
            break;
        }
        if ( !GetSecurityDescriptorDacl( psd, &fDaclPresent, &pAcl, &fDaclDefault ))
        {
            err = GetLastError();
            break;
        }

        // Increase the size for an extra ACE

        pAcl->AclSize += sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID);

        // Get World SID

        if ( (err = RtlAllocateAndInitializeSid( &SidAuth, 1,
              SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSid)) != ERROR_SUCCESS)
        {
            break;
        }

        // Add Permission ACE

        if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, dwPermission ,pSid))
        {
            err = GetLastError();
            break;
        }

        // Convert from relate format to absolute format

        if ( !MakeAbsoluteSD( psd, &absSD, &AbsSize, pDacl, &DaclSize, pSacl, &SaclSize,
                        pOSid, &OSidSize, pPSid, &PSidSize ))
        {
            err = GetLastError();
            break;
        }

        // Set SD

        if ( !SetSecurityDescriptorDacl( &absSD, TRUE, pAcl, FALSE ))
        {
            err = GetLastError();
            break;
        }
        if ( (err = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, psd ))
              != ERROR_SUCCESS )
        {
            break;
        }

    } while (FALSE);

    // Clean up the memory

    RtlFreeSid( pSid );
    LocalFree( psd );
    LocalFree( pDacl );
    LocalFree( pSacl );
    LocalFree( pOSid );
    LocalFree( pPSid );

    return (HRESULT_FROM_WIN32(err));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetEverybodyPermissionsOnOptionsKeys
//
//  Purpose:    Recurse through the options keys (if any), and set the
//              "Everybody" permissions on them.
//
//  Arguments:
//      hkeyOptions   []
//      dwPermissions []
//
//  Returns:
//
//  Author:     jeffspr   10 Sep 1997
//
//  Notes:
//
HRESULT HrSetEverybodyPermissionsOnOptionsKeys(HKEY hkeyOptions, DWORD dwPermissions)
{
    HRESULT     hr      = S_OK;
    DWORD       dwIndex = 0;
    WCHAR       szSubkeyName[MAX_PATH+1];
    FILETIME    ft;

    Assert(hkeyOptions);

    // First, do it on the root key.
    //
    hr = HrNwLibSetEverybodyPermission(hkeyOptions, dwPermissions);

    // Enumerate the keys, and set it on them as well
    //
    while (SUCCEEDED(hr))
    {
        DWORD dwSubkeyNameSize  = MAX_PATH+1;

        // Get the next key (starting with 0)
        //
        hr = HrRegEnumKeyEx(    hkeyOptions,
                                dwIndex++,
                                szSubkeyName,
                                &dwSubkeyNameSize,
                                NULL,
                                NULL,
                                &ft);
        if (SUCCEEDED(hr))
        {
            HKEY hkeyUser   = NULL;

            // Open that key for write
            hr = HrRegOpenKeyEx(hkeyOptions,
                                szSubkeyName,
                                KEY_ALL_ACCESS,
                                &hkeyUser);

            if (SUCCEEDED(hr))
            {
                hr = HrNwLibSetEverybodyPermission(hkeyUser, dwPermissions);
            }

            RegSafeCloseKey(hkeyUser);
        }
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
    {
        hr = S_OK;
    }

    TraceError("HrSetEverybodyPermissionsOnOptionsKeys", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateParametersSubkeys
//
//  Purpose:    Creates the subkeys under the NWCWorkstation parameters key.
//              This could have been done in the INF, but there were some
//              permissions that needed to be set on the keys as well, so
//              all of the work now takes place in this function.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrCreateParametersSubkeys()
{
    HRESULT     hr                  = S_OK;
    HKEY        hkeyOption          = NULL;
    HKEY        hkeyLogon           = NULL;
    DWORD       dwDisposition       = 0;

    TraceTag(ttidNWClientCfgFn, ">> HrCreateParametersSubkeys");

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
            c_szParamOptionKeyPath,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hkeyOption,
            &dwDisposition);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrCreateParametersSubkeys() - failed to "
                 "create/open key %S", c_szParamOptionKeyPath);
        goto Exit;
    }

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
            c_szParamLogonKeyPath,
            0,
            KEY_SET_VALUE,
            NULL,
            &hkeyLogon,
            &dwDisposition);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrCreateParametersSubkeys() - failed to "
                 "create/open key %S", c_szParamLogonKeyPath);
        goto Exit;
    }

    hr = HrSetEverybodyPermissionsOnOptionsKeys(hkeyOption, c_dwOptionKeyPermissions);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrSetEverybodyPermissionsOnOptionsKeys failed, hr: 0x%08x", hr);
        goto Exit;
    }

Exit:
    // Close the hkeys, if they're open
    RegSafeCloseKey(hkeyLogon);
    RegSafeCloseKey(hkeyOption);

    TraceTag(ttidNWClientCfgFn, ">> HrCreateParametersSubkeys");
    TraceError("HrCreateParametersSubkeys", hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDeleteParametersSubkeys
//
//  Purpose:    Deletes the subkeys under the NWCWorkstation parameters key.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrDeleteParametersSubkeys()
{
    HRESULT     hr                  = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrDeleteParametersSubkeys");

    // Note: We need to be taking ownership of these keys so we can delete
    // them. Regardless, ignore if the key deletions fail.

    hr = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE,
            c_szParamOptionKeyPath);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrDeleteParametersSubkeys() - failed to "
                 "delete key %S, hr = 0x%08x", c_szParamOptionKeyPath, hr);
        hr = S_OK;
    }

    hr = HrRegDeleteKey(HKEY_LOCAL_MACHINE,
            c_szParamLogonKeyPath);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrDeleteParametersSubkeys() - failed to "
                 "delete key %S, hr = 0x%08x", c_szParamLogonKeyPath, hr);
        hr = S_OK;
    }

    TraceTag(ttidNWClientCfgFn, ">> HrDeleteParametersSubkeys");
    TraceError("HrDeleteParametersSubkeys", hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FCheckForExistingFile
//
//  Purpose:    Checks for the existance of the passed in file. Should be
//              common-ized.
//
//  Arguments:
//      pszFileToCheck [] The file name to verify
//
//  Returns:    TRUE if the file was found, FALSE otherwise.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:      $$TODO: Should be improved if we move this to common code.
//              The thing that it doesn't do is distinguish between a file
//              being "not found" and a file error (such as access rights
//              or sharing violations) on the CreateFile call.
//
BOOL FCheckForExistingFile( PSTR pszFileToCheck )
{
    BOOL    fReturn = TRUE;
    HANDLE  hFile   = NULL;

    TraceTag(ttidNWClientCfgFn, ">> FCheckForExistingFile");

    hFile = CreateFileA(pszFileToCheck,
                        GENERIC_READ,
                        0,              // No sharing allowed
                        NULL,           // No security attributes
                        OPEN_EXISTING,  // Fail if file doesn't exist
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }
    else
    {
        // This was previously a bug. We weren't setting FALSE here, which made
        // the function somewhat useless.
        fReturn = FALSE;
    }

    TraceTag(ttidNWClientCfgFn, "<< FCheckForExistingFile");

    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   KillTrailingWhitespace
//
//  Purpose:    Remove whitespace from a non-UNICODE string. This is a utility
//              function for the autoexec.nt parser
//
//  Arguments:
//      pszKillMyWhitespace [] String from which to remove whitespace
//
//  Returns:
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
VOID KillTrailingWhitespace( PSTR pszKillMyWhitespace )
{
    long lLength = 0;

    if (!pszKillMyWhitespace)
    {
        Assert(pszKillMyWhitespace);
        goto Exit;
    }

    lLength = lstrlenA(pszKillMyWhitespace);
    if (lLength == 0)
    {
        goto Exit;
    }

    while (isspace(pszKillMyWhitespace[lLength-1]))
    {
        pszKillMyWhitespace[--lLength] = '\0';
    }

Exit:
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   FMoveSzToEndOfFile
//
//  Purpose:    Find a string in the file of this name, and if it's present,
//              move the string to the end of the file. This is used by the
//              autoexec.nt parser to move the IPX stuff to the end of the
//              file. This is a rewrite of similar code in the nwcfg.dll
//              stuff. That code apparently wasn't UNICODE, and didn't work
//              for what we were doing.
//
//  Arguments:
//      pszAutoexecName [] Name of the file to modify
//      pszMatch        [] String to move
//
//  Returns:
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
BOOL FMoveSzToEndOfFile( PSTR pszAutoexecName, PSTR pszMatch )
{
    FILE *  hsrcfile        = NULL;
    FILE *  hdesfile        = NULL;
    char *  pszTempname     = NULL;
    char    szInput[1000];

    TraceTag(ttidNWClientCfgFn, ">> FMoveSzToEndOfFile");

    // Get a temp name
    //
    pszTempname = tmpnam(NULL);

    // Open the original and the destination files
    //
    hsrcfile = fopen(pszAutoexecName, "r");
    hdesfile = fopen(pszTempname, "w");

    if (( hsrcfile != NULL ) && ( hdesfile != NULL ))
    {
        while (fgets(szInput,1000,hsrcfile))
        {
            CHAR    szInputCopy[1000];

            // Copy to another temp buffer so that when we remove the
            // trailing whitespace for the comparison, we won't lose the
            // original text.
            //
            strcpy(szInputCopy, szInput);

            // Remove the trailing whitespace, so we only have to compare the
            // real text
            //
            KillTrailingWhitespace(szInputCopy);

            // Compare the strings
            //
            if (lstrcmpiA(szInputCopy, pszMatch) != 0)
            {
                // If the strings weren't identical, then we still want
                // to copy the line
                //
                fputs(szInput,hdesfile);
            }
        }

        // Append the string to the end of the file.
        fputs(pszMatch, hdesfile);
        fputs("\r\n",hdesfile);
    }

    if (hsrcfile != NULL)
    {
        fclose(hsrcfile);
    }

    if (hdesfile != NULL)
    {
        fclose(hdesfile);
    }

    if (( hsrcfile != NULL ) && ( hdesfile != NULL ))
    {
        CopyFileA(pszTempname,pszAutoexecName, FALSE);
        DeleteFileA(pszTempname);
    }

    TraceTag(ttidNWClientCfgFn, "<< FMoveSzToEndOfFile");

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMungeAutoexecNT
//
//  Purpose:    Move the IPX stuff to the end of the autoexec.nt. Do this by
//              calling FMoveSzToEndOfFile on each of our lines.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrMungeAutoexecNT()
{
    HRESULT     hr                              = S_OK;
    CHAR        szAutoNTPath[MAX_PATH+1]        = {0};
    CHAR        szAutoTmpPath[MAX_PATH+1]       = {0};
    CHAR        szWindowsDirANSI[MAX_PATH+1]    = {0};
    PSTR       pszAutoPath                     = NULL;
    BOOL        fResult                         = FALSE;
    PCWSTR      pszRem1                         = NULL;
    PSTR        pszaRem1MultiByte                = NULL;
    int         iLength                         = 0;

    TraceTag(ttidNWClientCfgFn, ">> HrMungeAutoexecNT");

    // Get the windows directory
    if (GetSystemWindowsDirectoryA(szWindowsDirANSI, sizeof(szWindowsDirANSI)) == 0)
    {
        TraceLastWin32Error("HrMungeAutoexecNT - Call to GetWindowsDirectoryA");
        hr = HrFromLastWin32Error();
        goto Exit;
    }

    // Build the path to the autoexec.nt
    //
    wsprintfA(szAutoNTPath, "%s\\system32\\%s", szWindowsDirANSI, "autoexec.nt");
    if (FCheckForExistingFile(szAutoNTPath) == FALSE)
    {
        wsprintfA(szAutoTmpPath, "%s\\system32\\%s", szWindowsDirANSI, "autoexec.tmp");
        if (FCheckForExistingFile(szAutoTmpPath) == FALSE)
        {
            // Per the old INF, skip the whole shebang.
            goto Exit;
        }
        else
        {
            pszAutoPath = szAutoTmpPath;
        }
    }
    else
    {
        pszAutoPath = szAutoNTPath;
    }

    // At this point, we should have found at least one valid
    // autoexec.nt or .tmp file. If not, we should have dropped out of the
    // function

    Assert(pszAutoPath);

    pszRem1 = SzLoadStringPcch(_Module.GetResourceInstance(), IDS_AUTOEXEC_REM1, &iLength);
    if (!pszRem1 || iLength == 0)
    {
        AssertSz(FALSE, "Failed to load STR_AUTOEXEC_REM from the resources");

        TraceTag(ttidNWClientCfg,
                "ERROR: Failed to load STR_AUTOEXEC_REM from the resources");

        hr = E_FAIL;
        goto Exit;
    }

    // Allocate memory for the demoted string.
    pszaRem1MultiByte = (PSTR) MemAlloc(lstrlenW(pszRem1) + 1);
    if (!pszaRem1MultiByte)
    {
        TraceTag(ttidNWClientCfg, "ERROR: Failed to alloc memory for demoted string");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Demote the loaded string to multibyte (single char)
    WideCharToMultiByte(
        CP_ACP,                     // ANSI code page
        0,                          // flags for non-mapped character action
        pszRem1,                    // source string
        -1,                         // source string is NULL terminated
        pszaRem1MultiByte,           // destination string (multibyte)
        lstrlenW(pszRem1) + 1,       // size of destination string
        NULL,                       // default char on non-mapped char
        NULL);                      // return for default char mapping action

    // Move the REM from the autoexec.nt
    //
    fResult = FMoveSzToEndOfFile(pszAutoPath, pszaRem1MultiByte);
    if (!fResult)
    {
        // Traced in called function.
        hr = E_FAIL;
        goto Exit;
    }

    // Move the line that loads nw16
    //
    fResult = FMoveSzToEndOfFile(pszAutoPath, "lh %SystemRoot%\\system32\\nw16");
    if (!fResult)
    {
        // Traced in called function.
        hr = E_FAIL;
        goto Exit;
    }

    // Move the line that loads vwipxspx
    //
    fResult = FMoveSzToEndOfFile(pszAutoPath, "lh %SystemRoot%\\system32\\vwipxspx");
    if (!fResult)
    {
        // Traced in called function.
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    MemFree(pszaRem1MultiByte);

    TraceTag(ttidNWClientCfgFn, "<< HrMungeAutoexecNT");
    TraceError("HrMungeAutoexecNT", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddNetWareToWOWKnownList
//
//  Purpose:    Add the netware.drv to the WOW "known DLLS" list.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrAddNetWareToWOWKnownList()
{
    HRESULT     hr              = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrAddNetWareToWOWKnownList");

    // Call the cool new AddString... function
    //
    hr = HrRegAddStringToSz(
            L"netware.drv",
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\WOW",
            L"KnownDLLS",
            L' ',
            STRING_FLAG_ENSURE_AT_END,
            0);

    TraceTag(ttidNWClientCfgFn, "<< HrAddNetWareToWOWKnownList");
    TraceError("HrAddNetWareToWOWKnownList", hr);

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveNetWareFromWOWKnownList
//
//  Purpose:    Add the netware.drv to the WOW "known DLLS" list.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrRemoveNetWareFromWOWKnownList()
{
    HRESULT     hr              = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrRemoveNetWareFromWOWKnownList");

    // Call the cool new AddString... function
    //
    hr = HrRegRemoveStringFromSz(
            L"netware.drv",
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\WOW",
            L"KnownDLLS",
            L' ',
            STRING_FLAG_REMOVE_SINGLE);

    TraceTag(ttidNWClientCfgFn, "<< HrRemoveNetWareFromWOWKnownList");
    TraceError("HrRemoveNetWareFromWOWKnownList", hr);

    return hr;

}


//+---------------------------------------------------------------------------
//
//  Function:   HrUpdateLanmanSharedDrivesValue
//
//  Purpose:    If the LanmanServer service exists, make sure that they have the
//              EnableSharedNetDrives value turned on.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrUpdateLanmanSharedDrivesValue()
{
    HRESULT             hr              = S_OK;
    const DWORD         c_dwESNDValue   = 1;
    HKEY                hkeyLMSP        = NULL;
    SERVER_INFO_1540    si1540          = {0};
    NET_API_STATUS      nas             = ERROR_SUCCESS;
    DWORD               dwDisposition   = 0;

    TraceTag(ttidNWClientCfgFn, ">> HrUpdateLanmanSharedDrivesValue");

    // Open the LanmanServer parameters key, if it exists. If it doesn't exist,
    // it will still return S_OK, but the hkey will still be NULL.
    //
    hr = HrRegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,    // samDesired
            NULL,
            &hkeyLMSP,
            &dwDisposition);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfgFn, "Failed to create/open the "
                 "LanmanServer\\Parameters key");
        goto Exit;
    }

    Assert(hkeyLMSP);

    hr = HrRegSetDword(
            hkeyLMSP,
            L"EnableSharedNetDrives",
            c_dwESNDValue);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfgFn, "Failed to set the EnabledSharedNetDrives value in "
                 "HrUpdateLanmanSharedDrivesValue()");
        goto Exit;
    }

    // Call the NetServerSetInfo with the Enable Shared Net Drives info (1540).
    // This will allow this info to be set dynamically (so as not to require a
    // restart of the "Server" service.
    //
    si1540.sv1540_enablesharednetdrives = TRUE;

    // Set the server info for the EnableSharedDrives value. This will cause it to
    // take effect if the service is running (and will do nothing if it is not).
    //
    nas = NetServerSetInfo(NULL, 1540, (LPBYTE) &si1540, NULL);
    if (nas != NERR_Success)
    {
        // It's actually OK if this fails in one condition (0x842), because
        // it WILL fail if the server service That's not a problem, because
        // the value that I set in the registry above will be picked up the
        // next time the server service starts.
        //
        // OK, cheesy, but I don't know the define, I just know that this is the
        // right return code for our ignorable failure.
        //
        if (nas != 0x842)
        {
            AssertSz(nas == 0x842, "NetServerSetInfo failed for a reason other "
                   "than the service not running (which would have been ok)");
        }
    }

Exit:
    // Close the hkey, if it's open
    RegSafeCloseKey(hkeyLMSP);

    TraceTag(ttidNWClientCfgFn, "<< HrUpdateLanmanSharedDrivesValue");
    TraceError("HrUpdateLanmanSharedDrivesValue()", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRenameNWDocFiles
//
//  Purpose:    On the server install, rename the nwdocgw.* files, since
//              whether we're on CSNW or GSNW, the files are always called
//              nwdoc.*
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   13 Jul 1997
//
//  Notes:
//
HRESULT HrRenameNWDocFiles()
{
    HRESULT hr                          = S_OK;
    WCHAR   szWindowsDir[MAX_PATH+1];
    WCHAR   szSourceName[MAX_PATH+1];
    WCHAR   szTargetName[MAX_PATH+1];

    // Get the windows directory
    if (GetSystemWindowsDirectory(szWindowsDir, MAX_PATH) == 0)
    {
        TraceLastWin32Error("HrRenameNWDocFiles - Call to GetSystemWindowsDirectory");
        hr = HrFromLastWin32Error();
        goto Exit;
    }

    // Build the path for the first rename
    //
    wsprintfW(szSourceName, L"%s\\system32\\%s", szWindowsDir, c_szNwDocGWHelpName);
    wsprintfW(szTargetName, L"%s\\system32\\%s", szWindowsDir, c_szNwDocHelpName);

    // Rename the .HLP file. If this fails, no big deal.
    //
    if (!MoveFileEx(szSourceName, szTargetName, MOVEFILE_REPLACE_EXISTING))
    {
        // For debugging only.
        //
        DWORD dwLastError = GetLastError();
    }

    // Build the path for the second rename
    //
    wsprintfW(szSourceName, L"%s\\system32\\%s", szWindowsDir, c_szNwDocGWCNTName);
    wsprintfW(szTargetName, L"%s\\system32\\%s", szWindowsDir, c_szNwDocCNTName);

    // Rename the .CNT file. If this fails, no big deal.
    //
    if (!MoveFileEx(szSourceName, szTargetName, MOVEFILE_REPLACE_EXISTING))
    {
        // For debugging only.
        //
        DWORD dwLastError = GetLastError();
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwclicfg\nwcliobj.h ===
//
// N W C L I O B J . H
//
// Declaration of CNWClient and helper functions
//

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "ncmisc.h"
#include "resource.h"

// Typedefs for the functions that we'll GetProcAddress from the
// NetWare config DLL
typedef BOOL (PASCAL *NWCFG_PROC)(DWORD, PWSTR [], PWSTR *);


/////////////////////////////////////////////////////////////////////////////
// NWClient

class ATL_NO_VTABLE CNWClient :
    public CComObjectRoot,
    public CComCoClass<CNWClient, &CLSID_CNWClient>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
public:
    CNWClient();
    ~CNWClient();
    BEGIN_COM_MAP(CNWClient)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNWClient)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NWCLICFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags, DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

public:
    // Helper functions.
    HRESULT HrInstallCodeFromOldINF();
    HRESULT HrRemoveCodeFromOldINF();

    // Load and free the config DLL
    HRESULT HrLoadConfigDLL();
    VOID    FreeConfigDLL();

// Private state info
private:
    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};

    INSTALLACTION       m_eInstallAction;
    INetCfgComponent *  m_pncc;             // Place to keep my component
    INetCfg *           m_pnc;              // Place to keep my component
    HINSTANCE           m_hlibConfig;       // From LoadLibrary call.
    PRODUCT_FLAVOR      m_pf;               // Server/Workstation
    BOOL                m_fUpgrade;         // TRUE if we are upgrading with
                                            // an answer file

    tstring             m_strParamsRestoreFile;
    tstring             m_strSharesRestoreFile;
    tstring             m_strDrivesRestoreFile;
    DWORD               m_dwLogonScript;
    tstring             m_strDefaultLocation;

    // These functions below are initialized in the HrLoadConfigDLL() call,
    // which does a GetProcAddress on the appropriate function in nwcfg.dll
    // Note: "Provider" is spelled incorrectly, since it's spelled that way
    // in the config DLL itself, and that's the name that we're using in
    // the GetProcAddress call.

    NWCFG_PROC          m_pfnAddNetwarePrinterProvider;
    NWCFG_PROC          m_pfnDeleteNetwarePrinterProvider;
    NWCFG_PROC          m_pfnAppendSzToFile;
    NWCFG_PROC          m_pfnRemoveSzFromFile;
    NWCFG_PROC          m_pfnGetKernelVersion;
    NWCFG_PROC          m_pfnSetEverybodyPermission;
    NWCFG_PROC          m_pfnlodctr;
    NWCFG_PROC          m_pfnunlodctr;
    NWCFG_PROC          m_pfnDeleteGatewayPassword;
    NWCFG_PROC          m_pfnSetFileSysChangeValue;
    NWCFG_PROC          m_pfnCleanupRegistryForNWCS;
    NWCFG_PROC          m_pfnSetupRegistryForNWCS;

    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection);
    HRESULT HrRestoreRegistry(VOID);
    HRESULT HrWriteAnswerFileParams(VOID);
    HRESULT HrEnableGatewayIfNeeded(VOID);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwclicfg\nwcliobj.cpp ===
//
// N W C L I O B J . C P P
//
// Implementation of the CNWClient notify object model
//

#include "pch.h"
#pragma hdrstop
#include "ncerror.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "nwcliobj.h"

#include <ncshell.h>

extern const WCHAR c_szAfNWCWorkstationParameters[];
extern const WCHAR c_szAfNWCWorkstationShares[];
extern const WCHAR c_szAfNWCWorkstationDrives[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_Server[];

//---[ Constants ]-------------------------------------------------------------

static const WCHAR c_szNWClientParamPath[]      = L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters";
static const WCHAR c_szNWClientSharesPath[]     = L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Shares";
static const WCHAR c_szNWClientDrivesPath[]     = L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Drives";
static const WCHAR c_szLMServerParamPath[]      = L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
static const WCHAR c_szLMServerLinkagePath[]    = L"System\\CurrentControlSet\\Services\\LanmanServer\\Linkage";
static const WCHAR c_szEnableSharedNetDrives[]  = L"EnableSharedNetDrives";
static const WCHAR c_szOtherDependencies[]      = L"OtherDependencies";
static const WCHAR c_szGWEnabledValue[]         = L"GatewayEnabled";

extern const WCHAR c_szSvcLmServer[];          // L"LanmanServer";
extern const WCHAR c_szSvcNWCWorkstation[];    // L"NWCWorkstation";

HRESULT HrRefreshEntireNetwork();
HRESULT HrGetEntireNetworkPidl(LPITEMIDLIST *ppidlFolder);


//
// Constructor
//

CNWClient::CNWClient()
{
    // Initialize member variables.
    m_pnc            = NULL;
    m_pncc           = NULL;
    m_eInstallAction = eActUnknown;
    m_hlibConfig     = NULL;
    m_fUpgrade       = FALSE;

    // Get the product flavor (PF_WORKSTATION or PF_SERVER). Use this
    // to decide whether or not we need to install the "server" component.
    //
    GetProductFlavor(NULL, &m_pf);
}

CNWClient::~CNWClient()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);

    // Release KEY handles here.
}


//
// INetCfgNotify
//

STDMETHODIMP CNWClient::Initialize( INetCfgComponent *  pnccItem,
                                    INetCfg*            pnc,
                                    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    TraceTag(ttidNWClientCfg, "CNWClient::Initialize");

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "m_pncc NULL in CNWClient::Initialize");
    AssertSz(m_pnc, "m_pnc NULL in CNWClient::Initialize");

    // Addref the config objects
    //
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrRestoreRegistry
//
//  Purpose:    Restores the contents of the registry for this component
//
//  Arguments:
//      (none)
//
//  Returns:    Win32 error if failed, otherwise S_OK
//
//  Author:     jeffspr   13 Aug 1997
//
//  Notes:
//
HRESULT CNWClient::HrRestoreRegistry()
{
    HRESULT             hr                  = S_OK;
    HKEY                hkey                = NULL;
    TOKEN_PRIVILEGES *  ptpRestore          = NULL;
    DWORD               dwDisp              = 0;
    static const WCHAR c_szSvcDLLName[]     = L"%SystemRoot%\\System32\\nwwks.dll";
    static const WCHAR c_szServiceDll[]     = L"ServiceDll";

    TraceTag(ttidNWClientCfg, "CNWClient::HrRestoreRegistry");

    if (!m_strParamsRestoreFile.empty() ||
        !m_strDrivesRestoreFile.empty() ||
        !m_strSharesRestoreFile.empty())
    {
        hr = HrEnableAllPrivileges(&ptpRestore);
    }

    if (SUCCEEDED(hr) && !m_strParamsRestoreFile.empty())
    {
        // Ensure key is there by creating it
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szNWClientParamPath, 0,
                              KEY_ALL_ACCESS, NULL, &hkey, &dwDisp);
        if (SUCCEEDED(hr))
        {
            hr = HrRegRestoreKey(hkey, m_strParamsRestoreFile.c_str(), 0);
            if (FAILED(hr))
            {
                TraceError("CNWClient::HrRestoreRegistry - HrRestoreRegistry for "
                           "Parameters", hr);
                hr = S_OK;
            }

            //
            // Bug 182442. HrRegRestoreKey above overwrites the ServiceDll value added
            // from the inf file. So, we manually save it.
            //

            hr = HrRegSetValueEx(hkey, c_szServiceDll, REG_EXPAND_SZ,
                                 (const BYTE *)c_szSvcDLLName,
                                 (wcslen(c_szSvcDLLName) + 1) * sizeof(WCHAR));
            if (FAILED(hr))
            {
                TraceError("CNWClient::HrRestoreRegistry - HrRestoreRegistry for "
                        "ServiceDll", hr);
                        hr = S_OK;
            }

            RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    if (!m_strSharesRestoreFile.empty())
    {
        // Ensure key is there by creating it
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szNWClientSharesPath, 0,
                              KEY_ALL_ACCESS, NULL, &hkey, &dwDisp);
        if (SUCCEEDED(hr))
        {
            hr = HrRegRestoreKey(hkey, m_strSharesRestoreFile.c_str(), 0);
            if (FAILED(hr))
            {
                TraceError("CNWClient::HrRestoreRegistry - HrRestoreRegistry for "
                           "Shares", hr);
                hr = S_OK;
            }

            RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    if (!m_strDrivesRestoreFile.empty())
    {
        // Ensure key is there by creating it
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szNWClientDrivesPath, 0,
                              KEY_ALL_ACCESS, NULL, &hkey, &dwDisp);
        if (SUCCEEDED(hr))
        {
            hr = HrRegRestoreKey(hkey, m_strDrivesRestoreFile.c_str(), 0);
            if (FAILED(hr))
            {
                TraceError("CNWClient::HrRestoreRegistry - HrRestoreRegistry for "
                           "Drives", hr);
                hr = S_OK;
            }

            RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    if (ptpRestore)
    {
        hr = HrRestorePrivileges(ptpRestore);

        delete [] reinterpret_cast<BYTE *>(ptpRestore);
    }

    TraceError("CNWClient::HrRestoreRegistry", hr);
    return hr;
}

static const WCHAR c_szDefaultLocation[]        = L"DefaultLocation";
static const WCHAR c_szDefaultScriptOptions[]   = L"DefaultScriptOptions";

HRESULT CNWClient::HrWriteAnswerFileParams()
{
    HRESULT     hr = S_OK;

    TraceTag(ttidNWClientCfg, "CNWClient::HrWriteAnswerFileParams");

    // Don't do anything if we don't have anything to write to the
    // registry
    if (!m_strDefaultLocation.empty() || (m_dwLogonScript != 0xFFFFFFFF))
    {
        HKEY        hkey;
        DWORD       dwDisp;

        // Ensure key is there by creating it
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szNWClientParamPath, 0,
                              KEY_ALL_ACCESS, NULL, &hkey, &dwDisp);
        if (SUCCEEDED(hr))
        {
            if (!m_strDefaultLocation.empty())
            {
                hr = HrRegSetString(hkey, c_szDefaultLocation,
                                    m_strDefaultLocation);
                if (FAILED(hr))
                {
                    TraceError("CNWClient::HrWriteAnswerFileParams - Couldn't"
                               " set DefaultLocation", hr);
                    hr = S_OK;
                }
            }

            if (m_dwLogonScript != 0xFFFFFFFF)
            {
                // 0x3 is combination of the following:
                //
                // #define NW_LOGONSCRIPT_DISABLED          0x00000000
                // #define NW_LOGONSCRIPT_ENABLED           0x00000001
                // #define NW_LOGONSCRIPT_4X_ENABLED        0x00000002
                //
                hr = HrRegSetDword(hkey, c_szDefaultScriptOptions,
                                   m_dwLogonScript ? 0x3 : 0x0);
                if (FAILED(hr))
                {
                    TraceError("CNWClient::HrWriteAnswerFileParams - Couldn't"
                               " set DefaultLocation", hr);
                    hr = S_OK;
                }
            }

            RegCloseKey(hkey);
        }
    }

    TraceError("CNWClient::HrWriteAnswerFileParams", hr);
    return hr;
}

static const WCHAR c_szPreferredServer[]    = L"PreferredServer";
static const WCHAR c_szDefaultTree[]        = L"DefaultTree";
static const WCHAR c_szDefaultContext[]     = L"DefaultContext";
static const WCHAR c_szLogonScript[]        = L"LogonScript";

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrProcessAnswerFile
//
//  Purpose:    Handles necessary processing of contents of the answer file.
//
//  Arguments:
//      pszAnswerFile       [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Comma-separated list of sections in the
//                                  file appropriate to this component.
//
//  Returns:    S_OK if successful, setup API error otherwise.
//
//  Author:     jeffspr   8 May 1997
//
//  Notes:
//
HRESULT CNWClient::HrProcessAnswerFile( PCWSTR pszAnswerFile,
                                        PCWSTR pszAnswerSection)
{
    HRESULT         hr;
    CSetupInfFile   csif;

    TraceTag(ttidNWClientCfg, "CNWClient::HrProcessAnswerFile");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto Exit;
    }

    // Restore portions of the registry based on file names from the answer
    // file

    // Get restore file for "Parameters" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfNWCWorkstationParameters,
                          &m_strParamsRestoreFile);
    if (FAILED(hr))
    {
        TraceError("CNWClient::HrProcessAnswerFile - Error restoring "
                   "Parameters key", hr);

        // oh well, just continue
        hr = S_OK;
    }

    // Get restore file for "Shares" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfNWCWorkstationShares,
                          &m_strSharesRestoreFile);
    if (FAILED(hr))
    {
        TraceError("CNWClient::HrProcessAnswerFile - Error restoring "
                   "Shares key", hr);

        // oh well, just continue
        hr = S_OK;
    }

    // Get restore file for "Drives" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfNWCWorkstationDrives,
                          &m_strDrivesRestoreFile);
    if (FAILED(hr))
    {
        TraceError("CNWClient::HrProcessAnswerFile - Error restoring "
                   "Drives key", hr);

        // oh well, just continue
        hr = S_OK;
    }

    //
    // Read answer file parameters (these are all optional so no errors are
    // saved)
    //

    TraceTag(ttidNWClientCfg, "Reading PreferredServer from answer file");

    // Read contents of PreferredServer key.
    if (FAILED(csif.HrGetString(pszAnswerSection, c_szPreferredServer,
                                &m_strDefaultLocation)))
    {
        // Couldn't read PreferredServer key, so we must assume that the other
        // two values are present
        tstring     strDefaultTree;
        tstring     strDefaultContext;

        TraceTag(ttidNWClientCfg, "PreferredServer not found so trying "
                 "DefaultTree and DefaultContext instead");

        // Read contents of DefaultTree key.
        if (SUCCEEDED(csif.HrGetString(pszAnswerSection, c_szDefaultTree,
                                       &strDefaultTree)))
        {
            TraceTag(ttidNWClientCfg, "Got DefaultTree ok: %S",
                     strDefaultTree.c_str());

            // Read contents of DefaultContext key.
            hr = csif.HrGetString(pszAnswerSection, c_szDefaultContext,
                                  &strDefaultContext);
            if (SUCCEEDED(hr))
            {
                TraceTag(ttidNWClientCfg, "Got DefaultContext ok: %S",
                         strDefaultContext.c_str());

                // Munge the DefaultLocation value with the DefaultTree and
                // DefaultContext values read from the answer file

                m_strDefaultLocation = L"*";
                m_strDefaultLocation += strDefaultTree;
                m_strDefaultLocation += L"\\";
                m_strDefaultLocation += strDefaultContext;

                TraceTag(ttidNWClientCfg, "DefaultLocation is: %S",
                         m_strDefaultLocation.c_str());
            }
            else
            {
                TraceError("CNWClient::HrProcessAnswerFile - error reading "
                           "DefaultContext", hr);
                hr = S_OK;
            }
        }
    }
    else
    {
        TraceTag(ttidNWClientCfg, "DefaultLocation is: %S",
                 m_strDefaultLocation.c_str());
    }

    // Init to impossible value so we know whether we read it or not
    m_dwLogonScript = 0xFFFFFFFF;

    // Read contents of LogonScript key.
    (VOID) csif.HrGetStringAsBool(pszAnswerSection, c_szLogonScript,
                                  reinterpret_cast<BOOL *>(&m_dwLogonScript));

    TraceTag(ttidNWClientCfg, "LogonScript is: %ld", m_dwLogonScript);

Exit:
    TraceError("CNWClient::HrProcessAnswerFile", hr);
    return hr;
}

STDMETHODIMP CNWClient::Upgrade(DWORD dwSetupFlags, DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}

STDMETHODIMP CNWClient::ReadAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile,
                                          pszAnswerSection);

    TraceTag(ttidNWClientCfg, "CNWClient::ReadAnswerFile");

    m_eInstallAction = eActInstall;

    // If we're not already installed, do the work.
    //
    if (pszAnswerFile && pszAnswerSection)
    {
        HRESULT hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
        if (FAILED(hr))
        {
            TraceError("CNWClient::NetworkInstall - Answer file has errors. Defaulting "
                       "all information as if answer file did not exist.",
                       hr);
        }
    }

    return S_OK;
}

STDMETHODIMP CNWClient::Install(DWORD dw)
{
    Validate_INetCfgNotify_Install(dw);

    TraceTag(ttidNWClientCfg, "CNWClient::Install");

    m_eInstallAction = eActInstall;

    // Install the NWLink sub-component
    HRESULT hr = HrInstallComponentOboComponent(m_pnc, NULL,
                                        GUID_DEVCLASS_NETTRANS,
                                        c_szInfId_MS_NWIPX,
                                        m_pncc,
                                        NULL);
    if (SUCCEEDED(hr))
    {
        // If we're NT Server, we DO need to install it, as what we're
        // installing is GSNW, not CSNW (and therefore, since we're sharing
        // resources, we need to use the server service)
        //
        if (PF_SERVER == m_pf)
        {
            NETWORK_INSTALL_PARAMS nip;

            nip.dwSetupFlags = dw;
            nip.dwUpgradeFromBuildNo = -1;
            nip.pszAnswerFile = NULL;
            nip.pszAnswerSection = NULL;

            // Install Server
            hr = HrInstallComponentOboComponent(m_pnc, &nip,
                                                GUID_DEVCLASS_NETSERVICE,
                                                c_szInfId_MS_Server,
                                                m_pncc,
                                                NULL);
        }
    }

    TraceError("CNWClient::Install", hr);
    return hr;
}

STDMETHODIMP CNWClient::Removing()
{
    TraceTag(ttidNWClientCfg, "CNWClient::Removing");

    m_eInstallAction = eActRemove;

    // Remove the NWLink service
    //
    HRESULT hr = HrRemoveComponentOboComponent(m_pnc,
                                       GUID_DEVCLASS_NETTRANS,
                                       c_szInfId_MS_NWIPX,
                                       m_pncc);

    if (SUCCEEDED(hr))
    {
        if (PF_SERVER == m_pf)
        {
            // Remove our reference of the Server service
            //
            hr = HrRemoveComponentOboComponent(m_pnc,
                                               GUID_DEVCLASS_NETSERVICE,
                                               c_szInfId_MS_Server,
                                               m_pncc);
        }
    }

    if (hr == NETCFG_S_STILL_REFERENCED)
    {
        // If services are still in use, that's OK, I just needed to make
        // sure that I released my reference.
        //
        hr = S_OK;
    }

    Validate_INetCfgNotify_Removing_Return(hr);

    TraceError("CNWClient::Removing()", hr);
    return hr;
}

STDMETHODIMP CNWClient::Validate()
{
    return S_OK;
}

STDMETHODIMP CNWClient::CancelChanges()
{
    return S_OK;
}

STDMETHODIMP CNWClient::ApplyRegistryChanges()
{
    HRESULT     hr = S_OK;

    TraceTag(ttidNWClientCfg, "CNWClient::ApplyRegistryChanges");

    if (m_eInstallAction == eActRemove)
    {
        hr = HrRemoveCodeFromOldINF();
    }
    else if (m_eInstallAction == eActInstall)
    {
        hr = HrRestoreRegistry();
        if (FAILED(hr))
        {
            TraceError("CNWClient::ApplyRegistryChanges - HrRestoreRegistry non-fatal error",
                       hr);
            hr = S_OK;
        }

        hr = HrWriteAnswerFileParams();
        if (FAILED(hr))
        {
            TraceError("CNWClient::ApplyRegistryChanges - HrWriteAnswerFileParams "
                       "non-fatal error", hr);
            hr = S_OK;
        }

        // If gateway is enabled, modify lanmanserver appropriately
        // Ignore the return code other than to trace it.
        //
        hr = HrEnableGatewayIfNeeded();
        if (FAILED(hr))
        {
            TraceError("CNWClient::ApplyRegistryChanges - HrEnableGatewayIfNeeded non-fatal error", hr);
        }

        hr = HrInstallCodeFromOldINF();
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CNWClient::ApplyRegistryChanges",
        (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

STDMETHODIMP CNWClient::ApplyPnpChanges (
    INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr;

    hr = HrRefreshEntireNetwork();

    if (FAILED(hr))
    {
        TraceError("CNWClient::ApplyPnpChanges - HrRefreshEntireNetwork"
                   "non-fatal error", hr);
        hr = S_OK;
    }

    // GlennC can't do the work to make NW Client PnP so we're forced to
    // prompt for a reboot for any change.
    //
    return NETCFG_S_REBOOT;
}

// Note -- Don't convert this to a constant. We need copies of it within the
// functions because ParseDisplayName actually mangles the string.
//
#define ENTIRE_NETWORK_PATH   L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}\\EntireNetwork"

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEntireNetworkPidl
//
//  Purpose:    Get the pidl for "Entire Network". Used in places where we're
//              not folder specific, but we still need to update folder
//              entries.
//
//  Arguments:
//      ppidlFolder [out]   Return parameter for the folder pidl
//
//  Returns:
//
//  Author:     anbrad    08 Jun 1999
//              jeffspr   13 Jun 1998
//
//  Notes:
//
HRESULT HrGetEntireNetworkPidl(LPITEMIDLIST *ppidlFolder)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   pshf        = NULL;
    LPITEMIDLIST    pidlFolder  = NULL;

    Assert(ppidlFolder);

    WCHAR szEntireNetworkPath[] = ENTIRE_NETWORK_PATH;

    // Get the desktop folder, so we can parse the display name and get
    // the UI object of the connections folder
    //
    hr = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hr))
    {
        ULONG           chEaten;

        hr = pshf->ParseDisplayName(NULL, 0, (WCHAR *) szEntireNetworkPath,
            &chEaten, &pidlFolder, NULL);

        ReleaseObj(pshf);
    }

    // If succeeded, fill in the return param.
    //
    if (SUCCEEDED(hr))
    {
        *ppidlFolder = pidlFolder;
    }
    else
    {
        // If we failed, then delete the pidl if we already got it.
        //
        if (pidlFolder)
            SHFree(pidlFolder);
    }

    TraceHr(ttidNWClientCfg, FAL, hr, FALSE, "HrGetEntireNetworkPidl");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRefreshEntireNetwork
//
//  Purpose:    Update the "Entire Network" portion of the shell due to
//              the addition of a new networking client (NWClient)
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     anbrad  08  Jun 1999
//
//  Notes:
//
HRESULT HrRefreshEntireNetwork()
{
    HRESULT         hr          = S_OK;
    HCURSOR         hcWait      = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPITEMIDLIST    pidlFolder  = NULL;;

    hr = HrGetEntireNetworkPidl(&pidlFolder);

    // If we now have a pidl, send the GenerateEvent to update the item
    //
    if (SUCCEEDED(hr))
    {
        Assert(pidlFolder);
        // SHCNE_UPDATEDIR?ITEM
        GenerateEvent(SHCNE_UPDATEDIR, pidlFolder, NULL, NULL);
    }

    if (hcWait)
    {
        SetCursor(hcWait);
    }

    if (pidlFolder)
    {
        SHFree(pidlFolder);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrRefreshEntireNetwork");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableGatewayIfNeeded
//
//  Purpose:    Update the Lanman dependencies, if appropriate (meaning if
//              gateway is enabled).
//
//  Arguments:  
//      (none)
//
//  Returns:    
//
//  Author:     jeffspr   19 Aug 1999
//
//  Notes:      
//
HRESULT CNWClient::HrEnableGatewayIfNeeded()
{
    HRESULT         hr      = S_OK;
    HKEY            hKey    = NULL;
    DWORD           dwValue = 0;
    CServiceManager sm;
    CService        svc;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
        c_szNWClientParamPath,
        KEY_READ,  
        &hKey);
    if (FAILED(hr))
    {
        TraceError("Couldn't open NWClient param key", hr);
        goto Exit;
    }

    hr = HrRegQueryDword(hKey, 
        c_szGWEnabledValue,
        &dwValue);
    if (FAILED(hr))
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            TraceError("Couldn't query the GWEnabled Value", hr);
            goto Exit;
        }
        else
        {
            dwValue = 0;
        }
    }
    else
    {
        // Normalize to bool
        //
        dwValue = !!dwValue;
    }

    RegSafeCloseKey(hKey);
    hKey = NULL;

    // If there are gateway services present, then add the dependencies 
    // to LanmanServer
    // 
    if (dwValue > 0)
    {
        // Set the value in the registry for the server paramaters.
        //
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,  
            c_szLMServerParamPath,  
            KEY_WRITE,  
            &hKey);
        if (SUCCEEDED(hr))
        {
            hr = HrRegSetDword(hKey,
                c_szEnableSharedNetDrives,
                dwValue);

            RegSafeCloseKey(hKey);
            hKey = NULL;
        }

        hr = sm.HrOpen();
        if (SUCCEEDED(hr))
        {
            hr = sm.HrOpenService(&svc, c_szSvcLmServer, NO_LOCK);
            if (SUCCEEDED(hr))
            {
                // Add dependency of NWC Workstation to Server
                //
                hr = sm.HrAddServiceDependency(c_szSvcLmServer,
                    c_szSvcNWCWorkstation);

                if (SUCCEEDED(hr))
                {
                    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        c_szLMServerLinkagePath,
                        KEY_READ | KEY_WRITE,
                        &hKey);
                    if (SUCCEEDED(hr))
                    {
                        // Add the "OtherDependencies" to LanmanServer for legacy reasons
                        //
                        hr = HrRegAddStringToMultiSz(c_szSvcNWCWorkstation,
                            hKey,
                            NULL,
                            c_szOtherDependencies,
                            STRING_FLAG_ENSURE_AT_END | STRING_FLAG_DONT_MODIFY_IF_PRESENT,
                            0);

                        RegSafeCloseKey(hKey);
                        hKey = NULL;
                    }
                }
            }
            else
            {
                TraceError("Failed to open LanmanServer service for dependency mods", hr);
            }
        }
        else
        {
            TraceError("Failed to open service control manager", hr);
        }
    }

Exit:
    TraceHr(ttidNWClientCfg, FAL, hr, FALSE, "HrEnableGatewayIfNeeded");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwclicfg\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
//#define NOGDI
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "stllist.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwclicfg\resource.h ===
#include <ncres.h>

#define IDS_PRINT_PROVIDER_NAME         IDS_NC_NWCLICFG + 1
#define IDS_AUTOEXEC_REM1               IDS_NC_NWCLICFG + 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\nwlnkdlg.cpp ===
// nwlnkipx.cpp : Implementation of CNwlnkIPX

#include "pch.h"
#pragma hdrstop
#include "nwlnkipx.h"
#include "ncatlui.h"
#include "ncui.h"

extern const WCHAR c_szNetCfgHelpFile[];
extern const WCHAR c_sz8Zeros[];

static const FRAME_TYPE aFDDI_Frames[] = {{IDS_AUTO, AUTO},
                                          {IDS_FDDI, F802_2},
                                          {IDS_FDDI_SNAP, SNAP},
                                          {IDS_FDDI_802_3, F802_3},
                                          {0,0}
                                         };
static const FRAME_TYPE aTOKEN_Frames[] = {{IDS_AUTO, AUTO},
                                           {IDS_TK, F802_2},
                                           {IDS_802_5, SNAP},
                                           {0,0}
                                          };
static const FRAME_TYPE aARCNET_Frames[] = {
                                            {IDS_AUTO, AUTO},
                                            {IDS_ARCNET, ARCNET},
                                            {0,0}
                                           };
static const FRAME_TYPE aEthernet_Frames[] = {
                                              {IDS_AUTO, AUTO},
                                              {IDS_ETHERNET, ETHERNET},
                                              {IDS_802_2, F802_2},
                                              {IDS_802_3, F802_3},
                                              {IDS_SNAP, SNAP},
                                              {0,0}
                                             };

static const MEDIA_TYPE MediaMap[] = {{FDDI_MEDIA, aFDDI_Frames},
                                      {TOKEN_MEDIA, aTOKEN_Frames},
                                      {ARCNET_MEDIA, aARCNET_Frames},
                                      {ETHERNET_MEDIA, aEthernet_Frames}
                                     };

//+---------------------------------------------------------------------------
//
//  Member:     EditSubclassProc
//
//  Purpose:    Subclass proc for network number edit controls.  The
//              subclassing forces only correct input
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
STDAPI EditSubclassProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    WNDPROC pIpxEditProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

     // Allow copy/paste keys (CTRL)
    if ((!(GetKeyState(VK_CONTROL) & 0x8000)) &&
        (wMsg == WM_CHAR)) 
    {
        // Check for invalid hex characters
        if (!(((WCHAR)wParam >= L'0' && (WCHAR)wParam <= L'9') ||
              ((WCHAR)wParam >= L'a' && (WCHAR)wParam <= L'f') ||
              ((WCHAR)wParam >= L'A' && (WCHAR)wParam <= L'F') ||
              ((WCHAR)wParam == VK_BACK)))
        {
            // Not allowed
            MessageBeep(MB_ICONEXCLAMATION);
            return 0L;
        }
    }

    return CallWindowProc( pIpxEditProc, hwnd, wMsg, wParam, lParam );
}

LRESULT CommonIPXOnContextMenu(HWND hWnd, const DWORD * padwHelpIDs)
{
    Assert(padwHelpIDs);

    WinHelp(hWnd,
        c_szNetCfgHelpFile,
        HELP_CONTEXTMENU,
        (ULONG_PTR)padwHelpIDs);

    return 0;
}

LRESULT CommonIPXOnHelp(LPARAM lParam, const DWORD * padwHelpIDs)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);
    Assert(padwHelpIDs);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        if (padwHelpIDs != NULL)
        {
            WinHelp(static_cast<HWND>(lphi->hItemHandle),
                    c_szNetCfgHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)padwHelpIDs);
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::CIpxConfigDlg
//
//  Purpose:    ctor for the CIpxConfigDlg class
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
CIpxConfigDlg::CIpxConfigDlg(CNwlnkIPX *pmsc, CIpxEnviroment * pIpxEnviroment,
                             CIpxAdapterInfo * pAI)
{
    // Note these parameters are on loan, do not free them...
    Assert(NULL != pmsc);
    Assert(NULL != pIpxEnviroment);
    m_pmsc = pmsc;
    m_pIpxEnviroment = pIpxEnviroment;
    ZeroMemory(&m_WrkstaDlgInfo, sizeof(m_WrkstaDlgInfo));
    m_pAICurrent     = pAI;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::OnInitDialog
//
//  Purpose:    Called when this dialog is first brought up.
//
//  Parameters:
//      uMsg     [in]
//      wParam   [in] See the ATL documentation for params.
//      lParam   [in]
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 11-Apr-1997
//
//  Notes:
//
LRESULT CIpxConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& bHandled)
{
    UINT    nIdx;
    int     aIds[] = {IDS_IPXPP_TEXT_1, IDS_IPXPP_TEXT_2};
    tstring strText;
    WCHAR   szBuf[12];
    HWND    hwndEdit = GetDlgItem(EDT_IPXPP_NETWORKNUMBER);
    HWND    hwndEditINN = GetDlgItem(EDT_IPXAS_INTERNAL);

    // Build the property page's informative text block
    for (nIdx=0; nIdx < celems(aIds); nIdx++)
        strText += SzLoadIds(aIds[nIdx]);

    ::SetWindowText(GetDlgItem(IDC_IPXPP_TEXT), strText.c_str());

    // Subclass the network number edit control
    ::SetWindowLongPtr(hwndEdit, GWLP_USERDATA, ::GetWindowLongPtr(hwndEdit, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);
    ::SetWindowLongPtr(hwndEditINN, GWLP_USERDATA, (LONG_PTR) ::GetWindowLongPtr(hwndEditINN, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEditINN, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);

    // Limit the text in the network # edit control
    ::SendMessage(hwndEdit, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);
    ::SendMessage(hwndEditINN, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);

    // Populate the Inernal Network Number edit control
    HexSzFromDw(szBuf, m_pIpxEnviroment->DwVirtualNetworkNumber());
    ::SetWindowText(hwndEditINN,szBuf);

    // If no adapter cards are present inform the user
    // and disable the UI.
    Assert(NULL != m_pIpxEnviroment);
    if (NULL == m_pAICurrent)
    {
        int aIdc[] = {CMB_IPXPP_FRAMETYPE,
                      EDT_IPXPP_NETWORKNUMBER,
                      IDC_STATIC_NETNUM,
                      IDC_STATIC_FRAMETYPE,
                      GB_IPXPP_ADAPTER,
                      IDC_IPXPP_ADAPTER_TEXT };

        // Disable the dialog controls
        for (nIdx = 0; nIdx<celems(aIdc); nIdx++)
            ::ShowWindow(GetDlgItem(aIdc[nIdx]), SW_HIDE);
    }
    else
    {
        Assert(m_pAICurrent);
        Assert(!m_pAICurrent->FDeletePending());
        Assert(!m_pAICurrent->FDisabled());
        Assert(!m_pAICurrent->FHidden());

        // Move the Adapter Info to the dialog's internal form
        m_WrkstaDlgInfo.pAI = m_pAICurrent;
        m_WrkstaDlgInfo.dwMediaType = m_pAICurrent->DwMediaType();
        m_WrkstaDlgInfo.dwFrameType = m_pAICurrent->DwFrameType();
        m_WrkstaDlgInfo.dwNetworkNumber = m_pAICurrent->DwNetworkNumber();

        // Adjust the UI to reflect the currently selected adapter
        AdapterChanged();
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed.
//
//  Parameters:
//      idCtrl   [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 11-Apr-1997
//
//  Notes:
//
LRESULT CIpxConfigDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
    HWND        hwndEdit = GetDlgItem(EDT_IPXAS_INTERNAL);
    WCHAR       szBuf[12];

    ::GetWindowText(hwndEdit,szBuf,sizeof(szBuf)/sizeof(WCHAR));
    if (0 == lstrlenW(szBuf))
    {
        NcMsgBox(m_hWnd, IDS_MANUAL_FRAME_DETECT, IDS_INCORRECT_NETNUM, MB_OK | MB_ICONEXCLAMATION);
        ::SetFocus(hwndEdit);
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
        return TRUE;
    }

    // Update the virtual network number
    m_pIpxEnviroment->SetVirtualNetworkNumber(DwFromSz(szBuf, 16));

    if (NULL != m_pAICurrent)
    {
        m_pAICurrent->SetDirty(TRUE);

        // Force update of the currently selection items in our internal data
        // structure.  This handles the case case of someone changing only
        // network num, and nothing else on the page.
        FrameTypeChanged();

        // Apply the internal data to original adapter info
        UpdateLstPtstring(m_WrkstaDlgInfo.pAI->m_lstpstrFrmType,
                          m_WrkstaDlgInfo.dwFrameType);

        UpdateLstPtstring(m_WrkstaDlgInfo.pAI->m_lstpstrNetworkNum,
                          m_WrkstaDlgInfo.dwNetworkNumber);
    }

    TraceError("CIpxConfigDlg::OnOk", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxConfigDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPX_CONFIG);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxConfigDlg::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPX_CONFIG);
}


//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::GetFrameType
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 25-Apr-1997
//
const FRAME_TYPE *CIpxConfigDlg::GetFrameType(DWORD dwMediaType)
{
    // Locate the media type
    for (int i=0; i<celems(MediaMap); i++)
        if (MediaMap[i].dwMediaType == dwMediaType)
            return MediaMap[i].aFrameType;

    return aEthernet_Frames;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::UpdateNetworkNumber
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 28-Apr-1997
//
//  Notes:
//
void CIpxConfigDlg::UpdateNetworkNumber(DWORD dwNetworkNumber,
                                        DWORD dwFrameType)
{
    HWND hwndEdit = GetDlgItem(EDT_IPXPP_NETWORKNUMBER);

    if (dwFrameType != AUTO)
    {
        WCHAR szBuf[12];
        HexSzFromDw(szBuf, dwNetworkNumber);
        ::SetWindowText(hwndEdit, szBuf);
        ::EnableWindow(hwndEdit, TRUE);
        ::EnableWindow(GetDlgItem(IDC_STATIC_NETNUM), TRUE);
    }
    else
    {
        ::SetWindowText(hwndEdit, L"");
        ::EnableWindow(hwndEdit, FALSE);
        ::EnableWindow(GetDlgItem(IDC_STATIC_NETNUM), FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::AdapterChanged
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 28-Apr-1997
//
void CIpxConfigDlg::AdapterChanged()
{
    DWORD dwFrameType;
    HWND  hwndFrame = GetDlgItem(CMB_IPXPP_FRAMETYPE);
    HWND  hwndEdit = GetDlgItem(EDT_IPXPP_NETWORKNUMBER);
    int   nIdxLoop;
    int   nIdx;

    const FRAME_TYPE *   pft;

    if ((NULL == hwndFrame) || (NULL == m_pAICurrent))
        return;

    // Locate the Correct Frame Type info for this adapter's media type
    pft = GetFrameType(m_WrkstaDlgInfo.dwMediaType);
    Assert(NULL != pft);

    // Populate the Frame Type Combo
    ::SendMessage(hwndFrame, CB_RESETCONTENT, 0, 0L);
    for (nIdxLoop=0;
         pft[nIdxLoop].nFrameIds != 0;
         nIdxLoop++)
    {
        // Add the Frame Type's descriptive string
        nIdx = ::SendMessage(hwndFrame, CB_ADDSTRING, 0,
                       (LPARAM)(PCWSTR)SzLoadIds(pft[nIdxLoop].nFrameIds));
        if (CB_ERR == nIdx)
            break;

        // Add the Frame Type for convenient access later
        ::SendMessage(hwndFrame, CB_SETITEMDATA, nIdx,
                      pft[nIdxLoop].dwFrameType);
    }

    // Update the network number based on the frame type
    UpdateNetworkNumber(m_WrkstaDlgInfo.dwNetworkNumber,
                        m_WrkstaDlgInfo.dwFrameType);

    switch (m_WrkstaDlgInfo.dwFrameType)
    {
    case ETHERNET:
        nIdx = IDS_ETHERNET;
        break;

    case F802_2:
        switch (m_WrkstaDlgInfo.dwMediaType)
        {
        case TOKEN_MEDIA:
            nIdx = IDS_TK;
            break;

        case FDDI_MEDIA:
            nIdx = IDS_FDDI;
            break;

        default:
            nIdx = IDS_802_2;
            break;
        }
        break;

    case F802_3:
        switch (m_WrkstaDlgInfo.dwMediaType)
        {
        case FDDI_MEDIA:
            nIdx = IDS_FDDI_802_3;
            break;

        default:
            nIdx = IDS_802_3;
            break;
        }
        break;

    case SNAP:
        switch (m_WrkstaDlgInfo.dwMediaType)
        {
        case TOKEN_MEDIA:
            nIdx = IDS_802_5;
            break;

        case FDDI_MEDIA:
            nIdx = IDS_FDDI_SNAP;
            break;

        default:
            nIdx = IDS_SNAP;
            break;
        }
        break;

    case ARCNET:
        nIdx = IDS_ARCNET;
        break;

    case AUTO:
            // Fall through...
    default:
        nIdx = IDS_AUTO;
        break;
    }

    // Set the frame type in the combo box
    ::SendMessage(hwndFrame, CB_SETCURSEL,
            ::SendMessage(hwndFrame, CB_FINDSTRINGEXACT,
                          0, ((LPARAM)(PCWSTR)SzLoadIds(nIdx))), 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::FrameTypeChanged
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 28-Apr-1997
//
void CIpxConfigDlg::FrameTypeChanged()
{
    HWND  hwndFrame =   GetDlgItem(CMB_IPXPP_FRAMETYPE);
    int   nIdx;

    if (NULL == m_pAICurrent)
        return;

    // Locate the currently selected frame type
    nIdx = ::SendMessage(hwndFrame, CB_GETCURSEL, 0, 0L);
    if (CB_ERR == nIdx)
        return;

    // Update the currently selected frame type
    m_WrkstaDlgInfo.dwFrameType = ::SendMessage(hwndFrame, CB_GETITEMDATA, nIdx, 0L);

    SetNetworkNumber(&m_WrkstaDlgInfo.dwNetworkNumber);

    UpdateNetworkNumber(m_WrkstaDlgInfo.dwNetworkNumber,
                        m_WrkstaDlgInfo.dwFrameType);
}

void CIpxConfigDlg::SetNetworkNumber(DWORD *pdw)
{
    WCHAR szBuf[30];
    WCHAR szBuf2[30];
    szBuf[0] = NULL;

    HWND hwndEdit = GetDlgItem(EDT_IPXPP_NETWORKNUMBER);
    if (NULL == hwndEdit)
    {
        return;
    }

    // Get the new number and normalize it...
    ::GetWindowText(hwndEdit, szBuf, sizeof(szBuf)/sizeof(WCHAR));
    *pdw = DwFromSz(szBuf, 16);

    HexSzFromDw(szBuf2, *pdw);

    // Update the edit control if a parsing produced a net change
    if (lstrcmpW(szBuf,szBuf2) != 0)
    {
        ::SetWindowText(hwndEdit, szBuf2);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::HandleNetworkNumber
//
//  Purpose:    Called when the network number edit control gets a message.
//
//  Parameters: See the ATL documentation for params.
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 13-Aug-1997
//
//  Notes:
//
LRESULT
CIpxConfigDlg::HandleNetworkNumber(
    WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (EN_CHANGE == wNotifyCode)
    {
        SetChangedFlag();
    }

    if ((wNotifyCode != EN_KILLFOCUS) || (NULL == m_pAICurrent))
        return 0L;

    SetNetworkNumber(&m_WrkstaDlgInfo.dwNetworkNumber);

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::HandleFrameCombo
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 28-Apr-1997
//
LRESULT CIpxConfigDlg::HandleFrameCombo(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& bHandled)
{
    Assert(CMB_IPXPP_FRAMETYPE == wID);

    if (CBN_SELENDOK != wNotifyCode)
    {
        bHandled = FALSE;
        return 0L;
    }

    FrameTypeChanged();
    SetChangedFlag();

    bHandled = TRUE;

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::CIpxASConfigDlg
//
//  Purpose:    ctor for the CIpxASConfigDlg class
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
CIpxASConfigDlg::CIpxASConfigDlg(CNwlnkIPX *pmsc,
                                 CIpxEnviroment * pIpxEnviroment,
                                 CIpxAdapterInfo * pAI)
{
    // Note these parameters are on loan, do not free them...
    Assert(NULL != pmsc);
    Assert(NULL != pIpxEnviroment);
    m_pmsc = pmsc;
    m_pIpxEnviroment = pIpxEnviroment;
    m_pAICurrent = pAI;
    m_nRadioBttn = 0;
    m_dwMediaType = ETHERNET_MEDIA;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::~CIpxASConfigDlg
//
//  Purpose:    dtor for the CIpxASConfigDlg class
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
CIpxASConfigDlg::~CIpxASConfigDlg()
{
    DeleteColString(&m_lstpstrFrmType);
    DeleteColString(&m_lstpstrNetworkNum);
    m_pmsc = NULL;
    m_pIpxEnviroment = NULL;
    m_pAICurrent = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::FIsNetNumberInUse
//
//  Purpose:    Compare a network number to those already in use.
//              Returning TRUE if the network number is already present.
//
//  Parameters: dwFrameType - Frame Type as a DWORD
//              pszNetNum - Network number as a hex string
//
//  Returns:    BOOL, TRUE if the network number is already present, FALSE otherwise
//
//  Author:     scottbri 29-Apr-1997
//
BOOL CIpxASConfigDlg::FIsNetNumberInUse(DWORD dwFrameType, PCWSTR pszNetNum)
{
    DWORD  dwNetNum = DwFromSz(pszNetNum, 16);

    if (0 == dwNetNum)
    {
        return FALSE;
    }

    list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
    list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();

    while (iterFrmType != m_lstpstrFrmType.end() &&
           iterNetworkNum != m_lstpstrNetworkNum.end())
    {
        tstring *pstr1 = *iterFrmType;
        tstring *pstr2 = *iterNetworkNum;
        if ((DwFromSz(pstr1->c_str(), 16) == dwFrameType) &&
            (DwFromSz(pstr2->c_str(),16) == dwNetNum))
        {
            return TRUE;
        }

        iterFrmType++;
        iterNetworkNum++;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnInitDialog
//
//  Purpose:    Called when this dialog is first brought up.
//
//  Parameters:
//      uMsg     [in]
//      wParam   [in] See the ATL documentation for params.
//      lParam   [in]
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 11-Apr-1997
//
//  Notes:
//
LRESULT CIpxASConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& bHandled)
{
    // Initialize the listview column headings
    int       aIds[] = {IDS_IPXAS_FRAME_TYPE,IDS_IPXAS_NETWORK_NUM};
    HWND      hwndTmp;
    int       iCol;
    LV_COLUMN lvc;
    RECT      rc;
    WCHAR     szBuf[12];

    m_hwndLV = GetDlgItem(LVC_IPXAS_DEST);
    ::GetClientRect(m_hwndLV, &rc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = (rc.right - rc.left) / 2;

    UINT    nIdx;
    int     aIds2[] = {IDS_IPXPP_TEXT_1, IDS_IPXPP_TEXT_2};
    tstring strText;

    // Build the property page's informative text block
    for (nIdx=0; nIdx < celems(aIds2); nIdx++)
    {
        strText += SzLoadIds(aIds2[nIdx]);
    }

    ::SetWindowText(GetDlgItem(IDC_IPXPP_TEXT), strText.c_str());

    // Add columns
    for (iCol = 0; iCol < celems(aIds); iCol++)
    {
        lvc.iSubItem = iCol;
        lvc.pszText = (PWSTR)SzLoadIds(aIds[iCol]);
        if (ListView_InsertColumn(m_hwndLV, iCol, &lvc) == -1)
            return FALSE;
    }

    // Initialize the Internal Network Number Edit Control
    HexSzFromDw(szBuf, m_pIpxEnviroment->DwVirtualNetworkNumber());
    hwndTmp = GetDlgItem(EDT_IPXAS_INTERNAL);
    ::SetWindowText(hwndTmp,szBuf);

    // Subclass the edit control to allow only network number's
    ::SetWindowLongPtr(hwndTmp, GWLP_USERDATA, ::GetWindowLongPtr(hwndTmp, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndTmp, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);

    // Limit the text in the network # edit control
    ::SendMessage(hwndTmp, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);

    // Initialize the rest of the Server's General page
    InitGeneralPage();
    UpdateButtons();

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::UpdateButtons
//
//  Purpose:    Update the button settings on the server's IPX general page
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
void CIpxASConfigDlg::UpdateButtons()
{
    INT  nCount     = ListView_GetItemCount(m_hwndLV);
    HWND hwndEdit   = GetDlgItem(BTN_IPXAS_EDIT);
    HWND hwndRemove = GetDlgItem(BTN_IPXAS_REMOVE);
    HWND hwndAdd    = GetDlgItem(BTN_IPXAS_ADD);
    BOOL fEnableAdd = FALSE;
    BOOL fEnableEditRemove = TRUE;

    Assert(NULL != m_hwndLV);
    if ((0 == nCount) || !IsDlgButtonChecked(BTN_IPXAS_MANUAL))
    {
        fEnableEditRemove = FALSE;
    }

    ::EnableWindow(hwndRemove, fEnableEditRemove);
    ::EnableWindow(hwndEdit, fEnableEditRemove);

    if (NULL != m_pAICurrent)
    {
         fEnableAdd = !(nCount >= DetermineMaxNumFrames());
    }

    if (!IsDlgButtonChecked(BTN_IPXAS_MANUAL))
    {
        fEnableAdd = FALSE;
    }

    ::EnableWindow(hwndAdd, fEnableAdd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::DetermineMaxNumFrames
//
//  Purpose:    Return the max number of frames allowed for a give adapter
//              based on that adapters media type.
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
int CIpxASConfigDlg::DetermineMaxNumFrames()
{
    int n;

    if (NULL == m_pAICurrent)
        return 0;

    switch(m_dwMediaType)
    {
    case FDDI_MEDIA:
        n = 3;
        break;

    case TOKEN_MEDIA:
        n = 2;
        break;

    case ARCNET_MEDIA:
        n = 1;
        break;

    default:
        n = 4;
        break;
    }

    return n;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::InitGeneralPage
//
//  Purpose:    Initialize the Server's IPX general page
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
void CIpxASConfigDlg::InitGeneralPage()
{
    // Populate the adapter list
    int  nIdx;

    // Copy the adapter list info to a local structure
    // to allow user manipulation
    if (NULL != m_pAICurrent)
    {
        Assert(!m_pAICurrent->FDeletePending());
        Assert(!m_pAICurrent->FDisabled());
        Assert(!m_pAICurrent->FHidden());

        // Move the Adapter Info to the dialog's internal form
        m_dwMediaType = m_pAICurrent->DwMediaType();

        // Frame Type lists contain one of two possible values
        // 1) One AUTO entry
        // 2) One or more non-AUTO frame types
        //
        // If the first is not AUTO, then copy the frame and network number
        // pairs.  Otherwise, leave the local lists empty
        DWORD dw = DwFromLstPtstring(m_pAICurrent->m_lstpstrFrmType, c_dwPktTypeDefault, 16);
        if (AUTO != dw)
        {
            list<tstring*>::iterator    iterFrmType;
            list<tstring*>::iterator    iterNetworkNum;
            m_nRadioBttn = BTN_IPXAS_MANUAL;

            // Make an internal copy of the adapter's frame type and
            // Network number information
            for (iterFrmType = m_pAICurrent->m_lstpstrFrmType.begin(),
                  iterNetworkNum = m_pAICurrent->m_lstpstrNetworkNum.begin();
                 iterFrmType != m_pAICurrent->m_lstpstrFrmType.end(),
                  iterNetworkNum != m_pAICurrent->m_lstpstrNetworkNum.end();
                 iterFrmType++, iterNetworkNum++)
            {
                // Copy the Frame Type
                tstring *pstr1 = *iterFrmType;
                m_lstpstrFrmType.push_back(new tstring(pstr1->c_str()));

                // Copy the Network number
                tstring *pstr2 = *iterNetworkNum;
                m_lstpstrNetworkNum.push_back(new tstring(pstr2->c_str()));
            }
        }
        else
        {
            m_nRadioBttn = BTN_IPXAS_AUTO;
        }

        // Update the UI to reflect the currently selected adapter
        UpdateRadioButtons();
        HrUpdateListView();
        UpdateButtons();
    }
    else
    {
        // No adapters installed, disable the dialog sensibly
        //
        ::EnableWindow(GetDlgItem(BTN_IPXAS_MANUAL), FALSE);
        ::EnableWindow(GetDlgItem(BTN_IPXAS_ADD), FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::HrAddItemToList
//
//  Purpose:    Add a row to the list view
//
//  Parameters: idsFrameName - ie ARCNET, Ethernet II, etc
//              pszNetNum - Network number as a hex string
//
//  Returns:    HRESULT, S_OK if everything was added correctly
//
//  Author:     scottbri 29-Apr-1997
//
HRESULT CIpxASConfigDlg::HrAddItemToList(int idsFrameName, PCWSTR pszNetNum)
{
    int nIdx;
    LV_ITEM lvi;
    int nCount = ListView_GetItemCount(m_hwndLV);

    // Add the item info to the list view
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = nCount;
    lvi.iSubItem = 0;
    lvi.state = 0;
    lvi.stateMask = 0;
    lvi.pszText = (PWSTR)SzLoadIds(idsFrameName);
    lvi.cchTextMax = lstrlenW(lvi.pszText);
    lvi.iImage = 0;
    lvi.lParam = idsFrameName;
    nIdx = ListView_InsertItem(m_hwndLV, &lvi);
    if (-1 == nIdx)
    {
        return E_OUTOFMEMORY;
    }

    Assert(lvi.iItem == nIdx);
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 1;
    lvi.pszText = (PWSTR)pszNetNum;
    lvi.cchTextMax = lstrlenW(lvi.pszText);
    if (FALSE == ListView_SetItem(m_hwndLV, &lvi))
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::HrUpdateListView
//
//  Purpose:    Update the contents of the listview
//
//  Parameters: none
//
//  Returns:    HRESULT, S_OK if everything was added correctly
//
//  Author:     scottbri 29-Apr-1997
//
HRESULT CIpxASConfigDlg::HrUpdateListView()
{
    HRESULT hr = S_OK;
    Assert(NULL != m_pAICurrent);
    int    nSize = m_lstpstrFrmType.size();

    if (0 == nSize)
        return S_OK;

    // The list view is expected to be empty when this function is called
    Assert(0 == ListView_GetItemCount(m_hwndLV));

    // For efficency tell the list view how many items we're adding
    ListView_SetItemCount(m_hwndLV, nSize);

    // Enumerate the frame type/network number pairs use that data to
    // populate the list view
    list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
    list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();

    while (iterFrmType != m_lstpstrFrmType.end() &&
           iterNetworkNum != m_lstpstrNetworkNum.end())
    {
        tstring *pstr1 = *iterFrmType;
        tstring *pstr2 = *iterNetworkNum;
        DWORD dwFrameType = DwFromSz(pstr1->c_str(), 16);

        if (F802_2 == dwFrameType)
        {
            switch (m_dwMediaType)
            {
            case TOKEN_MEDIA:
                hr = HrAddItemToList(IDS_TK, pstr2->c_str());
                break;

            case FDDI_MEDIA:
                hr = HrAddItemToList(IDS_FDDI, pstr2->c_str());
                break;

            case ARCNET_MEDIA:
                hr = HrAddItemToList(IDS_ARCNET, pstr2->c_str());
                break;

            default:
                hr = HrAddItemToList(IDS_802_2, pstr2->c_str());
                break;
            }
        }
        else if (ETHERNET == dwFrameType)
        {
            hr = HrAddItemToList(IDS_ETHERNET, pstr2->c_str());
        }
        else if (F802_3 == dwFrameType)
        {
            switch (m_dwMediaType)
            {
            case FDDI_MEDIA:
                hr = HrAddItemToList(IDS_FDDI_802_3, pstr2->c_str());
                break;

            default:
                hr = HrAddItemToList(IDS_802_3, pstr2->c_str());
                break;
            }
        }
        else if (SNAP == dwFrameType)
        {
            switch (m_dwMediaType)
            {
            case TOKEN_MEDIA:
                hr = HrAddItemToList(IDS_802_5, pstr2->c_str());
                break;

            case FDDI_MEDIA:
                hr = HrAddItemToList(IDS_SNAP, pstr2->c_str());
                break;

            default:
                hr = HrAddItemToList(IDS_SNAP, pstr2->c_str());
                break;
            }
        }
        else
        {
            Assert(ARCNET == dwFrameType);
            hr = HrAddItemToList(IDS_ARCNET, pstr2->c_str());
        }

        // Was the network number already present in the list?
        if (S_FALSE == hr)
        {
            // Remove the duplicate network number and frame
            // Note that this usage of erase correctly advances both iterators
            delete pstr1;
            delete pstr2;
            iterFrmType = m_lstpstrFrmType.erase(iterFrmType);
            iterNetworkNum = m_lstpstrNetworkNum.erase(iterNetworkNum);
            hr = S_OK;  // Normalize return
        }
        else if (FAILED(hr))
        {
            break;
        }
        else
        {
            Assert(SUCCEEDED(hr));
            // Advance the iterators
            iterFrmType++;
            iterNetworkNum++;
        }
    }

    // Select the first item in the list
    ListView_SetItemState(m_hwndLV, 0, LVIS_SELECTED, LVIS_SELECTED);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::HandleRadioButton
//
//  Purpose:    React to changes to the dialog's radio buttons
//
//  Parameters: Std ATL handler params
//
//  Returns:    LRESULT
//
//  Author:     scottbri 21-Aug-1997
//
LRESULT CIpxASConfigDlg::HandleRadioButton(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& bHandled)
{
    bHandled = FALSE;

    if ((wNotifyCode != BN_CLICKED) || (NULL == m_pAICurrent))
        return 0;

    SetChangedFlag();

    Assert((BTN_IPXAS_AUTO==wID) || (BTN_IPXAS_MANUAL==wID));
    m_nRadioBttn = wID;
    UpdateButtons();

    bHandled = TRUE;
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::UpdateRadioButtons
//
//  Purpose:    Update the radio button settings based on the selected adapter
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 29-Apr-1997
//
void CIpxASConfigDlg::UpdateRadioButtons()
{
    DWORD dw;

    if (NULL == m_pAICurrent)
    {
        return;
    }

    if (0 == m_nRadioBttn)
    {
        m_nRadioBttn = BTN_IPXAS_AUTO;
    }

    CheckRadioButton(BTN_IPXAS_AUTO, BTN_IPXAS_MANUAL, m_nRadioBttn);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed.
//
//  Parameters:
//      idCtrl   [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 11-Apr-1997
//
//  Notes:
//
LRESULT CIpxASConfigDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT             hr = S_OK;
    WCHAR               szBuf[12];
    HWND                hwndEdit = GetDlgItem(EDT_IPXAS_INTERNAL);

    ::GetWindowText(hwndEdit,szBuf,sizeof(szBuf)/sizeof(WCHAR));
    if (0 == lstrlenW(szBuf))
    {
        NcMsgBox(m_hWnd, IDS_MANUAL_FRAME_DETECT, IDS_INCORRECT_NETNUM, MB_OK | MB_ICONEXCLAMATION);
        ::SetFocus(hwndEdit);
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
        return TRUE;
    }

    // Update the virtual network number
    m_pIpxEnviroment->SetVirtualNetworkNumber(DwFromSz(szBuf, 16));

    // Rewrite the local versions of the frame type and Network Numbers
    if (NULL != m_pAICurrent)
    {
        m_pAICurrent->SetDirty(TRUE);

        // First empty the respective destination lists...
        Assert(NULL != m_pAICurrent);
        DeleteColString(&m_pAICurrent->m_lstpstrFrmType);
        DeleteColString(&m_pAICurrent->m_lstpstrNetworkNum);

        // When the listbox is empty we're in AUTO mode
        if (0 == ListView_GetItemCount(m_hwndLV))
        {
            m_nRadioBttn = BTN_IPXAS_AUTO;
            CheckRadioButton(BTN_IPXAS_AUTO, BTN_IPXAS_MANUAL, m_nRadioBttn);
        }

        // Only transfer the Frame Type/Network Number information if manual
        // frame type detection was requested.
        if (BTN_IPXAS_MANUAL == m_nRadioBttn)
        {
            // Then create new destination lists from the local data
            list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
            list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();

            for (;iterFrmType != m_lstpstrFrmType.end(),
                  iterNetworkNum != m_lstpstrNetworkNum.end();
                  iterFrmType++,
                  iterNetworkNum++)
            {
                tstring *pstr1 = *iterFrmType;
                tstring *pstr2 = *iterNetworkNum;
                m_pAICurrent->m_lstpstrFrmType.push_back(new tstring(pstr1->c_str()));
                m_pAICurrent->m_lstpstrNetworkNum.push_back(new tstring(pstr2->c_str()));
            }
        }

        Assert(m_pAICurrent->m_lstpstrFrmType.size() == m_pAICurrent->m_lstpstrNetworkNum.size());

        // If the destination lists end up empty, supply default values
        if (0 == m_pAICurrent->m_lstpstrFrmType.size())
        {
            WCHAR szBuf[12];
            HexSzFromDw(szBuf, c_dwPktTypeDefault);

            m_pAICurrent->m_lstpstrFrmType.push_back(new tstring(szBuf));
            m_pAICurrent->m_lstpstrNetworkNum.push_back(new tstring(c_sz8Zeros));
        }
    }

    TraceError("CIpxASConfigDlg::OnOk", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxASConfigDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPXAS_CONFIG);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxASConfigDlg::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPXAS_CONFIG);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnAdd
//
//  Purpose:    Called when the Add button is pressed.  Used to add additional
//              frame type/network number pairs
//
//  Parameters:
//      wNotifyCode [in]
//      wID      [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 29-Apr-1997
//
LRESULT CIpxASConfigDlg::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CASAddDialog *       pdlg;

    if (NULL == m_pAICurrent)
        return 0;

    SetChangedFlag();

    // Bring up the dialog
    pdlg = new CASAddDialog(this, m_hwndLV, m_dwMediaType,
                            c_dwPktTypeDefault, c_sz8Zeros);

    if (pdlg == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (pdlg->DoModal(m_hWnd) == IDOK)
    {
        // Update the internal structures and the dialog with the returned values
        if (S_OK == HrAddItemToList(pdlg->IdsGetFrameType(), pdlg->SzGetNetworkNumber()))
        {
            // Validated above, so add to the internal list
            WCHAR szBuf[12];
            HexSzFromDw(szBuf,pdlg->DwGetFrameType());
            m_lstpstrFrmType.push_back(new tstring(szBuf));
            m_lstpstrNetworkNum.push_back(new tstring(pdlg->SzGetNetworkNumber()));

            // Select the new item
            int nCount = ListView_GetItemCount(m_hwndLV);
            Assert(0 < nCount);
            ListView_SetItemState(m_hwndLV, nCount-1, LVIS_SELECTED, LVIS_SELECTED);

            // Update the state of the Add, Edit, and Remove buttons
            HWND hwndFocus = GetFocus();
            UpdateButtons();
            if (!::IsWindowEnabled(hwndFocus))
            {
                ::SetFocus(GetDlgItem(BTN_IPXAS_EDIT));
            }
        }
    }

    delete pdlg;

    return 0;
}

LRESULT CIpxASConfigDlg::HandleInternalNetworkNumber(
    WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (EN_CHANGE == wNotifyCode)
    {
        SetChangedFlag();
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnEdit
//
//  Purpose:    Called when the Edit button is pressed.  Used to edit a
//              Frame Type/Network number pair
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 29-Apr-1997
//
LRESULT CIpxASConfigDlg::OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                  nIdx = 0;
    int                  nIdxSelected;

    // Locate the selected row in the listview
    if (FALSE == FGetSelectedRowIdx(&nIdxSelected))
        return 0;

    if (NULL == m_pAICurrent)
        return 0;

    SetChangedFlag();

    // Enumerate the internal data to locate the frame type/network number for
    // the selection
    list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
    list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();
    while ((iterFrmType != m_lstpstrFrmType.end()) &&
           (iterNetworkNum != m_lstpstrNetworkNum.end()))
    {
        if (nIdx == nIdxSelected)
        {
            tstring *pstr1 = *iterNetworkNum;
            tstring *pstr2 = *iterFrmType;

            // Create the dialog
            CASEditDialog * pdlg = new CASEditDialog(this, m_hwndLV,
                                                     DwFromSz(pstr2->c_str(), 16),
                                                     pstr1->c_str());
            if (pdlg->DoModal(m_hWnd) == IDOK)
            {
                LV_ITEM lvi;

                // Apply the dialog changes to the ListView Control
                ZeroMemory(&lvi, sizeof(lvi));
                lvi.mask = LVIF_TEXT;
                lvi.iItem = nIdxSelected;
                lvi.iSubItem = 1;
                lvi.pszText = (PWSTR)pdlg->SzGetNetworkNumber();
                ListView_SetItem(m_hwndLV, &lvi);

                // Apply the changes to the local data
                *(*iterNetworkNum) = pdlg->SzGetNetworkNumber();
            }

            delete pdlg;
            break;
        }

        nIdx++;
        iterFrmType++;
        iterNetworkNum++;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::FGetSelectedRowIdx
//
//  Purpose:    Returns the index of the selected row in the listview, if it exists
//
//  Parameters: pnIdx [out] - The selected row's zero based index
//
//  Returns:    BOOL, TRUE if a selected row exists, FALSE otherwise
//
BOOL CIpxASConfigDlg::FGetSelectedRowIdx(int *pnIdx)
{
    int nCount = ListView_GetItemCount(m_hwndLV);
    int nIdx;
    LV_ITEM lvi;

    lvi.mask      = LVIF_STATE;
    lvi.iSubItem  = 0;
    lvi.stateMask = LVIS_SELECTED;

    // Determine the selected pair
    for (nIdx = 0; nIdx < nCount; nIdx++)
    {
        lvi.iItem = nIdx;
        if ((TRUE == ListView_GetItem(m_hwndLV, &lvi)) &&
            (lvi.state & LVIS_SELECTED))
        {
            // Located the selected Item
            *pnIdx = nIdx;
            return TRUE;
        }
    }

    *pnIdx = 0;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnRemove
//
//  Purpose:    Called when the Remove button is pressed.  Used to remove a
//              Frame Type/Network Number pair.
//
//  Parameters:
//      wNotifyCode [in]
//      wID      [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 29-Apr-1997
//
LRESULT
CIpxASConfigDlg::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                  nCount;
    int                  nIdx = 0;
    int                  nIdxSelected;
#ifdef DBG
    BOOL                 fFound = FALSE;
#endif

    // Locate the selected row in the listview
    if (FALSE == FGetSelectedRowIdx(&nIdxSelected))
        return 0;

    if (NULL == m_pAICurrent)
        return 0;

    SetChangedFlag();

    // Remove the row from the internal local representation and listview
    list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
    list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();
    while ((iterFrmType != m_lstpstrFrmType.end()) &&
           (iterNetworkNum != m_lstpstrNetworkNum.end()))
    {
        if (nIdx == nIdxSelected)
        {
#ifdef DBG
            fFound = TRUE;
#endif
            // Remove and free the Frame Type piece
            tstring *pstr = *iterFrmType;
            m_lstpstrFrmType.erase(iterFrmType);
            delete pstr;

            // Remove and free the Network Number piece
            pstr = *iterNetworkNum;
            m_lstpstrNetworkNum.erase(iterNetworkNum);
            delete pstr;

            // We're done...
            break;
        }

        nIdx++;
        iterFrmType++;
        iterNetworkNum++;
    }

#ifdef DBG
    Assert(TRUE == fFound);
#endif

    // Remove the frame type/network number pair from the list view
    ListView_DeleteItem(m_hwndLV, nIdxSelected);

    nCount = ListView_GetItemCount(m_hwndLV);
    if (nCount <= nIdxSelected)
    {
        nIdxSelected = nCount - 1;
    }
    if (0 <= nIdxSelected)
    {
        ListView_SetItemState(m_hwndLV, nIdxSelected, LVIS_SELECTED, LVIS_SELECTED);
    }

    // Update the state of the Add, Edit, and Remove buttons
    HWND hwndFocus = GetFocus();
    UpdateButtons();
    if (!::IsWindowEnabled(hwndFocus))
    {
        ::SetFocus(GetDlgItem(BTN_IPXAS_ADD));
    }

    return 0;
}

#ifdef INCLUDE_RIP_ROUTING
//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::CIpxASInternalDlg
//
//  Purpose:    ctor for the CIpxASInternalDlg class
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 29-Apr-1997
//
CIpxASInternalDlg::CIpxASInternalDlg(CNwlnkIPX *pmsc,
                                     CIpxEnviroment * pIpxEnviroment)
{
    // Note these parameters are on loan, do not free them...
    Assert(NULL != pmsc);
    Assert(NULL != pIpxEnviroment);
    m_pmsc = pmsc;
    m_pIpxEnviroment = pIpxEnviroment;

    m_dwRipValue = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnInitDialog
//
//  Purpose:
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CIpxASInternalDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    ::EnableWindow(GetDlgItem(BTN_IPXAS_RIP), m_pIpxEnviroment->FRipEnabled());
    CheckDlgButton(BTN_IPXAS_RIP, m_pIpxEnviroment->FRipEnabled());
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnRip
//
//  Purpose:    Handle changes to the Rip check box on the routing page
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CIpxASInternalDlg::OnRip(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (BN_CLICKED != wNotifyCode)
    {
        bHandled = FALSE;
        return 0L;
    }

    if (!m_pIpxEnviroment->FRipInstalled())
    {
        // Don't allow the user to check this box, if rip isn't installed
        if (IsDlgButtonChecked(BTN_IPXAS_RIP))
            CheckDlgButton(BTN_IPXAS_RIP, FALSE);

        // Tell the user they must install RIP first
        //$ REVIEW - Post Beta 1, this should trigger Rip Installation
        NcMsgBox(m_hWnd, IDS_ROUTING, IDS_INSTALL_RIP,
                     MB_OK | MB_ICONEXCLAMATION);
    }
    else
    {
        m_dwRipValue = 0;

        // Ask the user if they want type 20 broadcast enabled
        if (!m_pIpxEnviroment->FRipInstalled())
        {
            if (IDYES == NcMsgBox(m_hWnd, IDS_ROUTING, IDS_NETBIOS_BROADCAST,
                                  MB_YESNO | MB_ICONQUESTION))
                m_dwRipValue = 1;
        }
    }

    return 0L;
}
//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed.
//
//  Parameters:
//      idCtrl   [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 29-Apr-1997
//
LRESULT CIpxASInternalDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;

    // Was the RIP checkbox changed?
    if (IsDlgButtonChecked(BTN_IPXAS_RIP) != m_pIpxEnviroment->FRipEnabled())
    {
        m_pIpxEnviroment->ChangeRipEnabling(IsDlgButtonChecked(BTN_IPXAS_RIP),
                                            m_dwRipValue);
    }

    TraceError("CIpxASInternalDlg::OnOk", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxASInternalDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPXAS_INTERNAL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxASInternalDlg::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPXAS_INTERNAL);
}

#endif  // INCLUDE_RIP_ROUTING

//+---------------------------------------------------------------------------
//
//  Function:   CenterChildOverListView
//
//  Purpose:    Center the specified top level window over the listview
//              control of the parent dialog
//
//  Parameters: hwnd - Dialog to center
//
//  Returns:    nothing
//
void CenterChildOverListView(HWND hwnd, HWND hwndLV)
{
    RECT rc;
    ::GetWindowRect(hwndLV, &rc);
    ::SetWindowPos(hwnd, NULL,  rc.left, rc.top, 0, 0,
                   SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDialog::CASAddDialog
//
//  Purpose:    ctor for the CASAddDialog class
//
//  Parameters: dwMediaType -
//              dwFrameType -
//              szNetworkNumber -
//
//  Returns:    nothing
//
CASAddDialog::CASAddDialog(CIpxASConfigDlg * pASCD, HWND hwndLV,
                           DWORD dwMediaType, DWORD dwFrameType,
                           PCWSTR pszNetworkNum) :
                           m_strNetworkNumber(pszNetworkNum)
{
    m_pASCD        = pASCD;         // Borrowed pointer
    m_hwndLV       = hwndLV;
    m_dwMediaType  = dwMediaType;
    m_dwFrameType  = dwFrameType;
    m_idsFrameType = 0;             // Out param
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDialog::OnInitDialog
//
//  Purpose:
//
//  Parameters:
//      wNotifyCode [in]
//      wID      [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CASAddDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    Assert(NULL != m_hwndLV);
    HWND hwndCBM = GetDlgItem(CMB_IPXAS_DEST);
    HWND hwndEdit = GetDlgItem(EDT_IPXAS_NETNUM);

    // Search for the set of frames matching this adapter's media type

    for (int idxMM=0; idxMM < celems(MediaMap); idxMM++)
    {
        if (m_dwMediaType == MediaMap[idxMM].dwMediaType)
        {
            const FRAME_TYPE *ft = MediaMap[idxMM].aFrameType;

            // For each frame type not already in use, present in the server's
            // general page ListView, add the available combo box

            for (int idxFT=0; 0 != ft[idxFT].nFrameIds; idxFT++)
            {
                LV_FINDINFO lvfi;
                lvfi.flags = LVFI_STRING;
                lvfi.psz = SzLoadIds(ft[idxFT].nFrameIds);

                if ((IDS_AUTO != ft[idxFT].nFrameIds) &&
                    (-1 == ListView_FindItem(m_hwndLV, -1, &lvfi)))
                {
                    int idx = ::SendMessage(hwndCBM, CB_ADDSTRING, 0,
                                            (LPARAM)SzLoadIds(ft[idxFT].nFrameIds));
                    if (CB_ERR != idx)
                    {
                        // Store the IDS we used for future reference
                        ::SendMessage(hwndCBM, CB_SETITEMDATA, idx, ft[idxFT].nFrameIds);
                    }
                }
            }

            break;
        }
    }

    // Select the first item in the combo box
    Assert(0 != ::SendMessage(hwndCBM, CB_GETCOUNT, 0, 0L));
    ::SendMessage(hwndCBM, CB_SETCURSEL, 0, 0L);

    // Subclass the network number edit control
    ::SetWindowLongPtr(hwndEdit, GWLP_USERDATA,
                       ::GetWindowLongPtr(hwndEdit, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);

    // Limit the text in the network # edit control
    ::SendMessage(hwndEdit, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);

    // Initialize the network controls contents
    ::SetWindowText(hwndEdit, m_strNetworkNumber.c_str());

    // Center window of parent's listview window
    CenterChildOverListView(m_hWnd, m_hwndLV);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDialog::OnOk
//
//  Purpose:
//
//  Parameters:
//      wNotifyCode [in]
//      wID      [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CASAddDialog::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    HWND hwndCBM = GetDlgItem(CMB_IPXAS_DEST);
    WCHAR szBuf[12];

    // Retrieve the network number
    ::GetWindowText(GetDlgItem(EDT_IPXAS_NETNUM), szBuf, sizeof(szBuf)/sizeof(WCHAR));
    if (lstrlenW(szBuf))
    {
        // Normalize value (String -> Number -> Formated String)
        DWORD dw = DwFromSz(szBuf, 16);
        HexSzFromDw(szBuf, dw);
    }
    else
    {
        // Tell the user they must enter a number
        NcMsgBox(m_hWnd, IDS_MANUAL_FRAME_DETECT, IDS_INCORRECT_NETNUM,
                     MB_OK | MB_ICONEXCLAMATION);
        return 0L;
    }

    // Retrieve the selection form the combo box
    int idx = ::SendMessage(hwndCBM, CB_GETCURSEL, 0, 0L);
    if (CB_ERR != idx)
    {
        UINT idsFrameType = ::SendMessage(hwndCBM, CB_GETITEMDATA, idx, 0L);
        Assert(CB_ERR != idsFrameType);

        // Look up the Frame IDS to retreive the actual frame type
        for (int idxMM=0; idxMM < celems(MediaMap); idxMM++)
        {
            if (MediaMap[idxMM].dwMediaType != m_dwMediaType)
            {
                continue;
            }

            const FRAME_TYPE *ft = MediaMap[idxMM].aFrameType;

            for (int idxFT=0; 0 != ft[idxFT].nFrameIds; idxFT++)
            {
                if (ft[idxFT].nFrameIds != idsFrameType)
                {
                    continue;
                }

                // Ensure the frame type/netnum is not in use elsewhere
                if (m_pASCD->FIsNetNumberInUse(ft[idxFT].dwFrameType, szBuf))
                {
                    // Warn the user that the network number specified
                    // was already in use.
                    NcMsgBox(m_hWnd, IDS_GENERAL, IDS_NETNUM_INUSE,
                             MB_OK | MB_ICONEXCLAMATION);
                    goto Done;
                }

                m_strNetworkNumber = szBuf;

                // Return the stashed Frame IDS
                m_idsFrameType = idsFrameType;

                // Return the selected frame type
                m_dwFrameType = ft[idxFT].dwFrameType;
                EndDialog(IDOK);
                return 0;
            }
        }
    }

Done:
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CASAddDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPXAS_FRAME_ADD);
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CASAddDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPXAS_FRAME_ADD);
}



//+---------------------------------------------------------------------------
//
//  Member:     CASEditDialog::OnInitDialog
//
//  Purpose:    Initialize the contents of the Edit Network Number dialog
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CASEditDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    HWND hwndEdit = GetDlgItem(EDT_IPXAS_NETNUM);

    // Set the initial contents of the network number edit control
    ::SetWindowText(hwndEdit, SzGetNetworkNumber());

    // Subclass the network number edit control
    ::SetWindowLongPtr(hwndEdit, GWLP_USERDATA,
                       ::GetWindowLongPtr(hwndEdit, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);

    // Limit the text in the network # edit control
    ::SendMessage(hwndEdit, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);

    // Center the dialog over the listview of the parent
    CenterChildOverListView(m_hWnd, m_hwndLV);

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CASEditDialog::OnOk
//
//  Purpose:    Process the Apply request for the Edit Network Number dialog
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CASEditDialog::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    DWORD dw;
    WCHAR szBuf[12];
    HWND hwndEdit = GetDlgItem(EDT_IPXAS_NETNUM);

    ::GetWindowText(hwndEdit, szBuf, sizeof(szBuf)/sizeof(WCHAR));
    if (0 == lstrlenW(szBuf))
    {
        // Tell the user they must enter a number
        NcMsgBox(m_hWnd, IDS_MANUAL_FRAME_DETECT, IDS_INCORRECT_NETNUM,
                     MB_OK | MB_ICONEXCLAMATION);
        return 0L;
    }

    // Normalize the return value
    dw = DwFromSz(szBuf, 16);
    HexSzFromDw(szBuf, dw);

    // If the network number was changed, verify it's uniqueness
    if ((0 != lstrcmpW(szBuf, m_strNetworkNumber.c_str())) &&
        m_pASCD->FIsNetNumberInUse(m_dwFrameType, szBuf))
    {
        // Warn the user that the network number specified
        // was already in use.
        NcMsgBox(m_hWnd, IDS_GENERAL, IDS_NETNUM_INUSE,
                 MB_OK | MB_ICONEXCLAMATION);
        return 0L;
    }

    // Persist the return value
    m_strNetworkNumber = szBuf;

    EndDialog(IDOK);
    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CASEditDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CASEditDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPXAS_FRAME_EDIT);
}

//+---------------------------------------------------------------------------
//
//  Member:     CASEditDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CASEditDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPXAS_FRAME_EDIT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\nwlnkhlp.h ===
// Copyright (c) 1999, Microsoft Corporation, all rights reserved.
//
// Ipxcfg.h is used by nwlnkcfg.rc
// Help context IDs and Help map
//
// Created in Dev Studio
// 4-22-99 Melissa Simmons


#define IDH_BTN_IPXAS_ADD           17000030
#define IDH_BTN_IPXAS_AUTO          17000027
#define IDH_BTN_IPXAS_EDIT          17000031
#define IDH_BTN_IPXAS_MANUAL        17000028
#define IDH_BTN_IPXAS_REMOVE        17000032
#define IDH_CMB_IPXAS_DEST          17000050
#define IDH_CMB_IPXPP_FRAMETYPE     17000001
#define IDH_EDT_IPXAS_INTERNAL      17000000
#define IDH_EDT_IPXPP_NETWORKNUMBER 17000002
#define IDH_LVC_IPXAS_DEST          17000029

#define IDH_DISABLE_HELP            (DWORD(-1))

const DWORD g_aHelpIDs_DLG_IPX_CONFIG[]=
{
    IDC_STATIC, IDH_DISABLE_HELP,
    EDT_IPXAS_INTERNAL,IDH_EDT_IPXAS_INTERNAL,
    GB_IPXPP_ADAPTER, IDH_DISABLE_HELP,
    IDC_IPXPP_ADAPTER_TEXT, IDH_DISABLE_HELP,
    IDC_STATIC_FRAMETYPE, IDH_CMB_IPXPP_FRAMETYPE,
    CMB_IPXPP_FRAMETYPE,IDH_CMB_IPXPP_FRAMETYPE,
    IDC_STATIC_NETNUM, IDH_EDT_IPXPP_NETWORKNUMBER,
    EDT_IPXPP_NETWORKNUMBER,IDH_EDT_IPXPP_NETWORKNUMBER,
    IDC_IPXPP_TEXT,IDH_DISABLE_HELP,
    0,0
};

const DWORD g_aHelpIDs_DLG_IPXAS_CONFIG[]=
{
    IDC_STATIC, IDH_DISABLE_HELP,
    EDT_IPXAS_INTERNAL,IDH_EDT_IPXAS_INTERNAL,
    IDC_IPXAS_GROUP, IDH_DISABLE_HELP,
    BTN_IPXAS_AUTO,IDH_BTN_IPXAS_AUTO,
    BTN_IPXAS_MANUAL,IDH_BTN_IPXAS_MANUAL,
    LVC_IPXAS_DEST,IDH_LVC_IPXAS_DEST,
    BTN_IPXAS_ADD,IDH_BTN_IPXAS_ADD,
    BTN_IPXAS_EDIT,IDH_BTN_IPXAS_EDIT,
    BTN_IPXAS_REMOVE,IDH_BTN_IPXAS_REMOVE,
    IDC_IPXPP_TEXT,IDH_DISABLE_HELP,
    0,0
};

const DWORD g_aHelpIDs_DLG_IPXAS_FRAME_ADD[]=
{
    IDC_STATIC, IDH_DISABLE_HELP,
    CMB_IPXAS_DEST,IDH_CMB_IPXAS_DEST,
    EDT_IPXAS_NETNUM, IDH_EDT_IPXPP_NETWORKNUMBER,
    0,0
};

const DWORD g_aHelpIDs_DLG_IPXAS_FRAME_EDIT[]=
{
    EDT_IPXAS_NETNUM, IDH_EDT_IPXPP_NETWORKNUMBER,
    0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\nwlnkipx.h ===
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <notifval.h>
#include <ncsetup.h>
#include "nwlnkutl.h"
#include "resource.h"
#include "nwlnkhlp.h"

// Forward references
class CIpxAdapterInfo;
class CNwlnkIPX;
class CIpxConfigDlg;
class CIpxASConfigDlg;

typedef list<tstring *> TSTRING_LIST;


/////////////////////////////////////////////////////////////////////////////
// nwlnkcfg

// Prototype shared constants
extern const WCHAR c_sz8Zeros[];
extern const DWORD c_dwPktTypeDefault;
extern const WCHAR c_szMediaType[];

// Maximum length of a network number
#define MAX_NETNUM_SIZE 8

// Frame Types
#define ETHERNET    0x0
#define F802_3      0x1
#define F802_2      0x2
#define SNAP        0x3
#define ARCNET      0x4
#define AUTO        0xff

// Media Types
#define ETHERNET_MEDIA  0x1
#define TOKEN_MEDIA     0x2
#define FDDI_MEDIA      0x3
#define ARCNET_MEDIA    0x8

class CIpxAdapterInfo
{
    friend class CIpxEnviroment;
    friend class CIpxConfigDlg;
    friend class CIpxASConfigDlg;
public:
    CIpxAdapterInfo();
    ~CIpxAdapterInfo();

    void              SetDeletePending(BOOL f) {m_fDeletePending = f;}
    BOOL              FDeletePending() {return m_fDeletePending;}

    void              SetDisabled(BOOL f) {m_fDisabled = f;}
    BOOL              FDisabled() {return m_fDisabled;}

    void              SetCharacteristics(DWORD dw) {m_dwCharacteristics = dw;}
    BOOL              FHidden() {return !!(NCF_HIDDEN & m_dwCharacteristics);}

    void              AdapterChanged();

    DWORD             DwMediaType() {return m_dwMediaType;}
    void              SetMediaType(DWORD dw) {m_dwMediaType=dw;}

    PCWSTR            SzAdapterDesc() {return m_strAdapterDesc.c_str();}
    void              SetAdapterDesc(PCWSTR psz) {m_strAdapterDesc = psz;}
    PCWSTR            SzBindName() {return m_strBindName.c_str();}
    void              SetBindName(PCWSTR psz) {m_strBindName = psz;}

    DWORD             DwFrameType()
                                {return DwFromLstPtstring(m_lstpstrFrmType,
                                                          AUTO, 16);}
    DWORD             DwNetworkNumber()
                                {return DwFromLstPtstring(m_lstpstrNetworkNum,
                                                          0, 16);}

    TSTRING_LIST *    PFrmTypeList() {return &m_lstpstrFrmType;}
    TSTRING_LIST *    PNetworkNumList() {return &m_lstpstrNetworkNum;}

    GUID *            PInstanceGuid() {return &m_guidInstance;}

    BOOL              IsDirty() {return m_fDirty;}
    VOID              SetDirty(BOOL f) {m_fDirty = f;}

private:
    BOOL              m_fDirty;

    // m_fDisabled is a boolean that, when TRUE, indicates this adapter
    // is currently disabled
    BOOL              m_fDisabled;

    // m_fDeletePending is a boolean that, when TRUE, indicates this adapter
    // is being removed from the adapter list (eventually)
    BOOL              m_fDeletePending;

    // m_dwCharacteristics contains the adapter's characteristic settings
    DWORD             m_dwCharacteristics;

    DWORD             m_dwMediaType;
    GUID              m_guidInstance;
    tstring           m_strAdapterDesc;
    tstring           m_strBindName;
    TSTRING_LIST      m_lstpstrFrmType;
    TSTRING_LIST      m_lstpstrNetworkNum;
};

typedef list<CIpxAdapterInfo *> ADAPTER_INFO_LIST;

typedef struct _tagIpxParams
{
    DWORD dwDedicatedRouter;
    DWORD dwEnableWANRouter;
    DWORD dwInitDatagrams;
    DWORD dwMaxDatagrams;
    DWORD dwReplaceConfigDialog;
    DWORD dwRipCount;
    DWORD dwRipTimeout;
    DWORD dwRipUsageTime;
    DWORD dwSocketEnd;
    DWORD dwSocketStart;
    DWORD dwSocketUniqueness;
    DWORD dwSourceRouteUsageTime;
    DWORD dwVirtualNetworkNumber;
} IpxParams;

class CIpxEnviroment
{
private:
    CIpxEnviroment(CNwlnkIPX *);
    HRESULT HrGetIpxParams();
    HRESULT HrGetAdapterInfo();
    HRESULT HrWriteAdapterInfo();
    HRESULT HrOpenIpxAdapterSubkey(HKEY *phkey, BOOL fCreate);
    HRESULT HrOpenIpxAdapterSubkeyEx(PCWSTR pszKeyName,
                                            DWORD dwAccess,
                                            BOOL fCreate, HKEY *phkey);

public:
    ~CIpxEnviroment();

    // Create and initialize a CIpxEnviroment instance
    static HRESULT   HrCreate(CNwlnkIPX *, CIpxEnviroment **);

    // Call to update registry
    HRESULT          HrUpdateRegistry();

    // Return a reference to the Adapter list
    ADAPTER_INFO_LIST & AdapterInfoList() {return m_lstpAdapterInfo;}

    // Create an CIpxAdapterInfo instance from settings in the registry
    HRESULT   HrGetOneAdapterInfo(INetCfgComponent * pNCC,
                                         CIpxAdapterInfo ** ppAI);

    // Write one CIpxAdapterInfo to the registry
    HRESULT   HrWriteOneAdapterInfo(HKEY hkey, CIpxAdapterInfo* pAI);

    // Remove an adapter from the list
    VOID RemoveAdapter(CIpxAdapterInfo * pAI);

    // Add an adapter to the list
    HRESULT HrAddAdapter(INetCfgComponent * pncc);

    DWORD DwCountValidAdapters();

    DWORD DwVirtualNetworkNumber() {return m_IpxParams.dwVirtualNetworkNumber;}
    void  SetVirtualNetworkNumber(DWORD dw) {m_IpxParams.dwVirtualNetworkNumber = dw;}

    BOOL  FRipInstalled() {return m_fRipInstalled;}
    BOOL  FRipEnabled()   {return m_fEnableRip;}
    void  ChangeRipEnabling(BOOL fEnable, DWORD dwRipVal)
                          { m_fEnableRip = fEnable;
                            m_dwRipValue = dwRipVal; }

    void  SetDedicatedRouter(BOOL f) {m_IpxParams.dwDedicatedRouter = (f ? 1 : 0);}
    void  SetEnableWANRouter(BOOL f) {m_IpxParams.dwEnableWANRouter = (f ? 1 : 0);}

    void  ReleaseAdapterInfo();

private:
    CNwlnkIPX *         m_pno;

    BOOL                m_fRipInstalled;    // NwlnkRip\Parameters
    BOOL                m_fEnableRip;       // NwlnkRip\Parameters

    DWORD               m_dwRipValue;       // NetbiosRouting = {1,0}

    IpxParams           m_IpxParams;        // NwlnkIpx\Parameters
    ADAPTER_INFO_LIST   m_lstpAdapterInfo;  // list of Adapters
};

// Pair Specific Sets of FRAME ID Strings with FRAME ID Values
typedef struct
{
    UINT    nFrameIds;
    DWORD   dwFrameType;
} FRAME_TYPE;

// Pairs Specific Media Types with sets Valid Frame Types
typedef struct
{
    DWORD              dwMediaType;
    const FRAME_TYPE * aFrameType;
} MEDIA_TYPE;

typedef struct
{
    CIpxAdapterInfo *pAI;
    DWORD dwMediaType;
    DWORD dwFrameType;
    DWORD dwNetworkNumber;
} WRKSTA_DIALOG_INFO;

//
// Ipx Workstation Configuration Dialog
//
class CIpxConfigDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CIpxConfigDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(EDT_IPXPP_NETWORKNUMBER,HandleNetworkNumber)
        COMMAND_ID_HANDLER(CMB_IPXPP_FRAMETYPE, HandleFrameCombo)
    END_MSG_MAP()

    CIpxConfigDlg(CNwlnkIPX *pmsc, CIpxEnviroment * pIpxEnviroment,
                  CIpxAdapterInfo * pAI);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT HandleNetworkNumber(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& bHandled);

    const FRAME_TYPE *GetFrameType(DWORD dwMediaType);

    void AdapterChanged();
    void FrameTypeChanged();
    void SetNetworkNumber(DWORD *pdw);
    void UpdateNetworkNumber(DWORD dwNetworkNumber, DWORD dwFrameType);

    LRESULT HandleFrameCombo(WORD wNotifyCode, WORD wID,
                             HWND hWndCtl, BOOL& bHandled);
private:
    CNwlnkIPX *         m_pmsc;
    CIpxEnviroment *    m_pIpxEnviroment;
    CIpxAdapterInfo *   m_pAICurrent;   // The current adapter
    WRKSTA_DIALOG_INFO  m_WrkstaDlgInfo;
};

typedef struct
{
    CIpxAdapterInfo *   pAI;
    UINT                nRadioBttn;
    DWORD               dwMediaType;
    list<tstring *>     lstpstrFrmType;
    list<tstring *>     lstpstrNetworkNum;
} SERVER_DIALOG_INFO;

// Dialog class to handle Add Frame feature
//
class CASAddDialog : public CDialogImpl<CASAddDialog>
{
public:
    enum { IDD = DLG_IPXAS_FRAME_ADD };

    BEGIN_MSG_MAP(CASAddDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDOK, OnOk);
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel);
    END_MSG_MAP()

public:
    CASAddDialog(CIpxASConfigDlg * pASCD, HWND hwndLV, DWORD dwMediaType,
                 DWORD dwFrame, PCWSTR pszNetworkNum);
    ~CASAddDialog() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
                    {EndDialog(IDCANCEL); return 0;}

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    int     IdsGetFrameType()    {return m_idsFrameType;}
    DWORD   DwGetFrameType()     {return m_dwFrameType;}
    PCWSTR SzGetNetworkNumber() {return m_strNetworkNumber.c_str();}

private:
    HWND                m_hwndLV;
    DWORD               m_dwMediaType;
    DWORD               m_dwFrameType;
    int                 m_idsFrameType;
    tstring             m_strNetworkNumber;
    CIpxASConfigDlg *   m_pASCD;
};

// Dialog class to handle Edit Network Number feature
//
class CASEditDialog : public CDialogImpl<CASEditDialog>
{
public:
    enum { IDD = DLG_IPXAS_FRAME_EDIT };

    BEGIN_MSG_MAP(CASEditDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDOK, OnOk);
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel);
    END_MSG_MAP()

public:
    CASEditDialog(CIpxASConfigDlg * pASCD, HWND hwndLV,
                  DWORD dwFrameType, PCWSTR pszNetworkNum) :
                m_strNetworkNumber(pszNetworkNum),
                m_dwFrameType(dwFrameType),
                m_hwndLV(hwndLV),
                m_pASCD(pASCD) {}
    ~CASEditDialog() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
                    {EndDialog(IDCANCEL); return 0;}
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    PCWSTR SzGetNetworkNumber() {return m_strNetworkNumber.c_str();}

private:
    DWORD               m_dwFrameType;
    tstring             m_strNetworkNumber;
    HWND                m_hwndLV;
    CIpxASConfigDlg *   m_pASCD;
};

//
// Ipx Server Configuration Dialog
//
class CIpxASConfigDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CIpxASConfigDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(EDT_IPXAS_INTERNAL,HandleInternalNetworkNumber)
        COMMAND_ID_HANDLER(BTN_IPXAS_ADD, OnAdd)
        COMMAND_ID_HANDLER(BTN_IPXAS_EDIT, OnEdit)
        COMMAND_ID_HANDLER(BTN_IPXAS_REMOVE, OnRemove)
        COMMAND_ID_HANDLER(BTN_IPXAS_AUTO, HandleRadioButton)
        COMMAND_ID_HANDLER(BTN_IPXAS_MANUAL, HandleRadioButton)
    END_MSG_MAP()

    CIpxASConfigDlg(CNwlnkIPX *, CIpxEnviroment *, CIpxAdapterInfo *);
    ~CIpxASConfigDlg();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    BOOL    FIsNetNumberInUse(DWORD dwFrameType, PCWSTR pszNetNum);

private:
    void UpdateRadioButtons();
    void UpdateButtons();
    void InitGeneralPage();
    int  DetermineMaxNumFrames();
    LRESULT HandleInternalNetworkNumber(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT HandleRadioButton(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    HRESULT HrUpdateListView();
    HRESULT HrAddItemToList(int idsFrameName, PCWSTR pszNetNum);
    BOOL FGetSelectedRowIdx(int *pnIdx);

private:
    CNwlnkIPX *         m_pmsc;
    CIpxEnviroment *    m_pIpxEnviroment;
    CIpxAdapterInfo *   m_pAICurrent;   // The current adapter

    HWND                m_hwndLV;

    UINT                m_nRadioBttn;
    DWORD               m_dwMediaType;
    list<tstring *>     m_lstpstrFrmType;
    list<tstring *>     m_lstpstrNetworkNum;
};

#ifdef INCLUDE_RIP_ROUTING
//
// Ipx Server Routing Dialog
//
class CIpxASInternalDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CIpxASInternalDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(BTN_IPXAS_RIP, OnRip)
    END_MSG_MAP()

    CIpxASInternalDlg(CNwlnkIPX *pmsc, CIpxEnviroment * pIpxEnviroment);
    ~CIpxASInternalDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnRip(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    CNwlnkIPX *         m_pmsc;
    CIpxEnviroment *    m_pIpxEnviroment;

    DWORD               m_dwRipValue;
};
#endif

class ATL_NO_VTABLE CNwlnkIPX :
    public CComObjectRoot,
    public CComCoClass<CNwlnkIPX, &CLSID_CNwlnkIPX>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding,
    public IIpxAdapterInfo
{
public:
    CNwlnkIPX();
    ~CNwlnkIPX();

    BEGIN_COM_MAP(CNwlnkIPX)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(IIpxAdapterInfo)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNwlnkIPX)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NWLNKIPX)

    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};


// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Upgrade)             (DWORD, DWORD);
    STDMETHOD (Removing)            ();

// INetCfgComponentPropertyUi
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// INetCfgComponentNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// IIpxAdapterInfo
    STDMETHOD (GetFrameTypesForAdapter)   (PCWSTR pszAdapterBindName,
                                           DWORD   cFrameTypesMax,
                                           DWORD*  anFrameTypes,
                                           DWORD*  pcFrameTypes);
    STDMETHOD (GetVirtualNetworkNumber)   (DWORD* pdwVNetworkNumber);
    STDMETHOD (SetVirtualNetworkNumber)   (DWORD dwVNetworkNumber);

private:
    STDMETHOD(HrCommitInstall)();
    STDMETHOD(HrCommitRemove)();

    HRESULT HrReconfigIpx();
    VOID    CleanupPropPages();
    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                PCWSTR pszAnswerSection);
    HRESULT HrReadAdapterAnswerFileSection(CSetupInfFile * pcsif,
                                           PCWSTR pszSection);

public:
    VOID MarkAdapterListChanged() {m_fAdapterListChanged = TRUE;};

private:
    INetCfgComponent*   m_pnccMe;
    INetCfg*            m_pNetCfg;
    BOOL                m_fNetworkInstall;
    BOOL                m_fAdapterListChanged;
    BOOL                m_fPropertyChanged;
    INSTALLACTION       m_eInstallAction;
    CPropSheetPage*     m_pspObj1;
    CPropSheetPage*     m_pspObj2;
    CIpxEnviroment*     m_pIpxEnviroment;
    IUnknown*           m_pUnkPropContext;

friend class CIpxEnviroment;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\nwlnknb.cpp ===
// nwlnknb.cpp : Implementation of CNwlnkNB

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "ncreg.h"
#include "ncsvc.h"
#include "nwlnknb.h"
#include "nwlnkipx.h"

CNwlnkNB::CNwlnkNB() :
    m_pnccMe(NULL),
    m_pNetCfg(NULL),
    m_eInstallAction(eActUnknown),
    m_eNbState(eStateNoChange)
{
}

CNwlnkNB::~CNwlnkNB()
{
    ReleaseObj(m_pNetCfg);
    ReleaseObj(m_pnccMe);
}

// INetCfgNotify

STDMETHODIMP CNwlnkNB::Initialize (
    INetCfgComponent* pncc,
    INetCfg* pNetCfg,
    BOOL fInstalling)
{
    Validate_INetCfgNotify_Initialize(pncc, pNetCfg, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pNetCfg = pNetCfg);

    // See if DNS is already installed.  If it is we need to be disabled
    if (fInstalling &&
        (S_OK == m_pNetCfg->FindComponent(L"MS_DNSServer", NULL)))
    {
        m_eNbState = eStateDisable;
    }

    return S_OK;
}

STDMETHODIMP CNwlnkNB::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile, pszAnswerSection);
    return S_OK;
}

STDMETHODIMP CNwlnkNB::Install (
    DWORD dwSetupFlags)
{
    m_eInstallAction = eActInstall;
    return S_OK;
}

STDMETHODIMP CNwlnkNB::Removing ()
{
    m_eInstallAction = eActRemove;
    return S_OK;
}

STDMETHODIMP CNwlnkNB::Validate ()
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::ApplyRegistryChanges ()
{
    UpdateBrowserDirectHostBinding ();

    if ((eActRemove != m_eInstallAction) &&
        (eStateNoChange != m_eNbState))
    {
        UpdateNwlnkNbStartType();
    }

    return S_OK;
}

// INetCfgSystemNotify

STDMETHODIMP CNwlnkNB::GetSupportedNotifications (
    DWORD* pdwSupportedNotifications )
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications(pdwSupportedNotifications);

    // Want to know when DNS comes and goes
    *pdwSupportedNotifications = NCN_NETSERVICE | NCN_ADD | NCN_REMOVE;
    return S_OK;
}

STDMETHODIMP CNwlnkNB::SysQueryBindingPath (
    DWORD dwChangeFlag,
    INetCfgBindingPath* pIPath)
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::SysQueryComponent (
    DWORD dwChangeFlag,
    INetCfgComponent* pIComp)
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::SysNotifyBindingPath (
    DWORD dwChangeFlag,
    INetCfgBindingPath* pIPath)
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::SysNotifyComponent (
    DWORD dwChangeFlag,
    INetCfgComponent* pnccItem)
{
    Validate_INetCfgSystemNotify_SysNotifyComponent(dwChangeFlag, pnccItem);

    // Assume we won't be dirty as a result of this notification.
    //
    HRESULT hr = S_FALSE;

    // If this component does not identify itself as DNS then skip it...
    if (FIsComponentId(L"MS_DNSServer", pnccItem))
    {
        // Disable/Enable NetBIOS when DNS is Added/Removed
        if (dwChangeFlag & NCN_ADD)
        {
            // Disable and shutdown NwlnkNb
            m_eNbState = eStateDisable;
            hr = S_OK;
        }
        else if (dwChangeFlag & NCN_REMOVE)
        {
            // Re-enable NwlnkNb
            m_eNbState = eStateEnable;
            hr = S_OK;
        }
    }

    return hr;
}


//
// Function:    CNwlnkNB::UpdateNwlnkNbStartType
//
// Purpose:     Enable or disable NwlnkNb
//
//
VOID
CNwlnkNB::UpdateNwlnkNbStartType(
    VOID)
{
    HRESULT hr;
    CServiceManager scm;
    CService        svc;

    hr = scm.HrOpenService(&svc, L"NwlnkNb");
    if (S_OK == hr)
    {
        if (eStateDisable == m_eNbState)
        {
            (VOID) svc.HrSetStartType(SERVICE_DISABLED);
            svc.Close();

            (VOID) scm.HrStopServiceNoWait(L"NwlnkNb");
        }
        else if (eStateEnable == m_eNbState)
        {
            (VOID) svc.HrSetStartType(SERVICE_DEMAND_START);
        }
    }
}

VOID
CNwlnkNB::UpdateBrowserDirectHostBinding(
    VOID)
{
    HRESULT hr;
    BOOL fBound = FALSE;

    // We don't need to check if client is bound to us if we are being
    // removed.
    //
    if (eActRemove != m_eInstallAction)
    {
        INetCfgComponent* pMsClient;

        hr = m_pNetCfg->FindComponent (L"ms_msclient", &pMsClient);
        if (S_OK == hr)
        {
            INetCfgComponentBindings* pMsClientBindings;
            hr = pMsClient->QueryInterface (IID_INetCfgComponentBindings,
                                (VOID**)&pMsClientBindings);
            if (S_OK == hr)
            {
                fBound = (S_OK == pMsClientBindings->IsBoundTo (m_pnccMe));

                ReleaseObj (pMsClientBindings);
            }

            ReleaseObj (pMsClient);
        }
    }

    HKEY hkey;

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\Browser\\Parameters",
            KEY_ALL_ACCESS, &hkey);

    if (S_OK == hr)
    {
        static const WCHAR c_szDirectHostBinding[] = L"DirectHostBinding";

        if (fBound)
        {
            // Write the DirectHostBinding info since we are directly bound
            //
            hr = HrRegSetMultiSz (hkey,
                    c_szDirectHostBinding,
                    L"\\Device\\NwlnkIpx\0\\Device\\NwlnkNb\0");
        }
        else
        {
            // Remove the DirectHostBinding value
            //
            (VOID) HrRegDeleteValue (hkey, c_szDirectHostBinding);
        }

        RegCloseKey (hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\nwlnkipx.cpp ===
// nwlnkipx.cpp : Implementation of CNwlnkIPX

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <netconp.h>
#include "ncmisc.h"
#include "ncnetcfg.h"
#include "ncpnp.h"
#include "ncreg.h"
#include "nwlnkipx.h"

extern const WCHAR c_szAdapterSections[];
extern const WCHAR c_szAdapters[];
extern const WCHAR c_szSpecificTo[];
extern const WCHAR c_szSvcNwlnkIpx[];
extern const WCHAR c_szInfId_MS_NWNB[];
extern const WCHAR c_szInfId_MS_NWSPX[];


static const WCHAR c_szProviderOrderVal[]      = L"ProviderOrder";
static const WCHAR c_szSrvProvOrderKey[]       = L"System\\CurrentControlSet\\Control\\ServiceProvider\\Order";

const WCHAR c_sz0xPrefix[]                   = L"0x";
const WCHAR c_sz8Zeros[]                     = L"00000000";
const DWORD c_dwPktTypeDefault               = AUTO;
const WCHAR c_szMediaType[]                  = L"MediaType";

static const WCHAR c_szIpxParameters[]       = L"System\\CurrentControlSet\\Services\\NwlnkIpx\\Parameters";
static const WCHAR c_szPktType[]             = L"PktType";
static const WCHAR c_szNetworkNumber[]       = L"NetworkNumber";
static const WCHAR c_szDedicatedRouter[]     = L"DedicatedRouter";
static const WCHAR c_szEnableWANRouter[]     = L"EnableWANRouter";
static const WCHAR c_szInitDatagrams[]       = L"InitDatagrams";
static const WCHAR c_szMaxDatagrams[]        = L"MaxDatagrams";
static const WCHAR c_szReplaceConfigDialog[] = L"ReplaceConfigDialog";
static const WCHAR c_szRipCount[]            = L"RipCount";
static const WCHAR c_szRipTimeout[]          = L"RipTimeout";
static const WCHAR c_szRipUsageTime[]        = L"RipUsageTime";
static const WCHAR c_szSocketEnd[]           = L"SocketEnd";
static const WCHAR c_szSocketStart[]         = L"SocketStart";
static const WCHAR c_szSocketUniqueness[]    = L"SocketUniqueness";
static const WCHAR c_szSourceRouteUsageTime[]= L"SourceRouteUsageTime";
static const WCHAR c_szVirtualNetworkNumber[]= L"VirtualNetworkNumber";

static const DWORD c_dwBindSap            = 0x8137;
static const DWORD c_dwEnableFuncaddr     = 1;
static const DWORD c_dwMaxPktSize         = 0;
static const DWORD c_dwSourceRouteBCast   = 0;
static const DWORD c_dwSourceRouteMCast   = 0;
static const DWORD c_dwSourceRouteDef     = 0;
static const DWORD c_dwSourceRouting      = 1;

static const WCHAR c_szBindSap[]          = L"BindSap";
static const WCHAR c_szEnableFuncaddr[]   = L"EnableFuncaddr";
static const WCHAR c_szMaxPktSize[]       = L"MaxPktSize";
static const WCHAR c_szSourceRouteBCast[] = L"SourceRouteBCast";
static const WCHAR c_szSourceRouteMCast[] = L"SourceRouteMCast";
static const WCHAR c_szSourceRouteDef[]   = L"SourceRouteDef";
static const WCHAR c_szSourceRouting[]    = L"SourceRouting";

static const DWORD c_dwDedicatedRouter      = 0;
static const DWORD c_dwEnableWANRouter      = 0;
static const DWORD c_dwInitDatagrams        = 0xa;
static const DWORD c_dwMaxDatagrams         = 0x32;
static const DWORD c_dwReplaceConfigDialog  = 0;
static const DWORD c_dwRipCount             = 0x5;
static const DWORD c_dwRipTimeout           = 0x1;
static const DWORD c_dwRipUsageTime         = 0xf;
static const DWORD c_dwSocketEnd            = 0x5fff;
static const DWORD c_dwSocketStart          = 0x4000;
static const DWORD c_dwSocketUniqueness     = 0x8;
static const DWORD c_dwSourceRouteUsageTime = 0xf;
static const DWORD c_dwVirtualNetworkNumber = 0;

static const REGBATCH regbatchIpx[] = {
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szDedicatedRouter, REG_DWORD,
         offsetof(IpxParams,dwDedicatedRouter), (BYTE *)&c_dwDedicatedRouter},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szEnableWANRouter, REG_DWORD,
         offsetof(IpxParams,dwEnableWANRouter), (BYTE *)&c_dwEnableWANRouter},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szInitDatagrams, REG_DWORD,
         offsetof(IpxParams,dwInitDatagrams), (BYTE *)&c_dwInitDatagrams},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szMaxDatagrams, REG_DWORD,
         offsetof(IpxParams,dwMaxDatagrams), (BYTE *)&c_dwMaxDatagrams},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szReplaceConfigDialog, REG_DWORD,
         offsetof(IpxParams,dwReplaceConfigDialog), (BYTE *)&c_dwReplaceConfigDialog},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szRipCount, REG_DWORD,
         offsetof(IpxParams,dwRipCount), (BYTE *)&c_dwRipCount},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szRipTimeout, REG_DWORD,
         offsetof(IpxParams,dwRipTimeout), (BYTE *)&c_dwRipTimeout},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szRipUsageTime, REG_DWORD,
         offsetof(IpxParams,dwRipUsageTime), (BYTE *)&c_dwRipUsageTime},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szSocketEnd, REG_DWORD,
         offsetof(IpxParams,dwSocketEnd), (BYTE *)&c_dwSocketEnd},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szSocketStart, REG_DWORD,
         offsetof(IpxParams,dwSocketStart), (BYTE *)&c_dwSocketStart},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szSocketUniqueness, REG_DWORD,
         offsetof(IpxParams,dwSocketUniqueness), (BYTE *)&c_dwSocketUniqueness},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szSourceRouteUsageTime, REG_DWORD,
         offsetof(IpxParams,dwSourceRouteUsageTime), (BYTE *)&c_dwSourceRouteUsageTime},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szVirtualNetworkNumber, REG_DWORD,
         offsetof(IpxParams,dwVirtualNetworkNumber), (BYTE *)&c_dwVirtualNetworkNumber}};


CNwlnkIPX::CNwlnkIPX() :
    m_pnccMe(NULL),
    m_pNetCfg(NULL),
    m_fNetworkInstall(FALSE),
    m_fAdapterListChanged(FALSE),
    m_fPropertyChanged(FALSE),
    m_eInstallAction(eActUnknown),
    m_pspObj1(NULL),
    m_pspObj2(NULL),
    m_pIpxEnviroment(NULL),
    m_pUnkPropContext(NULL)
{
}

CNwlnkIPX::~CNwlnkIPX()
{
    ReleaseObj(m_pUnkPropContext);
    ReleaseObj(m_pNetCfg);
    ReleaseObj(m_pnccMe);

    delete m_pIpxEnviroment;

    CleanupPropPages();
}


// INetCfgNotify

STDMETHODIMP CNwlnkIPX::Initialize (
    INetCfgComponent* pncc,
    INetCfg* pNetCfg,
    BOOL fInstalling)
{
    HRESULT hr;

    Validate_INetCfgNotify_Initialize(pncc, pNetCfg, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pNetCfg = pNetCfg);

    //
    // Determine if the Netware stack is installed, if so DO NOT
    // install over it.
    //
    if (FIsNetwareIpxInstalled())
    {
        //TODO: EventLog(Novell Netware already installed);
        //$REVIEW: Do we just want to silently proceed an do nothing?
    }

    // Query current settings
    hr = CIpxEnviroment::HrCreate(this, &m_pIpxEnviroment);

    TraceError("CNwlnkIPX::Initialize",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::Upgrade(DWORD, DWORD)
{
    return S_FALSE;
}

STDMETHODIMP CNwlnkIPX::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    HRESULT hr = S_OK;

    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile, pszAnswerSection );

    // Record the fact that this is a network installation
    m_fNetworkInstall = TRUE;
    m_eInstallAction = eActInstall;

    // Only process answer file and install sub-components if the answer file
    // is present.  If the answer file is not present we should already be installed.
    if (NULL == pszAnswerFile)
    {
        goto Error;     // Success case
    }

    // Read the Answer file contents
    hr = HrProcessAnswerFile(pszAnswerFile,
                             pszAnswerSection);
    if (FAILED(hr))
    {
        goto Error;
    }

Error:
    TraceError("CNwlnkIPX::ReadAnswerFile",hr);
    return hr;
}

//
// Function:    CNwlnkIPX::HrProcessAnswerFile
//
// Purpose:     Process the answer file information, merging
//              its contents into the internal information
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CNwlnkIPX::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    CSetupInfFile   csif;
    DWORD           dwData;
    BOOL            fValue;
    HRESULT         hr = S_OK;
    INFCONTEXT      infctx;

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Release all of the adapter specific info
    Assert(NULL != m_pIpxEnviroment);
    m_pIpxEnviroment->ReleaseAdapterInfo();

    // Read the DedicatedRouter parameter
    hr = csif.HrGetStringAsBool(pszAnswerSection, c_szDedicatedRouter,
                                &fValue);
    if (SUCCEEDED(hr))
    {
        m_pIpxEnviroment->SetDedicatedRouter(fValue);
    }

    // Read the EnableWANRouter parameter
    hr = csif.HrGetStringAsBool(pszAnswerSection, c_szEnableWANRouter,
                                &fValue);
    if (SUCCEEDED(hr))
    {
        m_pIpxEnviroment->SetEnableWANRouter(fValue);
    }

    // Read the virtual network number
    hr = csif.HrGetDword(pszAnswerSection, c_szVirtualNetworkNumber, &dwData);
    if (SUCCEEDED(hr))
    {
        m_pIpxEnviroment->SetVirtualNetworkNumber(dwData);
    }

    // Read the property containing the list of adapter sections
    hr = ::HrSetupFindFirstLine(csif.Hinf(), pszAnswerSection,
                                c_szAdapterSections, &infctx);
    if (SUCCEEDED(hr))
    {
        DWORD dwIdx;
        DWORD dwCnt = SetupGetFieldCount(&infctx);
        tstring str;

        // For each adapter in the list read the adapter information
        for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
        {
            hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
            if (FAILED(hr))
            {
                TraceError("CNwlnkIPX::HrProcessAnswerFile - Failed to read adapter section name",hr);
                break;
            }

            hr = HrReadAdapterAnswerFileSection(&csif, str.c_str());
            if (FAILED(hr))
            {
                goto Error;
            }
        }
    }

    hr = S_OK;

Error:
    TraceError("CNwlnkIpx::HrProcessAnswerFile", hr);
    return hr;
}

//
// Function:    CNwlnkIPX::HrReadAdapterAnswerFileSection
//
// Purpose:     Read the adapter answer file section and create
//              the adapter info section if successful
//
// Parameters:
//
// Returns:
//
HRESULT
CNwlnkIPX::HrReadAdapterAnswerFileSection(CSetupInfFile * pcsif,
                                          PCWSTR pszSection)
{
    HRESULT           hr = S_OK;
    CIpxAdapterInfo * pAI = NULL;
    INetCfgComponent* pncc = NULL;
    tstring           str;

    // Read the SpecificTo adapter name
    hr = pcsif->HrGetString(pszSection, c_szSpecificTo, &str);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Search for the specified adapter in the set of existing adapters
    hr = ::HrAnswerFileAdapterToPNCC(m_pNetCfg, str.c_str(), &pncc);
    if (FAILED(hr))
    {
        goto Error;
    }

    // if we found the adapter component object (pncc != NULL) process
    // the adapter section
    if (pncc)
    {
        DWORD       dwIdx;
        DWORD       dwCnt;
        INFCONTEXT  infctx;

        pAI = new CIpxAdapterInfo;
        Assert(NULL != pAI);

        // Query the adapter component info
        hr = ::HrQueryAdapterComponentInfo(pncc, pAI);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Read the PktType (Failure is usually just "not found")
        hr = ::HrSetupFindFirstLine(pcsif->Hinf(), pszSection, c_szPktType,
                                    &infctx);
        if (SUCCEEDED(hr))
        {
            dwCnt = ::SetupGetFieldCount(&infctx);

            // For each adapter in the list read the adapter information
            for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
            {
                hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
                if (FAILED(hr))
                {
                    TraceError("CNwlnkIPX::HrProcessAnswerFile - Failed to read adapter section name",hr);
                    goto Error;
                }

                Assert(!str.empty());

                // Raid # 205831 - Trim any leading "0x"
                //
                if (0 == _wcsnicmp(str.c_str(), c_sz0xPrefix, wcslen(c_sz0xPrefix)))
                {
                    str.erase(0, wcslen(c_sz0xPrefix));
                }

                pAI->PFrmTypeList()->push_back(new tstring(str));
            }
        }

        // Default PktType?
        if (0 == pAI->PFrmTypeList()->size())
        {
            WCHAR szBuf[10];

            // If the info was not found or contained no elements, add the
            // default value.
            wsprintfW(szBuf,L"%X",c_dwPktTypeDefault);
            pAI->PFrmTypeList()->push_back(new tstring(szBuf));
        }

        // Read the NetworkNumber
        hr = ::HrSetupFindFirstLine(pcsif->Hinf(), pszSection, c_szNetworkNumber,
                                    &infctx);
        if (SUCCEEDED(hr))
        {
            dwCnt = SetupGetFieldCount(&infctx);

            // For each adapter in the list read the adapter information
            for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
            {
                hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
                if (FAILED(hr))
                {
                    TraceError("CNwlnkIPX::HrProcessAnswerFile - Failed to read adapter section name",hr);
                    goto Error;
                }

                Assert(!str.empty());
                pAI->PNetworkNumList()->push_back(new tstring(str));
            }
        }

        // Default Network Number?
        if (0 == pAI->PNetworkNumList()->size())
        {
            // If the info was not found or contained no elements, add the
            // default value.
            pAI->PNetworkNumList()->push_back(new tstring(c_sz8Zeros));
        }

        // Ensure that the network number list has the same number of
        // elements as the frame type list.  This can happen when the user
        // configures multiple frame types on 3.51 but only one network
        // number is used.  We'll extend the last network number used
        // and pad it to make the network number list the same size.
        //
        Assert (pAI->PNetworkNumList()->size());

        while (pAI->PNetworkNumList()->size() < pAI->PFrmTypeList()->size())
        {
            pAI->PNetworkNumList()->push_back(
                    new tstring(*pAI->PNetworkNumList()->back()));
        }

        pAI->SetDirty(TRUE);
        m_pIpxEnviroment->AdapterInfoList().push_back(pAI);
        MarkAdapterListChanged();
    }
#ifdef ENABLETRACE
    else
    {
        TraceTag(ttidDefault, "CNwlnkIPX::HrReadAdapterAnswerFileSection - "
            "Adapter \"%S\" not yet installed.",str.c_str());
    }
#endif

    // Normalize return
    hr = S_OK;

Done:
    ReleaseObj(pncc);
    return hr;

Error:
    delete pAI;
    TraceError("CNwlnkIpx::HrReadAdapterAnswerFileSection",hr);
    goto Done;
}

STDMETHODIMP CNwlnkIPX::Install (DWORD)
{
    HRESULT hr;
    CIpxAdapterInfo * pAI;
    ADAPTER_INFO_LIST::iterator iter;

    m_eInstallAction = eActInstall;

    // Mark all the initially detected adapters as dirty
    for (iter = m_pIpxEnviroment->AdapterInfoList().begin();
         iter != m_pIpxEnviroment->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;
        pAI->SetDirty(TRUE);
    }

    // Install NwlnkNb.
    hr = ::HrInstallComponentOboComponent (m_pNetCfg, NULL,
                                           GUID_DEVCLASS_NETTRANS,
                                           c_szInfId_MS_NWNB,
                                           m_pnccMe,
                                           NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Install NwlnkSpx.
    hr = ::HrInstallComponentOboComponent (m_pNetCfg, NULL,
                                           GUID_DEVCLASS_NETTRANS,
                                           c_szInfId_MS_NWSPX,
                                           m_pnccMe,
                                           NULL);

Error:
    TraceError("CNwlnkIPX::Install",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::Removing ()
{
    HRESULT hr;

    m_eInstallAction = eActRemove;

    // Remove NwlnkNb.
    hr = ::HrRemoveComponentOboComponent(m_pNetCfg, GUID_DEVCLASS_NETTRANS,
                                         c_szInfId_MS_NWNB, m_pnccMe);
    if (FAILED(hr))
        goto Error;

    // Remove NwlnkSpx.
    hr = ::HrRemoveComponentOboComponent(m_pNetCfg, GUID_DEVCLASS_NETTRANS,
                                         c_szInfId_MS_NWSPX, m_pnccMe);

Error:
    TraceError("CNwlnkIPX::Removing",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::Validate ( )
{
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::ApplyRegistryChanges ()
{
    HRESULT hr = E_INVALIDARG;

    switch(m_eInstallAction)
    {
    case eActInstall:
        hr = HrCommitInstall();
        break;

    case eActRemove:
        hr = HrCommitRemove();
        break;

    default:    // eActUnknown (Configuration)
        if (m_fAdapterListChanged || m_fPropertyChanged)
        {
            // Update the registry if the adapter list changed
            Assert(m_pIpxEnviroment);
            hr = m_pIpxEnviroment->HrUpdateRegistry();
            if (SUCCEEDED(hr))
            {
                // Send change notification
                hr = HrReconfigIpx();
            }
        }
        break;
    }

    TraceError("CNwlnkIPX::ApplyRegistryChanges",hr);
    return hr;
}


// INetCfgComponentPropertyUi
STDMETHODIMP CNwlnkIPX::SetContext(IUnknown * pUnk)
{
    ReleaseObj(m_pUnkPropContext);
    m_pUnkPropContext = pUnk;
    if (m_pUnkPropContext)
    {
        AddRefObj(m_pUnkPropContext);
    }

    return S_OK;
}


STDMETHODIMP CNwlnkIPX::MergePropPages (
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    HRESULT           hr = S_OK;
    HPROPSHEETPAGE *  ahpsp = NULL;
    PRODUCT_FLAVOR    pf;
    int               nPages = 0;
    CIpxAdapterInfo * pAI = NULL;

    Assert(pahpspPrivate);
    Assert(*pahpspPrivate == NULL);    // Out param init done via Validate above
    *pcPages = 0;

    // Start with new property pages each time.
    CleanupPropPages();

    // Get the current Adapter
    if (NULL != m_pUnkPropContext)
    {
        CIpxAdapterInfo *   pAITmp;
        INetLanConnectionUiInfo * pLanConn = NULL;
        ADAPTER_INFO_LIST::iterator iter;

        hr = m_pUnkPropContext->QueryInterface(IID_INetLanConnectionUiInfo,
                                               reinterpret_cast<LPVOID *>(&pLanConn));
        if (SUCCEEDED(hr))
        {
            GUID guid;
            hr = pLanConn->GetDeviceGuid(&guid);
            ReleaseObj(pLanConn);
            if (FAILED(hr))
            {
                goto Error;
            }

            // Find the adapter in our adapter list
            for (iter = m_pIpxEnviroment->AdapterInfoList().begin();
                 iter != m_pIpxEnviroment->AdapterInfoList().end();
                 iter++)
            {
                pAITmp = *iter;

                if (guid == *pAITmp->PInstanceGuid())
                {
                    pAI = pAITmp;
                    break;
                }
            }

            Assert(SUCCEEDED(hr));

            // If we have an adapter but it's
            // disabled/hidden/deleted we show no pages
            if ((NULL != pAI) && (pAI->FDeletePending() ||
                                  pAI->FDisabled() || pAI->FHidden()))
            {
                Assert(0 == *pcPages);
                hr = S_FALSE;
                goto cleanup;
            }
        }
        else if (E_NOINTERFACE == hr)
        {
            // RAS doesn't have the notion of a current adapter
            hr = S_OK;
        }
    }
    else
    {
        // m_pUnkPropContext should have been set first
        hr = E_UNEXPECTED;
    }

    if (FAILED(hr))
    {
        goto Error;
    }

    // If the product is not workstation (therefore NTAS)
    GetProductFlavor(NULL, &pf);
    if ((PF_WORKSTATION != pf) && (NULL != pAI))
    {
        // Server
#ifdef INCLUDE_RIP_ROUTING
        nPages = 2;
#else
        nPages = 1;
#endif

        // Allocate a buffer large enough to hold the handle to the IPX config.
        // property page.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE) * nPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;       // Alloc failed to no need to free ahpsp
        }

        // Allocate the CPropSheetPage objects
        m_pspObj1 = new CIpxASConfigDlg(this, m_pIpxEnviroment, pAI);
#ifdef INCLUDE_RIP_ROUTING
        m_pspObj2 = new CIpxASInternalDlg(this, m_pIpxEnviroment, pAI);
#endif

        // Create the actual PROPSHEETPAGE for each object.
        // This needs to be done regardless of whether the classes existed before.
        ahpsp[0] = m_pspObj1->CreatePage(DLG_IPXAS_CONFIG, 0);
#ifdef INCLUDE_RIP_ROUTING
        ahpsp[1] = m_pspObj2->CreatePage(DLG_IPXAS_INTERNAL, 0);
#endif
    }
    else
    {
        // Workstation
        nPages = 1;

        // Allocate a buffer large enough to hold the handle to the IPX config.
        // property page.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE) * nPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;       // Alloc failed to no need to free ahpsp
        }

        // Allocate the CPropSheetPage object
        m_pspObj1 = new CIpxConfigDlg(this, m_pIpxEnviroment, pAI);

        // Create the actual PROPSHEETPAGE for each object.
        // This needs to be done regardless of whether the classes existed before.
        ahpsp[0] = m_pspObj1->CreatePage(DLG_IPX_CONFIG, 0);
    }

    if (NULL != ahpsp[0])
    {
        *pahpspPrivate = (LPBYTE)ahpsp;
        *pcPages = nPages;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

cleanup:
    TraceError("CNwlnkIPX::MergePropPages", hr);
    return hr;

Error:
    CoTaskMemFree(ahpsp);
    goto cleanup;
}

VOID CNwlnkIPX::CleanupPropPages()
{
    delete m_pspObj1;
    m_pspObj1 = NULL;

#ifdef INCLUDE_RIP_ROUTING
    delete m_pspObj2;
    m_pspObj2 = NULL;
#endif
}
STDMETHODIMP CNwlnkIPX::ValidateProperties (HWND)
{
    m_fPropertyChanged = TRUE;
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::CancelProperties ()
{
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::ApplyProperties ()
{
    return S_OK;
}


// INetCfgComponentNotifyBinding

STDMETHODIMP CNwlnkIPX::QueryBindingPath ( DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem )
{
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::NotifyBindingPath ( DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem )
{
    HRESULT hr = S_OK;
    INetCfgComponent *pnccFound = NULL;

    Validate_INetCfgBindNotify_NotifyBindingPath( dwChangeFlag, pncbpItem );

    Assert(NULL != m_pIpxEnviroment);

    // Only Interested in lower binding Add's and Remove's
    if (dwChangeFlag & (NCN_ADD | NCN_REMOVE | NCN_ENABLE | NCN_DISABLE))
    {
        CIterNetCfgBindingInterface ncbiIter(pncbpItem);
        INetCfgBindingInterface *pncbi;

        // Enumerate the binding interfaces looking for an Adapter
        while (SUCCEEDED(hr) &&
               (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            INetCfgComponent *pncc;

            hr = pncbi->GetLowerComponent(&pncc);
            if (S_OK == hr)
            {
                GUID guidClass;
                hr = pncc->GetClassGuid(&guidClass);
                if ((S_OK == hr) && (GUID_DEVCLASS_NET == guidClass))
                {
                    ReleaseObj(pnccFound);
                    pnccFound = pncc;   // Transfer Ownership
                    pncc = NULL;
                }
                else
                {
                    ReleaseObj(pncc);
                }
            }

            ReleaseObj(pncbi);
        }

        if (FAILED(hr))
            goto Error;

        // Did we find the Adapter?
        if (pnccFound)
        {
            BOOL                            fFound = FALSE;
            PWSTR                           pszBindName = NULL;
            CIpxAdapterInfo *               pAI;
            ADAPTER_INFO_LIST::iterator     iterAdapterInfo;

            Assert(m_pIpxEnviroment);

            hr = pnccFound->GetBindName(&pszBindName);
            if (S_OK != hr)
            {
                goto Error;
            }

            // Search the adapter list
            for (iterAdapterInfo  = m_pIpxEnviroment->AdapterInfoList().begin();
                 iterAdapterInfo != m_pIpxEnviroment->AdapterInfoList().end();
                 iterAdapterInfo++)
            {
                pAI = *iterAdapterInfo;
                Assert (pAI);

                if (0 == lstrcmpiW(pszBindName, pAI->SzBindName()))
                {
                    fFound = TRUE;
                    break;
                }
            }

            Assert(pszBindName);
            CoTaskMemFree(pszBindName);

            // Apply the appropriate delta to the adapter list
            if (fFound && (dwChangeFlag & NCN_REMOVE))
            {
                // Mark the adapter as Delete Pending
                pAI->SetDeletePending(TRUE);
                m_fAdapterListChanged = TRUE;
            }
            else if (!fFound && (dwChangeFlag & NCN_ADD))
            {
                // Add the adapter to the list
                hr = m_pIpxEnviroment->HrAddAdapter(pnccFound);
                m_fAdapterListChanged = TRUE;
            }
            else if (fFound && (dwChangeFlag & NCN_ADD))
            {
                // Re-enable the adapters existance
                pAI->SetDeletePending(FALSE);
            }

            if (fFound)
            {
                if (dwChangeFlag & NCN_ENABLE)
                {
                    pAI->SetDisabled(FALSE);
                    m_fAdapterListChanged = TRUE;
                }
                else if (dwChangeFlag & NCN_DISABLE)
                {
                    pAI->SetDisabled(TRUE);
                    m_fAdapterListChanged = TRUE;
                }
            }
        }

        if (SUCCEEDED(hr))
            hr = S_OK;      // Normailze return value
    }

Error:
    ReleaseObj(pnccFound);
    TraceError("CNwlnkIPX::NotifyBindingPath",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::GetFrameTypesForAdapter(PCWSTR pszAdapterBindName,
                                                DWORD   cFrameTypesMax,
                                                DWORD*  anFrameTypes,
                                                DWORD*  pcFrameTypes)
{
    Assert(pszAdapterBindName);
    Assert(cFrameTypesMax);
    Assert(anFrameTypes);
    Assert(pcFrameTypes);

    *pcFrameTypes = 0;

    ADAPTER_INFO_LIST::iterator iterAI;

    for (iterAI = m_pIpxEnviroment->AdapterInfoList().begin();
         iterAI != m_pIpxEnviroment->AdapterInfoList().end();
         iterAI++)
    {
        CIpxAdapterInfo *pAI = *iterAI;
        if (0 == lstrcmpW(pszAdapterBindName, pAI->SzBindName()))
        {
            list<tstring *>::iterator iterFrmType;
            for (iterFrmType = pAI->PFrmTypeList()->begin();
                 (iterFrmType != pAI->PFrmTypeList()->end()) &&
                 (*pcFrameTypes < cFrameTypesMax);
                 iterFrmType++)
            {
                // Copy the Frame Type
                tstring *pstr1 = *iterFrmType;
                anFrameTypes[(*pcFrameTypes)++] = DwFromSz(pstr1->c_str(), 16);
            }
            break;
        }
    }
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::GetVirtualNetworkNumber(DWORD* pdwVNetworkNumber)
{
    HRESULT hr = S_OK;

    if (NULL == pdwVNetworkNumber)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    Assert(NULL != m_pIpxEnviroment);
    *pdwVNetworkNumber = m_pIpxEnviroment->DwVirtualNetworkNumber();

Error:
    TraceError("CNwlnkIPX::GetVirtualNetworkNumber",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::SetVirtualNetworkNumber(DWORD dwVNetworkNumber)
{
    HRESULT hr;
    Assert(NULL != m_pIpxEnviroment);
    m_pIpxEnviroment->SetVirtualNetworkNumber(dwVNetworkNumber);
    m_fPropertyChanged = TRUE;

    // Tell INetCfg that our component is dirty
    INetCfgComponentPrivate* pinccp = NULL;
    Assert(NULL != m_pnccMe);
    hr = m_pnccMe->QueryInterface(IID_INetCfgComponentPrivate,
                                reinterpret_cast<void**>(&pinccp));
    if (SUCCEEDED(hr))
    {
        hr = pinccp->SetDirty();
        pinccp->Release();
    }

    return hr;
}

//
// Function:    CNwlnkIPX::HrCommitInstall
//
// Purpose:     Commit Installation registry changes to the registry
//
// Parameters:  None
//
// Returns:     HRESULT, S_OK on success
//
//
STDMETHODIMP CNwlnkIPX::HrCommitInstall()
{
    HRESULT hr;

    Assert(m_pIpxEnviroment);
    hr = m_pIpxEnviroment->HrUpdateRegistry();

    TraceError("CNwlnkIPX::HrCommitInstall",hr);
    return hr;
}

//
// Function:    CNwlnkIPX::HrCommitRemove
//
// Purpose:     Remove from the registry settings which were created by this
//              component's installation.
//
// Parameters:  None
//
// Returns:     HRESULT, S_OK on success
//
//
STDMETHODIMP CNwlnkIPX::HrCommitRemove()
{
    // Remove "NwlnkIpx" from the:
    //    System\CurrentControlSet\Control\ServiceProvider\Order\ProviderOrder value
    (void) HrRegRemoveStringFromMultiSz(c_szSvcNwlnkIpx, HKEY_LOCAL_MACHINE,
                                        c_szSrvProvOrderKey,
                                        c_szProviderOrderVal,
                                        STRING_FLAG_REMOVE_ALL);

    return S_OK;
}

CIpxAdapterInfo::CIpxAdapterInfo() : m_dwMediaType(ETHERNET_MEDIA),
                                     m_fDeletePending(FALSE),
                                     m_fDisabled(FALSE),
                                     m_fDirty(FALSE),
                                     m_dwCharacteristics(0L)
{
    ZeroMemory(&m_guidInstance, sizeof(m_guidInstance));
}

CIpxAdapterInfo::~CIpxAdapterInfo()
{
    DeleteColString(&m_lstpstrFrmType);
    DeleteColString(&m_lstpstrNetworkNum);
}

CIpxEnviroment::CIpxEnviroment(CNwlnkIPX *pno)
{
    Assert(NULL != pno);
    m_pno = pno;            // Retain the Notification object

    m_fRipInstalled = FALSE;
    m_fEnableRip = FALSE;
    m_dwRipValue = 0;
    ZeroMemory(&m_IpxParams, sizeof(m_IpxParams));
}

CIpxEnviroment::~CIpxEnviroment()
{
    ReleaseAdapterInfo();

    // Note: Do nothing with the m_pno notification object, we just borrowed it
}

//
//  Member:     CIpxEnviroment::ReleaseAdapterInfo
//
//  Purpose:    Release the adapter info
//
//  Arguments:  none
//
//  Returns:    nothing
//
void CIpxEnviroment::ReleaseAdapterInfo()
{
    CIpxAdapterInfo *pAI;

    while (!m_lstpAdapterInfo.empty())
    {
        pAI = m_lstpAdapterInfo.front();
        m_lstpAdapterInfo.pop_front();
        delete pAI;
    }
}

//
//  Member:     CIpxEnviroment::DwCountValidAdapters
//
//  Purpose:    Return the count of adapters not marked as delete pending,
//              disabled, or hidden.
//
//  Arguments:  none
//
//  Returns:    nothing
//
DWORD CIpxEnviroment::DwCountValidAdapters()
{
    DWORD dwCount = 0;
    ADAPTER_INFO_LIST::iterator iterAI;

    for (iterAI = AdapterInfoList().begin();
         iterAI != AdapterInfoList().end();
         iterAI++)
    {
        CIpxAdapterInfo *pAI = *iterAI;

        if (pAI->FDeletePending() || pAI->FDisabled() || pAI->FHidden())
            continue;

        dwCount++;
    }

    return dwCount;
}

HRESULT CIpxEnviroment::HrOpenIpxAdapterSubkey(HKEY *phkey, BOOL fCreateIfMissing)
{
    DWORD   dwDisposition;
    HRESULT hr;
    tstring str;

    // Open the NetCard key
    str = c_szIpxParameters;
    str += L"\\";
    str += c_szAdapters;
    if (fCreateIfMissing)
    {
        hr = ::HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, str.c_str(),
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                phkey, &dwDisposition);
    }
    else
    {
        hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, str.c_str(), KEY_READ, phkey );
    }
    if (S_OK != hr)
        goto Error;

Error:
    TraceError("CIpxEnviroment::HrOpenIpxAdapterSubkey",
                HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr ? S_OK : hr);
    return hr;
}

HRESULT CIpxEnviroment::HrOpenIpxAdapterSubkeyEx(PCWSTR pszKeyName,
                                                 DWORD dwAccess,
                                                 BOOL fCreateIfMissing,
                                                 HKEY *phkey)
{
    HRESULT hr;
    HKEY    hkeyRoot = NULL;

    Assert(pszKeyName);
    Assert(0 < lstrlenW(pszKeyName));

    // Open the NetCard key
    hr = HrOpenIpxAdapterSubkey(&hkeyRoot, fCreateIfMissing);
    if (S_OK != hr)
    {
        goto Error;
    }

    // Open the adapter specific subkey (creating if requested and required)
    if (fCreateIfMissing)
    {
        DWORD dwDisposition;

        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKeyName,
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                phkey, &dwDisposition);
    }
    else
    {
        // Try exact match first, it's faster
        hr = HrRegOpenKeyEx( hkeyRoot, pszKeyName, dwAccess, phkey );
    }

Error:
    RegSafeCloseKey(hkeyRoot);
    TraceError("CIpxEnviroment::HrOpenIpxAdapterSubkeyEx",
                HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr ? S_OK : hr);
    return hr;
}

HRESULT CIpxEnviroment::HrGetIpxParams()
{
    RegReadValues(celems(regbatchIpx), regbatchIpx, (BYTE *)&m_IpxParams,
                  KEY_READ);
    return S_OK;
}

HRESULT CIpxEnviroment::HrGetOneAdapterInfo(INetCfgComponent *pNCC,
                                            CIpxAdapterInfo **ppAI)
{
    HKEY              hkeyCard = NULL;
    HRESULT           hr = S_OK;
    CIpxAdapterInfo * pAI = NULL;

    Assert(NULL != pNCC);

    // Init the return value
    *ppAI = NULL;

    pAI = (CIpxAdapterInfo *)new CIpxAdapterInfo;
    Assert(NULL != pAI);

    if (pAI == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Query the adapter component info
    hr = ::HrQueryAdapterComponentInfo(pNCC, pAI);
    if (FAILED(hr))
        goto Error;

    // Open the IPX subkey specific to this adapter
    hr = HrOpenIpxAdapterSubkeyEx(pAI->SzBindName(), KEY_READ, FALSE,
                                  &hkeyCard);
    if (S_OK == hr)
    {
        // Get the packet types
        //
        hr = HrRegQueryColString(hkeyCard, c_szPktType,
                &pAI->m_lstpstrFrmType);
        if (S_OK != hr)
        {
            goto Error;
        }

        // Get the network numbers
        //
        hr = HrRegQueryColString(hkeyCard, c_szNetworkNumber,
                &pAI->m_lstpstrNetworkNum);
        if (S_OK != hr)
        {
            goto Error;
        }
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // Normalize any ERROR_FILE_NOT_FOUND errors
        hr = S_OK;
    }
    else if (FAILED(hr))
    {
        goto Error;
    }

    // Default PktType?
    if (0 == pAI->PFrmTypeList()->size())
    {
        WCHAR szBuf[10];

        // If the info was not found or contained no elements, add the
        // default value.
        wsprintfW(szBuf,L"%X",c_dwPktTypeDefault);
        pAI->PFrmTypeList()->push_back(new tstring(szBuf));
    }

    // Default Network Number?
    if (0 == pAI->PNetworkNumList()->size())
    {
        // If the info was not found or contained no elements, add the
        // default value.
        pAI->PNetworkNumList()->push_back(new tstring(c_sz8Zeros));
    }

    // Update the return value with the new object
    *ppAI = pAI;

Done:
    ::RegSafeCloseKey(hkeyCard);
    TraceError("CIpxEnviroment::HrGetOneAdapterInfo",hr);
    return hr;

Error:
    delete pAI;
    goto Done;
}

HRESULT CIpxEnviroment::HrGetAdapterInfo()
{
    HRESULT                hr = S_OK;
    CIpxAdapterInfo *      pAI = NULL;
    INetCfgComponent*      pncc = NULL;
    INetCfgComponent*      pnccUse = NULL;

    // Find each netcard, to do so, trace the bindings to their end
    // If the endpoint is a netcard then add it to the list
    CIterNetCfgBindingPath ncbpIter(m_pno->m_pnccMe);
    INetCfgBindingPath*    pncbp;

    while (SUCCEEDED(hr) && (S_OK == (hr = ncbpIter.HrNext (&pncbp))))
    {
        // Iterate the binding interfaces of this path.
        CIterNetCfgBindingInterface ncbiIter(pncbp);
        INetCfgBindingInterface* pncbi;

        while (SUCCEEDED(hr) && (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            // Retrieve the lower component
            hr = pncbi->GetLowerComponent(&pncc);
            if (S_OK == hr)
            {
                GUID guidClass;

                // Is it an Adapter?
                hr = pncc->GetClassGuid(&guidClass);
                if ((S_OK == hr) && (guidClass == GUID_DEVCLASS_NET))
                {
                    ReleaseObj(pnccUse);
                    pnccUse = pncc;
                    pncc = NULL;
                }
                else
                {
                    // Release the lower component
                    ReleaseObj(pncc);
                }
            }

            // Release the binding interface
            ReleaseObj (pncbi);
        }

        if (NULL != pnccUse)
        {
            // Query the Adapter information
            hr = HrGetOneAdapterInfo(pnccUse, &pAI);
            if (SUCCEEDED(hr))
            {
                if (S_FALSE == pncbp->IsEnabled())
                    pAI->SetDisabled(TRUE);

                // Add this Adapter to the list
                m_lstpAdapterInfo.push_back(pAI);
            }

            ReleaseObj(pnccUse);
            pnccUse = NULL;
        }

        // Release the binding path
        ReleaseObj (pncbp);
    }

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("CIpxEnviroment::HrGetNetCardInfo",hr);
    return hr;
}

HRESULT CIpxEnviroment::HrWriteOneAdapterInfo(HKEY hkeyAdapters,
                                              CIpxAdapterInfo* pAI)
{
    DWORD           dwDisposition;
    HRESULT         hr;
    HKEY            hkeyCard = NULL;
    PWSTR           psz = NULL;

    // Open the IPX subkey for this specific adapter
    hr = ::HrRegCreateKeyEx(hkeyAdapters, pAI->SzBindName(), REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL, &hkeyCard, &dwDisposition);
    if (S_OK != hr)
        goto Error;

    // Write the packet info
    // Generate the data to write
    AssertSz(pAI->m_lstpstrFrmType.size(),"Did not expect an empty list, default value missing");
    ColStringToMultiSz(pAI->m_lstpstrFrmType, &psz);
    if (psz)
    {
        hr = ::HrRegSetMultiSz(hkeyCard, c_szPktType, psz);
        if (S_OK != hr)
            goto Error;

        delete [] psz;
        psz = NULL;
    }
#ifdef DBG
    else
    {
        AssertSz(0,"PacketType value is NULL?");
    }
#endif

    // Write the network number
    AssertSz(pAI->m_lstpstrNetworkNum.size(),"Did not expect an empty list, default value missing");
    ColStringToMultiSz(pAI->m_lstpstrNetworkNum, &psz);
    if (psz)
    {
        hr = ::HrRegSetMultiSz(hkeyCard, c_szNetworkNumber, psz);
        if (S_OK != hr)
            goto Error;

        delete [] psz;
        psz = NULL;
    }
#ifdef DBG
    else
    {
        AssertSz(0,"NetworkNumber value is NULL?");
    }
#endif

    // If the key for this adapter didn't exist previously
    // write the base set of values
    if (REG_CREATED_NEW_KEY == dwDisposition)
    {
        struct
        {
            PCWSTR pszProp;
            DWORD  dwValue;
        } rgAdapterSettings[] = {{c_szBindSap,c_dwBindSap},
                                 {c_szEnableFuncaddr,c_dwEnableFuncaddr},
                                 {c_szMaxPktSize,c_dwMaxPktSize},
                                 {c_szSourceRouteBCast,c_dwSourceRouteBCast},
                                 {c_szSourceRouteMCast,c_dwSourceRouteMCast},
                                 {c_szSourceRouteDef,c_dwSourceRouteDef},
                                 {c_szSourceRouting,c_dwSourceRouting}};

        for (int nIdx=0; nIdx<celems(rgAdapterSettings); nIdx++)
        {
            hr = ::HrRegSetDword(hkeyCard, rgAdapterSettings[nIdx].pszProp,
                                 rgAdapterSettings[nIdx].dwValue);
            if (FAILED(hr))
            {
                goto Error;
            }
        }
    }

Error:
    delete [] psz;
    ::RegSafeCloseKey(hkeyCard);
    TraceError("CIpxEnviroment::HrWriteOneAdapterInfo",hr);
    return hr;
}

HRESULT CIpxEnviroment::HrWriteAdapterInfo()
{
    HRESULT                         hr = S_OK;
    HKEY                            hkeyAdapters = NULL;
    ADAPTER_INFO_LIST::iterator     iterAdapterInfo;
    CIpxAdapterInfo *               pAI;

    // Create the IPX Adapter Subkey
    hr = HrOpenIpxAdapterSubkey(&hkeyAdapters, TRUE);
    if (S_OK != hr)
        goto Error;

    // Now commit the contents of the adapter list to the registry
    for (iterAdapterInfo = m_lstpAdapterInfo.begin();
         iterAdapterInfo != m_lstpAdapterInfo.end();
         iterAdapterInfo++)
    {
        pAI = *iterAdapterInfo;

        // Write out all adapter's not marked with delete pending
        if (pAI->FDeletePending())
        {
            // Remove the NwlnkIpx\Adapter\{bindname} tree
            (VOID)::HrRegDeleteKeyTree(hkeyAdapters, pAI->SzBindName());
        }
        else if (pAI->IsDirty())
        {
            hr = HrWriteOneAdapterInfo(hkeyAdapters, pAI);
            if (S_OK != hr)
                goto Error;
        }
    }

Error:
    ::RegSafeCloseKey(hkeyAdapters);
    TraceError("CIpxEnviroment::HrWriteAdapterInfo",hr);
    return hr;
}

HRESULT CIpxEnviroment::HrCreate(CNwlnkIPX *pno, CIpxEnviroment ** ppIpxEnviroment)
{
    HRESULT          hr;
    CIpxEnviroment * pIpxEnviroment = (CIpxEnviroment *)new CIpxEnviroment(pno);

    if (pIpxEnviroment == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *ppIpxEnviroment = NULL;

    // Get the Ipx Parameter Key info
    hr = pIpxEnviroment->HrGetIpxParams();
    if (FAILED(hr))
        goto Error;

    // Collect the Adapter Info for all cards installed
    hr = pIpxEnviroment->HrGetAdapterInfo();
    if (FAILED(hr))
        goto Error;

    *ppIpxEnviroment = pIpxEnviroment;

Complete:
    TraceError("CIpxEnviroment::HrCreate",hr);
    return hr;

Error:
    delete pIpxEnviroment;
    goto Complete;
}

HRESULT CIpxEnviroment::HrUpdateRegistry()
{
    HRESULT hr;

    // Commit the registry changes
    hr = ::HrRegWriteValues(celems(regbatchIpx), regbatchIpx,
                            (BYTE *)&m_IpxParams, REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS);
    if (S_OK != hr)
        goto Error;

    // Write adapter info to registry
    hr = HrWriteAdapterInfo();

Error:
    TraceError("CIpxEnviroment::HrUpdateRegistry",hr);
    return hr;
}

VOID CIpxEnviroment::RemoveAdapter(CIpxAdapterInfo * pAI)
{
    Assert(NULL != pAI);
    m_lstpAdapterInfo.remove(pAI);
    delete pAI;
}

HRESULT CIpxEnviroment::HrAddAdapter(INetCfgComponent * pncc)
{
    HRESULT hr = S_OK;
    CIpxAdapterInfo * pAI = NULL;

    hr = HrGetOneAdapterInfo(pncc, &pAI);
    if (FAILED(hr))
        goto Error;

    if (SUCCEEDED(hr))
        hr = S_OK;      // Normalize return

    // Add the Adapter to the list
    pAI->SetDirty(TRUE);
    m_lstpAdapterInfo.push_back(pAI);

Error:
    TraceError("CIpxEnviroment::HrAddAdapter",hr);
    return hr;
}

//$ REVIEW - Start - This is moving to windows\inc\ipxpnp.h
#define IPX_RECONFIG_VERSION        0x1

#define RECONFIG_AUTO_DETECT        1
#define RECONFIG_MANUAL             2
#define RECONFIG_PREFERENCE_1       3
#define RECONFIG_NETWORK_NUMBER_1   4
#define RECONFIG_PREFERENCE_2       5
#define RECONFIG_NETWORK_NUMBER_2   6
#define RECONFIG_PREFERENCE_3       7
#define RECONFIG_NETWORK_NUMBER_3   8
#define RECONFIG_PREFERENCE_4       9
#define RECONFIG_NETWORK_NUMBER_4   10

#define RECONFIG_PARAMETERS         10

//
// Main configuration structure.
//

struct RECONFIG
{
   ULONG    ulVersion;
   BOOLEAN  InternalNetworkNumber;
   BOOLEAN  AdapterParameters[RECONFIG_PARAMETERS];
};

//$ REVIEW - End - This is moving to windows\inc\ipxpnp.h

//+---------------------------------------------------------------------------
//
//  Member:     CNwlnkIPX::HrReconfigIpx
//
//  Purpose:    Notify Ipx of configuration changes
//
//  Arguments:  none
//
//  Returns:    HRESULT, S_OK on success, NETCFG_S_REBOOT on failure
//
HRESULT CNwlnkIPX::HrReconfigIpx()
{
    HRESULT           hrRet;
    HRESULT           hr = S_OK;
    INT               nIdx;
    RECONFIG          Config;
    CIpxAdapterInfo * pAI;
    PRODUCT_FLAVOR    pf;
    ADAPTER_INFO_LIST::iterator iter;
    ULONG             ulConfigSize;

    if (0 == m_pIpxEnviroment->DwCountValidAdapters())
    {
        return S_OK;     // Nothing to configure
    }

    ZeroMemory(&Config, sizeof(Config));
    Config.ulVersion = IPX_RECONFIG_VERSION;

    // Workstation or server?
    GetProductFlavor(NULL, &pf);
    if (PF_WORKSTATION != pf)
    {
        Config.InternalNetworkNumber = TRUE;
        // Now submit the global reconfig notification
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szSvcNwlnkIpx, c_szEmpty,
                                      &Config, sizeof(RECONFIG));
        if (FAILED(hrRet) &&
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    Config.InternalNetworkNumber = FALSE;

    // For each adapter...
    for (nIdx=0, iter = m_pIpxEnviroment->AdapterInfoList().begin();
         iter != m_pIpxEnviroment->AdapterInfoList().end();
         nIdx++, iter++)
    {
        pAI = *iter;

        if (pAI->FDeletePending() || pAI->FDisabled() || !pAI->IsDirty())
            continue;

        ZeroMemory(&Config.AdapterParameters, sizeof(Config.AdapterParameters));

        if (AUTO == pAI->DwFrameType())
            Config.AdapterParameters[RECONFIG_AUTO_DETECT] = TRUE;
        else
            Config.AdapterParameters[RECONFIG_MANUAL] = TRUE;

        // We are performing a shortcut here by setting a range to TRUE
        // based on the number of frames in use.  For example if there is
        // only one frame in use we need to set both:
        // RECONFIG_PREFERENCE_1 and RECONFIG_NETWORK_NUMBER_1 to TRUE
        Assert(RECONFIG_PREFERENCE_1 + 1 == RECONFIG_NETWORK_NUMBER_1);
        Assert(RECONFIG_NETWORK_NUMBER_1 + 1 == RECONFIG_PREFERENCE_2);
        Assert(RECONFIG_PREFERENCE_2 + 1 == RECONFIG_NETWORK_NUMBER_2);
        Assert(RECONFIG_NETWORK_NUMBER_2 + 1 == RECONFIG_PREFERENCE_3);
        Assert(RECONFIG_PREFERENCE_3 + 1 == RECONFIG_NETWORK_NUMBER_3);
        Assert(RECONFIG_NETWORK_NUMBER_3 + 1 == RECONFIG_PREFERENCE_4);
        Assert(RECONFIG_PREFERENCE_4 + 1 == RECONFIG_NETWORK_NUMBER_4);

        INT nCntFrms = pAI->PFrmTypeList()->size();
        if ((0 < nCntFrms) && (4 >= nCntFrms))
        {
            memset(&Config.AdapterParameters[RECONFIG_PREFERENCE_1],
                   TRUE, sizeof(BOOLEAN) * nCntFrms * 2);
        }

        Assert(lstrlenW(pAI->SzBindName()));

        // Now submit the reconfig notification
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szSvcNwlnkIpx, pAI->SzBindName(),
                                      &Config, sizeof(RECONFIG));
        if (FAILED(hrRet) &&
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    TraceError("CNwlnkIPX::HrReconfigIpx",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\nwlnkutl.h ===
#pragma once


BOOL FIsNetwareIpxInstalled(
    VOID);

DWORD DwFromSz(PCWSTR sz, int nBase);

DWORD DwFromLstPtstring(const list<tstring *> & lstpstr, DWORD dwDefault,
                        int nBase);

void UpdateLstPtstring(list<tstring *> & lstpstr, DWORD dw);

void HexSzFromDw(PWSTR sz, DWORD dw);

class CIpxAdapterInfo;

HRESULT HrQueryAdapterComponentInfo(INetCfgComponent *pncc,
                                    CIpxAdapterInfo * pAI);

// Note this prototype is used privately also by atlkcfg in atlkobj.cpp
// update there if this api changes
HRESULT HrAnswerFileAdapterToPNCC(INetCfg *pnc, PCWSTR szAdapterId,
                                  INetCfgComponent** ppncc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\nwlnknb.h ===
#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"


class ATL_NO_VTABLE CNwlnkNB :
    public CComObjectRoot,
    public CComCoClass<CNwlnkNB, &CLSID_CNwlnkNB>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal
{
public:
    CNwlnkNB();
    ~CNwlnkNB();

    BEGIN_COM_MAP(CNwlnkNB)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNwlnkNB)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NWLNKNB)

    // Enable/Disable Action
    enum NBSTATE      {eStateNoChange, eStateDisable, eStateEnable};

    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};


// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

private:
    VOID UpdateNwlnkNbStartType(VOID);
    VOID UpdateBrowserDirectHostBinding(VOID);

private:
    INetCfgComponent* m_pnccMe;
    INetCfg*          m_pNetCfg;
    INSTALLACTION     m_eInstallAction;
    NBSTATE           m_eNbState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\nwlnkutl.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "ncreg.h"
#include "nwlnkipx.h"


#define ChLowX     L'x'
#define ChUpX      L'X'


//
// Function:    FIsNetwareIpxInstalled
//
// Purpose:     Check for the existance of the IPXSPSII key in the
//              HKLM\SYSTEM\...\Services hive
//

BOOL FIsNetwareIpxInstalled(
    VOID)
{
    HRESULT hr;
    HKEY hkey;
    BOOL fRet;

    fRet = FALSE;

    hr = HrRegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\IPXSPXII",
            KEY_READ,
            &hkey);
    if (S_OK == hr)
    {
        fRet = TRUE;
        RegCloseKey(hkey);
    }

    return fRet;
}

DWORD DwFromSz(PCWSTR sz, int nBase)
{
    PCWSTR psz = sz;
    WCHAR *pszStop;
    WCHAR szBuf[12];

    Assert(NULL != psz);

    if ((16 == nBase) && (ChLowX != sz[1]) && (ChUpX != sz[1]))
    {
        psz = szBuf;
        wcscpy(szBuf,L"0x");
        wcsncpy(szBuf+2, sz, 8);
        szBuf[10]=L'\0';
    }

    return wcstoul(psz, &pszStop, nBase);
}

DWORD DwFromLstPtstring(const list<tstring *> & lstpstr, DWORD dwDefault,
                        int nBase)
{
    if (lstpstr.empty())
        return dwDefault;
    else
        return DwFromSz(lstpstr.front()->c_str(), nBase);
}

void UpdateLstPtstring(TSTRING_LIST & lstpstr, DWORD dw)
{
    WCHAR szBuf[12];

    DeleteColString(&lstpstr);

    // Stringize the supplied dword as a hex with no "0x" prefix
    wsprintfW(szBuf,L"%0.8lX",dw);

    // Set as first item in the list
    lstpstr.push_front(new tstring(szBuf));
}

// Apply our special Hex Format to a DWORD.  Assumes adequately sized 'sz'
void HexSzFromDw(PWSTR sz, DWORD dw)
{
    wsprintfW(sz,L"%0.8lX",dw);
}

HRESULT HrQueryAdapterComponentInfo(INetCfgComponent *pncc,
                                    CIpxAdapterInfo * pAI)
{
    HRESULT           hr;
    PWSTR            pszwDesc = NULL;
    PWSTR            pszwBindName = NULL;
    DWORD             dwCharacteristics = 0L;

    Assert(NULL != pAI);
    Assert(NULL != pncc);

    // Get Description
    hr = pncc->GetDisplayName(&pszwDesc);
    if (FAILED(hr))
        goto Error;

    if (*pszwDesc)
        pAI->SetAdapterDesc(pszwDesc);
    else
        pAI->SetAdapterDesc(SzLoadIds(IDS_UNKNOWN_NETWORK_CARD));

    CoTaskMemFree(pszwDesc);

    // Get the Component's Instance Guid
    hr = pncc->GetInstanceGuid(pAI->PInstanceGuid());
    if (S_OK != hr)
        goto Error;

    // Get the Component's Bind Name
    hr = pncc->GetBindName(&pszwBindName);
    if (S_OK != hr)
        goto Error;

    Assert(NULL != pszwBindName);
    Assert(0 != lstrlenW(pszwBindName));
    pAI->SetBindName(pszwBindName);
    CoTaskMemFree(pszwBindName);

    // Failure is non-fatal
    hr = pncc->GetCharacteristics(&dwCharacteristics);
    if (SUCCEEDED(hr))
    {
        pAI->SetCharacteristics(dwCharacteristics);
    }

    // Get the media type (Optional key)
    {
        DWORD dwMediaType = ETHERNET_MEDIA;
        INetCfgComponentBindings* pnccBindings = NULL;

        hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                  reinterpret_cast<void**>(&pnccBindings));
        if (SUCCEEDED(hr))
        {
            struct
            {
                PCWSTR pszInterface;
                DWORD   dwInterface;
            } InterfaceMap[] = {{L"ethernet", ETHERNET_MEDIA},
                                {L"tokenring", TOKEN_MEDIA},
                                {L"arcnet", ARCNET_MEDIA},
                                {L"fddi", FDDI_MEDIA}};

            for (UINT nIdx=0; nIdx < celems(InterfaceMap); nIdx++)
            {
                hr = pnccBindings->SupportsBindingInterface(NCF_LOWER,
                                        InterfaceMap[nIdx].pszInterface);
                if (S_OK == hr)
                {
                    dwMediaType = InterfaceMap[nIdx].dwInterface;
                    break;
                }
            }

            ReleaseObj(pnccBindings);
        }

        pAI->SetMediaType(dwMediaType);
        hr = S_OK;
    }

Error:
    TraceError("HrQueryAdapterComponentInfo",hr);
    return hr;
}

// Note: Can successfully return *ppncc = NULL
HRESULT HrAnswerFileAdapterToPNCC(INetCfg *pnc, PCWSTR szAdapterId,
                                  INetCfgComponent** ppncc)
{
    GUID    guidAdapter;
    GUID    guidInstance;
    HRESULT hr = S_FALSE;   // assume we don't find it.

    Assert(NULL != szAdapterId);
    Assert(NULL != ppncc);
    Assert(lstrlenW(szAdapterId));

    *ppncc = NULL;

    // Get the Instance ID for the specified adapter
    if (FGetInstanceGuidOfComponentInAnswerFile(szAdapterId,
                                                pnc, &guidAdapter))
    {
        // Search for the specified adapter in the set of existing adapters
        CIterNetCfgComponent nccIter(pnc, &GUID_DEVCLASS_NET);
        INetCfgComponent* pncc;
        while (SUCCEEDED(hr) &&
               (S_OK == (hr = nccIter.HrNext (&pncc))))
        {
            hr = pncc->GetInstanceGuid(&guidInstance);
            if (SUCCEEDED(hr))
            {
                if (guidInstance == guidAdapter)
                {
                    // Found the adapter.  Transfer ownership and get out.
                    *ppncc = pncc;
                    break;
                }
            }
            ReleaseObj(pncc);
        }
    }

    TraceError("HrAnswerFileAdapterToPNCC", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwlnkcfg\resource.h ===
#include <ncres.h>

#define IDS_INFORMATION_MESSAGE         (IDS_NC_NWLNKCFG +  2)  // "Informational Message"
#define IDS_IPXPP_TEXT_1                (IDS_NC_NWLNKCFG +  3)
#define IDS_IPXPP_TEXT_2                (IDS_NC_NWLNKCFG +  4)
#define IDS_VIRTUAL_WARNING             (IDS_NC_NWLNKCFG + 11)
#define IDS_AUTO                        (IDS_NC_NWLNKCFG + 12)
#define IDS_ETHERNET                    (IDS_NC_NWLNKCFG + 13)
#define IDS_802_2                       (IDS_NC_NWLNKCFG + 14)
#define IDS_802_3                       (IDS_NC_NWLNKCFG + 15)
#define IDS_SNAP                        (IDS_NC_NWLNKCFG + 16)
#define IDS_ARCNET                      (IDS_NC_NWLNKCFG + 17)
#define IDS_802_5                       (IDS_NC_NWLNKCFG + 18)
#define IDS_TK                          (IDS_NC_NWLNKCFG + 19)
#define IDS_MANUAL_FRAME_DETECT         (IDS_NC_NWLNKCFG + 20)
#define IDS_INCORRECT_NETNUM            (IDS_NC_NWLNKCFG + 22)
#define IDS_FDDI                        (IDS_NC_NWLNKCFG + 23)
#define IDS_FDDI_SNAP                   (IDS_NC_NWLNKCFG + 24)
#define IDS_FDDI_802_3                  (IDS_NC_NWLNKCFG + 25)
#define IDS_IPXAS_FRAME_TYPE            (IDS_NC_NWLNKCFG + 26)
#define IDS_IPXAS_NETWORK_NUM           (IDS_NC_NWLNKCFG + 27)
#define IDS_GENERAL                     (IDS_NC_NWLNKCFG + 28)
#define IDS_NETNUM_INUSE                (IDS_NC_NWLNKCFG + 29)
#define IDS_INSTALL_RIP                 (IDS_NC_NWLNKCFG + 30)
#define IDS_ROUTING                     (IDS_NC_NWLNKCFG + 31)
#define IDS_NETBIOS_BROADCAST           (IDS_NC_NWLNKCFG + 32)

#define DLG_IPX_CONFIG                  17000
#define DLG_IPXAS_CONFIG                17001
#define DLG_IPXAS_INTERNAL              17002
#define DLG_IPXAS_FRAME_ADD             17003
#define DLG_IPXAS_FRAME_EDIT            17004


// IPX Workstation Property Page - Control IDs
#define IDC_IPXPP_TEXT                  200
#define CMB_IPXPP_FRAMETYPE             201
#define EDT_IPXPP_NETWORKNUMBER         202
#define IDC_STATIC_NETNUM               203
#define IDC_STATIC_FRAMETYPE            204
#define GB_IPXPP_ADAPTER                205
#define IDC_IPXPP_ADAPTER_TEXT          206

// IPX Server Property Pages - Control IDs
#define EDT_IPXAS_INTERNAL              207
#define IDC_IPXAS_GROUP                 208
#define BTN_IPXAS_AUTO                  209
#define BTN_IPXAS_MANUAL                210
#define LVC_IPXAS_DEST                  211
#define BTN_IPXAS_ADD                   212
#define BTN_IPXAS_EDIT                  213
#define BTN_IPXAS_REMOVE                214
#define BTN_IPXAS_RIP                   215
#define CMB_IPXAS_DEST                  216
#define EDT_IPXAS_NETNUM                217
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\bindobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       B I N D O B J . C P P
//
//  Contents:   Implementation of base class for RAS binding objects.
//
//  Notes:
//
//  Author:     shaunco   11 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "bindobj.h"
#include "ncmisc.h"
#include "ncsvc.h"

extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szBiNdisCoWan[];
extern const WCHAR c_szBiNdisWan[];
extern const WCHAR c_szBiNdisWanAsync[];

extern const WCHAR c_szInfId_MS_AppleTalk[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_NdisWan[];
extern const WCHAR c_szInfId_MS_NetBEUI[];
extern const WCHAR c_szInfId_MS_NetMon[];
extern const WCHAR c_szInfId_MS_RasCli[];
extern const WCHAR c_szInfId_MS_RasSrv[];
extern const WCHAR c_szInfId_MS_TCPIP[];


//----------------------------------------------------------------------------
// Data used for finding the other components we have to deal with.
//
const GUID* CRasBindObject::c_apguidComponentClasses [c_cOtherComponents] =
{
    &GUID_DEVCLASS_NETSERVICE,      // RasCli
    &GUID_DEVCLASS_NETSERVICE,      // RasSrv
    &GUID_DEVCLASS_NETTRANS,        // Ip
    &GUID_DEVCLASS_NETTRANS,        // Ipx
    &GUID_DEVCLASS_NETTRANS,        // Nbf
    &GUID_DEVCLASS_NETTRANS,        // Atalk
    &GUID_DEVCLASS_NETTRANS,        // NetMon
    &GUID_DEVCLASS_NETTRANS,        // NdisWan
    &GUID_DEVCLASS_NET,             // IpAdapter
};

const PCWSTR CRasBindObject::c_apszComponentIds [c_cOtherComponents] =
{
    c_szInfId_MS_RasCli,
    c_szInfId_MS_RasSrv,
    c_szInfId_MS_TCPIP,
    c_szInfId_MS_NWIPX,
    c_szInfId_MS_NetBEUI,
    c_szInfId_MS_AppleTalk,
    c_szInfId_MS_NetMon,
    c_szInfId_MS_NdisWan,
    c_szInfId_MS_NdisWanIp,
};

CRasBindObject::CRasBindObject ()
{
    m_ulOtherComponents = 0;
    m_pnc               = NULL;
}

HRESULT
CRasBindObject::HrCountInstalledMiniports (
    UINT* pcIpOut,
    UINT* pcNbfIn,
    UINT* pcNbfOut)
{
    Assert (pcIpOut);
    Assert (pcNbfIn);
    Assert (pcNbfOut);

    // Initialize output parameters.
    //
    *pcIpOut = *pcNbfIn = *pcNbfOut = 0;

    if (PnccIp() && PnccIpAdapter())
    {
        INetCfgComponentUpperEdge* pUpperEdge;
        HRESULT hr = HrQueryNotifyObject (
                        PnccIp(),
                        IID_INetCfgComponentUpperEdge,
                        reinterpret_cast<VOID**>(&pUpperEdge));

        if (SUCCEEDED(hr))
        {
            DWORD dwNumInterfaces;
            GUID* pguidInterfaceIds;

            hr = pUpperEdge->GetInterfaceIdsForAdapter (
                    PnccIpAdapter(),
                    &dwNumInterfaces,
                    &pguidInterfaceIds);
            if (SUCCEEDED(hr))
            {
                *pcIpOut = dwNumInterfaces;

                CoTaskMemFree (pguidInterfaceIds);
            }

            ReleaseObj (pUpperEdge);
        }
    }

    // Iterate adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter(m_pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent* pnccAdapter;
    while(S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        // Quickly discard non-hidden adapters to avoid unneccesary string
        // compares.
        //
        DWORD dwCharacter;
        if (   SUCCEEDED(pnccAdapter->GetCharacteristics (&dwCharacter))
            && (dwCharacter & NCF_HIDDEN))
        {
            PWSTR pszId;
            if (SUCCEEDED(pnccAdapter->GetId (&pszId)))
            {
                if (FEqualComponentId (c_szInfId_MS_NdisWanNbfIn, pszId))
                {
                    (*pcNbfIn)++;
                }
                else if (FEqualComponentId (c_szInfId_MS_NdisWanNbfOut, pszId))
                {
                    (*pcNbfOut)++;
                }

                CoTaskMemFree (pszId);
            }
        }
        ReleaseObj (pnccAdapter);
    }

    TraceTag (ttidRasCfg,
              "Current ndiswan miniports: "
              "%u IP dial-out, %u NBF dial-in, %u NBF dial-out",
              *pcIpOut, *pcNbfIn, *pcNbfOut);

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }
    TraceError ("CRasBindObject::HrCountInstalledMiniports", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::HrFindOtherComponents
//
//  Purpose:    Find the components listed in our OTHER_COMPONENTS enum.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:      We ref-count this action.  If called again (before
//              ReleaseOtherComponents) we increment a refcount.
//
//
HRESULT
CRasBindObject::HrFindOtherComponents ()
{
    AssertSz (c_cOtherComponents == celems(c_apguidComponentClasses),
              "Uhh...you broke something.");
    AssertSz (c_cOtherComponents == celems(c_apszComponentIds),
              "Uhh...you broke something.");
    AssertSz (c_cOtherComponents == celems(m_apnccOther),
              "Uhh...you broke something.");

    HRESULT hr = S_OK;

    if (!m_ulOtherComponents)
    {
        hr = HrFindComponents (
                m_pnc, c_cOtherComponents,
                c_apguidComponentClasses,
                c_apszComponentIds,
                m_apnccOther);
    }
    if (SUCCEEDED(hr))
    {
        m_ulOtherComponents++;
    }
    TraceError ("CRasBindObject::HrFindOtherComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::ReleaseOtherComponents
//
//  Purpose:    Releases the components found by a previous call to
//              HrFindOtherComponents.  (But only if the refcount is zero.)
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
NOTHROW
void
CRasBindObject::ReleaseOtherComponents ()
{
    AssertSz (m_ulOtherComponents,
              "You have not called HrFindOtherComponents yet or you have "
              "called ReleaseOtherComponents too many times.");

    if (0 == --m_ulOtherComponents)
    {
        ReleaseIUnknownArray (c_cOtherComponents, (IUnknown**)m_apnccOther);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::FIsRasBindingInterface
//
//  Purpose:    Return TRUE if an INetCfgBindingInterface represents
//              a RAS binding interface.  If it is, return the corresponding
//              RAS_BINDING_ID.
//
//  Arguments:
//      pncbi      [in]     INetCfgBindingInterface to check.
//      pRasBindId [out]    Returned RAS_BINDING_ID if the method returns
//                          TRUE.
//
//  Returns:    TRUE if the INetCfgBindingInterface represents a RAS binding
//              interface.  FALSE if not.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
BOOL
CRasBindObject::FIsRasBindingInterface (
    INetCfgBindingInterface*    pncbi,
    RAS_BINDING_ID*             pRasBindId)
{
    Assert (pRasBindId);

    // Initialize the output parameter.
    *pRasBindId = RBID_INVALID;

    PWSTR pszName;
    if (SUCCEEDED(pncbi->GetName (&pszName)))
    {
        if (0 == lstrcmpW (c_szBiNdisAtm, pszName))
        {
            *pRasBindId = RBID_NDISATM;
        }
        else if (0 == lstrcmpW (c_szBiNdisCoWan, pszName))
        {
            *pRasBindId = RBID_NDISCOWAN;
        }
        else if (0 == lstrcmpW (c_szBiNdisWan, pszName))
        {
            *pRasBindId = RBID_NDISWAN;
        }
        else if (0 == lstrcmpW (c_szBiNdisWanAsync, pszName))
        {
            *pRasBindId = RBID_NDISWANASYNC;
        }

        CoTaskMemFree (pszName);
    }

    return (RBID_INVALID != *pRasBindId);
}

HRESULT
CRasBindObject::HrAddOrRemoveIpOut (
    INT     nInstances)
{
    if ((nInstances > 0) && PnccIp() && PnccIpAdapter())
    {
        INetCfgComponentUpperEdge* pUpperEdge;
        HRESULT hr = HrQueryNotifyObject (
                        PnccIp(),
                        IID_INetCfgComponentUpperEdge,
                        reinterpret_cast<VOID**>(&pUpperEdge));

        if (SUCCEEDED(hr))
        {
            TraceTag (ttidRasCfg,
                "Adding %d TCP/IP interfaces to the ndiswanip adapter",
                nInstances);

            hr = pUpperEdge->AddInterfacesToAdapter (
                    PnccIpAdapter(),
                    nInstances);

            ReleaseObj (pUpperEdge);
        }
    }
    return S_OK;
}

HRESULT
CRasBindObject::HrProcessEndpointChange ()
{
    Assert (m_pnc);

    HRESULT hr = HrFindOtherComponents ();
    if (SUCCEEDED(hr))
    {
        // These will be the number of miniports we add(+) or remove(-) for
        // the in and out directions.  ('d' is hungarian for 'difference'.)
        //
        INT dIpOut, dNbfIn, dNbfOut;
        dIpOut = dNbfIn = dNbfOut = 0;

        UINT cCurIpOut, cCurNbfIn, cCurNbfOut;
        hr = HrCountInstalledMiniports (&cCurIpOut, &cCurNbfIn, &cCurNbfOut);
        if (SUCCEEDED(hr))
        {
            PRODUCT_FLAVOR pf;
            (VOID) GetProductFlavor (NULL, &pf);

            // This is the number of miniports we want to end up with
            // without normalizing the number within the max range.
            //
            INT cDesiredIpOut  = 2;
            INT cDesiredNbfIn  = 0;
            INT cDesiredNbfOut = 1;

            if (PF_SERVER == pf)
            {
                cDesiredNbfIn  = 2;
            }

            dIpOut  = ((PnccIp())  ? cDesiredIpOut  : 0) - cCurIpOut;
            dNbfIn  = ((PnccNbf()) ? cDesiredNbfIn  : 0) - cCurNbfIn;
            dNbfOut = ((PnccNbf()) ? cDesiredNbfOut : 0) - cCurNbfOut;
        }

        if (SUCCEEDED(hr) && dIpOut)
        {
            hr = HrAddOrRemoveIpOut (dIpOut);
        }

        if (SUCCEEDED(hr) && dNbfIn)
        {
            hr = HrAddOrRemoveNbfIn (dNbfIn);
        }

        if (SUCCEEDED(hr) && dNbfOut)
        {
            hr = HrAddOrRemoveNbfOut (dNbfOut);
        }

        // Normalize the HRESULT.  (i.e. don't return S_FALSE)
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }

        ReleaseOtherComponents ();
    }
    TraceError ("CRasBindObject::HrProcessEndpointChange", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\bindobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       B I N D O B J . H
//
//  Contents:   Declaration of base class for RAS binding objects.
//
//  Notes:
//
//  Author:     shaunco   11 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <notifval.h>
#include "resource.h"
#include "rasaf.h"
#include "rasdata.h"
#include "ncutil.h"


enum RAS_BINDING_ID
{
    RBID_INVALID = 0,
    RBID_NDISATM,
    RBID_NDISCOWAN,
    RBID_NDISWAN,
    RBID_NDISWANASYNC,
};

enum RAS_PROTOCOL_IDS
{
    RPI_IP      = 0x00000001,
    RPI_IPX     = 0x00000002,
    RPI_NBF     = 0x00000004,
    RPI_ATALK   = 0x00000008,
    RPI_NETMON  = 0x00000010,
    RPI_ALL     = 0xFFFFFFFF,
};

struct RAS_ENDPOINT_INFO
{
    UINT    cDialIn;
    UINT    cDialOut;
    UINT    cEndpoints;
};


class CRasBindObject
{
public:
    // Make these members public for now. Since this object
    // is instantiated from the modem class installer. We
    // need to set the INetCfg member.
    //
    INetCfg*                m_pnc;
    CRasBindObject          ();

    ~CRasBindObject         ()
    {
        ReleaseObj (m_pnc);
    }

    // You must call ReleaseOtherComponents after calling this.
    HRESULT HrFindOtherComponents   ();

    // You can only call this once per call to HrFindOtherComponents.
    NOTHROW VOID ReleaseOtherComponents  ();

    HRESULT HrProcessEndpointChange ();

    NOTHROW   INetCfgComponent* PnccNdisWan ();

protected:
    // We keep an array of INetCfgComponent pointers.  This enum
    // defines the indicies of the array.  The static arrays of
    // class guids and component ids identify the respecitive components.
    // HrFindOtherComonents initializes the array of component pointers
    // and ReleaseOtherComponents releases them.  Note, however, that this
    // action is refcounted.  This is because we are re-entrant.
    // HrFindOtherComponents only finds the components if the refcount is
    // zero.  After every call, it increments the refcount.
    // ReleaseOtherComponents always decrements the refcount and only
    // releases the components if the refcount is zero.
    //
    enum OTHER_COMPONENTS
    {
        c_ipnccRasCli = 0,
        c_ipnccRasSrv,
        c_ipnccIp,
        c_ipnccIpx,
        c_ipnccNbf,
        c_ipnccAtalk,
        c_ipnccNetMon,
        c_ipnccNdisWan,
        c_ipnccIpAdapter,
        c_cOtherComponents,
    };
    static const GUID*      c_apguidComponentClasses [c_cOtherComponents];
    static const PCWSTR     c_apszComponentIds       [c_cOtherComponents];
    INetCfgComponent*       m_apnccOther             [c_cOtherComponents];
    ULONG                   m_ulOtherComponents;

protected:
    BOOL    FIsRasBindingInterface  (INetCfgBindingInterface* pncbi,
                                     RAS_BINDING_ID* pRasBindId);

    HRESULT HrCountInstalledMiniports   (UINT* pcIpOut,
                                         UINT* pcNbfIn,
                                         UINT* pcNbfOut);

    HRESULT HrCountWanAdapterEndpoints  (INetCfgComponent* pncc,
                                         RAS_BINDING_ID RasBindId,
                                         UINT* pcEndpoints);

    HRESULT HrAddOrRemoveAtalkInOut (DWORD dwFlags);
    HRESULT HrAddOrRemoveIpAdapter  (DWORD dwFlags);
    HRESULT HrAddOrRemoveIpOut      (INT nInstances);
    HRESULT HrAddOrRemoveIpxInOut   (DWORD dwFlags);
    HRESULT HrAddOrRemoveNbfIn      (INT nInstances);
    HRESULT HrAddOrRemoveNbfOut     (INT nInstances);
    HRESULT HrAddOrRemoveNetMonInOut(DWORD dwFlags);
    HRESULT HrAddOrRemovePti        (DWORD dwFlags);

    NOTHROW INetCfgComponent*   PnccRasCli      ();
    NOTHROW INetCfgComponent*   PnccRasSrv      ();
    NOTHROW INetCfgComponent*   PnccRasRtr      ();
    NOTHROW INetCfgComponent*   PnccIp          ();
    NOTHROW INetCfgComponent*   PnccIpx         ();
    NOTHROW INetCfgComponent*   PnccNbf         ();
    NOTHROW INetCfgComponent*   PnccAtalk       ();
    NOTHROW INetCfgComponent*   PnccNetMon      ();
    NOTHROW INetCfgComponent*   PnccIpAdapter   ();
};

extern const WCHAR c_szInfId_MS_NdisWanAtalk[];
extern const WCHAR c_szInfId_MS_NdisWanIp[];
extern const WCHAR c_szInfId_MS_NdisWanIpx[];
extern const WCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const WCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const WCHAR c_szInfId_MS_NdisWanBh[];
extern const WCHAR c_szInfId_MS_PtiMiniport[];


inline
HRESULT
CRasBindObject::HrAddOrRemoveAtalkInOut (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_NdisWanAtalk, dwFlags);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveIpAdapter (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_NdisWanIp, dwFlags);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveIpxInOut (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_NdisWanIpx, dwFlags);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveNbfIn (
    INT     nInstances)
{
    DWORD dwFlags   = (nInstances > 0) ? ARA_ADD    : ARA_REMOVE;
    UINT cInstances = (nInstances > 0) ? nInstances : 0 - nInstances;

    TraceTag (ttidRasCfg, "%s %d %S adapters",
              (nInstances > 0) ? "Adding" : "Removing",
              cInstances,
              c_szInfId_MS_NdisWanNbfIn);

    return HrAddOrRemoveAdapter (m_pnc, c_szInfId_MS_NdisWanNbfIn,
                                    dwFlags, NULL, cInstances, NULL);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveNbfOut (
    INT     nInstances)
{
    DWORD dwFlags   = (nInstances > 0) ? ARA_ADD    : ARA_REMOVE;
    UINT cInstances = (nInstances > 0) ? nInstances : 0 - nInstances;

    TraceTag (ttidRasCfg, "%s %d %S adapters",
              (nInstances > 0) ? "Adding" : "Removing",
              cInstances,
              c_szInfId_MS_NdisWanNbfOut);

    return HrAddOrRemoveAdapter (m_pnc, c_szInfId_MS_NdisWanNbfOut,
                                    dwFlags, NULL, cInstances, NULL);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveNetMonInOut (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_NdisWanBh, dwFlags);
}

inline
HRESULT
CRasBindObject::HrAddOrRemovePti (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PtiMiniport, dwFlags);
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccRasCli ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccRasCli];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccRasSrv ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccRasSrv];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccIp ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccIp];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccIpx ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccIpx];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccNbf ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccNbf];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccAtalk ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccAtalk];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccNetMon ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccNetMon];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccIpAdapter ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccIpAdapter];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccNdisWan ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    //AssertSzH (m_apnccOther [c_ipnccNdisWan], "The NdisWan component was not found, but we installed it!");
    return m_apnccOther [c_ipnccNdisWan];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\bindcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       B I N D C F G . C P P
//
//  Contents:   Exposes control for creating and removing RAS bindings.
//
//  Notes:      The exported methods are called by RAS when endpoints
//              need to be created or removed for the purpose of making
//              calls.
//
//  Author:     shaunco   16 Oct 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcfg.h"
#include "ncutil.h"
#include "netcfgn.h"
#include <rasapip.h>

extern const WCHAR c_szInfId_MS_NdisWanIp[];
extern const WCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const WCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const WCHAR c_szInfId_MS_NetBEUI[];
extern const WCHAR c_szInfId_MS_TCPIP[];

class CRasBindingConfig
{
public:
    INetCfg*    m_pNetCfg;
    BOOL        m_fInitCom;

    enum NEEDED_COMPONENTS
    {
        INDEX_IP = 0,
        INDEX_NBF,
        INDEX_IPADAPTER,
        COUNT_COMPONENTS,
    };
    INetCfgComponent*   m_apComponents  [COUNT_COMPONENTS];

public:
#if DBG
    CRasBindingConfig ()
    {
        m_pNetCfg = NULL;
    }
    ~CRasBindingConfig ()
    {
        AssertH (!m_pNetCfg);
    }
#endif

public:
    HRESULT
    HrAddOrRemoveBindings (
        IN     DWORD        dwFlags,
        IN OUT UINT*        pcIpOut,
        IN     const GUID*  pguidIpOutBindings,
        IN OUT UINT*        pcNbfIn,
        IN OUT UINT*        pcNbfOut);

    HRESULT
    HrCountBindings (
        OUT UINT*   pcIpOut,
        OUT UINT*   pcNbfIn,
        OUT UINT*   pcNbfOut);

    HRESULT
    HrLoadINetCfg (
        IN REGSAM samDesired);

    HRESULT
    HrLoadINetCfgAndAddOrRemoveBindings (
        IN     DWORD        dwFlags,
        IN OUT UINT*        pcIpOut,
        IN     const GUID*  pguidIpOutBindings,
        IN OUT UINT*        pcNbfIn,
        IN OUT UINT*        pcNbfOut);

    VOID
    UnloadINetCfg ();

    INetCfgComponent*
    PnccIp ()
    {
        AssertH (m_pNetCfg);
        return m_apComponents [INDEX_IP];
    }

    INetCfgComponent*
    PnccIpAdapter ()
    {
        AssertH (m_pNetCfg);
        return m_apComponents [INDEX_IPADAPTER];
    }

    INetCfgComponent*
    PnccNbf ()
    {
        AssertH (m_pNetCfg);
        return m_apComponents [INDEX_NBF];
    }
};


HRESULT
CRasBindingConfig::HrCountBindings (
    UINT* pcIpOut,
    UINT* pcNbfIn,
    UINT* pcNbfOut)
{
    Assert (pcIpOut);
    Assert (pcNbfIn);
    Assert (pcNbfOut);

    HRESULT hr = S_OK;

    // Initialize output parameters.
    //
    *pcIpOut = *pcNbfIn = *pcNbfOut = 0;

    if (PnccIp() && PnccIpAdapter())
    {
        INetCfgComponentUpperEdge* pUpperEdge;
        hr = HrQueryNotifyObject (
                        PnccIp(),
                        IID_INetCfgComponentUpperEdge,
                        reinterpret_cast<VOID**>(&pUpperEdge));

        if (SUCCEEDED(hr))
        {
            DWORD dwNumInterfaces;
            GUID* pguidInterfaceIds;

            hr = pUpperEdge->GetInterfaceIdsForAdapter (
                    PnccIpAdapter(),
                    &dwNumInterfaces,
                    &pguidInterfaceIds);
            if (SUCCEEDED(hr))
            {
                *pcIpOut = dwNumInterfaces;

                CoTaskMemFree (pguidInterfaceIds);
            }

            ReleaseObj (pUpperEdge);
        }
    }

    if (PnccNbf())
    {
        // Iterate adapters in the system.
        //
        CIterNetCfgComponent nccIter(m_pNetCfg, &GUID_DEVCLASS_NET);
        INetCfgComponent* pnccAdapter;
	
        while (S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
        {
          // Quickly discard non-hidden adapters to avoid unneccesary
          // string compares.
          //
          DWORD dwCharacter;
          if (   SUCCEEDED(pnccAdapter->GetCharacteristics (&dwCharacter))
             	   && (dwCharacter & NCF_HIDDEN))
          {
             PWSTR pszId;
             if (SUCCEEDED(pnccAdapter->GetId (&pszId)))
             {
            	if (FEqualComponentId (c_szInfId_MS_NdisWanNbfIn,
                                pszId))
                 {
                       	(*pcNbfIn)++;
                 }
                 else if (FEqualComponentId (c_szInfId_MS_NdisWanNbfOut,
                                pszId))
                 {
                       	(*pcNbfOut)++;
                 }

	         CoTaskMemFree (pszId);
             }
           }
	            ReleaseObj (pnccAdapter);
        }
	
    }

    TraceTag (ttidRasCfg,
              "Current RAS bindings: "
              "%u IP dial-out, %u NBF dial-in, %u NBF dial-out",
              *pcIpOut, *pcNbfIn, *pcNbfOut);

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::HrCountBindings");
    return hr;
}

HRESULT
CRasBindingConfig::HrAddOrRemoveBindings (
    IN     DWORD        dwFlags,
    IN OUT UINT*        pcIpOut,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut)
{
    HRESULT hr = S_OK;

    // Safe off the input parameters.
    //
    UINT cIpOut  = *pcIpOut;
    UINT cNbfIn  = *pcNbfIn;
    UINT cNbfOut = *pcNbfOut;

    if (cIpOut && PnccIp() && PnccIpAdapter())
    {
        INetCfgComponentUpperEdge* pUpperEdge;
        hr = HrQueryNotifyObject (
                        PnccIp(),
                        IID_INetCfgComponentUpperEdge,
                        reinterpret_cast<VOID**>(&pUpperEdge));

        if (SUCCEEDED(hr))
        {
            if (dwFlags & ARA_ADD)
            {
                TraceTag (ttidRasCfg,
                    "Adding %d TCP/IP interfaces to the ndiswanip adapter",
                    cIpOut);

                hr = pUpperEdge->AddInterfacesToAdapter (
                        PnccIpAdapter(),
                        cIpOut);
            }
            else
            {
                TraceTag (ttidRasCfg,
                    "Removing %d TCP/IP interfaces from the ndiswanip adapter",
                    cIpOut);

                hr = pUpperEdge->RemoveInterfacesFromAdapter (
                        PnccIpAdapter(),
                        cIpOut,
                        pguidIpOutBindings);
            }

            ReleaseObj (pUpperEdge);
        }
    }

    if (PnccNbf() && SUCCEEDED(hr))
    {
        if (cNbfIn)
        {
            TraceTag (ttidRasCfg,
                "%s %d %S adapters",
                (dwFlags & ARA_ADD) ? "Adding" : "Removing",
                cNbfIn,
                c_szInfId_MS_NdisWanNbfIn);

            hr = HrAddOrRemoveAdapter (
                    m_pNetCfg,
                    c_szInfId_MS_NdisWanNbfIn,
                    dwFlags, NULL, cNbfIn, NULL);
        }

        if (cNbfOut && SUCCEEDED(hr))
        {
            TraceTag (ttidRasCfg,
                "%s %d %S adapters",
                (dwFlags & ARA_ADD) ? "Adding" : "Removing",
                cNbfOut,
                c_szInfId_MS_NdisWanNbfOut);

            hr = HrAddOrRemoveAdapter (
                    m_pNetCfg,
                    c_szInfId_MS_NdisWanNbfOut,
                    dwFlags, NULL, cNbfOut, NULL);
        }
    }

    HRESULT hrT = HrCountBindings(pcIpOut, pcNbfIn, pcNbfOut);
    if (SUCCEEDED(hr))
    {
        hr = hrT;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::HrAddOrRemoveBindings");
    return hr;
}

HRESULT
CRasBindingConfig::HrLoadINetCfg (
    IN REGSAM samDesired)
{
    HRESULT hr;

    Assert (!m_pNetCfg);

    // Get INetCfg and lock it for write.
    //
    m_fInitCom = TRUE;
    hr = HrCreateAndInitializeINetCfg (
            &m_fInitCom,
            &m_pNetCfg,
            (KEY_WRITE == samDesired),  // get the write lock if needed
            0,                          // don't wait for it
            L"RAS Binding Configuration",
            NULL);

    if (SUCCEEDED(hr))
    {
        ZeroMemory (m_apComponents, sizeof(m_apComponents));

        // Find the following components and hold on to their INetCfgComponent
        // interface pointers in m_apComponents.  UnloadINetCfg will release
        // these.  HrFindComponents will zero the array so it is safe to
        // call UnloadINetCfg if HrFindComponents fails.
        //
        const GUID* c_apguidComponentClasses [COUNT_COMPONENTS] =
        {
            &GUID_DEVCLASS_NETTRANS,        // Ip
            &GUID_DEVCLASS_NETTRANS,        // NetBEUI
            &GUID_DEVCLASS_NET,             // IpAdapter
        };

        const PCWSTR c_apszComponentIds [COUNT_COMPONENTS] =
        {
            c_szInfId_MS_TCPIP,
            c_szInfId_MS_NetBEUI,
            c_szInfId_MS_NdisWanIp,
        };

        if (SUCCEEDED(hr))
        {
            hr = HrFindComponents (
                    m_pNetCfg,
                    COUNT_COMPONENTS,
                    c_apguidComponentClasses,
                    c_apszComponentIds,
                    m_apComponents);
        }

        if (FAILED(hr))
        {
            // If we have a failure while trying to find these components
            // we're going to fail this method call, so be sure to cleanup
            // m_pNetCfg.
            //
            UnloadINetCfg ();
            Assert (!m_pNetCfg);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::HrLoadINetCfg");
    return hr;
}

HRESULT
CRasBindingConfig::HrLoadINetCfgAndAddOrRemoveBindings (
    IN     DWORD        dwFlags,
    IN OUT UINT*        pcIpOut,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut)
{
    Assert (!m_pNetCfg);

    HRESULT hr;

    hr = HrLoadINetCfg (KEY_WRITE);

    if (SUCCEEDED(hr))
    {
        __try
        {
            hr = HrAddOrRemoveBindings (
                    dwFlags,
                    pcIpOut,
                    pguidIpOutBindings,
                    pcNbfIn,
                    pcNbfOut);

            if (SUCCEEDED(hr))
            {
                (VOID) m_pNetCfg->Apply();
            }
            else
            {
                (VOID) m_pNetCfg->Cancel();
            }
        }
        __finally
        {
            UnloadINetCfg ();
        }
    }

    // We shouldn't ever leave with an un-released INetCfg.
    //
    Assert (!m_pNetCfg);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "CRasBindingConfig::HrLoadINetCfgAndAddOrRemoveBindings");
    return hr;
}

VOID
CRasBindingConfig::UnloadINetCfg ()
{
    // Must call HrLoadINetCfg before calling this.
    //
    Assert (m_pNetCfg);

    ReleaseIUnknownArray (COUNT_COMPONENTS, (IUnknown**)m_apComponents);

    (VOID) HrUninitializeAndReleaseINetCfg (m_fInitCom, m_pNetCfg, TRUE);
    m_pNetCfg = NULL;
}


//+---------------------------------------------------------------------------
// Exported functions
//

EXTERN_C
HRESULT
WINAPI
RasAddBindings (
    IN OUT UINT*    pcIpOut,
    IN OUT UINT*    pcNbfIn,
    IN OUT UINT*    pcNbfOut)
{
    HRESULT hr;

#if 0
    RtlValidateProcessHeaps ();
#endif

    // Validate parameters.
    //
    if (!pcIpOut || !pcNbfIn || !pcNbfOut)
    {
        hr = E_POINTER;
    }
    else if (!*pcIpOut && !*pcNbfIn && !*pcNbfOut)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CRasBindingConfig Config;

        hr = Config.HrLoadINetCfgAndAddOrRemoveBindings (
                ARA_ADD,
                pcIpOut,
                NULL,
                pcNbfIn,
                pcNbfOut);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::RasAddBindings");
    return hr;
}

EXTERN_C
HRESULT
WINAPI
RasCountBindings (
    OUT UINT*   pcIpOut,
    OUT UINT*   pcNbfIn,
    OUT UINT*   pcNbfOut)
{
    HRESULT hr;

#if 0
    RtlValidateProcessHeaps ();
#endif

    // Validate parameters.
    //
    if (!pcIpOut || !pcNbfIn || !pcNbfOut)
    {
        hr = E_POINTER;
    }
    else
    {
        CRasBindingConfig Config;

        hr = Config.HrLoadINetCfg (KEY_READ);
        if (SUCCEEDED(hr))
        {
            __try
            {
                hr = Config.HrCountBindings (
                        pcIpOut,
                        pcNbfIn,
                        pcNbfOut);
            }
            __finally
            {
                Config.UnloadINetCfg ();
            }
        }
        // We shouldn't ever leave with an un-released INetCfg.
        //
        Assert (!Config.m_pNetCfg);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::RasCountBindings");
    return hr;
}

EXTERN_C
HRESULT
WINAPI
RasRemoveBindings (
    IN OUT UINT*        pcIpOutBindings,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut)
{
    HRESULT hr;

#if 0
    RtlValidateProcessHeaps ();
#endif

    // Validate parameters.
    //
    if (!pcIpOutBindings || !pcNbfIn || !pcNbfOut)
    {
        hr = E_POINTER;
    }
    else if (!*pcIpOutBindings && !*pcNbfIn && !*pcNbfOut)
    {
        hr = E_INVALIDARG;
    }
    else if (*pcIpOutBindings && !pguidIpOutBindings)
    {
        hr = E_POINTER;
    }
    else
    {
        CRasBindingConfig Config;

        hr = Config.HrLoadINetCfgAndAddOrRemoveBindings (
                ARA_REMOVE,
                pcIpOutBindings,
                pguidIpOutBindings,
                pcNbfIn,
                pcNbfOut);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::RasRemoveBindings");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\l2tp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L 2 T P . C P P
//
//  Contents:   Implementation of L2TP configuration object.
//
//  Notes:
//
//  Author:     shaunco   15 Jul 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncui.h"
#include "ndiswan.h"
#include "rasobj.h"

extern const WCHAR c_szInfId_MS_L2tpMiniport[];

CL2tp::CL2tp () : CRasBindObject ()
{
    m_pnccMe = NULL;
    m_fSaveAfData = FALSE;
}

CL2tp::~CL2tp ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CL2tp::Initialize (
        INetCfgComponent*   pncc,
        INetCfg*            pnc,
        BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    //
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    return S_OK;
}

STDMETHODIMP
CL2tp::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CL2tp::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CL2tp::ApplyRegistryChanges ()
{
    if (m_fSaveAfData)
    {
        m_AfData.SaveToRegistry (m_pnc);
        m_fSaveAfData = FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CL2tp::ReadAnswerFile (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    // Read data from the answer file.
    // Don't let this affect the HRESULT we return.
    //
    if (SUCCEEDED(m_AfData.HrOpenAndRead (pszAnswerFile, pszAnswerSection)))
    {
        m_fSaveAfData = TRUE;
    }

    return S_OK;
}

STDMETHODIMP
CL2tp::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install the L2TP miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_L2tpMiniport, ARA_ADD);

    TraceError ("CL2tp::Install", hr);
    return hr;
}

STDMETHODIMP
CL2tp::Removing ()
{
    HRESULT hr;

    // Install the L2TP miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_L2tpMiniport, ARA_REMOVE);

    TraceError ("CL2tp::Removing", hr);
    return hr;
}

STDMETHODIMP
CL2tp::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\modemdi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M O D E M D I . H
//
//  Contents:   Modem coclass device installer hook.
//
//  Notes:
//
//  Author:     shaunco   7 May 1997
//
//----------------------------------------------------------------------------

#pragma once

extern const WCHAR c_szModemAttachedTo [];

HRESULT
HrModemClassCoInstaller (
        DI_FUNCTION                 dif,
        HDEVINFO                    hdi,
        PSP_DEVINFO_DATA            pdeid,
        PCOINSTALLER_CONTEXT_DATA   pContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\ncutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       N C U T I L . C P P
//
//  Contents:   INetCfg utilities.  This is all a candidate to be moved into
//              nccommon\src\ncnetcfg.cpp.
//
//  Notes:
//
//  Author:     shaunco   28 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcfg.h"
#include "ncutil.h"

extern const WCHAR c_szInfId_MS_NdisWanIp[];

//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureZeroOrOneAdapter
//
//  Purpose:
//
//  Arguments:
//      pnc            []
//      pszComponentId []
//      dwFlags        []
//
//  Returns:
//
//  Author:     shaunco   5 Dec 1997
//
//  Notes:
//
HRESULT
HrEnsureZeroOrOneAdapter (
    INetCfg*    pnc,
    PCWSTR     pszComponentId,
    DWORD       dwFlags)
{
    HRESULT hr = S_OK;

    if (dwFlags & ARA_ADD)
    {
        // Make sure we have one present.
        //
        if (!FIsAdapterInstalled (pnc, pszComponentId))
        {
            TraceTag (ttidRasCfg, "Adding %S", pszComponentId);

            hr = HrAddOrRemoveAdapter (pnc, pszComponentId,
                             ARA_ADD, NULL, 1, NULL);
        }
    }
    else
    {
        // Make sure we have none present.
        //
        TraceTag (ttidRasCfg, "Removing %S", pszComponentId);

        hr = HrFindAndRemoveAllInstancesOfAdapter (pnc, pszComponentId);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrEnsureZeroOrOneAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuidAsString
//
//  Purpose:
//
//  Arguments:
//      pncc    []
//      pszGuid []
//      cchGuid []
//
//  Returns:
//
//  Author:     shaunco   14 Jun 1997
//
//  Notes:
//
HRESULT
HrGetInstanceGuidAsString (
    INetCfgComponent*   pncc,
    PWSTR              pszGuid,
    INT                 cchGuid)
{
    GUID guid;
    HRESULT hr = pncc->GetInstanceGuid (&guid);
    if(SUCCEEDED(hr))
    {
        if (0 == StringFromGUID2(guid, pszGuid, cchGuid))
        {
            hr = E_INVALIDARG;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrGetInstanceGuidAsString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMapComponentIdToDword
//
//  Purpose:    Maps a component's id to a DWORD value.  The mapping is
//              specified by the caller through an array of pointers to
//              string values and their associated DWORD values.
//
//  Arguments:
//      pncc        [in]    pointer to component.
//      aMapSzDword [in]    array of elements mapping a string to a DWORD.
//      cMapSzDword [in]    count of elements in the array.
//      pdwValue    [out]   the returned value.
//
//  Returns:    S_OK if a match was found.  If a match wasn't found,
//              S_FALSE is returned.
//              Other Win32 error codes.
//
//  Author:     shaunco   17 May 1997
//
//  Notes:
//
HRESULT
HrMapComponentIdToDword (
    INetCfgComponent*   pncc,
    const MAP_SZ_DWORD* aMapSzDword,
    UINT                cMapSzDword,
    DWORD*              pdwValue)
{
    Assert (pncc);
    Assert (aMapSzDword);
    Assert (cMapSzDword);
    Assert (pdwValue);

    // Initialize output parameter.
    *pdwValue = 0;

    PWSTR pszwId;
    HRESULT hr = pncc->GetId (&pszwId);
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;
        while (cMapSzDword--)
        {
            if (FEqualComponentId (pszwId, aMapSzDword->pszValue))
            {
                *pdwValue = aMapSzDword->dwValue;
                hr = S_OK;
                break;
            }
            aMapSzDword++;
        }
        CoTaskMemFree (pszwId);
    }
    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
            "HrMapComponentIdToDword");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenComponentParamKey
//
//  Purpose:    Find a component and open its parameter key.
//
//  Arguments:
//      pnc            [in]
//      rguidClass     [in]
//      pszComponentId [in]
//      phkey          [out]
//
//  Returns:    S_OK if the component was found the key was opened.
//              S_FALSE if the compoennt was not found.
//              error code.
//
//  Author:     shaunco   13 Apr 1997
//
//  Notes:
//
HRESULT
HrOpenComponentParamKey (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszComponentId,
    HKEY*       phkey)
{
    Assert (pnc);
    Assert (pszComponentId);
    Assert (phkey);

    // Initialize the output parameter.
    *phkey = NULL;

    // Find the component.
    INetCfgComponent* pncc;
    HRESULT hr = pnc->FindComponent ( pszComponentId, &pncc);
    if (S_OK == hr)
    {
        // Open its param key.
        hr = pncc->OpenParamKey (phkey);
        ReleaseObj (pncc);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
            "HrOpenComponentParamKey");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\modemdi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M O D E M D I . C P P
//
//  Contents:   Modem coclass device installer hook.
//
//  Notes:
//
//  Author:     shaunco   7 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncsetup.h"

HRESULT
HrUpdateLegacyRasTapiDevices ();


//+---------------------------------------------------------------------------
//
//  Function:   HrModemClassCoInstaller
//
//  Purpose:    Responds to co-class installer messages to install and remove
//              net modem adapters.
//
//  Arguments:
//      dif      [in] See SetupApi.
//      hdi      [in]
//      pdeid    [in]
//      pContext [inout]
//
//  Returns:    S_OK, SPAPI_E_DI_POSTPROCESSING_REQUIRED, or an error code.
//
//  Author:     shaunco   3 Aug 1997
//
//  Notes:
//
HRESULT
HrModemClassCoInstaller (
    IN     DI_FUNCTION                  dif,
    IN     HDEVINFO                     hdi,
    IN     PSP_DEVINFO_DATA             pdeid,
    IN OUT PCOINSTALLER_CONTEXT_DATA    pContext)
{
    HRESULT hr = S_OK;

    if (DIF_INSTALLDEVICE == dif)
    {
        // When we're called during preprocessing, indicated
        // we require postprocessing.
        //
        if (!pContext->PostProcessing)
        {
            // Documentation indicates it, so we'll assert it.
            AssertSz (NO_ERROR == pContext->InstallResult,
                      "HrModemClassCoInstaller: Bug in SetupApi!  "
                      "InstallResult should be NO_ERROR.");

            // Make sure they wouldn't loose our context info
            // even if we used it.
#ifdef DBG
            pContext->PrivateData = NULL;
#endif // DBG

            hr = SPAPI_E_DI_POSTPROCESSING_REQUIRED;
        }
        else
        {


            // Check out "context info" to make sure they didn't
            // touch it.
            //
            AssertSz (!pContext->PrivateData, "HrModemClassCoInstaller: "
                      "Bug in SetupApi!  You sunk my battleship!  "
                      "(I mean, you trashed my PrivateData)");

            // We are now in the postprocessing phase.
            // We will install a virtual network adapter for
            // the modem that was just installed but only if
            // it was installed successfully.
            //

            // We should have handled this case back in ModemClassCoInstaller.
            //
            AssertSz (NO_ERROR == pContext->InstallResult,
                      "HrModemClassCoInstaller: Bug in ModemClassCoInstaller!  "
                      "InstallResult should be NO_ERROR or we would have "
                      "returned immediately.");


            hr = S_OK;
        }
    }

    else if (DIF_REMOVE == dif)
    {
        // We're not going to fail remove operations.  It's bad enough
        // when a user can't add a modem.  It pisses them off to no end
        // if they can't remove them.
        //
        hr = S_OK;
    }

    else if (DIF_DESTROYPRIVATEDATA == dif)
    {
        (VOID) HrUpdateLegacyRasTapiDevices ();
    }

    TraceError ("HrModemClassCoInstaller",
            (SPAPI_E_DI_POSTPROCESSING_REQUIRED == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUpdateLegacyRasTapiDevices
//
//  Purpose:    Legacy applications such as HPC Explorer 1.1 require
//              that modems that are "enabled" for RAS use be specified
//              under HKLM\Software\Microsoft\Ras\Tapi Devices\Unimodem.
//              The values that exist under these keys are multi-sz's of
//              COM ports, Friendly names, and Usage.  This routine sets
//              those keys corresponding to all modems present on the
//              machine (and active in this HW profile).
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   19 Mar 1998
//
//  Notes:
//
HRESULT
HrUpdateLegacyRasTapiDevices ()
{
    // Keep lists of strings that we will write as multi-sz to
    // HKLM\Software\Microsoft\Ras\Tapi Devices\Unimodem.
    //
    list<tstring*>  lstrAddress;
    list<tstring*>  lstrFriendlyName;
    list<tstring*>  lstrUsage;

    // Get all of the installed modems.
    //
    HDEVINFO hdi;
    HRESULT hr = HrSetupDiGetClassDevs (&GUID_DEVCLASS_MODEM, NULL,
                    NULL, DIGCF_PRESENT | DIGCF_PROFILE, &hdi);
    if (SUCCEEDED(hr))
    {
        // Declare these outside the while loop to avoid construction
        // destruction at each iteration.
        //
        tstring strAttachedTo;
        tstring strFriendlyName;

        // Enumerate the devices and open their dev reg key.
        //
        DWORD dwIndex = 0;
        SP_DEVINFO_DATA deid;
        while (SUCCEEDED(hr = HrSetupDiEnumDeviceInfo (hdi, dwIndex++, &deid)))
        {
            // Try to open the registry key for this modem.  If it fails,
            // ignore and move on to the next.
            //
            HKEY hkey;
            hr = HrSetupDiOpenDevRegKey(hdi, &deid,
                            DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                            KEY_READ, &hkey);
            if (SUCCEEDED(hr))
            {
                // Get the AttachedTo and FriendlyName values for the modem.
                // PnPAttachedTo will be present for PnP modems.
                //
                static const WCHAR c_szModemAttachedTo   [] = L"AttachedTo";
                static const WCHAR c_szModemPnPAttachedTo[] = L"PnPAttachedTo";
                static const WCHAR c_szModemFriendlyName [] = L"FriendlyName";
                static const WCHAR c_szUsage             [] = L"ClientAndServer";

                // Look for PnPAttached to first, then fallback to AttachedTo
                // if it failed.
                //
                hr = HrRegQueryString (hkey, c_szModemPnPAttachedTo,
                            &strAttachedTo);
                if (FAILED(hr))
                {
                    hr = HrRegQueryString (hkey, c_szModemAttachedTo,
                                &strAttachedTo);
                }
                if (SUCCEEDED(hr))
                {
                    hr = HrRegQueryString (hkey, c_szModemFriendlyName,
                                &strFriendlyName);
                    if (SUCCEEDED(hr))
                    {
                        // Add them to our lists.
                        lstrAddress     .push_back (new tstring (strAttachedTo));
                        lstrFriendlyName.push_back (new tstring (strFriendlyName));
                        lstrUsage       .push_back (new tstring (c_szUsage));
                    }
                }

                RegCloseKey (hkey);
            }
        }
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }


        SetupDiDestroyDeviceInfoList (hdi);
    }

    // Now save the lists as multi-sz's.
    //
    static const WCHAR c_szRegKeyLegacyRasUnimodemTapiDevices[]
        = L"Software\\Microsoft\\Ras\\Tapi Devices\\Unimodem";
    HKEY hkey;
    hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE,
            c_szRegKeyLegacyRasUnimodemTapiDevices,
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, NULL);
    if (SUCCEEDED(hr))
    {
        static const WCHAR c_szRegValAddress      [] = L"Address";
        static const WCHAR c_szRegValFriendlyName [] = L"Friendly Name";
        static const WCHAR c_szRegValUsage        [] = L"Usage";

        (VOID) HrRegSetColString (hkey, c_szRegValAddress,      lstrAddress);
        (VOID) HrRegSetColString (hkey, c_szRegValFriendlyName, lstrFriendlyName);
        (VOID) HrRegSetColString (hkey, c_szRegValUsage,        lstrUsage);


        static const WCHAR c_szRegValMediaType    [] = L"Media Type";
        static const WCHAR c_szRegValModem        [] = L"Modem";

        (VOID) HrRegSetSz (hkey, c_szRegValMediaType, c_szRegValModem);

        RegCloseKey (hkey);
    }

    FreeCollectionAndItem (lstrUsage);
    FreeCollectionAndItem (lstrFriendlyName);
    FreeCollectionAndItem (lstrAddress);

    TraceError ("HrUpdateLegacyRasTapiDevices", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\ndiswan.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       B I N D A G N T . H
//
//  Contents:   Declaration of NdisWan configuration object.
//
//  Notes:
//
//  Author:     shaunco   28 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "bindobj.h"
#include "resource.h"
#include "rasaf.h"
#include "rasdata.h"
#include "ncutil.h"


class ATL_NO_VTABLE CNdisWan :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CNdisWan, &CLSID_CNdisWan>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal
{
protected:
    // This is our in-memory state.
    BOOL    m_fInstalling;
    BOOL    m_fRemoving;

    // These are handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

public:
    CNdisWan  ();
    ~CNdisWan ();

    BEGIN_COM_MAP(CNdisWan)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNdisWan)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it.

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NDISWAN)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\pppoe.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P P T P . C P P
//
//  Contents:   Implementation of PPPOE configuration object.
//
//  Notes:
//
//  Author:     shaunco   10 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ndiswan.h"
#include "rasobj.h"

extern const WCHAR c_szInfId_MS_PppoeMiniport[];

CPppoe::CPppoe () : CRasBindObject ()
{
    m_pnccMe = NULL;
    m_fSaveAfData = FALSE;
}

CPppoe::~CPppoe ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CPppoe::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    //
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    return S_OK;
}

STDMETHODIMP
CPppoe::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CPppoe::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CPppoe::ApplyRegistryChanges ()
{
    if (m_fSaveAfData)
    {
        m_AfData.SaveToRegistry (m_pnc);
        m_fSaveAfData = FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CPppoe::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile (pszAnswerFile, pszAnswerSection);

    // Read data from the answer file.
    // Don't let this affect the HRESULT we return.
    //
    if (SUCCEEDED(m_AfData.HrOpenAndRead (pszAnswerFile, pszAnswerSection)))
    {
        m_fSaveAfData = TRUE;
    }

    return S_OK;
}

STDMETHODIMP
CPppoe::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install the PPPOE miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PppoeMiniport, ARA_ADD);

    TraceError ("CPppoe::Install", hr);
    return hr;
}

STDMETHODIMP
CPppoe::Removing ()
{
    HRESULT hr;

    // Remove the PPPOE miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PppoeMiniport, ARA_REMOVE);

    TraceError ("CPppoe::Removing", hr);
    return hr;
}

STDMETHODIMP
CPppoe::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\pptp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P P T P . C P P
//
//  Contents:   Implementation of PPTP configuration object.
//
//  Notes:
//
//  Author:     shaunco   10 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ndiswan.h"
#include "rasobj.h"

extern const WCHAR c_szInfId_MS_PptpMiniport[];

CPptp::CPptp () : CRasBindObject ()
{
    m_pnccMe = NULL;
    m_fSaveAfData = FALSE;
}

CPptp::~CPptp ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CPptp::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    //
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    return S_OK;
}

STDMETHODIMP
CPptp::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CPptp::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CPptp::ApplyRegistryChanges ()
{
    if (m_fSaveAfData)
    {
        m_AfData.SaveToRegistry (m_pnc);
        m_fSaveAfData = FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CPptp::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile (pszAnswerFile, pszAnswerSection);

    // Read data from the answer file.
    // Don't let this affect the HRESULT we return.
    //
    if (SUCCEEDED(m_AfData.HrOpenAndRead (pszAnswerFile, pszAnswerSection)))
    {
        m_fSaveAfData = TRUE;
    }

    return S_OK;
}

STDMETHODIMP
CPptp::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install the PPTP miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PptpMiniport, ARA_ADD);

    TraceError ("CPptp::Install", hr);
    return hr;
}

STDMETHODIMP
CPptp::Removing ()
{
    HRESULT hr;

    // Remove the PPTP miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PptpMiniport, ARA_REMOVE);

    TraceError ("CPptp::Removing", hr);
    return hr;
}

STDMETHODIMP
CPptp::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\ncutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       N C U T I L . H
//
//  Contents:   INetCfg utilities.  Some of these could to be moved into
//              nccommon\src\ncnetcfg.cpp.
//
//  Notes:
//
//  Author:     shaunco   28 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "ncstring.h"
#include "netcfgx.h"

inline
BOOL
FIsAdapterInstalled (
    INetCfg*    pnc,
    PCWSTR     pszComponentId)
{
    return (S_OK == pnc->FindComponent (pszComponentId, NULL));
}

HRESULT
HrEnsureZeroOrOneAdapter (
    INetCfg*    pnc,
    PCWSTR     pszComponentId,
    DWORD       dwFlags);

HRESULT
HrGetInstanceGuidAsString (
    INetCfgComponent*   pncc,
    PWSTR              pszGuid,
    INT                 cchGuid);


HRESULT
HrMapComponentIdToDword (
    INetCfgComponent*   pncc,
    const MAP_SZ_DWORD* aMapSzDword,
    UINT                cMapSzDword,
    DWORD*              pdwValue);

HRESULT
HrOpenComponentParamKey (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszComponentId,
    HKEY*       phkey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\rasaf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S A F . C P P
//
//  Contents:   RAS Answer File objects.
//
//  Notes:
//
//  Author:     shaunco   19 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncipaddr.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "rasaf.h"
#include "rasobj.h"

extern const WCHAR c_szAfAppleTalk[];
extern const WCHAR c_szAfAutoNetworkNumbers[];
extern const WCHAR c_szAfClientCanReqIpaddr[];
extern const WCHAR c_szAfClientReqNodeNumber[];
extern const WCHAR c_szAfDialinProtocols[];
extern const WCHAR c_szAfForceEncryptedData[];
extern const WCHAR c_szAfForceStrongEncryption[];
extern const WCHAR c_szAfForceEncryptedPassword[];
extern const WCHAR c_szAfWanNetPoolSize[];
extern const WCHAR c_szAfIpAddressStart[];
extern const WCHAR c_szAfIpAddressEnd[];
extern const WCHAR c_szAfIpxClientAccess[];
extern const WCHAR c_szAfIpx[];
extern const WCHAR c_szAfL2tpMaxVcs[];
extern const WCHAR c_szAfL2tpEndpoints[];
extern const WCHAR c_szAfMultilink[];
extern const WCHAR c_szAfNetNumberFrom[];
extern const WCHAR c_szAfNetbeuiClientAccess[];
extern const WCHAR c_szAfNetbeui[];
extern const WCHAR c_szAfNetwork[];
extern const WCHAR c_szAfParamsSection[];
extern const WCHAR c_szAfPptpEndpoints[];
extern const WCHAR c_szAfRouterType[];
extern const WCHAR c_szAfSecureVPN[];
extern const WCHAR c_szAfSetDialinUsage[];
extern const WCHAR c_szAfSameNetworkNumber[];
extern const WCHAR c_szAfTcpipClientAccess[];
extern const WCHAR c_szAfTcpip[];
extern const WCHAR c_szAfThisComputer[];
extern const WCHAR c_szAfUseDhcp[];

extern const WCHAR c_szInfId_MS_L2tpMiniport[];
extern const WCHAR c_szInfId_MS_PptpMiniport[];
extern const WCHAR c_szInfId_MS_PppoeMiniport[];


//+---------------------------------------------------------------------------
// CRasSrvAnswerFileData
//
HRESULT
CRasSrvAnswerFileData::HrOpenAndRead (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    // Open the answer file.  It will close itself in it's destructor.
    CSetupInfFile inf;
    UINT unErrorLine;

    HRESULT hr = inf.HrOpen (
                    pszAnswerFile, NULL,
                    INF_STYLE_OLDNT | INF_STYLE_WIN4,
                    &unErrorLine);

    if (SUCCEEDED(hr))
    {
        m_fRouterTypeSpecified = FALSE;
        m_fSetUsageToDialin = FALSE;

        // Prepare the default values for use when we fail to read.
        // Initializing with defaults also helps to gaurantee that bogus
        // values aren't used when we add items to the structure but fail
        // to provide answer file support for them.
        //
        m_dataSrvCfg.GetDefault ();
        m_dataSrvIp .GetDefault ();
        m_dataSrvIpx.GetDefault ();
        m_dataSrvNbf.GetDefault ();

        DATA_SRV_CFG defSrvCfg  = m_dataSrvCfg;
        DATA_SRV_IP  defSrvIp   = m_dataSrvIp;
        DATA_SRV_IPX defSrvIpx  = m_dataSrvIpx;
        DATA_SRV_NBF defSrvNbf  = m_dataSrvNbf;

        // Get the real parameter section.
        //
        tstring strSection;
        hr = inf.HrGetString (pszAnswerSection,
                              c_szAfParamsSection, &strSection);
        if (FAILED(hr))
        {
            // If we failed to find the parameter section, just try
            // this one.
            //
            strSection = pszAnswerSection;
        }

        static const MAP_SZ_DWORD c_mapProtocols [] =
        {
            { c_szAfTcpip,      RPI_IP    },
            { c_szAfIpx,        RPI_IPX   },
            { c_szAfNetbeui,    RPI_NBF   },
            { c_szAfAppleTalk,  RPI_ATALK },
        };
        // Read the list of dial-in protocols.
        //
        hr = inf.HrGetMultiSzMapToDword (strSection.c_str(),
                                         c_szAfDialinProtocols,
                                         c_mapProtocols,
                                         celems (c_mapProtocols),
                                         &m_dwDialInProtocolIds);
        if (FAILED(hr) || !m_dwDialInProtocolIds)
        {
            // If its not there, use all possible.
            m_dwDialInProtocolIds = RPI_ALL;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfMultilink,
                                    &m_dataSrvCfg.fMultilink);
        if (FAILED(hr))
        {
            m_dataSrvCfg.fMultilink = defSrvCfg.fMultilink;
        }

        hr = inf.HrGetDword(strSection.c_str(),
                            c_szAfRouterType,
                            (DWORD*)&m_dataSrvCfg.dwRouterType);
        if (FAILED(hr))
        {
            m_dataSrvCfg.dwRouterType = defSrvCfg.dwRouterType;
        }
        else
        {
            m_fRouterTypeSpecified = TRUE;
        }

        hr = inf.HrGetDword (strSection.c_str(),
                                    c_szAfForceEncryptedPassword,
                                    &m_dataSrvCfg.dwAuthLevel);
        if (FAILED(hr))
        {
            m_dataSrvCfg.dwAuthLevel = defSrvCfg.dwAuthLevel;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfForceEncryptedData,
                                    &m_dataSrvCfg.fDataEnc);
        if (FAILED(hr))
        {
            m_dataSrvCfg.fDataEnc = defSrvCfg.fDataEnc;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfForceStrongEncryption,
                                    &m_dataSrvCfg.fStrongDataEnc);
        if (FAILED(hr))
        {
            m_dataSrvCfg.fStrongDataEnc = defSrvCfg.fStrongDataEnc;
        }

        hr = inf.HrGetDword (strSection.c_str(),
                                    c_szAfSecureVPN,
                                    &m_dataSrvCfg.dwSecureVPN);
        if (FAILED(hr))
        {
            m_dataSrvCfg.dwSecureVPN = defSrvCfg.dwSecureVPN;
        }

        // pmay: 251736
        // Discover whether we are to set all port usage to 'dialin'
        //
        DWORD dwSetUsageToDialin;

        hr = inf.HrGetDword(strSection.c_str(),
                            c_szAfSetDialinUsage,
                            &dwSetUsageToDialin);
        if (SUCCEEDED(hr))
        {
            m_fSetUsageToDialin = !!dwSetUsageToDialin;
        }

        static const MAP_SZ_DWORD c_mapNetworkAccess [] =
        {
            { c_szAfNetwork,        TRUE    },
            { c_szAfThisComputer,   FALSE   },
        };

        // Read the IP values.
        //
        m_dataSrvIp.fEnableIn =
            (m_dwDialInProtocolIds & RPI_IP) ? TRUE : FALSE;

        hr = inf.HrGetStringMapToDword (strSection.c_str(),
                                        c_szAfTcpipClientAccess,
                                        c_mapNetworkAccess,
                                        celems (c_mapNetworkAccess),
                                        (DWORD*)&m_dataSrvIp.fAllowNetworkAccess);
        if (FAILED(hr))
        {
            m_dataSrvIp.fAllowNetworkAccess = defSrvIp.fAllowNetworkAccess;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfUseDhcp,
                                    &m_dataSrvIp.fUseDhcp);
        if (FAILED(hr))
        {
            m_dataSrvIp.fUseDhcp = defSrvIp.fUseDhcp;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfClientCanReqIpaddr,
                                    &m_dataSrvIp.fAllowClientAddr);
        if (FAILED(hr))
        {
            m_dataSrvIp.fAllowClientAddr = defSrvIp.fAllowClientAddr;
        }

        tstring strIpAddress;
        hr = inf.HrGetString (strSection.c_str(),
                             c_szAfIpAddressStart,
                             &strIpAddress);
        if (SUCCEEDED(hr))
        {
            m_dataSrvIp.dwIpStart = IpPszToHostAddr(strIpAddress.c_str());
        }
        else
        {
            m_dataSrvIp.dwIpStart = defSrvIp.dwIpStart;
        }

        hr = inf.HrGetString (strSection.c_str(),
                             c_szAfIpAddressEnd,
                             &strIpAddress);
        if (SUCCEEDED(hr))
        {
            m_dataSrvIp.dwIpEnd = IpPszToHostAddr(strIpAddress.c_str());
        }
        else
        {
            m_dataSrvIp.dwIpEnd = defSrvIp.dwIpEnd;
        }


        // Read the IPX values.
        //
        m_dataSrvIpx.fEnableIn =
            (m_dwDialInProtocolIds & RPI_IPX) ? TRUE : FALSE;

        hr = inf.HrGetStringMapToDword (strSection.c_str(),
                                        c_szAfIpxClientAccess,
                                        c_mapNetworkAccess,
                                        celems (c_mapNetworkAccess),
                                        (DWORD*)&m_dataSrvIpx.fAllowNetworkAccess);
        if (FAILED(hr))
        {
            m_dataSrvIpx.fAllowNetworkAccess = defSrvIpx.fAllowNetworkAccess;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfAutoNetworkNumbers,
                                    &m_dataSrvIpx.fUseAutoAddr);
        if (FAILED(hr))
        {
            m_dataSrvIpx.fUseAutoAddr = defSrvIpx.fUseAutoAddr;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfSameNetworkNumber,
                                    &m_dataSrvIpx.fUseSameNetNum);
        if (FAILED(hr))
        {
            m_dataSrvIpx.fUseSameNetNum = defSrvIpx.fUseSameNetNum;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfClientReqNodeNumber,
                                    &m_dataSrvIpx.fAllowClientNetNum);
        if (FAILED(hr))
        {
            m_dataSrvIpx.fAllowClientNetNum = defSrvIpx.fAllowClientNetNum;
        }

        hr = inf.HrGetDword (strSection.c_str(),
                             c_szAfNetNumberFrom,
                             &m_dataSrvIpx.dwIpxNetFirst);
        if (FAILED(hr))
        {
            m_dataSrvIpx.dwIpxNetFirst = defSrvIpx.dwIpxNetFirst;
        }

        hr = inf.HrGetDword (strSection.c_str(),
                             c_szAfWanNetPoolSize,
                             &m_dataSrvIpx.dwIpxWanPoolSize);
        if (FAILED(hr))
        {
            m_dataSrvIpx.dwIpxWanPoolSize = defSrvIpx.dwIpxWanPoolSize;
        }

        // Read the NBF values.
        //
        m_dataSrvNbf.fEnableIn =
            (m_dwDialInProtocolIds & RPI_NBF) ? TRUE : FALSE;

        hr = inf.HrGetStringMapToDword (strSection.c_str(),
                                        c_szAfNetbeuiClientAccess,
                                        c_mapNetworkAccess,
                                        celems (c_mapNetworkAccess),
                                        (DWORD*)&m_dataSrvNbf.fAllowNetworkAccess);
        if (FAILED(hr))
        {
            m_dataSrvNbf.fAllowNetworkAccess = defSrvNbf.fAllowNetworkAccess;
        }

        // Default anything bogus.
        //
        m_dataSrvCfg.CheckAndDefault ();
        m_dataSrvIp .CheckAndDefault ();
        m_dataSrvIpx.CheckAndDefault ();
        m_dataSrvNbf.CheckAndDefault ();

        hr = S_OK;
    }
    TraceError ("CRasSrvAnswerFileData::HrOpenAndRead", hr);
    return hr;
}

VOID
CRasSrvAnswerFileData::SaveToRegistry (
    VOID) const
{
    m_dataSrvCfg.SaveToReg();
    m_dataSrvIp .SaveToReg();
    m_dataSrvIpx.SaveToReg();
    m_dataSrvNbf.SaveToReg();
}

//+---------------------------------------------------------------------------
// CL2tpAnswerFileData
//
const DWORD c_MaxMaxVcs       = 1000;
const DWORD c_DefMaxVcs       = 1000;
const DWORD c_MaxEndpoints    = 1000;
const DWORD c_DefEndpoints    = 5;

VOID
CL2tpAnswerFileData::CheckAndDefault ()
{
    if (m_cMaxVcs > c_MaxMaxVcs)
    {
        m_cMaxVcs = c_DefMaxVcs;
    }

    if (m_cEndpoints > c_MaxEndpoints)
    {
        m_cEndpoints = c_DefEndpoints;
    }
}

HRESULT
CL2tpAnswerFileData::HrOpenAndRead (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    ZeroMemory (this, sizeof(*this));

    // Open the answer file.  It will close itself in it's destructor.
    CSetupInfFile inf;
    UINT unErrorLine;

    HRESULT hr = inf.HrOpen (
                    pszAnswerFile, NULL,
                    INF_STYLE_OLDNT | INF_STYLE_WIN4,
                    &unErrorLine);

    if (SUCCEEDED(hr))
    {
        // Read the number of VPNs.
        //
        hr = inf.HrGetDword (pszAnswerSection,
                             c_szAfL2tpMaxVcs,
                             &m_cMaxVcs);
        if (FAILED(hr))
        {
            m_cMaxVcs = c_DefMaxVcs;
        }

        hr = inf.HrGetDword (pszAnswerSection,
                             c_szAfL2tpEndpoints,
                             &m_cEndpoints);
        if (FAILED(hr))
        {
            m_cEndpoints = c_DefEndpoints;
            m_fWriteEndpoints = FALSE;
        }
        else
        {
            m_fWriteEndpoints = TRUE;
        }

        // Default anything bogus.
        //
        CheckAndDefault ();

        hr = S_OK;
    }
    TraceError ("CL2tpAnswerFileData::HrOpenAndRead", hr);
    return hr;
}

VOID
CL2tpAnswerFileData::SaveToRegistry (
    INetCfg* pnc) const
{
    Assert (pnc);

    HKEY hkey;
    HRESULT hr;

    // Update the L2TP miniport's parameter key.
    //
    hr = HrOpenComponentParamKey (
            pnc,
            GUID_DEVCLASS_NET,
            c_szInfId_MS_L2tpMiniport,
            &hkey);

    if (S_OK == hr)
    {
        (VOID) HrRegSetDword (hkey, L"MaxVcs", m_cMaxVcs);

        if (m_fWriteEndpoints)
        {
            (VOID) HrRegSetDword (hkey, L"WanEndpoints", m_cEndpoints);
        }

        RegCloseKey (hkey);
    }
}


//+---------------------------------------------------------------------------
// CPptpAnswerFileData
//

// Minimum and maximum number of Virtual Private Networks
// allowed by PPTP.
const DWORD c_cPptpVpnsMin = 0;
const DWORD c_cPptpVpnsMax = 1000;

static const DWORD c_cDefPptpVpnsWorkstation = 2;
static const DWORD c_cDefPptpVpnsServer      = 5;


DWORD
CPptpAnswerFileData::GetDefaultNumberOfVpns ()
{
    PRODUCT_FLAVOR pf;
    GetProductFlavor(NULL, &pf);

    DWORD cVpns;

    // On the server product, default to 5 VPNs, otherwise, default to 2 VPNs.
    //
    if (PF_SERVER == pf)
    {
        cVpns = c_cDefPptpVpnsServer;
    }
    else
    {
        cVpns = c_cDefPptpVpnsWorkstation;
    }

    return cVpns;
}

#pragma warning(push)
#pragma warning(disable:4296)
VOID
CPptpAnswerFileData::CheckAndDefault ()
{
    if ((m_cVpns < c_cPptpVpnsMin) || (m_cVpns > c_cPptpVpnsMax))
    {
        m_cVpns = GetDefaultNumberOfVpns ();
    }
}
#pragma warning(pop)

HRESULT
CPptpAnswerFileData::HrOpenAndRead (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    ZeroMemory (this, sizeof(*this));

    // Open the answer file.  It will close itself in it's destructor.
    CSetupInfFile inf;
    UINT unErrorLine;

    HRESULT hr = inf.HrOpen (
                    pszAnswerFile, NULL,
                    INF_STYLE_OLDNT | INF_STYLE_WIN4,
                    &unErrorLine);

    if (SUCCEEDED(hr))
    {
        // Read the number of VPNs.
        //
        hr = inf.HrGetDword (pszAnswerSection,
                             c_szAfPptpEndpoints,
                             &m_cVpns);
        if (FAILED(hr))
        {
            m_cVpns = GetDefaultNumberOfVpns ();
        }

        // Default anything bogus.
        //
        CheckAndDefault ();

        hr = S_OK;
    }
    TraceError ("CPptpAnswerFileData::HrOpenAndRead", hr);
    return hr;
}

VOID
CPptpAnswerFileData::SaveToRegistry (
    INetCfg* pnc) const
{
    Assert (pnc);

    HKEY hkey;
    HRESULT hr;

    // Update the PPTP miniport's parameter key.
    //
    hr = HrOpenComponentParamKey (
            pnc,
            GUID_DEVCLASS_NET,
            c_szInfId_MS_PptpMiniport,
            &hkey);

    if (S_OK == hr)
    {
        (VOID) HrRegSetDword (hkey, L"WanEndpoints", m_cVpns);

        RegCloseKey (hkey);
    }
}


VOID
CPppoeAnswerFileData::CheckAndDefault ()
{
    m_cVpns = 1;
}

HRESULT
CPppoeAnswerFileData::HrOpenAndRead (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    ZeroMemory (this, sizeof(*this));

    // Open the answer file.  It will close itself in it's destructor.
    CSetupInfFile inf;
    UINT unErrorLine;

    HRESULT hr = inf.HrOpen (
                    pszAnswerFile, NULL,
                    INF_STYLE_OLDNT | INF_STYLE_WIN4,
                    &unErrorLine);

    if (SUCCEEDED(hr))
    {
        // Read the number of VPNs.
        //
        hr = inf.HrGetDword (pszAnswerSection,
                             c_szAfL2tpEndpoints,
                             &m_cVpns);
        if (FAILED(hr))
        {
            m_cVpns = 1;
        }

        // Default anything bogus.
        //
        CheckAndDefault ();

        hr = S_OK;
    }
    TraceError ("CPppoeAnswerFileData::HrOpenAndRead", hr);
    return hr;
}

VOID
CPppoeAnswerFileData::SaveToRegistry (
    INetCfg* pnc) const
{
    Assert (pnc);

    HKEY hkey;
    HRESULT hr;

    // Update the PPTP miniport's parameter key.
    //
    hr = HrOpenComponentParamKey (
            pnc,
            GUID_DEVCLASS_NET,
            c_szInfId_MS_PppoeMiniport,
            &hkey);

    if (S_OK == hr)
    {
        (VOID) HrRegSetDword (hkey, L"WanEndpoints", m_cVpns);

        RegCloseKey (hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\ndiswan.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       N D I S W A N . C P P
//
//  Contents:   Implementation of NdisWan configuration object.
//
//  Notes:
//
//  Author:     shaunco   28 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ndiswan.h"
#include "ncreg.h"
#include "mprerror.h"
#include "rtutils.h"

extern const WCHAR c_szInfId_MS_AppleTalk[];
extern const WCHAR c_szInfId_MS_L2TP[];
extern const WCHAR c_szInfId_MS_L2tpMiniport[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_NdisWanAtalk[];
extern const WCHAR c_szInfId_MS_NdisWanBh[];
extern const WCHAR c_szInfId_MS_NdisWanIp[];
extern const WCHAR c_szInfId_MS_NdisWanIpx[];
extern const WCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const WCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const WCHAR c_szInfId_MS_NetBEUI[];
extern const WCHAR c_szInfId_MS_NetMon[];
extern const WCHAR c_szInfId_MS_PPTP[];
extern const WCHAR c_szInfId_MS_PptpMiniport[];
extern const WCHAR c_szInfId_MS_RasMan[];
extern const WCHAR c_szInfId_MS_TCPIP[];
extern const WCHAR c_szInfId_MS_PPPOE[];
extern const WCHAR c_szInfId_MS_PppoeMiniport[];

extern const WCHAR c_szRegValWanEndpoints[]    = L"WanEndpoints";
static const WCHAR c_szRegValMinWanEndpoints[] = L"MinWanEndpoints";
static const WCHAR c_szRegValMaxWanEndpoints[] = L"MaxWanEndpoints";

//$ TODO (shaunco) 3 Feb 1998: rasman has no notify object so just
// merge its services into ndiswan's and eliminate c_apguidInstalledOboNdiswan

//----------------------------------------------------------------------------
// Data used for installing other components.
//
static const GUID* c_apguidInstalledOboNdiswan [] =
{
    &GUID_DEVCLASS_NETSERVICE,  // RasMan
};

static const PCWSTR c_apszInstalledOboNdiswan [] =
{
    c_szInfId_MS_RasMan,
};


static const GUID* c_apguidInstalledOboUser [] =
{
    &GUID_DEVCLASS_NETTRANS,    // L2TP
    &GUID_DEVCLASS_NETTRANS,    // PPTP
    &GUID_DEVCLASS_NETTRANS,    // PPPOE
};

static const PCWSTR c_apszInstalledOboUser [] =
{
    c_szInfId_MS_L2TP,
    c_szInfId_MS_PPTP,
    c_szInfId_MS_PPPOE,
};


CNdisWan::CNdisWan () : CRasBindObject ()
{
    m_fInstalling        = FALSE;
    m_fRemoving          = FALSE;
    m_pnccMe             = NULL;
}

CNdisWan::~CNdisWan ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CNdisWan::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    //
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    m_fInstalling = fInstalling;

    return S_OK;
}

STDMETHODIMP
CNdisWan::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::ApplyRegistryChanges ()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CNdisWan::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install rasman.
    //
    hr = HrInstallComponentsOboComponent (m_pnc, NULL,
            celems (c_apguidInstalledOboNdiswan),
            c_apguidInstalledOboNdiswan,
            c_apszInstalledOboNdiswan,
            m_pnccMe);

//$ TODO (shaunco) 28 Dec 1997: Install L2TP, PPTP, PPPOE obo ndiswan.
//  But, this creates an upgrade problem.

    if (SUCCEEDED(hr))
    {
        hr = HrInstallComponentsOboUser (m_pnc, NULL,
                celems (c_apguidInstalledOboUser),
                c_apguidInstalledOboUser,
                c_apszInstalledOboUser);
    }

    if (SUCCEEDED(hr))
    {
        hr = HrAddOrRemovePti (ARA_ADD);
    }

    if (SUCCEEDED(hr))
    {
        hr = HrFindOtherComponents ();
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr) && PnccAtalk())
            {
                hr = HrAddOrRemoveAtalkInOut (ARA_ADD);
            }

            if (SUCCEEDED(hr) && PnccIp())
            {
                hr = HrAddOrRemoveIpAdapter (ARA_ADD);
            }

            if (SUCCEEDED(hr) && PnccIpx())
            {
                hr = HrAddOrRemoveIpxInOut (ARA_ADD);
            }

            if (SUCCEEDED(hr) && PnccNetMon())
            {
                hr = HrAddOrRemoveNetMonInOut (ARA_ADD);
            }

            ReleaseOtherComponents ();
        }
    }

    // Recompute (and adjust if needed) the number of ndiswan miniports.
    //
    hr = HrProcessEndpointChange ();
    TraceError ("CNdisWan::Install: HrProcessEndpointChange failed. "
        "(not propagating error)", hr);

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if ((NSF_WINNT_WKS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SBS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SVR_UPGRADE & dwSetupFlags))
    {
        HKEY    hkeyMd5;

        if (SUCCEEDED(HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\Rasman\\PPP\\CHAP\\MD5",
            KEY_READ, &hkeyMd5)))
        {
            HANDLE  hLog;

            // MD5 key was found. Need to log something to the eventlog.
            hLog = RouterLogRegister(L"RemoteAccess");
            if (hLog)
            {
                RouterLogWarning(hLog, WARNING_NO_MD5_MIGRATION, 0,
                                 NULL, NO_ERROR);

                RouterLogDeregister(hLog);
            }

            RegCloseKey (hkeyMd5);
        }
    }

    //  Check to see if Connection Manager is installed and
    //  if there are any profiles to migrate.  We do this
    //  by opening the CM mappings key and checking to see if it contains any
    //  values.  and if so then write a run-once setup key so that
    //  we can migrate profiles when the user logs in for the first time.
    //  Note that this only works for NT to NT upgrades.  The win9x registry
    //  hasn't been filled in by the time that this runs.  Thus our win9x
    //  migration dll (cmmgr\migration.dll) takes care of the win9x case.
    //

    static const WCHAR c_CmdString[] = L"cmstp.exe /m";
    static const WCHAR c_ValueString[] = L"Connection Manager Profiles Upgrade";
    static const WCHAR c_szRegCmMappings[] = L"SOFTWARE\\Microsoft\\Connection Manager\\Mappings";
    static const WCHAR c_szRegRunKey[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    static const WCHAR c_szRegCmUninstallKey[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Connection Manager";

    static const WCHAR c_szRegSysCompValue[] = L"SystemComponent";

    // dwTemp is used as temp DWORD.  Used as Disposition DWORD for RegCreateKey, and
    // as a value holder for RegSetValueEx
    //
    DWORD dwTemp;

    HKEY hKey;
    HRESULT hrT;

    //  Set the Connection Manager key as a system component.  This will prevent 1.0 installs
    //  from writing this key and having it show up in Add/Remove Programs (the syscomp flags
    //  tells ARP not to display the key).
    //
    hrT = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           c_szRegCmUninstallKey,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKey,
                           &dwTemp);

    if (SUCCEEDED(hrT))
    {
        dwTemp = 1;
        hrT = HrRegSetDword(hKey, c_szRegSysCompValue, dwTemp);
        RegCloseKey(hKey);
    }

    //  Now try to migrate profiles
    //
    hrT = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         c_szRegCmMappings,
                         KEY_READ,
                         &hKey);

    if (SUCCEEDED(hrT))
    {
        dwTemp = 0;
        hrT = HrRegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL,
                                 &dwTemp, NULL, NULL, NULL, NULL);

        if ((SUCCEEDED(hrT)) && (dwTemp > 0))
        {
            //  Then we have mappings values, so we need to migrate them.
            //

            RegCloseKey(hKey);

            hrT = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  c_szRegRunKey,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE | KEY_READ,
                                  NULL,
                                  &hKey,
                                  &dwTemp);

            if (SUCCEEDED(hrT))
            {
                hrT = HrRegSetSz (hKey, c_ValueString, c_CmdString);
                RegCloseKey(hKey);
            }
        }
        else
        {
            RegCloseKey(hKey);
        }
    }

    TraceError ("CNdisWan::Install", hr);
    return hr;
}

STDMETHODIMP
CNdisWan::Removing ()
{
    static const PCWSTR c_apszInfIdRemove [] =
    {
        c_szInfId_MS_L2tpMiniport,
        c_szInfId_MS_NdisWanAtalk,
        c_szInfId_MS_NdisWanBh,
        c_szInfId_MS_NdisWanIp,
        c_szInfId_MS_NdisWanIpx,
        c_szInfId_MS_NdisWanNbfIn,
        c_szInfId_MS_NdisWanNbfOut,
        c_szInfId_MS_PptpMiniport,
        c_szInfId_MS_PtiMiniport,
        c_szInfId_MS_PppoeMiniport,
    };

    m_fRemoving = TRUE;

    HRESULT hr = S_OK;

    // Remove wanarp and rasman.
    //
    HRESULT hrT = HrFindAndRemoveComponentsOboComponent (m_pnc,
                    celems (c_apguidInstalledOboNdiswan),
                    c_apguidInstalledOboNdiswan,
                    c_apszInstalledOboNdiswan,
                    m_pnccMe);

    hr = hrT;

    // Remove L2TP, PPTP and PPPOE on behalf of the user.
    //
    hrT = HrFindAndRemoveComponentsOboUser (m_pnc,
            celems (c_apguidInstalledOboUser),
            c_apguidInstalledOboUser,
            c_apszInstalledOboUser);
    if (SUCCEEDED(hr))
    {
        hr = hrT;
    }

    // Remove all of the adapters we may have created.
    //
    hrT = HrFindAndRemoveAllInstancesOfAdapters (m_pnc,
            celems(c_apszInfIdRemove),
            c_apszInfIdRemove);
    if (SUCCEEDED(hr))
    {
        hr = hrT;
    }

    // Don't return S_FALSE or NETCFG_S_STILL_REFERENCED
    //
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    Validate_INetCfgNotify_Removing_Return (hr);

    TraceError ("CNdisWan::Removing", hr);
    return hr;
}

STDMETHODIMP
CNdisWan::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    HRESULT hr;

    hr= HrInstallComponentsOboUser (m_pnc, NULL,
                    celems (c_apguidInstalledOboUser),
                    c_apguidInstalledOboUser,
                    c_apszInstalledOboUser);
    TraceError ("CNdisWan::Upgrade: HrInstallComponentsOboUser failed. "
        "(not propagating error)", hr);

    HKEY hkeyNew;
    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters",
            KEY_WRITE,
            &hkeyNew);

    if (SUCCEEDED(hr))
    {
        HKEY hkeyCurrent;
        DWORD dwValue;

        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Services\\Rasman\\PPP",
                    KEY_READ,
                    &hkeyCurrent);
        if (SUCCEEDED(hr))
        {
            // Move 'ServerFlags' value to new location.  This is for
            // interim NT5 builds.  This can go away after Beta3 ships.
            //
            hr = HrRegQueryDword (hkeyCurrent, L"ServerFlags", &dwValue);
            if (SUCCEEDED(hr))
            {
                hr = HrRegSetDword (hkeyNew, L"ServerFlags", dwValue);

                (VOID) HrRegDeleteValue (hkeyCurrent, L"ServerFlags");
            }

            RegCloseKey (hkeyCurrent);
        }

        // Copy 'RouterType' value to new location.
        //
        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    L"Software\\Microsoft\\Ras\\Protocols",
                    KEY_READ,
                    &hkeyCurrent);
        if (SUCCEEDED(hr))
        {
            hr = HrRegQueryDword (hkeyCurrent, L"RouterType", &dwValue);
            if (SUCCEEDED(hr))
            {
                hr = HrRegSetDword (hkeyNew, L"RouterType", dwValue);
            }

            RegCloseKey (hkeyCurrent);
        }

        RegCloseKey (hkeyNew);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgSystemNotify
//
STDMETHODIMP
CNdisWan::GetSupportedNotifications (
    DWORD*  pdwNotificationFlag)
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications (pdwNotificationFlag);

    *pdwNotificationFlag = NCN_BINDING_PATH |
                           NCN_NETTRANS | NCN_NETSERVICE |
                           NCN_ADD | NCN_REMOVE;

    return S_OK;
}

STDMETHODIMP
CNdisWan::SysQueryBindingPath (
    DWORD               dwChangeFlag,
    INetCfgBindingPath* pncbp)
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::SysQueryComponent (
    DWORD               dwChangeFlag,
    INetCfgComponent*   pncc)
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::SysNotifyBindingPath (
    DWORD               dwChangeFlag,
    INetCfgBindingPath* pncbp)
{
    HRESULT hr;
    HKEY hkey;

    Validate_INetCfgSystemNotify_SysNotifyBindingPath (dwChangeFlag, pncbp);

    hkey = NULL;

    // ndisatm miniports don't write WanEndpoints to their instance key.
    // We default it and write WanEndpoints for them.
    //
    if (dwChangeFlag & NCN_ADD)
    {
        CIterNetCfgBindingInterface ncbiIter(pncbp);
        INetCfgBindingInterface* pncbi;

        hr = S_OK;

        while (!hkey && SUCCEEDED(hr) &&
               (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            RAS_BINDING_ID RasBindId;

            if (FIsRasBindingInterface (pncbi, &RasBindId) &&
                (RBID_NDISATM == RasBindId))
            {
                INetCfgComponent* pnccLower;

                hr = pncbi->GetLowerComponent (&pnccLower);
                if (SUCCEEDED(hr))
                {
                    TraceTag (ttidRasCfg, "New ATM adapter");
                    hr = pnccLower->OpenParamKey (&hkey);

                    ReleaseObj (pnccLower);
                }
            }
            ReleaseObj(pncbi);
        }
    }

    if (hkey)
    {
        DWORD dwEndpoints;
        DWORD dwValue;

        hr = HrRegQueryDword (hkey, c_szRegValWanEndpoints, &dwEndpoints);
        if (FAILED(hr))
        {
            TraceTag (ttidRasCfg, "Defaulting WanEndpoints");

            dwEndpoints = 5;

            // Validate the default between the min and max
            // specified by the driver (if specified).
            //
            if (SUCCEEDED(HrRegQueryDword (hkey,
                                c_szRegValMaxWanEndpoints,
                                &dwValue)))
            {
                if ((dwValue < INT_MAX) && (dwEndpoints > dwValue))
                {
                    dwEndpoints = dwValue;
                }
            }
            else
            {
                (VOID) HrRegSetDword(hkey, c_szRegValMaxWanEndpoints, 500);
            }

            if (SUCCEEDED(HrRegQueryDword (hkey,
                                c_szRegValMinWanEndpoints,
                                &dwValue)))
            {
                if ((dwValue < INT_MAX) && (dwEndpoints < dwValue))
                {
                    dwEndpoints = dwValue;
                }
            }
            else
            {
                (VOID) HrRegSetDword(hkey, c_szRegValMinWanEndpoints, 0);
            }

            (VOID) HrRegSetDword (hkey, c_szRegValWanEndpoints, dwEndpoints);
        }

        RegCloseKey (hkey);
    }

    return S_FALSE;
}

STDMETHODIMP
CNdisWan::SysNotifyComponent (
    DWORD               dwChangeFlag,
    INetCfgComponent*   pncc)
{
    HRESULT hr = S_OK;

    Validate_INetCfgSystemNotify_SysNotifyComponent (dwChangeFlag, pncc);

    // If a protocol is coming or going, add or remove the
    // ndiswanXXX miniports.
    //
    DWORD dwAraFlags = 0;
    if (dwChangeFlag & NCN_ADD)
    {
        dwAraFlags = ARA_ADD;
    }
    else if (dwChangeFlag & NCN_REMOVE)
    {
        dwAraFlags = ARA_REMOVE;
    }
    if (dwAraFlags)
    {
        BOOL fProcessEndpoingChange = FALSE;

        PWSTR pszId;
        hr = pncc->GetId (&pszId);
        if (SUCCEEDED(hr))
        {
            if (FEqualComponentId (c_szInfId_MS_TCPIP, pszId))
            {
                hr = HrAddOrRemoveIpAdapter (dwAraFlags);
                fProcessEndpoingChange = TRUE;
            }
            else if (FEqualComponentId (c_szInfId_MS_NWIPX, pszId))
            {
                hr = HrAddOrRemoveIpxInOut (dwAraFlags);
            }
            else if (FEqualComponentId (c_szInfId_MS_NetBEUI, pszId))
            {
                fProcessEndpoingChange = TRUE;
            }
            else if (FEqualComponentId (c_szInfId_MS_AppleTalk, pszId))
            {
                hr = HrAddOrRemoveAtalkInOut (dwAraFlags);
            }
            else if (FEqualComponentId (c_szInfId_MS_NetMon, pszId))
            {
                hr = HrAddOrRemoveNetMonInOut (dwAraFlags);
            }

            CoTaskMemFree (pszId);
        }

        if (SUCCEEDED(hr) && fProcessEndpoingChange)
        {
            hr = HrProcessEndpointChange ();
        }
    }

    TraceError ("CNdisWan::SysNotifyComponent", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\rasaf.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S A F . H
//
//  Contents:   RAS Answer File object.
//
//  Notes:
//
//  Author:     shaunco   19 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "rasdata.h"


struct CRasSrvAnswerFileData
{
    HRESULT
    HrOpenAndRead (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection);

    VOID
    SaveToRegistry (
        VOID) const;

    BOOL            m_fRouterTypeSpecified;
    DWORD           m_dwDialInProtocolIds;
    BOOL            m_fSetUsageToDialin;
    DATA_SRV_CFG    m_dataSrvCfg;
    DATA_SRV_IP     m_dataSrvIp;
    DATA_SRV_IPX    m_dataSrvIpx;
    DATA_SRV_NBF    m_dataSrvNbf;
};

struct CL2tpAnswerFileData
{
    VOID
    CheckAndDefault ();

    HRESULT
    HrOpenAndRead (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection);

    VOID
    SaveToRegistry (
        INetCfg* pnc) const;

    DWORD   m_cMaxVcs;
    DWORD   m_cEndpoints;
    BOOL    m_fWriteEndpoints;
};

struct CPptpAnswerFileData
{
    VOID
    CheckAndDefault ();

    DWORD
    GetDefaultNumberOfVpns ();

    HRESULT
    HrOpenAndRead (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection);

    VOID
    SaveToRegistry (
        INetCfg* pnc) const;

    DWORD   m_cVpns;
};

struct CPppoeAnswerFileData
{
    VOID
    CheckAndDefault ();

    HRESULT
    HrOpenAndRead (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection);

    VOID
    SaveToRegistry (
        INetCfg* pnc) const;

    DWORD   m_cVpns;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\rasobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S O B J . H
//
//  Contents:   Declaration of RAS configuration objects.
//
//  Notes:
//
//  Author:     shaunco   21 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include <mprapi.h>
#include "ndiswan.h"
#include "resource.h"
#include "rasaf.h"
#include "rasdata.h"
#include "ncutil.h"


HRESULT
HrModemClassCoInstaller (
    DI_FUNCTION                 dif,
    HDEVINFO                    hdi,
    PSP_DEVINFO_DATA            pdeid,
    PCOINSTALLER_CONTEXT_DATA   pContext);


//+---------------------------------------------------------------------------
// L2TP
//
class ATL_NO_VTABLE CL2tp :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CL2tp, &CLSID_CL2tp>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    CL2tpAnswerFileData m_AfData;
    BOOL                m_fSaveAfData;

public:
    CL2tp  ();
    ~CL2tp ();

    BEGIN_COM_MAP(CL2tp)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_L2TP)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};



//+---------------------------------------------------------------------------
// PPTP
//
class ATL_NO_VTABLE CPptp :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CPptp, &CLSID_CPptp>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    CPptpAnswerFileData m_AfData;
    BOOL                m_fSaveAfData;

public:
    CPptp  ();
    ~CPptp ();

    BEGIN_COM_MAP(CPptp)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_PPTP)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};

//+---------------------------------------------------------------------------
// PPPOE
//
class ATL_NO_VTABLE CPppoe :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CPppoe, &CLSID_CPppoe>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    CPppoeAnswerFileData m_AfData;
    BOOL                m_fSaveAfData;

public:
    CPppoe  ();
    ~CPppoe ();

    BEGIN_COM_MAP(CPppoe)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_PPPOE)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};



//+---------------------------------------------------------------------------
// RAS Client
//
class ATL_NO_VTABLE CRasCli :
    public CComObjectRoot,
    public CComCoClass<CRasCli, &CLSID_CRasCli>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // These are handed to us during INetCfgComponentControl::Initialize.
    INetCfg*            m_pnc;
    INetCfgComponent*   m_pnccMe;

public:
    CRasCli ();
    ~CRasCli ();

    BEGIN_COM_MAP(CRasCli)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_RASCLI)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup

    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};



//+---------------------------------------------------------------------------
// RAS Server
//
class ATL_NO_VTABLE CRasSrv :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CRasSrv, &CLSID_CRasSrv>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    // This is our in-memory state.
    BOOL                    m_fInstalling;
    BOOL                    m_fRemoving;
    BOOL                    m_fNt4ServerUpgrade;
    CRasSrvAnswerFileData   m_AfData;
    BOOL                    m_fSaveAfData;

public:
    CRasSrv  ();
    ~CRasSrv ();

    BEGIN_COM_MAP(CRasSrv)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_RASSRV)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};


//+---------------------------------------------------------------------------
// Steelhead
//
typedef void (WINAPI* PFN_MAKE_INTERFACE_INFO)(PCWSTR pszwAdapterName,
                                               DWORD   dwPacketType,
                                               LPBYTE* ppb);
typedef void (WINAPI* PFN_MAKE_TRANSPORT_INFO)(LPBYTE* ppbGlobal,
                                               LPBYTE* ppbClient);

struct ROUTER_MANAGER_INFO
{
    DWORD                   dwTransportId;
    DWORD                   dwPacketType;
    PCWSTR                 pszwTransportName;
    PCWSTR                 pszwDllPath;
    PFN_MAKE_INTERFACE_INFO pfnMakeInterfaceInfo;
    PFN_MAKE_TRANSPORT_INFO pfnMakeTransportInfo;
};

class ATL_NO_VTABLE CSteelhead :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CSteelhead, &CLSID_CSteelhead>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    HANDLE              m_hMprConfig;
    HANDLE              m_hMprAdmin;
    BOOL                m_fRemoving;
    BOOL                m_fUpdateRouterConfiguration;

    BOOL    FAdapterExistsWithMatchingBindName  (PCWSTR pszwAdapterName,
                                                 INetCfgComponent** ppnccAdapter);
    BOOL    FIpxFrameTypeInUseOnAdapter         (DWORD dwwFrameType,
                                                 PCWSTR pszwAdapterName);
    BOOL    FIpxFrameTypeInUseOnAdapter         (PCWSTR pszwFrameType,
                                                 PCWSTR pszwAdapterName);

    HRESULT HrEnsureRouterInterfaceForAdapter   (ROUTER_INTERFACE_TYPE dwIfType,
                                                 DWORD dwPacketType,
                                                 PCWSTR pszwAdapterName,
                                                 PCWSTR pszwInterfaceName,
                                                 const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureIpxRouterInterfacesForAdapter   (PCWSTR pszwAdapterName);
    HRESULT HrEnsureRouterInterface             (ROUTER_INTERFACE_TYPE dwIfType,
                                                 PCWSTR pszwInterfaceName,
                                                 HANDLE* phConfigInterface,
                                                 HANDLE* phAdminInterface);
    HRESULT HrEnsureRouterInterfaceTransport    (PCWSTR pszwAdapterName,
                                                 DWORD dwPacketType,
                                                 HANDLE hConfigInterface,
                                                 HANDLE hAdminInterface,
                                                 const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureRouterManager               (const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureRouterManagerDeleted        (const ROUTER_MANAGER_INFO& rmi);

    HRESULT HrPassToAddInterfaces               ();
    HRESULT HrPassToRemoveInterfaces            (BOOL fFromRunningRouter);
    HRESULT HrPassToRemoveInterfaceTransports   (MPR_INTERFACE_0* pri0,
                                                 PCWSTR pszwAdapterName,
                                                 INetCfgComponent* pnccAdapter);

    HRESULT HrUpdateRouterConfiguration         ();

public:
    CSteelhead  ();
    ~CSteelhead ();

    BEGIN_COM_MAP(CSteelhead)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_STEELHEAD)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\rascli.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S C L I . C P P
//
//  Contents:   Implementation of RAS Client configuration object.
//
//  Notes:
//
//  Author:     shaunco   21 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncmisc.h"
#include "rasobj.h"

extern const WCHAR c_szInfId_MS_NdisWan[];

CRasCli::CRasCli ()
{
    m_pnc       = NULL;
    m_pnccMe    = NULL;
}

CRasCli::~CRasCli ()
{
    ReleaseObj (m_pnc);
    ReleaseObj (m_pnccMe);
}

//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CRasCli::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    return S_OK;
}

STDMETHODIMP
CRasCli::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CRasCli::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CRasCli::ApplyRegistryChanges ()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CRasCli::ReadAnswerFile (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP
CRasCli::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install(dwSetupFlags);

    // Install NdisWan.
    //
    hr = HrInstallComponentOboComponent (m_pnc, NULL,
            GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NdisWan,
            m_pnccMe,
            NULL);

    TraceHr (ttidError, FAL, hr, FALSE, "CRasCli::Install");
    return hr;
}

STDMETHODIMP
CRasCli::Removing ()
{
    HRESULT hr;

    // Remove NdisWan.
    //
    hr = HrRemoveComponentOboComponent (m_pnc,
            GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NdisWan,
            m_pnccMe);

    TraceHr (ttidError, FAL, hr, FALSE, "CRasCli::Removing");
    return hr;
}

STDMETHODIMP
CRasCli::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\router.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R O U T E R . C P P
//
//  Contents:   Implementation of functions used to setup the router.
//
//  Notes:
//
//  Author:     shaunco   13 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <fltdefs.h>    // must include for iprtinfo.h
#include <ipinfoid.h>
#include <iprtinfo.h>
#include <iprtrmib.h>
#include <ipxrtdef.h>
#include <mprerror.h>
#include <tdi.h>        // must include for isnkrnl.h
#include <isnkrnl.h>
#include <rtinfo.h>
#include <routprot.h>
#include "router.h"


#define PAD8(_p)    (((ULONG_PTR)(_p) + ALIGN_SHIFT) & ALIGN_MASK)


//+---------------------------------------------------------------------------
//
//  Function:   MakeIpInterfaceInfo
//
//  Purpose:    Create the router interface block for IP.
//
//  Arguments:
//      pszwAdapterName [in]    The adapter name
//      dwPacketType    [in]    The packet type
//      ppBuff          [out]   Pointer to the returned info.
//                              Free with delete.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpInterfaceInfo (
        PCWSTR pszwAdapterName,
        DWORD   dwPacketType,
        LPBYTE* ppBuff)
{
    UNREFERENCED_PARAMETER (pszwAdapterName);
    UNREFERENCED_PARAMETER (dwPacketType);
    Assert (ppBuff);

    const int c_cTocEntries = 3;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof( INTERFACE_STATUS_INFO )
                    + sizeof( RTR_DISC_INFO )
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) MemAlloc(dwSize);
    if (!pIBH)
    {
        *ppBuff = NULL;
        return;
    }

    ZeroMemory (pIBH, dwSize);
    *ppBuff                     = (LPBYTE) pIBH;

    // Initialize infobase fields.
    //
    pIBH->Version               = RTR_INFO_BLOCK_VERSION;
    pIBH->Size                  = dwSize;
    pIBH->TocEntriesCount       = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH-> TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Create empty route info block
    //
    pTocEntry->InfoType         = IP_ROUTE_INFO;
    pTocEntry->InfoSize         = sizeof( MIB_IPFORWARDROW );
    pTocEntry->Count            = 0;
    pTocEntry->Offset           = pbDataPtr - (LPBYTE)pIBH;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Create interface status block.
    //
    pTocEntry->InfoType         = IP_INTERFACE_STATUS_INFO;
    pTocEntry->InfoSize         = sizeof( INTERFACE_STATUS_INFO );
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (LPBYTE)pIBH;

    PINTERFACE_STATUS_INFO pifStat = (PINTERFACE_STATUS_INFO)pbDataPtr;
    pifStat->dwAdminStatus      = MIB_IF_ADMIN_STATUS_UP;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Create Router Disc. Info.
    //
    pTocEntry->InfoType         = IP_ROUTER_DISC_INFO;
    pTocEntry->InfoSize         = sizeof( RTR_DISC_INFO );
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (LPBYTE)pIBH;

    PRTR_DISC_INFO pRtrDisc     = (PRTR_DISC_INFO)pbDataPtr;
    pRtrDisc->bAdvertise        = FALSE;
    pRtrDisc->wMaxAdvtInterval  = DEFAULT_MAX_ADVT_INTERVAL;
    pRtrDisc->wMinAdvtInterval  = DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL;
    pRtrDisc->wAdvtLifetime     = DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL;
    pRtrDisc->lPrefLevel        = DEFAULT_PREF_LEVEL;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpTransportInfo
//
//  Purpose:    Create the router transport blocks for IP.  Free with delete.
//
//  Arguments:
//      ppBuffGlobal [out]  Pointer to the returned global block.
//      ppBuffClient [out]  Pointer to the returned client block.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpTransportInfo (LPBYTE* ppBuffGlobal, LPBYTE* ppBuffClient)
{
    Assert (ppBuffGlobal);
    Assert (ppBuffClient);

    *ppBuffClient = NULL;

    const int c_cTocEntries = 2;
    const int c_cProtocols  = 7;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(GLOBAL_INFO)
                    + SIZEOF_PRIORITY_INFO(c_cProtocols)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) MemAlloc(dwSize);
    if (!pIBH)
    {
        *ppBuffGlobal = NULL;
        return;
    }

    ZeroMemory (pIBH, dwSize);
    *ppBuffGlobal = (LPBYTE) pIBH;

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IP router manager global info.
    //
    pTocEntry->InfoType         = IP_GLOBAL_INFO;
    pTocEntry->InfoSize         = sizeof(GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PGLOBAL_INFO pGlbInfo       = (PGLOBAL_INFO) pbDataPtr;
    pGlbInfo->bFilteringOn      = FALSE;
    pGlbInfo->dwLoggingLevel    = IPRTR_LOGGING_ERROR;

    pbDataPtr += pTocEntry->Count * pTocEntry-> InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make IP router manager priority info.
    //
    pTocEntry->InfoType         = IP_PROT_PRIORITY_INFO;
    pTocEntry->InfoSize         = SIZEOF_PRIORITY_INFO(c_cProtocols);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PPRIORITY_INFO pPriorInfo   = (PPRIORITY_INFO) pbDataPtr;
    pPriorInfo->dwNumProtocols  = c_cProtocols;

    pPriorInfo->ppmProtocolMetric[ 0 ].dwProtocolId   = PROTO_IP_LOCAL;
    pPriorInfo->ppmProtocolMetric[ 0 ].dwMetric       = 1;

    pPriorInfo->ppmProtocolMetric[ 1 ].dwProtocolId   = PROTO_IP_NETMGMT;
    pPriorInfo->ppmProtocolMetric[ 1 ].dwMetric       = 10;

    pPriorInfo->ppmProtocolMetric[ 2 ].dwProtocolId   = PROTO_IP_NT_STATIC;
    pPriorInfo->ppmProtocolMetric[ 2 ].dwMetric       = 3;

    pPriorInfo->ppmProtocolMetric[ 3 ].dwProtocolId   = PROTO_IP_NT_STATIC_NON_DOD;
    pPriorInfo->ppmProtocolMetric[ 3 ].dwMetric       = 5;

    pPriorInfo->ppmProtocolMetric[ 4 ].dwProtocolId   = PROTO_IP_NT_AUTOSTATIC;
    pPriorInfo->ppmProtocolMetric[ 4 ].dwMetric       = 7;

    pPriorInfo->ppmProtocolMetric[ 5 ].dwProtocolId   = PROTO_IP_OSPF;
    pPriorInfo->ppmProtocolMetric[ 5 ].dwMetric       = 110;

    pPriorInfo->ppmProtocolMetric[ 6 ].dwProtocolId   = PROTO_IP_RIP;
    pPriorInfo->ppmProtocolMetric[ 6 ].dwMetric       = 120;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpxInterfaceInfo
//
//  Purpose:    Create the router interface block for IPX.
//
//  Arguments:
//      pszwAdapterName [in]    The adapter name
//      dwPacketType    [in]    The packet type
//      ppBuff          [out]   Pointer to the returned info.
//                              Free with delete.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpxInterfaceInfo (
        PCWSTR pszwAdapterName,
        DWORD   dwPacketType,
        LPBYTE* ppBuff)
{
    Assert (ppBuff);

    const BOOL fDialInInterface = (NULL == pszwAdapterName);

    const int c_cTocEntries = 5;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(IPX_IF_INFO)
                    + sizeof(IPX_ADAPTER_INFO)
                    + sizeof(IPXWAN_IF_INFO)
                    + sizeof(RIP_IF_CONFIG)
                    + sizeof(SAP_IF_CONFIG)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) MemAlloc(dwSize);
    if (!pIBH)
    {
        *ppBuff = NULL;
        return;
    }

    ZeroMemory (pIBH, dwSize);
    *ppBuff = (LPBYTE) pIBH;

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IPX router manager interface info.
    //
    pTocEntry->InfoType         = IPX_INTERFACE_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_IF_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PIPX_IF_INFO pIfInfo        = (PIPX_IF_INFO) pbDataPtr;
    pIfInfo->AdminState         = ADMIN_STATE_ENABLED;
    pIfInfo->NetbiosAccept      = ADMIN_STATE_ENABLED;
    pIfInfo->NetbiosDeliver     = (fDialInInterface) ? ADMIN_STATE_DISABLED
                                                     : ADMIN_STATE_ENABLED;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make adapter info.
    //
    pTocEntry->InfoType         = IPX_ADAPTER_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_ADAPTER_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PIPX_ADAPTER_INFO pAdInfo   = (PIPX_ADAPTER_INFO) pbDataPtr;
    if (ISN_FRAME_TYPE_AUTO == dwPacketType)
    {
        dwPacketType = AUTO_DETECT_PACKET_TYPE;
    }
    pAdInfo->PacketType         = dwPacketType;
    if (pszwAdapterName)
    {
        AssertSz (lstrlen (pszwAdapterName) < celems (pAdInfo->AdapterName),
                  "Bindname too big for pAdInfo->AdapterName buffer.");
        lstrcpyW (pAdInfo->AdapterName, pszwAdapterName);
    }
    else
    {
        AssertSz (0 == pAdInfo->AdapterName[0],
                    "Who removed the ZeroMemory call above?");
    }

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make wan info.
    //
    pTocEntry->InfoType         = IPXWAN_INTERFACE_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPXWAN_IF_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PIPXWAN_IF_INFO pWanInfo    = (PIPXWAN_IF_INFO) pbDataPtr;
    pWanInfo->AdminState        = ADMIN_STATE_DISABLED;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make RIP interface info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_RIP;
    pTocEntry->InfoSize         = sizeof(RIP_IF_CONFIG);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PRIP_IF_CONFIG pRipInfo     = (PRIP_IF_CONFIG) pbDataPtr;
    pRipInfo->RipIfInfo.AdminState              = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.UpdateMode              = (fDialInInterface)
                                                    ? IPX_NO_UPDATE
                                                    : IPX_STANDARD_UPDATE;
    pRipInfo->RipIfInfo.PacketType              = IPX_STANDARD_PACKET_TYPE;
    pRipInfo->RipIfInfo.Supply                  = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.Listen                  = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.PeriodicUpdateInterval  = 60;
    pRipInfo->RipIfInfo.AgeIntervalMultiplier   = 3;
    pRipInfo->RipIfFilters.SupplyFilterAction   = IPX_ROUTE_FILTER_DENY;
    pRipInfo->RipIfFilters.SupplyFilterCount    = 0;
    pRipInfo->RipIfFilters.ListenFilterAction   = IPX_ROUTE_FILTER_DENY;
    pRipInfo->RipIfFilters.ListenFilterCount    = 0;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make SAP interface info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_SAP;
    pTocEntry->InfoSize         = sizeof(SAP_IF_CONFIG);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PSAP_IF_CONFIG pSapInfo     = (PSAP_IF_CONFIG) pbDataPtr;
    pSapInfo->SapIfInfo.AdminState              = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.UpdateMode              = (fDialInInterface)
                                                    ? IPX_NO_UPDATE
                                                    : IPX_STANDARD_UPDATE;
    pSapInfo->SapIfInfo.PacketType              = IPX_STANDARD_PACKET_TYPE;
    pSapInfo->SapIfInfo.Supply                  = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.Listen                  = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.GetNearestServerReply   = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.PeriodicUpdateInterval  = 60;
    pSapInfo->SapIfInfo.AgeIntervalMultiplier   = 3;
    pSapInfo->SapIfFilters.SupplyFilterAction   = IPX_SERVICE_FILTER_DENY;
    pSapInfo->SapIfFilters.SupplyFilterCount    = 0;
    pSapInfo->SapIfFilters.ListenFilterAction   = IPX_SERVICE_FILTER_DENY;
    pSapInfo->SapIfFilters.ListenFilterCount    = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpxTransportInfo
//
//  Purpose:    Create the router transport blocks for IPX.  Free with delete.
//
//  Arguments:
//      ppBuffGlobal [out]  Pointer to the returned global block.
//      ppBuffClient [out]  Pointer to the returned client block.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpxTransportInfo (LPBYTE* ppBuffGlobal, LPBYTE* ppBuffClient)
{
    Assert (ppBuffGlobal);
    Assert (ppBuffClient);

    MakeIpxInterfaceInfo (NULL, ISN_FRAME_TYPE_AUTO, ppBuffClient);

    const int c_cTocEntries = 3;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(IPX_GLOBAL_INFO)
                    + sizeof(RIP_GLOBAL_INFO)
                    + sizeof(SAP_GLOBAL_INFO)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) MemAlloc(dwSize);
    if (!pIBH)
    {
        *ppBuffGlobal = NULL;
        return;
    }

    ZeroMemory (pIBH, dwSize);
    *ppBuffGlobal = (LPBYTE) pIBH;

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IPX router manager global info.
    //
    pTocEntry->InfoType         = IPX_GLOBAL_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PIPX_GLOBAL_INFO pGlbInfo       = (PIPX_GLOBAL_INFO) pbDataPtr;
    pGlbInfo->RoutingTableHashSize  = IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE;
    pGlbInfo->EventLogMask          = EVENTLOG_ERROR_TYPE;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make RIP global info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_RIP;
    pTocEntry->InfoSize         = sizeof(RIP_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PRIP_GLOBAL_INFO pRipInfo   = (PRIP_GLOBAL_INFO) pbDataPtr;
    pRipInfo->EventLogMask      = EVENTLOG_ERROR_TYPE;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make SAP global info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_SAP;
    pTocEntry->InfoSize         = sizeof(SAP_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = pbDataPtr - (PBYTE)pIBH;

    PSAP_GLOBAL_INFO pSapInfo   = (PSAP_GLOBAL_INFO) pbDataPtr;
    pSapInfo->EventLogMask      = EVENTLOG_ERROR_TYPE;
}



//+---------------------------------------------------------------------------
//
// mprapi.h wrappers to return HRESULTs and obey rules of COM in regard
// to output parameters.
//
HRESULT
HrMprAdminServerConnect(
    IN      PWSTR                  lpwsServerName      OPTIONAL,
    OUT     MPR_SERVER_HANDLE *     phMprServer
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminServerConnect (lpwsServerName, phMprServer);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phMprServer = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) == hr),
        "HrMprAdminServerConnect");
    return hr;
}

HRESULT
HrMprAdminInterfaceCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE *                phInterface
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceCreate (hMprServer,
                    dwLevel, lpbBuffer, phInterface);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phInterface = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprAdminInterfaceCreate");
    return hr;
}

HRESULT
HrMprAdminInterfaceEnum(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle        OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceEnum (hMprServer, dwLevel, lplpbBuffer,
                    dwPrefMaxLen, lpdwEntriesRead,
                    lpdwTotalEntries, lpdwResumeHandle);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *lpdwEntriesRead = 0;
        *lpdwTotalEntries = 0;
    }
    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_INVALID_BINDING) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) == hr),
        "HrMprAdminInterfaceEnum");
    return hr;
}

HRESULT
HrMprAdminInterfaceGetHandle(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      PWSTR                  lpwsInterfaceName,
    OUT     HANDLE *                phInterface,
    IN      BOOL                    fIncludeClientInterfaces
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceGetHandle (hMprServer, lpwsInterfaceName,
                    phInterface, fIncludeClientInterfaces);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phInterface = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_INVALID_BINDING) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) == hr),
        "HrMprAdminInterfaceGetHandle");
    return hr;
}

HRESULT
HrMprAdminInterfaceTransportAdd(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceTransportAdd (hMprServer, hInterface,
                    dwTransportId, pInterfaceInfo, dwInterfaceInfoSize);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_INTERFACE_ALREADY_EXISTS) == hr,
        "HrMprAdminInterfaceTransportAdd");
    return hr;
}

HRESULT
HrMprAdminTransportCreate(
    IN      HANDLE                  hMprAdmin,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      PWSTR                  lpwsDLLPath
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminTransportCreate (hMprAdmin, dwTransportId,
                    lpwsTransportName, pGlobalInfo, dwGlobalInfoSize,
                    pClientInterfaceInfo, dwClientInterfaceInfoSize,
                    lpwsDLLPath);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprAdminTransportCreate");
    return hr;
}

HRESULT
HrMprConfigServerConnect(
    IN      PWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigServerConnect (lpwsServerName, phMprConfig);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phMprConfig = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigServerConnect");
    return hr;
}

HRESULT
HrMprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceCreate (hMprConfig, dwLevel, lpbBuffer,
                                         phRouterInterface);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterInterface = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigInterfaceCreate");
    return hr;
}

HRESULT
HrMprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceEnum (hMprConfig, dwLevel, lplpBuffer,
                    dwPrefMaxLen, lpdwEntriesRead,
                    lpdwTotalEntries, lpdwResumeHandle);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *lpdwEntriesRead = 0;
        *lpdwTotalEntries = 0;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr,
        "HrMprConfigInterfaceEnum");
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportEnum (hMprConfig, hRouterInterface,
                    dwLevel, lplpBuffer,
                    dwPrefMaxLen, lpdwEntriesRead,
                    lpdwTotalEntries, lpdwResumeHandle);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *lpdwEntriesRead = 0;
        *lpdwTotalEntries = 0;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr,
        "HrMprConfigInterfaceTransportEnum");
    return hr;
}

HRESULT
HrMprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      PWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceGetHandle (hMprConfig, lpwsInterfaceName,
                                            phRouterInterface);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterInterface = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr,
        "HrMprConfigInterfaceGetHandle");
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportAdd (hMprConfig, hRouterInterface,
                                               dwTransportId, lpwsTransportName,
                                               pInterfaceInfo, dwInterfaceInfoSize,
                                               phRouterIfTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterIfTransport = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigInterfaceTransportAdd");
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportGetHandle (hMprConfig,
                                                     hRouterInterface,
                                                     dwTransportId,
                                                     phRouterIfTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterIfTransport = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr,
        "HrMprConfigInterfaceTransportGetHandle");
    return hr;
}

HRESULT
HrMprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      PWSTR                  lpwsDLLPath,
    OUT     HANDLE*                 phRouterTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportCreate (hMprConfig, dwTransportId,
                    lpwsTransportName, pGlobalInfo, dwGlobalInfoSize,
                    pClientInterfaceInfo, dwClientInterfaceInfoSize,
                    lpwsDLLPath, phRouterTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterTransport = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigTransportCreate");
    return hr;
}

HRESULT
HrMprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportDelete (hMprConfig, hRouterTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigTransportDelete");
    return hr;
}

HRESULT
HrMprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportGetHandle (hMprConfig, dwTransportId,
                                            phRouterTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterTransport = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr,
        "HrMprConfigTransportGetHandle");
    return hr;
}

HRESULT
HrMprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT PWSTR*                 lplpwsDLLPath               OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportGetInfo (hMprConfig, hRouterTransport,
                                          ppGlobalInfo, lpdwGlobalInfoSize,
                                          ppClientInterfaceInfo,
                                          lpdwClientInterfaceInfoSize,
                                          lplpwsDLLPath);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigTransportGetInfo");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sapcfg\resource.h ===
#include <ncres.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\resource.h ===
#include <ncres.h>

#define IDS_RAS_INTERNAL_ADAPTER    (IDS_NC_RASCFG + 0)
#define IDS_RAS_LOOPBACK_ADAPTER    (IDS_NC_RASCFG + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\router.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R O U T E R . H
//
//  Contents:   Declaration of functions used to setup the router.
//
//  Notes:
//
//  Author:     shaunco   12 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once

void WINAPI MakeIpInterfaceInfo     (PCWSTR pszwAdapterName,
                                     DWORD   dwPacketType,
                                     LPBYTE* ppBuff);
void WINAPI MakeIpTransportInfo     (LPBYTE* ppBuffGlobal,
                                     LPBYTE* ppBuffClient);
void WINAPI MakeIpxInterfaceInfo    (PCWSTR pszwAdapterName,
                                     DWORD   dwPacketType,
                                     LPBYTE* ppBuff);
void WINAPI MakeIpxTransportInfo    (LPBYTE* ppBuffGlobal,
                                     LPBYTE* ppBuffClient);

HRESULT
HrMprAdminServerConnect(
    IN      PWSTR                  lpwsServerName      OPTIONAL,
    OUT     MPR_SERVER_HANDLE *     phMprServer
);

HRESULT
HrMprAdminInterfaceGetHandle(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      PWSTR                  lpwsInterfaceName,
    OUT     HANDLE *                phInterface,
    IN      BOOL                    fIncludeClientInterfaces
);

HRESULT
HrMprAdminInterfaceCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE *                phInterface
);

HRESULT
HrMprAdminInterfaceEnum(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle        OPTIONAL
);

HRESULT
HrMprAdminInterfaceTransportAdd(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize
);

HRESULT
HrMprAdminTransportCreate(
    IN      HANDLE                  hMprAdmin,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      PWSTR                  lpwsDLLPath
);


HRESULT
HrMprConfigServerConnect(
    IN      PWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
);

HRESULT
HrMprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
);

HRESULT
HrMprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      PWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
);

HRESULT
HrMprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
);

HRESULT
HrMprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
);

HRESULT
HrMprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
);

HRESULT
HrMprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
);

HRESULT
HrMprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      PWSTR                  lpwsDLLPath,
    OUT     HANDLE*                 phRouterTransport
);

HRESULT
HrMprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport
);

HRESULT
HrMprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
);

HRESULT
HrMprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT PWSTR*                 lplpwsDLLPath               OPTIONAL
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\rasdata.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S D A T A . C P P
//
//  Contents:   Implementation of data structure persistence.
//
//  Notes:
//
//  Author:     shaunco   13 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "bindobj.h"
#include "ncreg.h"
#include "ncutil.h"
#include "rasdata.h"
#include "mprapip.h"

static const BOOL c_fDefAllowNetworkAccess  = TRUE;
static const BOOL c_fDefEnableIn            = TRUE;

//------------------------------------------------------------------------
//
// DATA_SRV_CFG
//

static const BOOL     c_fDefMultilink           = TRUE;
static const DWORD    c_fDefAuthLevel           = 2;
static const DWORD    c_fDefDataEnc             = FALSE;
static const DWORD    c_fDefStrongDataEnc       = FALSE;
static const DWORD    c_fDefSecureVPN           = 0;

// server flags copied from routing\ras\inc\rasppp.h
//
#define PPPCFG_NegotiateSPAP            0x00000040
#define PPPCFG_RequireEncryption        0x00000080
#define PPPCFG_NegotiateMSCHAP          0x00000100
#define PPPCFG_NegotiateMultilink       0x00000400
#define PPPCFG_RequireStrongEncryption  0x00001000
#define PPPCFG_NegotiatePAP             0x00010000
#define PPPCFG_NegotiateMD5CHAP         0x00020000
#define PPPCFG_NegotiateStrongMSCHAP    0x00800000
#define PPPCFG_DisableEncryption        0x00080000

VOID DATA_SRV_CFG::SaveToReg () const
{
    HRESULT hr;
    HKEY    hkey;
    DWORD   dwServerFlags = 0;

    // Save off the router type
    //
    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters",
            KEY_ALL_ACCESS,
            &hkey);
    if (SUCCEEDED(hr))
    {
        (VOID) HrRegSetDword (hkey, L"RouterType", dwRouterType);

        hr = HrRegQueryDword (hkey, L"ServerFlags", &dwServerFlags);
        if (SUCCEEDED(hr))
        {
            if (fMultilink)
            {
                dwServerFlags |= PPPCFG_NegotiateMultilink;
            }
            else
            {
                dwServerFlags &= ~PPPCFG_NegotiateMultilink;
            }

            dwServerFlags &= ~PPPCFG_RequireEncryption;
            dwServerFlags &= ~PPPCFG_RequireStrongEncryption;
            if (fDataEnc)
            {
                dwServerFlags |= PPPCFG_RequireEncryption;
            }
            if (fStrongDataEnc)
            {
                dwServerFlags |= PPPCFG_RequireStrongEncryption;
            }

            if (dwSecureVPN)
            {
                dwServerFlags |= PPPCFG_NegotiateStrongMSCHAP;
                dwServerFlags &= ~PPPCFG_NegotiateSPAP;
                dwServerFlags &= ~PPPCFG_NegotiateMSCHAP;
                dwServerFlags &= ~PPPCFG_NegotiatePAP;
                dwServerFlags &= ~PPPCFG_NegotiateMD5CHAP;
            }
            else
            {
                dwServerFlags |= PPPCFG_NegotiateMSCHAP;
                dwServerFlags |= PPPCFG_NegotiateStrongMSCHAP;
                dwServerFlags &= ~PPPCFG_NegotiateSPAP;
                dwServerFlags &= ~PPPCFG_NegotiatePAP;
                dwServerFlags &= ~PPPCFG_NegotiateMD5CHAP;

                if (dwAuthLevel < 2)
                {
                    dwServerFlags |= PPPCFG_NegotiateSPAP;
                    dwServerFlags |= PPPCFG_NegotiateMD5CHAP;
                }
                if (dwAuthLevel < 1)
                {
                    dwServerFlags |= PPPCFG_NegotiatePAP;
                }
            }

            // pmay: 382389
            //
            // Part of the fix to this should be to clear the disable encryption
            // flag
            //
            dwServerFlags &= ~PPPCFG_DisableEncryption;
       
            (VOID) HrRegSetDword (hkey, L"ServerFlags", dwServerFlags);
        }

        RegCloseKey (hkey);
    }

    // Read in the
}

VOID DATA_SRV_CFG::CheckAndDefault ()
{
    DATA_SRV_CFG def;
    def.GetDefault();

    if (dwRouterType >= RT_INVALID)
    {
        dwRouterType = def.dwRouterType;
    }
}

VOID DATA_SRV_CFG::GetDefault ()
{
    dwRouterType = RT_RAS;
    fMultilink   = c_fDefMultilink;
    dwAuthLevel  = c_fDefAuthLevel;
    fDataEnc     = c_fDefDataEnc;
    fStrongDataEnc = c_fDefStrongDataEnc;
    dwSecureVPN  = c_fDefSecureVPN;
}


//------------------------------------------------------------------------
//
// DATA_SRV_IP
//

static const WCHAR    c_szSubkeySrvIp []        = L"RemoteAccess\\Parameters\\Ip";
static const WCHAR    c_szSubkeySrvIpPool []    = L"RemoteAccess\\Parameters\\Ip\\StaticAddressPool\\0";
static const BOOL     c_fDefUseDhcp             = TRUE;
static const BOOL     c_fDefAllowClientAddr     = FALSE;
static const DWORD    c_dwDefIpAddr             = 0;
static const REGBATCH c_rbDataSrvIp []          =
{
    { HKLM_SVCS, c_szSubkeySrvIp, L"EnableIn",               REG_BOOL, offsetof(DATA_SRV_IP, fEnableIn),           (BYTE*)&c_fDefEnableIn },
    { HKLM_SVCS, c_szSubkeySrvIp, L"AllowNetworkAccess",     REG_BOOL, offsetof(DATA_SRV_IP, fAllowNetworkAccess), (BYTE*)&c_fDefAllowNetworkAccess },
    { HKLM_SVCS, c_szSubkeySrvIp, L"UseDhcpAddressing",      REG_BOOL, offsetof(DATA_SRV_IP, fUseDhcp),            (BYTE*)&c_fDefUseDhcp },
    { HKLM_SVCS, c_szSubkeySrvIp, L"AllowClientIpAddresses", REG_BOOL, offsetof(DATA_SRV_IP, fAllowClientAddr),    (BYTE*)&c_fDefAllowClientAddr },
    { HKLM_SVCS, c_szSubkeySrvIpPool, L"From",               REG_DWORD,offsetof(DATA_SRV_IP, dwIpStart),           (BYTE*)&c_dwDefIpAddr },
    { HKLM_SVCS, c_szSubkeySrvIpPool, L"To",                 REG_DWORD,offsetof(DATA_SRV_IP, dwIpEnd),             (BYTE*)&c_dwDefIpAddr },
};

VOID DATA_SRV_IP::SaveToReg () const
{
    (VOID) HrRegWriteValues (celems(c_rbDataSrvIp), c_rbDataSrvIp,
                             (const BYTE*)this,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
}

VOID DATA_SRV_IP::CheckAndDefault ()
{
}

VOID DATA_SRV_IP::GetDefault ()
{
    fEnableIn           = c_fDefEnableIn;
    fAllowNetworkAccess = c_fDefAllowNetworkAccess;
    fUseDhcp            = c_fDefUseDhcp;
    fAllowClientAddr    = c_fDefAllowClientAddr;
    dwIpStart           = 0;
    dwIpEnd             = 0;
};


//------------------------------------------------------------------------
//
// DATA_SRV_IPX
//

static const WCHAR    c_szSubkeySrvIpx []       = L"RemoteAccess\\Parameters\\Ipx";
static const BOOL     c_fDefUseAutoAddr         = TRUE;
static const BOOL     c_fDefUseSameNetNum       = TRUE;
static const BOOL     c_fDefAllowClientNetNum   = TRUE;
static const DWORD    c_dwDefIpxNetFirst        = 0;
static const DWORD    c_dwDefIpxWanPoolSize     = 1000;
static const REGBATCH c_rbDataSrvIpx   []       =
{
    { HKLM_SVCS, c_szSubkeySrvIpx, L"EnableIn",               REG_BOOL,  offsetof(DATA_SRV_IPX, fEnableIn),           (BYTE*)&c_fDefEnableIn },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"AllowNetworkAccess",     REG_BOOL,  offsetof(DATA_SRV_IPX, fAllowNetworkAccess), (BYTE*)&c_fDefAllowNetworkAccess },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"AutoWanNetAllocation",   REG_BOOL,  offsetof(DATA_SRV_IPX, fUseAutoAddr),        (BYTE*)&c_fDefUseAutoAddr },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"GlobalWanNet",           REG_BOOL,  offsetof(DATA_SRV_IPX, fUseSameNetNum),      (BYTE*)&c_fDefUseSameNetNum },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"AcceptRemoteNodeNumber", REG_BOOL,  offsetof(DATA_SRV_IPX, fAllowClientNetNum),  (BYTE*)&c_fDefAllowClientNetNum },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"FirstWanNet",            REG_DWORD, offsetof(DATA_SRV_IPX, dwIpxNetFirst),       (BYTE*)&c_dwDefIpxNetFirst },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"WanNetPoolSize",         REG_DWORD, offsetof(DATA_SRV_IPX, dwIpxWanPoolSize),        (BYTE*)&c_dwDefIpxWanPoolSize },
};

VOID DATA_SRV_IPX::SaveToReg () const
{
    (VOID) HrRegWriteValues (celems(c_rbDataSrvIpx), c_rbDataSrvIpx,
                             (const BYTE*)this,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
}

VOID DATA_SRV_IPX::CheckAndDefault ()
{
}

VOID DATA_SRV_IPX::GetDefault ()
{
    fEnableIn           = c_fDefEnableIn;
    fAllowNetworkAccess = c_fDefAllowNetworkAccess;
    fUseAutoAddr        = c_fDefUseAutoAddr;
    fUseSameNetNum      = c_fDefUseSameNetNum;
    fAllowClientNetNum  = c_fDefAllowClientNetNum;
    dwIpxNetFirst       = c_dwDefIpxNetFirst;
    dwIpxWanPoolSize    = c_dwDefIpxWanPoolSize;
};

//------------------------------------------------------------------------
//
// DATA_SRV_NBF
//

static const WCHAR    c_szSubkeySrvNbf [] = L"RemoteAccess\\Parameters\\Nbf";
static const REGBATCH c_rbDataSrvNbf   [] =
{
    { HKLM_SVCS, c_szSubkeySrvNbf, L"EnableIn",           REG_BOOL, offsetof(DATA_SRV_NBF, fEnableIn),           (BYTE*)&c_fDefEnableIn },
    { HKLM_SVCS, c_szSubkeySrvNbf, L"AllowNetworkAccess", REG_BOOL, offsetof(DATA_SRV_NBF, fAllowNetworkAccess), (BYTE*)&c_fDefAllowNetworkAccess },
};

VOID DATA_SRV_NBF::SaveToReg () const
{
    (VOID) HrRegWriteValues (celems(c_rbDataSrvNbf), c_rbDataSrvNbf,
                             (const BYTE*)this,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
}

VOID DATA_SRV_NBF::CheckAndDefault ()
{
}

VOID DATA_SRV_NBF::GetDefault ()
{
    fEnableIn           = c_fDefEnableIn;
    fAllowNetworkAccess = c_fDefAllowNetworkAccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\rasdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S D A T A . H
//
//  Contents:   Declaration of data structures used by RAS configuration.
//
//  Notes:
//
//  Author:     shaunco   13 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgx.h"

//+---------------------------------------------------------------------------
// DATA_SRV_CFG
//

enum SRV_ROUTER_TYPE
{
    RT_RAS      = 0x01,
    RT_LAN      = 0x02,
    RT_WAN      = 0x04,
    RT_INVALID  = 0x08
};

struct DATA_SRV_CFG
{
    DWORD   dwRouterType;
    BOOL    fMultilink;
    DWORD   dwAuthLevel;
    BOOL    fDataEnc;
    BOOL    fStrongDataEnc;
    DWORD   dwSecureVPN;

    VOID    SaveToReg       () const;
    VOID    CheckAndDefault ();
    VOID    GetDefault      ();
};


//+---------------------------------------------------------------------------
// DATA_SRV_IP
//

struct DATA_SRV_IP
{
    BOOL    fEnableIn;
    BOOL    fAllowNetworkAccess;
    BOOL    fUseDhcp;
    BOOL    fAllowClientAddr;
    DWORD   dwIpStart;
    DWORD   dwIpEnd;

    VOID    SaveToReg       () const;
    VOID    CheckAndDefault ();
    VOID    GetDefault      ();
};


//+---------------------------------------------------------------------------
// DATA_SRV_IPX
//

struct DATA_SRV_IPX
{
    BOOL    fEnableIn;
    BOOL    fAllowNetworkAccess;
    BOOL    fUseAutoAddr;
    BOOL    fUseSameNetNum;
    BOOL    fAllowClientNetNum;
    DWORD   dwIpxNetFirst;
    DWORD   dwIpxWanPoolSize;

    VOID    SaveToReg       () const;
    VOID    CheckAndDefault ();
    VOID    GetDefault      ();
};


//+---------------------------------------------------------------------------
// DATA_SRV_NBF
//

struct DATA_SRV_NBF
{
    BOOL    fEnableIn;
    BOOL    fAllowNetworkAccess;

    VOID    SaveToReg       () const;
    VOID    CheckAndDefault ();
    VOID    GetDefault      ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\rassrv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S S R V . C P P
//
//  Contents:   Implementation of RAS Server configuration object.
//
//  Notes:
//
//  Author:     shaunco   21 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncreg.h>
#include <mprapip.h>
#include "rasobj.h"
#include "ncnetcfg.h"


extern const WCHAR c_szInfId_MS_Steelhead[];

//+---------------------------------------------------------------------------
// HrMprConfigServerUnattendedInstall
//
// This function dynamically links to the mprsnap.dll and calls the
// utility function for unattended install of RAS/Routing.
//

typedef HRESULT (APIENTRY *PFNMPRINSTALL)(PCWSTR, BOOL);
typedef DWORD (APIENTRY *PFSETPORTUSAGE)(IN DWORD dwUsage);
const WCHAR g_pszNotificationPackages[] = L"Notification Packages";

HRESULT HrMprConfigServerUnattendedInstall(PCWSTR pszServer, BOOL fInstall)
{
    HINSTANCE   hLib = NULL;
    PFNMPRINSTALL   pMprConfigServerUnattendedInstall = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwErr;

    hLib = LoadLibrary(L"mprsnap.dll");
    if (hLib == NULL)
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
    }

    if (SUCCEEDED(hr))
    {
        pMprConfigServerUnattendedInstall = (PFNMPRINSTALL) GetProcAddress(hLib,
            "MprConfigServerUnattendedInstall");
        if (pMprConfigServerUnattendedInstall == NULL)
        {
            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32( dwErr );
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pMprConfigServerUnattendedInstall(pszServer, fInstall);
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    TraceError("HrMprConfigServerUnattendedInstall", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// HrSetUsageOnAllRasPorts
//
// This function dynamically links to rtrupg.dll and calls the
// utility function for setting port usage.
//

HRESULT HrSetUsageOnAllRasPorts(IN DWORD dwUsage)
{
    HINSTANCE   hLib = NULL;
    PFSETPORTUSAGE pSetPortUsage = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwErr;

    hLib = ::LoadLibrary(L"mprapi.dll");
    if (hLib == NULL)
    {
        dwErr = ::GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
    }

    if (SUCCEEDED(hr))
    {
        pSetPortUsage = (PFSETPORTUSAGE) ::GetProcAddress(hLib,
            "MprPortSetUsage");
        if (pSetPortUsage == NULL)
        {
            dwErr = ::GetLastError();
            hr = HRESULT_FROM_WIN32( dwErr );
        }
    }

    if (SUCCEEDED(hr))
        hr = pSetPortUsage(dwUsage);

    if (hLib)
        ::FreeLibrary(hLib);

    TraceError("HrSetUsageOnAllRasPorts", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// HrSetLsaNotificationPackage
//
// Installs the given package as an LSA notification package if it is not
// already installed.
//

HRESULT
HrSetLsaNotificationPackage(
    IN PWCHAR pszPackage)
{
    HRESULT hr = S_OK;
    HKEY hkLsa = NULL;
    DWORD dwErr = NO_ERROR, dwType, dwSize, dwLen, dwTotalLen;
    WCHAR pszPackageList[1024];
    PWCHAR pszCur = NULL;
    BOOL bFound = FALSE;
    
    do
    {
        // Open the Lsa key
        //
        hr = HrRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\Lsa",
                KEY_ALL_ACCESS,
                &hkLsa);
        if (FAILED(hr))
        {
            break;
        }

        // Query the value for the notification packages
        //
        dwType = REG_MULTI_SZ;
        dwSize = sizeof(pszPackageList);
        hr = HrRegQueryValueEx(
                hkLsa,
                g_pszNotificationPackages,
                &dwType,
                (LPBYTE)pszPackageList,
                &dwSize);
        if (FAILED(hr))
        {
            break;
        }

        // See if the given package is already installed
        //
        pszCur = (PWCHAR)pszPackageList;
        dwTotalLen = 0;
        while (*pszCur)
        {
            if (lstrcmpi(pszCur, pszPackage) == 0)
            {
                bFound = TRUE;
            }
            dwLen = (wcslen(pszCur) + 1);
            pszCur += dwLen;
            dwTotalLen += dwLen;
        }

        // If the package isn't already installed, add it.
        //
        if (!bFound)
        {
            dwLen = wcslen(pszPackage) + 1;
            wcscpy(pszCur, pszPackage);
            pszCur[dwLen] = L'\0';
            dwTotalLen += (dwLen + 1);

            hr = HrRegSetValueEx(
                    hkLsa,
                    g_pszNotificationPackages,
                    REG_MULTI_SZ,
                    (CONST BYTE*)pszPackageList,
                    dwTotalLen * sizeof(WCHAR));
            if (FAILED(hr))
            {
                break;
            }
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hkLsa)
        {
            RegCloseKey(hkLsa);
        }
    }

    return hr;
}

CRasSrv::CRasSrv () : CRasBindObject ()
{
    m_pnccMe            = NULL;
    m_fRemoving         = FALSE;
    m_fNt4ServerUpgrade = FALSE;
    m_fSaveAfData       = FALSE;
}

CRasSrv::~CRasSrv ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CRasSrv::Initialize (
        INetCfgComponent*   pncc,
        INetCfg*            pnc,
        BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    m_fInstalling = fInstalling;

    return S_OK;
}

STDMETHODIMP
CRasSrv::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CRasSrv::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CRasSrv::ApplyRegistryChanges ()
{
    if (!m_fRemoving)
    {
        if (m_fSaveAfData)
        {
            m_AfData.SaveToRegistry ();
            m_fSaveAfData = FALSE;

            if (m_AfData.m_fRouterTypeSpecified)
            {
                HRESULT hr = HrMprConfigServerUnattendedInstall(NULL, TRUE);
                TraceError("CRasSrv::ApplyRegistryChanges unattend inst (ignoring)", hr);

                if (m_AfData.m_dataSrvCfg.dwRouterType & 4)
                {
                    hr = HrSetUsageOnAllRasPorts(MPRFLAG_PORT_Router);
                    TraceError("CRasSrv::ApplyRegistryChanges set router usage (ignoring)", hr);
                }
            }

            // pmay: 251736
            //
            // On NTS, we set all usage to dialin
            //
            if (m_fNt4ServerUpgrade)
            {
                HRESULT hr = HrSetUsageOnAllRasPorts(MPRFLAG_PORT_Dialin);
                TraceError("CRasSrv::ApplyRegistryChanges set dialin usage (ignoring)", hr);
            }

            // On professional, we set non-vpn port usage to to dialin if 
            // a flag in the af tells us to do so.
            //
            else if (m_AfData.m_fSetUsageToDialin)
            {
                HRESULT hr = HrSetUsageOnAllRasPorts(MPRFLAG_PORT_NonVpnDialin);
                TraceError("CRasSrv::ApplyRegistryChanges set dialin usage (ignoring)", hr);
            }
        }

        if (m_fInstalling)
        {
            NT_PRODUCT_TYPE ProductType;

            if (RtlGetNtProductType (&ProductType))
            {
                // Upgrade local RAS user objects.  Do not do this if we are
                // a domain controller as local RAS user objects translates to
                // all domain users.  For the domain controller case, Dcpromo
                // handles upgrading the objects in a much more efficient
                // manner.
                //
                if (NtProductLanManNt != ProductType)
                {
                    DWORD dwErr = MprAdminUpgradeUsers (NULL, TRUE);
                    TraceError ("MprAdminUpgradeUsers", HRESULT_FROM_WIN32(dwErr));
                }

                // pmay: 407019
                //
                // Make sure that rassfm is installed as a notification package on all 
                // flavors of nt servers
                //
                if ((NtProductServer == ProductType) || (NtProductLanManNt == ProductType))
                {
                    HRESULT hr = HrSetLsaNotificationPackage(L"RASSFM");
                    TraceError("CRasSrv::ApplyRegistryChanges set lsa not package usage (ignoring)", hr);
                }
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CRasSrv::ReadAnswerFile (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile (pszAnswerFile, pszAnswerSection);

    // Read data from the answer file.
    // Don't let this affect the HRESULT we return.
    //
    if (SUCCEEDED(m_AfData.HrOpenAndRead (pszAnswerFile, pszAnswerSection)))
    {
        m_fSaveAfData = TRUE;
    }

    return S_OK;
}

STDMETHODIMP
CRasSrv::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    if (NSF_WINNT_SVR_UPGRADE & dwSetupFlags)
    {
        m_fNt4ServerUpgrade = TRUE;
    }

    // Install Steelhead.
    //
    hr = HrInstallComponentOboComponent (m_pnc, NULL,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_Steelhead,
            m_pnccMe,
            NULL);

    TraceHr (ttidError, FAL, hr, FALSE, "CRasSrv::Install");
    return hr;
}

STDMETHODIMP
CRasSrv::Removing ()
{
    HRESULT hr;

    m_fRemoving = TRUE;

    // Remove Steelhead.
    //
    hr = HrRemoveComponentOboComponent (m_pnc,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_Steelhead,
            m_pnccMe);

    TraceHr (ttidError, FAL, hr, FALSE, "CRasSrv::Removing");
    return hr;
}

STDMETHODIMP
CRasSrv::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\steelhead.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S T E E L H E A D . C P P
//
//  Contents:   Implementation of Steelhead configuration object.
//
//  Notes:
//
//  Author:     shaunco   15 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <mprerror.h>
#include <tdi.h>        // must include for isnkrnl.h
#include <isnkrnl.h>
#include <rtinfo.h>
#include "rasobj.h"
#include "ncsvc.h"
#include "netcfgp.h"
#include "router.h"

extern const WCHAR c_szBiNdis5[];

extern const WCHAR c_szInfId_MS_NdisWan[];

//+---------------------------------------------------------------------------
// Static data for adding router managers.
//
static const WCHAR c_szRtrMgrIp    []  = L"Ip";
static const WCHAR c_szRtrMgrDllIp []  = L"%SystemRoot%\\System32\\iprtrmgr.dll";
static const WCHAR c_szRtrMgrIpx   []  = L"Ipx";
static const WCHAR c_szRtrMgrDllIpx[]  = L"%SystemRoot%\\System32\\ipxrtmgr.dll";

static const ROUTER_MANAGER_INFO c_rmiIp =
{
    PID_IP,
    0,
    c_szRtrMgrIp,
    c_szRtrMgrDllIp,
    MakeIpInterfaceInfo,
    MakeIpTransportInfo,
};

static const ROUTER_MANAGER_INFO c_rmiIpx =
{
    PID_IPX,
    ISN_FRAME_TYPE_AUTO,
    c_szRtrMgrIpx,
    c_szRtrMgrDllIpx ,
    MakeIpxInterfaceInfo,
    MakeIpxTransportInfo,
};

// These guids are defined in sdk\inc\ifguid.h
// We need the string versions.
//
// DEFINE_GUID(GUID_IpLoopbackInterface,  0xca6c0780, 0x7526, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);
// DEFINE_GUID(GUID_IpRasServerInterface, 0x6e06f030, 0x7526, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);
// DEFINE_GUID(GUID_IpxInternalInterface, 0xa571ba70, 0x7527, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);

//static const WCHAR c_szIpLoopbackInterface  [] = L"ca6c0780-7526-11d2-00600815a4bd";
//static const WCHAR c_szIpRasServerInterface [] = L"6e06f030-7526-11d2-00600815a4bd";
//static const WCHAR c_szIpxInternalInterface [] = L"a571ba70-7527-11d2-00600815a4bd";

// For Ipx, the adapter name is the bind name.
// We need to create an interface per frame type.
// The interface name is the adapter name followed
// by these strings.
//

#pragma BEGIN_CONST_SECTION
static const MAP_SZ_DWORD c_mapFrameType [] =
{
    L"/EthII",  MISN_FRAME_TYPE_ETHERNET_II,
    L"/802.3",  MISN_FRAME_TYPE_802_3,
    L"/802.2",  MISN_FRAME_TYPE_802_2,
    L"/SNAP",   MISN_FRAME_TYPE_SNAP,
};
#pragma END_CONST_SECTION

NOTHROW
BOOL
FMapFrameTypeToString (
    DWORD       dwFrameType,
    PCWSTR*    ppszFrameType)
{
    Assert (ppszFrameType);

    for (int i = 0; i < celems (c_mapFrameType); i++)
    {
        if (dwFrameType == c_mapFrameType[i].dwValue)
        {
            *ppszFrameType = c_mapFrameType[i].pszValue;
            return TRUE;
        }
    }

    TraceTag (ttidRasCfg, "FMapFrameTypeToString: Unknown frame type %d!",
            dwFrameType);

    *ppszFrameType = NULL;
    return FALSE;
}

NOTHROW
BOOL
FMapStringToFrameType (
    PCWSTR pszFrameType,
    DWORD*  pdwFrameType)
{
    Assert (pszFrameType);
    Assert (pdwFrameType);

    for (int i = 0; i < celems (c_mapFrameType); i++)
    {
        if (0 == lstrcmpW (pszFrameType, c_mapFrameType[i].pszValue))
        {
            *pdwFrameType = c_mapFrameType[i].dwValue;
            return TRUE;
        }
    }

    TraceTag (ttidRasCfg, "FMapStringToFrameType: Unknown frame type %S!",
            pszFrameType);

    *pdwFrameType = NULL;
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrShouldRouteOverAdapter
//
//  Purpose:    Indicate if we should router over the adapter or not.
//
//  Arguments:
//      pnccAdapter     [in]  Adapter to test.
//      ppszBindName   [out] Returned bindname if S_OK is returned.
//
//  Returns:    S_OK if we should router over the adapter, S_FALSE if not.
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//

HRESULT
HrShouldRouteOverAdapter (
    INetCfgComponent*   pnccAdapter,
    PWSTR*             ppszBindName)
{
    Assert (pnccAdapter);

    // Initialize the output parameter.
    //
    if (ppszBindName)
    {
        *ppszBindName = NULL;
    }

    // We should return S_OK if the adapter is physical or it supports
    // a binding interface of ndis5.  S_FALSE otherwise.
    //
    DWORD dwCharacter;
    HRESULT hr = pnccAdapter->GetCharacteristics (&dwCharacter);
    if (SUCCEEDED(hr) && !(dwCharacter & NCF_PHYSICAL))
    {
        INetCfgComponentBindings* pnccBindings;
        hr = pnccAdapter->QueryInterface (
                IID_INetCfgComponentBindings,
                reinterpret_cast<VOID**>(&pnccBindings));

        if (SUCCEEDED(hr))
        {
            hr = pnccBindings->SupportsBindingInterface (
                    NCF_UPPER, c_szBiNdis5);

            ReleaseObj (pnccBindings);
        }

        if (S_OK == hr)
        {
            // Only consider devices which are present.
            //
            // This check is made *after* the check for binding interface
            // match above for two reasons. 1) It's much more expensive
            // 2) for ndiswan devices which do not come online when they
            // are installed (e.g. ndiswannbfout), GetDeviceStatus will
            // fail.  For this case we don't want to route over ndiswannbf
            // anyhow so we should just return S_FALSE and not a failure.
            //
            DWORD dwStatus;
            hr = pnccAdapter->GetDeviceStatus(&dwStatus);
            if (SUCCEEDED(hr) && (CM_PROB_DEVICE_NOT_THERE == dwStatus))
            {
                hr = S_FALSE;
            }
        }
    }

    // SupportsBindingInterface may return S_OK or S_FALSE.
    // We only want the bind name if we're going to return S_OK.
    //
    if ((S_OK == hr) && ppszBindName)
    {
        hr = pnccAdapter->GetBindName (ppszBindName);
    }

    TraceError ("HrShouldRouteOverAdapter", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::CSteelhead
//
//  Purpose:    Constructor
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
CSteelhead::CSteelhead () : CRasBindObject ()
{
    m_hMprConfig                    = NULL;
    m_hMprAdmin                     = NULL;
    m_fRemoving                     = FALSE;
    m_fUpdateRouterConfiguration    = FALSE;
    m_pnccMe                        = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::~CSteelhead
//
//  Purpose:    Destructor
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
CSteelhead::~CSteelhead ()
{
    Assert (!m_hMprConfig);
    Assert (!m_hMprAdmin);

    ReleaseObj (m_pnccMe);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FAdapterExistsWithMatchingBindName
//
//  Purpose:
//
//  Arguments:
//      pszAdapterName [in]
//      ppnccAdapter    [out]
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FAdapterExistsWithMatchingBindName (
    PCWSTR             pszAdapterName,
    INetCfgComponent**  ppnccAdapter)
{
    Assert (pszAdapterName);
    Assert (ppnccAdapter);

    *ppnccAdapter = NULL;

    BOOL fFound = FALSE;

    // Enumerate physical adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter (m_pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent* pnccAdapter;
    while (!fFound &&  S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        // Only consider this adapter if we should router over it.
        //
        PWSTR pszBindName;
        hr = HrShouldRouteOverAdapter (pnccAdapter, &pszBindName);
        if (S_OK == hr)
        {
            if (0 == lstrcmpW (pszAdapterName, pszBindName))
            {
                fFound = TRUE;

                *ppnccAdapter = pnccAdapter;
                AddRefObj (pnccAdapter);
            }

            CoTaskMemFree (pszBindName);
        }

        ReleaseObj (pnccAdapter);
    }
    return fFound;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FIpxFrameTypeInUseOnAdapter
//
//  Purpose:
//
//  Arguments:
//      dwFrameType   []
//      pszAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FIpxFrameTypeInUseOnAdapter (
    DWORD  dwFrameType,
    PCWSTR pszAdapterName)
{
    // Assume its not in use.  If PnccIpx() is NULL, it means IPX is not
    // installed and the frame type is definately not in use on the adapter.
    //
    BOOL fRet = FALSE;
    if (PnccIpx())
    {
        // Get the private interface off of the INetCfgComponent for IPX
        // then we can query for a notify object interface
        //
        INetCfgComponentPrivate* pinccp;
        HRESULT hr = PnccIpx()->QueryInterface(
                                IID_INetCfgComponentPrivate,
                                reinterpret_cast<VOID**>(&pinccp));

        if (SUCCEEDED(hr))
        {
            IIpxAdapterInfo* pIpxAdapterInfo;
            hr = pinccp->QueryNotifyObject(
                                 IID_IIpxAdapterInfo,
                                 reinterpret_cast<VOID**>(&pIpxAdapterInfo));
            if (SUCCEEDED(hr))
            {
                // Get the frametypes in use for this adapter.
                //
                DWORD adwFrameType [MISN_FRAME_TYPE_MAX + 1];
                DWORD cdwFrameType;
                hr = pIpxAdapterInfo->GetFrameTypesForAdapter (
                        pszAdapterName,
                        celems (adwFrameType),
                        adwFrameType,
                        &cdwFrameType);
                if (SUCCEEDED(hr))
                {
                    for (DWORD i = 0; i < cdwFrameType; i++)
                    {
                        if (dwFrameType == adwFrameType[i])
                        {
                            fRet = TRUE;
                            break;
                        }
                    }
                }

                ReleaseObj (pIpxAdapterInfo);
            }

            ReleaseObj (pinccp);
        }
    }
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FIpxFrameTypeInUseOnAdapter
//
//  Purpose:
//
//  Arguments:
//      pszFrameType   []
//      pszAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FIpxFrameTypeInUseOnAdapter (
    PCWSTR pszFrameType,
    PCWSTR pszAdapterName)
{
    // Assume its not in use.  If PnccIpx() is NULL, it means IPX is not
    // installed and the frame type is definately not in use on the adapter.
    //
    BOOL    fRet = FALSE;
    DWORD   dwFrameType;
    if (PnccIpx() && FMapStringToFrameType (pszFrameType, &dwFrameType))
    {
        fRet = FIpxFrameTypeInUseOnAdapter (dwFrameType, pszAdapterName);
    }
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterfaceForAdapter
//
//  Purpose:    Ensures the router interface block for the specified
//              interface (adapter) is present and that the specified router
//              manger is configured for that interface.
//
//  Arguments:
//      dwIfType          [in] Interface type
//      dwPacketType      [in] The packet type (IPX only, ignored othewise)
//      pszAdapterName   [in] The adapter name
//      pszInterfaceName [in] The interface name
//      rmi               [in] The router manager
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterfaceForAdapter (
    ROUTER_INTERFACE_TYPE      dwIfType,
    DWORD                      dwPacketType,
    PCWSTR                     pszAdapterName,
    PCWSTR                     pszInterfaceName,
    const ROUTER_MANAGER_INFO& rmi)
{
    // Make sure the interface is created.
    //
    HANDLE hConfigInterface;
    HANDLE hAdminInterface;

    HRESULT hr = HrEnsureRouterInterface (
                    dwIfType,
                    pszInterfaceName,
                    &hConfigInterface,
                    &hAdminInterface);

    if (SUCCEEDED(hr))
    {
        // Ensure the router manager is added to the interface.
        //
        hr = HrEnsureRouterInterfaceTransport (
                pszAdapterName,
                dwPacketType,
                hConfigInterface,
                hAdminInterface,
                rmi);
    }
    TraceError ("CSteelhead::HrEnsureRouterInterfaceForAdapter", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureIpxRouterInterfacesForAdapter
//
//  Purpose:
//
//  Arguments:
//      pszAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureIpxRouterInterfacesForAdapter (
    PCWSTR pszAdapterName)
{
    AssertSz (PnccIpx(), "Why is this being called if IPX isn't installed?");

    // Get the IIpxAdapterInfo interface from the IPX notify object.
    // We'll use it to find out how adapters are configured under IPX.
    //
    IIpxAdapterInfo* pIpxAdapterInfo;
    HRESULT hr = HrQueryNotifyObject (
                    PnccIpx(),
                    IID_IIpxAdapterInfo,
                    reinterpret_cast<VOID**>(&pIpxAdapterInfo));

    if (SUCCEEDED(hr))
    {
        // Get the frametypes in use for this adapter.
        //
        DWORD adwFrameType [MISN_FRAME_TYPE_MAX + 1];
        DWORD cdwFrameType;
        hr = pIpxAdapterInfo->GetFrameTypesForAdapter (
                pszAdapterName,
                celems (adwFrameType),
                adwFrameType,
                &cdwFrameType);
        if (SUCCEEDED(hr) && cdwFrameType)
        {
            // If more than one frame type is in use, or if there is only
            // one and it isn't auto, then we'll be creating interfaces
            // for those frame types explicitly.
            //
            if ((cdwFrameType > 1) ||
                ((1 == cdwFrameType) &&
                 (ISN_FRAME_TYPE_AUTO != adwFrameType[0])))
            {
                for (DWORD i = 0; SUCCEEDED(hr) && (i < cdwFrameType); i++)
                {
                    PCWSTR pszFrameType;
                    if (FMapFrameTypeToString (adwFrameType[i], &pszFrameType))
                    {
                        // Make the interface name by catenating the
                        // adapter (bind) name with the frame type.
                        //
                        WCHAR szInterfaceName [512];
                        lstrcpyW (szInterfaceName, pszAdapterName);
                        lstrcatW (szInterfaceName, pszFrameType);

                        hr = HrEnsureRouterInterfaceForAdapter (
                                ROUTER_IF_TYPE_DEDICATED,
                                adwFrameType[i],
                                pszAdapterName,
                                szInterfaceName,
                                c_rmiIpx);
                    }
                }
            }

            // Otherwise, we'll create the interface for the auto frame
            // type case.
            //
            else
            {
#ifdef DBG
                AssertSz (1 == cdwFrameType,
                        "IPX should report at least one frame type.  "
                        "You may continue without a problem.");
                if (1 == cdwFrameType)
                {
                    AssertSz (ISN_FRAME_TYPE_AUTO == adwFrameType[0],
                            "Frame type should be auto here.  "
                            "You may continue without a problem.");
                }
#endif
                hr = HrEnsureRouterInterfaceForAdapter (
                        ROUTER_IF_TYPE_DEDICATED,
                        ISN_FRAME_TYPE_AUTO,
                        pszAdapterName,
                        pszAdapterName,
                        c_rmiIpx);
            }
        }

        ReleaseObj (pIpxAdapterInfo);
    }

    TraceError ("CSteelhead::HrEnsureIpxRouterInterfacesForAdapter", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterface
//
//  Purpose:    Ensures the specified router interface is present and
//              returns a handle to it.
//
//  Arguments:
//      pszInterfaceName [in]  The interface (adapter) name
//      phConfigInterface       [out] Returned handle to the interface
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterface (
    ROUTER_INTERFACE_TYPE   dwIfType,
    PCWSTR                 pszInterfaceName,
    HANDLE*                 phConfigInterface,
    HANDLE*                 phAdminInterface)
{
    Assert (pszInterfaceName);
    Assert (phConfigInterface);
    Assert (phAdminInterface);

    // Initialize the output parameters.
    //
    *phConfigInterface = NULL;
    *phAdminInterface = NULL;

    HRESULT hrConfig;
    HRESULT hrAdmin;

    hrConfig = HrMprConfigInterfaceGetHandle (m_hMprConfig,
                        const_cast<PWSTR>(pszInterfaceName),
                        phConfigInterface);

    hrAdmin  = HrMprAdminInterfaceGetHandle (m_hMprAdmin,
                        const_cast<PWSTR>(pszInterfaceName),
                        phAdminInterface, FALSE);

    if ((HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE ) == hrConfig) ||
        (HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE ) == hrAdmin))
    {
        // It's not installed, so we'll create it.
        //

        MPR_INTERFACE_0 ri0;
        ZeroMemory (&ri0, sizeof(ri0));
        ri0.hInterface = INVALID_HANDLE_VALUE;
        ri0.fEnabled   = TRUE;  // thanks gibbs
        ri0.dwIfType   = dwIfType;

        // Copy the interface name into the buffer.
        //
        AssertSz (lstrlenW (pszInterfaceName) < celems (ri0.wszInterfaceName),
                  "Bindname too big for MPR_INTERFACE_0 buffer.");
        lstrcpyW (ri0.wszInterfaceName, pszInterfaceName);

        // Create the interface.
        //
        if (HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE) == hrConfig)
        {
            hrConfig = HrMprConfigInterfaceCreate (
                            m_hMprConfig, 0, (LPBYTE)&ri0, phConfigInterface);

            TraceTag (ttidRasCfg, "MprConfigInterfaceCreate for %S",
                pszInterfaceName);
        }

        if (HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE) == hrAdmin)
        {
            hrAdmin = HrMprAdminInterfaceCreate (
                            m_hMprAdmin, 0, (LPBYTE)&ri0, phAdminInterface);

            TraceTag (ttidRasCfg, "MprAdminInterfaceCreate for %S",
                pszInterfaceName);
        }
    }

    TraceError ("CSteelhead::HrEnsureRouterInterface", hrConfig);
    return hrConfig;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterfaceTransport
//
//  Purpose:    Ensures the specified router manager is configured over
//              the specified interface.
//
//  Arguments:
//      pszAdapterName     [in] The adapter name
//      dwPacketType        [in] The packet type (IPX only, ignored otherwise)
//      hInterface          [in] Handle to the interface
//      rmi                 [in] The router manager
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterfaceTransport (
    PCWSTR                     pszAdapterName,
    DWORD                       dwPacketType,
    HANDLE                      hConfigInterface,
    HANDLE                      hAdminInterface,
    const ROUTER_MANAGER_INFO&  rmi)
{
    Assert (hConfigInterface);
    // hAdminInterface may be NULL if the router is not running.

    HRESULT hrConfig;

    // See if the router manager is present on the interface.
    //
    HANDLE hIfTransport;

    hrConfig = HrMprConfigInterfaceTransportGetHandle (
                    m_hMprConfig, hConfigInterface,
                    rmi.dwTransportId, &hIfTransport);

    if (FAILED(hrConfig))
    {
        // Ensure the router manager is present.
        //
        hrConfig = HrEnsureRouterManager (rmi);

        if (SUCCEEDED(hrConfig))
        {
            // Create the interface info and add the router manager to
            // the interface.
            //
            PRTR_INFO_BLOCK_HEADER  pibh;

            Assert (rmi.pfnMakeInterfaceInfo);
            rmi.pfnMakeInterfaceInfo (pszAdapterName,
                                      dwPacketType,
                                      (LPBYTE*)&pibh);

            hrConfig = HrMprConfigInterfaceTransportAdd (
                            m_hMprConfig,
                            hConfigInterface,
                            rmi.dwTransportId,
                            const_cast<PWSTR>(rmi.pszwTransportName),
                            (LPBYTE)pibh,
                            pibh->Size,
                            &hIfTransport);

            TraceTag (ttidRasCfg, "MprConfigInterfaceTransportAdd for "
                "%S on %S",
                rmi.pszwTransportName,
                pszAdapterName);

            if (SUCCEEDED(hrConfig) && hAdminInterface)
            {
                Assert (m_hMprAdmin);
                (VOID) HrMprAdminInterfaceTransportAdd (
                                m_hMprAdmin,
                                hAdminInterface,
                                rmi.dwTransportId,
                                (LPBYTE)pibh,
                                pibh->Size);

                TraceTag (ttidRasCfg, "MprAdminInterfaceTransportAdd for "
                    "%S on %S",
                    rmi.pszwTransportName,
                    pszAdapterName);
            }

            MemFree (pibh);
        }
    }
    TraceError ("CSteelhead::HrEnsureRouterInterfaceTransport", hrConfig);
    return hrConfig;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterManager
//
//  Purpose:    Ensures that the specified router manager is installed.
//
//  Arguments:
//      rmi [in] The router manager.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterManager (
    const ROUTER_MANAGER_INFO& rmi)
{
    PRTR_INFO_BLOCK_HEADER  pibhGlobal;
    BOOL                    fCreate = FALSE;

    // See if the router manager is installed.
    //
    HANDLE hTransport;
    HRESULT hr = HrMprConfigTransportGetHandle (m_hMprConfig,
                                                rmi.dwTransportId,
                                                &hTransport);
    if (HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr)
    {
        // It's not installed, we'll create it.
        //
        fCreate = TRUE;
    }
    else if (SUCCEEDED(hr))
    {
        // Its installed, see if its transport info is available.
        //
        DWORD dwSize;
        hr = HrMprConfigTransportGetInfo (m_hMprConfig, hTransport,
                                          (LPBYTE*)&pibhGlobal, &dwSize,
                                          NULL, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            if (!pibhGlobal)
            {
                // Global info is missing, we'll create it.
                //
                fCreate = TRUE;
            }
            else
            {
                MprConfigBufferFree (pibhGlobal);
            }
        }
    }

    if (fCreate)
    {
        // Install the router manager.
        //
        Assert (rmi.pfnMakeTransportInfo);
        PRTR_INFO_BLOCK_HEADER  pibhClient;
        rmi.pfnMakeTransportInfo ((LPBYTE*)&pibhGlobal,
                                  (LPBYTE*)&pibhClient);

        hr = HrMprConfigTransportCreate (
                     m_hMprConfig,
                     rmi.dwTransportId,
                     const_cast<PWSTR>(rmi.pszwTransportName),
                     (LPBYTE)pibhGlobal, (pibhGlobal) ? pibhGlobal->Size : 0,
                     (LPBYTE)pibhClient, (pibhClient) ? pibhClient->Size : 0,
                     const_cast<PWSTR>(rmi.pszwDllPath),
                     &hTransport);

        (VOID) HrMprAdminTransportCreate (
                     m_hMprAdmin,
                     rmi.dwTransportId,
                     const_cast<PWSTR>(rmi.pszwTransportName),
                     (LPBYTE)pibhGlobal, (pibhGlobal) ? pibhGlobal->Size : 0,
                     (LPBYTE)pibhClient, (pibhClient) ? pibhClient->Size : 0,
                     const_cast<PWSTR>(rmi.pszwDllPath));

        MemFree (pibhGlobal);
        MemFree (pibhClient);
    }
    TraceError ("CSteelhead::HrEnsureRouterManager", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterManagerDeleted
//
//  Purpose:    Ensures that the specified router manager is not installed.
//
//  Arguments:
//      rmi [in] The router manager.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Sep 1997
//
//  Notes:
//
HRESULT CSteelhead::HrEnsureRouterManagerDeleted (
    const ROUTER_MANAGER_INFO& rmi)
{
    // See if the router manager is installed.
    //
    HANDLE hTransport;
    HRESULT hr = HrMprConfigTransportGetHandle (m_hMprConfig,
                                                rmi.dwTransportId,
                                                &hTransport);
    if (SUCCEEDED(hr))
    {
        // It is installed, so we need to delete it.
        //
        (VOID) HrMprConfigTransportDelete (m_hMprConfig, hTransport);
    }
    TraceError ("CSteelhead::HrEnsureRouterManagerDeleted",
                (HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr)
                ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToAddInterfaces
//
//  Purpose:
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToAddInterfaces ()
{
    HRESULT hr = S_OK;

    // Enumerate physical adapters in the system.
    //
    CIterNetCfgComponent nccIter(m_pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent* pnccAdapter;
    while (S_OK == (hr = nccIter.HrNext(&pnccAdapter)))
    {
        // Only consider this adapter if we should router over it.
        //
        PWSTR pszBindName;
        hr = HrShouldRouteOverAdapter (pnccAdapter, &pszBindName);
        if (S_OK == hr)
        {
            INetCfgComponentBindings* pnccBindingsIp = NULL;
            INetCfgComponentBindings* pnccBindingsIpx = NULL;

            // If Ip is bound to the adapter, create and interface
            // for it.
            //
            if (PnccIp())
            {
                hr = PnccIp()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<VOID**>(&pnccBindingsIp) );
            }
            if (PnccIp() && SUCCEEDED(hr) &&
                (S_OK == (hr = pnccBindingsIp->IsBoundTo (pnccAdapter))))
            {
                // Interface name is the same as the adapter name
                // is the same as the bind name.
                //
                hr = HrEnsureRouterInterfaceForAdapter (
                        ROUTER_IF_TYPE_DEDICATED,
                        0,
                        pszBindName,
                        pszBindName,
                        c_rmiIp);

            }
            ReleaseObj (pnccBindingsIp);

            // If Ipx is bound to the adapter, create the interface(s)
            // for it.
            if (PnccIpx())
            {
                hr = PnccIpx()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<VOID**>(&pnccBindingsIpx));
            }
            if (PnccIpx() &&
                (S_OK == (hr = pnccBindingsIpx->IsBoundTo( pnccAdapter )) ))
            {
                hr = HrEnsureIpxRouterInterfacesForAdapter (pszBindName);
            }
            ReleaseObj (pnccBindingsIpx);

            CoTaskMemFree (pszBindName);
        }

        ReleaseObj (pnccAdapter);
    }
    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError ("CSteelhead::HrPassToAddInterfaces", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToRemoveInterfaces
//
//  Purpose:
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToRemoveInterfaces (
    BOOL fFromRunningRouter)
{
    // Enumerate all of the installed router interfaces.
    //
    MPR_INTERFACE_0*    ari0;
    DWORD               dwEntriesRead;
    DWORD               dwTotalEntries;
    HRESULT             hr;

    if (fFromRunningRouter)
    {
        Assert (m_hMprAdmin);
        hr = HrMprAdminInterfaceEnum (m_hMprAdmin, 0,
                        reinterpret_cast<LPBYTE*>(&ari0),
                        -1, &dwEntriesRead, &dwTotalEntries, NULL);
    }
    else
    {
        hr = HrMprConfigInterfaceEnum (m_hMprConfig, 0,
                        reinterpret_cast<LPBYTE*>(&ari0),
                        -1, &dwEntriesRead, &dwTotalEntries, NULL);
    }
    if (SUCCEEDED(hr))
    {
        // By passing -1, we want everything, so we should get everything.
        Assert (dwEntriesRead == dwTotalEntries);

        // Iterate all of the interfaces.
        //
        for (MPR_INTERFACE_0* pri0 = ari0; dwEntriesRead--; pri0++)
        {
            BOOL fDeleteInterface = FALSE;
            PCWSTR pszInternalAdapter = SzLoadIds (IDS_RAS_INTERNAL_ADAPTER);

            // If its the internal interface and IP and IPX are no longer
            // installed delete the interface.
            //
            if ((ROUTER_IF_TYPE_INTERNAL == pri0->dwIfType) &&
                !PnccIpx() && !PnccIp() &&
                (0 == lstrcmpW (pri0->wszInterfaceName, pszInternalAdapter)))
            {
                fDeleteInterface = TRUE;
            }
            else if (ROUTER_IF_TYPE_DEDICATED != pri0->dwIfType)
            {
                // Skip non-dedicated interfaces.
                //
                continue;
            }

            BOOL                fSpecialIpxInterface = FALSE;
            INetCfgComponent*   pnccAdapter          = NULL;

            // Get the name of the interface and look for a '/' separator.
            // If present, it means this is a special IPX interface where
            // the first substring is the adapter name, and the second
            // substring is the frame type.
            //
            WCHAR* pchwSep = wcschr (pri0->wszInterfaceName, L'/');
            if (!fDeleteInterface && pchwSep)
            {
                fSpecialIpxInterface = TRUE;

                // Point to the frame type string.
                //
                PCWSTR pszFrameType = pchwSep;

                // Copy the adapter name into its own buffer.
                //
                WCHAR   szAdapterName [MAX_INTERFACE_NAME_LEN+1];
                lstrcpynW (szAdapterName, pri0->wszInterfaceName,
                            pchwSep - pri0->wszInterfaceName + 1);

                // If the frame type is not in use for the adapter, we need
                // to delete this interface.  This condition happens when
                // IPX configuration is changed and the frame type is removed
                // from the adapter.
                //
                if (!FIpxFrameTypeInUseOnAdapter (pszFrameType,
                        szAdapterName))
                {
                    fDeleteInterface = TRUE;
                    TraceTag (ttidRasCfg, "%S no longer in use on %S. "
                            "Deleting the router interface.",
                            pszFrameType, szAdapterName);
                }
            }

            // It's not a special interface, so just make sure an adapter
            // exists with a matching bind name.  If not, we will delete
            // the interface.
            //
            else if (!fDeleteInterface)
            {
                if (!FAdapterExistsWithMatchingBindName (
                        pri0->wszInterfaceName,
                        &pnccAdapter))
                {
                    fDeleteInterface = TRUE;
                    TraceTag (ttidRasCfg, "%S no longer present. "
                            "Deleting the router interface.",
                            pri0->wszInterfaceName);
                }
            }

            // Delete the interface if we need to.
            //
            if (fDeleteInterface)
            {
                if (fFromRunningRouter)
                {
                    MprAdminInterfaceDelete (m_hMprAdmin, pri0->hInterface);
                }
                else
                {
                    MprConfigInterfaceDelete (m_hMprConfig, pri0->hInterface);
                }
            }

            // If we don't need to delete the entire interface, check
            // for transports on the interface that we may need to delete.
            // Don't do this for the running router because there is
            // no MprAdminInterfaceTransportEnum API.
            //
            else if (!fFromRunningRouter)
            {
                // If its not an IPX special interface, the adapter
                // is the interface name.  If it is an IPX special
                // interface, then we would have already remove the entire
                // interface above if it were invalid.
                //
                (VOID) HrPassToRemoveInterfaceTransports (
                        pri0,
                        (!fSpecialIpxInterface) ? pri0->wszInterfaceName
                                                : NULL,
                        pnccAdapter);
            }

            ReleaseObj (pnccAdapter);
        }

        MprConfigBufferFree (ari0);
    }
    else if ((HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ||
             (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) ||
             (HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) == hr))
    {
        hr = S_OK;
    }
    TraceError ("CSteelhead::HrPassToRemoveInterfaces", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToRemoveInterfaceTransports
//
//  Purpose:
//
//  Arguments:
//      hInterface      []
//      pszAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToRemoveInterfaceTransports (
    MPR_INTERFACE_0*   pri0,
    PCWSTR             pszAdapterName,
    INetCfgComponent*  pnccAdapter)
{
    Assert (FImplies(pnccAdapter, pszAdapterName));

    // Enumerate all of the transports active on the router interface.
    //
    MPR_IFTRANSPORT_0*  arit0;
    DWORD               dwEntriesRead;
    DWORD               dwTotalEntries;
    HRESULT hr = HrMprConfigInterfaceTransportEnum (m_hMprConfig,
                    pri0->hInterface, 0,
                    reinterpret_cast<LPBYTE*>(&arit0),
                    -1, &dwEntriesRead, &dwTotalEntries, NULL);
    if (SUCCEEDED(hr))
    {
        // By passing -1, we want everything, so we should get everything.
        Assert (dwEntriesRead == dwTotalEntries);

        INetCfgComponentBindings* pnccBindingsIpx = NULL;
        INetCfgComponentBindings* pnccBindingsIp  = NULL;

        if (PnccIp())
        {
            hr = PnccIp()->QueryInterface (IID_INetCfgComponentBindings,
                    reinterpret_cast<VOID**>(&pnccBindingsIp));
        }
        if (SUCCEEDED(hr))
        {
            if (PnccIpx())
            {
                hr = PnccIpx()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<VOID**>(&pnccBindingsIpx));
            }
            if (SUCCEEDED(hr))
            {
                // Iterate all of the transports.
                //
                for (MPR_IFTRANSPORT_0* prit0 = arit0; dwEntriesRead--; prit0++)
                {
                    BOOL fDeleteInterfaceTransport = FALSE;

                    if (prit0->dwTransportId == c_rmiIp.dwTransportId)
                    {
                        if (!PnccIp())
                        {
                            fDeleteInterfaceTransport = TRUE;
                            TraceTag (ttidRasCfg, "TCP/IP no longer present.  "
                                    "Deleting this transport from interface %S.",
                                    pri0->wszInterfaceName);
                        }
                        else if (pnccAdapter &&
                                 (S_OK != (hr = pnccBindingsIp->IsBoundTo (pnccAdapter))))
                        {
                            fDeleteInterfaceTransport = TRUE;
                            TraceTag (ttidRasCfg, "TCP/IP no longer bound.  "
                                    "Deleting this transport from interface %S.",
                                    pri0->wszInterfaceName);
                        }
                    }
                    else if (prit0->dwTransportId == c_rmiIpx.dwTransportId)
                    {
                        if (!PnccIpx())
                        {
                            fDeleteInterfaceTransport = TRUE;
                            TraceTag (ttidRasCfg, "IPX no longer present.  "
                                    "Deleting this transport from interface %S.",
                                    pri0->wszInterfaceName);
                        }
                        else if (pnccAdapter &&
                                 (S_OK != (hr = pnccBindingsIpx->IsBoundTo (pnccAdapter))))
                        {
                            fDeleteInterfaceTransport = TRUE;
                            TraceTag (ttidRasCfg, "IPX no longer bound.  "
                                    "Deleting this transport from interface %S.",
                                    pri0->wszInterfaceName);
                        }
                        else if (pszAdapterName)
                        {
                            Assert (PnccIpx());

                            // if frame type is not auto on this adapter, delete
                            // the transport
                            if (!FIpxFrameTypeInUseOnAdapter (ISN_FRAME_TYPE_AUTO,
                                    pszAdapterName))
                            {
                                fDeleteInterfaceTransport = TRUE;
                                TraceTag (ttidRasCfg, "IPX Auto frame type no longer "
                                        "in use on %S.  "
                                        "Deleting this transport from interface %S.",
                                        pszAdapterName, pri0->wszInterfaceName);
                            }
                        }
                    }

                    if (fDeleteInterfaceTransport)
                    {
                        MprConfigInterfaceTransportRemove (
                            m_hMprConfig,
                            pri0->hInterface,
                            prit0->hIfTransport);
                    }

                }
                MprConfigBufferFree (arit0);

                ReleaseObj (pnccBindingsIpx);
            }

            ReleaseObj (pnccBindingsIp);
        }
    }
    else if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        // If there are no transports for this interface, that's okay.
        //
        hr = S_OK;
    }

    TraceError ("CSteelhead::HrPassToRemoveInterfaceTransports", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrUpdateRouterConfiguration
//
//  Purpose:    Updates the router configuration by ensuring router managers
//              are installed for the protocols present on the system (IP and
//              IPX).  Further, router interfaces are created for each
//              physical netcard present on the system.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrUpdateRouterConfiguration ()
{
    Assert (!m_hMprConfig);

    HRESULT hr = HrMprConfigServerConnect (NULL, &m_hMprConfig);
    if (SUCCEEDED(hr))
    {
        PCWSTR pszInternalAdapter = SzLoadIds (IDS_RAS_INTERNAL_ADAPTER);
        PCWSTR pszLoopbackAdapter = SzLoadIds (IDS_RAS_LOOPBACK_ADAPTER);

        // Connect to the running router if able.
        // (m_hMprAdmin will be non-NULL if we do.)
        //
        Assert (!m_hMprAdmin);
        (VOID) HrMprAdminServerConnect (NULL, &m_hMprAdmin);

        // Ensure router managers are installed for the protocols
        // we know about.  Good to do this in case no physical adapters.
        // are found below.  We actually do this by ensuring the internal
        // interface exists.  This will implicitly ensure the router
        // manger is created.
        //
        if (PnccIp())
        {
            (VOID) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_LOOPBACK,
                    c_rmiIp.dwPacketType,
                    pszLoopbackAdapter,
                    pszLoopbackAdapter,
                    c_rmiIp);

            (VOID) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_INTERNAL,
                    c_rmiIp.dwPacketType,
                    pszInternalAdapter,
                    pszInternalAdapter,
                    c_rmiIp);
        }
        else
        {
            (VOID) HrEnsureRouterManagerDeleted (c_rmiIp);
        }
        if (PnccIpx())
        {
            (VOID) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_INTERNAL,
                    c_rmiIpx.dwPacketType,
                    pszInternalAdapter,
                    pszInternalAdapter,
                    c_rmiIpx);
        }
        else
        {
            (VOID) HrEnsureRouterManagerDeleted (c_rmiIpx);
        }

        (VOID) HrPassToAddInterfaces ();

        (VOID) HrPassToRemoveInterfaces (FALSE);

        // If we have a connection to the running router, make a pass
        // to remove interfaces from it.
        //
        if (m_hMprAdmin)
        {
            (VOID) HrPassToRemoveInterfaces (TRUE);
            MprAdminServerDisconnect (m_hMprAdmin);
            m_hMprAdmin = NULL;
        }

        MprConfigServerDisconnect (m_hMprConfig);
        m_hMprConfig = NULL;
    }

    TraceError ("CSteelhead::HrUpdateRouterConfiguration", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CSteelhead::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    m_fUpdateRouterConfiguration = fInstalling;

    return S_OK;
}

STDMETHODIMP
CSteelhead::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    if (!m_fRemoving && m_fUpdateRouterConfiguration)
    {
        m_fUpdateRouterConfiguration = FALSE;

        TraceTag (ttidRasCfg, "Updating Steelhead configuration.");

        hr = HrFindOtherComponents ();
        if (SUCCEEDED(hr))
        {
            hr = HrUpdateRouterConfiguration ();

            ReleaseOtherComponents ();
        }

        if (FAILED(hr))
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    Validate_INetCfgNotify_Apply_Return (hr);

    TraceError ("CSteelhead::ApplyRegistryChanges",
        (NETCFG_S_REBOOT == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CSteelhead::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install NdisWan.
    hr = HrInstallComponentOboComponent (m_pnc, NULL,
             GUID_DEVCLASS_NETTRANS,
             c_szInfId_MS_NdisWan,
             m_pnccMe,
             NULL);

    TraceError ("CSteelhead::Install", hr);
    return hr;
}

STDMETHODIMP
CSteelhead::Removing ()
{
    HRESULT hr;

    m_fRemoving = TRUE;

    // Remove NdisWan.
    hr = HrRemoveComponentOboComponent (m_pnc,
            GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NdisWan,
            m_pnccMe);

    TraceError ("CSteelhead::Removing", hr);
    return hr;
}

STDMETHODIMP
CSteelhead::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}

//+---------------------------------------------------------------------------
// INetCfgSystemNotify
//
STDMETHODIMP
CSteelhead::GetSupportedNotifications (
    DWORD*  pdwNotificationFlag)
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications (pdwNotificationFlag);

    *pdwNotificationFlag = NCN_NET | NCN_NETTRANS |
                           NCN_ADD | NCN_REMOVE |
                           NCN_PROPERTYCHANGE;

    return S_OK;
}

STDMETHODIMP
CSteelhead::SysQueryBindingPath (
    DWORD               dwChangeFlag,
    INetCfgBindingPath* pncbp)
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::SysQueryComponent (
    DWORD               dwChangeFlag,
    INetCfgComponent*   pncc)
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::SysNotifyBindingPath (
    DWORD               dwChangeFlag,
    INetCfgBindingPath* pncbp)
{
    return S_FALSE;
}

STDMETHODIMP
CSteelhead::SysNotifyComponent (
    DWORD               dwChangeFlag,
    INetCfgComponent*   pncc)
{
    HRESULT hr;

    Validate_INetCfgSystemNotify_SysNotifyComponent (dwChangeFlag, pncc);

    // Assume we won't be dirty as a result of this notification.
    //
    hr = S_FALSE;

    if (!m_fUpdateRouterConfiguration)
    {
        // If we're being called for a change to a net device, make sure
        // its physical before deciding we need to update our configuration.
        //
        GUID guidClass;
        hr = pncc->GetClassGuid (&guidClass);
        if (S_OK == hr)
        {
            if (GUID_DEVCLASS_NET == guidClass)
            {
                hr = HrShouldRouteOverAdapter (pncc, NULL);
                if (S_OK == hr)
                {
                    TraceTag (ttidRasCfg, "CSteelhead::SysNotifyComponent: "
                        "called for adapter install/remove.");

                    m_fUpdateRouterConfiguration = TRUE;
                    Assert (S_OK == hr);
                }
            }
            else
            {
                TraceTag (ttidRasCfg, "CSteelhead::SysNotifyComponent: "
                    "called for protocol add/remove/change.");

                // If we're called for non-net devices, we want to
                // update our configuration.  (GetSupportedNotifications
                // controls how often we fall into this.)
                //
                m_fUpdateRouterConfiguration = TRUE;
                Assert (S_OK == hr);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CSteelhead::SysNotifyComponent", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "ncxbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\resource.h ===
#include <ncres.h>
#include <ncpcfg.h>

/*
#define IDCS_NC_SFNCFG              1000

// String resources
#define IDS_DESC_COMOBJ_SFNCFG      IDS_NC_SFNCFG + 0
#define IDS_DRIVE_NOT_NTFS          IDS_NC_SFNCFG + 3
#define IDS_DRIVE_NOT_FIXED         IDS_NC_SFNCFG + 4
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sapcfg\sapobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S A P O B J . H
//
//  Contents:   Declaration of SAP Agent configuration object.
//
//  Notes:
//
//  Author:     jeffspr   31 May 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"


class ATL_NO_VTABLE CSAPCfg :
    public CComObjectRoot,
    public CComCoClass<CSAPCfg, &CLSID_CSAPCfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
public:
    CSAPCfg();
    ~CSAPCfg();

    BEGIN_COM_MAP(CSAPCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CSAPCfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_SAPCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD,DWORD);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

// Private state info
private:
    INetCfgComponent *  m_pncc;             // Place to keep my component
    INetCfg *           m_pnc;              // Place to keep my component
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\ncpcfg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    ncpcfg.h
    NCP configuration dialog constants

*/

#ifndef _NCPCFG_H_
#define _NCPCFG_H_

#define IDS_BASE		1000
#define HC_UI_BASE		2000

#define NETWORKNUMBERSIZE 8
#define MAX_FRAMETYPE     5

#define SZ8ZEROES SZ("00000000")
#define SZSUPERVISOR SZ("Supervisor")
#define SZCONSOLEOPERATOR SZ("Console Operators")

/* Netware Configuration dialog
   Dialog ID has to be in the range of IDRSRC_NCPCFG_BASE  9200
   to IDRSRC_NCPCFG_LAST  9399, and it has to be explicit number. */

#define DLG_SysVolAndServerConfig       9301
#define DLG_AutoTuneParametersConfig    9302
                                         
#define NCP_INSTALL_DLG              9200
#define IDD_NCD_SLE_SYSDIR           101
#define IDD_NCD_SLE_PASSWORD         102
#define IDD_NCD_SLE_CONFIRM_PASSWORD 103
#define IDD_NCD_RB_MIN               104
#define IDD_NCD_RB_BALANCE           105
#define IDD_NCD_RB_MAX               106
#define IDD_NCD_SLE_SRVNAME          107

#define NCP_CONFIG_DLG               9201
#define IDD_NCD_PB_ADVANCED          108

/* Advanced Netwary Configuration dialog */
#define ADVANCED_NCP_CONFIG_DLG      9202
#define IDD_ANCD_SLE_INETNUM         201
#define IDD_ANCD_COMBO_ADAPTER       202
#define IDD_ANCD_COMBO_FRAMETYPE     203
#define IDD_ANCD_SLE_NETNUM          204
#define IDD_ANCD_LB_FRAME_NETNUM     205
#define IDD_ANCD_ST_FRAME_TYPE       206
#define IDD_ANCD_ST_NETWORK_NUM      207
#define IDD_ANCD_PB_ADD              208
#define IDD_ANCD_PB_REMOVE           209
#define IDD_NCD_CB_ROUTER            210
#define IDD_ANCD_RB_AUTODETECT       211
#define IDD_ANCD_RB_MANUALDETECT     212
#define IDD_ANCD_SLT_FRAME_TYPE      213
#define IDD_ANCD_SLT_NETWORK_NUMBER  214
#define IDD_ANCD_SLT_IN_HEX          215

#define NCP_SVCPASSWD_DLG            9203

// strings
#define IDS_STR_BASE                     IDS_BASE
#define IDS_UNKNOWN_NET_CARD             (IDS_STR_BASE+1)

#define IDS_ETHERNET                     (IDS_STR_BASE+2)
#define IDS_802_2                        (IDS_STR_BASE+3)
#define IDS_802_3                        (IDS_STR_BASE+4)
#define IDS_SNAP                         (IDS_STR_BASE+5)
#define IDS_ARCNET                       (IDS_STR_BASE+6)
#define IDS_802_5                        (IDS_STR_BASE+7)
#define IDS_TK                           (IDS_STR_BASE+8)
#define IDS_FDDI                         (IDS_STR_BASE+9)
#define IDS_FDDI_SNAP                    (IDS_STR_BASE+10)
#define IDS_FDDI_802_3                   (IDS_STR_BASE+11)

#define IDS_NCPCFG_HELP_FILE_NAME        (IDS_STR_BASE+12)
#define IDS_NCPCFG_BLT_INIT_FAILED       (IDS_STR_BASE+13)

#define IDS_InvalidPath                  (IDS_STR_BASE+14)
#define IDS_BAD_PASSWORD                 (IDS_STR_BASE+15)
#define IDS_BAD_CONFIRM_PASSWORD         (IDS_STR_BASE+16)
#define IERR_ADD_NETWORK_NUMBER          (IDS_STR_BASE+17)

#define IDS_NO_FRAME_TYPE                (IDS_STR_BASE+22)
#define IDS_NO_NETWORK_NUMBER            (IDS_STR_BASE+23)
#define IDS_BAD_IPX_CONFIGURATION        (IDS_STR_BASE+26)
#define IDS_UNMATCH_PASSWORD             (IDS_STR_BASE+27)
#define IDS_SUPERVISOR_ALREADY_EXIST     (IDS_STR_BASE+28)
#define IDS_DRIVE_NOT_NTFS               (IDS_STR_BASE+29)
#define IDS_DRIVE_NOT_FIXED              (IDS_STR_BASE+30)
#define IDS_ZERO_INTERNAL_NETWORK_NUMBER (IDS_STR_BASE+31)
#define IDS_SUPERVISOR_COMMENT           (IDS_STR_BASE+32)
#define IDS_CONSOLE_OPERATOR_COMMENT     (IDS_STR_BASE+33)
#define IDS_NO_NTFS_DRIVE                (IDS_STR_BASE+34)
#define IDS_FORCE_REMOVE                 (IDS_STR_BASE+35)
#define IDS_NOT_VALID_CONFIGURE          (IDS_STR_BASE+36)
#define IDS_SVC_ACCOUNT_NAME             (IDS_STR_BASE+37)
#define IDS_SVC_ACCOUNT_ALREADY_EXIST    (IDS_STR_BASE+38)
#define IDS_SVC_ACCOUNT_COMMENT          (IDS_STR_BASE+39)
#define IDS_RAND_INTERNAL_NETWORK_NUMBER (IDS_STR_BASE+40)
#define IDS_NULL_SVCPASSWORD             (IDS_STR_BASE+41)
#define IDS_NETNUMBER_USED               (IDS_STR_BASE+42)
#define IDS_REPLICATION_HUNG             (IDS_STR_BASE+43)
#define IDS_INVALID_SERVER_NAME          (IDS_STR_BASE+44)

#define IDS_SAP_REQUIRED                 (IDS_STR_BASE+50)
#define IDS_FPNW_CAPTION                 (IDS_STR_BASE+51)
#define IDS_DESC_COMOBJ_SFNCFG           (IDS_STR_BASE+52)
#define IDS_WKS_ONLY                     (IDS_STR_BASE+53)

// help index
#define HC_NCP_INSTALL_DIALOG            (HC_UI_BASE)
#define HC_NCP_CONFIG_DIALOG             (HC_UI_BASE + 1)
#define HC_ADVANCED_NCP_CONFIG_DIALOG    (HC_UI_BASE + 2)
#define HC_INTERNAL_NETNUM_DIALOG        (HC_UI_BASE + 3)
#define HC_NCP_SVC_PASSWD_DIALOG         (HC_UI_BASE + 4)

#endif // _NCPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sapcfg\sapobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S A P O B J . C P P
//
//  Contents:   Implementation of the CSAPCfg notify object
//
//  Notes:
//
//  Author:     jeffspr   31 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "sapobj.h"
#include "ncreg.h"

extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szRegKeyRefCounts[];
extern const WCHAR c_szRegValueComponentId[];

const WCHAR c_szProtoPath[] = L"System\\CurrentControlSet\\Control\\Network\\{4D36E975-E325-11CE-BFC1-08002BE10318}";
const WCHAR c_szOcSapRef[] = L"%Msft%nwsapagent";

CSAPCfg::CSAPCfg()
{
    m_pnc   = NULL;
    m_pncc  = NULL;
}

CSAPCfg::~CSAPCfg()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);
}


STDMETHODIMP
CSAPCfg::Initialize (
    INetCfgComponent*   pnccItem,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "m_pncc NULL in CSAPCfg::Initialize");
    AssertSz(m_pnc, "m_pnc NULL in CSAPCfg::Initialize");

    // Addref the config objects
    //
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    return S_OK;
}

STDMETHODIMP
CSAPCfg::Validate()
{
    return S_OK;
}

STDMETHODIMP
CSAPCfg::CancelChanges()
{
    return S_OK;
}

STDMETHODIMP
CSAPCfg::ApplyRegistryChanges()
{
    return S_OK;
}

STDMETHODIMP
CSAPCfg::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP
CSAPCfg::Upgrade(DWORD, DWORD)
{
    // Raid 266650 - Need to clean up the registry as in Beta 2 SAP was an optional component.
    //               Cleanup is done by deleting the NetOC OBO Install ref-count on IPX.
    //
    HRESULT hr;
    HKEY    hkeyProto;

    // Open the protocol list
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szProtoPath, KEY_ALL_ACCESS, &hkeyProto);
    if (SUCCEEDED(hr))
    {
        BOOL        fDone = FALSE;
        WCHAR       szValueName [_MAX_PATH];
        DWORD       cchBuffSize = _MAX_PATH;
        FILETIME    ft;
        DWORD       dwKeyIndex = 0;

        // Enum the keys children, search for ms_nwipx
        //
        while (SUCCEEDED(hr = HrRegEnumKeyEx(hkeyProto, dwKeyIndex, szValueName,
                                             &cchBuffSize, NULL, NULL, &ft)) &&
               !fDone)
        {
            HKEY hkeyComponent;

            // Open the key that was enumerated
            //
            hr = HrRegOpenKeyEx(hkeyProto, szValueName, KEY_ALL_ACCESS, &hkeyComponent);
            if (SUCCEEDED(hr))
            {
                tstring str;

                // Is this ms_nwipx?
                //
                hr = HrRegQueryString(hkeyComponent, c_szRegValueComponentId, &str);
                if (SUCCEEDED(hr) && (0 == _wcsicmp(str.c_str(), c_szInfId_MS_NWIPX)))
                {
                    HKEY hkeyRefCounts;

                    // Open the "RefCounts" subkey
                    //
                    hr = HrRegOpenKeyEx(hkeyComponent, c_szRegKeyRefCounts,
                                        KEY_ALL_ACCESS, &hkeyRefCounts);
                    if (SUCCEEDED(hr))
                    {
                        // Enumerate the values under here searching for %Msft%nwsapagent
                        //
                        for (DWORD dwIndex = 0; SUCCEEDED(hr); dwIndex++)
                        {
                            WCHAR pszValueName [_MAX_PATH];
                            DWORD cchValueName = celems (pszValueName);
                            DWORD dwType;
                            DWORD dwRefCount = 0;
                            DWORD cbData = sizeof (dwRefCount);

                            hr = HrRegEnumValue (hkeyRefCounts, dwIndex,
                                                 pszValueName, &cchValueName,
                                                 &dwType, (LPBYTE)&dwRefCount, &cbData);
                            if (SUCCEEDED(hr) && (0 == _wcsicmp(pszValueName, c_szOcSapRef)))
                            {
                                // Delete the value and exit the loop
                                //
                                hr = HrRegDeleteValue (hkeyRefCounts, pszValueName);
                                break;
                            }
                        }

                        RegCloseKey(hkeyRefCounts);
                    }

                    fDone = TRUE;
                }

                RegCloseKey(hkeyComponent);
            }

            cchBuffSize = _MAX_PATH;
            dwKeyIndex++;
        }

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkeyProto);
    }


    return S_OK;
}

STDMETHODIMP
CSAPCfg::Install (
    DWORD   dw)
{
    Validate_INetCfgNotify_Install(dw);

    // Install IPX
    //
    HRESULT hr = HrInstallComponentOboComponent(m_pnc, NULL,
                    GUID_DEVCLASS_NETTRANS,
                    c_szInfId_MS_NWIPX,
                    m_pncc, NULL);

    TraceError("CSAPCfg::Install", hr);
    return hr;
}

STDMETHODIMP
CSAPCfg::Removing()
{
    // Remove IPX
    //
    HRESULT hr = HrRemoveComponentOboComponent (m_pnc,
                    GUID_DEVCLASS_NETTRANS,
                    c_szInfId_MS_NWIPX,
                    m_pncc);

    // Normalize the HRESULT. (NETCFG_S_STILL_REFERENCED or NETCFG_S_REBOOT
    // may have been returned.)
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    Validate_INetCfgNotify_Removing_Return (hr);

    TraceError ("CSAPCfg::Removing", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\sfncfg.cpp ===
#include "pch.h"
#pragma hdrstop
#include "sfnobj.h"

#define INITGUID
#include <guiddef.h>
DEFINE_GUID(CLSID_CSfnCfg,0x774BADAA,0xA7AC,0x11D0,0xB2,0x5B,0x00,0xC0,0x4F,0xC9,0xE2,0x92);

// Global
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CSfnCfg, CSFNCfg)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        InitializeDebugging();

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        UnInitializeDebugging();
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    return NcAtlModuleRegisterServer (&_Module);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\sfndef.h ===
// Only allow single inclusion of this file.
#pragma once

// Name of the NetWare Config file.
#define NW_CONFIG_DLL_NAME      L"fpnwcfg.dll"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\sfnobj.cpp ===
//
// S F N O B J . C P P
//
// Implementation of the CSFNCfg notify object model
//

#include "pch.h"
#pragma hdrstop
#include "sfnobj.h"
#include "ncatlui.h"
#include "ncui.h"
#include "ncreg.h"
#include "ncmisc.h"

extern const WCHAR c_szFPNWVolumes[];
extern const WCHAR c_szSys[];
extern const WCHAR c_szPath[];
extern const WCHAR c_szBackslash[];

extern const WCHAR c_szInfId_MS_NwSapAgent[];

static const WCHAR c_szSysVolRoot[] = L"C:\\SysVol";


//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrCopySysVolFiles(INetCfgComponent * pncc);

//
// Destructor
//

CSFNCfg::CSFNCfg()
{
    // Initialize member variables.
    m_pnc                   = NULL;
    m_pncc                  = NULL;
    m_eInstallAction        = eActUnknown;
    m_fDirty                = FALSE;
    m_fAlreadyInstalled     = FALSE;

    // Config lib stuff
    m_hlibConfig            = NULL;
    m_pfnIsSpoolerRunning   = NULL;
    m_pfnRunNcpDlg          = NULL;
    m_pfnRemoveNcpServer    = NULL;
    m_pfnCommitNcpDlg       = NULL;

    // Propsheet pages
    m_apspObj[0]            = NULL;
    m_apspObj[1]            = NULL;

    m_dwTuning              = c_dwDefaultTuning;
    m_szSysVol[0]           = L'\0';
    m_szFPNWServerName[0]   = L'\0';

    m_pNcpInfoHandle        = NULL;

}

CSFNCfg::~CSFNCfg()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);
}


//
// INetCfgNotify
//

STDMETHODIMP CSFNCfg::Initialize(   INetCfgComponent *  pnccItem,
                                    INetCfg*            pnc,
                                    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "m_pncc NULL in CSFNCfg::Initialize");
    AssertSz(m_pnc, "m_pnc NULL in CSFNCfg::Initialize");

    // Determine if already installed.  Don't trust the fInstalling, because
    // this component is a have disk component and we don't want to do
    // much if already installed.
    //

    // Addref the config objects
    //
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    return S_OK;
}

STDMETHODIMP CSFNCfg::Upgrade(DWORD dwSetupFlags,
                              DWORD dwUpgradeFromBuildNo)
{

    // during first time install, perform some basic tasks that aren't related
    // to bindings
    if (dwSetupFlags & NSF_POSTSYSINSTALL)
    {
        HRESULT hr = HrCodeFromOldINF();
        if (SUCCEEDED(hr))
        {
            m_fDirty = TRUE;
        }
    }

    return S_OK;
}

STDMETHODIMP CSFNCfg::ReadAnswerFile(PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection)
{
    return S_OK;
}


STDMETHODIMP CSFNCfg::Install(DWORD dw)
{
    HRESULT         hr = S_OK;
    NT_PRODUCT_TYPE pt;

    Validate_INetCfgNotify_Install(dw);

    m_eInstallAction = eActInstall;

    RtlGetNtProductType (&pt);
    if (NtProductLanManNt != pt)
    {
        // Return a warning instead of an error so the UI won't popup an
        // error dialog after we've already notified the user of why the
        // install failed.
        //

        // Tell the user that they can't install on this platform.
        //
        NcMsgBox(GetActiveWindow(), IDS_FPNW_CAPTION,
                 IDS_WKS_ONLY, MB_OK | MB_ICONINFORMATION);

        hr = E_FAIL;
        TraceTag(ttidSFNCfg, "User tried to install on machine other than a DC, this is not allowed.");
        goto Error;
    }

    // Install SAP, which should install nwlnkipx
    //
    hr = HrInstallComponentOboComponent(m_pnc, NULL,
                                        GUID_DEVCLASS_NETSERVICE,
                                        c_szInfId_MS_NwSapAgent,
                                        m_pncc,
                                        NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Write the sysvol info if not already present
    //
    hr = HrWriteDefaultSysVol();
    if (FAILED(hr))
    {
        goto Error;
    }

    // Call the fpnw configuration code and have it do it's stuff
    //
    hr = HrCodeFromOldINF();
    if (FAILED(hr))
    {
        goto Error;
    }

    // Copy files to the location the user specified in the fpnw dialog
    //
    hr = HrCopySysVolFiles(m_pncc);
    if (SUCCEEDED(hr))
    {
        m_fDirty = TRUE;
    }

Error:
    // Validate_INetCfgNotify_Install_Return(hr);

    TraceError("CSFNCfg::Install", hr);
    return hr;
}

HRESULT CSFNCfg::HrWriteDefaultSysVol()
{
    HRESULT hr;
    PWSTR  pszValue = NULL;
    tstring str;

    str = c_szFPNWVolumes;
    str += c_szBackslash;
    str += c_szSys;
    hr = HrRegQueryMultiSzWithAlloc(HKEY_LOCAL_MACHINE, str.c_str(),
                                    &pszValue);
    if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr)
    {
        // Not found is ok, we need to write the default value
        //
        str = c_szPath;
        str += c_szSysVolRoot;
        hr = HrRegAddStringToMultiSz(str.c_str(), HKEY_LOCAL_MACHINE,
                                     c_szFPNWVolumes, c_szSys,
                                     STRING_FLAG_ENSURE_AT_END,
                                     0);
    }
    else if (S_OK == hr)
    {
        // Just clean up
        MemFree(pszValue);
    }

    TraceError("CSFNCfg::HrWriteDefaultSysVol", hr);
    return hr;
}

STDMETHODIMP CSFNCfg::Removing()
{
    m_eInstallAction = eActInstall;

    HRESULT hr = HrLoadConfigDLL();
    if (SUCCEEDED(hr))
    {
        m_fDirty = TRUE;

        // Remove the SAP Agent service
        hr = HrRemoveComponentOboComponent(m_pnc,
                                           GUID_DEVCLASS_NETSERVICE,
                                           c_szInfId_MS_NwSapAgent,
                                           m_pncc);
        if (hr == NETCFG_S_STILL_REFERENCED)
        {
            // If services are still in use, that's OK, I just needed to make
            // sure that I released my reference.
            //
            hr = S_OK;
        }
    }

    Validate_INetCfgNotify_Removing_Return(hr);

    TraceError("CSFNCfg::Removing", hr);
    return hr;
}

STDMETHODIMP CSFNCfg::Validate()
{
    return S_OK;
}

STDMETHODIMP CSFNCfg::CancelChanges()
{
    return S_OK;
}

STDMETHODIMP CSFNCfg::ApplyRegistryChanges()
{
    HRESULT     hr      = S_OK;
    BOOL        fResult = TRUE;

    if (m_fDirty)
    {
        if (eActInstall == m_eInstallAction)
        {
            Assert(m_pfnCommitNcpDlg);
            Assert(m_pNcpInfoHandle);

            // The TRUE below means that we're installing.
            //
            fResult = m_pfnCommitNcpDlg(NULL, TRUE, m_pNcpInfoHandle);
            if (FALSE == fResult)
            {
                hr = E_FAIL;
            }
        }
        else if (eActRemove == m_eInstallAction)
        {
            // Removing
            Assert(m_pfnRemoveNcpServer);
            if (FALSE == m_pfnRemoveNcpServer(NULL))
            {
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CSFNCfg::ApplyRegistryChanges",
        (hr == S_FALSE) ? S_OK : hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\sfninf.cpp ===
//---[ sfninf.cpp ]-----------------------------------------------------------
//
//  NetWare client configuration notify object.
//  Functionality from old INF
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "sfndef.h"
#include "sfnobj.h"
#include "ncreg.h"
#include "ncsetup.h"

//---[ Constants ]-------------------------------------------------------------

const WCHAR g_szConfigDLLName[]         = NW_CONFIG_DLL_NAME;     // sfndef.h
const WCHAR c_szLogin[]                 = L"\\Login";
const WCHAR c_szPublic[]                = L"\\Public";
const WCHAR c_szCopyFilesLogin[]        = L"CpyFiles_Login";
const WCHAR c_szCopyFilesPublic[]       = L"CpyFiles_Public";
extern const WCHAR c_szFPNWVolumes[]           = L"System\\CurrentControlSet\\Services\\FPNW\\Volumes";
extern const WCHAR c_szSys[]                   = L"Sys";
extern const WCHAR c_szPath[]                  = L"Path=";

//---[ Typedefs ]--------------------------------------------------------------

//---[ Prototypes ]------------------------------------------------------------

HRESULT HrInstallFPNWPerfmonCounters();

//-----------------------------------------------------------------------------

//---[ CSFNCfg::HrCodeFromOldINF ]-------------------------------------------
//
//  This contains all of the logic from the old oemnsvnw.inf, or at least
//  calls to helper functions that perform all of the logic. This runs pretty
//  much straight through the old installadapter code.
//
//  Parameters - None
//
//-----------------------------------------------------------------------------

HRESULT CSFNCfg::HrCodeFromOldINF()
{
    HRESULT hr              = S_OK;
    BOOL    fResult         = TRUE;

    hr = HrLoadConfigDLL();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Call the FPNWCFG function that tests for a running spooler.

    fResult = m_pfnIsSpoolerRunning();
    if (!fResult)
    {
        hr = E_FAIL;
        TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrCodeFromOldINF failed in SpoolerRunning");
        goto Exit;
    }

    hr = HrDoConfigDialog();
    if (FAILED(hr))
    {
        TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrCodeFromOldINF failed in HrDoConfigDialog");
        goto Exit;
    }

    hr = HrInstallFPNWPerfmonCounters();
    if (FAILED(hr))
    {
        TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrCodeFromOldINF failed in HrInstallFPNWPerfmonCounters");
        goto Exit;
    }

Exit:
    TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrCodeFromOldINF");
    return hr;
}

//---[ CSFNCfg::HrLoadConfigDLL ]----------------------------------------------
//
//  Load nwcfg.dll, so we can call some of the functions within. Also, do the
//  GetProcAddress calls for all of the functions that we might need.
//
//  Parameters - None
//
//-----------------------------------------------------------------------------

HRESULT CSFNCfg::HrLoadConfigDLL()
{
    HRESULT     hr                              = S_OK;

    AssertSz(!m_hlibConfig, "This should not be getting initialized twice");

    m_hlibConfig = LoadLibrary(g_szConfigDLLName);
    if (!m_hlibConfig)
    {
        DWORD dwLastError = GetLastError();

        TraceHr(ttidSFNCfg, FAL, hr, FALSE, "Failed to LoadLib the config DLL");
        hr = E_FAIL;
        goto Exit;
    }

    // Get DLL entry point for the IsSpoolerRunning API
    //
    m_pfnIsSpoolerRunning   = (FPNWCFG_ISSPOOLERRUNNING_PROC)
            GetProcAddress(m_hlibConfig, "IsSpoolerRunning");

    // Get DLL entry point for the RunNcpDlg API
    //
    m_pfnRunNcpDlg          = (FPNWCFG_RUNNCPDLG_PROC)
            GetProcAddress(m_hlibConfig, "RunNcpDlg");

    // Get DLL entry point for the CommitNcpDlg API
    //
    m_pfnCommitNcpDlg       = (FPNWCFG_COMMITNCPDLG_PROC)
            GetProcAddress(m_hlibConfig, "FCommitNcpDlg");

    // Get DLL entry point for the RemoveNcpServer API
    //
    m_pfnRemoveNcpServer    = (FPNWCFG_REMOVENCPSERVER_PROC)
            GetProcAddress(m_hlibConfig, "RemoveNcpServer");

    // If any of these are bogus, then we need to fail out.
    //
    if (!m_pfnIsSpoolerRunning  || !m_pfnRunNcpDlg ||
        !m_pfnCommitNcpDlg || !m_pfnRemoveNcpServer)
    {
        TraceHr(ttidSFNCfg, FAL, hr, FALSE,
            "Failed to load one of the config DLL functions");
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    TraceHr(ttidSFNCfg, FAL, hr, FALSE, "CSFNCfg::HrLoadConfigDLL()");
    return hr;
}

//---[ CSFNCfg::FreeConfigDLL ]----------------------------------------------
//
//  Free nwcfg.dll, and NULL out the function pointers.
//
//  Parameters - None
//
//-----------------------------------------------------------------------------

VOID CSFNCfg::FreeConfigDLL()
{
    // If we successfully loaded the library, free it.
    if (m_hlibConfig)
    {
        // Free up the library resources.
        FreeLibrary(m_hlibConfig);
        m_hlibConfig = NULL;

        m_pfnIsSpoolerRunning   = NULL;
        m_pfnRunNcpDlg          = NULL;
        m_pfnCommitNcpDlg       = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallFPNWPerfmonCounters
//
//  Purpose:    Install FPNW perfmon counters (what did you think it did?)
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   5 Feb 1998
//
//  Notes:
//
HRESULT HrInstallFPNWPerfmonCounters()
{
    HRESULT             hr      = NOERROR;
    BOOL                fResult = FALSE;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               szIniPath[MAX_PATH+1];
    WCHAR               szCmdLine[MAX_PATH+1];

    ZeroMemory((LPVOID) &si, sizeof(si));

    si.cb = sizeof(STARTUPINFO);

    if (GetSystemDirectory(szIniPath, MAX_PATH+1))
    {
        wsprintfW(szCmdLine, L"lodctr %s\\fpnwperf.ini", szIniPath);

        fResult = CreateProcess(NULL, szCmdLine, NULL, NULL,
                                FALSE, 0, NULL, NULL, &si, &pi);
        if (!fResult)
        {
            hr = HrFromLastWin32Error();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrInstallFPNWPerfmonCounters");
    return hr;

}

HRESULT HrCopySysVolFiles2(INetCfgComponent * pncc, PWSTR pszPath)
{
    TraceFileFunc(ttidSFNCfg);

    HWND hwndParent = GetActiveWindow();

    HRESULT             hr;
    CSetupInfFile       csif;
    PSP_FILE_CALLBACK   pfc;
    PVOID               pvCtx;
    HSPFILEQ            hfq;
    tstring             str;

    // Open the answer file.
    hr = csif.HrOpen(L"netsfn.inf", NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    TraceTag(ttidSFNCfg, "Calling SetupOpenFileQueue");
    hr = HrSetupOpenFileQueue(&hfq);
    if (SUCCEEDED(hr))
    {
        TraceTag(ttidSFNCfg, "Calling HrAddSectionFilesToQueue - Login");
        str = pszPath;
        str += c_szLogin;

        if (!SetupSetDirectoryId(csif.Hinf(), 32768, str.c_str()))
        {
            hr = ::HrFromLastWin32Error();
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidSFNCfg, "Calling SetupInstallFilesFromInfSection - Login");
            hr = HrSetupInstallFilesFromInfSection(csif.Hinf(), NULL, hfq,
                                                   c_szCopyFilesLogin, NULL, 0);
        }

        TraceTag(ttidSFNCfg, "Calling SetupSetDirectoryId - Public");
        str = pszPath;
        str += c_szPublic;
        if (!SetupSetDirectoryId(csif.Hinf(), 32769, str.c_str()))
        {
            hr = ::HrFromLastWin32Error();
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidSFNCfg, "Calling SetupInstallFilesFromInfSection - Public");
            hr = HrSetupInstallFilesFromInfSection(csif.Hinf(), NULL, hfq,
                                                   c_szCopyFilesPublic, NULL, 0);
        }

        // Set the default callback context
        // If the install is quiet, we need to make sure the callback
        // doesn't display UI
        //
        if (SUCCEEDED(hr))
        {
            TraceTag(ttidSFNCfg, "Calling SetupInitDefaultQueueCallbackEx");
            hr = HrSetupInitDefaultQueueCallbackEx(hwndParent, NULL, 0, 0,
                                                   NULL, &pvCtx);
        }

        if (SUCCEEDED(hr))
        {
            // Not doing anything special so use SetupApi default handler
            // for file copy
            pfc = SetupDefaultQueueCallback;

            // Scan the queue to see if the files are already in the
            // destination and if so, ask the user if he/she wants to
            // use what's there (provided we are not doing a quiet install)
            // Note: we only scan the queue if we are not in Gui mode setup
            //
            DWORD dwScanResult;
            TraceTag(ttidSFNCfg, "Scanning queue for validity");
            hr = HrSetupScanFileQueueWithNoCallback(hfq,
                    SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_INFORM_USER,
                    hwndParent, &dwScanResult);

            // Now commit the queue so any files needing to be
            // copied, will be
            //
            if (SUCCEEDED(hr))
            {
                TraceTag(ttidSFNCfg, "Calling SetupCommitFileQueue");
                hr = HrSetupCommitFileQueue(hwndParent, hfq, pfc, pvCtx);
            }

            TraceTag(ttidSFNCfg, "Closing queue");

            // We need to release the default context
            //
            SetupTermDefaultQueueCallback(pvCtx);
        }

        // close the file queue
        //
        SetupCloseFileQueue(hfq);

        // Unregister the copy directories
        //
        SetupSetDirectoryId(csif.Hinf(), 8001, NULL);
        SetupSetDirectoryId(csif.Hinf(), 8002, NULL);
    }

Error:
    TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrCopySysVolFiles2");
    return hr;
}

HRESULT HrCopySysVolFiles(INetCfgComponent * pncc)
{
    HRESULT hr = S_OK;
    HKEY    hkey = NULL;
    PWSTR  psz = NULL;
    PWSTR  pszTmp;

    Assert(NULL != pncc);

    // Open the HKLM "System\\CurrentControlSet\\Services\\FPNW\\Volumes" key
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szFPNWVolumes, KEY_ALL_ACCESS, &hkey);
    if (FAILED(hr))
    {
        TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrCopySysVolFiles - Volumes key open failed");
        goto Error;
    }

    // Get the "Sys" value
    hr = HrRegQueryMultiSzWithAlloc(hkey, c_szSys, &psz);
    if (FAILED(hr) || !psz || !(*psz))
    {
        TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrCopySysVolFiles - Sys value open failed");
        goto Error;
    }

    // Find the "Path=" multi-sz entry
    //
    for (pszTmp = psz; (*pszTmp); pszTmp += wcslen(pszTmp))
    {
        if (0 == _wcsnicmp(pszTmp, c_szPath, wcslen(c_szPath)))
        {
            pszTmp += wcslen(c_szPath);
            break;
        }
    }

    // If the pszPath points to a character then we found the path
    //
    Assert(pszTmp);
    if (*pszTmp)
    {
        hr = HrCopySysVolFiles2(pncc, pszTmp);
    }
    else
    {
        TraceHr(ttidSFNCfg, FAL, HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
                FALSE, "HrCopySysVolFiles - Sys volume path is missing!");
    }

Error:
    RegSafeCloseKey(hkey);
    MemFree(psz);

    // Normalize return code.  File not found can occur if the Volumes key
    // is not present or if the Sys value is missing.  The original NT 4 inf
    // code treated these as acceptable.
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    TraceHr(ttidSFNCfg, FAL, hr, FALSE, "HrCopySysVolFiles");
    return hr;
}

HRESULT CSFNCfg::HrDoConfigDialog()
{
    HRESULT         hr              = S_OK;
    BOOL            fResult         = FALSE;
    BOOL            fConfigChanged  = FALSE;

    fResult = m_pfnRunNcpDlg(NULL, TRUE, &m_pNcpInfoHandle, &fConfigChanged);
    if (!fResult)
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\sfnobj.h ===
//
// S F N O B J . H
//
// Declaration of CSFNCfg and helper functions
//

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"


EXTERN_C const CLSID CLSID_CSfnCfg;


//---[ Typedefs for FPNWCFG functions ]----------------------------------------
//
// Typedefs for the functions that we'll GetProcAddress from the
// NetWare config DLL. We'll use VOID * for the RUNNCPDLG/COMMITNCPDLG because:
//      1:  We don't want to muck with the data ourselves. This makes
//          that a tad easier to enforce.
//      2:  Bringing in an NCP_INFO structure involves a
//          ridiculous amount of header inclusion, including BLT
//          stuff that we should really avoid.

typedef BOOL (PASCAL *FPNWCFG_RUNNCPDLG_PROC)(HWND, BOOL, VOID **, BOOL *);
typedef BOOL (PASCAL *FPNWCFG_COMMITNCPDLG_PROC)(HWND, BOOL, VOID *);
typedef BOOL (PASCAL *FPNWCFG_REMOVENCPSERVER_PROC)(HWND);
typedef BOOL (PASCAL *FPNWCFG_ISSPOOLERRUNNING_PROC)();

//---[ Constants ]-------------------------------------------------------------

const INT   c_iMaxNetWareServerName     =   47;
const INT   c_iMaxNetWarePassword       =   127;
const WCHAR c_dwDefaultTuning           =   3;

//---[ SFNCfg ]----------------------------------------------------------------

class ATL_NO_VTABLE CSFNCfg :
    public CComObjectRoot,
    public CComCoClass<CSFNCfg, &CLSID_CSfnCfg>,
    public INetCfgComponentSetup,
    public INetCfgComponentControl
{
public:
    CSFNCfg();
    ~CSFNCfg();

    BEGIN_COM_MAP(CSFNCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CSFNCfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY(CSFNCfg,
                     L"Microsoft.SFNCfg.1",
                     L"Microsoft.SFNCfg",
                     IDS_DESC_COMOBJ_SFNCFG, THREADFLAGS_BOTH)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();


public:
// Helper functions.
    HRESULT HrCodeFromOldINF();

    // Load and free the config DLL
    HRESULT HrLoadConfigDLL();
    VOID    FreeConfigDLL();

    // FPNW UI parameters.
    DWORD   m_dwTuning;
    WCHAR   m_szSysVol[MAX_PATH+1];
    WCHAR   m_szFPNWServerName[c_iMaxNetWareServerName+1];
    WCHAR   m_szPassword[c_iMaxNetWarePassword+1];

// Private state info
private:
    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};

    INSTALLACTION       m_eInstallAction;
    HINSTANCE           m_hlibConfig;           // From LoadLibrary call.
    INetCfgComponent *  m_pncc;                 // Place to keep my component
    INetCfg *           m_pnc;                  // Place to keep the Netcfg object
    VOID *              m_pNcpInfoHandle;       // Handle to opaque data struct from fpnwcfg
    BOOL                m_fDirty;
    BOOL                m_fAlreadyInstalled;    // TRUE if component is already installed

    FPNWCFG_ISSPOOLERRUNNING_PROC   m_pfnIsSpoolerRunning;
    FPNWCFG_RUNNCPDLG_PROC          m_pfnRunNcpDlg;
    FPNWCFG_REMOVENCPSERVER_PROC    m_pfnRemoveNcpServer;
    FPNWCFG_COMMITNCPDLG_PROC       m_pfnCommitNcpDlg;

    // number of property sheet pages
    enum PAGES
    {
        c_cPages = 2
    };

    // Generic dialog data
    CPropSheetPage *    m_apspObj[c_cPages];// pointer to each of the prop
                                            // sheet page objects

    HRESULT HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages);
    VOID CleanupPropPages(VOID);

    // CheckForSAPExistance removed. See slm logs to revive
    // HRESULT HrCheckForSAPExistance();           // Check to see if SAP is already installed.

    HRESULT HrDoConfigDialog();
    HRESULT HrWriteDefaultSysVol();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "FPNW Network Configuration Object"
#define VER_INTERNALNAME_STR            "sfncfg.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\srvrcfg\resource.h ===
#include <ncres.h>

#define DLG_ServerConfig                2200

#define CHK_Announce                    200
#define RDB_Balance                     201
#define RDB_FileSharing                 202
#define RDB_Minimize                    203
#define RDB_NetApps                     204
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\srvrcfg\srvrdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S R V R D L G . C P P
//
//  Contents:   Dialog box handling for the Server object.
//
//  Notes:
//
//  Author:     danielwe   5 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "srvrdlg.h"
#include "ncreg.h"

static const WCHAR c_szServerParams[] = L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
static const WCHAR c_szLmAnnounce[] = L"Lmannounce";
static const WCHAR c_szSize[] = L"Size";
static const WCHAR c_szMemoryManagement[] = L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management";
static const WCHAR c_szLargeCache[] = L"LargeSystemCache";

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrSetupPropSheets
//
//  Purpose:    Inits the prop sheet page objects and creates the pages to be
//              returned to the installer object.
//
//  Arguments:
//      pahpsp [out]    Array of handles to property sheet pages.
//      cPages [in]     Number of pages.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages)
{
    HRESULT         hr = S_OK;
    HPROPSHEETPAGE *ahpsp = NULL;

    Assert(pahpsp);

    *pahpsp = NULL;

    // Allocate a buffer large enough to hold the handles to all of our
    // property pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                             * cPages);
    if (!ahpsp)
    {
        hr = E_OUTOFMEMORY;
        goto err;
    }

    if (!m_apspObj[0])
    {
        // Allocate each of the CPropSheetPage objects
        m_apspObj[0] = new CServerConfigDlg(this);
    }

    // Create the actual PROPSHEETPAGE for each object.
    ahpsp[0] = m_apspObj[0]->CreatePage(DLG_ServerConfig, 0);

    Assert(SUCCEEDED(hr));

    *pahpsp = ahpsp;

cleanup:
    TraceError("HrSetupPropSheets", hr);
    return hr;

err:
    CoTaskMemFree(ahpsp);
    goto cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::CleanupPropPages
//
//  Purpose:    Loop thru each of the pages and free the objects associated
//              with them.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
VOID CSrvrcfg::CleanupPropPages()
{
    INT     ipage;

    for (ipage = 0; ipage < c_cPages; ipage++)
    {
        delete m_apspObj[ipage];
        m_apspObj[ipage] = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrOpenRegKeys
//
//  Purpose:    Open the various registry keys we'll be working with for the
//              lifetime of our object.
//
//  Arguments:  pnc - An INetCfg interface
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrOpenRegKeys(INetCfg *pnc)
{
    HRESULT     hr = S_OK;

    hr = HrRegOpenKeyBestAccess(HKEY_LOCAL_MACHINE, c_szMemoryManagement,
                                &m_hkeyMM);
    if (FAILED(hr))
        goto err;

err:
    TraceError("CSrvrcfg::HrOpenRegKeys", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrGetRegistryInfo
//
//  Purpose:    Fill our in-memory state with data from the registry.
//
//  Arguments:
//      fInstalling [in]    TRUE if component is being installed, FALSE if
//                          it is just being initialized (already installed)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrGetRegistryInfo(BOOL fInstalling)
{
    HRESULT         hr = S_OK;
    HKEY            hkeyParams;

    // Set reasonable defaults in case the key is missing
    m_sdd.fAnnounce = FALSE;

    if (m_pf == PF_SERVER)
    {
        m_sdd.dwSize = 3;
        m_sdd.fLargeCache = TRUE;
    }
    else
    {
        m_sdd.dwSize = 1;
        m_sdd.fLargeCache = FALSE;
    }

    if (!m_fUpgradeFromWks)
    {
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szServerParams, KEY_READ,
                            &hkeyParams);
        if (SUCCEEDED(hr))
        {
            DWORD   dwSize;

            hr = HrRegQueryDword(hkeyParams, c_szLmAnnounce,
                                 (DWORD *)&m_sdd.fAnnounce);
            if (FAILED(hr))
            {
                if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                {
                    hr = S_OK;
                }
                else
                {
                    goto err;
                }
            }

            hr = HrRegQueryDword(hkeyParams, c_szSize, &dwSize);
            if (FAILED(hr))
            {
                if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                {
                    hr = S_OK;
                }
                else
                {
                    goto err;
                }
            }
            else
            {
                AssertSz(dwSize != 0, "This shouldn't be 0!");
                m_sdd.dwSize = dwSize;
            }

            RegCloseKey(hkeyParams);
        }

        if (!fInstalling)
        {
            // RAID #94442
            // Only read old value if this is not an initial install.
            // We want our default to be written when this is a first time install.

            AssertSz(m_hkeyMM, "No MM registry key??");

            hr = HrRegQueryDword(m_hkeyMM, c_szLargeCache,
                                 (DWORD *) &m_sdd.fLargeCache);
            if (FAILED(hr))
            {
                if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                {
                    hr = S_OK;
                }
                else
                {
                    goto err;
                }
            }
        }
    }
    else
    {
        TraceTag(ttidSrvrCfg, "Upgrading from workstation product so we're "
                 "ignoring the registry read code.");
    }

err:
    TraceError("CSrvrcfg::HrGetRegistryInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrSetRegistryInfo
//
//  Purpose:    Save out our in-memory state to the registry.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrSetRegistryInfo()
{
    HRESULT     hr = S_OK;
    HKEY        hkeyParams;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szServerParams,
                        KEY_ALL_ACCESS, &hkeyParams);
    if (SUCCEEDED(hr))
    {
        hr = HrRegSetDword(hkeyParams, c_szLmAnnounce, m_sdd.fAnnounce);
        if (SUCCEEDED(hr))
        {
            hr = HrRegSetDword(hkeyParams, c_szSize, m_sdd.dwSize);
        }

        RegCloseKey(hkeyParams);
    }

    if (SUCCEEDED(hr))
    {
        AssertSz(m_hkeyMM, "Why is this not open?");

        hr = HrRegSetDword(m_hkeyMM, c_szLargeCache, m_sdd.fLargeCache);
    }

    TraceError("CSrvrcfg::HrSetRegistryInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\srvrcfg\srvrdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S R V R D L G . H
//
//  Contents:   Dialog box handling for the Server object.
//
//  Notes:
//
//  Author:     danielwe   5 Mar 1997
//
//----------------------------------------------------------------------------

#ifndef _SRVRDLG_H
#define _SRVRDLG_H
#pragma once
#include "srvrobj.h"

//
// Server Configuration Dialog
//
class CServerConfigDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CServerConfigDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(RDB_Minimize, OnChange)
        COMMAND_ID_HANDLER(RDB_Balance, OnChange)
        COMMAND_ID_HANDLER(RDB_FileSharing, OnChange)
        COMMAND_ID_HANDLER(RDB_NetApps, OnChange)
        COMMAND_ID_HANDLER(CHK_Announce, OnChange)
    END_MSG_MAP()

    CServerConfigDlg(CSrvrcfg *psc): m_psc(psc) {}

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& Handled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);                        
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnChange(WORD wNotifyCode, WORD wID,
                    HWND hWndCtl, BOOL& bHandled)
    {
        // Simply tell the page changes were made
        SetChangedFlag();
        return 0;
    }

private:
    CSrvrcfg *m_psc;
};

#endif //!_SRVRDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\srvrcfg\srvrhlp.h ===
//This file is used by srvrcfg.rc
//
// Generated by Melissa Simmons, 4-6-99

#define IDH_CHK_Announce 80000104
#define IDH_RDB_Balance 80000101
#define IDH_RDB_FileSharing 80000102
#define IDH_RDB_Minimize 80000100
#define IDH_RDB_NetApps 80000103
#define IDH_DISABLEHELP ((DWORD)-1)



const DWORD g_aHelpIDs_DLG_ServerConfig[]=
{
	IDC_STATIC, IDH_DISABLEHELP,
	CHK_Announce,IDH_CHK_Announce,
	RDB_NetApps,IDH_RDB_NetApps,
	RDB_FileSharing,IDH_RDB_FileSharing,
	RDB_Balance,IDH_RDB_Balance,
	RDB_Minimize,IDH_RDB_Minimize,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\srvrcfg\confgdlg.cpp ===
//
// C O N F G D L G . C P P
//
// Dialog box handling for Server configuration
//
// Author:  danielwe
// Created: 5 Mar 1997
//

#include "pch.h"
#pragma hdrstop

#include "resource.h"
#include "srvrdlg.h"
#include "srvrhlp.h"

extern const WCHAR c_szNetCfgHelpFile[];

LRESULT CServerConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& bHandled)
{
    const SERVER_DLG_DATA * psdd;
    INT                     idd = 0;

    psdd = m_psc->DlgData();
    Assert(psdd);

    switch (psdd->dwSize)
    {
    case 1:
        idd = RDB_Minimize;
        break;
    case 2:
        idd = RDB_Balance;
        break;
    case 3:
        if (psdd->fLargeCache)
        {
            idd = RDB_FileSharing;
        }
        else
        {
            idd = RDB_NetApps;
        }
        break;
    default:
        AssertSz(FALSE, "Invalid Size parameter!");
        break;
    }

    CheckDlgButton(idd, TRUE);
    CheckDlgButton(CHK_Announce, psdd->fAnnounce);

    return TRUE;
}

LRESULT CServerConfigDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    SERVER_DLG_DATA *   psdd;
    static const INT aidd[] =
    {
        RDB_Minimize,
        RDB_Balance,
        RDB_FileSharing,
        RDB_NetApps,
    };
    static const INT cidd = celems(aidd);
    INT         iidd;

    psdd = m_psc->DlgDataRW();
    Assert(psdd);

    // figure out which radio button was selected
    for (iidd = 0; iidd < cidd; iidd++)
    {
        if (IsDlgButtonChecked(aidd[iidd]))
            break;
    }

    AssertSz(iidd < cidd, "Umm. How could a button NOT be selected??");

    // make it 1-based instead of 0-based
    iidd++;

    psdd->fLargeCache = (iidd == 3);
    psdd->dwSize = min(iidd, 3);
    psdd->fAnnounce = IsDlgButtonChecked(CHK_Announce);
    m_psc->SetDirty();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method: CServerConfigDlg::OnContextMenu
//
//  Desc:   Bring up context-sensitive help
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
LRESULT
CServerConfigDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (g_aHelpIDs_DLG_ServerConfig != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)g_aHelpIDs_DLG_ServerConfig);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method: CServerConfigDlg::OnHelp
//
//  Desc:   Bring up context-sensitive help when dragging ? icon over a control
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
//
LRESULT
CServerConfigDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((g_aHelpIDs_DLG_ServerConfig != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_DLG_ServerConfig);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\srvrcfg\srvrobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S R V R O B J . C P P
//
//  Contents:   Implementation of CSrvrcfg and helper functions.
//
//  Notes:
//
//  Author:     danielwe   5 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "srvrobj.h"
#include "ncerror.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "afilestr.h"

static const WCHAR c_szRegKeyServerParams[]     = L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
static const WCHAR c_szRegKeyServerShares[]     = L"System\\CurrentControlSet\\Services\\LanmanServer\\Shares";
static const WCHAR c_szRegKeyServerAutoTuned[]  = L"System\\CurrentControlSet\\Services\\LanmanServer\\AutotunedParameters";

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::CSrvrcfg
//
//  Purpose:    Constructs the CSrvrcfg object.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
CSrvrcfg::CSrvrcfg()
:
    m_hkeyMM(NULL),
    m_fDirty(FALSE),
    m_pncc(NULL),
    m_fOneTimeInstall(FALSE),
    m_fRestoredRegistry(FALSE),
    m_fUpgradeFromWks(FALSE),
    m_fUpgrade(FALSE)
{
    ZeroMemory(&m_apspObj, sizeof(m_apspObj));
    ZeroMemory(&m_sdd, sizeof(m_sdd));
}

//
// INetCfgComponentControl
//

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::Initialize
//
//  Purpose:    Called when we are initialized.
//
//  Arguments:
//      pnccItem    [in]    Component we belong to.
//      pnc         [in]    INetCfg master object if we need it.
//      fInstalling [in]    TRUE if we are being installed, FALSE otherwise.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   22 Mar 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::Initialize(INetCfgComponent* pnccItem, INetCfg *pnc,
                                  BOOL fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    AddRefObj(m_pncc);
    GetProductFlavor(NULL, &m_pf);

    HRESULT hr = HrOpenRegKeys(pnc);
    if (SUCCEEDED(hr))
    {
        hr = HrGetRegistryInfo(fInstalling);
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CSrvrcfg::Initialize", hr);
    return hr;
}

STDMETHODIMP CSrvrcfg::Validate()
{
    return S_OK;
}

STDMETHODIMP CSrvrcfg::CancelChanges()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::Apply
//
//  Purpose:    Called when changes to this component should be applied.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::ApplyRegistryChanges()
{
    HRESULT     hr = S_OK;

    static const WCHAR c_szLicenseSvc[] = L"LicenseService";

    if (m_fUpgrade)
    {
        TraceTag(ttidSrvrCfg, "Upgrading MS_SERVER");

        if (!m_fRestoredRegistry)
        {
            TraceTag(ttidSrvrCfg, "Restoring registry");

            hr = HrRestoreRegistry();
            if (FAILED(hr))
            {
                TraceError("CSrvrcfg::ApplyRegistryChanges - HrRestoreRegistry - non-fatal",
                           hr);
                hr = S_OK;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (m_fDirty)
        {
            hr = HrSetRegistryInfo();
        }

        if (SUCCEEDED(hr))
        {
            if (m_fOneTimeInstall)
            {
                hr = HrChangeServiceStartTypeOptional(c_szLicenseSvc,
                                                      SERVICE_AUTO_START);
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;

                    m_fDirty = FALSE;
                    m_fOneTimeInstall = FALSE;
                }
            }
        }
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CSrvrcfg::ApplyRegistryChanges",
        (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//
// INetCfgComponentSetup
//

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::Install
//
//  Purpose:    Called when this component is being installed
//
//  Arguments:
//      dwSetupFlags [in]   Flags that describe the type of setup
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::Install(DWORD dwSetupFlags)
{
    m_fDirty = TRUE;
    m_fOneTimeInstall = TRUE;

    if (dwSetupFlags & NSF_WINNT_WKS_UPGRADE)
    {
        m_fUpgrade = TRUE;
        m_fUpgradeFromWks = TRUE;
    }
    else if ((dwSetupFlags & NSF_WINNT_SVR_UPGRADE) ||
             (dwSetupFlags & NSF_WINNT_SBS_UPGRADE))
    {
        m_fUpgrade = TRUE;
    }

    return S_OK;
}

STDMETHODIMP CSrvrcfg::Upgrade(DWORD dwSetupFlags,
                               DWORD dwUpgradeFomBuildNo)
{
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::ReadAnswerFile
//
//  Purpose:    Reads the appropriate fields from the given answer file into
//              our in-memory state.
//
//  Arguments:
//      pszAnswerFile     [in] File name of answer file
//      pszAnswerSection [in] Section of answer file to look in
//
//  Returns:    S_OK if successful, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::ReadAnswerFile(PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection)
{
    HRESULT     hr = S_OK;

    if (pszAnswerSection && pszAnswerFile)
    {
        // There's an answer file. We must process it now.
        hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
        if (FAILED(hr))
        {
            TraceError("CSrvrcfg::ReadAnswerFile- Answer file has "
                       "errors. Defaulting all information as if "
                       "answer file did not exist.",
                       NETSETUP_E_ANS_FILE_ERROR);
            hr = S_OK;
        }
    }

    TraceError("CSrvrcfg::ReadAnswerFile", hr);
    return hr;
}

STDMETHODIMP CSrvrcfg::Removing()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrRestoreRegistry
//
//  Purpose:    Restores the contents of the registry for this component
//
//  Arguments:
//      (none)
//
//  Returns:    Win32 error if failed, otherwise S_OK
//
//  Author:     danielwe   8 Aug 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrRestoreRegistry()
{
    HRESULT             hr = S_OK;
    HKEY                hkey;
    TOKEN_PRIVILEGES *  ptpRestore = NULL;
    BOOL                fRestoreSucceeded = FALSE;

    if (!m_strParamsRestoreFile.empty() ||
        !m_strSharesRestoreFile.empty() ||
        !m_strAutoTunedRestoreFile.empty())
    {
        hr = HrEnableAllPrivileges(&ptpRestore);
        if (SUCCEEDED(hr))
        {
            if (!m_strParamsRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServerParams,
                                      KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey, m_strParamsRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CSrvrcfg::HrRestoreRegistry - HrRestoreRegistry for "
                                   "Parameters", hr);
                        hr = S_OK;
                    }
                    else
                    {
                        fRestoreSucceeded = TRUE;
                    }

                    RegCloseKey(hkey);
                }
            }

            if (fRestoreSucceeded)
            {
                // if the restore succeeded, rewrite the values that were blown
                // away by the restore

                static const WCHAR c_szSvcDLLName[]     = L"%SystemRoot%\\System32\\srvsvc.dll";
                static const WCHAR c_szServiceDll[]     = L"ServiceDll";

                HKEY hkResult = NULL;
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServerParams, KEY_ALL_ACCESS, &hkResult);
                if SUCCEEDED(hr)
                {
                    hr = HrRegSetValueEx(hkResult, c_szServiceDll, REG_EXPAND_SZ, (const BYTE *)c_szSvcDLLName, CbOfMultiSzAndTermSafe(c_szSvcDLLName));
                    RegSafeCloseKey(hkResult);
                }

                if FAILED(hr)
                {
                    TraceError("CSrvrcfg::HrRestoreRegistry - HrRestoreRegistry for "
                            "ServiceDll", hr);
                    hr = S_OK;
                }

                static const WCHAR c_szTrkWks[]         = L"TrkWks";
                static const WCHAR c_szTrkSrv[]         = L"TrkSrv";
                static const WCHAR c_szNullSession[]    = L"NullSessionPipes";

                hr = HrRegAddStringToMultiSz(c_szTrkWks,
                                             HKEY_LOCAL_MACHINE,
                                             c_szRegKeyServerParams,
                                             c_szNullSession,
                                             STRING_FLAG_ENSURE_AT_END,
                                             0);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegAddStringToMultiSz(c_szTrkSrv,
                                                 HKEY_LOCAL_MACHINE,
                                                 c_szRegKeyServerParams,
                                                 c_szNullSession,
                                                 STRING_FLAG_ENSURE_AT_END,
                                                 0);
                }

                if (FAILED(hr))
                {
                    TraceError("CSrvrcfg::HrRestoreRegistry - Error replacing "
                               "values for Parameters", hr);
                    hr = S_OK;
                }
            }

            if (!m_strSharesRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServerShares,
                                    KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey, m_strSharesRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CSrvrcfg::HrRestoreRegistry - HrRestoreRegistry for "
                                   "Shares", hr);
                        hr = S_OK;
                    }

                    RegCloseKey(hkey);
                }
            }

            if (!m_strAutoTunedRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServerAutoTuned,
                                    KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey, m_strAutoTunedRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CSrvrcfg::HrRestoreRegistry - HrRestoreRegistry for "
                                   "AutotunedParameters", hr);
                        hr = S_OK;
                    }

                    RegCloseKey(hkey);
                }
            }

            hr = HrRestorePrivileges(ptpRestore);

            delete [] reinterpret_cast<BYTE *>(ptpRestore);

            // Set a flag so we don't do this again if we are applied again
            m_fRestoredRegistry = TRUE;
        }
    }
    else
    {
        TraceTag(ttidSrvrCfg, "WARNING: HrRestoreRegistry() was called without"
                 " ReadAnswerFile() being called!");
    }

    TraceError("CSrvrcfg::HrRestoreRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrProcessAnswerFile
//
//  Purpose:    Handles necessary processing of contents of the answer file.
//
//  Arguments:
//      pszAnswerFile       [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Comma-separated list of sections in the
//                                  file appropriate to this component.
//
//  Returns:    S_OK if successful, setup API error otherwise.
//
//  Author:     danielwe   8 May 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection)
{
    HRESULT         hr = S_OK;
    tstring         strOpt;
    PCWSTR         szOptDefault;
    CSetupInfFile   csif;

    if (m_pf == PF_SERVER)
    {
        szOptDefault = c_szAfMaxthroughputforfilesharing;
    }
    else
    {
        szOptDefault = c_szAfMinmemoryused;
    }

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto err;
    }

    if (m_fUpgrade)
    {
        // Restore portions of the registry based on file names from the answer
        // file

        // Get restore file for "Parameters" key
        hr = csif.HrGetString(pszAnswerSection, c_szAfLmServerParameters,
                              &m_strParamsRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CSrvrcfg::HrProcessAnswerFile - Error restoring "
                       "Parameters key", hr);

            // oh well, just continue
            hr = S_OK;
        }

        // Get restore file for "Shares" key
        hr = csif.HrGetString(pszAnswerSection, c_szAfLmServerShares,
                              &m_strSharesRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CSrvrcfg::HrProcessAnswerFile - Error restoring "
                       "Shares key", hr);

            // oh well, just continue
            hr = S_OK;
        }

        // Get restore file for "AutotunedParameters" key
        hr = csif.HrGetString(pszAnswerSection,
                              c_szAfLmServerAutotunedParameters,
                              &m_strAutoTunedRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CSrvrcfg::HrProcessAnswerFile - Error restoring "
                       "AutotunedParameters key", hr);

            // oh well, just continue
            hr = S_OK;
        }
    }

    // Read contents Opimitzation key
    hr = csif.HrGetString(pszAnswerSection, c_szAfLmServerOptimization,
                          &strOpt);
    if (SUCCEEDED(hr))
    {
		m_fDirty = TRUE;

        if (!lstrcmpiW(strOpt.c_str(), c_szAfMinmemoryused))
        {
            m_sdd.dwSize = 1;
        }
        else if (!lstrcmpiW(strOpt.c_str(), c_szAfBalance))
        {
            m_sdd.dwSize = 2;
        }
        else if (!lstrcmpiW(strOpt.c_str(), c_szAfMaxthroughputforfilesharing))
        {
            m_sdd.dwSize = 3;
            m_sdd.fLargeCache = TRUE;
        }
        else if (!lstrcmpiW(strOpt.c_str(), c_szAfMaxthrouputfornetworkapps))
        {
            m_sdd.dwSize = 3;
            m_sdd.fLargeCache = FALSE;
        }
#ifdef DBG
        else
        {
            // NOTE: Default values for dwSize and fLargeCache will have been set
            // already by registry reading function.

            TraceTag(ttidSrvrCfg, "Unknown Optimization value '%S'. Using default "
                     "'%S'.", strOpt.c_str(), szOptDefault);
        }
#endif
    }

    // Read contents of BroadcastsToLanman2Clients key.
    hr = csif.HrGetStringAsBool(pszAnswerSection, c_szAfBroadcastToClients,
                                &m_sdd.fAnnounce);
    if (FAILED(hr))
    {
        TraceError("CSrvrcfg::HrProcessAnswerFile - Error restoring "
                   "BroadcastsToLanman2Clients key. Using default value"
                   " of FALSE.", hr);

        // oh well, just continue
        hr = S_OK;
    }

err:
    TraceError("CSrvrcfg::HrProcessAnswerFile", hr);
    return hr;
}

//
// INetCfgProperties
//

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::MergePropPages
//
//  Purpose:    Called when this component's properties are about to be
//              brought up.
//
//  Arguments:
//      pdwDefPages   [out] Number of default pages to show.
//      pahpspPrivate [out] Array of property sheet handles to pages that this
//                          component will show.
//      pcPrivate     [out] Number of pages in array.
//      hwndParent    [in]  Parent window for any UI.
//      pszStartPage  [out] Pointer to start page.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::MergePropPages(DWORD *pdwDefPages,
                                      LPBYTE *pahpspPrivate,
                                      UINT *pcPrivate, HWND hwndParent,
                                      PCWSTR *pszStartPage)
{
    HRESULT         hr = S_OK;
    HPROPSHEETPAGE *ahpsp = NULL;

    Validate_INetCfgProperties_MergePropPages(pdwDefPages, pahpspPrivate,
                                              pcPrivate, hwndParent,
                                              pszStartPage);

    // We don't want any default pages to be shown
    *pdwDefPages = 0;

    if (m_pf == PF_WORKSTATION)
    {
        // On workstation product, UI is not shown.
        *pcPrivate = 0;
    }
    else
    {
        hr = HrSetupPropSheets(&ahpsp, c_cPages);
        if (SUCCEEDED(hr))
        {
            *pahpspPrivate = (LPBYTE)ahpsp;
            *pcPrivate = c_cPages;
        }
    }

    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CSrvrcfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CSrvrcfg::ValidateProperties(HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CSrvrcfg::CancelProperties()
{
    return S_OK;
}

STDMETHODIMP CSrvrcfg::ApplyProperties()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::~CSrvrcfg
//
//  Purpose:    Destroys the CSrvrcfg object.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
CSrvrcfg::~CSrvrcfg()
{
    ReleaseObj(m_pncc);

    RegSafeCloseKey(m_hkeyMM);

    CleanupPropPages();

#ifdef DBG
    {
        INT     ipage;

        for (ipage = 0; ipage < c_cPages; ipage++)
        {
            AssertSz(!m_apspObj[ipage], "Prop page object should be NULL!");
        }
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgaddr.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A D D R . C P P
//
//  Contents:   CTcpAddrPage implementation
//
//  Notes:  CTcpAddrPage is the IP Address page
//
//  Author: tongl   5 Nov, 1997
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "dlgaddr.h"

#include "resource.h"
#include "tcpconst.h"
#include "tcperror.h"
#include "tcphelp.h"
#include "tcputil.h"

#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"
#include "ncsvc.h"
#include "ncperms.h"

#include "dlgaddrm.h"
#include "dlgdns.h"
#include "dlgwins.h"
#include "dlgatm.h"
#include "dlgopt.h"
#include "dlgras.h"

CTcpAddrPage::CTcpAddrPage(CTcpipcfg * ptcpip, const DWORD * adwHelpIDs) :
m_pageBackup(ptcpip, g_aHelpIDS_IDD_BACK_UP),
m_hBackupPage(NULL)
{
    Assert(ptcpip);
    m_ptcpip = ptcpip;
    m_adwHelpIDs = adwHelpIDs;
    m_pAdapterInfo = ptcpip->GetConnectionAdapterInfo();

    m_fModified = FALSE;

    m_fPropShtOk = FALSE;
    m_fPropShtModified = FALSE;
    m_fLmhostsFileReset = FALSE;

//IPSec is removed from connection UI       
//    m_fIpsecPolicySet = FALSE;

    m_ConnType = m_ptcpip->GetConnectionType();
    Assert(m_ConnType != CONNECTION_UNSET);

    m_fRasNotAdmin = m_ptcpip->IsRasNotAdmin();

    m_pIpSettingsPage = NULL;
    m_pTcpDnsPage     = NULL;
    m_pTcpWinsPage    = NULL;
    m_pAtmArpcPage    = NULL;
    m_pTcpOptionsPage = NULL;
    m_pTcpRasPage     = NULL;
}

CTcpAddrPage::~CTcpAddrPage()
{
    FreeCollectionAndItem(m_vstrWarnedDupIpList);
}

LRESULT CTcpAddrPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    // limit the field ranges for the address fields
    m_ipAddress.Create(m_hWnd, IDC_IPADDR_IP);
    m_ipAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    m_ipDnsPrimary.Create(m_hWnd, IDC_DNS_PRIMARY);
    m_ipDnsPrimary.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    m_ipDnsSecondary.Create(m_hWnd, IDC_DNS_SECONDARY);
    m_ipDnsSecondary.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    if (m_ConnType == CONNECTION_LAN)
    {
        // these are for Lan connections only
        m_ipSubnetMask.Create(m_hWnd, IDC_IPADDR_SUB);

        m_ipDefGateway.Create(m_hWnd, IDC_IPADDR_GATE);
        m_ipDefGateway.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);
    }

    if (!FHasPermission(NCPERM_AllowAdvancedTCPIPConfig))
    {
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADVANCED), FALSE);
    }

    return 0;
}

LRESULT CTcpAddrPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpAddrPage::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CTcpAddrPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    m_fSetInitialValue = TRUE;
    SetInfo();
    m_fSetInitialValue = FALSE;

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, 0);
    return 0;
}

LRESULT CTcpAddrPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // All error values are loaded and then checked here
    // while all non-error values are checked in OnApply

    BOOL fError = FALSE; // Allow page to lose active status
    HWND hWndFocus = 0;


    // If the ip address and subnet mask on this page mismatch,
    // just raise error and do not update the UI

    if (m_ConnType == CONNECTION_LAN)
    {
        if (m_ipAddress.IsBlank() && !m_ipSubnetMask.IsBlank())
        {

            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                   MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            hWndFocus = (HWND) m_ipAddress;
            fError = TRUE;
        }
        else if (!m_ipAddress.IsBlank() && m_ipSubnetMask.IsBlank())
        {
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NOSUBNET,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            hWndFocus = (HWND) m_ipSubnetMask;
            fError = TRUE;
        }
    }

    if (!m_ipDnsPrimary.IsBlank() && !m_ipDnsSecondary.IsBlank())
    {
        tstring strPrimaryDns;
        tstring strSecondDns;

        m_ipDnsPrimary.GetAddress(&strPrimaryDns);
        m_ipDnsSecondary.GetAddress(&strSecondDns);
        if (strPrimaryDns == strSecondDns)
        {
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_DUP_SECOND_DNS,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            hWndFocus = (HWND) m_ipDnsSecondary;
            fError = TRUE;
        }
    }
    

    // Now, update in memory structure
    if (!fError)
    {
        UpdateInfo();

        if (m_ConnType != CONNECTION_LAN)
        {
            if (!m_pAdapterInfo->m_fEnableDhcp)
            {
                // simply make sure ip address is not empty for RAS connections
                if (!m_pAdapterInfo->m_vstrIpAddresses.size())
                {
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    fError = TRUE;
                }
                else
                {
                    DWORD ardwIp[4];
                    GetNodeNum(m_pAdapterInfo->m_vstrIpAddresses[0]->c_str(), ardwIp);
                    if (ardwIp[0] > c_iIPADDR_FIELD_1_HIGH || ardwIp[0] < c_iIPADDR_FIELD_1_LOW)
                    {
                        IPAlertPrintf(m_hWnd, IDS_INCORRECT_IP_FIELD_1,
                                ardwIp[0],
                                c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

                        hWndFocus = (HWND) m_ipAddress;
                        fError = TRUE;
                    }
                }

            }
        }
        else // for Lan connections
        {
            // Check validate IP address and duplication on each card before
            // allowing the page to lose focus

            IP_VALIDATION_ERR err;
            
            // Validate IP Address for adapter used in this connection
            if ((err = ValidateIp(m_pAdapterInfo)) != ERR_NONE)
            {
                switch(err)
                {
                case ERR_HOST_ALL0:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_HOST_ALL_0,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    break;
                case ERR_HOST_ALL1:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_HOST_ALL_1,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    break;

                case ERR_SUBNET_ALL0:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_SUBNET_ALL_0,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipSubnetMask;
                    break;
                case ERR_NO_IP:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    break;

                case ERR_NO_SUBNET:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NOSUBNET,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipSubnetMask;
                    break;

                case ERR_UNCONTIGUOUS_SUBNET:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_ERROR_UNCONTIGUOUS_SUBNET,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipSubnetMask;
                    break;

                default:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INCORRECT_IPADDRESS,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    break;
                }

                fError = TRUE;
            }

            if ((!fError) && (!m_pAdapterInfo->m_fEnableDhcp))
            {
                // Check ip address duplicates between this adapter and any other
                // enabled LAN adapters in our first memory list

                // same adapter
                if (FHasDuplicateIp(m_pAdapterInfo))
                {
                    // duplicate IP address on same adapter is an error
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_DUPLICATE_IP_ERROR,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    fError = TRUE;
                }

                // different adapter
                if (!fError)
                {
                    // The pvcard is a readonly version of the first memory state
                    const VCARD * pvcard = m_ptcpip->GetConstAdapterInfoVector();
                    int iDupCard;

                    VSTR_ITER iterIpBegin = m_pAdapterInfo->m_vstrIpAddresses.begin();
                    VSTR_ITER iterIpEnd = m_pAdapterInfo->m_vstrIpAddresses.end();
                    VSTR_ITER iterIp = iterIpBegin;

                    for( ; iterIp != iterIpEnd ; ++iterIp)
                    {
                        if ((iDupCard=CheckForDuplicates(pvcard, m_pAdapterInfo, **iterIp)) >=0)
                        {
                            Assert((*pvcard)[iDupCard]->m_guidInstanceId != m_pAdapterInfo->m_guidInstanceId);

                            // duplicate IP address between different adapters is not necessarily an error
                            // we raise a warning(requested by bug# 158578)
                            if (!FAlreadyWarned(**iterIp))
                            {
                                FARPROC pfnHrGetPnpDeviceStatus;
                                HMODULE hNetman;

                                HRESULT hrTmp;
                                NETCON_STATUS   ncStatus = NCS_CONNECTED;

                                hrTmp = HrLoadLibAndGetProc(L"netman.dll", "HrGetPnpDeviceStatus",
                                                            &hNetman, &pfnHrGetPnpDeviceStatus);

                                if (SUCCEEDED(hrTmp))
                                {
                                    hrTmp = (*(PHRGETPNPDEVICESTATUS)pfnHrGetPnpDeviceStatus)(
                                                    &((*pvcard)[iDupCard]->m_guidInstanceId),
                                                    &ncStatus);
                                    FreeLibrary(hNetman);
                                }

                                UINT    uIdMsg = IDS_DUPLICATE_IP_WARNING;

                                if (SUCCEEDED(hrTmp) &&
                                    (NCS_HARDWARE_MALFUNCTION == ncStatus ||
                                     NCS_HARDWARE_NOT_PRESENT == ncStatus))
                                {
                                    // bug 286379, if the dup card is malfunctioning or not physically present,
                                    // we should give a more specific error
                                    uIdMsg = IDS_DUP_MALFUNCTION_IP_WARNING;
                                }

                                //here is the normal case: both cards are functioning
                                if (NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, uIdMsg,
                                         MB_APPLMODAL | MB_ICONINFORMATION | MB_YESNO,
                                         (*iterIp)->c_str(),
                                         (*pvcard)[iDupCard]->m_strDescription.c_str()) == IDYES)
                                {
                                    fError = TRUE; // NOT ok to leave the UI
                                }
                                else
                                {
                                    // user said the dup is ok, don't warn them again
                                    m_vstrWarnedDupIpList.push_back(new tstring((*iterIp)->c_str()));
                                }

                            }
                        }

                        if (fError)
                            break;
                    }
                }
            }
        }

        if (fError) // page not going away, we should update the Ui with what's in memory
            SetInfo();
    }

    //we need to change focus to the control that contains invalidate data
    if (fError && hWndFocus)
        ::SetFocus(hWndFocus);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

LRESULT CTcpAddrPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if(m_fLmhostsFileReset) // if lmhosts has been reset
    {
        m_ptcpip->SetSecondMemoryLmhostsFileReset();
    }

//IPSec is removed from connection UI   
/*  
    if (m_fIpsecPolicySet)
    {
        m_ptcpip->SetSecondMemoryIpsecPolicySet();
    }
*/  

    //Bug 232011, warning the user that the local IP address will be set as the primary DNS
    // server address if DHCP is disabled and DNS server list is empty, if DNS server service
    // is installed.
    if((!m_pAdapterInfo->m_fEnableDhcp) && (m_pAdapterInfo->m_vstrDnsServerList.size() == 0))
    {
        CServiceManager scm;
        CService        svc;
        HRESULT hr = scm.HrOpenService (&svc, c_szSvcDnsServer, NO_LOCK,
                        SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);

        if(SUCCEEDED(hr))
        {
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_TCPIP_DNS_EMPTY,
            MB_OK | MB_APPLMODAL | MB_ICONEXCLAMATION);
        }
    }

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    m_ptcpip->SetSecondMemoryModified();
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CTcpAddrPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpAddrPage::OnDhcpButton(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (!m_pAdapterInfo->m_fEnableDhcp) // if Dhcp was disabled
        {
            // turn on DHCP button and disable the ip and subnet controls
            m_pAdapterInfo->m_fEnableDhcp = TRUE;
            EnableGroup(m_pAdapterInfo->m_fEnableDhcp);

            PageModified();

            FreeCollectionAndItem(m_pAdapterInfo->m_vstrIpAddresses);
            m_ipAddress.ClearAddress();

            if (m_ConnType == CONNECTION_LAN)
            {
                FreeCollectionAndItem(m_pAdapterInfo->m_vstrSubnetMask);
                FreeCollectionAndItem(m_pAdapterInfo->m_vstrDefaultGateway);
                FreeCollectionAndItem(m_pAdapterInfo->m_vstrDefaultGatewayMetric);

                m_ipSubnetMask.ClearAddress();
                m_ipDefGateway.ClearAddress();
            }

        } // if !m_pAdapterInfo->m_fEnableDhcp

        break;
    } // switch

    return 0;
}

LRESULT CTcpAddrPage::OnFixedButton(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                   BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (m_pAdapterInfo->m_fEnableDhcp)
        {
            PageModified();

            // turn off DHCP button and enable the ip and subnet controls
            m_pAdapterInfo->m_fEnableDhcp = FALSE;
            EnableGroup(m_pAdapterInfo->m_fEnableDhcp);
        }
        break;
    } // switch

    return 0;
}

LRESULT CTcpAddrPage::OnDnsDhcp(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        PageModified();

        FreeCollectionAndItem(m_pAdapterInfo->m_vstrDnsServerList);
        m_ipDnsPrimary.ClearAddress();
        m_ipDnsSecondary.ClearAddress();

        EnableStaticDns(FALSE);

        break;
    } // switch

    return 0;
}

LRESULT CTcpAddrPage::OnDnsFixed(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        PageModified();
        EnableStaticDns(TRUE);

        ::SetFocus(GetDlgItem(IDC_DNS_PRIMARY));

        break;
    } // switch

    return 0;
}

LRESULT CTcpAddrPage::OnAdvancedButton(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        BOOL fErr = FALSE;

        if (m_ConnType == CONNECTION_LAN)
        {
            // check inconsistency between ip address & subnet mask
            if (m_ipAddress.IsBlank() && !m_ipSubnetMask.IsBlank())
            {
                NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                ::SetFocus(m_ipAddress);
                fErr = TRUE;
            }
            else if (!m_ipAddress.IsBlank() && m_ipSubnetMask.IsBlank())
            {
                NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NOSUBNET,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                ::SetFocus(m_ipSubnetMask);
                fErr = TRUE;
            }
        }

        if (!m_ipDnsPrimary.IsBlank() && !m_ipDnsSecondary.IsBlank())
        {
            tstring strPrimaryDns;
            tstring strSecondDns;

            m_ipDnsPrimary.GetAddress(&strPrimaryDns);
            m_ipDnsSecondary.GetAddress(&strSecondDns);
            if (strPrimaryDns == strSecondDns)
            {
                NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_DUP_SECOND_DNS,
                                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
                ::SetFocus(m_ipDnsSecondary);
                fErr = TRUE;
            }
        }

        if (!fErr)
        {
            // update our in memory structure with what's in the controls
            UpdateInfo();

            // Bring up the advanced pages
            ADAPTER_INFO adapterInfo;
            adapterInfo = *m_pAdapterInfo;

            GLOBAL_INFO glbInfo;
            glbInfo = *(m_ptcpip->GetGlobalInfo());

            int iRet = DoPropertySheet(&adapterInfo, &glbInfo);

            if (iRet != -1)
            {
                if (m_fPropShtOk && m_fPropShtModified)
                {
                    // Something changed, so mark the page as modified
                    PageModified();

                    // Reset values
                    m_fPropShtOk = FALSE;
                    m_fPropShtModified = FALSE;

                    // Update second memory info structure
                    *m_pAdapterInfo = adapterInfo;

                    GLOBAL_INFO * pGlbInfo = m_ptcpip->GetGlobalInfo();
                    *pGlbInfo = glbInfo;
                }
            }

            // Update the controls with new data
            SetInfo();
        }
        break;
    }

    return 0;
}

//Show or Hide the backup configuration page depend on the 
//current settings of dhcp vs static
void CTcpAddrPage::ShowOrHideBackupPage()
{
    if (IsDlgButtonChecked(IDC_IP_DHCP) || IsDlgButtonChecked(IDC_DNS_DHCP)) 
    {
        //show the backup configuration page
        if (NULL == m_hBackupPage)
        {
            m_hBackupPage = m_pageBackup.CreatePage(IDD_BACK_UP, 0);
            Assert(m_hBackupPage);

            if (m_hBackupPage)
            {
                ::SendMessage(GetParent(), PSM_ADDPAGE, 0, (LPARAM) m_hBackupPage);
            }
        }
    }
    else
    {
        //hide the backup configuration page
        if (NULL != m_hBackupPage)
        {
            ::SendMessage(GetParent(), PSM_REMOVEPAGE, 1, (LPARAM) m_hBackupPage);
            m_hBackupPage = NULL;
        }
    }
}


int CTcpAddrPage::DoPropertySheet(ADAPTER_INFO * pAdapterDlg,
                                  GLOBAL_INFO  * pGlbDlg)
{
    Assert(pAdapterDlg);
    Assert(pGlbDlg);

    HRESULT hr = S_OK;
    int iRet = -1;

    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    // Create property pages
    // ahpsp is allocated memory by CoTaskMemAlloc
    hr = HrSetupPropPages(pAdapterDlg, pGlbDlg, &ahpsp, &cPages);

    if (SUCCEEDED(hr))
    {
        // Show the property sheet
        PROPSHEETHEADER psh = {0};

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_NOAPPLYNOW;
        psh.hwndParent = ::GetActiveWindow();
        psh.hInstance = _Module.GetModuleInstance();
        psh.pszIcon = NULL;
        psh.pszCaption = (PWSTR)SzLoadIds(IDS_TCP_ADV_HEADER);
        psh.nPages = cPages;
        psh.phpage = ahpsp;

        iRet = PropertySheet(&psh);

        if (-1 == iRet)
        {
            DWORD dwError = GetLastError();
            TraceError("CTcpAddrPage::DoPropertySheet", HRESULT_FROM_WIN32(dwError));
        }
    }

    if (m_pIpSettingsPage)
    {
        delete m_pIpSettingsPage;
        m_pIpSettingsPage = NULL;
    }

    if (m_pTcpDnsPage)
    {
        delete m_pTcpDnsPage;
        m_pTcpDnsPage = NULL;
    }

    if (m_pTcpWinsPage)
    {
        delete m_pTcpWinsPage;
        m_pTcpWinsPage = NULL;
    }

    if (m_pAtmArpcPage)
    {
        delete m_pAtmArpcPage;
        m_pAtmArpcPage = NULL;
    }

    if (m_pTcpOptionsPage)
    {
        delete m_pTcpOptionsPage;
        m_pTcpOptionsPage = NULL;
    }
    
    if (m_pTcpRasPage)
    {
        delete m_pTcpRasPage;
        m_pTcpRasPage = NULL;
    }

    if (ahpsp)
        CoTaskMemFree(ahpsp);

    return iRet;
}

HRESULT CTcpAddrPage::HrSetupPropPages( ADAPTER_INFO * pAdapterDlg,
                                        GLOBAL_INFO * pGlbDlg,
                                        HPROPSHEETPAGE ** pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;

    // initialize output parameters
    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    // Set up the property pages
    cPages = 4;
    if (m_ConnType == CONNECTION_LAN)
    {
        m_pIpSettingsPage = new CIpSettingsPage(this, pAdapterDlg,
                                                g_aHelpIDs_IDD_IPADDR_ADV);
        if (m_pIpSettingsPage == NULL)
        {
            CORg(E_OUTOFMEMORY);
        }
    }
    else
    {
        m_pTcpRasPage = new CTcpRasPage(this, pAdapterDlg, g_aHelpIDs_IDD_OPT_RAS);

        if (m_pTcpRasPage == NULL)
        {
            CORg(E_OUTOFMEMORY);
        }
    }

    m_pTcpDnsPage = new CTcpDnsPage(this, pAdapterDlg,
                                    pGlbDlg, g_aHelpIDs_IDD_TCP_DNS);

    m_pTcpWinsPage = new CTcpWinsPage(m_ptcpip, this, pAdapterDlg,
                                      pGlbDlg, g_aHelpIDs_IDD_TCP_WINS);

    if ((m_pTcpDnsPage == NULL) ||
        (m_pTcpWinsPage == NULL))
    {
        CORg(E_OUTOFMEMORY);
    }

    if (pAdapterDlg->m_fIsAtmAdapter)
    {
        m_pAtmArpcPage = new CAtmArpcPage(this, pAdapterDlg,
                                          g_aHelpIDs_IDD_ATM_ARPC);
        if (m_pAtmArpcPage == NULL)
        {
            CORg(E_OUTOFMEMORY);
        }

        cPages++;
    }

    //After removing the IPSec connection UI, there are no options to
    //put in the option tab. So we just go ahead remove it.
    if (!pAdapterDlg->m_fIsRasFakeAdapter)
    {
        m_pTcpOptionsPage = new CTcpOptionsPage(this, pAdapterDlg, pGlbDlg,
                                            g_aHelpIDs_IDD_TCP_OPTIONS);

        if (m_pTcpOptionsPage == NULL)
        {
            CORg(E_OUTOFMEMORY);
        }
    }
    else
    {
        //we remove the option tab for the ras connections
        cPages--;
    }

    // Allocate a buffer large enough to hold the handles to all of our
    // property pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                             * cPages);

    if (!ahpsp)
    {
        CORg(E_OUTOFMEMORY);
    }

    cPages =0;

    if (m_ConnType == CONNECTION_LAN)
    {
        ahpsp[cPages++] = m_pIpSettingsPage->CreatePage(IDD_IPADDR_ADV, 0);
    }
    else
    {
        ahpsp[cPages++] = m_pTcpRasPage->CreatePage(IDD_OPT_RAS, 0);
    }

    ahpsp[cPages++] = m_pTcpDnsPage->CreatePage(IDD_TCP_DNS, 0);
    ahpsp[cPages++] = m_pTcpWinsPage->CreatePage(IDD_TCP_WINS, 0);

    if (pAdapterDlg->m_fIsAtmAdapter)
    {
        ahpsp[cPages++] = m_pAtmArpcPage->CreatePage(IDD_ATM_ARPC, 0);
    }

    if (!pAdapterDlg->m_fIsRasFakeAdapter && m_pTcpOptionsPage)
    {
        ahpsp[cPages++] = m_pTcpOptionsPage->CreatePage(IDD_TCP_OPTIONS, 0);
    }

    *pahpsp = ahpsp;
    *pcPages = cPages;

Error:
    if (FAILED(hr))
    {
        if (m_pIpSettingsPage)
        {
            delete m_pIpSettingsPage;
            m_pIpSettingsPage = NULL;
        }

        if (m_pTcpDnsPage)
        {
            delete m_pTcpDnsPage;
            m_pTcpDnsPage = NULL;
        }

        if (m_pTcpWinsPage)
        {
            delete m_pTcpWinsPage;
            m_pTcpWinsPage = NULL;
        }

        if (m_pAtmArpcPage)
        {
            delete m_pAtmArpcPage;
            m_pAtmArpcPage = NULL;
        }

        if (m_pTcpOptionsPage)
        {
            delete m_pTcpOptionsPage;
            m_pTcpOptionsPage = NULL;
        }

        if (m_pTcpRasPage)
        {
            delete m_pTcpRasPage;
            m_pTcpRasPage = NULL;
        }
        
    }

    return hr;
}

LRESULT CTcpAddrPage::OnIpAddrIp(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnIpAddrSub(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;

    case EN_SETFOCUS:

        // if the subnet mask is blank, create a mask and insert it into
        // the control
        if (!m_ipAddress.IsBlank() && m_ipSubnetMask.IsBlank())
        {
            tstring strSubnetMask;
            tstring strIpAddress;

            m_ipAddress.GetAddress(&strIpAddress);

            // generate the mask and update the control, and internal structure
            GenerateSubnetMask(m_ipAddress, &strSubnetMask);
            m_ipSubnetMask.SetAddress(strSubnetMask.c_str());

            ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrSubnetMask),
                                strSubnetMask.c_str());
        }
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnIpAddrGateway(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnDnsPrimary(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnDnsSecondary(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    switch(idCtrl)
    {
    case IDC_IPADDR_IP:
    case IDC_IPADDR_GATE:
    case IDC_DNS_PRIMARY:
    case IDC_DNS_SECONDARY:

        lpnmipa = (LPNMIPADDRESS) pnmh;

        if (0==lpnmipa->iField)
        {
            iLow  = c_iIPADDR_FIELD_1_LOW;
            iHigh = c_iIPADDR_FIELD_1_HIGH;
        };

        IpCheckRange(lpnmipa, 
                     m_hWnd, 
                     iLow, 
                     iHigh, 
                     (IDC_IPADDR_IP == idCtrl || IDC_IPADDR_GATE == idCtrl));
        break;

    case IDC_IPADDR_SUB:

        lpnmipa = (LPNMIPADDRESS) pnmh;
        IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);
        break;

    default:
        break;
    }

    return 0;
}

void CTcpAddrPage::EnableGroup(BOOL fEnableDhcp)
{
    BOOL fStaticIp = !fEnableDhcp;

    CheckDlgButton(IDC_IP_DHCP,  fEnableDhcp);
    CheckDlgButton(IDC_IP_FIXED, fStaticIp);

    ::EnableWindow(GetDlgItem(IDC_IPADDR_IPTEXT), fStaticIp);
    ::EnableWindow(GetDlgItem(IDC_IPADDR_IP), fStaticIp);

    if (m_ConnType == CONNECTION_LAN)
    {
        ::EnableWindow(GetDlgItem(IDC_IPADDR_SUBTEXT), fStaticIp);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_SUB), fStaticIp);

        ::EnableWindow(GetDlgItem(IDC_IPADDR_GATE), fStaticIp);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_GATETEXT), fStaticIp);
    }

    if (!fEnableDhcp) // enforce DNS address option
    {
        CheckDlgButton(IDC_DNS_DHCP,  FALSE);
        CheckDlgButton(IDC_DNS_FIXED, TRUE);

        ::EnableWindow(GetDlgItem(IDC_DNS_DHCP), FALSE);
        EnableStaticDns(TRUE);
    }
    else
    {
        ::EnableWindow(GetDlgItem(IDC_DNS_DHCP), TRUE);
    }

    if (CONNECTION_LAN == m_ConnType)
    {
        ShowOrHideBackupPage();
    }
}

void CTcpAddrPage::EnableStaticDns(BOOL fUseStaticDns)
{
    ::EnableWindow(GetDlgItem(IDC_DNS_PRIMARY), fUseStaticDns);
    ::EnableWindow(GetDlgItem(IDC_DNS_PRIMARY_TEXT), fUseStaticDns);
    ::EnableWindow(GetDlgItem(IDC_DNS_SECONDARY), fUseStaticDns);
    ::EnableWindow(GetDlgItem(IDC_DNS_SECONDARY_TEXT), fUseStaticDns);
}

// Set info to controls using the data in m_pAdapterInfo
void CTcpAddrPage::SetInfo()
{
    Assert(m_pAdapterInfo);

    // Dhcp Ip address is not allowed when Dhcp server is installed or
    // it is a SLIP connection

    // const GLOBAL_INFO * pglb = m_ptcpip->GetConstGlobalInfo();
    // if ((pglb->m_fDhcpServerInstalled) || (m_ConnType == CONNECTION_RAS_SLIP))

    if (m_ConnType == CONNECTION_RAS_SLIP)
    {
        ::EnableWindow(GetDlgItem(IDC_IP_DHCP), FALSE);
        m_pAdapterInfo->m_fEnableDhcp = 0;
    }

    EnableGroup(m_pAdapterInfo->m_fEnableDhcp);

    // Set Ip address
    if(m_pAdapterInfo->m_fEnableDhcp == 0) //Dhcp disabled, static IP
    {
        tstring strTmp;
        if (fQueryFirstAddress(m_pAdapterInfo->m_vstrIpAddresses, &strTmp))
            m_ipAddress.SetAddress(strTmp.c_str());
        else
            m_ipAddress.ClearAddress();
    }
    else //Dhcp enabled
    {
        m_ipAddress.ClearAddress();
        FreeCollectionAndItem(m_pAdapterInfo->m_vstrIpAddresses);
    }

    // Set Subnet mask and default gateway if Lan connection
    if (m_ConnType == CONNECTION_LAN)
    {
        if(m_pAdapterInfo->m_fEnableDhcp == 0) //Dhcp disabled, static IP
        {
            tstring strTmp;

            if (fQueryFirstAddress(m_pAdapterInfo->m_vstrSubnetMask, &strTmp))
                m_ipSubnetMask.SetAddress(strTmp.c_str());
            else
                m_ipSubnetMask.ClearAddress();

            if (fQueryFirstAddress(m_pAdapterInfo->m_vstrDefaultGateway, &strTmp))
                m_ipDefGateway.SetAddress(strTmp.c_str());
            else
                m_ipDefGateway.ClearAddress();
        }
        else //Dhcp enabled
        {
            m_ipSubnetMask.ClearAddress();
            FreeCollectionAndItem(m_pAdapterInfo->m_vstrSubnetMask);

            tstring strGateway;

            if (fQueryFirstAddress(m_pAdapterInfo->m_vstrDefaultGateway, &strGateway))
                m_ipDefGateway.SetAddress(strGateway.c_str());
            else
                m_ipDefGateway.ClearAddress();
        }
    }

    // Set Dns addresses
    BOOL fUseStaticDns = ((!m_pAdapterInfo->m_fEnableDhcp) ||
                          (m_pAdapterInfo->m_vstrDnsServerList.size() >0));

    CheckDlgButton(IDC_DNS_DHCP,  !fUseStaticDns);
    CheckDlgButton(IDC_DNS_FIXED, fUseStaticDns);

    EnableStaticDns(fUseStaticDns);

    if (fUseStaticDns)
    {
        tstring strTmp;

        if (fQueryFirstAddress(m_pAdapterInfo->m_vstrDnsServerList, &strTmp))
            m_ipDnsPrimary.SetAddress(strTmp.c_str());
        else
            m_ipDnsPrimary.ClearAddress();

        if (fQuerySecondAddress(m_pAdapterInfo->m_vstrDnsServerList, &strTmp))
            m_ipDnsSecondary.SetAddress(strTmp.c_str());
        else
            m_ipDnsSecondary.ClearAddress();
    }
    else
    {
        m_ipDnsPrimary.ClearAddress();
        m_ipDnsSecondary.ClearAddress();
    }
}

// Update info in m_pAdapterInfo with what's in the controls
void CTcpAddrPage::UpdateInfo()
{
    Assert(m_pAdapterInfo);

    if (!m_pAdapterInfo->m_fEnableDhcp) // If DHCP disabled
    {
        tstring strNewAddress;

        // ip address & subnet mask
        if (!m_ipAddress.IsBlank())
        {
            m_ipAddress.GetAddress(&strNewAddress);
            ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrIpAddresses),
                                strNewAddress.c_str());

            if (m_ConnType == CONNECTION_LAN)
            {
                if (m_ipSubnetMask.IsBlank())
                {
                    SendDlgItemMessage(IDC_IPADDR_SUB, WM_SETFOCUS, 0, 0);
                }
                else
                {
                    m_ipSubnetMask.GetAddress(&strNewAddress);
                    ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrSubnetMask),
                                        strNewAddress.c_str());
                }
            }
        }
        else // no ip address
        {
            if (m_ConnType == CONNECTION_LAN)
            {
                if (m_ipSubnetMask.IsBlank())
                {
                    // delete the first ip address and subnet mask
                    if (m_pAdapterInfo->m_vstrIpAddresses.size())
                    {
                        FreeVectorItem(m_pAdapterInfo->m_vstrIpAddresses, 0);

                        if (!m_pAdapterInfo->m_vstrIpAddresses.empty())
                            m_ipAddress.SetAddress(m_pAdapterInfo->m_vstrIpAddresses[0]->c_str());

                        if (m_pAdapterInfo->m_vstrSubnetMask.size())
                        {
                            FreeVectorItem(m_pAdapterInfo->m_vstrSubnetMask, 0);

                            if (!m_pAdapterInfo->m_vstrSubnetMask.empty())
                                m_ipSubnetMask.SetAddress(m_pAdapterInfo->m_vstrSubnetMask[0]->c_str());
                        }
                    }
                }
                else
                {
                    AssertSz(FALSE, "No ip address.");
                }
            }
            else // RAS connection, simply delete IP address
            {
                if (m_pAdapterInfo->m_vstrIpAddresses.size())
                {
                    FreeVectorItem(m_pAdapterInfo->m_vstrIpAddresses, 0);
                }
            }
        }

        // default gateway
        if (m_ConnType == CONNECTION_LAN)
        {
            if (!m_ipDefGateway.IsBlank())
            {
                m_ipDefGateway.GetAddress(&strNewAddress);
                ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrDefaultGateway),
                                    strNewAddress.c_str());
                int iSize = m_pAdapterInfo->m_vstrDefaultGatewayMetric.size();
                if (m_pAdapterInfo->m_vstrDefaultGatewayMetric.size() == 0)
                {
                    WCHAR buf[IP_LIMIT];
                    //if there is no default gateway before (that's the reason metric list is
                    //empty), we add the default metric for it
                    _ltot(c_dwDefaultMetricOfGateway, buf, 10);
                    m_pAdapterInfo->m_vstrDefaultGatewayMetric.push_back(new tstring(buf));
                }
            }
            else
            {
                if (m_pAdapterInfo->m_vstrDefaultGateway.size() >0)
                {
                    FreeVectorItem(m_pAdapterInfo->m_vstrDefaultGateway, 0);

                    if (!m_pAdapterInfo->m_vstrDefaultGateway.empty())
                        m_ipDefGateway.SetAddress(m_pAdapterInfo->m_vstrDefaultGateway[0]->c_str());

                    if (m_pAdapterInfo->m_vstrDefaultGatewayMetric.size() >0)
                        FreeVectorItem(m_pAdapterInfo->m_vstrDefaultGatewayMetric, 0);
                }
            }
        }
    }

    // DNS addresses
    UpdateAddressList(&(m_pAdapterInfo->m_vstrDnsServerList),
                        m_ipDnsPrimary, m_ipDnsSecondary);
}

// Update a vector of strings with values from two IP address
// controls
void CTcpAddrPage::UpdateAddressList(VSTR * pvstrList,
                                     IpControl& ipPrimary,
                                     IpControl& ipSecondary)
{
    tstring str;
    if (pvstrList->size()<=2) // if the list did not have more than two addresses
    {
        // Free the list
        FreeCollectionAndItem(*pvstrList);

        // Insert new addresses if any
        if (!ipPrimary.IsBlank())
        {
            ipPrimary.GetAddress(&str);
            pvstrList->push_back(new tstring(str.c_str()));
        }

        if (!ipSecondary.IsBlank())
        {
            ipSecondary.GetAddress(&str);
            pvstrList->push_back(new tstring(str.c_str()));
        }
    }
    else
    {
        // Replace addresses if they exists
        if (!ipSecondary.IsBlank())
        {
            ipSecondary.GetAddress(&str);
            ReplaceSecondAddress(pvstrList, str.c_str());
        }
        else
        {
            FreeVectorItem(*pvstrList, 1);
        }

        if (!ipPrimary.IsBlank())
        {
            ipPrimary.GetAddress(&str);
            ReplaceFirstAddress(pvstrList, str.c_str());
        }
        else
        {
            FreeVectorItem(*pvstrList, 0);
        }

        //fix Bug 425112: Update the UI if either of the IP control
        //is blank because sometimes UpdateInfo get called twice (which 
        // will make us delete the address twice if we dont update the UI)
        if (ipPrimary.IsBlank() || ipSecondary.IsBlank())
        {   
            if (!pvstrList->empty())
            {
                ipPrimary.SetAddress((*pvstrList)[0]->c_str());
            }

            if (pvstrList->size() >= 2)
            {
                ipSecondary.SetAddress((*pvstrList)[1]->c_str());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\tcpipcfg\dlgaddrm.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A D D R M . C P P
//
//  Contents:   Implementation of CIpsSettingPage, CAddressDialog and
//              CGatewayDialog
//
//  Notes:  CIpSettingsPage is the Advanced IP Addressing dialog
//
//  Author: tongl   5 Nov 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "dlgaddrm.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "resource.h"
#include "tcpconst.h"
#include "tcperror.h"
#include "dlgaddr.h"
#include "tcphelp.h"
#include "tcputil.h"

// CIpSettingsPage
CIpSettingsPage::CIpSettingsPage(CTcpAddrPage * pTcpAddrPage,
                                   ADAPTER_INFO * pAdapterInfo,
                                   const DWORD * adwHelpIDs)
{
    m_pParentDlg = pTcpAddrPage;
    Assert(pTcpAddrPage != NULL);

    Assert(pAdapterInfo != NULL);
    m_pAdapterInfo = pAdapterInfo;

    m_adwHelpIDs = adwHelpIDs;

    m_uiRemovedMetric = c_dwDefaultMetricOfGateway;

    // Initialize internal states
    m_fModified = FALSE;
    m_fEditState = FALSE;
}

CIpSettingsPage::~CIpSettingsPage()
{
}

LRESULT CIpSettingsPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL & fHandled)
{
    WCHAR   szAdd[16];

    // Get the IP address Add and Edit button Text and remove ellipse
    GetDlgItemText(IDC_IPADDR_ADDIP, szAdd, celems(szAdd));
    szAdd[lstrlen(szAdd) - c_cchRemoveCharatersFromEditOrAddButton] = 0;
    m_strAdd = szAdd;

    // Repos the windows relative to the static text at top
    HWND hText = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_IPADDR_TEXT);
    RECT rect;

    if (hText)
    {
        ::GetWindowRect(hText, &rect);
        SetWindowPos(NULL,  rect.left, rect.top-16, 0,0,
                     SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
    }

    m_hIpListView = GetDlgItem(IDC_IPADDR_ADVIP);

    LV_COLUMN lvCol;        // list view column structure
    int index, iNewItem;

    // Calculate column width
    ::GetClientRect(m_hIpListView, &rect);
    int colWidth = (rect.right/c_nColumns);

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column
    lvCol.cx = colWidth;       // width of column in pixels

    // Add the two columns and header text.
    for (index = 0; index < c_nColumns; index++)
    {
        // column header text
        if (0==index) // first column
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_IPADDRESS_TEXT);
        }
        else
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_SUBNET_TXT);
        }

        iNewItem = ListView_InsertColumn(m_hIpListView, index, &lvCol);

        AssertSz((iNewItem == index), "Invalid item inserted to list view !");
    }

    // assign hwnds for controls
    m_hAddIp = GetDlgItem(IDC_IPADDR_ADDIP);
    m_hEditIp = GetDlgItem(IDC_IPADDR_EDITIP);
    m_hRemoveIp = GetDlgItem(IDC_IPADDR_REMOVEIP);

    m_hGatewayListView = GetDlgItem(IDC_IPADDR_GATE);

    // Calculate column width
    ::GetClientRect(m_hGatewayListView, &rect);
    colWidth = (rect.right/c_nColumns);

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column
    lvCol.cx = colWidth;       // width of column in pixels

    // Add the two columns and header text.
    for (index = 0; index < c_nColumns; index++)
    {
        // column header text
        if (0==index) // first column
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_GATEWAY_TEXT);
        }
        else
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_METRIC_TEXT);
        }

        iNewItem = ListView_InsertColumn(m_hGatewayListView, index, &lvCol);
    }
    m_hAddGateway = GetDlgItem(IDC_IPADDR_ADDGATE);
    m_hEditGateway = GetDlgItem(IDC_IPADDR_EDITGATE);
    m_hRemoveGateway = GetDlgItem(IDC_IPADDR_REMOVEGATE);

    SendDlgItemMessage(IDC_IPADDR_METRIC, EM_LIMITTEXT, MAX_METRIC_DIGITS, 0);

    // do this last
    UINT uiMetric = m_pAdapterInfo->m_dwInterfaceMetric;
    if (c_dwDefaultIfMetric == uiMetric)
    {
        CheckDlgButton(IDC_AUTO_METRIC, TRUE);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_METRIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_STATIC_IF_METRIC), FALSE);
    }
    else
    {
        if (uiMetric > MAX_METRIC)
        {
            uiMetric = MAX_METRIC;
        }
        SetDlgItemInt(IDC_IPADDR_METRIC, uiMetric, FALSE);
    }

    SetIpInfo();  // do this before SetGatewayInfo
    SetIpButtons();

    SetGatewayInfo();
    SetGatewayButtons();

    return 0;
}


LRESULT CIpSettingsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CIpSettingsPage::OnHelp(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CIpSettingsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CIpSettingsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    UpdateIpList(); // update the info for the current adapter
    UpdateGatewayList();

    //Validate IP address
    BOOL fError = FALSE;
    UINT uiMetric;
    HWND hFocus = NULL;

    if (IsDlgButtonChecked(IDC_AUTO_METRIC))
    {
        if (m_pAdapterInfo->m_dwInterfaceMetric != c_dwDefaultIfMetric)
        {
            m_pAdapterInfo->m_dwInterfaceMetric = c_dwDefaultIfMetric;
            PageModified();
        }
    }
    else
    {
        uiMetric = GetDlgItemInt(IDC_IPADDR_METRIC, &fError, FALSE);
        if (fError && uiMetric >= 1 && uiMetric <= MAX_METRIC)
        {
            if (m_pAdapterInfo->m_dwInterfaceMetric != uiMetric)
            {
                m_pAdapterInfo->m_dwInterfaceMetric = uiMetric;
                PageModified();
            }
            fError = FALSE;
        }
        else
        {
            TCHAR szBuf[32] = {0};
            wsprintf(szBuf, L"%u", MAX_METRIC);
            
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_METRIC,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK, szBuf);
            hFocus = GetDlgItem(IDC_IPADDR_METRIC);
            fError = TRUE;
        }
    }

    IP_VALIDATION_ERR err = ERR_NONE;
    if ((err = ValidateIp(m_pAdapterInfo)) != ERR_NONE)
    {
        NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, GetIPValidationErrorMessageID(err),
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
        fError = TRUE;
    }


    if ((!fError) && (!m_pAdapterInfo->m_fEnableDhcp))
    {
        // Check ip address duplicates between this adapter and any other
        // enabled LAN adapters in our first memory list

        // same adapter
        if (FHasDuplicateIp(m_pAdapterInfo))
        {
            // duplicate IP address on same adapter is an error
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_DUPLICATE_IP_ERROR,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            fError = TRUE;
        }
    }

    if (fError)
    {
        SetIpInfo();  // do this before SetGatewayInfo due to cache'd data
        SetIpButtons();

        SetGatewayInfo();
        SetGatewayButtons();
    }

    if (fError && hFocus)
    {
        ::SetFocus(hFocus);
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

LRESULT CIpSettingsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    SetModifiedTo(FALSE);  // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CIpSettingsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CIpSettingsPage::OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

void CIpSettingsPage::UpdateIpList()
{
    // update the IP addresses list for the specified adapter
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrIpAddresses);
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrSubnetMask);

    if (m_pAdapterInfo->m_fEnableDhcp)
    {
        TraceTag(ttidTcpip, "[UpdateIpList] adapter %S has Dhcp enabled",
                 m_pAdapterInfo->m_strDescription.c_str());
        return;
    }

    int nlvCount = ListView_GetItemCount(m_hIpListView);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT;

    for (int j=0; j< nlvCount; j++)
    {
        WCHAR buf[IP_LIMIT];
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);

        lvItem.iItem = j;
        lvItem.iSubItem = 0;
        ListView_GetItem(m_hIpListView, &lvItem);

        Assert(buf);
        m_pAdapterInfo->m_vstrIpAddresses.push_back(new tstring(buf));

        lvItem.iItem = j;
        lvItem.iSubItem = 1;
        ListView_GetItem(m_hIpListView, &lvItem);

        Assert(buf);
        m_pAdapterInfo->m_vstrSubnetMask.push_back(new tstring(buf));
    }
}

LRESULT CIpSettingsPage::OnAddIp(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CAddressDialog * pDlgAddr = new CAddressDialog(this, g_aHelpIDs_IDD_IPADDR_ADV_CHANGEIP);

    if (pDlgAddr == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pDlgAddr->m_strNewIpAddress = m_strRemovedIpAddress;
    pDlgAddr->m_strNewSubnetMask = m_strRemovedSubnetMask;

    // See if the address is added
    if (pDlgAddr->DoModal() == IDOK)
    {
        int nCount = ListView_GetItemCount(m_hIpListView);

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.lParam =0;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;

        // IP address
        lvItem.iItem=nCount;
        lvItem.iSubItem=0;
        lvItem.pszText= (PWSTR)(pDlgAddr->m_strNewIpAddress.c_str());
        SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

        // Subnet mask
        lvItem.iItem=nCount;
        lvItem.iSubItem=1;
        lvItem.pszText= (PWSTR)(pDlgAddr->m_strNewSubnetMask.c_str());
        SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_SETITEMTEXT, nCount, (LPARAM)&lvItem);

        SetIpButtons();

        // empty strings, this removes the saved address from RemoveIP
        pDlgAddr->m_strNewIpAddress = L"";
        pDlgAddr->m_strNewSubnetMask = L"";

    }
    m_strRemovedIpAddress = pDlgAddr->m_strNewIpAddress;
    m_strRemovedSubnetMask = pDlgAddr->m_strNewSubnetMask;

    delete pDlgAddr;
    return 0;
}

LRESULT CIpSettingsPage::OnEditIp(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    // get the user selection and allow the user to edit the ip/subnet pair
    int itemSelected = ListView_GetNextItem(m_hIpListView, -1, LVNI_SELECTED);
    
    CAddressDialog * pDlgAddr = new CAddressDialog(this, 
                                        g_aHelpIDs_IDD_IPADDR_ADV_CHANGEIP,
                                        itemSelected);

    pDlgAddr->m_strNewIpAddress = m_strRemovedIpAddress;
    pDlgAddr->m_strNewSubnetMask = m_strRemovedSubnetMask;

    
    if (itemSelected != -1)
    {
        WCHAR buf[IP_LIMIT];

        // save off the removed address and delete if from the listview
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        // Get IP address
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        ListView_GetItem(m_hIpListView, &lvItem);

        pDlgAddr->m_strNewIpAddress = buf;

        // Get Subnet mask
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        ListView_GetItem(m_hIpListView, &lvItem);

        pDlgAddr->m_strNewSubnetMask = buf;

        // See if the address is added
        if (pDlgAddr->DoModal() == IDOK)
        {
            int nCount = ListView_GetItemCount(m_hIpListView);
            Assert(nCount>0);

            LV_ITEM lvItem;

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = itemSelected;

            // IP address
            lvItem.pszText = (PWSTR) pDlgAddr->m_strNewIpAddress.c_str();
            lvItem.iSubItem = 0;
            SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_SETITEM, 0, (LPARAM)&lvItem);

            // Subnet mask
            lvItem.pszText = (PWSTR) pDlgAddr->m_strNewSubnetMask.c_str();
            lvItem.iSubItem = 1;
            SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_SETITEM, 0, (LPARAM)&lvItem);
        }
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT, IDS_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    // don't save this ip/sub pair
    m_strRemovedIpAddress = L"";;
    m_strRemovedSubnetMask = L"";;

    delete pDlgAddr;
    return 0;
}

LRESULT CIpSettingsPage::OnRemoveIp(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    // get the current selected item and remove it
    int itemSelected = ListView_GetNextItem(m_hIpListView, -1,
                                            LVNI_SELECTED);

    if (itemSele