                       to the query.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system. Only remote
                            operations can be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsSuspend
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Suspend cluster operation control on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode control suspended.
        WLBS_ALREADY     => Cluster mode control already suspended.
        WLBS_STOPPED     => Cluster mode was stopped and control suspended.
        WLBS_DRAIN_STOP  => Suspending cluster mode control interrupted ongoing
                           connection draining.

        Cluster-wide:

        WLBS_OK          => Cluster mode control suspended on all hosts.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by at least one member of the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsResume
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Resume cluster operation control on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode control resumed.
        WLBS_ALREADY     => Cluster mode control already resumed.

        Cluster-wide:

        WLBS_OK          => Cluster mode control resumed on all hosts.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsStart
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Start cluster operations on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode started.
        WLBS_ALREADY     => Cluster mode already started.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_DRAIN_STOP  => Starting cluster mode interrupted ongoing connection
                            draining.
        WLBS_BAD_PARAMS  => Could not start cluster mode due to invalid configuration
                            parameters.

        Cluster-wide:

        WLBS_OK          => Cluster mode started on all hosts.
        WLBS_BAD_PARAMS  => Could not start cluster mode on at least one host
                            due to invalid configuration parameters.
        WLBS_SUSPENDED   => If at least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsStop
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE   response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Stop cluster operations on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode stopped.
        WLBS_ALREADY     => Cluster mode already stopped.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_DRAIN_STOP  => Starting cluster mode interrupted ongoing connection
                            draining.

        Cluster-wide:

        WLBS_OK          => Cluster mode stopped on all hosts.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDrainStop
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Enter draining mode on specified host or all cluster hosts. New connections
    will not be accepted. Cluster mode will be stopped when all existing
    connections finish. While draining, host will participate in convergence and
    remain part of the cluster.

    Draining mode can be interrupted by performing WlbsStop or WlbsStart.
    WlbsEnable, WlbsDisable and WlbsDrain commands cannot be executed
    while the host is draining.

    Note that this command is NOT equivalent to doing WlbsDrain with
    WLBS_ALL_PORTS parameter followed by WlbsStop. WlbsDrainStop affects all
    ports, not just the ones specified in the multiple host filtering mode port
    rules.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Host entered draining mode.
        WLBS_ALREADY     => Host is already draining.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_STOPPED     => Cluster mode is already stopped.

        Cluster-wide:

        WLBS_OK          => Draining mode entered on all hosts.
        WLBS_STOPPED     => Cluster mode is already stopped on all hosts.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsEnable
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Enable traffic handling for rule containing the specified port on specified
    host or all cluster hosts. Only rules that are set for multiple host
    filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Port rule enabled.
        WLBS_ALREADY     => Port rule already enabled.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot start handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot enable handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule enabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDisable
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Disable ALL traffic handling for rule containing the specified port on
    specified host or all cluster hosts. Only rules that are set for multiple
    host filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => All traffic handling on the port rule is disabled.
        WLBS_ALREADY     => Port rule already disabled.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot stop handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot stop handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule disabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDrain
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Disable NEW traffic handling for rule containing the specified port on
    specified host or all cluster hosts. Only rules that are set for multiple
    host filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => New traffic handling on the port rule is disabled.
        WLBS_ALREADY     => Port rule already being drained.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot stop handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot stop handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule disabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


/******************************************************************************
    "Sticky" options for remote operations. Parameters set by these routines will
    apply for all subsequent remote cluster control operations for the specified
    cluster. Use WLBS_ALL_CLUSTERS to adjust parameters for all clusters.
 ******************************************************************************/


extern VOID WINAPI WlbsPortSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    WORD            port        /* IN  - UDP port or 0 to revert to the
                                         default (2504). */
);
/*
    Set UDP port that will be used for sending control messages to the cluster.

    returns:
*/


extern VOID WINAPI WlbsPasswordSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    WCHAR*          password    /* IN  - Password or NULL to revert to the
                                         default (no password). */
);
/*
    Set password to be used in the subsequent control messages sent to the
    cluster.

    returns:
*/


extern VOID WINAPI WlbsCodeSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           password    /* IN  - Password or 0 to revert to the
                                         default (no password). */
);
/*
    Set password to be used in the subsequent control messages sent to the
    cluster.

    returns:
*/


extern VOID WINAPI WlbsDestinationSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           dest        /* IN  - Destination address or 0 to revert to
                                         the default (same as the cluster
                                         address specified during control
                                         calls). */
);
/*
    Set the destination address to send cluster control messages to. This
    parameter in only supplied for debugging or special purposes. By default
    all control messages are sent to the cluster primary address specified
    when invoking cluster control routines.

    returns:
*/


extern VOID WINAPI WlbsTimeoutSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           milliseconds /*IN  - Number of milliseconds or 0 to revert
                                         to the default (10 seconds). */
);
/*
    Set number of milliseconds to wait for replies from cluster hosts when
    performing remote operations.

    returns:
*/

DWORD WINAPI WlbsEnumClusters(OUT DWORD* pdwAddresses, OUT DWORD* pdwNum);

DWORD WINAPI WlbsGetAdapterGuid(IN DWORD cluster, OUT GUID* pAdapterGuid);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _WLBSCTRL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\cfgutils.cpp ===
//***************************************************************************
//
//  CFGUTILS.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Low-level utilities to configure NICs -- bind/unbind,
//           get/set IP address lists, and get/set NLB cluster params.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created
//
//***************************************************************************
#include "private.h"
#include <netcfgx.h>
#include <devguid.h>
#include <cfg.h>
#include "..\..\..\inc\wlbsiocl.h"
#include "..\..\..\api\control.h"
#include "cfgutils.tmh"

//
// This magic has the side effect defining "smart pointers"
//  IWbemServicesPtr
//  IWbemLocatorPtr
//  IWbemClassObjectPtr
//  IEnumWbemClassObjectPtr
//  IWbemCallResultPtr
//  IWbemStatusCodeTextPtr
//
// These types automatically call the COM Release function when the
// objects go out of scope.
//
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));

WBEMSTATUS
CfgUtilGetWmiAdapterObjFromAdapterConfigurationObj(
    IN  IWbemClassObjectPtr spObj,              // smart pointer
    OUT  IWbemClassObjectPtr &spAdapterObj      // smart pointer, by reference
    );

WBEMSTATUS
get_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    OUT LPWSTR *ppStringValue
    );

WBEMSTATUS
get_nic_instance(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szNicGuid,
    OUT IWbemClassObjectPtr &sprefObj
    );

WBEMSTATUS
get_multi_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  UINT    MaxStringLen,  // in wchars, INCLUDING space for trailing zeros.
    OUT UINT    *pNumItems,
    OUT LPCWSTR *ppStringValue
    );

WBEMSTATUS
set_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  LPCWSTR szValue
    );

WBEMSTATUS
set_multi_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  UINT    MaxStringLen,  // in wchars, INCLUDING space for trailing zeros.
    IN  UINT    NumItems,
    IN  LPCWSTR pStringValue
    );

//
// This locally-defined class implements interfaces to WMI, NetConfig,
// and low-level NLB APIs.
//
class CfgUtils
{

public:
    
    //
    // Initialization function -- call before using any other functions 
    //
    WBEMSTATUS
    Initialize(
        VOID
        );

    //
    // Deinitialization function -- call after using any other functions
    //
    VOID
    Deinitialize(
        VOID
        );

    //
    // Constructor and distructor. 
    //
    CfgUtils(VOID)
    {
        //
        // WARNING: We do a blanked zero memory initialization of our entire
        // structure. Any other initialization should go into the
        // Initialize() function.
        //
        ZeroMemory(this, sizeof(*this));

        InitializeCriticalSection(&m_Crit);
    }

    ~CfgUtils()
    {
        DeleteCriticalSection(&m_Crit);
    }

    //
    // Check if we're initialized
    //
    BOOL
    IsInitalized(VOID)
    {
        return m_ComInitialized && m_WmiInitialized && m_NLBApisInitialized;
    }

    IWbemStatusCodeTextPtr  m_spWbemStatusIF; // Smart pointer
    IWbemServicesPtr        m_spWbemServiceIF; // Smart pointer
    CWlbsControl            *m_pWlbsControl;

    WBEMSTATUS
    GetClusterFromGuid(
            IN  LPCWSTR szGuid,
            OUT CWlbsCluster **pCluster
            );

private:


    //
    // A single lock serialzes all access.
    // Use mfn_Lock and mfn_Unlock.
    //
    CRITICAL_SECTION m_Crit;

    BOOL m_ComInitialized;
    BOOL m_WmiInitialized;
    BOOL m_NLBApisInitialized;

    
    VOID
    mfn_Lock(
        VOID
        )
    {
        EnterCriticalSection(&m_Crit);
    }

    VOID
    mfn_Unlock(
        VOID
        )
    {
        LeaveCriticalSection(&m_Crit);
    }


};


//
// This class manages NetCfg interfaces
//
class MyNetCfg
{

public:

    MyNetCfg(VOID)
    {
        m_pINetCfg  = NULL;
        m_pLock     = NULL;
    }

    ~MyNetCfg()
    {
        ASSERT(m_pINetCfg==NULL);
        ASSERT(m_pLock==NULL);
    }

    WBEMSTATUS
    Initialize(
        BOOL fWriteLock
        );

    VOID
    Deinitialize(
        VOID
        );


    WBEMSTATUS
    GetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        );

    WBEMSTATUS
    GetNicIF(
        IN  LPCWSTR szNicGuid,
        OUT INetCfgComponent **ppINic
        );

    WBEMSTATUS
    GetBindingIF(
        IN  LPCWSTR                     szComponent,
        OUT INetCfgComponentBindings   **ppIBinding
        );

    typedef enum
    {
        NOOP,
        BIND,
        UNBIND

    } UPDATE_OP;

    WBEMSTATUS
    UpdateBindingState(
        IN  LPCWSTR         szNic,
        IN  LPCWSTR         szComponent,
        IN  UPDATE_OP       Op,
        OUT BOOL            *pfBound
        );

private:

    INetCfg     *m_pINetCfg;
    INetCfgLock *m_pLock;

}; // Class MyNetCfg

//
// We keep a single global instance of this class around currently...
//
CfgUtils g_CfgUtils;


WBEMSTATUS
CfgUtilInitialize(VOID)
{
    return g_CfgUtils.Initialize();
}

VOID
CfgUtilDeitialize(VOID)
{
    return g_CfgUtils.Deinitialize();
}

WBEMSTATUS
CfgUtils::Initialize(
    VOID
    )
{
    WBEMSTATUS Status = WBEM_E_INITIALIZATION_FAILURE;
    HRESULT hr;
    TRACE_INFO(L"-> CfgUtils::Initialize");

    mfn_Lock();

    //
    // Initialize COM
    //
    {
        HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
        if ( FAILED(hr) )
        {
            TRACE_CRIT(L"CfgUtils: Failed to initialize COM library (hr=0x%08lx)", hr);
            goto end;
        }
        m_ComInitialized = TRUE;
    }

    //
    // WMI Initialization
    //
    {
        IWbemLocatorPtr         spWbemLocatorIF = NULL; // Smart pointer

        //
        // Get error text generator interface
        //
        SCODE sc = CoCreateInstance(
                    CLSID_WbemStatusCodeText,
                    0,
                    CLSCTX_INPROC_SERVER,
                    IID_IWbemStatusCodeText,
                    (LPVOID *) &m_spWbemStatusIF
                    );
        if( sc != S_OK )
        {
            ASSERT(m_spWbemStatusIF == NULL); // smart pointer
            TRACE_CRIT(L"CfgUtils: CoCreateInstance IWbemStatusCodeText failure\n");
            goto end;
        }
        TRACE_INFO(L"CfgUtils: m_spIWbemStatusIF=0x%p\n", (PVOID) m_spWbemStatusIF);

        //
        // Get "locator" interface
        //
        hr = CoCreateInstance(
                CLSID_WbemLocator, 0, 
                CLSCTX_INPROC_SERVER, 
                IID_IWbemLocator, 
                (LPVOID *) &spWbemLocatorIF
                );
 
        if (FAILED(hr))
        {
            ASSERT(spWbemLocatorIF == NULL); // smart pointer
            TRACE_CRIT(L"CoCreateInstance  IWebmLocator failed 0x%08lx", (UINT)hr);
            goto end;
        }

        //
        // Get interface to provider for NetworkAdapter class objects
        // on the local machine
        //
        _bstr_t serverPath = L"root\\cimv2";
        hr = spWbemLocatorIF->ConnectServer(
                serverPath,
                NULL, // strUser,
                NULL, // strPassword,
                NULL,
                0,
                NULL,
                NULL,
                &m_spWbemServiceIF
             );
        if (FAILED(hr))
        {
            ASSERT(m_spWbemServiceIF == NULL); // smart pointer
            TRACE_CRIT(L"ConnectServer to cimv2 failed 0x%08lx", (UINT)hr);
            goto end;
        }
        TRACE_INFO(L"CfgUtils: m_spIWbemServiceIF=0x%p\n", (PVOID) m_spWbemServiceIF);

        hr = CoSetProxyBlanket(
                    m_spWbemServiceIF,
                    RPC_C_AUTHN_WINNT,
                    RPC_C_AUTHZ_DEFAULT,      // RPC_C_AUTHZ_NAME,
                    COLE_DEFAULT_PRINCIPAL,   // NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    COLE_DEFAULT_AUTHINFO, // NULL,
                    EOAC_DEFAULT // EOAC_NONE
                    );
        
        if (FAILED(hr))
        {
            TRACE_INFO(L"Error 0x%08lx setting proxy blanket", (UINT) hr);
            goto end;
        }


        //
        // Release locator interface.
        //
        // <NO need to do this explicitly, because this is a smart pointer>
        //
        spWbemLocatorIF = NULL;
        m_WmiInitialized = TRUE;
    }


    //
    // Netconfig Initialization
    //
    {
        // Nothing to do here...
    }

    //
    // WLBS API Initialization
    //
    {
        CWlbsControl *pWlbsControl = NULL;
        pWlbsControl = new CWlbsControl;

        if (pWlbsControl == NULL)
        {
            TRACE_CRIT("Could not initialize wlbs control!");
            goto end;
        }
        DWORD dwRet = pWlbsControl->Initialize();

        if (dwRet == WLBS_INIT_ERROR)
        {
            TRACE_CRIT("Error initializing WLBS Control!");
            delete pWlbsControl;
            pWlbsControl = NULL;
            goto end;
        }
        else
        {
            TRACE_INFO("WlbsControl (0x%p) Initialize returns 0x%08lx",
                    (PVOID) pWlbsControl, dwRet);
        }

        m_pWlbsControl = pWlbsControl;
        m_NLBApisInitialized = TRUE;

    }

    Status = WBEM_NO_ERROR;

end:

    mfn_Unlock();

    if (FAILED(Status))
	{
        TRACE_CRIT("CfgUtil -- FAILING INITIALIZATION! Status=0x%08lx",
            (UINT) Status);
        CfgUtils::Deinitialize();
    }

    TRACE_INFO(L"<- CfgUtils::Initialize(Status=0x%08lx)", (UINT) Status);

    return Status;
}



VOID
CfgUtils::Deinitialize(
    VOID
    )
//
// NOTE: can be called in the context of a failed initialization.
//
{
    TRACE_INFO(L"-> CfgUtils::Deinitialize");

    mfn_Lock();

    //
    // De-initialize WLBS API
    //
    if (m_NLBApisInitialized)
	{
        delete m_pWlbsControl;
        m_pWlbsControl = NULL;
        m_NLBApisInitialized = FALSE;
    }

    //
    // Deinitialize Netconfig
    //

    //
    // Deinitialize WMI
    //
    {
        //
        // Release interface to NetworkAdapter provider
        //
	    if (m_spWbemStatusIF!= NULL)
	    {
	        // Smart pointer.
	        m_spWbemStatusIF= NULL;
	    }

	    if (m_spWbemServiceIF!= NULL)
	    {
	        // Smart pointer.
	        m_spWbemServiceIF= NULL;
	    }

        m_WmiInitialized = FALSE;
    }

    //
    // Deinitialize COM.
    //
    if (m_ComInitialized)
    {
        TRACE_CRIT(L"CfgUtils: Deinitializing COM");
        CoUninitialize();
        m_ComInitialized = FALSE;
    }

    mfn_Unlock();

    TRACE_INFO(L"<- CfgUtils::Deinitialize");
}

WBEMSTATUS
CfgUtils::GetClusterFromGuid(
            IN  LPCWSTR szGuid,
            OUT CWlbsCluster **ppCluster
            )
{
    GUID            Guid;
    WBEMSTATUS      Status      = WBEM_NO_ERROR;
    CWlbsCluster    *pCluster   = NULL;
    GUID AdapterGuid;
    HRESULT hr;

    hr = CLSIDFromString((LPWSTR)szGuid, &Guid);
    if (FAILED(hr))
    {
        TRACE_CRIT(
            "CWlbsControl::Initialize failed at CLSIDFromString %ws",
            szGuid
            );
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    mfn_Lock(); // TODO: This is not really that effective because we still
                // refer to pCluster outside this function.
    g_CfgUtils.m_pWlbsControl->ReInitialize();
    pCluster = m_pWlbsControl->GetClusterFromAdapter(Guid);
    mfn_Unlock();

    if (pCluster == NULL)
    {
        TRACE_CRIT("ERROR: Couldn't find cluster with Nic GUID %ws", szGuid);
        Status = WBEM_E_NOT_FOUND;
        goto end;
    }

    Status      = WBEM_NO_ERROR;

end:

    *ppCluster = pCluster;

    return Status;
}


//
// Gets the list of statically-bound IP addresses for the NIC.
// Sets *pNumIpAddresses to 0 if DHCP
//
WBEMSTATUS
CfgUtilGetIpAddressesAndFriendlyName(
    IN  LPCWSTR szNic,
    OUT UINT    *pNumIpAddresses,
    OUT NLB_IP_ADDRESS_INFO **ppIpInfo, // Free using c++ delete operator.
    OUT LPWSTR *pszFriendlyName // Optional, Free using c++ delete
    )
{
    WBEMSTATUS          Status  = WBEM_NO_ERROR;
    IWbemClassObjectPtr spObj   = NULL;  // smart pointer
    HRESULT             hr;
    LPCWSTR             pAddrs  = NULL;
    LPCWSTR             pSubnets = NULL;
    UINT                AddrCount = 0;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;

    TRACE_INFO(L"-> %!FUNC!(Nic=%ws)", szNic);

    *pNumIpAddresses = NULL;
    *ppIpInfo = NULL;
    if (pszFriendlyName!=NULL)
    {
        *pszFriendlyName = NULL;
    }

    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    //
    // Get WMI instance to specific NIC
    //
    Status = get_nic_instance(
                g_CfgUtils.m_spWbemServiceIF,
                szNic,
                spObj // pass by reference
                );
    if (FAILED(Status))
    {
        ASSERT(spObj == NULL);
        goto end;
    }


    //
    // Extract IP addresses and subnets.
    //
    {
        //
        // This gets the ip addresses in a 2D WCHAR array -- inner dimension
        // is WLBS_MAX_CLI_IP_ADDR.
        //
        Status =  get_multi_string_parameter(
                    spObj,
                    L"IPAddress", // szParameterName,
                    WLBS_MAX_CL_IP_ADDR, // MaxStringLen - in wchars, incl null
                    &AddrCount,
                    &pAddrs
                    );

        if (FAILED(Status))
        {
            pAddrs = NULL;
            goto end;
        }
        else
        {
            TRACE_INFO("GOT %lu IP ADDRESSES!", AddrCount);
        }

        UINT SubnetCount;
        Status =  get_multi_string_parameter(
                    spObj,
                    L"IPSubnet", // szParameterName,
                    WLBS_MAX_CL_NET_MASK, // MaxStringLen - in wchars, incl null
                    &SubnetCount,
                    &pSubnets
                    );

        if (FAILED(Status))
        {
            pSubnets = NULL;
            goto end;
        }
        else if (SubnetCount != AddrCount)
        {
            TRACE_CRIT("FAILING SubnetCount!=AddressCount!");
            goto end;
        }
    }

    //
    // Convert IP addresses to our internal form.
    //
    if (AddrCount != 0)
    {
        pIpInfo = new NLB_IP_ADDRESS_INFO[AddrCount];
        if (pIpInfo == NULL)
        {
            TRACE_CRIT("get_multi_str_parm: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }
        ZeroMemory(pIpInfo, AddrCount*sizeof(*pIpInfo));
        
        for (UINT u=0;u<AddrCount; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // from the 2 2D arrays and insert it into a NLB_IP_ADDRESS_INFO
            // structure.
            //
            LPCWSTR pIp = pAddrs+u*WLBS_MAX_CL_IP_ADDR;
            LPCWSTR pSub = pSubnets+u*WLBS_MAX_CL_NET_MASK;
            TRACE_INFO("IPaddress: %ws; SubnetMask:%ws", pIp, pSub);
            UINT len = wcslen(pIp);
            UINT len1 = wcslen(pSub);
            if ( (len < WLBS_MAX_CL_IP_ADDR) && (len1 < WLBS_MAX_CL_NET_MASK))
            {
                CopyMemory(pIpInfo[u].IpAddress, pIp, (len+1)*sizeof(WCHAR));
                CopyMemory(pIpInfo[u].SubnetMask, pSub, (len1+1)*sizeof(WCHAR));
            }
            else
            {
                //
                // This would be an implementation error in get_multi_string_...
                //
                ASSERT(FALSE);
                Status = WBEM_E_CRITICAL_ERROR;
                goto end;
            }
        }
    }

    //
    // If requested, get friendly name.
    // We don't fail if there's an error, just return the empty "" string.
    //
    if (pszFriendlyName != NULL)
    {
        IWbemClassObjectPtr spAdapterObj   = NULL;  // smart pointer 
        LPWSTR   szFriendlyName  = NULL;
        WBEMSTATUS TmpStatus;

        do
        {
            TmpStatus = CfgUtilGetWmiAdapterObjFromAdapterConfigurationObj(
                            spObj,
                            spAdapterObj // passed by ref
                            );

            if (FAILED(TmpStatus))
            {
                break;
            }

            TmpStatus = CfgUtilGetWmiStringParam(
                            spAdapterObj,
                            L"NetConnectionID",
                            &szFriendlyName
                            );
            if (FAILED(TmpStatus))
            {
                TRACE_CRIT("%!FUNC! Get NetConnectionID failed error=0x%08lx\n",
                            (UINT) TmpStatus);

            }

        }  while (FALSE);


        if (szFriendlyName == NULL)
        {
            //
            // Try to put an empty string.
            //
            szFriendlyName = new WCHAR[1];
            if (szFriendlyName == NULL)
            {
                Status = WBEM_E_OUT_OF_MEMORY;
                TRACE_CRIT("%!FUNC! Alloc failure!");
                goto end;
            }
            *szFriendlyName = 0; // Empty string
        }

        *pszFriendlyName = szFriendlyName;
        szFriendlyName = NULL;
    }

end:

    if (pAddrs != NULL)
    {
        delete pAddrs;
    }
    if (pSubnets != NULL)
    {
        delete pSubnets;
    }

    if (FAILED(Status))
    {
        if (pIpInfo != NULL)
        {
            delete pIpInfo;
            pIpInfo = NULL;
        }
        AddrCount = 0;
    }

    *pNumIpAddresses = AddrCount;
    *ppIpInfo = pIpInfo;
    spObj   = NULL;  // smart pointer

    TRACE_INFO(L"<- %!FUNC!(Nic=%ws) returns 0x%08lx", szNic, (UINT) Status);

    return Status;
}

#if OBSOLETE
//
// Sets the list of statically-bound IP addresses for the NIC.
// if NumIpAddresses is 0, the NIC is configured for DHCP.
//
WBEMSTATUS
CfgUtilSetStaticIpAddressesOld(
    IN  LPCWSTR szNic,
    IN  UINT    NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemClassObjectPtr spNicClassObj   = NULL;  // smart pointer
    IWbemClassObjectPtr      spWbemInputInstance = NULL; // smart pointer
    HRESULT             hr;
    WCHAR *rgIpAddresses = NULL;
    WCHAR *rgIpSubnets   = NULL;
    LPWSTR             pRelPath = NULL;

    TRACE_INFO(L"-> %!FUNC!(Nic=%ws)", szNic);

    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    if (NumIpAddresses != 0)
    {
        //
        // Convert IP addresses from our internal form into 2D arrays.
        //
        rgIpAddresses = new WCHAR[NumIpAddresses * WLBS_MAX_CL_IP_ADDR];
        rgIpSubnets   = new WCHAR[NumIpAddresses * WLBS_MAX_CL_NET_MASK];
        if (rgIpAddresses == NULL ||  rgIpSubnets == NULL)
        {
            TRACE_CRIT("SetStaticIpAddresses: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }

        for (UINT u=0;u<NumIpAddresses; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // from the 2 2D arrays and insert it into a NLB_IP_ADDRESS_INFO
            // structure.
            //
            LPWSTR pIpDest  = rgIpAddresses+u*WLBS_MAX_CL_IP_ADDR;
            LPWSTR pSubDest = rgIpSubnets+u*WLBS_MAX_CL_NET_MASK;
            LPCWSTR pIpSrc  = pIpInfo[u].IpAddress;
            LPCWSTR pSubSrc = pIpInfo[u].SubnetMask;
            UINT len = wcslen(pIpSrc);
            UINT len1 = wcslen(pSubSrc);
            if ( (len < WLBS_MAX_CL_IP_ADDR) && (len1 < WLBS_MAX_CL_NET_MASK))
            {
                CopyMemory(pIpDest, pIpSrc, (len+1)*sizeof(WCHAR));
                CopyMemory(pSubDest, pSubSrc, (len1+1)*sizeof(WCHAR));
            }
            else
            {
                //
                // This would be an implementation error in get_multi_string_...
                //
                ASSERT(FALSE);
                goto end;
            }
        }
    }


    //
    // Get WMI path to specific NIC
    //
    {
        IWbemClassObjectPtr spNicObj   = NULL;  // smart pointer
        pRelPath = NULL;
        Status = get_nic_instance(
                    g_CfgUtils.m_spWbemServiceIF,
                    szNic,
                    spNicObj // pass by reference
                    );
        if (FAILED(Status))
        {
            ASSERT(spObj == NULL);
            goto end;
        }

        //
        // Extract the relative path, needed for ExecMethod.
        //
        Status =  get_string_parameter(
                    spNicObj,
                    L"__RELPATH", // szParameterName
                    &pRelPath  // Delete when done.
                    );
        if (FAILED(Status))
        {
            TRACE_CRIT("Couldn't get rel path");
            pRelPath = NULL;
            goto end;
        }
        else
        {
            if (pRelPath==NULL)
            {
                ASSERT(FALSE); // we don't expect this!
                goto end;
            }
            TRACE_CRIT("GOT RELATIVE PATH for %ws: %ws", szNic, pRelPath);
        }
    }

    //
    // Get NIC CLASS object
    //
    {
        hr = g_CfgUtils.m_spWbemServiceIF->GetObject(
                        _bstr_t(L"Win32_NetworkAdapterConfiguration"),
                        0,
                        NULL,
                        &spNicClassObj,
                        NULL
                        );

        if (FAILED(hr))
        {
            TRACE_CRIT("Couldn't get nic class object pointer");
            goto end;
        }
    }

    //
    // Set up input parameters to the call to Enable static.
    //
    {
        IWbemClassObjectPtr      spWbemInput = NULL; // smart pointer


        // check if any input parameters specified.
    
        hr = spNicClassObj->GetMethod(
                        L"EnableStatic",
                        0,
                        &spWbemInput,
                        NULL
                        );
        if( FAILED( hr) )
        {
            TRACE_CRIT("IWbemClassObject::GetMethod failure");
            goto end;
        }
            
        hr = spWbemInput->SpawnInstance( 0, &spWbemInputInstance );
        if( FAILED( hr) )
        {
            TRACE_CRIT("IWbemClassObject::SpawnInstance failure. Unable to spawn instance." );
            goto end;
        }
    
        //
        // This gets the ip addresses in a 2D WCHAR array -- inner dimension
        // is WLBS_MAX_CLI_IP_ADDR.
        //
        Status =  set_multi_string_parameter(
                    spWbemInputInstance,
                    L"IPAddress", // szParameterName,
                    WLBS_MAX_CL_IP_ADDR, // MaxStringLen - in wchars, incl null
                    NumIpAddresses,
                    rgIpAddresses
                    );

        if (FAILED(Status))
        {
            goto end;
        }
        else
        {
            TRACE_INFO("SET %lu IP ADDRESSES!", NumIpAddresses);
        }

        Status =  set_multi_string_parameter(
                    spWbemInputInstance,
                    L"SubnetMask", // szParameterName,
                    WLBS_MAX_CL_NET_MASK, // MaxStringLen - in wchars, incl null
                    NumIpAddresses,
                    rgIpSubnets
                    );

        if (FAILED(Status))
        {
            goto end;
        }
    }


    //
    // execute method and get the output result
    // WARNING: we try this a few times because the wmi call apperears to
    // suffer from a recoverable error. TODO: Need to get to the bottom of
    // this.
    //
    for (UINT NumTries=10; NumTries--;)
    {
        IWbemClassObjectPtr      spWbemOutput = NULL; // smart pointer.
        _variant_t v_retVal;

        TRACE_CRIT("Going to call EnableStatic");

        hr = g_CfgUtils.m_spWbemServiceIF->ExecMethod(
                     _bstr_t(pRelPath),
                     L"EnableStatic",
                     0, 
                     NULL, 
                     spWbemInputInstance,
                     &spWbemOutput, 
                     NULL
                     );                          
        TRACE_CRIT("EnableStatic returns");
    
        if( FAILED( hr) )
        {
            TRACE_CRIT("IWbemServices::ExecMethod failure 0x%08lx", (UINT) hr);
            goto end;
        }

        hr = spWbemOutput->Get(
                    L"ReturnValue",
                     0,
                     &v_retVal,
                     NULL,
                     NULL
                     );
        if( FAILED( hr) )
        {
            TRACE_CRIT("IWbemClassObject::Get failure");
            goto end;
        }

        LONG lRet = (LONG) v_retVal;
        v_retVal.Clear();

        if (lRet == 0)
        {
            TRACE_INFO("EnableStatic returns SUCCESS!");
            Status = WBEM_NO_ERROR;
            break;
        }
        else if (lRet == 0x51) // This appears to be a recoverable error
        {
            TRACE_INFO(
                "EnableStatic on NIC %ws returns recoverable FAILURE:0x%08lx!",
                szNic,
                lRet
                );
            Sleep(1000);
            Status = WBEM_E_CRITICAL_ERROR;
        }
        else
        {
            TRACE_INFO(
                "EnableStatic on NIC %ws returns FAILURE:0x%08lx!",
                szNic,
                lRet
                );
            Status = WBEM_E_CRITICAL_ERROR;
        }
    }

end:

    if (rgIpAddresses != NULL)
    {
        delete  rgIpAddresses;
    }
    if (rgIpSubnets   != NULL)
    {
        delete  rgIpSubnets;
    }

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    spNicClassObj   = NULL;  // smart pointer
    spWbemInputInstance = NULL;

    TRACE_INFO(L"<- %!FUNC!(Nic=%ws) returns 0x%08lx", szNic, (UINT) Status);

    return Status;
}
#endif // OBSOLETE

//
// Sets the list of statically-bound IP addresses for the NIC.
// if NumIpAddresses is 0, the NIC is configured for DHCP.
//
WBEMSTATUS
CfgUtilSetStaticIpAddresses(
    IN  LPCWSTR szNic,
    IN  UINT    NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemClassObjectPtr      spWbemInputInstance = NULL; // smart pointer
    WCHAR *rgIpAddresses = NULL;
    WCHAR *rgIpSubnets   = NULL;
    LPWSTR             pRelPath = NULL;

    TRACE_INFO(L"-> %!FUNC!(Nic=%ws)", szNic);

    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    if (NumIpAddresses != 0)
    {
        //
        // Convert IP addresses from our internal form into 2D arrays.
        //
        rgIpAddresses = new WCHAR[NumIpAddresses * WLBS_MAX_CL_IP_ADDR];
        rgIpSubnets   = new WCHAR[NumIpAddresses * WLBS_MAX_CL_NET_MASK];
        if (rgIpAddresses == NULL ||  rgIpSubnets == NULL)
        {
            TRACE_CRIT("SetStaticIpAddresses: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }

        for (UINT u=0;u<NumIpAddresses; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // from the 2 2D arrays and insert it into a NLB_IP_ADDRESS_INFO
            // structure.
            //
            LPWSTR pIpDest  = rgIpAddresses+u*WLBS_MAX_CL_IP_ADDR;
            LPWSTR pSubDest = rgIpSubnets+u*WLBS_MAX_CL_NET_MASK;
            LPCWSTR pIpSrc  = pIpInfo[u].IpAddress;
            LPCWSTR pSubSrc = pIpInfo[u].SubnetMask;
            UINT len = wcslen(pIpSrc);
            UINT len1 = wcslen(pSubSrc);
            if ( (len < WLBS_MAX_CL_IP_ADDR) && (len1 < WLBS_MAX_CL_NET_MASK))
            {
                CopyMemory(pIpDest, pIpSrc, (len+1)*sizeof(WCHAR));
                CopyMemory(pSubDest, pSubSrc, (len1+1)*sizeof(WCHAR));
            }
            else
            {
                //
                // This would be an implementation error in get_multi_string_...
                //
                ASSERT(FALSE);
                goto end;
            }
        }
    }

    //
    // Get input instance and relpath...
    //
    Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    g_CfgUtils.m_spWbemServiceIF,
                    L"Win32_NetworkAdapterConfiguration", // szClassName
                    L"SettingID",               // szPropertyName
                    szNic,                      // szPropertyValue
                    L"EnableStatic",            // szMethodName,
                    spWbemInputInstance,        // smart pointer
                    &pRelPath                   // free using delete 
                    );

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Set up input parameters to the call to Enable static.
    //
    {
    
        //
        // This gets the ip addresses in a 2D WCHAR array -- inner dimension
        // is WLBS_MAX_CLI_IP_ADDR.
        //
        Status =  set_multi_string_parameter(
                    spWbemInputInstance,
                    L"IPAddress", // szParameterName,
                    WLBS_MAX_CL_IP_ADDR, // MaxStringLen - in wchars, incl null
                    NumIpAddresses,
                    rgIpAddresses
                    );

        if (FAILED(Status))
        {
            goto end;
        }
        else
        {
            TRACE_INFO("SET %lu IP ADDRESSES!", NumIpAddresses);
        }

        Status =  set_multi_string_parameter(
                    spWbemInputInstance,
                    L"SubnetMask", // szParameterName,
                    WLBS_MAX_CL_NET_MASK, // MaxStringLen - in wchars, incl null
                    NumIpAddresses,
                    rgIpSubnets
                    );

        if (FAILED(Status))
        {
            goto end;
        }
    }


    //
    // execute method and get the output result
    // WARNING: we try this a few times because the wmi call apperears to
    // suffer from a recoverable error. TODO: Need to get to the bottom of
    // this.
    //
    for (UINT NumTries=10; NumTries--;)
    {
        HRESULT hr;
        IWbemClassObjectPtr      spWbemOutput = NULL; // smart pointer.
        _variant_t v_retVal;

        TRACE_CRIT("Going to call EnableStatic");

        hr = g_CfgUtils.m_spWbemServiceIF->ExecMethod(
                     _bstr_t(pRelPath),
                     L"EnableStatic",
                     0, 
                     NULL, 
                     spWbemInputInstance,
                     &spWbemOutput, 
                     NULL
                     );                          
        TRACE_CRIT("EnableStatic returns");
    
        if( FAILED( hr) )
        {
            TRACE_CRIT("IWbemServices::ExecMethod failure 0x%08lx", (UINT) hr);
            goto end;
        }

        hr = spWbemOutput->Get(
                    L"ReturnValue",
                     0,
                     &v_retVal,
                     NULL,
                     NULL
                     );
        if( FAILED( hr) )
        {
            TRACE_CRIT("IWbemClassObject::Get failure");
            goto end;
        }

        LONG lRet = (LONG) v_retVal;
        v_retVal.Clear();

        if (lRet == 0)
        {
            TRACE_INFO("EnableStatic returns SUCCESS!");
            Status = WBEM_NO_ERROR;
            break;
        }
        else if (lRet == 0x51) // This appears to be a recoverable error
        {
            TRACE_INFO(
                "EnableStatic on NIC %ws returns recoverable FAILURE:0x%08lx!",
                szNic,
                lRet
                );
            Sleep(1000);
            Status = WBEM_E_CRITICAL_ERROR;
        }
        else
        {
            TRACE_INFO(
                "EnableStatic on NIC %ws returns FAILURE:0x%08lx!",
                szNic,
                lRet
                );
            Status = WBEM_E_CRITICAL_ERROR;
        }
    }

end:

    if (rgIpAddresses != NULL)
    {
        delete  rgIpAddresses;
    }
    if (rgIpSubnets   != NULL)
    {
        delete  rgIpSubnets;
    }

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    spWbemInputInstance = NULL;

    TRACE_INFO(L"<- %!FUNC!(Nic=%ws) returns 0x%08lx", szNic, (UINT) Status);

    return Status;
}

//
// Determines whether NLB is bound to the specified NIC.
//
WBEMSTATUS
CfgUtilCheckIfNlbBound(
    IN  LPCWSTR szNic,
    OUT BOOL *pfBound
    )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    MyNetCfg NetCfg;
    BOOL fBound = FALSE;


    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(FALSE); // FALSE == don't get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    //
    //
    Status =  NetCfg.UpdateBindingState(
                            szNic,
                            L"ms_wlbs",
                            MyNetCfg::NOOP,
                            &fBound
                            );

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    *pfBound = fBound;

    return Status;
}


//
// Binds/unbinds NLB to the specified NIC.
//
WBEMSTATUS
CfgUtilChangeNlbBindState(
    IN  LPCWSTR szNic,
    IN  BOOL fBind
    )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    MyNetCfg NetCfg;
    BOOL fBound = FALSE;


    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(TRUE); // TRUE == get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    //
    //
    Status =  NetCfg.UpdateBindingState(
                            szNic,
                            L"ms_wlbs",
                            fBind ? MyNetCfg::BIND : MyNetCfg::UNBIND,
                            &fBound
                            );

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    return Status;
}



//
// Gets the current NLB configuration for the specified NIC
//
WBEMSTATUS
CfgUtilGetNlbConfig(
    IN  LPCWSTR szNic,
    OUT WLBS_REG_PARAMS *pParams
    )
{
    GUID Guid;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    CWlbsCluster *pCluster = NULL;

    // g_CfgUtils.mfn_Lock(); // Because pCluster is not protected...

    Status = g_CfgUtils.GetClusterFromGuid(
                            szNic,
                            &pCluster
                            );
    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Read the configuration.
    //
    DWORD dwRet = pCluster->ReadConfig(pParams);
    if (dwRet != WLBS_OK)
    {
        TRACE_CRIT("Could not read NLB configuration for %wsz", szNic);
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    // g_CfgUtils.mfn_Unlock();

    return Status;
}

//
// Sets the current NLB configuration for the specified NIC. This
// includes notifying the driver if required.
//
WBEMSTATUS
CfgUtilSetNlbConfig(
    IN  LPCWSTR szNic,
    IN  WLBS_REG_PARAMS *pParams
    )
{
    GUID Guid;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    CWlbsCluster *pCluster = NULL;
    DWORD dwRet = 0;

    // NOTE: we assume pCluster won't go away -- i.e. no one is trying
    // to unbind in this process' context.
    // someone else remove it say fron netconfig UI?

    Status = g_CfgUtils.GetClusterFromGuid(
                            szNic,
                            &pCluster
                            );
    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Write the configuration.
    //
    dwRet = pCluster->WriteConfig(pParams);
    if (dwRet != WLBS_OK)
    {
        TRACE_CRIT("Could not write NLB configuration for %wsz. Err=0x%08lx",
             szNic, dwRet);
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    //
    // Commit the changes.
    //
    dwRet = pCluster->CommitChanges(g_CfgUtils.m_pWlbsControl);
    if (dwRet != WLBS_OK)
    {
        TRACE_CRIT("Could not commit changes to NLB configuration for %wsz. Err=0x%08lx",
             szNic, dwRet);
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    return Status;
}



WBEMSTATUS
CfgUtilsAnalyzeNlbUpdate(
    IN  WLBS_REG_PARAMS *pCurrentParams, OPTIONAL
    IN  WLBS_REG_PARAMS *pNewParams,
    OUT BOOL *pfConnectivityChange
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    BOOL fConnectivityChange = FALSE;


    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC! FAILING because uninitialized");
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    if (pCurrentParams != NULL)
    {
        //
        // If the structures have identical content, we return S_FALSE.
        // We do this check before we call ValidateParm below, because
        // ValidateParam has the side effect of filling out / modifying
        // certain fields.
        //
        if (memcmp(pCurrentParams, pNewParams, sizeof(*pCurrentParams))==0)
        {
            Status = WBEM_S_FALSE;
            goto end;
        }
    }

    //
    // Validate pNewParams -- this may also modify pNewParams slightly, by
    // re-formatting ip addresses into canonical format.
    //
    BOOL fRet = g_CfgUtils.m_pWlbsControl->ValidateParam(pNewParams);
    if (!fRet)
    {
        TRACE_CRIT(L"%!FUNC!FAILING because New params are invalid");
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    Status = WBEM_NO_ERROR;

    if (pCurrentParams == NULL)
    {
        //
        // NLB was not previously bound.
        //
        fConnectivityChange = TRUE;
        goto end;
    }

    //
    // Change in multicast modes or mac address.
    //
    if (    (pCurrentParams->mcast_support != pNewParams->mcast_support)
         || _wcsicmp(pCurrentParams->cl_mac_addr, pNewParams->cl_mac_addr)!=0)
    {
        fConnectivityChange = TRUE;
    }

    //
    // Change in primary cluster ip or subnet mask
    //
    if (   _wcsicmp(pCurrentParams->cl_ip_addr,pNewParams->cl_ip_addr)!=0
        || _wcsicmp(pCurrentParams->cl_net_mask,pNewParams->cl_net_mask)!=0)
    {
        fConnectivityChange = TRUE;
    }


end:
    *pfConnectivityChange = fConnectivityChange;
    return Status;
}


WBEMSTATUS
CfgUtilsValidateNicGuid(
    IN LPCWSTR szGuid
    )
//
//
{
    //
    // Sample GUID: {EBE09517-07B4-4E88-AAF1-E06F5540608B}
    //
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    UINT Length = wcslen(szGuid);

    if (Length != NLB_GUID_LEN)
    {
        TRACE_CRIT("Length != %d", NLB_GUID_LEN);
        goto end;
    }

    //
    // Open tcpip's registry key and look for guid there -- if not found,
    // we'll return WBEM_E_NOT_FOUND
    //
    {
        WCHAR szKey[128]; // This is enough for the tcpip+guid key
    
        wcscpy(szKey, 
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"
        );
        wcscat(szKey, szGuid);
        HKEY hKey = NULL;
        LONG lRet;
        lRet = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, // handle to an open key
                szKey,              // address of subkey name
                0,                  // reserved
                KEY_QUERY_VALUE,    // desired security access
                &hKey              // address of buffer for opened handle
                );
        if (lRet != ERROR_SUCCESS)
        {
            TRACE_CRIT("Guid %ws doesn't exist under tcpip", szGuid);
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
        RegCloseKey(hKey);
    }

    Status = WBEM_NO_ERROR;

end:

    return Status;
}


WBEMSTATUS
get_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    OUT LPWSTR *ppStringValue
    )
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    WCHAR *pStringValue = NULL;
    _variant_t   v_value;
    CIMTYPE      v_type;
    HRESULT hr;

    hr = spObj->Get(
            _bstr_t(szParameterName), // Name
            0,                     // Reserved, must be 0     
            &v_value,               // Place to store value
            &v_type,                // Type of value
            NULL                   // Flavor (unused)
            );
   if (FAILED(hr))
   {
        // Couldn't read the Setting ID field!
        //
        TRACE_CRIT(
            "get_str_parm:Couldn't retrieve %ws from 0x%p",
            szParameterName,
            (PVOID) spObj
            );
        goto end;
   }
   else
   {
       if (v_type != VT_BSTR)
       {
            TRACE_CRIT(
                "get_str_parm: Parm value not of string type %ws from 0x%p",
                szParameterName,
                (PVOID) spObj
                );
            Status = WBEM_E_INVALID_PARAMETER;
       }
       else
       {

           _bstr_t bstrNicGuid(v_value);
           LPCWSTR sz = bstrNicGuid; // Pointer to internal buffer.

           if (sz==NULL)
           {
                // hmm.. null value 
                Status = WBEM_NO_ERROR;
           }
           else
           {
               UINT len = wcslen(sz);
               pStringValue = new WCHAR[len+1];
               if (pStringValue == NULL)
               {
                    TRACE_CRIT("get_str_parm: Alloc failure!");
                    Status = WBEM_E_OUT_OF_MEMORY;
               }
               else
               {
                    CopyMemory(pStringValue, sz, (len+1)*sizeof(WCHAR));
                    Status = WBEM_NO_ERROR;
               }
            }

            TRACE_VERB(
                "get_str_parm: String parm %ws of 0x%p is %ws",
                szParameterName,
                (PVOID) spObj,
                (sz==NULL) ? L"<null>" : sz
                );
       }

       v_value.Clear(); // Must be cleared after each call to Get.
    }

end:
    
    *ppStringValue = pStringValue;

    return Status;

}


WBEMSTATUS
get_nic_instance(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szNicGuid,
    OUT IWbemClassObjectPtr &sprefObj
    )
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr spObj = NULL; // smart pointer.

    Status = CfgUtilGetWmiObjectInstance(
                    spWbemServiceIF,
                    L"Win32_NetworkAdapterConfiguration", // szClassName
                    L"SettingID", // szParameterName
                    szNicGuid,    // ParameterValue
                    spObj // smart pointer, passed by ref
                    );
    if (FAILED(Status))
    {
        ASSERT(spObj == NULL);
        goto end;
    }

end:

    if (FAILED(Status))
    {
        sprefObj = NULL;
    }
    else
    {
        sprefObj = spObj; // smart pointer.
    }


    return Status;
}


WBEMSTATUS
get_multi_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  UINT    MaxStringLen,  // in wchars, INCLUDING space for trailing zeros.
    OUT UINT    *pNumItems,
    OUT LPCWSTR *ppStringValue
    )
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    WCHAR *pStringValue = NULL;
    _variant_t   v_value;
    CIMTYPE      v_type;
    HRESULT hr;
    LONG count = 0;

    *ppStringValue = NULL;
    *pNumItems = 0;

    hr = spObj->Get(
            _bstr_t(szParameterName),
            0,                     // Reserved, must be 0     
            &v_value,               // Place to store value
            &v_type,                // Type of value
            NULL                   // Flavor (unused)
            );
    if (FAILED(hr))
    {
        // Couldn't read the requested parameter.
        //
        TRACE_CRIT(
            "get_multi_str_parm:Couldn't retrieve %ws from 0x%p",
            szParameterName,
            (PVOID) spObj
            );
        goto end;
    }


    {
        VARIANT    ipsV = v_value.Detach();

        do // while false
        {
            BSTR* pbstr;
    
            if (ipsV.vt == VT_NULL)
            {
                //
                // NULL string -- this is ok
                //
                count = 0;
            }
            else
            {
                count = ipsV.parray->rgsabound[0].cElements;
            }

            if (count==0)
            {
                Status = WBEM_NO_ERROR;
                break;
            }
    
            pStringValue = new WCHAR[count*MaxStringLen];
    
            if (pStringValue == NULL)
            {
                TRACE_CRIT("get_multi_str_parm: Alloc failure!");
                Status = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            ZeroMemory(pStringValue, sizeof(WCHAR)*count*MaxStringLen);
    
            hr = SafeArrayAccessData(ipsV.parray, ( void **) &pbstr);
            if(FAILED(hr))
            {
                Status = WBEM_E_INVALID_PARAMETER; // TODO: pick better error
                break;
            }
    
            Status = WBEM_NO_ERROR;
            for( LONG x = 0; x < count; x++ )
            {
               LPCWSTR sz = pbstr[x]; // Pointer to internal buffer.
                
               if (sz==NULL)
               {
                    // hmm.. null value 
                    continue;
               }
               else
               {
                   UINT len = wcslen(sz);
                   if ((len+1) > MaxStringLen)
                   {
                        TRACE_CRIT("get_str_parm: string size too long!");
                        Status = WBEM_E_INVALID_PARAMETER;
                        break;
                   }
                   else
                   {
                        WCHAR *pDest = pStringValue+x*MaxStringLen;
                        CopyMemory(pDest, sz, (len+1)*sizeof(WCHAR));
                   }
                }
            }
    
            (VOID) SafeArrayUnaccessData( ipsV.parray );
    
        } while (FALSE);

        VariantClear( &ipsV );
    }

    if (FAILED(Status))
    {
        if (pStringValue!=NULL)
        {
            delete pStringValue;
            *pStringValue = NULL;
        }
    }
    else
    {
        *ppStringValue = pStringValue;
        *pNumItems = count;
    }


end:

   return Status;
}

    


WBEMSTATUS
MyNetCfg::Initialize(
    BOOL fWriteLock
    )
{
    HRESULT     hr;
    INetCfg     *pnc = NULL;
    INetCfgLock *pncl = NULL;
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    BOOL        fLocked = FALSE;
    BOOL        fInitialized=FALSE;
    
    if (m_pINetCfg != NULL || m_pLock != NULL)
    {
        ASSERT(FALSE);
        goto end;
    }

    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_INetCfg, 
                           (void **) &pnc);

    if( !SUCCEEDED( hr ) )
    {
        // failure to create instance.
        TRACE_CRIT("ERROR: could not get interface to Net Config");
        goto end;
    }

    //
    // If require, get the write lock
    //
    if (fWriteLock)
    {
        WCHAR *szLockedBy = NULL;
        hr = pnc->QueryInterface( IID_INetCfgLock, ( void **) &pncl );
        if( !SUCCEEDED( hr ) )
        {
            TRACE_CRIT("ERROR: could not get interface to NetCfg Lock");
            goto end;
        }

        hr = pncl->AcquireWriteLock( 1, // One Second
                                     L"NLBManager",
                                     &szLockedBy);
        if( hr != S_OK )
        {
            TRACE_CRIT("Could not get write lock. Lock held by %ws",
            (szLockedBy!=NULL) ? szLockedBy : L"<null>");
            goto end;
            
        }
    }

    // Initializes network configuration by loading into 
    // memory all basic networking information
    //
    hr = pnc->Initialize( NULL );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Initialize
        TRACE_CRIT("INetCfg::Initialize failure ");
        goto end;
    }

    Status = WBEM_NO_ERROR; 
    
end:

    if (FAILED(Status))
    {
        if (pncl!=NULL)
        {
            if (fLocked)
            {
                pncl->ReleaseWriteLock();
            }
            pncl->Release();
            pncl=NULL;
        }
        if( pnc != NULL)
        {
            if (fInitialized)
            {
                pnc->Uninitialize();
            }
            pnc->Release();
            pnc= NULL;
        }
    }
    else
    {
        m_pINetCfg  = pnc;
        m_pLock     = pncl;
    }

    return Status;
}


VOID
MyNetCfg::Deinitialize(
    VOID
    )
{
    if (m_pLock!=NULL)
    {
        m_pLock->ReleaseWriteLock();
        m_pLock->Release();
        m_pLock=NULL;
    }
    if( m_pINetCfg != NULL)
    {
        m_pINetCfg->Uninitialize();
        m_pINetCfg->Release();
        m_pINetCfg= NULL;
    }
}


WBEMSTATUS
MyNetCfg::GetNicIF(
        IN  LPCWSTR szNicGuid,
        OUT INetCfgComponent **ppINic
        )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    INetCfgComponent *pncc = NULL;
    HRESULT hr;
    IEnumNetCfgComponent* pencc = NULL;
    ULONG                 countToFetch = 1;
    ULONG                 countFetched;
    DWORD                 characteristics;


    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }

    hr = m_pINetCfg->EnumComponents( &GUID_DEVCLASS_NET, &pencc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Enumerate net components
        TRACE_CRIT("Could not enum netcfg adapters");
        pencc = NULL;
        goto end;
    }

    while( ( hr = pencc->Next( countToFetch, &pncc, &countFetched ) )== S_OK )
    {
        LPWSTR                szName = NULL; 

        hr = pncc->GetBindName( &szName );
        if (!SUCCEEDED(hr))
        {
            TRACE_CRIT("WARNING: couldn't get bind name for 0x%p, ignoring",
                    (PVOID) pncc);
            continue;
        }
        if(!_wcsicmp(szName, szNicGuid))
        {
            //
            // Got this one!
            //
            CoTaskMemFree( szName );
            break;
        }
        CoTaskMemFree( szName );
        pncc->Release();
        pncc=NULL;
    }

    if (pncc == NULL)
    {
        TRACE_CRIT("Could not find NIC %ws", szNicGuid);
        Status = WBEM_E_NOT_FOUND;
    }
    else
    {
        Status = WBEM_NO_ERROR;
    }

end:

    if (pencc != NULL)
    {
        pencc->Release();
    }

    *ppINic = pncc;

    return Status;
}


LPWSTR *
CfgUtilsAllocateStringArray(
    UINT NumStrings,
    UINT MaxStringLen      //  excluding ending NULL
    )
/*
    Allocate a single chunk of memory using the new LPWSTR[] operator.
    The first NumStrings LPWSTR values of this operator contain an array
    of pointers to WCHAR strings. Each of these strings
    is of size (MaxStringLen+1) WCHARS.
    The rest of the memory contains the strings themselve.

    Return NULL if NumStrings==0 or on allocation failure.

    Each of the strings are initialized to be empty strings (first char is 0).
*/
{
    LPWSTR *pStrings = NULL;
    UINT   TotalSize = 0;

    if (NumStrings == 0)
    {
        goto end;
    }

    //
    // Note - even if MaxStringLen is 0 we will allocate space for NumStrings
    // pointers and NumStrings empty (first char is 0) strings.
    //

    //
    // Calculate space for the array of pointers to strings...
    //
    TotalSize = NumStrings*sizeof(LPWSTR);

    //
    // Calculate space for the strings themselves...
    // Remember to add +1 for each ending 0 character.
    //
    TotalSize +=  NumStrings*(MaxStringLen+1)*sizeof(WCHAR);

    //
    // Allocate space for *both* the array of pointers and the strings
    // in one shot -- we're doing a new of type LPWSTR[] for the whole
    // lot, so need to specify the size in units of LPWSTR (with an
    // additional +1 in case there's roundoff.
    //
    pStrings = new LPWSTR[(TotalSize/sizeof(LPWSTR))+1];
    if (pStrings == NULL)
    {
        goto end;
    }

    //
    // Make sz point to the start of the place where we'll be placing
    // the string data.
    //
    LPWSTR sz = (LPWSTR) (pStrings+NumStrings);
    for (UINT u=0; u<NumStrings; u++)
    {
        *sz=NULL;
        pStrings[u] = sz;
        sz+=(MaxStringLen+1); // +1 for ending NULL
    }

end:

    return pStrings;

}



WBEMSTATUS
MyNetCfg::GetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        )
/*
    Returns an array of pointers to string-version of GUIDS
    that represent the set of alive and healthy NICS that are
    suitable for NLB to bind to -- basically alive ethernet NICs.

    Delete ppNics using the delete WCHAR[] operator. Do not
    delete the individual strings.
*/
{
    #define MY_GUID_LENGTH  38

    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    HRESULT hr;
    IEnumNetCfgComponent* pencc = NULL;
    INetCfgComponent *pncc = NULL;
    ULONG                 countToFetch = 1;
    ULONG                 countFetched;
    DWORD                 characteristics;
    UINT                  NumNics = 0;
    LPWSTR               *pszNics = NULL;
    INetCfgComponentBindings    *pINlbBinding=NULL;
    UINT                  NumNlbBoundNics = 0;

    typedef struct _MYNICNODE MYNICNODE;

    typedef struct _MYNICNODE
    {
        LPWSTR szNicGuid;
        MYNICNODE *pNext;
    } MYNICNODE;

    MYNICNODE *pNicNodeList = NULL;
    MYNICNODE *pNicNode     = NULL;


    *ppszNics = NULL;
    *pNumNics = 0;

    if (pNumBoundToNlb != NULL)
    {
        *pNumBoundToNlb  = 0;
    }

    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }

    hr = m_pINetCfg->EnumComponents( &GUID_DEVCLASS_NET, &pencc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Enumerate net components
        TRACE_CRIT("%!FUNC! Could not enum netcfg adapters");
        pencc = NULL;
        goto end;
    }


    //
    // Check if nlb is bound to the nlb component.
    //

    //
    // If we need to count of NLB-bound nics, get instance of the nlb component
    //
    if (pNumBoundToNlb != NULL)
    {
        Status = GetBindingIF(L"ms_wlbs", &pINlbBinding);
        if (FAILED(Status))
        {
            TRACE_CRIT("%!FUNC! WARNING: NLB doesn't appear to be installed on this machine");
            pINlbBinding = NULL;
        }
    }

    while( ( hr = pencc->Next( countToFetch, &pncc, &countFetched ) )== S_OK )
    {
        LPWSTR                szName = NULL; 

        hr = pncc->GetBindName( &szName );
        if (!SUCCEEDED(hr))
        {
            TRACE_CRIT("%!FUNC! WARNING: couldn't get bind name for 0x%p, ignoring",
                    (PVOID) pncc);
            continue;
        }

        do // while FALSE -- just to allow breaking out
        {


            UINT Len = wcslen(szName);
            if (Len != MY_GUID_LENGTH)
            {
                TRACE_CRIT("%!FUNC! WARNING: GUID %ws has unexpected length %ul",
                        szName, Len);
                break;
            }
    
            DWORD characteristics = 0;
    
            hr = pncc->GetCharacteristics( &characteristics );
            if(!SUCCEEDED(hr))
            {
                TRACE_CRIT("%!FUNC! WARNING: couldn't get characteristics for %ws, ignoring",
                        szName);
                break;
            }
    
            if(characteristics & NCF_PHYSICAL)
            {
                ULONG devstat = 0;
    
                // This is a physical network card.
                // we are only interested in such devices
    
                // check if the nic is enabled, we are only
                // interested in enabled nics.
                //
                hr = pncc->GetDeviceStatus( &devstat );
                if(!SUCCEEDED(hr))
                {
                    TRACE_CRIT(
                        "%!FUNC! WARNING: couldn't get dev status for %ws, ignoring",
                        szName
                        );
                    break;
                }
    
                // if any of the nics has any of the problem codes
                // then it cannot be used.
    
                if( devstat != CM_PROB_NOT_CONFIGURED
                    &&
                    devstat != CM_PROB_FAILED_START
                    &&
                    devstat != CM_PROB_NORMAL_CONFLICT
                    &&
                    devstat != CM_PROB_NEED_RESTART
                    &&
                    devstat != CM_PROB_REINSTALL
                    &&
                    devstat != CM_PROB_WILL_BE_REMOVED
                    &&
                    devstat != CM_PROB_DISABLED
                    &&
                    devstat != CM_PROB_FAILED_INSTALL
                    &&
                    devstat != CM_PROB_FAILED_ADD
                    )
                {
                    //
                    // No problem with this nic and also 
                    // physical device 
                    // thus we want it.
                    //

                    if (pINlbBinding != NULL)
                    {
                        BOOL fBound = FALSE;

                        hr = pINlbBinding->IsBoundTo(pncc);

                        if( !SUCCEEDED( hr ) )
                        {
                            TRACE_CRIT("IsBoundTo method failed for Nic %ws", szName);
                            goto end;
                        }
                    
                        if( hr == S_OK )
                        {
                            TRACE_VERB("BOUND: %ws\n", szName);
                            NumNlbBoundNics++;
                            fBound = TRUE;
                        }
                        else if (hr == S_FALSE )
                        {
                            TRACE_VERB("NOT BOUND: %ws\n", szName);
                            fBound = FALSE;
                        }
                    }


                    // We allocate a little node to keep this string
                    // temporarily and add it to our list of nodes.
                    //
                    pNicNode = new MYNICNODE;
                    if (pNicNode  == NULL)
                    {
                        Status = WBEM_E_OUT_OF_MEMORY;
                        goto end;
                    }
                    ZeroMemory(pNicNode, sizeof(*pNicNode));
                    pNicNode->szNicGuid = szName;
                    szName = NULL; // so we don't delete inside the lopp.
                    pNicNode->pNext = pNicNodeList;
                    pNicNodeList = pNicNode;
                    NumNics++;
                }
                else
                {
                    // There is a problem...
                    TRACE_CRIT(
                        "%!FUNC! WARNING: Skipping %ws because DeviceStatus=0x%08lx",
                        szName, devstat
                        );
                    break;
                }
            }
            else
            {
                TRACE_VERB("%!FUNC! Ignoring non-physical device %ws", szName);
            }

        } while (FALSE);

        if (szName != NULL)
        {
            CoTaskMemFree( szName );
        }
        pncc->Release();
        pncc=NULL;
    }

    if (pINlbBinding!=NULL)
    {
        pINlbBinding->Release();
        pINlbBinding = NULL;
    }

    if (NumNics==0)
    {
        Status = WBEM_NO_ERROR;
        goto end;
    }
    
    //
    // Now let's  allocate space for all the nic strings and:w
    // copy them over..
    //
    #define MY_GUID_LENGTH  38
    pszNics =  CfgUtilsAllocateStringArray(NumNics, MY_GUID_LENGTH);
    if (pszNics == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    pNicNode= pNicNodeList;
    for (UINT u=0; u<NumNics; u++, pNicNode=pNicNode->pNext)
    {
        ASSERT(pNicNode != NULL); // because we just counted NumNics of em.
        UINT Len = wcslen(pNicNode->szNicGuid);
        if (Len != MY_GUID_LENGTH)
        {
            //
            // We should never get here beause we checked the length earlier.
            //
            TRACE_CRIT("%!FUNC! ERROR: GUID %ws has unexpected length %ul",
                    pNicNode->szNicGuid, Len);
            ASSERT(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        CopyMemory(
            pszNics[u],
            pNicNode->szNicGuid,
            (MY_GUID_LENGTH+1)*sizeof(WCHAR));
        ASSERT(pszNics[u][MY_GUID_LENGTH]==0);
    }

    Status = WBEM_NO_ERROR;


end:

    //
    // Now release the temporarly allocated memory.
    //
    pNicNode= pNicNodeList;
    while (pNicNode!=NULL)
    {
        MYNICNODE *pTmp = pNicNode->pNext;
        CoTaskMemFree(pNicNode->szNicGuid);
        pNicNode->szNicGuid = NULL;
        delete pNicNode;
        pNicNode = pTmp;
    }

    if (FAILED(Status))
    {
        TRACE_CRIT("%!FUNC! fails with status 0x%08lx", (UINT) Status);
        NumNics = 0;
        if (pszNics!=NULL)
        {
            delete pszNics;
            pszNics = NULL;
        }
    }
    else
    {
        if (pNumBoundToNlb != NULL)
        {
            *pNumBoundToNlb = NumNlbBoundNics;
        }
        *ppszNics = pszNics;
        *pNumNics = NumNics;
    }

    if (pencc != NULL)
    {
        pencc->Release();
    }

    return Status;
}


WBEMSTATUS
MyNetCfg::GetBindingIF(
        IN  LPCWSTR                     szComponent,
        OUT INetCfgComponentBindings   **ppIBinding
        )
{
    WBEMSTATUS                  Status = WBEM_E_CRITICAL_ERROR;
    INetCfgComponent            *pncc = NULL;
    INetCfgComponentBindings    *pnccb = NULL;
    HRESULT                     hr;


    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }


    hr = m_pINetCfg->FindComponent(szComponent,  &pncc);

    if (FAILED(hr))
    {
        TRACE_CRIT("Error checking if component %ws does not exist\n", szComponent);
        pncc = NULL;
        goto end;
    }
    else if (hr == S_FALSE)
    {
        Status = WBEM_E_NOT_FOUND;
        TRACE_CRIT("Component %ws does not exist\n", szComponent);
        goto end;
    }
   
   
    hr = pncc->QueryInterface( IID_INetCfgComponentBindings, (void **) &pnccb );
    if( !SUCCEEDED( hr ) )
    {
        TRACE_CRIT("INetCfgComponent::QueryInterface failed ");
        pnccb = NULL;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    if (pncc)
    {
        pncc->Release();
        pncc=NULL;
    }

    *ppIBinding = pnccb;

    return Status;

}


WBEMSTATUS
set_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  LPCWSTR szValue
    )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    HRESULT     hr;

    {
        _bstr_t     bstrName =  szParameterName;
        _variant_t  v_value = (LPWSTR) szValue; // Allocates.
    
        hr = spObj->Put(
                 bstrName, // Parameter Name
                 0, // Must be 0
                 &v_value,
                 0  // Must be 0
                 );
        v_value.Clear();
    
        if (FAILED(hr))
        {
            TRACE_CRIT("Unable to put parameter %ws", szParameterName);
            goto end;
        }
        Status = WBEM_NO_ERROR;

        //
        // I think bstrName releases the internally allocated string
        // on exiting this block.
        //

    }

end:

    return Status;
}

WBEMSTATUS
set_multi_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  UINT    MaxStringLen,  // in wchars, INCLUDING space for trailing zeros.
    IN  UINT    NumItems,
    IN  LPCWSTR pStringValue
    )
{
    WBEMSTATUS   Status = WBEM_E_CRITICAL_ERROR;
    SAFEARRAY   *pSA = NULL;
    HRESULT hr;
    LONG Index = 0;

    //
    // Create safe array for the parameter values
    //
    pSA =  SafeArrayCreateVector(
                VT_BSTR,
                0,          // lower bound
                NumItems    // size of the fixed-sized vector.
                );
    if (pSA == NULL)
    {
        TRACE_CRIT("Could not create safe array");
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    //
    // Place the strings into the safe array
    //
    {
        for (Index = 0; Index<NumItems; Index++)
        {
            LPCWSTR sz = pStringValue + Index*MaxStringLen;

            //
            // SafeArrayPutElement expects the string passed in to 
            // be of type BSTR, which is of type wchar *, except, that
            // the first 2 wchars contains length and other(?)
            // information. This is why you can't simply pass in sz.
            //
            // So to get this we initalize an object of type _bstr_t
            // based on sz. On initializaton, bstrValue allocates memory
            // and copies the string.
            //
            _bstr_t bstrValue = sz;
            wchar_t *pwchar = (wchar_t *) bstrValue; // returns internal pointer.

            // bpStr[Index] = sz; // may work as well.
            //
            // SafeArrayPutElement internally allocates space for pwchar and
            // copies over the string.
            // So pSA doesn't contain a direct reference to pwchar.
            //
            hr = SafeArrayPutElement(pSA, &Index, pwchar);
            if (FAILED(hr))
            {
                TRACE_CRIT("Unable to put element %wsz",  sz);
                (VOID) SafeArrayUnaccessData(pSA);
                goto end;
            }

            //
            // I think that bstrValue's contents are deallocated on exit of
            // this block.
            //
                
        }
    }
      
#if DBG
    //
    // Just check ...
    //
    {
        BSTR *pbStr=NULL;
        hr = SafeArrayAccessData(pSA, ( void **) &pbStr);
        if (FAILED(hr))
        {
            TRACE_CRIT("Could not access data of safe array");
            goto end;
        }
        for (UINT u = 0; u<NumItems; u++)
        {
            LPCWSTR sz = pbStr[u];
            if (_wcsicmp(sz, (pStringValue + u*MaxStringLen)))
            {
                TRACE_CRIT("!!!MISMATCH!!!!");
            }
            else
            {
                TRACE_CRIT("!!!MATCH!!!!");
            }
        }
        (VOID) SafeArrayUnaccessData(pSA);
        pbStr=NULL;
    }
#endif // DBG

    //
    // Put the parameter.
    //
    {
        VARIANT     V;
        _bstr_t  bstrName =  szParameterName;

        VariantInit(&V);
        V.vt = VT_ARRAY | VT_BSTR;
        V.parray = pSA;
        _variant_t   v_value;
        v_value.Attach(V);  // Takes owhership of V. V now becomes empty.
        ASSERT(V.vt == VT_EMPTY);
        pSA = NULL; // should be no need to delete this explicitly now.
                    // v_value.Clear() should delete it, I think.

        hr = spObj->Put(
                 bstrName, // Parameter Name
                 0, // Must be 0
                 &v_value,
                 0  // Must be 0
                 );

        v_value.Clear();
        if (FAILED(hr))
        {
            TRACE_CRIT("Unable to put parameter %ws", szParameterName);
            goto end;
        }
        Status = WBEM_NO_ERROR;
    }

    //
    // ?Destroy the data?
    //
    if (FAILED(Status))
    {
        if (pSA!=NULL)
        {
            SafeArrayDestroy(pSA);
            pSA = NULL;
        }
    }

end:

    return Status;
}



WBEMSTATUS
MyNetCfg::UpdateBindingState(
        IN  LPCWSTR         szNic,
        IN  LPCWSTR         szComponent,
        IN  UPDATE_OP       Op,
        OUT BOOL            *pfBound
        )
{
    WBEMSTATUS                  Status = WBEM_E_CRITICAL_ERROR;
    INetCfgComponent            *pINic = NULL;
    INetCfgComponentBindings    *pIBinding=NULL;
    BOOL                        fBound = FALSE;
    HRESULT                     hr;

    //
    // Get instance to the NIC
    //
    Status = GetNicIF(szNic, &pINic);
    if (FAILED(Status))
    {
        pINic = NULL;
        goto end;
    }

    //
    // Get instance of the nlb component
    //
    Status = GetBindingIF(szComponent, &pIBinding);
    if (FAILED(Status))
    {
        pIBinding = NULL;
        goto end;
    }

    //
    // Check if nlb is bound to the nlb component.
    //
    hr = pIBinding->IsBoundTo(pINic);
    if( !SUCCEEDED( hr ) )
    {
        TRACE_CRIT("IsBoundTo method failed for Nic %ws", szNic);
        goto end;
    }

    if( hr == S_OK )
    {
        fBound = TRUE;
    }
    else if (hr == S_FALSE )
    {
        fBound = FALSE;
    }

    if (    (Op == MyNetCfg::NOOP)
        ||  (Op == MyNetCfg::BIND && fBound)
        ||  (Op == MyNetCfg::UNBIND && !fBound))
    {
        Status = WBEM_NO_ERROR;
        goto end;
    }

    if (Op == MyNetCfg::BIND)
    {
        hr = pIBinding->BindTo( pINic );
    }
    else if (Op == MyNetCfg::UNBIND)
    {
        hr = pIBinding->UnbindFrom( pINic );
    }
    else
    {
        ASSERT(FALSE);
        goto end;
    }

    if (FAILED(hr))
    {
        TRACE_CRIT("Error 0x%08lx %ws %ws on %ws",
                (UINT) hr,
                ((Op==MyNetCfg::BIND) ? L"binding" : L"unbinding"),
                szComponent,
                szNic
                );
        goto end;
    }

    //
    // apply the binding change made.
    //
    hr = m_pINetCfg->Apply();
    if( !SUCCEEDED( hr ) )
    {
        TRACE_CRIT("INetCfg::Apply failed with 0x%08lx", (UINT) hr);
        goto end;
    }

    //
    // We're done. Our state should now be toggled.
    //
    fBound = !fBound;

    Status = WBEM_NO_ERROR;

end:

    if (pINic!=NULL)
    {
        pINic->Release();
        pINic = NULL;
    }

    if (pIBinding!=NULL)
    {
        pIBinding->Release();
        pIBinding = NULL;
    }

    *pfBound = fBound;

    return Status;
}

WBEMSTATUS
CfgUtilControlCluster(
    IN  LPCWSTR szNic,
    IN  LONG    ioctl
    )
{
    HRESULT hr;
    GUID Guid;
    WBEMSTATUS Status;

    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    hr = CLSIDFromString((LPWSTR)szNic, &Guid);
    if (FAILED(hr))
    {
        TRACE_CRIT(
            "CWlbsControl::Initialize failed at CLSIDFromString %ws",
            szNic
            );
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    TRACE_INFO("Going to stop cluster on NIC %ws...", szNic);
    DWORD dwRet = g_CfgUtils.m_pWlbsControl->LocalClusterControl(
                        Guid,
                        ioctl
                        );
    TRACE_INFO("Stop cluster returned with wlbs error 0x%08lx", dwRet);

    Status = WBEM_NO_ERROR;

    switch(dwRet)
    {
    case WLBS_ALREADY:      break;
    case WLBS_CONVERGED:    break;
    case WLBS_CONVERGING:   break;
    case WLBS_DEFAULT:      break;
    case WLBS_DRAIN_STOP:   break;
    case WLBS_DRAINING:     break;
    case WLBS_OK:           break;
    case WLBS_STOPPED:      break;
    case WLBS_SUSPENDED:    break;
    case WLBS_BAD_PARAMS:   Status = WBEM_E_INVALID_PARAMETER; break;
    default:                Status = WBEM_E_CRITICAL_ERROR; break;
    }

end:

    return Status;
}

//
// Initializes pParams using default values.
//
VOID
CfgUtilInitializeParams(
    OUT WLBS_REG_PARAMS *pParams
    )
{
    //
    // We don't expect WlbsSetDefaults to fail (it should have been
    // defined returning VOID.
    //
    DWORD dwRet;


    dwRet =  WlbsSetDefaults(pParams);

    if (dwRet != WLBS_OK)
    {
        ZeroMemory(pParams, sizeof(*pParams));
        TRACE_CRIT("Internal error: WlbsSetDefaults failed");
        ASSERT(FALSE);
    }
}

WBEMSTATUS
CfgUtilSafeArrayFromStrings(
    IN  LPCWSTR       *pStrings,
    IN  UINT          NumStrings,
    OUT SAFEARRAY   **ppSA
    )
/*
    Allocates and returns a SAFEARRAY of strings -- strings are copies of
    the passed in values.

    Call  SafeArrayDestroy when done with the array.
*/
{
    WBEMSTATUS   Status = WBEM_E_CRITICAL_ERROR;
    SAFEARRAY   *pSA = NULL;
    HRESULT hr;
    LONG Index = 0;

    *ppSA = NULL;

    //
    // Create safe array for the parameter values
    //
    pSA =  SafeArrayCreateVector(
                VT_BSTR,
                0,          // lower bound
                NumStrings    // size of the fixed-sized vector.
                );
    if (pSA == NULL)
    {
        TRACE_CRIT("Could not create safe array");
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    //
    // Place the strings into the safe array
    //
    {
        for (Index = 0; Index<NumStrings; Index++)
        {
            LPCWSTR sz = pStrings[Index];

            //
            // SafeArrayPutElement expects the string passed in to 
            // be of type BSTR, which is of type wchar *, except, that
            // the first 2 wchars contains length and other(?)
            // information. This is why you can't simply pass in sz.
            //
            // So to get this we initalize an object of type _bstr_t
            // based on sz. On initializaton, bstrValue allocates memory
            // and copies the string.
            //
            _bstr_t bstrValue = sz;
            wchar_t *pwchar = (wchar_t *) bstrValue; // returns internal pointer.

            // bpStr[Index] = sz; // may work as well.
            //
            // SafeArrayPutElement internally allocates space for pwchar and
            // copies over the string.
            // So pSA doesn't contain a direct reference to pwchar.
            //
            hr = SafeArrayPutElement(pSA, &Index, pwchar);
            if (FAILED(hr))
            {
                TRACE_CRIT("Unable to put element %wsz",  sz);
                (VOID) SafeArrayUnaccessData(pSA);
                goto end;
            }

            //
            // I think that bstrValue's contents are deallocated on exit of
            // this block.
            //
                
        }
    }
    Status = WBEM_NO_ERROR;
      
end:

    if (FAILED(Status))
    {
        if (pSA!=NULL)
        {
            SafeArrayDestroy(pSA);
            pSA = NULL;
        }
    }

    *ppSA = pSA;

    return Status;
}


WBEMSTATUS
CfgUtilStringsFromSafeArray(
    IN  SAFEARRAY   *pSA,
    OUT LPWSTR     **ppStrings,
    OUT UINT        *pNumStrings
    )
/*
    Extracts copies of the strings in the passed-in safe array.
    Free *pStrings using the delete operator when done.
    NOTE: Do NOT delete the individual strings -- they are
    stored in the memory allocated for pStrings.
*/
{
    WBEMSTATUS  Status      = WBEM_E_OUT_OF_MEMORY;
    LPWSTR     *pStrings    = NULL;
    LPCWSTR     csz;
    LPWSTR      sz;
    UINT        NumStrings = 0;
    UINT        u;
    HRESULT     hr;
    BSTR       *pbStr       =NULL;
    UINT        TotalSize   =0;
    LONG        UBound      = 0;

    *ppStrings = NULL;
    *pNumStrings = 0;

    hr = SafeArrayGetUBound(pSA, 1, &UBound);
    if (FAILED(hr))
    {
        TRACE_CRIT("Could not get upper bound of safe array");
        goto end;
    }
    NumStrings = (UINT) (UBound+1); // Convert from UpperBound to NumStrings.

    if (NumStrings == 0)
    {
        // nothing in array -- we're done.
        Status = WBEM_NO_ERROR;
        goto end;

    }

    hr = SafeArrayAccessData(pSA, ( void **) &pbStr);
    if (FAILED(hr))
    {
        TRACE_CRIT("Could not access data of safe array");
        goto end;
    }

    //
    // Calculate space for the array of pointers to strings...
    //
    TotalSize = NumStrings*sizeof(LPWSTR);

    //
    // Calculate space for the strings themselves...
    //
    for (u=0; u<NumStrings; u++)
    {
        csz = pbStr[u];
        TotalSize += (wcslen(csz)+1)*sizeof(WCHAR);
    }

    //
    // Allocate space for *both* the array of pointers and the strings
    // in one shot -- we're doing a new of type LPWSTR[] for the whole
    // lot, so need to specify the size in units of LPWSTR (with an
    // additional +1 in case there's roundoff.
    //
    pStrings = new LPWSTR[(TotalSize/sizeof(LPWSTR))+1];
    if (pStrings == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        (VOID) SafeArrayUnaccessData(pSA);
        goto end;
    }

    //
    // Make sz point to the start of the place where we'll be placing
    // the string data.
    //
    sz = (LPWSTR) (pStrings+NumStrings);
    for (u=0; u<NumStrings; u++)
    {
        csz = pbStr[u];
        UINT len = wcslen(csz)+1;
        CopyMemory(sz, csz, len*sizeof(WCHAR));
        pStrings[u] = sz;
        sz+=len;
    }

    (VOID) SafeArrayUnaccessData(pSA);
    Status = WBEM_NO_ERROR;

end:

    pbStr=NULL;
    if (FAILED(Status))
    {
        if (pStrings!=NULL)
        {
            delete pStrings;
            pStrings = NULL;
        }
        NumStrings = 0;
    }

    *ppStrings = pStrings;
    *pNumStrings = NumStrings;

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiObjectInstance(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szClassName,
    IN  LPCWSTR             szPropertyName,
    IN  LPCWSTR             szPropertyValue,
    OUT IWbemClassObjectPtr &sprefObj // smart pointer
    )
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    HRESULT hr;

    //
    // TODO: consider using  IWbemServices::ExecQuery
    //
    IEnumWbemClassObjectPtr  spEnum=NULL; // smart pointer
    IWbemClassObjectPtr spObj = NULL; // smart pointer.
    _bstr_t bstrClassName =  szClassName;

    //
    // get all instances of object
    //
    hr = spWbemServiceIF->CreateInstanceEnum(
             bstrClassName,
             WBEM_FLAG_RETURN_IMMEDIATELY,
             NULL,
             &spEnum
             );
    if (FAILED(hr))
    {
        TRACE_CRIT("IWbemServices::CreateInstanceEnum failure\n" );
        spEnum = NULL;
        goto end;
    }

    //
    // Look for the object with the matching property.
    //
    do
    {
        ULONG count = 1;
        
        hr = spEnum->Next(
                         INFINITE,
                         1,
                         &spObj,
                         &count
                         );
        //
        // Note -- Next() returns S_OK if number asked == number returned.
        //         and  S_FALSE if number asked < than number requested.
        //         Since we're asking for only ...
        //
        if (hr == S_OK)
        {
            LPWSTR szEnumValue = NULL;

            Status =  get_string_parameter(
                        spObj,
                        szPropertyName,
                        &szEnumValue  // Delete when done.
                        );
            if (FAILED(Status))
            {
                //
                // Ignore this failure here.
                //

            }
            else if (szEnumValue!=NULL)
            {
               BOOL fFound = FALSE;
               if (!_wcsicmp(szEnumValue, szPropertyValue))
               {
                    fFound = TRUE;
               }
               delete szEnumValue;

               if (fFound)
               {
                    break; // BREAK BREAK BREAK BREAK
               }

            }
        }
        else
        {
            TRACE_INFO(
                "====0x%p->Next() returns Error 0x%lx; count=0x%lu", (PVOID) spObj,
                (UINT) hr, count);
        }


        //
        // Since I don't fully trust smart pointers, I'm specifically
        // setting spObj to NULL here...
        //
        spObj = NULL; // smart pointer

    } while (hr == S_OK);

    if (spObj == NULL)
    {
        //
        //  We couldn't find a NIC which matches the one asked for...
        //
        Status =  WBEM_E_NOT_FOUND;
        goto end;
    }

end:

    if (FAILED(Status))
    {
        sprefObj = NULL;
    }
    else
    {
        sprefObj = spObj; // smart pointer.
    }


    return Status;
}


WBEMSTATUS
CfgUtilGetWmiRelPath(
    IN  IWbemClassObjectPtr spObj,
    OUT LPWSTR *           pszRelPath          // free using delete 
    )
{
    WBEMSTATUS   Status = WBEM_E_CRITICAL_ERROR;
    LPWSTR pRelPath = NULL;


    //
    // Extract the relative path, needed for ExecMethod.
    //
    Status =  get_string_parameter(
                spObj,
                L"__RELPATH", // szParameterName
                &pRelPath  // Delete when done.
                );
    if (FAILED(Status))
    {
        TRACE_CRIT("Couldn't get rel path");
        pRelPath = NULL;
        goto end;
    }
    else
    {
        if (pRelPath==NULL)
        {
            ASSERT(FALSE); // we don't expect this!
            goto end;
        }
        TRACE_CRIT("GOT RELATIVE PATH %ws", pRelPath);
    }

end:
    *pszRelPath = pRelPath;

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiInputInstanceAndRelPath(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szClassName,
    IN  LPCWSTR             szPropertyName, // NULL: return Class rel path
    IN  LPCWSTR             szPropertyValue,
    IN  LPCWSTR             szMethodName,
    OUT IWbemClassObjectPtr &spWbemInputInstance, // smart pointer
    OUT LPWSTR *            pszRelPath          // free using delete 
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemClassObjectPtr spClassObj   = NULL;  // smart pointer
    HRESULT             hr;
    LPWSTR              pRelPath = NULL;

    TRACE_INFO(L"-> %!FUNC!(PropertyValue=%ws)", szPropertyValue);

    //
    // Get CLASS object
    //
    {
        hr = spWbemServiceIF->GetObject(
                        _bstr_t(szClassName),
                        0,
                        NULL,
                        &spClassObj,
                        NULL
                        );

        if (FAILED(hr))
        {
            TRACE_CRIT("Couldn't get nic class object pointer");
            Status = (WBEMSTATUS)hr;
            goto end;
        }
    }


    //
    // Get WMI path to specific object
    //
    if (szPropertyName == NULL)
    {
        // Get WMI path to the class
        Status =  CfgUtilGetWmiRelPath(
                    spClassObj,
                    &pRelPath
                    );
        if (FAILED(Status))
        {
            goto end;
        }
    }
    else
    {
        IWbemClassObjectPtr spObj   = NULL;  // smart pointer
        pRelPath = NULL;

        Status = CfgUtilGetWmiObjectInstance(
                        spWbemServiceIF,
                        szClassName,
                        szPropertyName,
                        szPropertyValue,
                        spObj // smart pointer, passed by ref
                        );
        if (FAILED(Status))
        {
            ASSERT(spObj == NULL);
            goto end;
        }

        Status =  CfgUtilGetWmiRelPath(
                    spObj,
                    &pRelPath
                    );
        spObj = NULL; // smart pointer
        if (FAILED(Status))
        {
            goto end;
        }
    }

    //
    // Get the input parameters to the call to the method
    //
    {
        IWbemClassObjectPtr      spWbemInput = NULL; // smart pointer

        // check if any input parameters specified.
    
        hr = spClassObj->GetMethod(
                        szMethodName,
                        0,
                        &spWbemInput,
                        NULL
                        );
        if(FAILED(hr))
        {
            TRACE_CRIT("IWbemClassObject::GetMethod failure");
            Status = (WBEMSTATUS) hr;
            goto end;
        }
            
        if (spWbemInput != NULL)
        {
            hr = spWbemInput->SpawnInstance( 0, &spWbemInputInstance );
            if( FAILED( hr) )
            {
                TRACE_CRIT("IWbemClassObject::SpawnInstance failure. Unable to spawn instance." );
                Status = (WBEMSTATUS) hr;
                goto end;
            }
        }
        else
        {
            //
            // This method has no input arguments!
            //
            spWbemInputInstance = NULL;
        }

    }

    Status = WBEM_NO_ERROR;

end:


    if (FAILED(Status))
    {
        if (pRelPath != NULL)
        {
            delete pRelPath;
            pRelPath = NULL;
        }
    }

    *pszRelPath = pRelPath;

    TRACE_INFO(L"<- %!FUNC!(Obj=%ws) returns 0x%08lx", szPropertyValue, (UINT) Status);

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiStringParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT LPWSTR *ppStringValue
)
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    WCHAR *pStringValue = NULL;
    
    try
    {

        _variant_t   v_value;
        CIMTYPE      v_type;
        HRESULT hr;
    
        hr = spObj->Get(
                _bstr_t(szParameterName), // Name
                0,                     // Reserved, must be 0     
                &v_value,               // Place to store value
                &v_type,                // Type of value
                NULL                   // Flavor (unused)
                );
       if (FAILED(hr))
       {
            // Couldn't read the Setting ID field!
            //
            TRACE_CRIT(
                "get_str_parm:Couldn't retrieve %ws from 0x%p. Hr=0x%08lx",
                szParameterName,
                (PVOID) spObj,
                hr
                );
            goto end;
       }
       else if (v_type == VT_NULL)
       {
            pStringValue = NULL;
            Status = WBEM_NO_ERROR;
            goto end;
       }
       else
       {
           if (v_type != VT_BSTR)
           {
                TRACE_CRIT(
                    "get_str_parm: Parm value not of string type %ws from 0x%p",
                    szParameterName,
                    (PVOID) spObj
                    );
                Status = WBEM_E_INVALID_PARAMETER;
           }
           else
           {
    
               _bstr_t bstrNicGuid(v_value);
               LPCWSTR sz = bstrNicGuid; // Pointer to internal buffer.
    
               if (sz==NULL)
               {
                    // hmm.. null value 
                    pStringValue = NULL;
                    Status = WBEM_NO_ERROR;
               }
               else
               {
                   UINT len = wcslen(sz);
                   pStringValue = new WCHAR[len+1];
                   if (pStringValue == NULL)
                   {
                        TRACE_CRIT("get_str_parm: Alloc failure!");
                        Status = WBEM_E_OUT_OF_MEMORY;
                   }
                   else
                   {
                        CopyMemory(pStringValue, sz, (len+1)*sizeof(WCHAR));
                        Status = WBEM_NO_ERROR;
                   }
                }
    
                TRACE_VERB(
                    "get_str_parm: String parm %ws of 0x%p is %ws",
                    szParameterName,
                    (PVOID) spObj,
                    (sz==NULL) ? L"<null>" : sz
                    );
           }
    
           v_value.Clear(); // Must be cleared after each call to Get.
        }

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    }

end:

    if (!FAILED(Status) && pStringValue == NULL)
    {
        //
        // We convert a NULL value to an empty, not NULL string.
        //
        pStringValue = new WCHAR[1];
        if (pStringValue == NULL)
        {
            Status = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            *pStringValue = 0;
            Status = WBEM_NO_ERROR;
        }
    }

    
    *ppStringValue = pStringValue;

    return Status;

}


WBEMSTATUS
CfgUtilSetWmiStringParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  LPCWSTR             szValue
    )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;

    try
    {

        HRESULT     hr;
        _bstr_t     bstrName =  szParameterName;
        _variant_t  v_value = (LPWSTR) szValue; // Allocates.
        
            hr = spObj->Put(
                     bstrName, // Parameter Name
                     0, // Must be 0
                     &v_value,
                     0  // Must be 0
                     );
            v_value.Clear();
        
            if (FAILED(hr))
            {
                TRACE_CRIT("Unable to put parameter %ws", szParameterName);
                goto end;
            }
            Status = WBEM_NO_ERROR;
    
        //
        // I think bstrName releases the internally allocated string
        // on exiting this block.
        //
    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_INVALID_PARAMETER;
    }

end:

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiStringArrayParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT LPWSTR              **ppStrings,
    OUT UINT                *pNumStrings
)
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;

    try
    {
        _variant_t   v_value;
        CIMTYPE      v_type;
        HRESULT hr;
        LONG count = 0;
    
        *ppStrings = NULL;
        *pNumStrings = 0;
    
        hr = spObj->Get(
                _bstr_t(szParameterName),
                0,                     // Reserved, must be 0     
                &v_value,               // Place to store value
                &v_type,                // Type of value
                NULL                   // Flavor (unused)
                );
        if (FAILED(hr))
        {
            // Couldn't read the requested parameter.
            //
            TRACE_CRIT(
                "get_multi_str_parm:Couldn't retrieve %ws from 0x%p",
                szParameterName,
                (PVOID) spObj
                );
            Status = WBEM_E_INVALID_PARAMETER;
            goto end;
        }
    
    
        if (v_type != (VT_ARRAY | VT_BSTR))
        {

           if (v_type == VT_NULL)
           {
                //
                // We convert a NULL value to zero strings
                //
                Status = WBEM_NO_ERROR;
                goto end;
           }
           TRACE_CRIT("vt is not of type string!");
           goto end;
        }
        else
        {
            VARIANT    ipsV = v_value.Detach();
            SAFEARRAY   *pSA = ipsV.parray;
    
            Status =  CfgUtilStringsFromSafeArray(
                            pSA,
                            ppStrings,
                            pNumStrings
                            );
    
            VariantClear( &ipsV );
        }
    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_NOT_FOUND;
    }

end:

   return Status;
}


WBEMSTATUS
CfgUtilSetWmiStringArrayParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  LPCWSTR             *ppStrings,
    IN  UINT                NumStrings
)
{
    WBEMSTATUS   Status = WBEM_E_CRITICAL_ERROR;
    SAFEARRAY   *pSA = NULL;


    try
    {

        HRESULT hr;
        LONG Index = 0;
    
    
        Status = CfgUtilSafeArrayFromStrings(
                    ppStrings,
                    NumStrings,
                    &pSA
                    );
        if (FAILED(Status))
        {
            pSA = NULL;
            goto end;
        }
    
    
        //
        // Put the parameter.
        //
        {
            VARIANT     V;
            _bstr_t  bstrName =  szParameterName;
    
            VariantInit(&V);
            V.vt = VT_ARRAY | VT_BSTR;
            V.parray = pSA;
            _variant_t   v_value;
            v_value.Attach(V);  // Takes owhership of V. V now becomes empty.
            ASSERT(V.vt == VT_EMPTY);
            pSA = NULL; // should be no need to delete this explicitly now.
                        // v_value.Clear() should delete it, I think.
    
            hr = spObj->Put(
                     bstrName, // Parameter Name
                     0, // Must be 0
                     &v_value,
                     0  // Must be 0
                     );
    
            v_value.Clear();
            if (FAILED(hr))
            {
                Status = (WBEMSTATUS) hr;
                TRACE_CRIT("Unable to put parameter %ws", szParameterName);
                goto end;
            }
            Status = WBEM_NO_ERROR;
        }

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_INVALID_PARAMETER;
    }

end:

    if (pSA!=NULL)
    {
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiDWORDParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT DWORD              *pValue
)
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    DWORD Value=0;


    try
    {
        _variant_t   v_value;
        CIMTYPE      v_type;
        HRESULT hr;
    
        hr = spObj->Get(
                _bstr_t(szParameterName), // Name
                0,                     // Reserved, must be 0     
                &v_value,               // Place to store value
                &v_type,                // Type of value
                NULL                   // Flavor (unused)
                );
       if (FAILED(hr))
       {
            // Couldn't read the parameter
            //
            TRACE_CRIT(
                "GetDWORDParm:Couldn't retrieve %ws from 0x%p",
                szParameterName,
                (PVOID) spObj
                );
            goto end;
       }
       else
       {
           Value = (DWORD) (long)  v_value;
           v_value.Clear(); // Must be cleared after each call to Get.
           Status = WBEM_NO_ERROR;
        }

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_NOT_FOUND;
    }

end:

    *pValue = Value;

    return Status;

}


WBEMSTATUS
CfgUtilSetWmiDWORDParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  DWORD               Value
)
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;


    try
    {

        HRESULT     hr;
        _bstr_t     bstrName =  szParameterName;
        _variant_t  v_value = (long) Value;
        
        hr = spObj->Put(
                 bstrName, // Parameter Name
                 0, // Must be 0
                 &v_value,
                 0  // Must be 0
                 );
        v_value.Clear();
    
        if (FAILED(hr))
        {
            TRACE_CRIT("Unable to put parameter %ws", szParameterName);
            goto end;
        }
        Status = WBEM_NO_ERROR;

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_INVALID_PARAMETER;
    }

end:

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiBoolParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT BOOL                *pValue
)
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    BOOL Value=0;

    try
    {
        _variant_t   v_value;
        CIMTYPE      v_type;
        HRESULT hr;
    
        hr = spObj->Get(
                _bstr_t(szParameterName), // Name
                0,                     // Reserved, must be 0     
                &v_value,               // Place to store value
                &v_type,                // Type of value
                NULL                   // Flavor (unused)
                );
       if (FAILED(hr))
       {
            // Couldn't read the parameter
            //
            TRACE_CRIT(
                "GetDWORDParm:Couldn't retrieve %ws from 0x%p",
                szParameterName,
                (PVOID) spObj
                );
            goto end;
       }
       else
       {
           Value = ((bool)  v_value)!=0;
           v_value.Clear(); // Must be cleared after each call to Get.
           Status = WBEM_NO_ERROR;
        }

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_NOT_FOUND;
    }

end:

    *pValue = Value;

    return Status;
}


WBEMSTATUS
CfgUtilSetWmiBoolParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  BOOL                Value
)
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;

    try
    {
        HRESULT     hr;
        _bstr_t     bstrName =  szParameterName;
        _variant_t  v_value = (long) Value;
        
        hr = spObj->Put(
                 bstrName, // Parameter Name
                 0, // Must be 0
                 &v_value,
                 0  // Must be 0
                 );
        v_value.Clear();
    
        if (FAILED(hr))
        {
            TRACE_CRIT("Unable to put parameter %ws", szParameterName);
            goto end;
        }
        Status = WBEM_NO_ERROR;

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_INVALID_PARAMETER;
    }

end:

    return Status;
}


WBEMSTATUS
CfgUtilConnectToServer(
    IN  LPCWSTR szNetworkResource, // \\machinename\root\microsoftnlb  \root\...
    IN  LPCWSTR szUser,
    IN  LPCWSTR szPassword,
    IN  LPCWSTR szAuthority,
    OUT IWbemServices  **ppWbemService // deref when done.
    )
{
    HRESULT hr = WBEM_E_CRITICAL_ERROR;
    IWbemLocatorPtr     spLocator=NULL; // Smart pointer
    IWbemServices       *pService=NULL;

    try
    {

        _bstr_t                serverPath(szNetworkResource);
    
        *ppWbemService = NULL;
        
        hr = CoCreateInstance(CLSID_WbemLocator, 0, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IWbemLocator, 
                              (LPVOID *) &spLocator);
     
        if (FAILED(hr))
        {
            TRACE_CRIT(L"CoCreateInstance  IWebmLocator failed 0x%08lx ", (UINT)hr);
            goto end;
        }

        for (int timesToRetry=0; timesToRetry<10; timesToRetry++)
        {
    
            hr = spLocator->ConnectServer(
                    serverPath,
                    // (szUser!=NULL) ? (_bstr_t(szUser)) : NULL,
                    _bstr_t(szUser),
                    // (szPassword==NULL) ? NULL : _bstr_t(szPassword),
                    _bstr_t(szPassword),
                    NULL, // Locale
                    0,    // Security flags
                    //(szAuthority==NULL) ? NULL : _bstr_t(szAuthority),
                    _bstr_t(szAuthority),
                    NULL,
                    &pService
                 );

            if( !FAILED( hr) )
            {
                break;
            }

            //
            // these have been found to be special cases where retrying may
            // help. The errors below are not in any header file, and I searched
            // the index2a sources for these constants -- no hits.
            // TODO: file bug against WMI.
            //
            if( ( hr == 0x800706bf ) || ( hr == 0x80070767 ) || ( hr == 0x80070005 )  )
            {
                    TRACE_CRIT(L"connectserver recoverable failure, retrying.");
                    Sleep(500);
            }
        }
    
    
        if (FAILED(hr))
        {
            TRACE_CRIT(L"Error 0x%08lx connecting to server", (UINT) hr);
            goto end;
        }
        else
        {
            TRACE_INFO(L"Successfully connected to server %s", serverPath);
        }
        
        // Set the proxy so that impersonation of the client occurs.
        //
        hr = CoSetProxyBlanket(
                pService,
                RPC_C_AUTHN_WINNT,
                RPC_C_AUTHZ_DEFAULT,      // RPC_C_AUTHZ_NAME,
                COLE_DEFAULT_PRINCIPAL,   // NULL,
                RPC_C_AUTHN_LEVEL_DEFAULT,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                COLE_DEFAULT_AUTHINFO, // NULL,
                EOAC_DEFAULT // EOAC_NONE
                );
    
        if (FAILED(hr))
        {
            TRACE_CRIT(L"Error 0x%08lx setting proxy blanket", (UINT) hr);
            goto end;
        }
    
        hr = WBEM_NO_ERROR;

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        hr = WBEM_E_INVALID_PARAMETER;
    }

end:

    spLocator = NULL; // smart pointer.


	if (FAILED(hr))
	{
	    if (pService != NULL)
	    {
	        pService->Release();
	        pService=NULL;
	    }
    }

    *ppWbemService = pService;

    return (WBEMSTATUS) hr;
}

WBEMSTATUS
CfgUtilsGetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    MyNetCfg NetCfg;
    BOOL fBound = FALSE;


    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(FALSE); // TRUE == get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    //
    //
    Status = NetCfg.GetNlbCompatibleNics(
                        ppszNics,
                        pNumNics,
                        pNumBoundToNlb // OPTIONAL
                        );

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    return Status;
}

WBEMSTATUS
CfgUtilGetWmiAdapterObjFromAdapterConfigurationObj(
    IN  IWbemClassObjectPtr spObj,              // smart pointer
    OUT  IWbemClassObjectPtr &spAdapterObj      // smart pointer, by reference
    )
/*
    We need to return the "Win32_NetworkAdapter" object  associated with
    the  "Win32_NetworkAdapterConfiguration" object.

    We use the "Win32_NetworkAdapterSetting" object for this.

*/
{
    spAdapterObj = spObj;
    return WBEM_NO_ERROR;
}

#if 0
HRESULT
Test(
    IWbemClassObject * pNetworkAdapterIn)
//
// FROM: nt\base\cluster\mgmt\cluscfg\server\cenumcluscfgipaddresses.cpp
//
{
    #define ARRAYSIZE(_arr) (sizeof(_arr)/sizeof(_arr[0]))
    #define TraceSysAllocString(_str) (NULL)
    #define TraceSysFreeString( bstrQuery ) (0)
    #define THR(_exp) S_OK
    #define STHR(_exp) S_OK
    #define STATUS_REPORT_STRING(_a, _b, _c, _d, _e) (0)
    #define STATUS_REPORT( _a, _b, _c, _d) (0)
    #define Assert ASSERT
    #define HRETURN( hr ) return hr

    HRESULT                 hr = S_OK;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;
    VARIANT                 var;
    WCHAR                   sz[ 256 ];
    IEnumWbemClassObject *  pConfigurations = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pConfiguration = NULL;
    int                     cFound = 0;
    BSTR                    bstrAdapterName = NULL;
    int                     idx;

    VariantInit( &var );

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    _snwprintf( sz, ARRAYSIZE( sz ), L"Associators of {Win32_NetworkAdapter.DeviceID='%s'} where AssocClass=Win32_NetworkAdapterSetting", var.bstrVal );

    bstrQuery = TraceSysAllocString( sz );
    if ( bstrQuery == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"NetConnectionID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrAdapterName = TraceSysAllocString( var.bstrVal );
    if ( bstrAdapterName == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pConfigurations ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING(
                TASKID_Major_Find_Devices,
                TASKID_Minor_WMI_NetworkAdapterSetting_Qry_Failed,
                IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED,
                bstrAdapterName,
                hr
                );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        hr = pConfigurations->Next( WBEM_INFINITE, 1, &pConfiguration, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            //
            //  KB: 25-AUG-2000 GalenB
            //
            //  WMI only supports one configuration per adapter!
            //
            Assert( idx < 1 );

            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pConfiguration, L"IPEnabled", VT_BOOL, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If this configuration is not for TCP/IP then skip it.
            //
            if ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) )
            {
                hr = S_FALSE;
                STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Non_Tcp_Config, IDS_WARNING__NON_TCP_CONFIG, bstrAdapterName, hr );
                continue;
            } // if:

            hr = STHR( HrSaveIPAddresses( bstrAdapterName, pConfiguration ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  KB: 24-AUG-2000 GalenB
            //
            //  If any configuration returns S_FALSE then we skip.
            //
            if ( hr == S_FALSE )
            {
                pConfiguration->Release();
                pConfiguration = NULL;
                continue;
            } // if:

            cFound++;
            pConfiguration->Release();
            pConfiguration = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WQL_Qry_Next_Failed, IDS_ERROR_WQL_QRY_NEXT_FAILED, bstrQuery, hr );
            goto Cleanup;
        } // else:
    } // for:

    //
    //  If we didn't find any valid configurations then we should return S_FALSE
    //  to tell the caller to ingore that adpater.
    //
    if ( cFound == 0 )
    {
        hr = S_FALSE;
        STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_No_Valid_TCP_Configs, IDS_WARNING_NO_VALID_TCP_CONFIGS, bstrAdapterName, hr );
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetAdapterConfiguration, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );
    TraceSysFreeString( bstrAdapterName );

    if ( pConfiguration != NULL )
    {
        pConfiguration->Release();
    } // if:

    if ( pConfigurations != NULL )
    {
        pConfigurations->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrGetAdapterConfiguration
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbportrule.h ===
#ifndef _MNLBPORTRULE_H
#define _MNLBPORTRULE_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNLBPortRule interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

// Include Files

class MNLBPortRule
{
public:

    enum MNLBPortRule_Error
    {
        MNLBPortRule_SUCCESS = 0,
        
        InvalidRule = 1,

        InvalidNode = 2,

        COM_FAILURE  = 10,
    };

    enum Protocol
    {
        tcp,
        udp,
        both,
    };


    enum Affinity
    {
        none,
        single,
        classC,
    };


    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // startPort             IN   : start port in range.
    // endPort               IN   : end port in range.
    // trafficToHandle       IN   : set port for specified protocol.
    // 
    // Returns:
    // -------
    // none.
    MNLBPortRule( long startPort,
                  long endPort,
                  Protocol      trafficToHandle );


    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    MNLBPortRule();


    bool
    operator==(const MNLBPortRule& objToCompare ) const; 

    bool
    operator!=(const MNLBPortRule& objToCompare ) const;

    long _key;

    long _startPort;
    long _endPort;

    Protocol      _trafficToHandle;


};


// load balanced port rule class.
class MNLBPortRuleLoadBalanced : public MNLBPortRule
{
public:

    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // startPort             IN   : start port in range.
    // endPort               IN   : end port in range.
    // trafficToHandle       IN   : set port for specified protocol.
    // isEqualLoadBalanced   IN   : indicates whether equal load balanced.
    // load                  IN   : if not equalLoadBalanced indicates load%.
    // Affinity              IN   : indicates affinity of connection.
    // 
    // Returns:
    // -------
    // none.

    MNLBPortRuleLoadBalanced( long startPort,
                           long endPort,
                           Protocol      traficToHandle,
                           bool          isEqualLoadBalanced,
                           long load,
                           Affinity      affinity );

    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    MNLBPortRuleLoadBalanced();

    bool
    operator==(const MNLBPortRuleLoadBalanced& objToCompare ) const;

    bool
    operator!=(const MNLBPortRuleLoadBalanced& objToCompare ) const;

    bool          _isEqualLoadBalanced;
    
    long _load;

    Affinity      _affinity;


};
    
// failover class.
class MNLBPortRuleFailover : public MNLBPortRule
{
public:

    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // startPort             IN   : start port in range.
    // endPort               IN   : end port in range.
    // trafficToHandle       IN   : set port for specified protocol.
    // priority              IN   : indicates host priority for failover.
    // 
    // Returns:
    // -------
    // none.

    MNLBPortRuleFailover( long startPort,
                       long endPort,
                       Protocol      traficToHandle,
                       long priority );


    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    MNLBPortRuleFailover();


    bool
    operator==(const MNLBPortRuleFailover& objToCompare ) const;

    bool
    operator!=(const MNLBPortRuleFailover& objToCompare ) const;

    long _priority;

};

class MNLBPortRuleDisabled : public MNLBPortRule
{

public:
    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // startPort             IN   : start port in range.
    // endPort               IN   : end port in range.
    // trafficToHandle       IN   : set port for specified protocol.
    // 
    // Returns:
    // -------
    // none.

    MNLBPortRuleDisabled( long startPort,
                       long endPort,
                       Protocol      traficToHandle );

    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    MNLBPortRuleDisabled();

    bool
    operator==(const MNLBPortRuleDisabled& objToCompare ) const;

    bool
    operator!=(const MNLBPortRuleDisabled& objToCompare ) const;


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\makefile.inc ===
$(O)\nlbmprov.mof $(O)\nlbmprov.mfl: nlbmprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\nlbmprov.mof -MFL:$(O)\nlbmprov.mfl nlbmprov.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#undef UNICODE
#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>

void __stdcall InitializeTraceing(void);
void __stdcall DeinitializeTraceing(void);

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{4c97e0a8-c5ea-40fd-960d-7d6c987be0a6}";
CLSID CLSID_NLBSNIC;

extern BOOL g_UpdateConfigurationEnabled;

//Count number of objects and number of locks.
long g_cLock=0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

    CLSIDFromString(GUIDSTRING, &CLSID_NLBSNIC);
    if (CLSID_NLBSNIC!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"NLBSNIC"))
    {
        sc = S_OK;
    }
    else
    {
        sc = S_FALSE;
    }
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "";
    char * pModel;
    HKEY hKey1, hKey2;

    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

    if(g_UpdateConfigurationEnabled && Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    CLSIDFromString(GUIDSTRING, &CLSID_NLBSNIC);
    StringFromGUID2(CLSID_NLBSNIC, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    CLSIDFromString(GUIDSTRING, &CLSID_NLBSNIC);
    StringFromGUID2(CLSID_NLBSNIC, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain ( HINSTANCE hInstDLL, // handle to dll module
                        DWORD fdwReason,    // reason for calling function
                        LPVOID lpReserved   )   // reserved
{
    BOOL bRet = TRUE;
    
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:

    // TO DO: Consider adding DisableThreadLibraryCalls().

         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
            ghModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL(L"NLBSNIC");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\cfgutils.h ===
//***************************************************************************
//
//  UPDATECFG.H
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Defines class NlbConfigurationUpdate, used for 
//           async update of NLB properties associated with a particular NIC.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created
//
//***************************************************************************

typedef struct _NLB_IP_ADDRESS_INFO
{
    WCHAR       IpAddress[WLBS_MAX_CL_IP_ADDR];
    WCHAR       SubnetMask[WLBS_MAX_CL_NET_MASK];
    
} NLB_IP_ADDRESS_INFO;

WBEMSTATUS
CfgUtilInitialize(VOID);

VOID
CfgUtilDeitialize(VOID);

//
// Gets the list of IP addresses and the friendly name for the specified NIC.
//
WBEMSTATUS
CfgUtilGetIpAddressesAndFriendlyName(
    IN  LPCWSTR szNic,
    OUT UINT    *pNumIpAddresses,
    OUT NLB_IP_ADDRESS_INFO **ppIpInfo, // Free using c++ delete operator.
    OUT LPWSTR *pszFriendlyName // Optional, Free using c++ delete
    );

//
// Sets the list of statically-bound IP addresses for the NIC.
// if NumIpAddresses is 0, the NIC is configured for DHCP.
//
WBEMSTATUS
CfgUtilSetStaticIpAddresses(
    IN  LPCWSTR szNic,
    IN  UINT    NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    );

//
//    Returns an array of pointers to string-version of GUIDS
//    that represent the set of alive and healthy NICS that are
//    suitable for NLB to bind to -- basically alive ethernet NICs.
//
//    Delete ppNics using the delete WCHAR[] operator. Do not
//    delete the individual strings.
//
WBEMSTATUS
CfgUtilsGetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // Optional
        );

//
// Determines whether NLB is bound to the specified NIC.
//
WBEMSTATUS
CfgUtilCheckIfNlbBound(
    IN  LPCWSTR szNic,
    OUT BOOL *pfBound
    );

//
// Binds/unbinds NLB to the specified NIC.
//
WBEMSTATUS
CfgUtilChangeNlbBindState(
    IN  LPCWSTR szNic,
    IN  BOOL fBind
    );


//
// Initializes pParams using default values.
//
VOID
CfgUtilInitializeParams(
    OUT WLBS_REG_PARAMS *pParams
    );

//
// Gets the current NLB configuration for the specified NIC
//
WBEMSTATUS
CfgUtilGetNlbConfig(
    IN  LPCWSTR szNic,
    OUT WLBS_REG_PARAMS *pParams
    );

//
// Sets the current NLB configuration for the specified NIC. This
// includes notifying the driver if required.
//
WBEMSTATUS
CfgUtilSetNlbConfig(
    IN  LPCWSTR szNic,
    IN  WLBS_REG_PARAMS *pParams
    );

//
// Recommends whether the update should be performed async or sync
// Returns WBEM_S_FALSE if the update is a no op.
// Returns WBEM_INVALID_PARAMATER if the params are invalid.
//
WBEMSTATUS
CfgUtilsAnalyzeNlbUpdate(
    IN  WLBS_REG_PARAMS *pCurrentParams, OPTIONAL
    IN  WLBS_REG_PARAMS *pNewParams,
    OUT BOOL *pfConnectivityChange
    );


//
// Verifies that the NIC GUID exists.
//
WBEMSTATUS
CfgUtilsValidateNicGuid(
    IN LPCWSTR szGuid
    );


WBEMSTATUS
CfgUtilControlCluster(
    IN  LPCWSTR szNic,
    IN  LONG    ioctl
    );


WBEMSTATUS
CfgUtilSafeArrayFromStrings(
    IN  LPCWSTR       *pStrings,
    IN  UINT          NumStrings,
    OUT SAFEARRAY   **ppSA
    );

WBEMSTATUS
CfgUtilStringsFromSafeArray(
    IN  SAFEARRAY   *pSA,
    OUT LPWSTR     **ppStrings,
    OUT UINT        *pNumStrings
    );


_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));

WBEMSTATUS
get_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    OUT LPWSTR *ppStringValue
    );


WBEMSTATUS
CfgUtilGetWmiObjectInstance(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szClassName,
    IN  LPCWSTR             szPropertyName,
    IN  LPCWSTR             szPropertyValue,
    OUT IWbemClassObjectPtr &sprefObj // smart pointer
    );

WBEMSTATUS
CfgUtilGetWmiRelPath(
    IN  IWbemClassObjectPtr spObj,
    OUT LPWSTR *            pszRelPath          // free using delete 
    );

WBEMSTATUS
CfgUtilGetWmiInputInstanceAndRelPath(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szClassName,
    IN  LPCWSTR             szPropertyName, // NULL: return Class rel path
    IN  LPCWSTR             szPropertyValue,
    IN  LPCWSTR             szMethodName,
    OUT IWbemClassObjectPtr &spWbemInputInstance, // smart pointer
    OUT LPWSTR *           pszRelPath          // free using delete 
    );


WBEMSTATUS
CfgUtilGetWmiStringParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT LPWSTR *ppStringValue
);


WBEMSTATUS
CfgUtilSetWmiStringParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  LPCWSTR             szValue
    );


WBEMSTATUS
CfgUtilGetWmiStringArrayParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT LPWSTR              **ppStrings,
    OUT UINT                *pNumStrings
);


WBEMSTATUS
CfgUtilSetWmiStringArrayParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  LPCWSTR             *ppStrings,
    IN  UINT                NumStrings
);


WBEMSTATUS
CfgUtilGetWmiDWORDParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT DWORD              *pValue
);


WBEMSTATUS
CfgUtilSetWmiDWORDParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  DWORD               Value
);


WBEMSTATUS
CfgUtilGetWmiBoolParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT BOOL                *pValue
);


WBEMSTATUS
CfgUtilSetWmiBoolParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  BOOL                Value
);

WBEMSTATUS
CfgUtilConnectToServer(
    IN  LPCWSTR szNetworkResource, // \\machinename\root\microsoftnlb  \root\...
    IN  LPCWSTR szUser,   // Must be NULL for local server
    IN  LPCWSTR szPassword,   // Must be NULL for local server
    IN  LPCWSTR szAuthority,  // Must be NULL for local server
    OUT IWbemServices  **ppWbemService // deref when done.
    );

LPWSTR *
CfgUtilsAllocateStringArray(
    UINT NumStrings,
    UINT MaxStringLen      //  excluding ending NULL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\myntrtl.h ===
//
// These are taken from NTRTL.H. Currently including ntrtl.h causes
// errors because of a conflict with some other header file.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\mnlbprovidersetting.h ===
#ifndef _MNLBSETTING_H
#define _MNLBSETTING_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNLBProviderSetting interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------


// Include Files


#include "MNLBPortRule.h"

#include "Common.h"

#include "MWmiObject.h"

#include "MWmiInstance.h"

#include <vector>
#include <memory>

#include <comdef.h>

using namespace std;

class MNLBProviderSetting
{
public:
    enum MNLBProviderSetting_Error
    {
        MNLBProviderSetting_SUCCESS        = 0,

        COM_FAILURE                 = 1,

        UNCONSTRUCTED               = 2,

        MACHINE_FAILURE             = 3,
        
        BOUND                       = 4,

        UNBOUND                     = 5,

        NO_SUCH_NIC                 = 6,
        
        NLBS_NOT_INSTALLED          = 7,

        NO_SUCH_IP                  = 8,

        INVALID_RULE                = 9,
    };

    
    MNLBProviderSetting( _bstr_t    fullNICName );


    // NOT IMPLEMENTED. 
    // 
    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    MNLBProviderSetting();


    //
    // Description:
    // -----------
    // copy constructor.
    // 
    // Parameters:
    // ----------
    // objToCopy             IN  :  object to copy.
    // 
    // Returns:
    // -------
    // none.

    MNLBProviderSetting(const MNLBProviderSetting& objToCopy );


    //
    // Description:
    // -----------
    // assignment operator
    // 
    // Parameters:
    // ----------
    // rhs             IN   : object to assign.
    // 
    // Returns:
    // -------
    // self

    MNLBProviderSetting&
    operator=( const MNLBProviderSetting& rhs );


    //
    // Description:
    // -----------
    // destructor
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // none.

    ~MNLBProviderSetting();


    //
    // Description:
    // -----------
    // gets the nlbs host properties.
    // 
    // Parameters:
    // ----------
    // hp                       OUT      : host properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    getHostProperties( HostProperties* hp );

    //
    // Description:
    // -----------
    // gets the nlbs cluster properties.
    // 
    // Parameters:
    // ----------
    // cp                       OUT      : cluster properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    getClusterProperties( ClusterProperties* cp );


    //
    // Description:
    // -----------
    // sets the nlbs host properties.
    // 
    // Parameters:
    // ----------
    // hp                       IN      : host properties to set.
    // retVal                   OUT     : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    setHostProperties( const HostProperties& hp,
                       unsigned long* retVal );


    //
    // Description:
    // -----------
    // sets the nlbs cluster properties.
    // 
    // Parameters:
    // ----------
    // cp                       IN      : cluster properties to set.
    // retVal                   OUT     : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    setClusterProperties( const ClusterProperties& cp,
                          unsigned long* retVal );

    //
    // Description:
    // -----------
    // sets the nlbs remote control password.
    // 
    // Parameters:
    // ----------
    // password                 IN      : password to set.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    setPassword( const _bstr_t& password,
                 unsigned long* retVal );                 

    //
    // Description:
    // -----------
    // get the load balanced port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsLB           OUT    : load balanced port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.


    MNLBProviderSetting_Error
    getPortRulesLoadBalanced( vector<MNLBPortRuleLoadBalanced>* portsLB );


    //
    // Description:
    // -----------
    // get the failover port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsF           OUT    : failover port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    getPortRulesFailover( vector<MNLBPortRuleFailover>* portsF );


    //
    // Description:
    // -----------
    // get the disabled port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsD           OUT    : failover port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    getPortRulesDisabled( vector<MNLBPortRuleDisabled>* portsD );

    //
    // Description:
    // -----------
    // adds a load balanced port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleLB             IN  :  load balanced port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    addPortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB );

    //
    // Description:
    // -----------
    // adds a failover port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleF             IN  :  failover port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    addPortRuleFailover( const MNLBPortRuleFailover& portRuleF );


    //
    // Description:
    // -----------
    // adds a disabled port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleD             IN  :  disabled port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    addPortRuleDisabled( const MNLBPortRuleDisabled& portRuleD );
    

    //
    // Description:
    // -----------
    // removes a load balanced port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleLB             IN  :  load balanced port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    removePortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB );

    //
    // Description:
    // -----------
    // removes a failover port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleF             IN  :  failover port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    removePortRuleFailover( const MNLBPortRuleFailover& portRuleF );


    //
    // Description:
    // -----------
    // removes a disabled port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleD             IN  :  disabled port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    removePortRuleDisabled( const MNLBPortRuleDisabled& portRuleD );

    //
    // Description:
    // -----------
    // sync up the driver with the parameters in the regestry
    // 
    // Parameters:
    // ----------
    // retVal              OUT  : whether sync was successful or not.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBProviderSetting_Error
    reload( unsigned long* retVal );        

private:

    // data
    auto_ptr<MWmiObject>   p_machine;

    _bstr_t mIP;

    _bstr_t nic;    
    
    // functions

    MNLBProviderSetting_Error
    connectToMachine();

    MNLBProviderSetting_Error
    checkNicBinding(_bstr_t& guid );


    MNLBProviderSetting::MNLBProviderSetting_Error
    MNLBProviderSetting::getPortRulesLoadBalanced_private( vector<MNLBPortRuleLoadBalanced>* portsLB, 
                                                    vector<MWmiInstance>*          instances );

    MNLBProviderSetting::MNLBProviderSetting_Error
    MNLBProviderSetting::getPortRulesFailover_private( vector<MNLBPortRuleFailover>*     portsF,
                                                vector<MWmiInstance>*          instances );
    
    MNLBProviderSetting::MNLBProviderSetting_Error
    MNLBProviderSetting::getPortRulesDisabled_private( vector<MNLBPortRuleDisabled>*     portsD,
                                                vector<MWmiInstance>*          instances );

    MNLBProviderSetting_Error
    getClusterIPAndHostID( _bstr_t& clusterIP,
                           _bstr_t& hostID );

};


// ensure type safety

typedef class MNLBProviderSetting MNLBProviderSetting;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\mnlbprovidersetting.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBProviderSetting
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-09-01
// Reason     : clustersetting class no longer has igmpjoininterval
//              property.
//
// Revised by : mhakim
// Date       : 02-11-01
// Reason     : password support added.
//
// Revised by : mhakim
// Date       : 02-14-01
// Reason     : The order in which win2k and whistler settings
//              is done depends on previous state of cluster.

// include files
#include "MNLBProviderSetting.h"
#include "MTrace.h"
#include "WTokens.h"
#include "NICCard.h"

#include <iostream>

using namespace std;

// constructor for local machine
//
MNLBProviderSetting::MNLBProviderSetting( _bstr_t    fullNICName )
        : mIP( L"self" ),
          nic( fullNICName ),
          p_machine( 0 )
{
    connectToMachine();
    TRACE(MTrace::INFO, L"mnlbssetting constructor\n");
}


// default constructor
// 
// note that default constructor is purposely left undefined.  
// NO one should be using it.  It is declared just for vector class usage.


// copy constructor
//
MNLBProviderSetting::MNLBProviderSetting(const MNLBProviderSetting& objToCopy )
        : mIP( objToCopy.mIP ),
          nic( objToCopy.nic ),
          p_machine( auto_ptr<MWmiObject>( new MWmiObject( *objToCopy.p_machine ) ) )
{
    TRACE(MTrace::INFO, L"mnlbssetting copy constructor\n");
}


// assignment operator
//
MNLBProviderSetting&
MNLBProviderSetting::operator=( const MNLBProviderSetting& rhs )
{
    mIP = rhs.mIP;
    nic = rhs.nic;
    p_machine = auto_ptr<MWmiObject>( new MWmiObject( *rhs.p_machine ) );

    TRACE(MTrace::INFO, L"mnlbssetting assignment operator\n");

    return *this;
}


// destructor
//
MNLBProviderSetting::~MNLBProviderSetting()
{
    TRACE(MTrace::INFO, L"mnlbssetting destructor\n");
}

// getClusterProperties
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getClusterProperties( ClusterProperties* cp )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set parameters to get for win2k
    //
    vector<MWmiParameter* >   parameterStoreWin2k;

    MWmiParameter ClusterIPAddress(L"ClusterIPAddress");
    parameterStoreWin2k.push_back( &ClusterIPAddress );

    MWmiParameter ClusterNetworkMask(L"ClusterNetworkMask");
    parameterStoreWin2k.push_back( &ClusterNetworkMask );

    MWmiParameter ClusterName(L"ClusterName");
    parameterStoreWin2k.push_back( &ClusterName );

    MWmiParameter ClusteMACAddress(L"ClusterMACAddress");
    parameterStoreWin2k.push_back( &ClusteMACAddress );

    MWmiParameter MulticastSupportEnabled(L"MulticastSupportEnabled");
    parameterStoreWin2k.push_back( &MulticastSupportEnabled );

    MWmiParameter RemoteControlEnabled(L"RemoteControlEnabled");
    parameterStoreWin2k.push_back( &RemoteControlEnabled );

    // set parameters to get for whistler
    // these properties only present in whistler.
    //
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter IgmpSupport(L"IgmpSupport");
    parameterStoreWhistler.push_back( &IgmpSupport );

    MWmiParameter ClusterIPToMulticastIP(L"ClusterIPToMulticastIP");
    parameterStoreWhistler.push_back( &ClusterIPToMulticastIP );

    MWmiParameter MulticastIPAddress(L"MulticastIPAddress");
    parameterStoreWhistler.push_back( &MulticastIPAddress );

    // Edited( mhakim 02-09-01)
    // now no longer do we have any igmpjoininterval property.
    // 

    // MWmiParameter IgmpJoinInterval(L"IgmpJoinInterval");
    // parameterStoreWhistler.push_back( &IgmpJoinInterval );

    // get instances of clustersetting class.    
    //
    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStore );

    // get win2k parameters
    instanceStore[0].getParameters( parameterStoreWin2k );

    // get whistler parameters
    bool machineIsWhistler = true;

    try
    {
        // this will fail on win2k
        // as adapterguid, igmpsupport etc are not present.
        instanceStore[0].getParameters( parameterStoreWhistler );
    }
    catch( _com_error e )
    {
        // maybe it was a win2k machine.  This exception is expected, thus catch.
        // for better safety, need to find exact error code returned and then only do the 
        // folllowing otherwise need to rethrow.
        //
        TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        machineIsWhistler = false;
    }

    cp->cIP = ClusterIPAddress.getValue();
    
    cp->cSubnetMask = ClusterNetworkMask.getValue();
            
    cp->cFullInternetName = ClusterName.getValue();
            
    cp->cNetworkAddress = ClusteMACAddress.getValue();
            
    cp->multicastSupportEnabled = MulticastSupportEnabled.getValue();
        
    cp->remoteControlEnabled  = RemoteControlEnabled.getValue();

    if( machineIsWhistler == true )
    {
        cp->igmpSupportEnabled = IgmpSupport.getValue();
                
        cp->clusterIPToMulticastIP = ClusterIPToMulticastIP.getValue();

        cp->multicastIPAddress = MulticastIPAddress.getValue();

        // Edited( mhakim 02-09-01)
        // now no longer do we have any igmpjoininterval property.
        // 

        // cp->igmpJoinInterval = IgmpJoinInterval.getValue();
    }

    return MNLBProviderSetting_SUCCESS;
}    

// getHostProperties
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getHostProperties( HostProperties* hp )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // get node properties
    //
    vector<MWmiParameter* >    parameterStoreWin2k;

    // the status code is to be got from the Node class.
    //
    MWmiParameter  StatusCode(L"StatusCode");
    parameterStoreWin2k.push_back( &StatusCode );    

    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_Node.Name=\"" + clusterIP + L":" + hostID + L"\"";

    p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                    relPath,
                                    &instanceStore );
    instanceStore[0].getParameters( parameterStoreWin2k );

    hp->hostStatus = long( StatusCode.getValue() );

    parameterStoreWin2k.erase( parameterStoreWin2k.begin(), parameterStoreWin2k.end() );

    instanceStore.erase( instanceStore.begin(), instanceStore.end() );
    
    MWmiParameter  DedicatedIPAddress(L"DedicatedIPAddress");
    parameterStoreWin2k.push_back( &DedicatedIPAddress );

    MWmiParameter  DedicatedNetworkMask(L"DedicatedNetworkMask");
    parameterStoreWin2k.push_back( &DedicatedNetworkMask );

    MWmiParameter  HostPriority(L"HostPriority");
    parameterStoreWin2k.push_back( &HostPriority );

    MWmiParameter  ClusterModeOnStart(L"ClusterModeOnStart");
    parameterStoreWin2k.push_back( &ClusterModeOnStart );

    MWmiParameter Server("__Server");
    parameterStoreWin2k.push_back( &Server);

    // set parameters to get for whistler
    // these properties only present in whistler.
    //
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStoreWhistler.push_back( &AdapterGuid );


    // get instances of nodesetting class.
    //
    relPath = L"MicrosoftNLB_NodeSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_NodeSetting",
                                    relPath,
                                    &instanceStore );

    // get win2k parameters.
    instanceStore[0].getParameters( parameterStoreWin2k );

    // get whistler parameters
    bool machineIsWhistler = true;

    try
    {
        // this will fail on win2k
        // as adapterguid, igmpsupport etc are not present.
        instanceStore[0].getParameters( parameterStoreWhistler );
    }
    catch( _com_error e )
    {
        // maybe it was a win2k machine.  This exception is expected, thus catch.
        // for better safety, need to find exact error code returned and then only do the 
        // folllowing otherwise need to rethrow.
        //
        TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        machineIsWhistler = false;
    }


    hp->hIP = DedicatedIPAddress.getValue();

    hp->hSubnetMask = DedicatedNetworkMask.getValue();
            
    hp->hID         = HostPriority.getValue();
            
    hp->initialClusterStateActive = ClusterModeOnStart.getValue();

    hp->machineName = Server.getValue();

    return MNLBProviderSetting_SUCCESS;
}


// setClusterProperties    
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::setClusterProperties( const ClusterProperties& cp,
                                           unsigned long* retVal 
                                           )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set parameters to set for win2k
    vector<MWmiParameter* >   parameterStoreWin2k;

    MWmiParameter ClusterIPAddress(L"ClusterIPAddress");
    ClusterIPAddress.setValue( cp.cIP );
    parameterStoreWin2k.push_back( &ClusterIPAddress );
    

    MWmiParameter ClusterNetworkMask(L"ClusterNetworkMask");
    ClusterNetworkMask.setValue( cp.cSubnetMask );
    parameterStoreWin2k.push_back( &ClusterNetworkMask );

    MWmiParameter ClusterName(L"ClusterName");
    ClusterName.setValue( cp.cFullInternetName );
    parameterStoreWin2k.push_back( &ClusterName );

    // mac address cannot be set.

    MWmiParameter MulticastSupportEnabled(L"MulticastSupportEnabled");
    MulticastSupportEnabled.setValue( cp.multicastSupportEnabled );
    parameterStoreWin2k.push_back( &MulticastSupportEnabled );

    MWmiParameter RemoteControlEnabled(L"RemoteControlEnabled");
    RemoteControlEnabled.setValue( cp.remoteControlEnabled );
    parameterStoreWin2k.push_back( &RemoteControlEnabled );

    // set parameters for whistler.
    // these properties only for whistler
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter IgmpSupport(L"IgmpSupport");
    IgmpSupport.setValue( cp.igmpSupportEnabled );
    parameterStoreWhistler.push_back( &IgmpSupport );

    MWmiParameter ClusterIPToMulticastIP(L"ClusterIPToMulticastIP");
    ClusterIPToMulticastIP.setValue( cp.clusterIPToMulticastIP );
    parameterStoreWhistler.push_back( &ClusterIPToMulticastIP );

    MWmiParameter MulticastIPAddress(L"MulticastIPAddress");
    MulticastIPAddress.setValue( cp.multicastIPAddress );
    parameterStoreWhistler.push_back( &MulticastIPAddress );

    // Edited( mhakim 02-09-01)
    // now no longer do we have any igmpjoininterval property.
    // 

    // MWmiParameter IgmpJoinInterval(L"IgmpJoinInterval");
    // IgmpJoinInterval.setValue( cp.igmpJoinInterval );
    // parameterStoreWhistler.push_back( &IgmpJoinInterval );

    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStore );

    // Edited( mhakim 02-14-01)
    //
    // The order in which win2k and whistler operations
    // need to be done depends on previous state of cluster.
    // If the previous mode of cluster was unicast, then
    // you have to do win2k first, whistler next.
    // If the previous mode was mcast+igmp you have to 
    // do whistler first, win2k next.
    // If the previous mode was mcast, the order does not
    // matter.
    // All this is because you cant have unicast+igmp 
    // together.

    // find previous cluster mode.
    ClusterProperties cpPrevious;
    getClusterProperties( &cpPrevious );

    if( cpPrevious.multicastSupportEnabled == false ) 
    {
        // mode is unicast

        // set win2k parameters.
        instanceStore[0].setParameters( parameterStoreWin2k );
        
        // set whistler parameters.
        try
        {
            instanceStore[0].setParameters( parameterStoreWhistler );
        }
        catch( _com_error e )
        {
            // maybe it was a win2k machine.  This exception is expected, thus catch.
            // For better safety, need to match error code returned with expected and then only do the 
            // folllowing otherwise need to rethrow.
            //
            TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        }
    }
    else
    {
        // set whistler parameters.
        try
        {
            instanceStore[0].setParameters( parameterStoreWhistler );
        }
        catch( _com_error e )
        {
            // maybe it was a win2k machine.  This exception is expected, thus catch.
            // For better safety, need to match error code returned with expected and then only do the 
            // folllowing otherwise need to rethrow.
            //
            TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        }

        // set win2k parameters.
        instanceStore[0].setParameters( parameterStoreWin2k );
    }

    // sync up the driver with these changes.
    reload( retVal );

    return MNLBProviderSetting_SUCCESS;
}


// setHostProperties
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::setHostProperties( const HostProperties& hp,
                                 unsigned long* retVal )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set node properties
    //
    vector<MWmiParameter* >    parameterStore;
    
    MWmiParameter  DedicatedIPAddress(L"DedicatedIPAddress");
    DedicatedIPAddress.setValue( hp.hIP );
    parameterStore.push_back( &DedicatedIPAddress );

    MWmiParameter  DedicatedNetworkMask(L"DedicatedNetworkMask");
    DedicatedNetworkMask.setValue( hp.hSubnetMask );
    parameterStore.push_back( &DedicatedNetworkMask );

    MWmiParameter  HostPriority(L"HostPriority");
    HostPriority.setValue( hp.hID );
    parameterStore.push_back( &HostPriority );

    MWmiParameter  ClusterModeOnStart(L"ClusterModeOnStart");
    ClusterModeOnStart.setValue( hp.initialClusterStateActive );
    parameterStore.push_back( &ClusterModeOnStart );

    // get instances of nodesetting class.
    //
    vector< MWmiInstance >     instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_NodeSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_NodeSetting",
                                    relPath,
                                    &instanceStore );

    instanceStore[0].setParameters( parameterStore );
    
    // sync up the driver with these changes.
    reload( retVal );

    return MNLBProviderSetting_SUCCESS;
}

// getPortRulesLoadBalanced
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getPortRulesLoadBalanced( vector<MNLBPortRuleLoadBalanced>* portsLB )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesLoadBalanced_private( portsLB, 
                                             &instanceStore );

}

// getPortRulesLoadBalanced_private
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getPortRulesLoadBalanced_private( vector<MNLBPortRuleLoadBalanced>* portsLB,
                                                vector<MWmiInstance>*          instances )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MWmiParameter EqualLoad(L"EqualLoad");
    parameterStore.push_back( &EqualLoad );

    MWmiParameter LoadWeight(L"LoadWeight");
    parameterStore.push_back( &LoadWeight );

    MWmiParameter AffinityProp(L"Affinity");
    parameterStore.push_back( &AffinityProp );    

    MNLBPortRule::Affinity    affinity;
    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleLoadBalanced",
                             instances );
    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }


        switch(  long(AffinityProp.getValue()) )
        {
            case 0:
                affinity = MNLBPortRule::none;
                break;

            case 1:
                affinity = MNLBPortRule::single;
                break;

            case 2:
                affinity = MNLBPortRule::classC;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified affinity\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

                
        portsLB->push_back( MNLBPortRuleLoadBalanced(long (StartPort.getValue()),
                                                  long( EndPort.getValue()),
                                                  trafficToHandle,
                                                  bool( EqualLoad.getValue()),
                                                  long( LoadWeight.getValue()),
                                                  affinity) );
                                
    }

    return MNLBProviderSetting_SUCCESS;
}


// getPortRulesFailover
//       
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getPortRulesFailover( vector<MNLBPortRuleFailover>* portsF )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesFailover_private( portsF, 
                                         &instanceStore );
}
    

// getPortRulesFailover_private
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getPortRulesFailover_private( vector<MNLBPortRuleFailover>* portsF,
                                            vector<MWmiInstance>*          instances )
{    
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MWmiParameter Priority(L"Priority");
    parameterStore.push_back( &Priority );

    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleFailover",
                             instances );

    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

        portsF->push_back( MNLBPortRuleFailover(long (StartPort.getValue()),
                                             long( EndPort.getValue()),
                                             trafficToHandle,
                                             long( Priority.getValue()) )
                           );
    }

    return MNLBProviderSetting_SUCCESS;
}


// getPortRulesDisabled
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getPortRulesDisabled( vector<MNLBPortRuleDisabled>* portsD )
{

    vector<MWmiInstance> instanceStore;

    return getPortRulesDisabled_private( portsD, 
                                         &instanceStore );

}    


// getPortRulesDisabled_private
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getPortRulesDisabled_private( vector<MNLBPortRuleDisabled>*         portsD,
                                            vector<MWmiInstance>*          instances )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleDisabled",
                             instances );
    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

        portsD->push_back( MNLBPortRuleDisabled( long (StartPort.getValue() ),
                                              long( EndPort.getValue() ),
                                              trafficToHandle ) );
    }

    return MNLBProviderSetting_SUCCESS;
}


// addPortRuleLoadBalanced
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::addPortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = clusterIP + L":" + hostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleLB._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  EndPort(L"EndPort");
    EndPort.setValue( portRuleLB._endPort );
    instanceParameter.push_back( &EndPort );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleLB._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }

    instanceParameter.push_back( &protocol );

    MWmiParameter  el(L"EqualLoad");
    el.setValue( portRuleLB._isEqualLoadBalanced );
    instanceParameter.push_back( &el );    

    MWmiParameter  lw(L"LoadWeight");
    lw.setValue( portRuleLB._load );
    instanceParameter.push_back( &lw );    

    MWmiParameter  affinity(L"Affinity");
    long affinityValue;
    switch(  portRuleLB._affinity )
    {
        case MNLBPortRule::none:
            affinityValue = 0;
            affinity.setValue(affinityValue);
            break;

        case MNLBPortRule::single:
            affinityValue = 1;
            affinity.setValue(affinityValue);
            break;

        case MNLBPortRule::classC:
            affinityValue = 2;
            affinity.setValue(affinityValue);
            break;

        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified affinity\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &affinity );    

    p_machine->createInstance( L"MicrosoftNLB_PortRuleLoadBalanced",
                               instanceParameter
                               );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBProviderSetting_SUCCESS;
}

// addPortRuleFailover
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::addPortRuleFailover( const MNLBPortRuleFailover& portRuleF )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = clusterIP + L":" + hostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleF._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  EndPort(L"EndPort");
    EndPort.setValue( portRuleF._endPort );
    instanceParameter.push_back( &EndPort );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleF._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &protocol );

    MWmiParameter p("Priority");
    p.setValue( portRuleF._priority);
    instanceParameter.push_back( &p );

    p_machine->createInstance( L"MicrosoftNLB_PortRuleFailover",
                               instanceParameter
                               );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBProviderSetting_SUCCESS;
}


// addPortRuleDisabled
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::addPortRuleDisabled( const MNLBPortRuleDisabled& portRuleD )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = clusterIP + L":" + hostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleD._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  ep(L"EndPort");
    ep.setValue( portRuleD._endPort );
    instanceParameter.push_back( &ep );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleD._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &protocol );

    p_machine->createInstance( L"MicrosoftNLB_PortRuleDisabled",
                               instanceParameter
                               );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBProviderSetting_SUCCESS;
}

// removePortRuleLoadBalanced
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::removePortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleLB._startPort );

    vector<MWmiInstance >           instanceStorePortRuleLoadBalanced;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleLoadBalanced.Name=\""  
        + clusterIP + L":" + hostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleLoadBalanced",
                                    relPath,
                                    &instanceStorePortRuleLoadBalanced );

    p_machine->deleteInstance( instanceStorePortRuleLoadBalanced[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBProviderSetting_SUCCESS;
}


// removePortRuleFailover
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::removePortRuleFailover( const MNLBPortRuleFailover& portRuleF )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleF._startPort );

    vector<MWmiInstance >           instanceStorePortRuleFailover;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleFailover.Name=\""  
        + clusterIP + L":" + hostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleFailover",
                                    relPath,
                                    &instanceStorePortRuleFailover );

    p_machine->deleteInstance( instanceStorePortRuleFailover[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBProviderSetting_SUCCESS;
}

// removePortRuleDisabled
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::removePortRuleDisabled( const MNLBPortRuleDisabled& portRuleD )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleD._startPort );

    vector<MWmiInstance >           instanceStorePortRuleDisabled;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleDisabled.Name=\""  
        + clusterIP + L":" + hostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleDisabled",
                                    relPath,
                                    &instanceStorePortRuleDisabled );

    p_machine->deleteInstance( instanceStorePortRuleDisabled[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );
    return MNLBProviderSetting_SUCCESS;
}

// getClusterIPAndHostID
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::getClusterIPAndHostID( _bstr_t& clusterIP,
                                            _bstr_t& hostID )
{
    //
    // this ensures that nic is present, and bound to nlbs 
    // on nic specified at construction time.
    //
    _bstr_t guid;
    checkNicBinding( guid );

    //
    // find clustersettingclass mapping to this nic.
    //

    // set parameters to get.
    //
    vector<MWmiParameter* >   parameterStore;

    MWmiParameter Name(L"Name");
    parameterStore.push_back( &Name );

    // get guid
    // This parameter not present on win2k nlbs provider.
    //
    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStore.push_back( &AdapterGuid );

    // get instances of clustersetting class.    
    //
    vector< MWmiInstance >    instanceStore;
    bool found = false;
    int  i;

    p_machine->getInstances( L"Microsoftnlb_ClusterSetting",
                             &instanceStore );
    found = false;
    for( i = 0; i < instanceStore.size(); ++i )
    {
        try
        {
            instanceStore[i].getParameters( parameterStore );
        }
        catch( _com_error e )
        {
            // the above operation can fail on win2k machines.
            // if so we need to handle exception. This clustersetting is the actual one 
            // required.
            found = true;
            break;  // get out of for loop.
        }

        if( guid == _bstr_t( AdapterGuid.getValue() ) )
        {
            // right object found
            found = true;
            break;
        }
    }

    
    if( found == false )
    {
        TRACE(MTrace::SEVERE_ERROR, L"this is unexpected and a bug.  NlbsNic and ClusterSetting class guids may not be matching\n");
        throw _com_error( WBEM_E_UNEXPECTED );
    }

    _bstr_t name = _bstr_t( Name.getValue() );

    WTokens        tok;
    vector<wstring> tokens;
    tok.init( wstring( name ),
              L":" );
    tokens = tok.tokenize();
            
    clusterIP = tokens[0].c_str();
    hostID = tokens[1].c_str();

    return MNLBProviderSetting_SUCCESS;
}


// connectToMachine
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::connectToMachine()
{
    // we want to connect to self machine.
    p_machine = auto_ptr< MWmiObject > ( new MWmiObject( L"root\\microsoftnlb") );

    // check if nic is bound to nlbs.
    _bstr_t guid;
    checkNicBinding( guid );

    return MNLBProviderSetting_SUCCESS;
}


// checkNicBinding
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::checkNicBinding( _bstr_t& guid ) 
{
    bool found = false;

    vector< NICCard::Info > nicList;
    NICCard::getNics( &nicList );
    
    for( int i = 0; i < nicList.size(); ++i )
    {
        if( _bstr_t( nicList[i].fullName.c_str() ) == nic )
        {
            // nic specified found.
            guid = nicList[i].guid.c_str();
            found = true;
            break;
        }
    }

    if( found != true )
    {
        TRACE(MTrace::SEVERE_ERROR, L"nic specified not found on machine\n");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    return MNLBProviderSetting_SUCCESS;
}


// reload
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::reload( unsigned long* retVal )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // form path
    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";

    vector<MWmiInstance >           instanceStoreClusterSetting;
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStoreClusterSetting );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;
            
    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );
            
    instanceStoreClusterSetting[0].runMethod( L"LoadAllSettings",
                                              inputParameters,
                                              outputParameters );

    *retVal = ( long ) returnValue.getValue();

    return MNLBProviderSetting_SUCCESS;
}    


// setPassword
//
MNLBProviderSetting::MNLBProviderSetting_Error
MNLBProviderSetting::setPassword( const _bstr_t& password,
                                  unsigned long* retVal 
                                  )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // form path
    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";

    vector<MWmiInstance >           instanceStoreClusterSetting;
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStoreClusterSetting );

    // input parameters is password
    //
    vector<MWmiParameter *> inputParameters;
    MWmiParameter    Password(L"Password");
    Password.setValue( password );
    inputParameters.push_back( &Password );
            
    // output parameters which are of interest.
    // none.
    //
    vector<MWmiParameter *> outputParameters;
            
    instanceStoreClusterSetting[0].runMethod( L"SetPassword",
                                              inputParameters,
                                              outputParameters );

    reload( retVal );

    return MNLBProviderSetting_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\nlbsnic.cpp ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   NlbsNic.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : Added password support.
//
// Revised by : mhakim
// Date       : 02-16-01
// Reason     : Added friendly name support.
//
// Reason     : filling out version info.  This was being not 
//              done previously in GetObject.

#include <fwcommon.h>  // This must be the first include.

#include "NlbsNic.h"
#include "NICCard.h"
#include "MNicInfo.h"
#include "MIPAddressAdmin.h"
#include "MNLBProviderSetting.h"
#include "Common.h"
#include "MUsingCom.h"
#include "WTokens.h"
#include "MNLBMachine.h"

#include <winbase.h> // For Sleep
#include <windows.h> // For Sleep

#include <string>
//#include <wlbsiocl.h>
#include "wlbsconfig.h"
#include "myntrtl.h"
#include "wlbsparm.h"
#include "cfgutils.h"
#include "updatecfg.h"
#include "nlbsnic.tmh"
using namespace std;

MUsingCom   com;

BOOL g_UpdateConfigurationEnabled = FALSE;


WBEMSTATUS
ProvGetClusterConfiguration(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvUpdateClusterConfiguration(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvQueryConfigurationUpdateStatus(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WCHAR*
CNlbsNic::version = L"03-09-2001";

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
// DONE : mhakim
//===================================================================
CNlbsNic MyNlbsNicSet (PROVIDER_NAME_NLBSNIC, L"root\\microsoftnlb") ;

// Property names
//===============
const static WCHAR* pAdapterGuid = L"AdapterGuid" ;
const static WCHAR* pDependent = L"Dependent" ;
const static WCHAR* pFriendlyName = L"FriendlyName" ;
const static WCHAR* pFullName = L"FullName" ;
const static WCHAR* pVersion = L"Version" ;

/*****************************************************************************
 *
 *  FUNCTION    :   CNlbsNic::CNlbsNic
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CNlbsNic::CNlbsNic (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
        Provider(lpwszName, lpwszNameSpace)
{
    //
    // Enable WMI event tracing
    //
    WPP_INIT_TRACING(L"Microsoft\\NLB\\TPROV");

    if (g_UpdateConfigurationEnabled)
    {
        //
        //    Initialize update config
        //
        NlbConfigurationUpdate::Initialize();
    }
    
}

/*****************************************************************************
 *
 *  FUNCTION    :   CNlbsNic::~CNlbsNic
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CNlbsNic::~CNlbsNic ()
{

    if (g_UpdateConfigurationEnabled)
    {
        //
        // Deinitialize update config code
        //
        NlbConfigurationUpdate::Deinitialize();
    }

    //
    // Disable WMI event tracing
    //
    WPP_CLEANUP();
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must 
*                       be filled in.  If there are no instances, return 
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*                DONE: mhakim
*
*****************************************************************************/
HRESULT CNlbsNic::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // get information about all nics on the machine.
    //
    NICCard::NICCard_Error errN;
    vector< NICCard::Info > nicList;
    errN = NICCard::getNics( &nicList );
    if( errN != NICCard::NICCard_SUCCESS )
    {
        return WBEM_E_NOT_FOUND;
    }

    // populate all instances.
    //
    for( int i = 0; i < nicList.size(); ++i )
    {
        CInstance* pInstance = CreateNewInstance(pMethodContext);

        pInstance->SetCHString(pAdapterGuid, nicList[i].guid.c_str()  );

        pInstance->SetCHString(pFriendlyName, nicList[i].friendlyName.c_str() );

        pInstance->SetCHString(pFullName, nicList[i].fullName.c_str() );

        pInstance->SetCHString(pVersion, version );

        hRes = pInstance->Commit();
        pInstance->Release();
    }
    
    hRes = WBEM_S_NO_ERROR;    
    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/
HRESULT CNlbsNic::GetObject ( CInstance* pInstance, long lFlags )
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString     sTemp;
    pInstance->GetCHString( L"FullName",
                            sTemp );
    
    wstring fullName = sTemp;

    NICCard::NICCard_Error errN;
    vector< NICCard::Info > nicList;
    errN = NICCard::getNics( &nicList );
    if( errN != NICCard::NICCard_SUCCESS )
    {
        return WBEM_E_NOT_FOUND;
    }

    // populate all instances.
    //
    hr = WBEM_E_NOT_FOUND;
    for( int i = 0; i < nicList.size(); ++i )
    {
        if( nicList[i].fullName == fullName )
        {
            // found specific instance.
            //
            pInstance->SetCHString(pAdapterGuid, nicList[i].guid.c_str()  );

            pInstance->SetCHString(pFriendlyName, nicList[i].friendlyName.c_str() );

            pInstance->SetCHString(pFullName, nicList[i].fullName.c_str() );

            pInstance->SetCHString(pVersion, version );

            hr = WBEM_S_NO_ERROR;    
            break;
        }
    }

    return hr;
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CNlbsNic::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : CNlbsNic::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, 
*                       or are creating a 'method only' provider, remove this 
*                       method.
*
*****************************************************************************/
HRESULT CNlbsNic::PutInstance ( const CInstance &Instance, long lFlags)
{
    // Use the CInstance Get functions (for example, call 
    // GetCHString(L"Name", sTemp)) against Instance to see the key values 
    // the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CNlbsNic::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    // Use the CInstance Get functions (for example, call 
    // GetCHString(L"Name", sTemp)) against Instance to see the key values 
    // the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CNlbsNic::ExecMethod ( const CInstance& Instance,
                               const BSTR bstrMethodName,
                               CInstance *pInParams,
                               CInstance *pOutParams,
                               long lFlags)
{
    // For non-static methods, use the CInstance Get functions (for example, 
    // call GetCHString(L"Name", sTemp)) against Instance to see the key 
    // values the client requested.
    HRESULT hresult = WBEM_E_PROVIDER_NOT_CAPABLE;

    CHString     sTemp;

    wstring fullName;

    wstring clusterIPAddress;
    wstring clusterNetworkMask;
    wstring clusterName;
    wstring password;

    _variant_t  hostPriority;
    wstring dedicatedIPAddress;
    wstring dedicatedNetworkMask;

    bool retBool;

    Instance.GetCHString( L"FullName",
                          sTemp );
    fullName = sTemp;

    NICCard nic( NICCard::fullName,
                 fullName );

    NICCard::NICCard_Error err;

    DWORD retValue= 100;

    if (_wcsicmp(bstrMethodName, L"IsBound") == 0)
    {
        // check if bound or not.
        err = nic.isBoundTo( L"ms_wlbs");

        if( err == NICCard::BOUND )
        {
            retValue = 1;
        }
        else if( err == NICCard::UNBOUND )
        {
            retValue = 0;
        }
        else if( err == NICCard::NO_SUCH_NIC )
        {
            retValue = 20;
        }
        else if( err == NICCard::NO_SUCH_COMPONENT )
        {
            retValue = 30;
        }
        else
        {
            retValue = 40;
        }

        hresult = WBEM_S_NO_ERROR;
        pOutParams->SetDWORD(L"ReturnValue", retValue);
        return hresult;

    }
    else if (_wcsicmp(bstrMethodName, L"Bind") == 0)
    {
        // bind nlbs to the nic.
        err = nic.bind( L"ms_wlbs" );
        if( err == NICCard::NICCard_SUCCESS )
        {
            retValue = 0;
        }
        else if( err == NICCard::NO_SUCH_NIC )
        {
            retValue = 20;
        }
        else if( err == NICCard::NO_SUCH_COMPONENT )
        {
            retValue = 30;
        }
        else
        {
            retValue = 40;
        }

        hresult = WBEM_S_NO_ERROR;
        pOutParams->SetDWORD(L"ReturnValue", retValue);
        return hresult;

    }
    else if (_wcsicmp(bstrMethodName, L"Unbind") == 0)
    {
        // unbind nlbs from nic
        err = nic.unbind( L"ms_wlbs" );

        if( err == NICCard::NICCard_SUCCESS )
        {
            retValue = 0;
        }
        else if( err == NICCard::NO_SUCH_NIC )
        {
            retValue = 20;
        }
        else if( err == NICCard::NO_SUCH_COMPONENT )
        {
            retValue = 30;
        }
        else
        {
            retValue = 40;
        }

        hresult = WBEM_S_NO_ERROR;
        pOutParams->SetDWORD(L"ReturnValue", retValue);
        return hresult;

    }
    else if (_wcsicmp(bstrMethodName, L"BindAndConfigure") == 0)
    {
        // here we need to be passed everything
        // required to configure cluster completely
        // on this machine.

        // bind nlbs to the nic.
        err = nic.bind( L"ms_wlbs" );

        if( err == NICCard::NICCard_SUCCESS )
        {
            MNLBProviderSetting nlbs( fullName.c_str() );

            // remove all old port rules.
            // removing LB port rules

            vector<MNLBPortRuleLoadBalanced> portLB;
            nlbs.getPortRulesLoadBalanced( &portLB );
            
            for( int i = 0; i < portLB.size(); ++i )
            {
                nlbs.removePortRuleLoadBalanced( portLB[i] );
            }            

            // removing D port rules

            vector<MNLBPortRuleDisabled> portD;
            nlbs.getPortRulesDisabled( &portD );
            
            for( int i = 0; i < portD.size(); ++i )
            {
                nlbs.removePortRuleDisabled( portD[i] );
            }            
            
            // removing Failover port rules
            vector<MNLBPortRuleFailover> portF;
            nlbs.getPortRulesFailover( &portF );

            for( int i = 0; i < portF.size(); ++i )
            {
                nlbs.removePortRuleFailover( portF[i] );
            }            

            //
            // get port rules to configure.
            //
            SAFEARRAY* portRulesArray;
            SAFEARRAYBOUND sb;
            sb.lLbound = 0;
            sb.cElements = 100;

            portRulesArray = SafeArrayCreate( VT_BSTR, 1, &sb );

            pInParams->GetStringArray( L"PortRules",
                                       portRulesArray );

            vector<_bstr_t> portRulesVector;
            GetVectorFromSafeArray( portRulesArray,
                                    portRulesVector );

            ClusterData clusterData;
            FillInPortRules( &clusterData,
                             L"rashuma",
                             portRulesVector );

            // add all new port rules.
            
            // equal load balanced.
            map< long, PortDataELB>::iterator topELB;

            for( topELB = clusterData.portELB.begin();
                 topELB != clusterData.portELB.end();
                 ++topELB )
            {
                nlbs.addPortRuleLoadBalanced(
                    (*topELB).second );
            }


            // unequal load balanced
            map< long, PortDataULB>::iterator topULB;
            for( topULB = clusterData.portULB.begin();
                 topULB != clusterData.portULB.end();
                 ++topULB )
            {
                MNLBPortRuleLoadBalanced portRuleULB = (*topULB).second;
                portRuleULB._load = 
                    (*topULB).second.machineMapToLoadWeight[L"rashuma"];
                
                nlbs.addPortRuleLoadBalanced(
                    portRuleULB );
            }

            // disabled
            map< long, PortDataD>::iterator topD;
            for( topD = clusterData.portD.begin();
                 topD != clusterData.portD.end();
                 ++topD )
            {
                nlbs.addPortRuleDisabled(
                    (*topD).second );
            }

            // failover
            map< long, PortDataF>::iterator topF;
            for( topF = clusterData.portF.begin();
                 topF != clusterData.portF.end();
                 ++topF )
            {
                MNLBPortRuleFailover portRuleF = (*topF).second;
                portRuleF._priority = 
                    (*topF).second.machineMapToPriority[ L"rashuma" ];
                
                nlbs.addPortRuleFailover( portRuleF );
                
            }

            //
            // set host properties.
            //
            HostProperties hp;

            // host priority
            pInParams->GetVariant( L"HostPriority",
                                   hostPriority );
            hp.hID = hostPriority;

            // dip
            pInParams->GetCHString( L"DedicatedIPAddress",
                                    sTemp );
            dedicatedIPAddress = sTemp;
            hp.hIP = dedicatedIPAddress.c_str();

            // dsn
            pInParams->GetCHString( L"DedicatedNetworkMask",
                                    sTemp );
            dedicatedNetworkMask = sTemp;
            hp.hSubnetMask = dedicatedNetworkMask.c_str();

            // initial state ?
            pInParams->Getbool( L"ClusterModeOnStart",
                                hp.initialClusterStateActive );

            unsigned long retVal;
            nlbs.setHostProperties( hp,
                                    &retVal );

            //
            // set cluster properties.
            //
            ClusterProperties cp;
            RetreiveAndSetClusterProperties(pInParams, nlbs, cp, fullName );

            //
            // if initial state active start cluster
            // else stop cluster.
            //
            MNLBMachine nlbMachine( cp.cIP );

            if( hp.initialClusterStateActive == true )
            {
                nlbMachine.start( Common::THIS_HOST, &retVal );
            }
            else
            {
                nlbMachine.stop( Common::THIS_HOST, &retVal );
            }

            retValue = 0;
        }
        else if( err == NICCard::NO_SUCH_NIC )
        {
            retValue = 20;
        }
        else if( err == NICCard::NO_SUCH_COMPONENT )
        {
            retValue = 30;
        }
        else
        {
            retValue = 40;
        }

        
        hresult = WBEM_S_NO_ERROR;
        pOutParams->SetDWORD(L"ReturnValue", retValue);
        return hresult;

    }
    else if (_wcsicmp(bstrMethodName, L"ModifyClusterProperties") == 0)
    {
        // check if nic is bound to adapter or not.
        err = nic.isBoundTo( L"ms_wlbs" );
        if( err == NICCard::BOUND )
        {
            MNLBProviderSetting nlbs( fullName.c_str() );
            
            //
            // set cluster properties.
            //
            ClusterProperties cp;
            RetreiveAndSetClusterProperties(pInParams, nlbs, cp, fullName);

        }
        else if( err == NICCard::UNBOUND )
        {
            retValue = 10;
        }
        else if( err == NICCard::NO_SUCH_NIC )
        {
            retValue = 20;
        }
        else if( err == NICCard::NO_SUCH_COMPONENT )
        {
            retValue = 30;
        }
        else
        {
            retValue = 40;
        }

        hresult = WBEM_S_NO_ERROR;
        pOutParams->SetDWORD(L"ReturnValue", retValue);
        return hresult;
    }
    else if (_wcsicmp(bstrMethodName, L"GetClusterConfiguration") == 0)
    {
        hresult = ProvGetClusterConfiguration(
                       pInParams,
                       pOutParams
                       );
        return hresult;
    }
    else if (_wcsicmp(bstrMethodName, L"UpdateClusterConfiguration") == 0)
    {
        hresult = ProvUpdateClusterConfiguration(
                       pInParams,
                       pOutParams
                       );
        return hresult;
    }
    else if (_wcsicmp(bstrMethodName, L"QueryConfigurationUpdateStatus") == 0)
    {
        hresult = ProvQueryConfigurationUpdateStatus(
                       pInParams,
                       pOutParams
                       );
        return hresult;
    }
    else
    {
        // unknown call, we do not support this.
        hresult = WBEM_E_PROVIDER_NOT_CAPABLE;
        pOutParams->SetDWORD(L"ReturnValue", retValue);
        return hresult;
    }
}

void
CNlbsNic::RetreiveAndSetClusterProperties(CInstance *pInParams, 
                                          MNLBProviderSetting &nlbs, 
                                          ClusterProperties& cp,
                                          const wstring&    fullName )
{
    CHString     sTemp;
    wstring clusterIPAddress;
    wstring clusterNetworkMask;
    wstring clusterName;
    wstring password;

    // cip
    pInParams->GetCHString( L"ClusterIPAddress", sTemp );
    clusterIPAddress = sTemp;
    cp.cIP = clusterIPAddress.c_str();

    // csn
    pInParams->GetCHString( L"ClusterNetworkMask", sTemp );
    clusterNetworkMask = sTemp;
    cp.cSubnetMask = clusterNetworkMask.c_str();

    // full internet name
    pInParams->GetCHString( L"ClusterName", sTemp );
    clusterName = sTemp;
    cp.cFullInternetName = clusterName.c_str();

    // igmp support?
    pInParams->Getbool( L"IGMPSupport", cp.igmpSupportEnabled );

    // multicast enabled?
    pInParams->Getbool( L"MulticastSupportEnabled", cp.multicastSupportEnabled );

    // remote control enabled?
    pInParams->Getbool( L"RemoteControlEnabled", cp.remoteControlEnabled );

    // password
    pInParams->GetCHString( L"Password", sTemp );
    password = sTemp;
    cp.password = password.c_str();

    unsigned long retVal;
    try
    {
        nlbs.setClusterProperties( cp, &retVal );
    }
    catch( _com_error e )
    {
    }

    // set password.
    try
    {
        if( cp.remoteControlEnabled == true )
        {
            nlbs.setPassword( cp.password,
                              &retVal );
        }
    }
    catch( _com_error e )
    {
    }
    
    //
    // add cluster ip
    //
    MIPAddressAdmin ipAdmin( fullName.c_str() );
    
    long SleepDuration = 0;
    while ((ipAdmin.addIPAddress(cp.cIP, cp.cSubnetMask) != MIPAddressAdmin::MIPAddressAdmin_SUCCESS)
           &&(SleepDuration < PROTOCOL_BIND_DELAY))
    {
        SleepDuration += PROTOCOL_BIND_WAIT_INCREMENT;
        Sleep(PROTOCOL_BIND_WAIT_INCREMENT);
    }
}

void
CNlbsNic::GetVectorFromSafeArray( SAFEARRAY*&  stringArray, 
                                  vector<_bstr_t>& strings )
{
    LONG count = stringArray->rgsabound[0].cElements;
    BSTR* pbstr;
    HRESULT hr;

    if( SUCCEEDED( SafeArrayAccessData( stringArray, ( void **) &pbstr)))
    {
        for( LONG x = 0; x < count; x++ )
        {
            strings.push_back( pbstr[x] );
        }

        hr = SafeArrayUnaccessData( stringArray );
    }
}    


void 
CNlbsNic::FillInPortRules( ClusterData*           p_clusterData,
                           const _bstr_t&         myMachine,
                           const vector<_bstr_t>& portRules )
{
    wchar_t portBuf[1000];
    wstring temp;
    WTokens tok;
    vector<wstring> tokens;

    for( int i = 0; i < portRules.size(); ++i )
    {
        wcscpy( portBuf, portRules[i] );

        tok.init( portBuf, L"\t");
        tokens = tok.tokenize();

        if( tokens[3] == L"Multiple" )
        {
            if( tokens[5] == L"Equal" )
            {
                p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._startPort = _wtoi( tokens[0].c_str() );
                p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._endPort = _wtoi( tokens[1].c_str() );
                if( tokens[2] == L"Both" )
                {
                    p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::both;
                }
                else if( tokens[2] == L"TCP" )
                {
                    p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::tcp;
                }
                else
                {
                    p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::udp;
                }
            
                if( tokens[6] == L"Single" )
                {
                    p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._affinity = MNLBPortRule::single;
                }
                else if( tokens[6] == L"None" ) 
                {
                    p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._affinity = MNLBPortRule::none;
                }
                else
                {
                    p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._affinity = MNLBPortRule::classC;
                }

                p_clusterData->portELB[ _wtoi( tokens[0].c_str()) ]._isEqualLoadBalanced = true;
                
            }
            else
            {
                p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._startPort = _wtoi( tokens[0].c_str() );
                p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._endPort = _wtoi( tokens[1].c_str() );
                if( tokens[2] == L"Both" )
                {
                    p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::both;
                }
                else if( tokens[2] == L"TCP" )
                {
                    p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::tcp;
                }
                else
                {
                    p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::udp;
                }
                
                if( tokens[6] == L"Single" )
                {
                    p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._affinity = MNLBPortRule::single;
                }
                else if( tokens[6] == L"None" ) 
                {
                    p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._affinity = MNLBPortRule::none;
                }
                else
                {
                    p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._affinity = MNLBPortRule::classC;
                }

                p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ]._isEqualLoadBalanced = false;

                p_clusterData->portULB[ _wtoi( tokens[0].c_str()) ].machineMapToLoadWeight[myMachine] = 
                    _wtoi( tokens[5].c_str() );
                
            }
        }
        else if ( tokens[3] == L"Single" )
        {
            p_clusterData->portF[ _wtoi( tokens[0].c_str()) ]._startPort = _wtoi( tokens[0].c_str() );
            p_clusterData->portF[ _wtoi( tokens[0].c_str()) ]._endPort = _wtoi( tokens[1].c_str() );
            if( tokens[2] == L"Both" )
            {
                p_clusterData->portF[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::both;
            }
            else if( tokens[2] == L"TCP" )
            {
                p_clusterData->portF[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::tcp;
            }
            else
            {
                p_clusterData->portF[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::udp;
            }
            
            p_clusterData->portF[ _wtoi( tokens[0].c_str()) ].machineMapToPriority[myMachine] = 
                _wtoi( tokens[4].c_str() );
        }
        else
        {
            p_clusterData->portD[ _wtoi( tokens[0].c_str()) ]._startPort = _wtoi( tokens[0].c_str() );
            p_clusterData->portD[ _wtoi( tokens[0].c_str()) ]._endPort = _wtoi( tokens[1].c_str() );
            if( tokens[2] == L"Both" )
            {
                p_clusterData->portD[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::both;
            }
            else if( tokens[2] == L"TCP" )
            {
                p_clusterData->portD[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::tcp;
            }
            else
            {
                p_clusterData->portD[ _wtoi( tokens[0].c_str()) ]._trafficToHandle = MNLBPortRule::udp;
            }
        }
    }
}


WBEMSTATUS
ProvGetClusterConfiguration(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper around  NlbConfigurationUpdate::GetConfiguration

--*/
{
    if (!g_UpdateConfigurationEnabled) return WBEM_E_PROVIDER_NOT_CAPABLE;

    LPCWSTR pAdapterGuid = NULL;
    WBEMSTATUS Status =  WBEM_E_PROVIDER_NOT_CAPABLE;
    CHString     sTemp;
    bool         fRet;
    NLB_EXTENDED_CLUSTER_CONFIGURATION Cfg;
    SAFEARRAY   *pSA = NULL;

    /*
        [IN]  String  AdapterGuid,
        [OUT] uint32  Generation,
        [OUT] String  NetworkAddresses[], // "10.1.1.1/255.0.0.0"
        [OUT] Boolean NLBBound,
        [OUT] String  ClusterNetworkAddress, // "10.1.1.1/255.0.0.0"
        [OUT] String  ClusterName,
        [OUT] String  TrafficMode, // UNICAST MULTICAST IGMPMULTICAST
        [OUT] String  PortRules[],
        [OUT] uint32  HostPriority,
        [OUT] String  DedicatedNetworkAddress, // "10.1.1.1/255.0.0.0"
        [OUT] Boolean ClusterModeOnStart,
        [OUT] Boolean RemoteControlEnabled
    */

    fRet = pInParams->GetCHString( L"AdapterGuid", sTemp );
    if (!fRet)
    {
        TRACE_CRIT("->%!FUNC!: Missing adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Note: (LPCWSTR) sTemp returns an internal pointer to sTemp's char 
    // buffer -- see operator LPCWSTR() of WString docs.
    //
    pAdapterGuid = (LPCWSTR) sTemp;

    if (pAdapterGuid == NULL || *pAdapterGuid == 0)
    {
        TRACE_CRIT("->%!FUNC!: Null of empty adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    else
    {
        TRACE_VERB(L"->%!FUNC!(Nic=%ws)", pAdapterGuid);
    }

    Status = NlbConfigurationUpdate::GetConfiguration(
                pAdapterGuid,
                &Cfg
                );

    if (FAILED(Status))
    {
       goto end; 
    }

    pOutParams->SetDWORD(L"ReturnValue", (DWORD) WBEM_NO_ERROR);
    pOutParams->SetDWORD(L"Generation", Cfg.GetGeneration());

    //
    // Fill in NetworkAddresses[]
    //
    {
        Status = Cfg.GetNetworkAddressesSafeArray(
                        &pSA
                        );
        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: couldn't extract network addresses from Cfg"
                " for NIC %ws",
                pAdapterGuid
                );
            goto end;
        }
        

        if (pSA!=NULL)
        {
            pOutParams->SetStringArray(
                    L"NetworkAddresses",
                    *pSA // pass by reference
                    );
            SafeArrayDestroy(pSA);
            pSA = NULL;
        }
    }

    if (!Cfg.IsNlbBound())
    {
        //
        // NLB is bound
        //

        pOutParams->Setbool(L"NLBBound", FALSE);
        Status = WBEM_NO_ERROR;
        goto end;
    }
    
    //
    // NLB is bound
    //

    pOutParams->Setbool(L"NLBBound", TRUE);

    if (!Cfg.IsValidNlbConfig())
    {
        TRACE_CRIT(
            "%!FUNC!: NLB-specific configuration on NIC %ws is invalid",
            pAdapterGuid
            );
        goto end;
    }

    //
    // Cluster name
    //
    {
        LPWSTR szName = NULL;
        Status = Cfg.GetClusterName(&szName);

        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: Could not extract cluster name for NIC %ws",
                pAdapterGuid
                );
            goto end;
        }
        pOutParams->SetCHString(L"ClusterName", szName);
        delete (szName);
        szName = NULL;
    }
    
    //
    // Cluster and dedicated network addresses
    //
    {
        LPWSTR szAddress = NULL;
        Status = Cfg.GetClusterNetworkAddress(&szAddress);

        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: Could not extract cluster address for NIC %ws",
                pAdapterGuid
                );
            goto end;
        }
        pOutParams->SetCHString(L"ClusterNetworkAddress", szAddress);
        delete (szAddress);
        szAddress = NULL;

        Status = Cfg.GetDedicatedNetworkAddress(&szAddress);

        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: Could not extract dedicated address for NIC %ws",
                pAdapterGuid
                );
            goto end;
        }
        pOutParams->SetCHString(L"DedicatedNetworkAddress", szAddress);
        delete (szAddress);
        szAddress = NULL;
    }

    //
    // TrafficMode
    //
    {
        LPCWSTR szMode = NULL;
        switch(Cfg.GetTrafficMode())
        {
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST:
            szMode = L"UNICAST";
            break;
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST:
            szMode = L"MULTICAST";
            break;
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST:
            szMode = L"IGMPMULTICAST";
            break;
        default:
            assert(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        pOutParams->SetCHString(L"TrafficMode", szMode);
    }

    pOutParams->SetDWORD(L"HostPriority", Cfg.GetHostPriority());

    if (Cfg.GetClusterModeOnStart() ==
        NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STARTED)
    {
        pOutParams->Setbool(L"ClusterModeOnStart", TRUE);
    }
    else
    {
        pOutParams->Setbool(L"ClusterModeOnStart", FALSE);
    }

    pOutParams->Setbool(L"RemoteControlEnabled", Cfg.GetRemoteControlEnabled());
    

    //
    // TODO: get port rules
    // [OUT] String  PortRules[],
    //
    

    Status = WBEM_NO_ERROR;

end:

    if (pSA!=NULL)
    {
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }

    TRACE_VERB(L"<-%!FUNC! returns 0x%08lx", (UINT) Status);

    return Status;

}


WBEMSTATUS
ProvUpdateClusterConfiguration(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper NlbConfigurationUpdate::UpdateConfiguration
    with some additional wrinkles:
    we selectively update the current version.

--*/
{
    if (!g_UpdateConfigurationEnabled) return WBEM_E_PROVIDER_NOT_CAPABLE;

    LPCWSTR pAdapterGuid = NULL;
    LPCWSTR pClientDescription = L"Unspecified WMI Client"; // TODO: localize
    WBEMSTATUS Status =  WBEM_E_PROVIDER_NOT_CAPABLE;
    CHString     sClientDescription;
    CHString     sAdapterGuid;
    CHString     sTemp;
    bool         fRet;
    NLB_EXTENDED_CLUSTER_CONFIGURATION Cfg;
    SAFEARRAY   *pSA = NULL;

    /*
        [IN] String  ClientDescription,
        [IN] String  AdapterGuid,
        [IN] uint32  Generation,
        [IN] Boolean PartialUpdate,
        [IN] String  NetworkAddresses[], // "10.1.1.1/255.255.255.255"
        [IN] Boolean NLBBound,
        [IN] String  ClusterNetworkAddress, // "10.1.1.1/255.0.0.0"
        [IN] String  ClusterName,
        [IN] String  TrafficMode, // UNICAST MULTICAST IGMPMULTICAST
        [IN] String  PortRules[],
        [IN] uint32  HostPriority,
        [IN] String  DedicatedNetworkAddress, // "10.1.1.1/255.0.0.0"
        [IN] Boolean ClusterModeOnStart,
        [IN] Boolean RemoteControlEnabled,
        [IN] String  Password,
        [OUT] uint32 NewGeneration,
        [OUT] String Log
    */

    fRet = pInParams->GetCHString( L"ClientDescription", sClientDescription);
    if (fRet)
    {
        // Note: (LPCWSTR) sTemp returns an internal pointer to sTemp's char 
        pClientDescription = (LPCWSTR) sClientDescription;
    }

    fRet = pInParams->GetCHString( L"AdapterGuid", sAdapterGuid);
    if (!fRet)
    {
        TRACE_CRIT("->%!FUNC!: Missing adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Note: (LPCWSTR) sTemp returns an internal pointer to sTemp's char 
    // buffer -- see operator LPCWSTR() of WString docs.
    //
    pAdapterGuid = (LPCWSTR) sAdapterGuid;

    if (pAdapterGuid == NULL || *pAdapterGuid == 0)
    {
        TRACE_CRIT("->%!FUNC!: Null of empty adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    else
    {
        TRACE_VERB(L"->%!FUNC!(Nic=%ws)", pAdapterGuid);
    }

    //
    // Get the current configuration
    //
    Status = NlbConfigurationUpdate::GetConfiguration(
                pAdapterGuid,
                &Cfg
                );

    if (FAILED(Status))
    {
       goto end; 
    }


    //
    // Modify the snapshot of the current configuration with whatever
    // cluster configuration information is specified in the input
    // parameters
    //
    {
        DWORD       InGeneration    = 0;
        bool        NlbBound        = FALSE;
        bool        bResult         = FALSE;
        bool        bPartialUpdate   = FALSE;
    
        //
        // Determine if this is a partial or full update.
        // If partial update, we allow a subset of cluster configuration
        // parameters to be specified, but allow only a restricted set
        // of update operations.
        //
        // Disallowed partial update operations:
        //  - Transitions between bound and !bound 
        //  - Currently bound  but nlb parameters are invalid
        //
        // Some allowed partial updates:
        //  - Modifying IP address lists
        //  - Modifying cluster / dedicated addresses/subnets
        //  - Modifying existing portrules
        //  - Adding/deleting port rules
        //

        bResult = pInParams->GetDWORD(
                    L"Generation",      // <--------------------------------
                    InGeneration
                    );
        if (!bResult)
        {
            //
            // We allow generation to be unspecified.
            //
            InGeneration = 0;
        }
        else
        {
            //
            // If generation is specified,
            // we verify that the current generation matches the
            // specified generation.
            // TODO: this really must be done in the context of
            // mfn_Start update -- after we've acquired the global lock!
            //
            if (InGeneration != Cfg.GetGeneration())
            {
                    TRACE_CRIT("Partial update: input generation(%lu) != current generation(%lu)", InGeneration, Cfg.GetGeneration());
                    Status = WBEM_E_HANDLE_OUT_OF_DATE;
                    goto end;
            }
        }

        bResult = pInParams->Getbool(
                        L"NLBBound",    // <--------------------------------
                        NlbBound
                        );
    
        if (!bResult)
        {
            NlbBound = Cfg.IsNlbBound();
            TRACE_CRIT(L"Could not read NLBBound -- assuming current state %d.",
                 NlbBound);
        }

        bResult = pInParams->GetStringArray(
                    L"NetworkAddresses", // <--------------------------------
                    pSA
                    );
        if (!bResult)
        {
            //
            // We set pCfg to zero addresses, which causes update to
            // use it's own defaults...
            //
            TRACE_CRIT(L"Could not read Network addresses -- using defaults");
            Status = Cfg.SetNetworkAddresses(NULL, 0);
            pSA = NULL;
        }
        else
        {
            if (pSA != NULL)
            {
                Status = Cfg.SetNetworkAddressesSafeArray(pSA);
                SafeArrayDestroy(pSA);
                pSA = NULL;
            }
        }

        if (!NlbBound)
        {
            // NLB is not to be bound -- no need to read the input params.
            Cfg.fBound = FALSE;
            Cfg.fValidNlbCfg = FALSE;
        }
        else
        {
            BOOL fNewConfig = FALSE;

            if (!Cfg.fBound || Cfg.fValidNlbCfg == FALSE)
            {
                //
                // If we were previously unbound or we were bound but with
                // a bad configuration, we need to setup our
                // new cfg with good defaults
                //
                CfgUtilInitializeParams(&Cfg.NlbParams);
                Cfg.fBound = TRUE;
                Cfg.fValidNlbCfg = TRUE;
                fNewConfig = TRUE;
            }
        
            bResult = pInParams->GetCHString(
                            L"ClusterNetworkAddress", // <--------------------
                            sTemp
                            );
        
            if (!bResult)
            {
                if (fNewConfig)
                {
                    //
                    // Cluster address MUST be specified for new config.
                    //
                    TRACE_CRIT(L"ERROR: Could not read Cluster IP for new config.");
                    Status =  WBEM_E_INVALID_PARAMETER;
                    goto end;
                    
                }
                TRACE_CRIT(L"Could not read Cluster IP. Keeping existing.");
            }
            else
            {
                LPCWSTR      szClusterNetworkAddress = NULL;
                szClusterNetworkAddress = (LPCWSTR) sTemp; // no copies here.
                Cfg.SetClusterNetworkAddress(szClusterNetworkAddress);
                szClusterNetworkAddress = NULL;
            }
        
            bResult = pInParams->GetCHString(
                            L"ClusterName", // <-------------------------
                            sTemp
                            );
        
            if (!bResult)
            {
                TRACE_CRIT(L"Could not read Cluster Name. Keeping existing");
            }
            else
            {
                LPCWSTR      szClusterName = NULL;
                szClusterName = (LPCWSTR) sTemp; // no copies here.
                Cfg.SetClusterName(szClusterName);
                szClusterName = NULL;
            }
        
            //
            // Traffic mode
            //
            {
                bResult = pInParams->GetCHString(
                                L"TrafficMode", // <-------------------------
                                sTemp
                                );
            
                if (!bResult)
                {
                    TRACE_CRIT(L"Could not read TrafficMode. Keeping existing");
                }
                else
                {
                    LPCWSTR      szTrafficMode = NULL;
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE TrafficMode
                    =  NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
                    szTrafficMode = (LPCWSTR) sTemp; // no copies here.
        
                    if (!_wcsicmp(szTrafficMode, L"UNICAST"))
                    {
                        TrafficMode =
                        NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
                    }
                    else if (!_wcsicmp(szTrafficMode, L"MULTICAST"))
                    {
                        TrafficMode =
                        NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST;
                    }
                    else if (!_wcsicmp(szTrafficMode, L"IGMPMULTICAST"))
                    {
                        TrafficMode =
                        NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST;
                    }
                    else
                    {
                        TRACE_CRIT("Invalid TrafficMode: %ws", szTrafficMode);
                        Status =  WBEM_E_INVALID_PARAMETER;
                        goto end;
                    }

                    Cfg.SetTrafficMode(TrafficMode);
                    szTrafficMode = NULL;
                }
            }
        
            //
            // TODO: process port rules.
            //          [OUT] String  PortRules[]
            //

            DWORD HostPriority = 0; 
            bResult = pInParams->GetDWORD(
                        L"HostPriority",      // <---------------------------
                        HostPriority
                        );
            if (!bResult)
            {
                TRACE_CRIT(L"Could not read HostPriority. Keeping existing");
            }
            else
            {
                Cfg.SetHostPriority(HostPriority);
            }
        
            bResult = pInParams->GetCHString(
                            L"DedicatedNetworkAddress", // <-----------------
                            sTemp
                            );
        
            if (!bResult)
            {
                TRACE_CRIT(L"Could not dedicated IP. Keeping existing");
            }
            else
            {
                LPCWSTR      szAddress = NULL;
                szAddress = (LPCWSTR) sTemp; // no copies here.
                Cfg.SetDedicatedNetworkAddress(szAddress);

                //
                // For now, we'll always try to  add the dedicated IP address
                // to the NIC.
                //
                Cfg.fAddDedicatedIp = TRUE;
                szAddress = NULL;
            }
            
            //
            // StartMode
            //
            {
                bool StartMode = FALSE;
                bResult = pInParams->Getbool(
                                L"ClusterModeOnStart",   // <-----------------
                                StartMode
                                );
            
                if (!bResult)
                {
                    TRACE_CRIT(L"Could not read StartMode. Keeping existing");
                }
                else
                {
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE
                    ClusterModeOnStart;
                    if (StartMode)
                    {
                        ClusterModeOnStart = 
                         NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STARTED;
                    }
                    else
                    {
                        ClusterModeOnStart = 
                         NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED;
                    }
                    Cfg.SetClusterModeOnStart(ClusterModeOnStart);
                }
            }
        
            //
            // Remote control enabled
            //
            {
                bool bRemoteControlEnabled;
                bResult = pInParams->Getbool(
                                L"RemoteControlEnabled",   // <---------------
                                bRemoteControlEnabled
                                );
            
                if (!bResult)
                {
                    TRACE_CRIT(L"Could not read RemoteControlEnabled. Keeping existing");
                }
                else
                {
                    Cfg.SetRemoteControlEnabled(bRemoteControlEnabled!=FALSE);
                }
            }

            //
            // TODO: if PartialUpdate is specified, we need to 
            // make sure that fValidNlbCfg is already set.
            //
            Cfg.fValidNlbCfg = TRUE;
    
        } while (FALSE) ;

    }

    //
    // Call NlbConfigurationUpdate::DuUpdate to do the actual work.
    //
    UINT NewGeneration = 0;
    LPWSTR pLog = NULL;

    Status = NlbConfigurationUpdate::DoUpdate(
                pAdapterGuid,
                pClientDescription,
                &Cfg,
                &NewGeneration,
                &pLog
                );

    //
    // Fill out the out parameters: status new generation and log
    //
    pOutParams->SetDWORD(L"ReturnValue", (DWORD) Status);
    pOutParams->SetDWORD(L"NewGeneration", (DWORD) NewGeneration);
    if (pLog != NULL)
    {
        pOutParams->SetCHString(L"Log", pLog);
        delete pLog;
        pLog = NULL;
    }

    //
    // If we've actually called DoUpdate,
    // we always return WBEM_NO_ERROR. The return value has the
    // real result.
    //
    Status = WBEM_NO_ERROR;

end:

    if (pSA!=NULL)
    {
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }

    TRACE_VERB(L"<-%!FUNC! returns 0x%08lx", (UINT) Status);

    return Status;

}


WBEMSTATUS
ProvQueryConfigurationUpdateStatus(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper around NlbConfigurationUpdate::GetUpdateStatus

--*/
{
    if (!g_UpdateConfigurationEnabled) return WBEM_E_PROVIDER_NOT_CAPABLE;

    LPCWSTR pAdapterGuid = NULL;
    WBEMSTATUS Status =  WBEM_E_PROVIDER_NOT_CAPABLE;
    CHString     sTemp;
    bool         fRet;
    DWORD       Generation = 0;

    /*
        [IN] String  AdapterGuid,
        [IN] uint32  Generation,
        [OUT] String Log
    */

    fRet = pInParams->GetCHString( L"AdapterGuid", sTemp);
    if (!fRet)
    {
        TRACE_CRIT("->%!FUNC!: Missing adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Note: (LPCWSTR) sTemp returns an internal pointer to sTemp's char 
    // buffer -- see operator LPCWSTR() of WString docs.
    //
    pAdapterGuid = (LPCWSTR) sTemp;

    if (pAdapterGuid == NULL || *pAdapterGuid == 0)
    {
        TRACE_CRIT("->%!FUNC!: Null of empty adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    else
    {
        TRACE_VERB(L"->%!FUNC!(Nic=%ws)", pAdapterGuid);
    }

    fRet = pInParams->GetDWORD(
                L"Generation",      // <--------------------------------
                Generation
                );
    if (!fRet)
    {
        TRACE_CRIT("%!FUNC!: Missing generation!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Call NlbConfigurationUpdate::GetUpdateResult to do the actual work.
    //
    LPWSTR pLog = NULL;
    WBEMSTATUS CompletionStatus = WBEM_NO_ERROR;

    Status = NlbConfigurationUpdate::GetUpdateStatus(
                pAdapterGuid,
                Generation,
                FALSE,  // FALSE == Don't delete completion record
                &CompletionStatus,
                &pLog
                );

    if (!FAILED(Status))
    {
        //
        // Fill out the out parameters: status new generation and log
        //
        pOutParams->SetDWORD(L"ReturnValue", (DWORD) CompletionStatus);
        if (pLog != NULL)
        {
            pOutParams->SetCHString(L"Log", pLog);
            delete pLog;
            pLog = NULL;
        }
    }

end:

    TRACE_VERB(L"<-%!FUNC! returns 0x%08lx", (UINT) Status);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\private.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager provider test harness

File Name:

    private.h

Abstract:

    Internal headers


History:

    04/08/01    JosephJ Created

--*/

// #include "windows.h"
// #include <ntddk.h>
#include <FWcommon.h>
#include <assert.h>
#include <objbase.h>
#include <initguid.h>
#include <wlbsiocl.h>
#include "wlbsconfig.h"
#include "myntrtl.h"
#include "wlbsparm.h"
#include "cfgutils.h"
#include "updatecfg.h"

//
// Debugging stuff...
//
extern BOOL g_DoBreaks;
#define MyBreak(_str) ((g_DoBreaks) ? (OutputDebugString(_str),DebugBreak(),1):0)


#define ASSERT assert
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\new.cpp ===
#include "private.h"
#include "new.tmh"

#define NLB_MAX_PORT_STRING_SIZE 128 // in WCHARS, including ending NULL

BOOL
gen_port_rule_string(
    IN PWLBS_PORT_RULE pPr,
    OUT LPWSTR pString         // At least NLB_MAX_PORT_STRING_SIZE wchars
    );

BOOL
parse_port_rule_string(
    IN LPCWSTR pString,
    OUT PWLBS_PORT_RULE pPr
    );

VOID
test_port_rule_string(VOID)
{

    LPCWSTR RuleStrings[] =
                {
L"",
L"   \t \n ",
L"n=v",
L" \t \n   n=v",
L"  \t \n  n \t \n = \t \n v",
L"na=v1 nb=v2 nc=v3",
L"\t  na \t  =   \t v1   \t  nb \t \n =\t \n  v2  \t \n  nc \t  = \n  v3  ",
#if 1
L"ip=1.1.1.1 protocol=TCP start=80 end=288 mode=SINGLE"
                                                L" priority=1",
L"ip=1.1.1.1 protocol=UDP start=80 end=288 mode=MULTIPLE"
                                                L" affinity=SINGLE load=80",
L"ip=1.1.1.1 protocol=UDP start=80 end=288 mode=MULTIPLE"
                                                L" affinity=NONE load=80",
L"ip=1.1.1.1 protocol=UDP start=80 end=288 mode=MULTIPLE"
                                                L" affinity=CLASSC",
L"ip=1.1.1.1 protocol=BOTH start=80 end=288 mode=DISABLED",
#endif // 0

NULL    // Must be last
                };


    for (LPCWSTR *ppRs = RuleStrings; *ppRs!=NULL; ppRs++)
    {
        LPCWSTR szRule = *ppRs;
        WCHAR szGenString[NLB_MAX_PORT_STRING_SIZE];
        printf("ORIG: %ws\n", szRule);
        WLBS_PORT_RULE Pr;
        BOOL fRet;
        fRet = parse_port_rule_string(
                    szRule,
                    &Pr
                    );
        if (fRet == FALSE)
        {
            printf("parse_port_rule_string returned FAILURE.\n");
            continue;
        }
        fRet = gen_port_rule_string(
                    &Pr,
                    szGenString
                    );
        if (fRet == FALSE)
        {
            printf("gen_port_rule_string returned FAILURE.\n");
            continue;
        }
        printf("GEN: %ws\n", szGenString);
    }
}


BOOL
gen_port_rule_string(
    IN PWLBS_PORT_RULE pPr,
    OUT LPWSTR pString         // At least NLB_MAX_PORT_STRING_SIZE wchars
    )
{
    BOOL fRet = FALSE;

    LPCWSTR szProtocol = L"";
    LPCWSTR szMode = L"";
    LPCWSTR szAffinity = L"";

    ZeroMemory(pString, NLB_MAX_PORT_STRING_SIZE*sizeof(WCHAR));

    switch(pPr->protocol)
    {
    case CVY_TCP:
        szProtocol = L"TCP";
        break;
    case CVY_UDP:
        szProtocol = L"UDP";
        break;
    case CVY_TCP_UDP:
        szProtocol = L"BOTH";
        break;
    default:
        goto end; // bad parse
    }

    switch(pPr->mode)
    {
    case  CVY_SINGLE:
        szMode = L"SINGLE";
        break;
    case CVY_MULTI:
        szMode = L"MULTIPLE";
        switch(pPr->mode_data.multi.affinity)
        {
        case CVY_AFFINITY_NONE:
            szAffinity = L"NONE";
            break;
        case CVY_AFFINITY_SINGLE:
            szAffinity = L"SINGLE";
            break;
        case CVY_AFFINITY_CLASSC:
            szAffinity = L"CLASSC";
            break;
        default:
            goto end; // bad parse
        }
        break;
    case CVY_NEVER:
        szMode = L"DISABLED";
        break;
    default:
        goto end; // bad parse
    }

    *pString = 0;
    _snwprintf(
        pString,
        NLB_MAX_PORT_STRING_SIZE-1,
        L"ip=%ws protocol=%ws start=%u end=%u mode=%ws ",
        pPr->virtual_ip_addr,
        szProtocol,
        pPr->start_port,
        pPr->end_port,
        szMode
        );

    UINT Len = wcslen(pString);
    if (Len >= (NLB_MAX_PORT_STRING_SIZE-1))
    {
        goto end; // not enough space.
    }

    if (pPr->mode == CVY_MULTI)
    {
        if (pPr->mode_data.multi.equal_load)
        {
            _snwprintf(
                pString+Len,
                (NLB_MAX_PORT_STRING_SIZE-1-Len),
                L"affinity=%ws",
                szAffinity
                );
        }
        else
        {
            _snwprintf(
                pString+Len,
                (NLB_MAX_PORT_STRING_SIZE-1-Len),
                L"affinity=%ws load=%u",
                szAffinity,
                pPr->mode_data.multi.load
                );
        }
    }
    else if (pPr->mode == CVY_SINGLE)
    {
            _snwprintf(
                pString+Len,
                (NLB_MAX_PORT_STRING_SIZE-1-Len),
                L"priority=%u",
                pPr->mode_data.single.priority
                );
    }
    if (pString[NLB_MAX_PORT_STRING_SIZE-1] !=0)
    {
        // out of space
        goto end;
    }

    fRet = TRUE;

end:

    return fRet;
}

BOOL
parse_port_rule_string(
    IN LPCWSTR pString,
    OUT PWLBS_PORT_RULE pPr
    )
{
//
//  Look for following name=value pairs
//
//      ip=1.1.1.1
//      protocol=[TCP|UDP|BOTH]
//      start=122
//      end=122
//      mode=[SINGLE|MULTIPLE|DISABLED]
//      affinity=[NONE|SINGLE|CLASSC]
//      load=80
//      priority=1"
//

    #define INVALID_VALUE ((DWORD)-1)
    LPWSTR psz = NULL;
    WCHAR szCleanedString[2*NLB_MAX_PORT_STRING_SIZE];
    WCHAR c;
    BOOL fRet = FALSE;
    DWORD protocol= INVALID_VALUE;
    DWORD start_port= INVALID_VALUE;
    DWORD end_port= INVALID_VALUE;
    DWORD mode= INVALID_VALUE;
    DWORD affinity= INVALID_VALUE;
    DWORD load= INVALID_VALUE;
    DWORD priority= INVALID_VALUE;

    ZeroMemory(pPr, sizeof(*pPr));

    //
    // Set szCleanedString  to be a version of pString in "canonical" form:
    // extraneous whitespace stripped out and whitspace represented by a
    // single '\b' character.
    {
        UINT Len = wcslen(pString);
        if (Len > (sizeof(szCleanedString)/sizeof(WCHAR)))
        {
            goto end;
        }
        wcscpy(szCleanedString, pString);

        //
        // convert different forms of whitespace into blanks
        //
        for (psz=szCleanedString; (c=*psz)!=0; psz++)
        {
            if (c == ' ' || c == '\t' || c == '\n')
            {
                *psz = ' ';
            }
        }

        //
        // convert runs of whitespace into a single blank
        // also get rid of initial whitespace
        //
        LPWSTR psz1 = szCleanedString;
        BOOL fRun = TRUE; // initial value of TRUE gets rid of initial space
        for (psz=szCleanedString; (c=*psz)!=0; psz++)
        {
            if (c == ' ')
            {
                if (fRun)
                {
                    continue;
                }
                else
                {
                    fRun = TRUE;
                }
            }
            else if (c == '=')
            {
                if (fRun)
                {
                    //
                    // The '=' was preceed by whitespace -- delete that
                    // whitespace. We keep fRun TRUE so subsequent whitespace
                    // is eliminated.
                    //
                    if (psz1 == szCleanedString)
                    {
                        // we're just starting, and we get an '=' -- bad
                        goto end;
                    }
                    psz1--;
                    if (*psz1 != ' ')
                    {
                        ASSERT(*psz1 == '=');
                        goto end; // two equals in a row, not accepted!
                    }
                }
            }
            else // non blank and non '=' chracter
            {
                fRun = FALSE;
            }
            *psz1++ = c;
        }
        *psz1=0;
    }

    wprintf(L"CLEANED: \"%ws\"\n", szCleanedString);

    //
    // Now actually do the parse.
    //
    psz = szCleanedString;
    while(*psz!=0)
    {
        WCHAR Name[32];
        WCHAR Value[32];

        // 
        // Look for the Name in Name=Value pair.
        //
        if (swscanf(psz, L"%16[a-zA-Z]=%16[0-9.a-zA-Z]", Name, Value) != 2)
        {
            // bad parse;
            goto end;
        }

        //
        // Skip past the name=value pair -- it contains no blanks
        //
        for (; (c=*psz)!=NULL; psz++)
        {
           if (c==' ')
           {
             psz++; // to skip past the blank
             break;
           }
        }


        //
        // Now look for the specific name/values
        //
        //      ip=1.1.1.1
        //      protocol=[TCP|UDP|BOTH]
        //      start=122
        //      end=122
        //      mode=[SINGLE|MULTIPLE|DISABLED]
        //      affinity=[NONE|SINGLE|CLASSC]
        //      load=80
        //      priority=1"
        //
        if (!_wcsicmp(Name, L"ip"))
        {
            if (swscanf(Value, L"%15[0-9.]", pPr->virtual_ip_addr) != 1)
            {
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"protocol"))
        {
            if (!_wcsicmp(Value, L"TCP"))
            {
                protocol = CVY_TCP;
            }
            else if (!_wcsicmp(Value, L"UDP"))
            {
                protocol = CVY_UDP;
            }
            else if (!_wcsicmp(Value, L"BOTH"))
            {
                protocol = CVY_TCP_UDP;
            }
            else
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"protocol"))
        {
        }
        else if (!_wcsicmp(Name, L"start"))
        {
            if (swscanf(Value, L"%u", &start_port)!=1)
            {
                // bad parse;
                goto end;
            }
            if (start_port > 65535)
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"end"))
        {
            if (swscanf(Value, L"%u", &end_port)!=1)
            {
                // bad parse;
                goto end;
            }
            if (end_port > 65535)
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"mode"))
        {
            if (!_wcsicmp(Value, L"SINGLE"))
            {
                mode = CVY_SINGLE;
            }
            else if (!_wcsicmp(Value, L"MULTIPLE"))
            {
                mode = CVY_MULTI;
            }
            else if (!_wcsicmp(Value, L"DISABLED"))
            {
                mode = CVY_NEVER;
            }
            else
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"affinity"))
        {
            if (!_wcsicmp(Value, L"NONE"))
            {
                affinity = CVY_AFFINITY_NONE;
            }
            else if (!_wcsicmp(Value, L"SINGLE"))
            {
                affinity = CVY_AFFINITY_SINGLE;
            }
            else if (!_wcsicmp(Value, L"CLASSC"))
            {
                affinity = CVY_AFFINITY_CLASSC;
            }
            else
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"load"))
        {
            if (swscanf(Value, L"%u", &load)!=1)
            {
                if (load > 100)
                {
                    // bad parse;
                    goto end;
                }
            }
        }
        else if (!_wcsicmp(Name, L"priority"))
        {
            if (swscanf(Value, L"%u", &priority)!=1)
            {
                if (priority > 31)
                {
                    // bad parse;
                    goto end;
                }
            }
        }
        else
        {
            // bad parse
            goto end;
        }
        printf("SUCCESSFUL PARSE: %ws = %ws\n", Name, Value);
    }


    //
    // Set up the PARAMS structure, doing extra parameter validation along the
    // way.
    //
    switch(mode)
    {
        case CVY_SINGLE:

            if (load != INVALID_VALUE || affinity != INVALID_VALUE)
            {
                goto end; // bad parse;
            }
            if ((priority < CVY_MIN_PRIORITY) || (priority > CVY_MAX_PRIORITY))
            {
                goto end; // bad parse
            }
            pPr->mode_data.single.priority = priority;
            break;

        case CVY_MULTI:

            if (priority != INVALID_VALUE)
            {
                goto end; // bad parse;
            }

            switch(affinity)
            {
            case CVY_AFFINITY_NONE:
                break;
            case CVY_AFFINITY_SINGLE:
                break;
            case CVY_AFFINITY_CLASSC:
                break;
            case INVALID_VALUE:
            default:
                goto end; // bad parse;
            }

            pPr->mode_data.multi.affinity = affinity;

            if (load == INVALID_VALUE)
            {
                // this means it's unassigned, which means equal.
                pPr->mode_data.multi.equal_load = 1;
            }
            else if (load > CVY_MAX_LOAD)
            {
                goto end; // bad parse
            }
            else
            {
                pPr->mode_data.multi.load = load;
            }
            break;

        case CVY_NEVER:

            if (load != INVALID_VALUE || affinity != INVALID_VALUE 
                || priority != INVALID_VALUE)
            {
                goto end; // bad parse;
            }
            break;

        case INVALID_VALUE:
        default:
            goto end; // bad parse;

    }

    pPr->mode = mode;
    pPr->end_port = end_port;
    pPr->start_port = start_port;
    pPr->protocol = protocol;


    fRet = TRUE;

end:

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\updatecfg.cpp ===
//***************************************************************************
//
//  UPDATECFG.CPP
// 
//  Module: 
//
//  Purpose: Support for asynchronous NLB configuration updates
//           Contains the high-level code for executing and tracking the updates
//           The lower-level, NLB-specific work is implemented in 
//           CFGUTILS.CPP
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created
//
//***************************************************************************
#include "private.h"
#include "updatecfg.tmh"

#define NLBUPD_REG_PENDING L"PendingOperation"
#define NLBUPD_REG_COMPLETIONS L"Completions"
#define NLBUPD_MAX_LOG_LENGTH 1024 // Max length in chars of a completion log entry

//
// NLBUPD_MAX_NETWORK_ADDRESS_LENGTH is the max number of chars (excluding
// the terminating 0) of a string of the form "ip-addr/subnet", eg:
// "10.0.0.1/255.255.255.0"
//
#define NLBUPD_MAX_NETWORK_ADDRESS_LENGTH \
    (WLBS_MAX_CL_IP_ADDR + 1 + WLBS_MAX_CL_NET_MASK)


LPWSTR *
allocate_string_array(
    UINT NumStrings,
    UINT StringLen      //  excluding ending NULL
    );

WBEMSTATUS
address_string_to_ip_and_subnet(
    IN  LPCWSTR szAddress,
    OUT LPWSTR  szIp, // max WLBS_MAX_CL_IP_ADDR
    OUT LPWSTR  szSubnet // max WLBS_MAX_CL_NET_MASK
    );

WBEMSTATUS
ip_and_subnet_to_address_string(
    IN  LPCWSTR szIp,
    IN  LPCWSTR szSubnet,
    OUT LPWSTR  szAddress // max  NLBUPD_MAX_NETWORK_ADDRESS_LENGTH
                         // + 1 (for NULL)
    );
//
// For debugging only -- used to cause various locations to break into
// the debugger.
//
BOOL g_DoBreaks;

//
// Static vars 
//
CRITICAL_SECTION NlbConfigurationUpdate::s_Crit;
LIST_ENTRY       NlbConfigurationUpdate::s_listCurrentUpdates;
BOOL             NlbConfigurationUpdate::s_fDeinitializing;

//
// Local utility functions.
//
WBEMSTATUS
update_cluster_config(
    PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg,
    PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfgNew
    );


VOID
NlbConfigurationUpdate::Initialize(
        VOID
        )
/*++

--*/
{
    TRACE_INFO("->%!FUNC!");
    InitializeCriticalSection(&s_Crit);
    InitializeListHead(&s_listCurrentUpdates);
    (VOID) CfgUtilInitialize();
    TRACE_INFO("<-%!FUNC!");
}

VOID
NlbConfigurationUpdate::Deinitialize(
    VOID
    )
/*++
    Status: done not tested
--*/
{
    TRACE_INFO("->%!FUNC!");

    //
    // Go through the list of updates, dereferencing any of them.
    //
    sfn_Lock();

    TRACE_INFO("Deinitialize: Going to deref all update objects");

    s_fDeinitializing = TRUE;

    while (!IsListEmpty(&s_listCurrentUpdates))
    {
        LIST_ENTRY *pLink = RemoveHeadList(&s_listCurrentUpdates);
        HANDLE hThread = NULL;
        NlbConfigurationUpdate *pUpdate;

        pUpdate = CONTAINING_RECORD(
                    pLink,
                    NlbConfigurationUpdate,
                    m_linkUpdates
                    );

        hThread = pUpdate->m_hAsyncThread;

        if (hThread != NULL)
        {
            //
            // There is an async thread for this update object. We're going
            // to wait for it to exit. But we need to first get a duplicate
            // handle for ourself, because we're not going to be holding any
            // locks when we're doing the waiting, and we want to make sure
            // that the handle doesn't go away.
            //
            BOOL fRet;
            fRet = DuplicateHandle(
                            GetCurrentProcess(),
                            hThread,
                            GetCurrentProcess(),
                            &hThread, // overwritten with the duplicate handle
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS
                            );
            if (!fRet)
            {
                TRACE_CRIT("Deinitialize: ERROR: couldn't duplicate handle");
                hThread=NULL;
            }
        }
        sfn_Unlock();

        //
        // Wait for the async thread (if any) for this process to exit
        //
        if (hThread != NULL)
        {
            TRACE_CRIT("Deinitialize: waiting for hThread 0x%p", hThread);
            WaitForSingleObject(hThread, INFINITE);
            TRACE_CRIT("Deinitialize: done waiting for hThread 0x%p", hThread);
            CloseHandle(hThread);
        }


        TRACE_INFO(L"Deinitialize: Dereferencing pUpdate(Guid=%ws)",
                            pUpdate->m_szNicGuid);
        pUpdate->mfn_Dereference(); // Deref ref added when adding this item to
                                    // the global list.
        sfn_Lock();
    }
    sfn_Unlock();

    //
    // Deinitialize the configuration utilities
    //
    CfgUtilDeitialize();

    DeleteCriticalSection(&s_Crit);

    TRACE_INFO("<-%!FUNC!");
}


WBEMSTATUS
NlbConfigurationUpdate::GetConfiguration(
    IN  LPCWSTR szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg // must be zero'd out
)
//
//
//
{
    WBEMSTATUS Status =  WBEM_NO_ERROR;
    NlbConfigurationUpdate *pUpdate = NULL;
    TRACE_INFO(L"->%!FUNC!(Nic=%ws)", szNicGuid);


    //
    // Look for an update object for the specified NIC, creating one if 
    // required.
    //
    Status = sfn_LookupUpdate(szNicGuid, TRUE, &pUpdate); // TRUE == Create

    if (FAILED(Status))
    {
        TRACE_CRIT(
            L"DoUpdate: Error looking up update object for NIC %ws",
            szNicGuid
            );
        pUpdate = NULL;
        goto end;
    }

    Status = pUpdate->mfn_GetCurrentClusterConfiguration(pCurrentCfg);

end:

    if (pUpdate != NULL)
    {
        //
        // Dereference the temporary reference added by sfn_LookupUpdate on
        // our behalf.
        //
        pUpdate->mfn_Dereference();
    }

    TRACE_INFO(L"<-%!FUNC!(Nic=%ws) returns 0x%08lx", szNicGuid, (UINT) Status);

    return Status;
}


WBEMSTATUS
NlbConfigurationUpdate::DoUpdate(
    IN  LPCWSTR szNicGuid,
    IN  LPCWSTR szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewCfg,
    OUT UINT   *pGeneration,
    OUT WCHAR  **ppLog                   // free using delete operator.
)
//
// 
//
// Called to initiate update to a new cluster state on that NIC. This
// could include moving from a NLB-bound state to the NLB-unbound state.
// *pGeneration is used to reference this particular update request.
//
/*++

Return Value:
    WBEM_S_PENDING  Pending operation.

--*/
{
    WBEMSTATUS Status =  WBEM_S_PENDING;
    NlbConfigurationUpdate *pUpdate = NULL;

    TRACE_INFO(L"->%!FUNC!(Nic=%ws)", szNicGuid);
    *ppLog = NULL;

    //
    // Look for an update object for the specified NIC, creating one if 
    // required.
    //
    Status = sfn_LookupUpdate(szNicGuid, TRUE, &pUpdate); // TRUE == Create

    if (FAILED(Status))
    {
        TRACE_CRIT(
            L"DoUpdate: Error creating new update object for NIC %ws",
            szNicGuid
            );
        pUpdate = NULL;
        goto end;
    }


    TRACE_INFO(
        L"DoUpdate: Created/found update object 0x%p update object for NIC %ws",
        pUpdate,
        szNicGuid
        );


    BOOL fDoAsync = FALSE;

    //
    // Get exclusive permission to perform an update on this NIC.
    // If mfn_StartUpdate succeeds we MUST make sure that mfn_StopUpdate() is
    // called, either here or asynchronously (or else we'll block all subsequent
    // updates to this NIC until this process/dll is unloaded!).
    //
    MyBreak(L"Break before calling StartUpdate.\n");
    Status = pUpdate->mfn_StartUpdate(pNewCfg, szClientDescription, &fDoAsync, ppLog);
    if (FAILED(Status))
    {
        goto end;
    }

    if (Status == WBEM_S_FALSE)
    {
        //
        //  The update is a No-Op. We return the current generation ID
        //  and switch the status to WBEM_NO_ERROR.
        //
        // WARNING/TODO: we return the value in m_OldClusterConfig.Generation,
        // because we know that this gets filled in when analyzing the update.
        // However there is a small possibility that a complete update
        // happened in *another* thead in between when we called mfn_StartUpdate
        // and now, in which case we'll be reporting the generation ID of
        // the later update.
        //
        sfn_Lock();
        if (!pUpdate->m_OldClusterConfig.fValidNlbCfg)
        {
            //
            // We could get here if some activity happened in another
            // thread which resulted in the old cluster state now being
            // invalid. It's a highly unlikely possibility.
            //
            ASSERT(!"Old cluster state invalid");
            TRACE_CRIT("old cluster state is invalid %ws", szNicGuid);
            Status = WBEM_E_CRITICAL_ERROR;
        }
        else
        {
            *pGeneration = pUpdate->m_OldClusterConfig.Generation;
            Status = WBEM_NO_ERROR;
        }
        sfn_Unlock();
        goto end;
    }


    TRACE_INFO(
        L"DoUpdate: We're cleared to update for NIC %ws",
        szNicGuid
        );

    //
    // Once we've started the update, m_Generation is the generation number 
    // assigned to this update.
    //
    *pGeneration = pUpdate->m_Generation;

    //
    // For testing purposes, force fDoAsync==FALSE;
    //
    // fDoAsync = FALSE;

    if (fDoAsync)
    {
        TRACE_INFO(
            L"DoUpdate: Initialting ASYNC update for NIC %ws",
            szNicGuid
            );
        //
        // We must do this asynchronously -- start a thread that'll complete
        // the configuration update, and return PENDING.
        //
        DWORD ThreadId;
        HANDLE hThread;

        hThread = CreateThread(
                        NULL,       // lpThreadAttributes,
                        0,          // dwStackSize,
                        s_AsyncUpdateThreadProc, // lpStartAddress,
                        pUpdate,    // lpParameter,
                        CREATE_SUSPENDED, // dwCreationFlags,
                        &ThreadId       // lpThreadId
                        );
        if (hThread == NULL)
        {
            TRACE_INFO(
                L"DoUpdate: ERROR Creating Thread. Aborting update request for Nic %ws",
                szNicGuid
                );
            Status = WBEM_E_FAILED; // TODO -- find better error
        }
        else
        {

            sfn_Lock();
            //
            // Since we've claimed the right to perform a config update on this
            // NIC we'd better not find an other update going on!
            // Save away the thread handle and id.
            //
            ASSERT(m_hAsyncThread == NULL);
            pUpdate->mfn_Reference(); // Add reference for async thread.
            pUpdate->m_hAsyncThread = hThread;
            pUpdate->m_AsyncThreadId = ThreadId;
            sfn_Unlock();
    
            //
            // The rest of the update will carry on in the context of the async
            // thread. That thread will make sure that pUpdate->mfn_StopUpdate()
            // is called so we shouldn't do it here.
            //
    
            DWORD dwRet = ResumeThread(hThread);
            if (dwRet == 0xFFFFFFFF) // this is what it says in the SDK
            {
                //
                // Aargh ... failure
                // Undo reference to this thread in pUpdate
                //
                TRACE_INFO("ERROR resuming thread for NIC %ws", szNicGuid);
                sfn_Lock();
                ASSERT(pUpdate->m_hAsyncThread == hThread);
                pUpdate->m_hAsyncThread = NULL;
                pUpdate->m_AsyncThreadId = 0;
                pUpdate->mfn_Dereference(); // Remove ref added above.
                sfn_Unlock();
                CloseHandle(hThread);
                Status = WBEM_E_FAILED; // TODO -- find better error
            }
            else
            {
                Status = WBEM_S_PENDING;
            }
        }

        if (FAILED(Status)) // this doesn't include pending
        {
            //
            // Signal the stop of the update process.
            // This also releases exclusive permission to do updates.
            //

            pUpdate->m_CompletionStatus = Status; // Stop update needs this to be set.
            pUpdate->mfn_StopUpdate(ppLog);
        }
        else
        {
            ASSERT(Status == WBEM_S_PENDING);
        }

    }
    else
    {
        //
        // We can do this synchronously -- call  mfn_Update here itself
        // and return the result.
        //
        pUpdate->mfn_ReallyDoUpdate();

        //
        // Let's extract the result
        //
        sfn_Lock();
        Status =  pUpdate->m_CompletionStatus;
        sfn_Unlock();

        ASSERT(Status != WBEM_S_PENDING);

        //
        // Signal the stop of the update process. This also releases exclusive
        // permission to do updates. So potentially other updates can start
        // happening concurrently before mfn_StopUpdate returns.
        //
        pUpdate->mfn_StopUpdate(ppLog);
    }

end:

    if (pUpdate != NULL)
    {
        //
        // Dereference the temporary reference added by sfn_LookupUpdate on
        // our behalf.
        //
        pUpdate->mfn_Dereference();
    }


    TRACE_INFO(L"<-%!FUNC!(Nic=%ws) returns 0x%08lx", szNicGuid, (UINT) Status);

    return Status;
}



//
// Constructor and distructor --  note that these are private
//
NlbConfigurationUpdate::NlbConfigurationUpdate(VOID)
//
// 
//
{
    //
    // This assumes that we don't have a parent class. We should never
    // have a parent class.
    //
    ZeroMemory(this, sizeof(*this));
    m_State = UNITIALIZED;

    //
    // Note: the refcount is zero on return from the constructor.
    // The caller is expected to bump it up when it adds this entry to
    // to the list.
    //

}

NlbConfigurationUpdate::~NlbConfigurationUpdate()
//
// Status: done
//
{
    ASSERT(m_RefCount == 0);
    ASSERT(m_State!=ACTIVE);
    ASSERT(m_hAsyncThreadId == 0);

    //
    // TODO: Delete ip-address-info structures if any
    //

    if (m_hEvent!=NULL)
    {
        CloseHandle(m_hEvent);
    }

}

VOID
NlbConfigurationUpdate::mfn_Reference(
    VOID
    )
{
    InterlockedIncrement(&m_RefCount);
}

VOID
NlbConfigurationUpdate::mfn_Dereference(
    VOID
    )
{
    LONG l  = InterlockedDecrement(&m_RefCount);

    ASSERT(l >= 0);

    if (l == 0)
    {
        TRACE_CRIT("Deleting update instance 0x%p", (PVOID) this);
        delete this;
    }
}

//
// Following is a shortcut where you directly specify a format string.
//
VOID
NlbConfigurationUpdate::mfn_Log(
    LPCWSTR szFormat,
    ...
    )
{
   WCHAR wszBuffer[1024];
   wszBuffer[0] = 0;

   va_list arglist;
   va_start (arglist, szFormat);
   int cch = vswprintf(wszBuffer, szFormat, arglist);
   va_end (arglist);

   mfn_LogRawText(wszBuffer);

//   Sleep(2000);
}

#if OBSOLETE
VOID
NlbConfigurationUpdate::mfn_LogRawTextOld(
    LPCWSTR szText
    )
{
    UINT EntrySize = lstrlen(szText)+1; // in units of wchars, incl ending NULL.

    //
    // Note: on entry, m_Log.Start, m_Log.End, and m_CharsLeft can all be 0.
    // We allocate/reallocate as required.
    //

    sfn_Lock();

    if (m_Log.CharsLeft < EntrySize)
    {
        //
        // Not enough space in the log buffer for this entry. Let's try
        // to grow the buffer...
        //
        UINT_PTR CurrentFilledSize = (m_Log.End - m_Log.Start);
        UINT_PTR CurrentSize = CurrentFilledSize + m_Log.CharsLeft;
        UINT_PTR NewSize = EntrySize + 2*CurrentSize;


        //
        // We don't let the log grow without bound -- truncate if required.
        //
        #define NLB_MAX_LOG_SIZE 1024 // Size in units of wchars
        if (NewSize > NLB_MAX_LOG_SIZE)
        {
            NewSize = NLB_MAX_LOG_SIZE;
        }

        //
        // Reallocate Log if we need to..
        //
        if (NewSize > CurrentSize)
        {
            WCHAR *pNewBuf = new WCHAR[NewSize];

            if (pNewBuf == NULL)
            {
                //
                // Oops -- couldn't create log entry.
                //
                TRACE_CRIT(
                    "Error expanding log entry for object 0x%p",
                    (PVOID) this
                    );
            }
            else
            {
                WCHAR *pOldBuf = m_Log.Start; // could be NULL

                if (CurrentFilledSize!=0)
                {
                    //
                    // Copy over what's in the old log, excluding the final
                    // null terminator ... 
                    //
                    CopyMemory(pNewBuf, pOldBuf, CurrentFilledSize*sizeof(*pNewBuf));
                }
                if (pOldBuf != NULL)
                {
                    delete pOldBuf;
                    pOldBuf = NULL;
                }
                m_Log.Start = pNewBuf;
                m_Log.End   = pNewBuf + CurrentFilledSize;
                m_Log.CharsLeft = (NewSize-CurrentFilledSize);
                //
                // Null terminate the string. There will be
                // enough space for this because New>Current.
                //
                ASSERT(m_Log.CharsLeft != 0);
                *m_Log.End  = 0;
            }
        }
    }

    //
    // Lets try again ...
    //
    if (m_Log.CharsLeft >= EntrySize)
    {
        ASSERT(*m_Log.End == 0);
        //
        // Enough space in log for the entry. Let's copy it over.
        // Note that we make the m_Log.End point to the last character
        // (NULL), and compute m_Log.CharsLeft accordingly.
        //
        CopyMemory(m_Log.End, szText, EntrySize*sizeof(*szText));
        m_Log.End+=(EntrySize-1); // EntrySize includes the NULL
        m_Log.CharsLeft-=(EntrySize-1);

        ASSERT(*m_Log.End == 0);
    }


    sfn_RegUpdateCompletionLog(
        m_szNicGuid,
        m_Generation,
        m_Log.Start
        );

    sfn_Unlock();
}
#endif // OBSOLETE


#if OBSOLETE
VOID
NlbConfigurationUpdate::mfn_ExtractLog(
    OUT LPWSTR *ppLog
    )
{
    UINT_PTR CurrentFilledSize;

    *ppLog = NULL;

    sfn_Lock();

    CurrentFilledSize = (m_Log.End - m_Log.Start);

    if (CurrentFilledSize != 0)
    {
        WCHAR *pCopy = new WCHAR[CurrentFilledSize+1]; // +1 for ending null.

        if (pCopy!=NULL)
        {
            //
            // If non-empty, the log always has space for 1 char, and
            // *m_Log.End is the the NULL-termination.
            //
            ASSERT(m_Log.CharsLeft!=0);
            ASSERT(*m_Log.End == 0);
            CopyMemory(pCopy, m_Log.Start, (CurrentFilledSize+1)*sizeof(*pCopy));
            ASSERT(pCopy[CurrentFilledSize]==0);
            *ppLog = pCopy;
        }
    }

    sfn_Unlock();
}
#endif // OBSOLETE



VOID
NlbConfigurationUpdate::sfn_ReadLog(
    IN  HKEY hKeyLog,
    IN  UINT Generation,
    OUT LPWSTR *ppLog
    )
{
    WCHAR szValueName[128];
    WCHAR *pLog = NULL;
    LONG lRet;
    DWORD dwType;
    DWORD cbData;

    *ppLog = NULL;


    wsprintf(szValueName, L"%d.log", Generation);

    cbData = 0;
    lRet =  RegQueryValueEx(
              hKeyLog,         // handle to key to query
              szValueName,  // address of name of value to query
              NULL,         // reserved
              &dwType,   // address of buffer for value type
              NULL, // address of data buffer
              &cbData  // address of data buffer size
              );
    if (    (lRet == ERROR_SUCCESS)
        &&  (cbData > sizeof(WCHAR))
        &&  (dwType == REG_SZ))
    {
        // We've got a non-null log entry...
        // Let's try to read it..
        // cbData should be a multiple of sizeof(WCHAR) but just in
        // case let's allocate a little more...
        pLog = new WCHAR[(cbData+1)/sizeof(WCHAR)];
        if (pLog == NULL)
        {
            TRACE_CRIT("Error allocating space for log");
        }
        else
        {
            lRet =  RegQueryValueEx(
                      hKeyLog,         // handle to key to query
                      szValueName,  // address of name of value to query
                      NULL,         // reserved
                      &dwType,   // address of buffer for value type
                      (LPBYTE)pLog, // address of data buffer
                      &cbData  // address of data buffer size
                      );
            if (    (lRet != ERROR_SUCCESS)
                ||  (cbData <= sizeof(WCHAR))
                ||  (dwType != REG_SZ))
            {
                // Oops -- an error this time around!
                TRACE_CRIT("Error reading log entry for gen %d", Generation);
                delete pLog;
                pLog = NULL;
            }
        }
    }
    else
    {
        TRACE_CRIT("Error reading log entry for Generation %lu", Generation); 
        // ignore the rror
        //
    }

    *ppLog = pLog;

}



VOID
NlbConfigurationUpdate::sfn_WriteLog(
    IN  HKEY hKeyLog,
    IN  UINT Generation,
    IN  LPCWSTR pLog,
    IN  BOOL    fAppend
    )
{
    //
    // TODO: If fAppend==TRUE, this function is a bit wasteful in its use
    // of the heap.
    //
    WCHAR szValueName[128];
    LONG lRet;
    LPWSTR pOldLog = NULL;
    LPWSTR pTmpLog = NULL;
    UINT Len = wcslen(pLog)+1; // +1 for ending NULL

    if (fAppend)
    {
        sfn_ReadLog(hKeyLog, Generation, &pOldLog);
        if (pOldLog != NULL && *pOldLog != NULL)
        {
            Len += wcslen(pOldLog);
            if (Len > NLBUPD_MAX_LOG_LENGTH)
            {
                TRACE_CRIT("sfn_WriteLog: log size exceeded");
                goto end;
            }
            pTmpLog = new WCHAR[Len];
            if (pTmpLog == NULL)
            {
                TRACE_CRIT("sfn_WriteLog: allocation failure!");
                goto end;
            }
            wcscpy(pTmpLog, pOldLog);
            wcscat(pTmpLog, pLog);
            pLog = pTmpLog;
        }
    }
    wsprintf(szValueName, L"%d.log", Generation);

    lRet = RegSetValueEx(
            hKeyLog,           // handle to key to set value for
            szValueName,    // name of the value to set
            0,              // reserved
            REG_SZ,     // flag for value type
            (BYTE*) pLog,// address of value data
            Len*sizeof(WCHAR)  // size of value data
            );
    if (lRet != ERROR_SUCCESS)
    {
        TRACE_CRIT("Error writing log entry for generation %d", Generation);
        // We ignore this error.
    }

end:

    if (pOldLog != NULL)
    {
        delete pOldLog;
    }

    if (pTmpLog != NULL)
    {
        delete pTmpLog;
    }

    return;
}



VOID
NlbConfigurationUpdate::mfn_LogRawText(
    LPCWSTR szText
    )
//
// We read the current value of the log for this update, append szText
// and write back the log.
{

    TRACE_CRIT(L"LOG: %ws", szText);
    sfn_Lock();

    if (m_State!=ACTIVE)
    {
        //
        // Logging should only be performed when there is an active update
        // going on -- the log is specific to the currently active update.
        //
        TRACE_CRIT("WARNING: Attempt to log when not in ACTIVE state");
        goto end;
    }
    else
    {
        HKEY hKey = m_hCompletionKey;

        if (hKey != NULL)
        {
            sfn_WriteLog(hKey, m_Generation, szText, TRUE); // TRUE==append.
        }
    }
end:

    sfn_Unlock();
}

//
// Looks up the current update for the specific NIC.
// We don't bother to reference count because this object never
// goes away once created -- it's one per unique NIC GUID for as long as
// the DLL is loaded (may want to revisit this).
//
WBEMSTATUS
NlbConfigurationUpdate::sfn_LookupUpdate(
    IN LPCWSTR szNic,
    IN BOOL    fCreate, // Create if required
    OUT NlbConfigurationUpdate ** ppUpdate
    )
//
// 
//
{
    WBEMSTATUS Status;
    NlbConfigurationUpdate *pUpdate = NULL;

    *ppUpdate = NULL;
    //
    // With our global lock held, we'll look for an update structure
    // with the matching nic. If we find it, we'll return it, else
    // (if fCreate==TRUE) we'll create and initialize a structure and add
    // it to the list.
    //
    sfn_Lock();

    if (s_fDeinitializing)
    {
        TRACE_CRIT(
            "LookupUpdate: We are Deinitializing, so we FAIL this request: %ws",
            szNic
            );
        Status = WBEM_E_NOT_AVAILABLE;
        goto end;
    }

    Status = CfgUtilsValidateNicGuid(szNic);

    if (FAILED(Status))
    {
        TRACE_CRIT(
            "LookupUpdate: Invalid GUID specified: %ws",
            szNic
            );
        goto end;
        
    }

    LIST_ENTRY *pLink = s_listCurrentUpdates.Flink;

    while (pLink != & s_listCurrentUpdates)
    {
        

        pUpdate = CONTAINING_RECORD(
                    pLink,
                    NlbConfigurationUpdate,
                    m_linkUpdates
                    );
        if (!_wcsicmp(pUpdate->m_szNicGuid, szNic))
        {
            // Found it!
            break;
        }
        pUpdate = NULL;
        pLink = pLink->Flink;
    }

    if (pUpdate==NULL && fCreate)
    {
        // Let's create one -- it does NOT add itself to the list, and
        // furthermore, its reference count is zero.
        //
        pUpdate = new NlbConfigurationUpdate();

        if (pUpdate==NULL)
        {
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }
        else
        {
            //
            // Complete initialization here, and place it in the list.
            //

            CopyMemory(
                pUpdate->m_szNicGuid,
                szNic,
                (NLB_GUID_LEN+1)*sizeof(WCHAR)
                );

            //
            //  Create a handle to the global configuration EVENT for this
            //  NIC
            //
            HANDLE hEvent;
            WCHAR  EventName[sizeof(NLB_CONFIGURATION_EVENT_PREFIX)/sizeof(WCHAR) + NLB_GUID_LEN];
            wcscpy(EventName, NLB_CONFIGURATION_EVENT_PREFIX);
            wcscat(EventName, szNic);

            hEvent = CreateEvent(
                        NULL, //  lpEventAttributes,
                        FALSE, //  bManualReset FALSE==AutoReset
                        TRUE, // TRUE==initial state is signaled.
                        EventName
                        );
                                          
            TRACE_INFO(
                L"CreatedEvent(%ws) returns 0x%08p",
                EventName,
                hEvent
                );

            if (hEvent == NULL)
            {
                delete pUpdate;
                pUpdate = NULL;
                Status = (WBEMSTATUS) GetLastError(); // TODO
                if (!FAILED(Status))
                {
                    ASSERT(FALSE);
                    Status = WBEM_E_OUT_OF_MEMORY;
                }
                goto end;

            }
            else
            {
                pUpdate->m_hEvent = hEvent;
                InsertHeadList(&s_listCurrentUpdates, &pUpdate->m_linkUpdates);
                pUpdate->mfn_Reference(); // Reference for being in the list
                pUpdate->m_State = IDLE;
            }
        }
    }
    else if (pUpdate == NULL) // Couldn't find it, fCreate==FALSE
    {
        TRACE_CRIT(
            "LookupUpdate: Could not find GUID specified: %ws",
            szNic
            );
        Status = WBEM_E_NOT_FOUND;
        goto end;
    }

    ASSERT(pUpdate!=NULL);
    pUpdate->mfn_Reference(); // Reference for caller. Caller should deref.
    *ppUpdate = pUpdate;

    Status = WBEM_NO_ERROR;

end:
    if (FAILED(Status))
    {
        ASSERT(pStatus!=NULL);
    }

    sfn_Unlock();


    return Status;
}


DWORD
WINAPI
NlbConfigurationUpdate::s_AsyncUpdateThreadProc(
    LPVOID lpParameter   // thread data
    )
/*++

--*/
{
    //
    // This thread is started only after we have exclusive right to perform
    // an update on the specified NIC. This means that mfn_StartUpdate()
    // has previously returned successfully. We need to call mfn_StopUpdate()
    // to signal the end of the update when we're done.
    //

    NlbConfigurationUpdate *pUpdate = (NlbConfigurationUpdate *) lpParameter;

    TRACE_INFO(L"->%!FUNC!(Nic=%ws)",  pUpdate->m_szNicGuid);

    ASSERT(pUpdate->m_AsyncThreadId == GetCurrentThreadId());

    //
    // Actually perform the update. mfn_ReallyDoUpate will save away the status
    // appropriately.
    //
    pUpdate->mfn_ReallyDoUpdate();

    //
    // We're done, let's remove the reference to our thread from pUpdate.
    //
    HANDLE hThread;
    sfn_Lock();
    hThread = pUpdate->m_hAsyncThread;
    pUpdate->m_hAsyncThread = NULL;
    pUpdate->m_AsyncThreadId = 0;
    sfn_Unlock();
    ASSERT(hThread!=NULL);
    CloseHandle(hThread);

    //
    // Signal the stop of the update process. This also releases exclusive
    // permission to do updates. So potentially other updates can start
    // happening concurrently before mfn_StopUpdate returns.
    //
    pUpdate->mfn_StopUpdate(NULL);

    TRACE_INFO(L"<-%!FUNC!(Nic=%ws)",  pUpdate->m_szNicGuid);

    //
    // Deref the ref to pUpdate added when this thread was started.
    // pUpdate may not be valid after this.
    //
    pUpdate->mfn_Dereference();

    return 0; // This return value is ignored.
}

//
// Create the specified subkey key (for r/w access) for the specified
// the specified NIC.
//
HKEY
NlbConfigurationUpdate::
sfn_RegCreateKey(
    IN  LPCWSTR szNicGuid,
    IN  LPCWSTR szSubKey,   // Optional
    IN  BOOL    fVolatile,
    OUT BOOL   *fExists
    )
// Status 
{
    WCHAR szKey[1024];
    DWORD dwOptions = 0;

    if (fVolatile)
    {
        dwOptions = REG_OPTION_VOLATILE;
    }

    wcscpy(szKey, 
        L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\ConfigurationHistory\\");
    wcscat(szKey, szNicGuid);
    if (szSubKey != NULL)
    {
        wcscat(szKey, L"\\");
        wcscat(szKey, szSubKey);
    }

    HKEY hKey = NULL;
    DWORD dwDisposition;

    LONG lRet;
    lRet = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE, // handle to an open key
            szKey,                // address of subkey name
            0,                  // reserved
            L"class",           // address of class string
            dwOptions,          // special options flag
            KEY_ALL_ACCESS,     // desired security access
            NULL,               // address of key security structure
            &hKey,              // address of buffer for opened handle
            &dwDisposition   // address of disposition value buffer
            );
    if (lRet == ERROR_SUCCESS)
    {
        if (dwDisposition == REG_CREATED_NEW_KEY)
        {
            *fExists = FALSE;
        }
        else
        {
            ASSERT(dwDisposition == REG_OPENED_EXISTING_KEY);
            *fExists = TRUE;
        }
    }
    else
    {
        TRACE_CRIT("Error creating key %ws. WinError=0x%08lx", szKey, GetLastError());
        hKey = NULL;
    }

    return hKey;
}


//
// Open the specified subkey key (for r/w access) for the specified
// the specified NIC.
//
HKEY
NlbConfigurationUpdate::
sfn_RegOpenKey(
    IN  LPCWSTR szNicGuid,
    IN  LPCWSTR szSubKey
    )
{
    WCHAR szKey[1024];

    wcscpy(szKey, 
        L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\ConfigurationHistory\\");
    wcscat(szKey, szNicGuid);
    if (szSubKey != NULL)
    {
        wcscat(szKey, L"\\");
        wcscat(szKey, szSubKey);
    }

    HKEY hKey = NULL;
    DWORD dwDisposition;

    LONG lRet;
    lRet = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle to an open key
            szKey,                // address of subkey name
            0,                  // reserved
            KEY_ALL_ACCESS,     // desired security access
            &hKey              // address of buffer for opened handle
            );
    if (lRet != ERROR_SUCCESS)
    {
        TRACE_CRIT("Error opening key %ws. WinError=0x%08lx", szKey, GetLastError());
        hKey = NULL;
    }

    return hKey;
}


//
// Save the specified completion status to the registry.
//
WBEMSTATUS
NlbConfigurationUpdate::sfn_RegSetCompletion(
    IN  LPCWSTR szNicGuid,
    IN  UINT    Generation,
    IN  WBEMSTATUS    CompletionStatus
    )
{
    WBEMSTATUS Status = WBEM_E_FAILED;
    HKEY hKey;
    BOOL fExists;

    hKey =  sfn_RegCreateKey(
                szNicGuid,
                NLBUPD_REG_COMPLETIONS, // szSubKey,
                TRUE, // TRUE == fVolatile,
                &fExists
                );

    if (hKey == NULL)
    {
        TRACE_CRIT("Error creating key for %ws", szNicGuid);
        goto end;
    }

    LONG lRet;
    WCHAR szValueName[128];
    NLB_COMPLETION_RECORD Record;

    ZeroMemory(&Record, sizeof(Record));
    Record.Version = NLB_CURRENT_COMPLETION_RECORD_VERSION;
    Record.Generation = Generation;
    Record.CompletionCode = (UINT) CompletionStatus;
    
    wsprintf(szValueName, L"%d", Generation);

    lRet = RegSetValueEx(
            hKey,           // handle to key to set value for
            szValueName,    // name of the value to set
            0,              // reserved
            REG_BINARY,     // flag for value type
            (BYTE*) &Record,// address of value data
            sizeof(Record)  // size of value data
            );

    if (lRet == ERROR_SUCCESS)
    {

        Status = WBEM_NO_ERROR;
    }
    else
    {
        TRACE_CRIT("Error setting completion record for %ws(%lu)",
                    szNicGuid,
                    Generation
                    ); 
        goto end;
    }

end:

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return Status;
}


//
// Retrieve the specified completion status from the registry.
//
WBEMSTATUS
NlbConfigurationUpdate::
sfn_RegGetCompletion(
    IN  LPCWSTR szNicGuid,
    IN  UINT    Generation,
    OUT WBEMSTATUS  *pCompletionStatus,
    OUT WCHAR  **ppLog                   // free using delete operator.
    )
{
    WBEMSTATUS Status = WBEM_E_FAILED;
    HKEY hKey;
    WCHAR *pLog = NULL;

    #if 0
    typedef struct {
        UINT Version;
        UINT Generation;
        UINT CompletionCode;
        UINT Reserved;
    } NLB_COMPLETION_RECORD, *PNLB_COMPLETION_RECORD;
    #endif // 0

    hKey =  sfn_RegOpenKey(
                szNicGuid,
                NLBUPD_REG_COMPLETIONS // szSubKey,
                );

    if (hKey == NULL)
    {
        TRACE_CRIT("Error opening key for %ws", szNicGuid);
        goto end;
    }
    
    
    LONG lRet;
    WCHAR szValueName[128];
    DWORD dwType;
    NLB_COMPLETION_RECORD Record;
    DWORD cbData  = sizeof(Record);

    wsprintf(szValueName, L"%d", Generation);

    lRet =  RegQueryValueEx(
              hKey,         // handle to key to query
              szValueName,  // address of name of value to query
              NULL,         // reserved
              &dwType,   // address of buffer for value type
              (LPBYTE)&Record, // address of data buffer
              &cbData  // address of data buffer size
              );
    if (    (lRet != ERROR_SUCCESS)
        ||  (cbData != sizeof(Record)
        ||  (dwType != REG_BINARY))
        ||  (Record.Version != NLB_CURRENT_COMPLETION_RECORD_VERSION)
        ||  (Record.Generation != Generation))
    {
        // This is not a valid record!
        TRACE_CRIT("Error reading completion record for %ws(%d)",
                        szNicGuid, Generation);
        goto end;
    }

    //
    // We've got a valid completion record.
    // Let's now try to read the log for this record.
    //
    sfn_ReadLog(hKey, Generation, &pLog);

    //
    // We've got valid values -- fill out the output params...
    //
    *pCompletionStatus = (WBEMSTATUS) Record.CompletionCode;
    *ppLog = pLog; // could be NULL.
    Status = WBEM_NO_ERROR;

end:

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return Status;
}


//
// Delete the specified completion status from the registry.
//
VOID
NlbConfigurationUpdate::
sfn_RegDeleteCompletion(
    IN  LPCWSTR szNicGuid,
    IN  UINT    Generation
    )
{
    WBEMSTATUS Status = WBEM_E_FAILED;
    HKEY hKey;
    WCHAR pLog = NULL;

    hKey =  sfn_RegOpenKey(
                szNicGuid,
                NLBUPD_REG_COMPLETIONS // szSubKey,
                );

    if (hKey == NULL)
    {
        TRACE_CRIT("Error opening key for %ws", szNicGuid);
        goto end;
    }

    
    WCHAR szValueName[128];
    wsprintf(szValueName, L"%d", Generation);
    RegDeleteValue(hKey, szValueName);
    wsprintf(szValueName, L"%d.log", Generation);
    RegDeleteValue(hKey, szValueName);

end:

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }
}

//
// Called to get the status of an update request, identified by
// Generation.
//
WBEMSTATUS
NlbConfigurationUpdate::GetUpdateStatus(
    IN  LPCWSTR szNicGuid,
    IN  UINT    Generation,
    IN  BOOL    fDelete,                // Delete completion record
    OUT WBEMSTATUS  *pCompletionStatus,
    OUT WCHAR  **ppLog                   // free using delete operator.
    )
//
// 
//
{
    WBEMSTATUS  Status = WBEM_E_NOT_FOUND;
    WBEMSTATUS  CompletionStatus = WBEM_NO_ERROR;

    TRACE_INFO(
        L"->%!FUNC!(Nic=%ws, Gen=%ld)",
        szNicGuid,
        Generation
        );

    //
    // We look in the registry for
    // this generation ID and return the status based on the registry
    // record
    //
    Status =  sfn_RegGetCompletion(
                    szNicGuid,
                    Generation,
                    &CompletionStatus,
                    ppLog
                    );

    if (!FAILED(Status))
    {
        if (fDelete && CompletionStatus!=WBEM_S_PENDING)
        {
            sfn_RegDeleteCompletion(
                szNicGuid,
                Generation
                );
        }
        *pCompletionStatus = CompletionStatus;
    }

    TRACE_INFO(
        L"<-%!FUNC!(Nic=%ws, Gen=%ld) returns 0x%08lx",
        szNicGuid,
        Generation,
        (UINT) Status
        );

    return Status;
}


//
// Release the machine-wide update event for this NIC, and delete any
// temporary entries in the registry that were used for this update.
//
VOID
NlbConfigurationUpdate::mfn_StopUpdate(
    OUT WCHAR **                           ppLog
    )
{
    WBEMSTATUS Status;

    if (ppLog != NULL)
    {
        *ppLog = NULL;
    }

    sfn_Lock();

    if (m_State!=ACTIVE)
    {
        ASSERT(FALSE);
        TRACE_CRIT("StopUpdate: invalid state %d", (int) m_State);
        goto end;
    }

    ASSERT(m_hAsyncThread==NULL);


    //
    // Update the completion status value for current generation
    //
    Status =  sfn_RegSetCompletion(
                    m_szNicGuid,
                    m_Generation,
                    m_CompletionStatus
                    );
    
    if (FAILED(m_CompletionStatus))
    {
    }
    //
    // Note: mfn_ReallyDoUpdate logs the fact that it started and stopped the
    // update, so no need to do that here.
    //

    //
    // Release (signal) the gobal config event for this NIC
    //
    m_State = IDLE;
    ASSERT(m_hCompletionKey != NULL); // If we started, this key should be !null
    if (ppLog!=NULL)
    {
        sfn_ReadLog(m_hCompletionKey, m_Generation, ppLog);
    }
    RegCloseKey(m_hCompletionKey);
    m_hCompletionKey = NULL;
    m_Generation = 0;
    SetEvent(m_hEvent);
end:

    sfn_Unlock();
    return;
}


WBEMSTATUS
NlbConfigurationUpdate::mfn_StartUpdate(
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewCfg,
    IN  LPCWSTR                             szClientDescription,
    OUT BOOL                               *pfDoAsync,
    OUT WCHAR **                           ppLog
    )
//
// Special return values:
//    WBEM_E_ALREADY_EXISTS: another update is in progress.
//
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    HANDLE hEvent;
    BOOL fWeAcquiredLock = FALSE;
    HKEY hRootKey = NULL;
    BOOL fExists;

    if (ppLog != NULL)
    {
        *ppLog = NULL;
    }

    //
    // Try to acquire global config event for this NIC. If we do, 
    // set our state to ACTIVE.
    //

    sfn_Lock();

    do // while false
    {
        hEvent = m_hEvent;
        if (m_State!=IDLE)
        {
            TRACE_CRIT("StartUpdate: invalid state %d", (int) m_State);
            break;
        }
        if (hEvent == NULL)
        {
            // TODO: create event on the fly here (we may not want to
            // keep the handle to the event open for long periods of time).

            TRACE_CRIT("StartUpdate: Unexpected NULL event handle");
            break;
        }

        //
        // Try to gain exclusive access...
        // WARNING: we're waiting for 100ms with the global lock held!
        // If we want to try for longer we should have a loop outside
        // the lock/unlock.
        //
        TRACE_INFO("Waiting to get global event");
        DWORD dwRet = WaitForSingleObject(hEvent, 100);
        if (dwRet == WAIT_TIMEOUT || dwRet == WAIT_FAILED)
        {
            TRACE_CRIT("StartUpdate: timeout or failure waiting for event");
            Status = WBEM_E_ALREADY_EXISTS;
            break;
        }
        TRACE_INFO("Got global event!");
        Status = WBEM_NO_ERROR;
        fWeAcquiredLock = TRUE;

        //
        // Create/Open the completions key for this NIC.
        //
        {
            HKEY hKey;

            hKey =  sfn_RegCreateKey(
                        m_szNicGuid,
                        NLBUPD_REG_COMPLETIONS, // szSubKey,
                        TRUE, // TRUE == fVolatile,
                        &fExists
                        );
        
            if (hKey == NULL)
            {
                TRACE_CRIT("Error creating completions key for %ws", m_szNicGuid);
                Status = WBEM_E_CRITICAL_ERROR;
                ASSERT(m_hCompletionKey == NULL);
            }
            else
            {
                m_hCompletionKey = hKey;
            }
        }
    }
    while (FALSE);


    if (!FAILED(Status))
    {
        m_State = ACTIVE;
    }

    sfn_Unlock();


    if (FAILED(Status)) goto end;

    //
    // WE HAVE NOW GAINED EXCLUSIVE ACCESS TO UPDATE THE CONFIGURATION
    //

    //
    // Creat/Open the root key for updates to the specified NIC, and determine
    // the proposed NEW generation count for the NIC. We don't actually
    // write the new generation count back to the registry unless we're
    // going to do an update. The reasons for NOT doing an update are
    // (a) some failure or (b) the update turns out to be a NO-OP.
    //
    {
        BOOL fExists = FALSE;
        LONG lRet;
        DWORD dwType;
        DWORD dwData;
        DWORD Generation;
        hRootKey =  sfn_RegCreateKey(
                    m_szNicGuid,
                    NULL,       // NULL == root for this guid.
                    FALSE, // FALSE == Non-volatile
                    &fExists
                    );
        
        if (hRootKey==NULL)
        {
                TRACE_CRIT("CRITICAL ERROR: Couldn't set generation number for %ws",
                m_szNicGuid);
                Status = WBEM_E_CRITICAL_ERROR;
                goto end;
        }

        Generation = 1; // We assume generation is 1 on error reading gen.
    
        dwData = sizeof(Generation);
        lRet =  RegQueryValueEx(
                  hRootKey,         // handle to key to query
                  L"Generation",  // address of name of value to query
                  NULL,         // reserved
                  &dwType,   // address of buffer for value type
                  (LPBYTE) &Generation, // address of data buffer
                  &dwData  // address of data buffer size
                  );
        if (    lRet != ERROR_SUCCESS
            ||  dwType != REG_DWORD
            ||  dwData != sizeof(Generation))
        {
            //
            // Couldn't read the generation. Let's assume it's 
            // a starting value of 1.
            //
            TRACE_CRIT("Error reading generation for %ws; assuming its 1",
                m_szNicGuid);
            Generation = 1;
        }

        //
        // We set the value here before actually writing the new
        // generation to the registry purely because we want any
        // subsequently logged information to go to this generation.
        // Logging uses m_Generation to figure out where to put the log.
        //
        m_Generation = Generation + 1;
    }

    //
    // Copy over upto NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH chars of
    // szClientDescription.
    //
    {
        UINT lClient = wcslen(szClientDescription)+1;
        if (lClient > NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH)
        {
            TRACE_CRIT("Truncating client description %ws", szClientDescription);
            lClient = NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH;
        }
        CopyMemory(
            m_szClientDescription,
            szClientDescription,
            (lClient+1)*sizeof(WCHAR) // +1 for NULL
            );
        m_szClientDescription[NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH] = 0;

    }

    //
    // Log the fact the we're received an update request from the specified
    // client.
    //
    mfn_Log(L"Processing update request from \"%ws\"\n", m_szClientDescription);

    // Load the current cluster configuration into
    // m_OldClusterConfig field.
    // The m_OldClusterConfig.fValidNlbCfg field is set to TRUE IFF there were
    // no errors trying to fill out the information.
    //
    if (m_OldClusterConfig.pIpAddressInfo != NULL)
    {
        delete m_OldClusterConfig.pIpAddressInfo;
    }
    // mfn_GetCurrentClusterConfiguration expects a zeroed-out structure
    // on init...
    ZeroMemory(&m_OldClusterConfig, sizeof(m_OldClusterConfig));
    Status = mfn_GetCurrentClusterConfiguration(&m_OldClusterConfig);
    if (FAILED(Status))
    {
        //
        // Ouch, couldn't read the current cluster configuration...
        //
        TRACE_CRIT(L"Cannot get current cluster config on Nic %ws", m_szNicGuid);
        mfn_Log(L"Error reading cluster configuration\n");

        goto end;
    }

    ASSERT(mfn_OldClusterConfig.fValidNlbCfg == TRUE);
    if (m_Generation != (m_OldClusterConfig.Generation+1))
    {
        //
        // We should never get here, because no one should updated the
        // generation between when we read it in this function
        // and when we called mfn_GetCurrentClusterConfiguration.
        //
        TRACE_CRIT("ERROR: Generation bumped up unexpectedly for %ws",
                     m_szNicGuid);
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    //
    // Analyze the proposed update to see if we can do this synchronously
    // or asynchronously..
    // We also do parameter validation here.
    //
    BOOL ConnectivityChange = FALSE;
    *pfDoAsync = FALSE;
    Status = mfn_AnalyzeUpdate(
                    pNewCfg,
                    &ConnectivityChange
                    );
    if (FAILED(Status))
    {
        //
        // Ouch, we've hit some error -- probably bad params.
        //
        TRACE_CRIT(L"Cannot perform update on Nic %ws", m_szNicGuid);
        goto end;
    }
    else if (Status == WBEM_S_FALSE)
    {
        //
        // We use this success code to indicate that this is a No-op.
        // That
        //
        TRACE_CRIT(L"Update is a NOOP on Nic %ws", m_szNicGuid);
        goto end;
    }
    //
    // We recommend Async if there is a connectivity change, including
    // changes in IP addresses or cluster operation modes (unicast/multicast).
    //
    *pfDoAsync = ConnectivityChange;

    //
    // Save the proposed new configuration...
    //
    //Status = update_cluster_config(&m_NewClusterConfig, pNewCfg);
    Status = m_NewClusterConfig.Update(pNewCfg);
    if (FAILED(Status))
    {
        //
        // This is probably a memory allocation error.
        //
        TRACE_CRIT("Couldn't copy new config for %ws", m_szNicGuid);
        mfn_Log(L"Memory allocation failure.\n");
        goto end;
    }


    //
    // Create volatile "PendingOperation" key
    //
    // TODO: we don't use this pending operations key currently.
    //
    if (0)
    {
        HKEY hPendingKey =  sfn_RegCreateKey(
                    m_szNicGuid,
                    NLBUPD_REG_PENDING, // szSubKey,
                    TRUE, // TRUE == fVolatile,
                    &fExists
                    );
        if (hPendingKey == NULL)
        {
            // Ugh, can't create the volatile key...
            //
            TRACE_CRIT("Couldn't create pending key for %ws", m_szNicGuid);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        else if (fExists)
        {
            // Ugh, this key already exists. Currently we'll just
            // move on.
            //
            TRACE_CRIT("WARNING -- volatile pending-op key exists for %ws", m_szNicGuid);
        }
        RegCloseKey(hPendingKey);
        hPendingKey = NULL;
    }

    //
    // Actually write the new generation count to the registry...
    //
    {
        LONG lRet;
        DWORD Generation = m_Generation;

        lRet = RegSetValueEx(
                hRootKey,           // handle to key to set value for
                L"Generation",    // name of the value to set
                0,              // reserved
                REG_DWORD,     // flag for value type
                (BYTE*) &Generation,// address of value data
                sizeof(Generation)  // size of value data
                );

        if (lRet !=ERROR_SUCCESS)
        {
            TRACE_CRIT("CRITICAL ERROR: Couldn't set new generation number %d for %ws",
                Generation, m_szNicGuid);
            Status = WBEM_E_CRITICAL_ERROR;
            mfn_Log(L"Critical internal error.\n");
            goto end;
        }
    }

    //
    // The new cluster state's generation field is not filled in on entry.
    // Set it to the new generation -- whose update is under progress.
    //
    m_NewClusterConfig.Generation = m_Generation;

    //
    // We set the completion status to pending.
    // It will be set to the final status when the update completes,
    // either asynchronously or synchronously.
    //
    m_CompletionStatus = WBEM_S_PENDING;

    Status =  sfn_RegSetCompletion(
                    m_szNicGuid,
                    m_Generation,
                    m_CompletionStatus
                    );
 
    if (FAILED(Status))
    {
        mfn_Log(L"Critical internal error.\n");
    }
    else
    {
        //
        // Let's clean up an old completion record here. This is our mechanism
        // for garbage collection.
        //
        if (m_Generation > NLB_MAX_GENERATION_GAP)
        {
            UINT OldGeneration = m_Generation - NLB_MAX_GENERATION_GAP;
            (VOID) sfn_RegDeleteCompletion(m_szNicGuid, OldGeneration);
        }

    }

end:

    if (fWeAcquiredLock && (FAILED(Status) || Status == WBEM_S_FALSE))
    {
        //
        // Oops -- we acquired the lock but either had a problem
        // or there is nothing to do. Clean up.
        //
        sfn_Lock();
        ASSERT(m_State == ACTIVE);

        m_State = IDLE;
        if (m_hCompletionKey != NULL)
        {
            if (ppLog != NULL)
            {
                sfn_ReadLog(m_hCompletionKey, m_Generation, ppLog);
            }
            RegCloseKey(m_hCompletionKey);
            m_hCompletionKey = NULL;
        }
        m_Generation = 0; // This field is unused when m_State != ACTIVE;
        SetEvent(m_hEvent);
        sfn_Unlock();
    }
    else if (Status == WBEM_E_ALREADY_EXISTS)
    {
        // Another update is pending.
        if (ppLog != NULL)
        {
            WCHAR *pLog = new WCHAR[128];
            if (pLog != NULL)
            {
            #if 0
                HKEY hCompKey;
    
                hKey =  sfn_RegOpenKey(
                            m_szNicGuid,
                            NLBUPD_REG_COMPLETIONS // szSubKey,
                            );
            
                if (hKey != NULL)
                {
                    sfn_ReadLog(hCompKey, PendingGeneration, ppLog);
                    RegCloseKey(hCompKey);
                }
                else
                {
                    m_hCompletionKey = hKey;
                }
            #endif // 0

                // TODO: localize...
                // TODO: get the origin of that update...
                wcscpy(pLog, L"Another update is ongoing.\n");
            }
            *ppLog = pLog;
        }
    }


    if (hRootKey != NULL)
    {
        RegCloseKey(hRootKey);
    }
    return  Status;
}


#if OBSOLETE
WBEMSTATUS
update_cluster_config(
    PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg,
    PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfgNew
    )
//
// This is basically a structure copy, but we need to
// re-allocate the IP addresses info array.
//
//
// If we fail, we leave the configuration untouched.
//
{
    WBEMSTATUS Status;
    UINT NumIpAddresses  = pCfgNew->NumIpAddresses;
    NLB_IP_ADDRESS_INFO *pIpAddressInfo = NULL;

    //
    // Free and realloc pCfg's ip info array if rquired.
    //
    if (pCfg->NumIpAddresses == NumIpAddresses)
    {
        //
        // we can re-use the existing one
        //
        pIpAddressInfo = pCfg->pIpAddressInfo;
    }
    else
    {
        //
        // Free the old one and allocate space for the new array if required.
        //

        if (NumIpAddresses != 0)
        {
            pIpAddressInfo = new NLB_IP_ADDRESS_INFO[NumIpAddresses];
            if (pIpAddressInfo == NULL)
            {
                TRACE_CRIT(L"Error allocating space for IP address info array");
                Status = WBEM_E_OUT_OF_MEMORY;
                goto end;
            }
        }

        if (pCfg->NumIpAddresses!=0)
        {
            delete pCfg->pIpAddressInfo;
            pCfg->pIpAddressInfo = NULL;
            pCfg->NumIpAddresses = 0;
        }

    }

    //
    // Copy over the new ip address info, if there is any.
    //
    if (NumIpAddresses)
    {
        CopyMemory(
            pIpAddressInfo,
            pCfgNew->pIpAddressInfo,
            NumIpAddresses*sizeof(*pIpAddressInfo)
            );
    }
   
    //
    // Do any other error checks here.
    //

    //
    // Struct copy the entire structure, then fix up the pointer to
    // ip address info array.
    //
    *pCfg = *pCfgNew; // struct copy
    pCfg->pIpAddressInfo = pIpAddressInfo;
    pCfg->NumIpAddresses = NumIpAddresses;

    Status = WBEM_NO_ERROR;

end:

    return Status;
}
#endif // OBSOLETE

//
// Uses various windows APIs to fill up the current extended cluster
// information for a specific nic (identified by *this)
//
//
WBEMSTATUS
NlbConfigurationUpdate::mfn_GetCurrentClusterConfiguration(
    OUT  PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
    )
//
// pCfg MUST be zero-initialized on entry.
//
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
    UINT NumIpAddresses = 0;
    BOOL fNlbBound = FALSE;
    WLBS_REG_PARAMS  NlbParams;    // The WLBS-specific configuration
    BOOL    fNlbParamsValid = FALSE;
    UINT Generation = 1;

    //
    // Verify that pCfg is indeed zero-initialized.
    // We are doing this because we want to make sure that the caller
    // doesn't pass in a perviously initialized pCfg which may have a non-null
    // ip address array.
    //
    {
        BYTE *pb = (BYTE*) pCfg;
        BYTE *pbEnd = (BYTE*) (pCfg+1);

        for (; pb < pbEnd; pb++)
        {
            if (*pb!=0)
            {
                TRACE_CRIT(L"uninitialized pCfg");
                ASSERT(!"uninitialized pCfg");
                Status = WBEM_E_INVALID_PARAMETER;
                goto end;
            }
        }

    }

    //
    // Get the ip address list.
    //
    Status = CfgUtilGetIpAddressesAndFriendlyName(
                m_szNicGuid,
                &NumIpAddresses,
                &pIpInfo,
                NULL
                );

    if (FAILED(Status))
    {
        TRACE_CRIT("Error 0x%08lx getting ip address list for %ws",
                (UINT) Status,  m_szNicGuid);
        mfn_Log(L"Error IP Address list on this NIC\n");
        pIpInfo = NULL;
        goto end;
    }

    //
    // TEST TEST TEST
    //
    if (0)
    {
        if (NumIpAddresses>1)
        {
            //
            // Let's munge the 2nd IP address
            //
            if (!_wcsicmp(pIpInfo[1].IpAddress, L"10.0.0.33"))
            {
                wcscpy(pIpInfo[1].IpAddress, L"10.0.0.44");
            }
            else
            {
                wcscpy(pIpInfo[1].IpAddress, L"10.0.0.33");
            }
        }
        MyBreak(L"Break just before calling CfgUtilSetStaticIpAddresses\n");
        Status =  CfgUtilSetStaticIpAddresses(
                        m_szNicGuid,
                        NumIpAddresses,
                        pIpInfo
                        );
    
    }

    //
    // Check if NLB is bound
    //
    Status =  CfgUtilCheckIfNlbBound(
                    m_szNicGuid,
                    &fNlbBound
                    );
    if (FAILED(Status))
    {
        TRACE_CRIT("Error 0x%08lx determining if NLB is bound to %ws",
                (UINT) Status,  m_szNicGuid);
        mfn_Log(L"Error determining if NLB is bound to this NIC\n");
        goto end;
    }

    if (fNlbBound)
    {
        //
        // Get the latest NLB configuration information for this NIC.
        //
        Status =  CfgUtilGetNlbConfig(
                    m_szNicGuid,
                    &NlbParams
                    );
        if (FAILED(Status))
        {
            //
            // We don't consider a catastrophic failure.
            //
            TRACE_CRIT("Error 0x%08lx reading NLB configuration for %ws",
                    (UINT) Status,  m_szNicGuid);
            mfn_Log(L"Error reading NLB configuration for this NIC\n");
            Status = WBEM_NO_ERROR;
            fNlbParamsValid = FALSE;
            ZeroMemory(&NlbParams, sizeof(NlbParams));
        }
        else
        {
            fNlbParamsValid = TRUE;
        }
    }

    //
    // Get the current generation
    //
    {
        BOOL fExists=FALSE;
        HKEY hKey =  sfn_RegOpenKey(
                        m_szNicGuid,
                        NULL       // NULL == root for this guid.,
                        );
        
        Generation = 1; // We assume generation is 1 on error reading gen.

        if (hKey!=NULL)
        {
            LONG lRet;
            DWORD dwType;
            DWORD dwData;
        
            dwData = sizeof(Generation);
            lRet =  RegQueryValueEx(
                      hKey,         // handle to key to query
                      L"Generation",  // address of name of value to query
                      NULL,         // reserved
                      &dwType,   // address of buffer for value type
                      (LPBYTE) &Generation, // address of data buffer
                      &dwData  // address of data buffer size
                      );
            if (    lRet != ERROR_SUCCESS
                ||  dwType != REG_DWORD
                ||  dwData != sizeof(Generation))
            {
                //
                // Couldn't read the generation. Let's assume it's 
                // a starting value of 1.
                //
                TRACE_CRIT("Error reading generation for %ws; assuming its 0",
                    m_szNicGuid);
                Generation = 1;
            }
        }
    }

    //
    // Success ... fill out pCfg
    //
    pCfg->fValidNlbCfg = fNlbParamsValid;
    pCfg->Generation = Generation;
    pCfg->fBound = fNlbBound;
    pCfg->NumIpAddresses = NumIpAddresses; 
    pCfg->pIpAddressInfo = pIpInfo;
    if (fNlbBound)
    {
        pCfg->NlbParams = NlbParams;    // struct copy
    }


    Status = WBEM_NO_ERROR;

end:

    if (FAILED(Status))
    {
        if (pIpInfo!=NULL)
        {
            delete pIpInfo;
        }
        pCfg->fValidNlbCfg = FALSE;
    }

    return Status;

}


//
// Does the update synchronously -- this is where the meat of the update
// logic exists. It can range from a NoOp, through changing the
// fields of a single port rule, through binding NLB, setting up cluster
// parameters and adding the relevant IP addresses in TCPIP.
//
VOID
NlbConfigurationUpdate::mfn_ReallyDoUpdate(
    VOID
    )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fResetIpList = FALSE; // Whether to re-do ip addresses in the end
    TRACE_INFO(L"->%!FUNC!(Nic=%ws)", m_szNicGuid);

/*
    PSEUDO CODE


    if (bound)
    {
        if (major-change, including unbind or mac-address change)
        {
            stop wlbs, set initial-state to false/suspended.
            remove all ip addresses except dedicated-ip
        }

        if (need-to-unbind)
        {
            <unbind>
        }
    }
    else // not bound
    {
        if (need to bind)
        {
            if (nlb config already exists in registry)
            {
                munge initial state to stopped,
                zap old cluster ip address.
            }
            <bind>
        }
    }

    if (need to bind)
    {
       <change cluster properties>
    }


    <add new ip list if needed>

    note: on major change, cluster is left in the stopped state,
          with initial-state=stopped

    this is so that a second round can be made just to start the hosts.
*/
    MyBreak(L"Break at start of ReallyDoUpdate.\n");

    mfn_Log(L"Starting update...\n");

    if (m_OldClusterConfig.fBound)
    {
        BOOL fTakeOutVips = FALSE;

        //
        // We are currently bound
        //
        
        if (!m_NewClusterConfig.fBound)
        {
            //
            // We need to unbind
            //
            fTakeOutVips = TRUE;
        }
        else
        {
            BOOL fConnectivityChange = FALSE;

            //
            // We were bound and need to remain bound.
            // Determine if this is a major change or not.
            //

            Status =  CfgUtilsAnalyzeNlbUpdate(
                        &m_OldClusterConfig.NlbParams,
                        &m_NewClusterConfig.NlbParams,
                        &fConnectivityChange
                        );
            if (FAILED(Status))
            {
                if (Status == WBEM_E_INVALID_PARAMETER)
                {
                    //
                    // We'd better exit.
                    //
                    mfn_Log(L"New parameters are incorrect!\n");
                    goto end;
                }
                else
                {
                    //
                    // Lets try to plow on...
                    //
                    //
                    // Log
                    //
                    TRACE_CRIT("Analyze update returned error 0x%08lx, trying to continue...", (UINT)Status);
                    fConnectivityChange = TRUE;
                }
            }

            fTakeOutVips = fConnectivityChange;
        }

        if (fTakeOutVips)
        {
            mfn_TakeOutVips();
            fResetIpList  = TRUE;
        }

        if (!m_NewClusterConfig.fBound)
        {
            // Unbind...
            mfn_Log(L"Going to unbind NLB...\n");
            Status =  CfgUtilChangeNlbBindState(m_szNicGuid, FALSE);
            if (FAILED(Status))
            {
                mfn_Log(L"Unbind operation failed.\n");
            }
            else
            {
                mfn_Log(L"Unbind operation succeeded.\n");
            }
            fResetIpList  = TRUE;
        }
    }
    else // We were previously unbound
    {
        
        if (m_NewClusterConfig.fBound)
        {
            //
            // We need to bind.
            //
            // TODO: mfn_ZapUnboundSettings();
            mfn_Log(L"Going to bind NLB...\n");
            Status =  CfgUtilChangeNlbBindState(m_szNicGuid, TRUE);
            if (FAILED(Status))
            {
                mfn_Log(L"Bind operation failed.\n");
            }
            else
            {
                WLBS_REG_PARAMS Params;
                mfn_Log(L"Bind operation succeeded.\n");

                //
                // Let wait until we can read our config again...
                //
                // TODO: use constants here, see if there is a better
                // way to do this. We retry because if the NIC is
                // disconnected, we Bind returns, but GetConfig fails --
                // because the driver is not really started yet -- we need
                // to investigate why that is happening!
                //
                UINT MaxTry = 20;
                WBEMSTATUS TmpStatus = WBEM_E_CRITICAL_ERROR;
                for (UINT u=0;u<MaxTry;u++)
                {
                    //
                    // TODO: we put this in here really to work around
                    // the real problem, which is that NLB is not read
                    // right after bind completes. We need to fix that.
                    //
                    if (MaxTry>1)
                    {
                        Sleep(1000);
                    }

                    TmpStatus =  CfgUtilGetNlbConfig(
                                    m_szNicGuid,
                                    &Params
                                    );

                    if (!FAILED(TmpStatus)) break;

                }
                if (FAILED(TmpStatus))
                {
                    Status = TmpStatus;
                    mfn_Log(L"Failed to read cluster configuration.\n");
                    TRACE_CRIT("CfgUtilGetNlbConfig failed, returning %d", TmpStatus);
                }
                else
                {
                    mfn_Log(L"Cluster configuration stabilized.\n");
                }
            }
            fResetIpList  = TRUE;
        }
    }

    if (FAILED(Status)) goto end;
    
    if (m_NewClusterConfig.fBound)
    {
        //
        // We should already be bound, so we change cluster properties
        // if reuired.
        //
        mfn_Log(L"Going to modify cluster configuration...\n");
        Status = CfgUtilSetNlbConfig(m_szNicGuid, &m_NewClusterConfig.NlbParams);
        if (FAILED(Status))
        {
            mfn_Log(L"Modification failed.\n");
        }
        else
        {
            mfn_Log(L"Modification succeeded.\n");
        }
    }

    if (FAILED(Status)) goto end;

    if (!fResetIpList)
    {
        //
        // Additionally check if there is a change in 
        // the before and after ip lists! We could get here for example of
        // we were previously unbound and remain unbound, but there is
        // a change in the set of IP addresses on the adapter.
        //

        INT NumOldAddresses = m_OldClusterConfig.NumIpAddresses;

        if ( m_NewClusterConfig.NumIpAddresses != NumOldAddresses)
        {
            fResetIpList = TRUE;
        }
        else
        {
            //
            // Check if there is a change in the list of ip addresses or
            // their order of appearance.
            //
            NLB_IP_ADDRESS_INFO *pOldIpInfo = m_OldClusterConfig.pIpAddressInfo;
            NLB_IP_ADDRESS_INFO *pNewIpInfo = m_NewClusterConfig.pIpAddressInfo;
            for (UINT u=0; u<NumOldAddresses; u++)
            {
                if (   _wcsicmp(pNewIpInfo[u].IpAddress, pOldIpInfo[u].IpAddress)
                    || _wcsicmp(pNewIpInfo[u].SubnetMask, pOldIpInfo[u].SubnetMask))
                {
                    fResetIpList = TRUE;
                    break;
                }
            }
        }
    }

    if (fResetIpList)
    {

        mfn_Log(L"Going to add IP addresses...\n");
        Status =  CfgUtilSetStaticIpAddresses(
                        m_szNicGuid,
                        m_NewClusterConfig.NumIpAddresses,
                        m_NewClusterConfig.pIpAddressInfo
                        );
        if (FAILED(Status))
        {
            mfn_Log(L"Attempt to Add IP addresses failed.\n");
        }
        else
        {
            mfn_Log(L"IP addresses added successfully.\n");
        }
    }
    
end:

    if (FAILED(Status))
    {
        mfn_Log(
            L"Update failed with status code 0x%08lx.\n",
            (UINT) Status
            );
    }
    else
    {
        mfn_Log(L"Update completed successfully.\n");
    }
    TRACE_INFO(L"<-%!FUNC!(Nic=%ws)", m_szNicGuid);
    m_CompletionStatus = Status;

}


VOID
NlbConfigurationUpdate::mfn_TakeOutVips(VOID)
{
    WBEMSTATUS Status;
    WLBS_REG_PARAMS *pParams =  &m_OldClusterConfig.NlbParams;

    //
    // Stop the cluster.
    //
    mfn_Log(L"Going to stop cluster...\n");
    Status = CfgUtilControlCluster(m_szNicGuid, IOCTL_CVY_CLUSTER_OFF); 
    if (FAILED(Status))
    {
        mfn_Log(L"Stop failed with error 0x%08lx.\n", (UINT) Status);
    }
    else
    {
        mfn_Log(L"Stop succeeded.\n");
    }

    //
    // Take out all vips except the dedicated IP address if there is one.
    //
    if (m_OldClusterConfig.fValidNlbCfg && pParams->ded_ip_addr[0]!=0)
    {
        NLB_IP_ADDRESS_INFO IpInfo;
        ZeroMemory(&IpInfo, sizeof(IpInfo));
        wcscpy(IpInfo.IpAddress, pParams->ded_ip_addr);
        wcscpy(IpInfo.SubnetMask, pParams->ded_net_mask);

        TRACE_INFO("Going to take out all addresses except dedicated address on %ws", m_szNicGuid);

        mfn_Log(L"Going to remove cluster IPs...\n");
        Status =  CfgUtilSetStaticIpAddresses(
                        m_szNicGuid,
                        1,
                        &IpInfo
                        );
    }
    else
    {
        TRACE_INFO("Going to take out ALL addresses on NIC %ws", m_szNicGuid);
        mfn_Log(L"Going to remove all static IP addresses...\n");
        Status =  CfgUtilSetStaticIpAddresses(
                        m_szNicGuid,
                        0,
                        NULL
                        );
    }

    if (FAILED(Status))
    {
        mfn_Log(L"Attempt to remove IP addresses faild.\n");
    }
    else
    {
        mfn_Log(L"Successfully removed IP addresses.\n");
    }
}


//
// Analyzes the nature of the update, mainly to decide whether or not
// we need to do the update asynchronously.
//
// Side effect: builds/modifies a list of IP addresses that need to be added on 
// the NIC. Also may munge some of the wlbsparm fields to bring them into
// canonical format.
//
WBEMSTATUS
NlbConfigurationUpdate::mfn_AnalyzeUpdate(
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewCfg,
    IN  BOOL *pConnectivityChange
    )
//
//    WBEM_S_FALSE -- update is a no-op.
//
{
    BOOL fConnectivityChange = FALSE;
    BOOL fSettingsChanged = FALSE;
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    UINT NumIpAddresses = 0;
    NLB_IP_ADDRESS_INFO *pNewIpInfo = NULL;
    UINT u;

    sfn_Lock();

    if (m_OldClusterConfig.fBound && !m_OldClusterConfig.fValidNlbCfg)
    {
        //
        // We're starting with a bound but invalid cluster state -- all bets are
        // off.
        //
        fConnectivityChange = TRUE;
        TRACE_CRIT("Analyze: Choosing Async because old state is invalid %ws",
                            m_szNicGuid);
    }
    else if (m_OldClusterConfig.fBound != pNewCfg->fBound)
    {
        //
        //  bound/unbound state is different -- we do async
        //
        fConnectivityChange = TRUE;

        if (pNewCfg->fBound)
        {
            TRACE_CRIT("Analyze: Request to bind NLB to %ws", m_szNicGuid);
        }
        else
        {
            TRACE_CRIT("Analyze: Request to unbind NLB from %ws", m_szNicGuid);
        }
    }
    else
    {
        if (pNewCfg->fBound)
        {
            TRACE_CRIT("Analyze: Request to change NLB configuration on %ws", m_szNicGuid);
        }
        else
        {
            TRACE_CRIT("Analyze: NLB not bound and to remain not bound on %ws", m_szNicGuid);
        }
    }

    if (pNewCfg->fBound)
    {
        WLBS_REG_PARAMS *pOldParams;

        if (m_OldClusterConfig.fBound)
        {
            pOldParams = &m_OldClusterConfig.NlbParams;
        }
        else
        {
            pOldParams = NULL;
        }

        //
        // We may have been bound before and we remain bound, let's check if we
        // still need to do async, and also vaidate pNewCfg wlbs params in the
        // process
        //
        WBEMSTATUS
        TmpStatus = CfgUtilsAnalyzeNlbUpdate(
                    pOldParams,
                    &pNewCfg->NlbParams,
                    &fConnectivityChange
                    );
    
        if (FAILED(TmpStatus))
        {
            TRACE_CRIT("Analyze: Error analyzing nlb params for %ws", m_szNicGuid);
            if (Status == WBEM_E_INVALID_PARAMETER)
            {
                mfn_Log(L"New parameters are incorrect!\n");
            }
            else
            {
                mfn_Log(L"Error analyzing new NLB configuration");
            }
            Status = TmpStatus;
            goto end;
        }

        //
        // NOTE: CfgUtilsAnalyzeNlbUpdate can return WBEM_S_FALSE if
        // the update is a no-op. We should be careful to preserve this
        // on success.
        //
        if (TmpStatus != WBEM_S_FALSE)
        {
            fSettingsChanged = TRUE;
        }

        //
        // Check the supplied list of IP addresses, to make sure that
        // includes the dedicated IP first and the cluster vip and the
        // per-port-rule vips.
        //

        NumIpAddresses = pNewCfg->NumIpAddresses;
        pNewIpInfo     = pNewCfg->pIpAddressInfo;

        if ((NumIpAddresses == 0) != (pNewIpInfo == NULL))
        {
            // Bogus input
            TRACE_CRIT("Analze: mismatch between NumIpAddresses and pIpInfo");
            mfn_Log(L"Invalid parameters\n");
            goto end;
        }

        ASSERT(Status == WBEM_E_INVALID_PARAMETER);

        if (NumIpAddresses == 0)
        {
            //
            // If NULL, we use defaults: dedicated-ip (if present) first,
            // then cluster-vip, then per-port-rule vips (specify the same
            // subnet as cluster-vip).
            //

            NLB_IP_ADDRESS_INFO TmpIpInfo[2]; // 1 for dedicated, 1 for cluster
            NLB_IP_ADDRESS_INFO *pInfo = TmpIpInfo;

            ZeroMemory(TmpIpInfo, sizeof(TmpIpInfo));

            if (pNewCfg->fAddDedicatedIp)
            {
                LPCWSTR sz = pNewCfg->NlbParams.ded_ip_addr;
                if (*sz == 0)
                {
                    TRACE_CRIT("fAddDedicatedIp specified, but ded_ip is not");
                    goto end;
                }
                wcscpy(pInfo->IpAddress, sz);
                wcscpy(pInfo->SubnetMask, pNewCfg->NlbParams.ded_net_mask);
                NumIpAddresses++;
                pInfo++;
            }
            
            wcscpy(pInfo->IpAddress, pNewCfg->NlbParams.cl_ip_addr);
            wcscpy(pInfo->SubnetMask, pNewCfg->NlbParams.cl_net_mask);
            NumIpAddresses++;

            //
            // TODO: Add IP addresses for per-port-rule VIPs here...
            //

            pNewIpInfo = new NLB_IP_ADDRESS_INFO[NumIpAddresses];

            if (pNewIpInfo == NULL)
            {
                TRACE_CRIT("ERROR:Could not allocate memory for pIpAddrInfo");
                mfn_Log(L"Memory Allocation Failure\n");
                Status = WBEM_E_OUT_OF_MEMORY;
                goto end;
            }
            for (u = 0; u<NumIpAddresses; u++)
            {
                pNewIpInfo[u] = TmpIpInfo[u]; // Struct copy.
            }
            pNewCfg->NumIpAddresses = NumIpAddresses;
            pNewCfg->pIpAddressInfo = pNewIpInfo;
        }

        ASSERT(NumIpAddresses != 0);
        ASSERT(Status == WBEM_E_INVALID_PARAMETER);

        //
        // Check that dedicated ip address, if present is first.
        //
        if (pNewCfg->fAddDedicatedIp)
        {
            if (_wcsicmp(pNewIpInfo[0].IpAddress, pNewCfg->NlbParams.ded_ip_addr))
            {
                TRACE_CRIT("ERROR: dedicated IP address is not first IP address");
                goto end;
            }

            if (_wcsicmp(pNewIpInfo[0].SubnetMask, pNewCfg->NlbParams.ded_net_mask))
            {
                TRACE_CRIT("ERROR: dedicated IP address is not first IP address");
                goto end;
            }

        }

        //
        // Check that cluster-vip is present
        //
        {
            for (u=0; u< NumIpAddresses; u++)
            {
                if (!_wcsicmp(pNewIpInfo[u].IpAddress, pNewCfg->NlbParams.cl_ip_addr))
                {
                    //
                    // Found it! Check that the subnet masks match.
                    //
                    if (_wcsicmp(pNewIpInfo[u].SubnetMask, pNewCfg->NlbParams.cl_net_mask))
                    {
                        TRACE_CRIT("Cluster subnet mask doesn't match that in addr list");
                        goto end;
                    }
                    break;
                }
            }
            if (u==NumIpAddresses)
            {
                TRACE_CRIT("Cluster ip address is not in the list of addresses!");
                goto end;
            }
        }

        //
        // Check that per-port-rule vips are present.
        // TODO
        {
        }

    }
    else
    {
        //
        // NLB is to be unbound. We don't do any checking on the supplied
        // list of IP addresses -- we assume caller knows best. Note that
        // if NULL
        // we switch to dhcp/autonet.
        //
    }

    ASSERT(Status == WBEM_E_INVALID_PARAMETER);
    //
    // If there's any change in the list of ipaddresses or subnets, including
    // a change in the order, we switch to async.
    //
    if (pNewCfg->NumIpAddresses != m_OldClusterConfig.NumIpAddresses)
    {
        TRACE_INFO("Analyze: detected change in list of IP addresses on %ws", m_szNicGuid);
        fConnectivityChange = TRUE;
    }
    else
    {
        //
        // Check if there is a change in the list of ip addresses or
        // their order of appearance.
        //
        NumIpAddresses = pNewCfg->NumIpAddresses;
        NLB_IP_ADDRESS_INFO *pOldIpInfo = m_OldClusterConfig.pIpAddressInfo;
        NLB_IP_ADDRESS_INFO *pNewIpInfo = pNewCfg->pIpAddressInfo;
        for (u=0; u<NumIpAddresses; u++)
        {
            if (   _wcsicmp(pNewIpInfo[u].IpAddress, pOldIpInfo[u].IpAddress)
                || _wcsicmp(pNewIpInfo[u].SubnetMask, pOldIpInfo[u].SubnetMask))
            {
                TRACE_INFO("Analyze: detected change in list of IP addresses on %ws", m_szNicGuid);
                fConnectivityChange = TRUE;
                break;
            }
        }
    }
    Status = WBEM_NO_ERROR; 


end:

    sfn_Unlock();


    if (!FAILED(Status))
    {
        *pConnectivityChange = fConnectivityChange;

        if (fConnectivityChange)
        {
            fSettingsChanged = TRUE;
        }

        if (fSettingsChanged)
        {
            Status = WBEM_NO_ERROR;
        }
        else
        {
            Status = WBEM_S_FALSE;
        }
    }
    
    return  Status;
}


VOID
NlbConfigurationUpdate::mfn_Log(
    UINT    Id,      // Resource ID of format,
    ...
    )
{
    // Not implemented.
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::Update(
        IN  const NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfgNew
        )
{
    WBEMSTATUS Status;
    UINT NumIpAddresses  = pCfgNew->NumIpAddresses;
    NLB_IP_ADDRESS_INFO *pIpAddressInfo = NULL;
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg = this;

    //
    // Free and realloc pCfg's ip info array if rquired.
    //
    if (pCfg->NumIpAddresses == NumIpAddresses)
    {
        //
        // we can re-use the existing one
        //
        pIpAddressInfo = pCfg->pIpAddressInfo;
    }
    else
    {
        //
        // Free the old one and allocate space for the new array if required.
        //

        if (NumIpAddresses != 0)
        {
            pIpAddressInfo = new NLB_IP_ADDRESS_INFO[NumIpAddresses];
            if (pIpAddressInfo == NULL)
            {
                TRACE_CRIT(L"Error allocating space for IP address info array");
                Status = WBEM_E_OUT_OF_MEMORY;
                goto end;
            }
        }

        if (pCfg->NumIpAddresses!=0)
        {
            delete pCfg->pIpAddressInfo;
            pCfg->pIpAddressInfo = NULL;
            pCfg->NumIpAddresses = 0;
        }

    }

    //
    // Copy over the new ip address info, if there is any.
    //
    if (NumIpAddresses)
    {
        CopyMemory(
            pIpAddressInfo,
            pCfgNew->pIpAddressInfo,
            NumIpAddresses*sizeof(*pIpAddressInfo)
            );
    }
   
    //
    // Do any other error checks here.
    //

    //
    // Struct copy the entire structure, then fix up the pointer to
    // ip address info array.
    //
    *pCfg = *pCfgNew; // struct copy
    pCfg->pIpAddressInfo = pIpAddressInfo;
    pCfg->NumIpAddresses = NumIpAddresses;

    Status = WBEM_NO_ERROR;

end:

    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetNetworkAddresses(
        IN  LPCWSTR *pszNetworkAddresses,
        IN  UINT    NumNetworkAddresses
        )
/*
    pszNetworkAddresses is an array of strings. These strings have the
    format "addr/subnet", eg: "10.0.0.1/255.0.0.0"
*/
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;

    if (NumNetworkAddresses != 0)
    {

        //
        // Allocate space for the new ip-address-info array
        //
        pIpInfo = new NLB_IP_ADDRESS_INFO[NumNetworkAddresses];
        if (pIpInfo == NULL)
        {
            TRACE_CRIT("%!FUNC!: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }
        ZeroMemory(pIpInfo, NumNetworkAddresses*sizeof(*pIpInfo));

        
        //
        // Convert IP addresses to our internal form.
        //
        for (UINT u=0;u<NumNetworkAddresses; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // from the "addr/subnet" format insert it into a
            // NLB_IP_ADDRESS_INFO structure.
            //
            // SAMPLE:  10.0.0.1/255.0.0.0
            //
            LPCWSTR szAddr = pszNetworkAddresses[u];

            Status =  address_string_to_ip_and_subnet(
                        szAddr,
                        pIpInfo[u].IpAddress,
                        pIpInfo[u].SubnetMask
                        );

            if (FAILED(Status))
            {
                //
                // This one of the ip/subnet parms is too large.
                //
                TRACE_CRIT("%!FUNC!:ip or subnet part too large: %ws", szAddr);
                goto end;
            }
        }
    }

    //
    // Replace the old ip-address-info with the new one
    //
    if (this->pIpAddressInfo != NULL)
    {
        delete this->pIpAddressInfo;
        this->pIpAddressInfo = NULL;
    }
    this->pIpAddressInfo = pIpInfo;
    pIpInfo = NULL;
    this->NumIpAddresses = NumNetworkAddresses;
    Status = WBEM_NO_ERROR;

end:

    if (pIpInfo != NULL)
    {
        delete pIpInfo;
    }

    return Status;
}


WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetNetworkAddresses(
        OUT LPWSTR **ppszNetworkAddresses,   // free using delete
        OUT UINT    *pNumNetworkAddresses
        )
/*
    ppszNetworkAddresses is filled out on successful return to
    an array of strings. These strings have the
    format "addr/subnet", eg: "10.0.0.1/255.0.0.0"
*/
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    UINT        AddrCount = this->NumIpAddresses;
    NLB_IP_ADDRESS_INFO *pIpInfo = this->pIpAddressInfo;
    LPWSTR      *pszNetworkAddresses = NULL;


    if (AddrCount != 0)
    {
        //
        // Convert IP addresses from our internal form into
        // format "addr/subnet", eg: "10.0.0.1/255.0.0.0"
        //
        //


        pszNetworkAddresses =  allocate_string_array(
                               AddrCount,
                                 WLBS_MAX_CL_IP_ADDR    // for IP address
                               + WLBS_MAX_CL_NET_MASK   // for subnet mask
                               + 1                      // for separating '/' 
                               );
        if (pszNetworkAddresses == NULL)
        {
            TRACE_CRIT("%!FUNC!: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }

        for (UINT u=0;u<AddrCount; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // insert them into a NLB_IP_ADDRESS_INFO
            // structure.
            //
            LPCWSTR pIpSrc  = pIpInfo[u].IpAddress;
            LPCWSTR pSubSrc = pIpInfo[u].SubnetMask;
            LPWSTR szDest   = pszNetworkAddresses[u];
            Status =  ip_and_subnet_to_address_string(pIpSrc, pSubSrc, szDest);
            if (FAILED(Status))
            {
                //
                // This would be an implementation error in get_multi_string_...
                //
                ASSERT(FALSE);
                Status = WBEM_E_CRITICAL_ERROR;
                goto end;
            }
        }
    }
    Status = WBEM_NO_ERROR;

end:

    if (FAILED(Status))
    {
        if (pszNetworkAddresses != NULL)
        {
            delete pszNetworkAddresses;
            pszNetworkAddresses = NULL;
        }
        AddrCount = 0;
    }
    
    *ppszNetworkAddresses = pszNetworkAddresses;
    *pNumNetworkAddresses = AddrCount;
    return Status;
}

        
WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetNetworkAddresPairs(
        IN  LPCWSTR *pszIpAddresses,
        IN  LPCWSTR *pszSubnetMasks,
        IN  UINT    NumNetworkAddresses
        )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    goto end;

end:
    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetNetworkAddressPairs(
        OUT LPWSTR **ppszIpAddresses,   // free using delete
        OUT LPWSTR **ppszIpSubnetMasks,   // free using delete
        OUT UINT    *pNumNetworkAddresses
        )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    goto end;

end:
    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetPortRules(
        OUT LPWSTR **ppszPortRules,
        OUT UINT    *pNumPortRules
        )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    goto end;

end:
    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetPortRules(
        IN LPCWSTR *pszPortRules,
        IN UINT    NumPortRules
        )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    goto end;

end:
    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetPortRulesSafeArray(
    IN SAFEARRAY   *pSA
    )
{
    return WBEM_E_CRITICAL_ERROR;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetPortRulesSafeArray(
    OUT SAFEARRAY   **ppSA
    )
{
    return WBEM_E_CRITICAL_ERROR;
}


WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetClusterNetworkAddress(
        OUT LPWSTR *pszAddress
        )
/*
    allocate and return the cluster-ip and mask in address/subnet form.
    Eg: "10.0.0.1/255.0.0.0"
*/
{
    WBEMSTATUS Status = WBEM_E_OUT_OF_MEMORY;
    LPWSTR szAddress = NULL;

    if (fValidNlbCfg)
    {
        UINT len =  wcslen(NlbParams.cl_ip_addr)+wcslen(NlbParams.cl_net_mask);
        len+= 1; // for '/'
        szAddress = new WCHAR[NLBUPD_MAX_NETWORK_ADDRESS_LENGTH+1];
        if (szAddress != NULL)
        {
            Status = ip_and_subnet_to_address_string(
                        NlbParams.cl_ip_addr,
                        NlbParams.cl_net_mask,
                        szAddress
                        );
            if (FAILED(Status))
            {
                delete szAddress;
                szAddress = NULL;
            }
        }
    }

    *pszAddress = szAddress;

    return Status;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetClusterNetworkAddress(
        IN LPCWSTR szAddress
        )
{
    if (szAddress == NULL) szAddress = L"";
    (VOID) address_string_to_ip_and_subnet(
                    szAddress,
                    NlbParams.cl_ip_addr,
                    NlbParams.cl_net_mask
                    );
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetClusterName(
        OUT LPWSTR *pszName
        )
/*
    allocate and return the cluster name
*/
{
    WBEMSTATUS Status = WBEM_E_OUT_OF_MEMORY;
    LPWSTR szName = NULL;

    if (fValidNlbCfg)
    {
        UINT len =  wcslen(NlbParams.domain_name);
        szName = new WCHAR[len+1]; // +1 for ending zero
        if (szName != NULL)
        {
            CopyMemory(szName, NlbParams.domain_name, (len+1)*sizeof(WCHAR));
            Status = WBEM_NO_ERROR;
        }
    }

    *pszName = szName;

    return Status;
}


VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetClusterName(
        IN LPCWSTR szName
        )
{
    if (szName == NULL) szName = L"";
    UINT len =  wcslen(szName);
    if (len>WLBS_MAX_DOMAIN_NAME)
    {
        TRACE_CRIT("%!FUNC!: Cluster name too large");
    }
    CopyMemory(NlbParams.domain_name, szName, (len+1)*sizeof(WCHAR));
}



WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetDedicatedNetworkAddress(
        OUT LPWSTR *pszAddress
        )
{
    WBEMSTATUS Status = WBEM_E_OUT_OF_MEMORY;
    LPWSTR szAddress = NULL;

    if (fValidNlbCfg)
    {
        UINT len = wcslen(NlbParams.ded_ip_addr)+wcslen(NlbParams.ded_net_mask);
        len+= 1; // for '/'
        szAddress = new WCHAR[NLBUPD_MAX_NETWORK_ADDRESS_LENGTH+1];
        if (szAddress != NULL)
        {
            Status = ip_and_subnet_to_address_string(
                        NlbParams.ded_ip_addr,
                        NlbParams.ded_net_mask,
                        szAddress
                        );
            if (FAILED(Status))
            {
                delete szAddress;
                szAddress = NULL;
            }
        }
    }

    *pszAddress = szAddress;

    return Status;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetDedicatedNetworkAddress(
        IN LPCWSTR szAddress
        )
{
    if (szAddress == NULL) {szAddress = L"";}
    (VOID) address_string_to_ip_and_subnet(
                    szAddress,
                    NlbParams.ded_ip_addr,
                    NlbParams.ded_net_mask
                    );
}

#if 0
typedef enum
{
    TRAFFIC_MODE_UNICAST,
    TRAFFIC_MODE_MULTICAST,
    TRAFFIC_MODE_IGMPMULTICAST

} TRAFFIC_MODE;
#endif // 0

NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetTrafficMode(
    VOID
    )
{
    return TRAFFIC_MODE_UNICAST;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetTrafficMode(
    TRAFFIC_MODE Mode
    )
{
}

UINT
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetHostPriority(
    VOID
    )
{
    return 0;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetHostPriority(
    UINT Priority
    )
{
}

#if 0
typedef enum
{
   START_MODE_STARTED,
    START_MODE_STOPPED

} START_MODE;
#endif // 0

NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetClusterModeOnStart(
    VOID
    )
{
    return START_MODE_STARTED;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetClusterModeOnStart(
    START_MODE
    )
{
}

BOOL
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetRemoteControlEnabled(
    VOID
    )
{
    return FALSE;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetRemoteControlEnabled(
    BOOL fEnabled
    )
{
}
WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetNetworkAddressesSafeArray(
    IN SAFEARRAY   *pSA
    )
{
    LPWSTR          *pStrings=NULL;
    UINT            NumStrings = 0;
    WBEMSTATUS      Status;
    Status =  CfgUtilStringsFromSafeArray(
                    pSA,
                    &pStrings,  // delete when done useing pStrings
                    &NumStrings
                    );
    if (FAILED(Status))
    {
        pStrings=NULL;
        goto end;
    }

    Status =  this->SetNetworkAddresses(
                    (LPCWSTR*)pStrings,
                    NumStrings
                    );

    if (pStrings != NULL)
    {
        delete pStrings;
    }

end:
    
    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetNetworkAddressesSafeArray(
    OUT SAFEARRAY   **ppSA
    )
{
    LPWSTR *pszNetworkAddresses = NULL;
    UINT NumNetworkAddresses = 0;
    SAFEARRAY   *pSA=NULL;
    WBEMSTATUS Status;

    Status = this->GetNetworkAddresses(
                    &pszNetworkAddresses,
                    &NumNetworkAddresses
                    );
    if (FAILED(Status))
    {
        pszNetworkAddresses = NULL;
        goto end;
    }

    Status = CfgUtilSafeArrayFromStrings(
                (LPCWSTR*) pszNetworkAddresses,
                NumNetworkAddresses, // can be zero
                &pSA
                );

    if (FAILED(Status))
    {
        pSA = NULL;
    }

end:

    *ppSA = pSA;
    if (pszNetworkAddresses != NULL)
    {
        delete pszNetworkAddresses;
        pszNetworkAddresses = NULL;
    }

    if (FAILED(Status))
    {
        TRACE_CRIT("%!FUNC!: couldn't extract network addresses from Cfg");
    }

    return Status;

}


LPWSTR *
allocate_string_array(
    UINT NumStrings,
    UINT MaxStringLen      //  excluding ending NULL
    )
/*
    Allocate a single chunk of memory using the new LPWSTR[] operator.
    The first NumStrings LPWSTR values of this operator contain an array
    of pointers to WCHAR strings. Each of these strings
    is of size (MaxStringLen+1) WCHARS.
    The rest of the memory contains the strings themselve.

    Return NULL if NumStrings==0 or on allocation failure.

    Each of the strings are initialized to be empty strings (first char is 0).
*/
{
    return  CfgUtilsAllocateStringArray(NumStrings, MaxStringLen);
}

WBEMSTATUS
address_string_to_ip_and_subnet(
    IN  LPCWSTR szAddress,
    OUT LPWSTR  szIp,    // max WLBS_MAX_CL_IP_ADDR including NULL
    OUT LPWSTR  szSubnet // max WLBS_MAX_CL_NET_MASK including NULL
    )
// Special case: if szAddress == "", we zero out both szIp and szSubnet;
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    if (*szAddress == 0) {szAddress = L"/";} // Special case mentioned above

    // from the "addr/subnet" format insert it into a
    // NLB_IP_ADDRESS_INFO structure.
    //
    // SAMPLE:  10.0.0.1/255.0.0.0
    //
    LPCWSTR pSlash = NULL;
    LPCWSTR pSrcSub = NULL;

    *szIp = 0;
    *szSubnet = 0;

    pSlash = wcsrchr(szAddress, (int) '/');
    if (pSlash == NULL)
    {
        TRACE_CRIT("%!FUNC!:missing subnet portion in %ws", szAddress);
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    pSrcSub = pSlash+1;
    UINT len = (UINT) (pSlash - szAddress);
    UINT len1 = wcslen(pSrcSub);
    if ( (len < WLBS_MAX_CL_IP_ADDR) && (len1 < WLBS_MAX_CL_NET_MASK))
    {
        CopyMemory(szIp, szAddress, len*sizeof(WCHAR));
        szIp[len] = 0;
        CopyMemory(szSubnet, pSrcSub, (len1+1)*sizeof(WCHAR));
    }
    else
    {
        //
        // One of the ip/subnet parms is too large.
        //
        TRACE_CRIT("%!FUNC!:ip or subnet part too large: %ws", szAddress);
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    return Status;
}


WBEMSTATUS
ip_and_subnet_to_address_string(
    IN  LPCWSTR szIp,
    IN  LPCWSTR szSubnet,
    OUT LPWSTR  szAddress// max WLBS_MAX_CL_IP_ADDR
                         // + 1(for slash) + WLBS_MAX_CL_NET_MASK + 1 (for NULL)
    )
{
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    UINT len =  wcslen(szIp)+wcslen(szSubnet) + 1; // +1 for separating '/'

    if (len >= NLBUPD_MAX_NETWORK_ADDRESS_LENGTH)
    {
        goto end;
    }
    else
    {
        wsprintf(
            szAddress,
            L"%ws/%ws", 
            szIp,
            szSubnet
            );
        Status = WBEM_NO_ERROR;
    }

end:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\nlbsnic.h ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   NlbsNic.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _NlbsNic_H_
#define _NlbsNic_H_

#define PROVIDER_NAME_NLBSNIC L"NlbsNic"

#include "MNLBUIData.h"
#include "MNLBProviderSetting.h"

#include <vector>
using namespace std;

// Property name externs -- defined in NlbsNic.cpp
//=================================================

extern const WCHAR* pAdapterGuid ;
extern const WCHAR* pDependent ;
extern const WCHAR* pFriendlyName ;
extern const WCHAR* pFullName ;


class CNlbsNic : public Provider 
{
    public:
    

        // Constructor/destructor
        //=======================

        CNlbsNic(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CNlbsNic();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        virtual HRESULT ExecMethod( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags = 0L );

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    private:
        // All data members for CNlbsNic should be included here.   
    void
    GetVectorFromSafeArray( SAFEARRAY*&  stringArray, 
                            vector<_bstr_t>& strings );
    void
    RetreiveAndSetClusterProperties(CInstance *pInParams, 
                                    MNLBProviderSetting &nlbs,
                                    ClusterProperties& cp,
                                    const wstring&    fullName );

    void 
    FillInPortRules( ClusterData*           p_clusterData,
                     const _bstr_t&         myMachine,
                     const vector<_bstr_t>& portRules );


private:
    enum
    {
        PROTOCOL_BIND_DELAY = 20000,
        PROTOCOL_BIND_WAIT_INCREMENT = 1000
    };

    static WCHAR* version;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\updatecfg.h ===
//***************************************************************************
//
//  UPDATECFG.H
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Defines class NlbConfigurationUpdate, used for 
//           async update of NLB properties associated with a particular NIC.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created
//
//***************************************************************************

typedef struct _NLB_IP_ADDRESS_INFO NLB_IP_ADDRESS_INFO;

//
// This structure contains all information associated with a particular NIC
// that is relevant to NLB. This includes the IP addresses bound the NIC,
// whether or not NLB is bound to the NIC, and if NLB is bound, all 
// the NLB-specific properties.
//
class NLB_EXTENDED_CLUSTER_CONFIGURATION
{
public:

    NLB_EXTENDED_CLUSTER_CONFIGURATION(VOID)  {ZeroMemory(this, sizeof(*this));}
    ~NLB_EXTENDED_CLUSTER_CONFIGURATION()
     {
        if (pIpAddressInfo != NULL)
        {
            delete (pIpAddressInfo);
        }
     };

    WBEMSTATUS
    Update(
        IN  const NLB_EXTENDED_CLUSTER_CONFIGURATION *pNewCfg
        );

    WBEMSTATUS
    SetNetworkAddresses(
        IN  LPCWSTR *pszNetworkAddresses,
        IN  UINT    NumNetworkAddresses
        );

    WBEMSTATUS
    SetNetworkAddressesSafeArray(
        IN SAFEARRAY   *pSA
        );

    WBEMSTATUS
    GetNetworkAddresses(
        OUT LPWSTR **ppszNetworkAddresses,   // free using delete
        OUT UINT    *pNumNetworkAddresses
        );

    WBEMSTATUS
    GetNetworkAddressesSafeArray(
        OUT SAFEARRAY   **ppSA
        );
        
    WBEMSTATUS
    SetNetworkAddresPairs(
        IN  LPCWSTR *pszIpAddresses,
        IN  LPCWSTR *pszSubnetMasks,
        IN  UINT    NumNetworkAddresses
        );

    WBEMSTATUS
    GetNetworkAddressPairs(
        OUT LPWSTR **ppszIpAddresses,   // free using delete
        OUT LPWSTR **ppszIpSubnetMasks,   // free using delete
        OUT UINT    *pNumNetworkAddresses
        );

    WBEMSTATUS
    GetPortRules(
        OUT LPWSTR **ppszPortRules,
        OUT UINT    *pNumPortRules
        );


    WBEMSTATUS
    SetPortRules(
        IN LPCWSTR *pszPortRules,
        IN UINT    NumPortRules
        );
    
    WBEMSTATUS
    GetPortRulesSafeArray(
        OUT SAFEARRAY   **ppSA
        );

    WBEMSTATUS
    SetPortRulesSafeArray(
        IN SAFEARRAY   *pSA
        );

    UINT GetGeneration(VOID)    {return Generation;}
    BOOL IsNlbBound(VOID)       {return fBound;}
    BOOL IsValidNlbConfig(VOID) {return fBound && fValidNlbCfg;}

    WBEMSTATUS
    GetClusterName(
            OUT LPWSTR *pszName
            );

    VOID
    SetClusterName(
            IN LPCWSTR szName // NULL ok
            );

    WBEMSTATUS
    GetClusterNetworkAddress(
            OUT LPWSTR *pszAddress
            );

    VOID
    SetClusterNetworkAddress(
            IN LPCWSTR szAddress // NULL ok
            );
    
    WBEMSTATUS
    GetDedicatedNetworkAddress(
            OUT LPWSTR *pszAddress
            );

    VOID
    SetDedicatedNetworkAddress(
            IN LPCWSTR szAddress // NULL ok
            );

    typedef enum
    {
        TRAFFIC_MODE_UNICAST,
        TRAFFIC_MODE_MULTICAST,
        TRAFFIC_MODE_IGMPMULTICAST

    } TRAFFIC_MODE;

    TRAFFIC_MODE
    GetTrafficMode(
        VOID
        );

    VOID
    SetTrafficMode(
        TRAFFIC_MODE Mode
        );

    UINT
    GetHostPriority(
        VOID
        );

    VOID
    SetHostPriority(
        UINT Priority
        );

    typedef enum
    {
        START_MODE_STARTED,
        START_MODE_STOPPED

    } START_MODE;

    START_MODE
    GetClusterModeOnStart(
        VOID
        );

    VOID
    SetClusterModeOnStart(
        START_MODE
        );

    BOOL
    GetRemoteControlEnabled(
        VOID
        );

    VOID
    SetRemoteControlEnabled(
        BOOL fEnabled
        );
    
    //
    // Following fields are public because this class started out as a
    // structure. TODO: wrap these with access methods.
    //

    BOOL            fValidNlbCfg;   // True iff all the information is valid.
    UINT            Generation;     // Generation ID of this Update.
    BOOL            fBound;         // Whether or not NLB is bound to this NIC.
    BOOL            fAddDedicatedIp; // Whether to add the dedicated ip address

    //
    // When GETTING configuration info, the following provide the full
    // list of statically configured IP addresses on the specified NIC.
    //
    // When SETTING configuration info, the following can either be zero
    // or non-zero. If zero, the set of IP addresses to be added will
    // be inferred from other fields (like cluster vip, per-port vips, etc.)
    // If non-zero, the exact set of VIPS specified will be used.
    //
    UINT            NumIpAddresses; // Number of IP addresses bound to the NIC
    NLB_IP_ADDRESS_INFO *pIpAddressInfo; // The actual IP addresses & masks


    WLBS_REG_PARAMS  NlbParams;    // The WLBS-specific configuration

};

typedef NLB_EXTENDED_CLUSTER_CONFIGURATION *PNLB_EXTENDED_CLUSTER_CONFIGURATION;

//
// The header of a completion header stored as a REG_BINARY value in
// the registry.
//
typedef struct {
    UINT Version;
    UINT Generation;        // Redundant, used for internal consistancy check
    UINT CompletionCode;
    UINT Reserved;
} NLB_COMPLETION_RECORD, *PNLB_COMPLETION_RECORD;

#define NLB_CURRENT_COMPLETION_RECORD_VERSION  0x3d7376e2

//
// Prefix of the global event name used to control update access to the specifed
// NIC.
// Name has format <prefix><NicGuid>
// Example event name: NLB_D6901862{EBE09517-07B4-4E88-AAF1-E06F5540608B}
//
// The value "D6901862" is a random number.
//
#define NLB_CONFIGURATION_EVENT_PREFIX L"NLB_D6901862"

//
// The maximum generation difference between the oldest valid completion
// record and the current one. Records older then the oldest valid record
// are subject to pruning.
//
#define NLB_MAX_GENERATION_GAP  10

class NlbConfigurationUpdate
{
public:
    
    //
    // Static initialization function -- call in process-attach
    //
    static
    VOID
    Initialize(
        VOID
        );

    //
    // Static deinitialization function -- call in process-detach
    //
    static
    VOID
    Deinitialize(
        VOID
        );
    
    //
    // Returns the current configuration on  the specific NIC.
    //
    static
    WBEMSTATUS
    GetConfiguration(
        IN  LPCWSTR szNicGuid,
        OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    );

    //
    // Called to initiate update to a new cluster state on that NIC. This
    // could include moving from a NLB-bound state to the NLB-unbound state.
    // *pGeneration is used to reference this particular update request.
    //
    static
    WBEMSTATUS
    DoUpdate(
        IN  LPCWSTR szNicGuid,
        IN  LPCWSTR szClientDescription,
        IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
        OUT UINT   *pGeneration,
        OUT WCHAR  **ppLog                   // free using delete operator.
    );
    /*++
        ppLog   -- will point to a NULL-terminated string which contains
        any messages to be displayed to the user. The string may contain
        embedded (WCHAR) '\n' characters to delimit lines. 

        NOTE: ppLog will be filled out properly EVEN ON FAILURE. If non-null
        it must be deleted by the caller.
    --*/


    //
    // Called to get the status of an update request, identified by
    // Generation.
    //
    static
    WBEMSTATUS
    GetUpdateStatus(
        IN  LPCWSTR szNicGuid,
        IN  UINT    Generation,
        IN  BOOL    fDelete,                // Delete record if it exists
        OUT WBEMSTATUS  *pCompletionStatus,
        OUT WCHAR  **ppLog                   // free using delete operator.
        );

    static
    DWORD
    WINAPI
    s_AsyncUpdateThreadProc(
        LPVOID lpParameter   // thread data
        );

    
private:


///////////////////////////////////////////////////////////////////////////////
//
//          S T A T I C         S T U F F
//
///////////////////////////////////////////////////////////////////////////////
    //
    // A single static lock serialzes all access.
    // Use sfn_Lock and sfn_Unlock.
    //
    static
    CRITICAL_SECTION s_Crit;

    static
    BOOL
    s_fDeinitializing;    // Set to true if we're in the process of
                        // de-initializing, in which case we don't want to
                        // handle any *new* update requests or even queries.

    //
    // Global list of current updates, one per NIC.
    //
    static
    LIST_ENTRY
    s_listCurrentUpdates;
    
    static
    VOID
    sfn_Lock(
        VOID
        )
    {
        EnterCriticalSection(&s_Crit);
    }

    static
    VOID
    sfn_Unlock(
        VOID
        )
    {
        LeaveCriticalSection(&s_Crit);
    }

    //
    // Looks up the current update for the specific NIC.
    // We don't bother to reference count because this object never
    // goes away once created -- it's one per unique NIC GUID for as long as
    // the DLL is loaded (may want to revisit this).
    //
    //
    static
    WBEMSTATUS
    sfn_LookupUpdate(
        IN  LPCWSTR szNic,
        IN  BOOL    fCreate, // Create if required
        OUT NlbConfigurationUpdate ** ppUpdate
        );

    //
    // Save the specified completion status to the registry.
    //
    static
    WBEMSTATUS
    sfn_RegSetCompletion(
        IN  LPCWSTR szNicGuid,
        IN  UINT    Generation,
        IN  WBEMSTATUS    CompletionStatus
        );

    //
    // Retrieve the specified completion status from the registry.
    //
    static
    WBEMSTATUS
    sfn_RegGetCompletion(
        IN  LPCWSTR szNicGuid,
        IN  UINT    Generation,
        OUT WBEMSTATUS  *pCompletionStatus,
        OUT WCHAR  **ppLog                   // free using delete operator.
        );

    //
    // Delete the specified completion status from the registry.
    //
    static
    VOID
    sfn_RegDeleteCompletion(
        IN  LPCWSTR szNicGuid,
        IN  UINT    Generation
        );

    //
    // Create the specified subkey key (for r/w access) for the specified
    // the specified NIC.
    //
    static
    HKEY
    sfn_RegCreateKey(
        IN  LPCWSTR szNicGuid,
        IN  LPCWSTR szSubKey,
        IN  BOOL    fVolatile,
        OUT BOOL   *fExists
        );

    //
    // Open the specified subkey key (for r/w access) for the specified
    // the specified NIC.
    //
    static
    HKEY
    sfn_RegOpenKey(
        IN  LPCWSTR szNicGuid,
        IN  LPCWSTR szSubKey
        );

    static
    VOID
    sfn_ReadLog(
        IN  HKEY hKeyLog,
        IN  UINT Generation,
        OUT LPWSTR *ppLog
        );


    static
    VOID
    sfn_WriteLog(
        IN  HKEY hKeyLog,
        IN  UINT Generation,
        IN  LPCWSTR pLog,
        IN  BOOL    fAppend
        );

///////////////////////////////////////////////////////////////////////////////
//
//          P E R   I N S T A N C E     S T U F F
//
///////////////////////////////////////////////////////////////////////////////

    //
    // Used in the global one-per-NIC  list of updates maintained in
    // s_listCurrentUpdates;
    //
    LIST_ENTRY m_linkUpdates;

    #define NLB_GUID_LEN 38
    #define NLB_GUID_STRING_SIZE  40 // 38 for the GUID plus trailing NULL + pad
    WCHAR   m_szNicGuid[NLB_GUID_STRING_SIZE]; // NIC's GUID in  text form

    LONG    m_RefCount;

#if OBSOLETE
    //
    // Used by the mfn_Log function;
    //
    struct {
        WCHAR *Start;         // Points to first WCHAR in log.
        WCHAR *End;           // Points to next place to write.
        UINT_PTR CharsLeft;   // WCHARS left in log.
    } m_Log;
#endif // OBSOLETE

    typedef enum
    {
        UNITIALIZED,       // IDLE -- no ongoing updates
        IDLE,               // IDLE -- no ongoing updates
        ACTIVE              // There is an ongoing update

    } MyState;

    MyState m_State;

    HANDLE  m_hEvent;       // Handle to machine-wide update event -- this
                            // event is claimed for as long as the current
                            // update is ongoing.

    //
    // The following fields are valid only when the state is ACTIVE
    //
    UINT m_Generation;      // Current generation count
    #define NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH 64
    WCHAR   m_szClientDescription[NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH+1];
    DWORD   m_AsyncThreadId; // Thread doing async config update operation.
    HANDLE  m_hAsyncThread;  // ID of above thread.
    HKEY    m_hCompletionKey; // Key to the registry where
                            // completions are stored

    //
    // A snapshot of the cluster configuration state at the start
    // of the update
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION m_OldClusterConfig;

    //
    // The requested final state
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION m_NewClusterConfig;


    //
    // Completion status of the current update.
    // Could be PENDING.
    //
    WBEMSTATUS m_CompletionStatus;


    //
    // END -- of fields that are valid only when the state is ACTIVE
    //


    //
    // Constructor and destructor --  note that these are private
    // In fact, the constructor is only called from sfn_LookupUpdate
    // and the destructor from mfn_Dereference.
    //
    NlbConfigurationUpdate(VOID);
    ~NlbConfigurationUpdate();

    //
    // Try to acquire the machine-wide
    // NLB configuration update event for this NIC, and create the
    // appropriate keys in the registry to track this update.
    // NOTE: ppLog will be filled out EVEN ON FAILURE -- it should always
    // be deleted by the caller (using the delete operator) if non-NULL.
    //
    WBEMSTATUS
    mfn_StartUpdate(
        IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
        IN  LPCWSTR                            szClientDescription,
        OUT BOOL                               *pfDoAsync,
        OUT WCHAR **                           ppLog
        );

    //
    // Increment ref count. Object stays alive as long as refcount is nonzero.
    //
    VOID
    mfn_Reference(
        VOID
        );

    //
    // Decrement ref count. Object is deleted when refcount goes to zero.
    //
    VOID
    mfn_Dereference(
        VOID
        );
    //
    // Release the machine-wide update event for this NIC, and delete any
    // temporary entries in the registry that were used for this update.
    // ppLog must be deleted by caller useing the delete operator.
    //
    VOID
    mfn_StopUpdate(
        OUT WCHAR **                           ppLog
        );

    //
    // Looks up the completion record identified by Generation, for
    // specific NIC (identified by *this).
    // 
    //
    BOOL
    mfn_LookupCompletion(
        IN  UINT Generation,
        OUT PNLB_COMPLETION_RECORD *pCompletionRecord
        );

    //
    // Uses various windows APIs to fill up the current extended cluster
    // information for a specific nic (identified by *this).
    // It fills out pNewCfg.
    // The pNewCfg->field is set to TRUE IFF there were
    // no errors trying to fill out the information.
    //
    //
    WBEMSTATUS
    mfn_GetCurrentClusterConfiguration(
        OUT  PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
        );

    //
    // Analyzes the nature of the update, mainly to decide whether or not
    // we need to do the update asynchronously.
    // This also performs parameter validation.
    //
    WBEMSTATUS
    mfn_AnalyzeUpdate(
        IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewCfg,
        IN  BOOL *pDoAsync
        );

    //
    // Does the update synchronously -- this is where the meat of the update
    // logic exists. It can range from a NoOp, through changing the
    // fields of a single port rule, through binding NLB, setting up cluster
    // parameters and adding the relevant IP addresses in TCPIP.
    //
    VOID
    mfn_ReallyDoUpdate(
        VOID
        );

    VOID
    mfn_Log(
        UINT    Id,      // Resource ID of format,
        ...
        );

    //
    // Following is a shortcut where you directly specify a format string.
    //
    VOID
    mfn_Log(
        LPCWSTR szFormat,
        ...
        );

    VOID
    mfn_LogRawText(
        LPCWSTR szText
        );

#if OBSOLETE

    //
    // Extracts a copy of the current log.
    // The default delete operator should be used to delete *pLog, if NON-NULL.
    //
    VOID
    mfn_ExtractLog(
        OUT LPWSTR *ppLog
        );

#endif // OBSOLETE

    
    //
    // Stop the current cluster and take out its vips.
    //
    VOID
    mfn_TakeOutVips(
        VOID
        );
};

VOID
test_port_rule_string(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\nlbhost.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost.h

Abstract:

    Header file for class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created

--*/

// #include <vector>
// using namespace std;



typedef
VOID
(*PFN_LOGGER)(
    PVOID           Context,
    const   WCHAR * Text
    );

class NLBHost
{

public:

#if 1
	class NicInformation
    {
    public:
        _bstr_t fullNicName;
        _bstr_t adapterGuid;
        _bstr_t friendlyName;

        BOOL   isDHCPEnabled;

        // vector<_bstr_t> ipsOnNic;
        // vector<_bstr_t> subnetMasks;

        BOOL    isBoundToNLB;
    };


	class HostInformation
    {
    public:
        _bstr_t MachineName;
         NicInformation nicInformation[1];
         UINT NumNics;
    };


#endif // 0

    NLBHost(
        const WCHAR *   pBindString,
        const WCHAR *   pFriendlyName,
        PFN_LOGGER      pfnLogger,
        PVOID           pLoggerContext
        );

    ~NLBHost();

    
    UINT
    Ping(
        VOID
        );
    
#if 1
    WBEMSTATUS
    GetHostInformation(
    	OUT HostInformation **ppHostInfo 
	    );
#endif // 0


//
// Configuration operations:
//

    WBEMSTATUS
    GetClusterConfiguration(
        IN const    WCHAR *                         pNicGuid,
        OUT         PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
        );

    WBEMSTATUS
    SetClusterConfiguration(
        IN const    WCHAR *                         pNicGuid,
        IN const    PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg,
        IN          UINT                            GenerationId,
        OUT         UINT *                          pRequestId
        );

    WBEMSTATUS
    GetAsyncResult(
        IN          UINT                            RequestId,
        OUT         UINT *                          pGenerationId,
        OUT         UINT *                          ResultCode,
        OUT         _bstr_t *                       pResultText
        );

//
// Management operations:
//
//
//    GetClusterState(NIC-Guid, &ClusterState)
//    SetClusterState(NIC-Guid, ClusterState)
//
private:

    static WSADATA      s_WsaData;
    static LONG         s_InstanceCount;
    static BOOL         s_FatalError;
    static BOOL         s_ComInitialized;
    static BOOL         s_WsaInitialized;
    static IWbemStatusCodeTextPtr s_sp_werr; //Smart pointer

    _bstr_t             m_BindString;
    _bstr_t             m_FriendlyName;
    PFN_LOGGER          m_pfnLogger;
    PVOID       	    m_pLoggerContext;
    BOOL				m_fProcessing;	// Already processing some method.
    IWbemLocatorPtr     m_sp_pwl; // Smart pointer
 	IWbemServicesPtr    m_sp_pws; // Smart pointer
    CRITICAL_SECTION    m_Lock;

    WBEMSTATUS
    mfn_connect(
        VOID
        );

    VOID
    mfn_disconnect(
        VOID
        );


    VOID
    mfn_lock(
        VOID
        );

    VOID
    mfn_unlock(
        VOID
        );
    
    VOID
    mfn_Log(
        LPCWSTR pwszMessage,
        ...
        );


    VOID
    mfn_LogHr(
        LPCWSTR pwszMessage,
        HRESULT hr
        );

    UINT
    mfn_ping(
        VOID
        );


    VOID
    mfn_InitializeStaticFields(
            VOID
            );

    VOID
    mfn_DeinitializeStaticFields(
            VOID
            );

};


WBEMSTATUS
NlbHostGetConfiguration(
 	IN  LPCWSTR              szMachine, // NULL or empty for local
    IN  LPCWSTR              szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    );

WBEMSTATUS
NlbHostDoUpdate(
 	IN  LPCWSTR              szMachine, // NULL or empty for local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
    OUT UINT                 *pGeneration,
    OUT WCHAR                **ppLog    // free using delete operator.
);

WBEMSTATUS
NlbHostGetUpdateStatus(
 	IN  LPCWSTR              szMachine, // NULL or empty for local
    IN  LPCWSTR              szNicGuid,
    IN  UINT                 Generation,
    OUT WBEMSTATUS           *pCompletionStatus,
    OUT WCHAR                **ppLog    // free using delete operator.
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\nlbhost.cpp ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost.cpp

Abstract:

    Implementation of class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created

--*/

#include "tprov.h"
#include "nlbhost.tmh"


//
// Static members of class NLBHost.
//
WSADATA      NLBHost::s_WsaData;
LONG         NLBHost::s_InstanceCount;
BOOL         NLBHost::s_FatalError;
BOOL         NLBHost::s_WsaInitialized;
BOOL         NLBHost::s_ComInitialized;
IWbemStatusCodeTextPtr NLBHost::s_sp_werr; // Smart pointer


WBEMSTATUS
extract_GetClusterConfiguration_output_params(
    IN  IWbemClassObjectPtr                 spWbemOutput,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
    );

WBEMSTATUS
setup_GetClusterConfiguration_input_params(
    IN LPCWSTR                              szNic,
    IN IWbemClassObjectPtr                  spWbemInput
    );

WBEMSTATUS
setup_UpdateClusterConfiguration_input_params(
    IN LPCWSTR                              szNic,
    IN PNLB_EXTENDED_CLUSTER_CONFIGURATION  pCfg,
    IN IWbemClassObjectPtr                  spWbemInput
    );


VOID
NLBHost::mfn_LogHr(
        LPCWSTR pwszMessage,
        HRESULT hr
        )
{

    if (s_sp_werr)
    {
        BSTR  bstr1 = 0;
        BSTR  bstr2 = 0;

        SCODE sc;
            
        sc = s_sp_werr->GetFacilityCodeText( hr, 
                                           0,
                                           0,
                                           &bstr1 );
        if( sc != S_OK )
        {
            bstr2 = L"Unknown Error";
        }
    
    
        sc = s_sp_werr->GetErrorCodeText( hr, 
                                        0,
                                        0,
                                        &bstr2 );
        if( sc != S_OK )
        {
            bstr2 = L"Unknown Code";
        }
    
        mfn_Log(
            L"%s %s: %s(hr=0x%08lx)",
            pwszMessage,
            (LPCWSTR) bstr1,
            (LPCWSTR) bstr2,
            hr
            );
    
        SysFreeString( bstr1 );
        SysFreeString( bstr2 );
    }
    else
    {
        mfn_Log(
            L"%s (hr=0x%08lx)",
            pwszMessage,
            hr
            );
    }
}


VOID
NLBHost::mfn_Log(
        LPCWSTR pwszMessage,
        ...
        )
{
   WCHAR wszBuffer[1024];
   wszBuffer[0] = 0;

   va_list arglist;
   va_start (arglist, pwszMessage);
   int cch = vswprintf(wszBuffer, pwszMessage, arglist);
   va_end (arglist);

   m_pfnLogger(m_pLoggerContext, wszBuffer);
}



NLBHost::NLBHost(
    const WCHAR *   pBindString,
    const WCHAR *   pFriendlyName,
    PFN_LOGGER      pfnLogger,
    PVOID           pLoggerContext
    )
/*++

Routine Description:

    Constructor for NLBHost.

    The constructor does not initiate any connections to the host. Connections
    to the host are initiated on demand (based on method calls).

Arguments:

    pBindString     - String used to connect to the remote host.
    pFriendlyName   - Descriptive name of the host. Used for logging.
    pfnLogger       - Function called to log textual information.
    pLoggerContext  - Caller's context, passed in calls to pfnLogger
    
--*/
{
    m_BindString        = pBindString;      // implicit copy
    m_FriendlyName      = pFriendlyName;    // implicit copy
    m_pfnLogger         = pfnLogger;
    m_pLoggerContext    = pLoggerContext;

    if (InterlockedIncrement(&s_InstanceCount) == 1)
    {
        mfn_InitializeStaticFields();

    }

    InitializeCriticalSection(&m_Lock);

    mfn_Log(
        L"NLBHost(BindString=%s, FriendlyName=%s) constructor succeeded.",
        (LPCWSTR) pBindString,
        (LPCWSTR) pFriendlyName
        );
}

NLBHost::~NLBHost()
/*++

Routine Description:

    Destructor for NLBHost.

--*/
{
    mfn_Log(L"NLBHost distructor(%s).", (LPCWSTR) m_FriendlyName);

    ASSERT(m_fProcessing == FALSE);	// Shouldn't be doing any processing when
                                    // calling the distructor.

    if (InterlockedDecrement(&s_InstanceCount)==0)
    {
        mfn_DeinitializeStaticFields();
    }
    
    DeleteCriticalSection(&m_Lock);

}

    
UINT
NLBHost::Ping(
    VOID
    )
{
    if (s_FatalError) return ERROR_INTERNAL_ERROR;

    return mfn_ping();
}
    
WBEMSTATUS
NLBHost::GetHostInformation(
    OUT HostInformation **ppHostInfo 
    )
{
    WBEMSTATUS Status;
    HostInformation *pHostInfo = NULL;
    BOOL fConnected = FALSE;
    NicInformation *pNicInfo=NULL;

    if (s_FatalError)
    {
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    pHostInfo = new HostInformation;
    if (pHostInfo == NULL) 
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    //
    // Connect to the host.
    //
    Status = mfn_connect();

    if (FAILED(Status)) goto end;
    
    fConnected = TRUE;

#if 0
    //
    // Now find the instance and execute the method to get the host info.
    //
    mfn_find_host_instance();
    ... stuff parameters ...
    mfn_execute_method();
#endif // 

    pHostInfo->MachineName = L"ACME-Machine-Name";

    pNicInfo = pHostInfo->nicInformation;

    pNicInfo->fullNicName = L"ACME Full Nic Name";
    pNicInfo->adapterGuid =  L"{AD4DA14D-CAAE-42DD-97E3-5355E55247C2}";
    pNicInfo->friendlyName = L"ACME Friendly Name";

    pHostInfo->NumNics = 1;


end:

    if (fConnected)
    {
        mfn_disconnect();
    }

    if (FAILED(Status))
    {
       if (pHostInfo != NULL) 
       {
            delete pHostInfo;
       }
       pHostInfo = NULL;
    }

    *ppHostInfo = pHostInfo;

    return Status;
}


//
// Configuration operations:
//

WBEMSTATUS
NLBHost::GetClusterConfiguration(
    IN const    WCHAR*                          pNicGuid,
    OUT         PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemClassObjectPtr spWbemInputInstance = NULL; // smart pointer
    BOOL                fConnected = FALSE;
    LPWSTR              pRelPath = NULL;
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.

    ZeroMemory(pCfg, sizeof(*pCfg));

    if (s_FatalError)
    {
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    //
    // Connect to the host.
    //
    Status = mfn_connect();

    if (FAILED(Status)) goto end;
    
    fConnected = TRUE;


    mfn_Log(
        L"NLBHost -- getting cluster configuration on NIC (%s).",
        pNicGuid
        );

    //
    // Get input instance and relpath...
    //
    Status =  CfgUtilGetWmiInputInstanceAndRelPath(
	                m_sp_pws,
                    L"NlbsNic",                 // szClassName
                    L"AdapterGuid",                // szParameterName
                    pNicGuid,                   // szPropertyValue
                    L"GetClusterConfiguration",    // szMethodName,
                    spWbemInputInstance,        // smart pointer
                    &pRelPath                   // free using delete 
                    );


    if (FAILED(Status))
    {
        mfn_Log(
            L"NLBHost -- error 0x%08lx trying to find NIC instance\n",
            (UINT) Status
            );
        goto end;
    }

    //
    // NOTE: spWbemInputInstance could be NULL -- in fact it is
    // NULL because GetClusterConfiguration doesn't require input args
    //

    //
    // Run the Method!
    //
    {
        HRESULT hr;

        printf("Going to call GetClusterConfiguration\n");

        hr = m_sp_pws->ExecMethod(
                     _bstr_t(pRelPath),
                     L"GetClusterConfiguration",
                     0, 
                     NULL, 
                     spWbemInputInstance,
                     &spWbemOutput, 
                     NULL
                     );                          
        printf("GetClusterConfiguration returns\n");
    
        if( FAILED( hr) )
        {
            printf("IWbemServices::ExecMethod failure 0x%08lx\n", (UINT) hr);
            goto end;
        }
        else
        {
            printf("GetClusterConfiguration method returns SUCCESS!\n");
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod GetClusterConfiguration had no output\n");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract all the out parameters!
    //
    {
        DWORD dwRet=0;
        Status =  CfgUtilGetWmiDWORDParam(
                        spWbemOutput,
                        L"ReturnValue",
                        &dwRet
                        );

        if (FAILED(Status))
        {
            printf("IWbemClassObject::Get failure\n");
            // 
            // Let's ignore for now...
            //
            dwRet = 0;
        }
        Status = extract_GetClusterConfiguration_output_params(
                        spWbemOutput,
                        pCfg
                        );

    }


end:

    if (fConnected)
    {
        mfn_disconnect();
    }

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    spWbemInputInstance = NULL; // smart pointer.

    return Status;

}




WBEMSTATUS
NLBHost::SetClusterConfiguration(
    IN const    WCHAR *                         pNicGuid,
    IN const    PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg,
    IN          UINT                            GenerationId,
    OUT         UINT *                          pRequestId
    )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;

    if (s_FatalError)
    {
        goto end;
    }

    mfn_Log(
        L"NLBHost -- setting cluster configuration on NIC (%s).",
        pNicGuid
        );
    *pRequestId = 123;

    Status = WBEM_S_PENDING;

end:

    return Status;
}



WBEMSTATUS
NLBHost::GetAsyncResult(
    IN          UINT                            RequestId,
    OUT         UINT *                          pGenerationId,
    OUT         UINT *                          pResultCode,
    OUT         _bstr_t *                       pResultText
    )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    if (s_FatalError)
    {
        goto end;
    }

    mfn_Log(
        L"NLBHost -- checking result of Async operation %d\n",
        RequestId
        );
    *pGenerationId = 1;
    *pResultCode = 1;
    *pResultText = L"Result";
    Status = WBEM_NO_ERROR;

end:

    return Status;
}


WBEMSTATUS
NLBHost::mfn_connect(
    VOID
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
	HRESULT hr;
    _bstr_t                serverPath;

    hr = CoCreateInstance(CLSID_WbemLocator, 0, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IWbemLocator, 
                          (LPVOID *) &m_sp_pwl);
 
    if (FAILED(hr))
    {
        mfn_LogHr(L"CoCreateInstance  IWebmLocator failed", hr);
        m_sp_pwl = NULL;
        goto end;
    }

    //

    serverPath =  _bstr_t(L"\\\\") + m_BindString + L"\\root\\microsoftnlb";


    hr = m_sp_pwl->ConnectServer(
            serverPath,
            NULL, // strUser,
            NULL, // strPassword,
            NULL,
            0,
            NULL,
            NULL,
            &m_sp_pws
         );
    // these have been found to be special cases where retrying may help.
    if( ( hr == 0x800706bf ) || ( hr == 0x80070767 ) || ( hr == 0x80070005 )  )
    {
    	int delay = 250; // milliseconds
        int timesToRetry = 20;
    	
        for( int i = 0; i < timesToRetry; ++i )
        {
        	Sleep(delay);
            mfn_Log(L"connectserver recoverable failure, retrying.");
            hr = m_sp_pwl->ConnectServer(
                serverPath,
                NULL, // strUser,
                NULL, // strPassword,
                NULL,
                0,
                NULL,
                NULL,
                &m_sp_pws );
            if( !FAILED( hr) )
            {
                break;
            }
        }
    }
    else if ( hr == 0x80041064 )
    {
        // trying to connect to local machine.  Cannot use credentials.
        mfn_Log(L"Connecting to self.  Retrying without using credentials");
        hr = m_sp_pwl->ConnectServer(
            serverPath,
            NULL,
            NULL,
            0,                                  
            NULL,
            0,
            0,       
            &m_sp_pws 
            );
    }


    if (FAILED(hr))
    {
        mfn_LogHr(L"Error connecting to server", hr);
        m_sp_pws = NULL;
        goto end;
    }
    else
    {
        mfn_Log(L"Successfully connected to server %s", serverPath);
    }

    
    // Set the proxy so that impersonation of the client occurs.
    //
    hr = CoSetProxyBlanket(
            m_sp_pws,
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_DEFAULT,      // RPC_C_AUTHZ_NAME,
            COLE_DEFAULT_PRINCIPAL,   // NULL,
            RPC_C_AUTHN_LEVEL_DEFAULT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            COLE_DEFAULT_AUTHINFO, // NULL,
            EOAC_DEFAULT // EOAC_NONE
            );

    if (FAILED(hr))
    {
        mfn_LogHr(L"Error setting proxy blanket", hr);
        goto end;
    }
    else
    {
        mfn_Log(L"Successfully set up proxy settings.");
    }

    Status = WBEM_NO_ERROR;


end:
	if (FAILED(Status))
	{
	    if (m_sp_pws != NULL)
	    {
	        // Smart pointer.
	        m_sp_pws = NULL;
	    }

	    if (m_sp_pwl != NULL)
	    {
	        // Smart pointer.
	        m_sp_pwl = NULL;
	    }
    }

    return Status;
}


VOID
NLBHost::mfn_disconnect(
    VOID
    )
{
    mfn_Log(L"Disconnecting from host %s", m_BindString);
    if (m_sp_pws != NULL)
    {
       // Smart pointer
        m_sp_pws = NULL;
    }

    if (m_sp_pwl != NULL)
    {
        // Smart pointer
        m_sp_pwl = NULL;
    }
}


VOID
NLBHost::mfn_InitializeStaticFields(
    VOID
    )
{
    s_FatalError = TRUE;

    // Initialize com.
    //
    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    if ( FAILED(hr) )
    {
        mfn_Log(L"Failed to initialize COM library (hr=0x%08lx)", hr);
        goto end;
    }
    s_ComInitialized = TRUE;


    //
    // Initialize Winsock
    //
    int err = WSAStartup(MAKEWORD(2,2), &s_WsaData);
    mfn_Log(L"Initializing Winsock");
    err = WSAStartup(MAKEWORD(2,2), &s_WsaData);
    if (err) {
        mfn_Log(L"PING_WSASTARTUP_FAILED %d", GetLastError());
        goto end;
    }
    s_WsaInitialized = TRUE;
    s_FatalError = FALSE;


    //
    // Get some WMI interface pointers...
    //
    SCODE sc = CoCreateInstance(
                CLSID_WbemStatusCodeText,
                0,
                CLSCTX_INPROC_SERVER,
                IID_IWbemStatusCodeText,
                (LPVOID *) &s_sp_werr
                );
    if( sc != S_OK )
    {
        s_sp_werr = NULL;
        mfn_Log(L"CoCreateInstance IWbemStatusCodeText failure\n");
    }

end:

    if (s_FatalError)
    {
        mfn_DeinitializeStaticFields();
    }

}

VOID
NLBHost::mfn_DeinitializeStaticFields(
    VOID
    )
{
        if (s_sp_werr != NULL)
        {
            s_sp_werr = NULL; // Smart pointer
        }

        if (s_WsaInitialized)
        {
            mfn_Log(L"Deinitializing Winsock");
            WSACleanup();
            s_WsaInitialized = FALSE;
        }

        if (s_ComInitialized)
        {
            mfn_Log(L"Deinitializing COM");
            CoUninitialize();
            s_ComInitialized = FALSE;
        }
}
       

#if 0
WBEMSTATUS
extract_extended_config_from_wmi(
    IN  IWbemClassObjectPtr                 &spWbemOutput,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
    )
{


    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
    UINT NumIpAddresses = 0;
    BOOL fNlbBound = FALSE;
    WLBS_REG_PARAMS  NlbParams;    // The WLBS-specific configuration
    BOOL    fNlbParamsValid = FALSE;
    UINT Generation = 1;

    //
    // Verify that pCfg is indeed zero-initialized.
    // We are doing this because we want to make sure that the caller
    // doesn't pass in a perviously initialized pCfg which may have a non-null
    // ip address array.
    //
    {
        BYTE *pb = (BYTE*) pCfg;
        BYTE *pbEnd = (BYTE*) (pCfg+1);

        for (; pb < pbEnd; pb++)
        {
            if (*pb!=0)
            {
                printf(L"uninitialized pCfg\n");
                ASSERT(!"uninitialized pCfg");
                Status = WBEM_E_INVALID_PARAMETER;
                goto end;
            }
        }

    }

    //
    // Get the ip address list.
    //
    Status = CfgUtilGetStaticIpAddresses(
                m_szNicGuid,
                &NumIpAddresses,
                &pIpInfo
                );

    if (FAILED(Status))
    {
        printf("Error 0x%08lx getting ip address list for %ws\n",
                (UINT) Status,  m_szNicGuid);
        mfn_Log(L"Error IP Address list on this NIC\n");
        pIpInfo = NULL;
        goto end;
    }

    //
    // TEST TEST TEST
    //
    if (0)
    {
        if (NumIpAddresses>1)
        {
            //
            // Let's munge the 2nd IP address
            //
            if (!_wcsicmp(pIpInfo[1].IpAddress, L"10.0.0.33"))
            {
                wcscpy(pIpInfo[1].IpAddress, L"10.0.0.44");
            }
            else
            {
                wcscpy(pIpInfo[1].IpAddress, L"10.0.0.33");
            }
        }
        MyBreak(L"Break just before calling CfgUtilSetStaticIpAddresses\n");
        Status =  CfgUtilSetStaticIpAddresses(
                        m_szNicGuid,
                        NumIpAddresses,
                        pIpInfo
                        );
    
    }

    //
    // Check if NLB is bound
    //
    Status =  CfgUtilCheckIfNlbBound(
                    m_szNicGuid,
                    &fNlbBound
                    );
    if (FAILED(Status))
    {
        printf("Error 0x%08lx determining if NLB is bound to %ws\n",
                (UINT) Status,  m_szNicGuid);
        mfn_Log(L"Error determining if NLB is bound to this NIC\n");
        goto end;
    }

    if (fNlbBound)
    {
        //
        // Get the latest NLB configuration information for this NIC.
        //
        Status =  CfgUtilGetNlbConfig(
                    m_szNicGuid,
                    &NlbParams
                    );
        if (FAILED(Status))
        {
            //
            // We don't consider a catastrophic failure.
            //
            printf("Error 0x%08lx reading NLB configuration for %ws\n",
                    (UINT) Status,  m_szNicGuid);
            mfn_Log(L"Error reading NLB configuration for this NIC\n");
            Status = WBEM_NO_ERROR;
            fNlbParamsValid = FALSE;
            ZeroMemory(&NlbParams, sizeof(NlbParams));
        }
        else
        {
            fNlbParamsValid = TRUE;
        }
    }

    //
    // Get the current generation
    //
    {
        BOOL fExists=FALSE;
        HKEY hKey =  sfn_RegOpenKey(
                        m_szNicGuid,
                        NULL       // NULL == root for this guid.,
                        );
        
        Generation = 1; // We assume generation is 1 on error reading gen.

        if (hKey!=NULL)
        {
            LONG lRet;
            DWORD dwType;
            DWORD dwData;
        
            dwData = sizeof(Generation);
            lRet =  RegQueryValueEx(
                      hKey,         // handle to key to query
                      L"Generation",  // address of name of value to query
                      NULL,         // reserved
                      &dwType,   // address of buffer for value type
                      (LPBYTE) &Generation, // address of data buffer
                      &dwData  // address of data buffer size
                      );
            if (    lRet != ERROR_SUCCESS
                ||  dwType != REG_DWORD
                ||  dwData != sizeof(Generation))
            {
                //
                // Couldn't read the generation. Let's assume it's 
                // a starting value of 1.
                //
                printf("Error reading generation for %ws; assuming its 0\n",
                    m_szNicGuid);
                Generation = 1;
            }
        }
    }

    //
    // Success ... fill out pCfg
    //
    pCfg->fValidNlbCfg = fNlbParamsValid;
    pCfg->Generation = Generation;
    pCfg->fBound = fNlbBound;
    pCfg->NumIpAddresses = NumIpAddresses; 
    pCfg->pIpAddressInfo = pIpInfo;
    if (fNlbBound)
    {
        pCfg->NlbParams = NlbParams;    // struct copy
    }


    Status = WBEM_NO_ERROR;

end:

    if (FAILED(Status))
    {
        if (pIpInfo!=NULL)
        {
            delete pIpInfo;
        }
        pCfg->fValidNlbCfg = FALSE;
    }

    return Status;
    return WBEM_NO_ERROR;
}
#endif // 0


WBEMSTATUS
NlbHostGetConfiguration(
 	IN  LPCWSTR              szMachine, // empty string for local
    IN  LPCWSTR              szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
 	IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput  = NULL; // smart pointer
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.
    LPWSTR              pRelPath = NULL;

    //
    // Get interface to the NLB namespace on the specified machine
    //
    {
        #define _MaxLen 256
        WCHAR NetworkResource[_MaxLen];

        if (*szMachine == 0)
        {
            szMachine = L".";
        }
        _snwprintf(NetworkResource, (_MaxLen-1), L"\\\\%ws\\root\\microsoftnlb",
                 szMachine);
        NetworkResource[_MaxLen-1]=0;

        wprintf(L"Connecting to NLB on %ws ...\n", szMachine);

        Status = CfgUtilConnectToServer(
                    NetworkResource,
                    NULL, // szUser
                    NULL, // szPassword
                    NULL, // szAuthority (domain)
                    &spWbemService
                    );
        if (FAILED(Status))
        {
            wprintf(L"ERROR: COULD NOT CONNECT TO NLB ON %ws\n", szMachine);
            goto end;
        }
        wprintf(L"Successfully connected to NLB on %ws...\n", szMachine);
    }

    //
    // Get wmi input instance to "GetClusterConfiguration" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
	                spWbemService,
                    L"NlbsNic",             // szClassName
                    L"AdapterGuid",         // szParameterName
                    szNicGuid,              // szPropertyValue
                    L"GetClusterConfiguration",    // szMethodName,
                    spWbemInput,            // smart pointer
                    &pRelPath               // free using delete 
                    );


        if (FAILED(Status))
        {
            wprintf(
               L"ERROR 0x%08lx trying to get instance of GetClusterConfiguration\n",
                (UINT) Status
                );
            goto end;
        }
    }

    //
    // Setup params for the "GetClusterConfiguration" method
    // NOTE: spWbemInput could be NULL.
    //
    Status = setup_GetClusterConfiguration_input_params(
                szNicGuid,
                spWbemInput
                );

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Call the "GetClusterConfiguration" method
    //
    {
        HRESULT hr;

        wprintf(L"Going get GetClusterConfiguration...\n");

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"GetClusterConfiguration",
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            wprintf(L"GetClusterConfiguration returns with failure 0x%8lx\n",
                        (UINT) hr);
            goto end;
        }
        else
        {
            wprintf(L"GetClusterConfiguration returns successfully\n");
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod GetClusterConfiguration had no output");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract params from the "GetClusterConfiguration" method
    //
    Status = extract_GetClusterConfiguration_output_params(
                spWbemOutput,
                pCurrentCfg
                );

end:

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

 	spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    return Status;
}



WBEMSTATUS
NlbHostDoUpdate(
 	IN  LPCWSTR              szMachine, // NULL or empty for local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
    OUT UINT                 *pGeneration,
    OUT WCHAR                **ppLog    // free using delete operator.
)
{

    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
 	IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput  = NULL; // smart pointer
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.
    LPWSTR              pRelPath = NULL;

    *pGeneration = 0;
    *ppLog = NULL;

    //
    // Get interface to the NLB namespace on the specified machine
    //
    {
        #define _MaxLen 256
        WCHAR NetworkResource[_MaxLen];

        if (*szMachine == 0)
        {
            szMachine = L".";
        }
        _snwprintf(NetworkResource, (_MaxLen-1), L"\\\\%ws\\root\\microsoftnlb",
                 szMachine);
        NetworkResource[_MaxLen-1]=0;

        wprintf(L"Connecting to NLB on %ws ...\n", szMachine);

        Status = CfgUtilConnectToServer(
                    NetworkResource,
                    NULL, // szUser
                    NULL, // szPassword
                    NULL, // szAuthority (domain)
                    &spWbemService
                    );
        if (FAILED(Status))
        {
            wprintf(L"ERROR: COULD NOT CONNECT TO NLB ON %ws\n", szMachine);
            goto end;
        }
        wprintf(L"Successfully connected to NLB on %ws...\n", szMachine);
    }

    //
    // Get wmi input instance to "UpdateClusterConfiguration" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
	                spWbemService,
                    L"NlbsNic",             // szClassName
                    L"AdapterGuid",         // szParameterName
                    szNicGuid,              // szPropertyValue
                    L"UpdateClusterConfiguration",    // szMethodName,
                    spWbemInput,            // smart pointer
                    &pRelPath               // free using delete 
                    );


        if (FAILED(Status))
        {
            wprintf(
               L"ERROR 0x%08lx trying to get instance of UpdateConfiguration\n",
                (UINT) Status
                );
            goto end;
        }
    }

    //
    // Setup params for the "UpdateClusterConfiguration" method
    // NOTE: spWbemInput could be NULL.
    //
    Status = setup_UpdateClusterConfiguration_input_params(
                szNicGuid,
                pNewState,
                spWbemInput
                );

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Call the "UpdateClusterConfiguration" method
    //
    {
        HRESULT hr;

        wprintf(L"Going get UpdateClusterConfiguration...\n");

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"UpdateClusterConfiguration",
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            wprintf(L"UpdateConfiguration returns with failure 0x%8lx\n",
                        (UINT) hr);
            goto end;
        }
        else
        {
            wprintf(L"UpdateConfiguration returns successfully\n");
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod UpdateConfiguration had no output");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract params from the "UpdateClusterConfiguration" method
    //
    {
        DWORD dwReturnValue = 0;

        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"ReturnValue",      // <--------------------------------
                    &dwReturnValue
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read ReturnValue failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
    
    
        LPWSTR szLog = NULL;

        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"Log", // <-------------------------
                        &szLog
                        );
    
        if (FAILED(Status))
        {
            szLog = NULL;
        }
        *ppLog = szLog;

        DWORD dwGeneration = 0;
        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"NewGeneration",      // <--------------------------------
                    &dwGeneration
                    );
        if (FAILED(Status))
        {
            //
            // Generation should always be specified for pending operations.
            // TODO: for successful operations also?
            //
            if ((WBEMSTATUS)dwReturnValue == WBEM_S_PENDING)
            {
                wprintf(L"Attempt to read NewGeneration for pending update failed. Error=0x%08lx\n",
                     (UINT) Status);
                Status = WBEM_E_CRITICAL_ERROR;
                goto end;
            }
            dwGeneration = 0; // we don't care if it's not set for non-pending
        }
        *pGeneration = (UINT) dwGeneration;
        

        //
        // Make the return status reflect the true status of the update 
        // operation.
        //
        Status = (WBEMSTATUS) dwReturnValue;
    }

end:

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

 	spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    return Status;
}


WBEMSTATUS
NlbHostGetUpdateStatus(
 	IN  LPCWSTR              szMachine, // NULL or empty for local
    IN  LPCWSTR              szNicGuid,
    IN  UINT                 Generation,
    OUT WBEMSTATUS           *pCompletionStatus,
    OUT WCHAR                **ppLog    // free using delete operator.
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
 	IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput  = NULL; // smart pointer
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.
    LPWSTR              pRelPath = NULL;

    *ppLog = NULL;
    *pCompletionStatus = WBEM_E_CRITICAL_ERROR;

    //
    // Get interface to the NLB namespace on the specified machine
    //
    {
        #define _MaxLen 256
        WCHAR NetworkResource[_MaxLen];

        if (*szMachine == 0)
        {
            szMachine = L".";
        }
        _snwprintf(NetworkResource, (_MaxLen-1), L"\\\\%ws\\root\\microsoftnlb",
                 szMachine);
        NetworkResource[_MaxLen-1]=0;

        // wprintf(L"Connecting to NLB on %ws ...\n", szMachine);

        Status = CfgUtilConnectToServer(
                    NetworkResource,
                    NULL, // szUser
                    NULL, // szPassword
                    NULL, // szAuthority (domain)
                    &spWbemService
                    );
        if (FAILED(Status))
        {
            wprintf(L"ERROR: COULD NOT CONNECT TO NLB ON %ws\n", szMachine);
            goto end;
        }
        // wprintf(L"Successfully connected to NLB on %ws...\n", szMachine);
    }

    //
    // Get wmi input instance to  "QueryConfigurationUpdateStatus" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
	                spWbemService,
                    L"NlbsNic",             // szClassName
                    L"AdapterGuid",         // szParameterName
                    szNicGuid,              // szPropertyValue
                    L"QueryConfigurationUpdateStatus", // szMethodName,
                    spWbemInput,            // smart pointer
                    &pRelPath               // free using delete 
                    );


        if (FAILED(Status))
        {
            wprintf(
                L"ERROR 0x%08lx trying to find instance to QueryUpdateStatus\n",
                (UINT) Status
                );
            goto end;
        }
    }

    //
    // Setup params for the  "QueryConfigurationUpdateStatus" method
    // NOTE: spWbemInput could be NULL.
    //
    {
        Status =  CfgUtilSetWmiStringParam(
                        spWbemInput,
                        L"AdapterGuid",
                        szNicGuid
                        );
        if (FAILED(Status))
        {
            wprintf(
                L"Couldn't set Adapter GUID parameter to QueryUpdateStatus\n");
            goto end;
        }

        Status =  CfgUtilSetWmiDWORDParam(
                        spWbemInput,
                        L"Generation",
                        Generation
                        );
        if (FAILED(Status))
        {
            wprintf(
                L"Couldn't set Generation parameter to QueryUpdateStatus\n");
            goto end;
        }
    }

    //
    // Call the  "QueryConfigurationUpdateStatus" method
    //
    {
        HRESULT hr;

        // wprintf(L"Going call QueryConfigurationUpdateStatus...\n");

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"QueryConfigurationUpdateStatus", // szMethodName,
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            wprintf(L"QueryConfigurationUpdateStatus returns with failure 0x%8lx\n",
                        (UINT) hr);
            goto end;
        }
        else
        {
            // wprintf(L"QueryConfigurationUpdateStatus returns successfully\n");
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod QueryConfigurationUpdateStatus had no output");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract output params --- return code and log.
    //
    {
        DWORD dwReturnValue = 0;

        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"ReturnValue",      // <--------------------------------
                    &dwReturnValue
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read ReturnValue failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
    
        *pCompletionStatus =  (WBEMSTATUS) dwReturnValue;
    
        
        LPWSTR szLog = NULL;

        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"Log", // <-------------------------
                        &szLog
                        );
    
        if (FAILED(Status))
        {
            szLog = NULL;
        }
        
        *ppLog = szLog;

        ASSERT(Status != WBEM_S_PENDING);
    }

end:

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

 	spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    return Status;
}


WBEMSTATUS
setup_GetClusterConfiguration_input_params(
    IN LPCWSTR                              szNic,
    IN IWbemClassObjectPtr                  spWbemInput
    )
/*
    Setup the input wmi parameters for the GetClusterConfiguration method
*/
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    Status =  CfgUtilSetWmiStringParam(
                    spWbemInput,
                    L"AdapterGuid",
                    szNic
                    );
    return Status;
}


WBEMSTATUS
extract_GetClusterConfiguration_output_params(
    IN  IWbemClassObjectPtr                 spWbemOutput,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    DWORD       Generation          = 0;
    BOOL        NlbBound            = FALSE;
    LPWSTR      *pszNetworkAddresses= NULL;
    UINT        NumNetworkAddresses = 0;
    BOOL        ValidNlbCfg         = FALSE;
    LPWSTR      szClusterName       = NULL;
    LPWSTR      szClusterNetworkAddress = NULL;
    LPWSTR      szTrafficMode       = NULL;
    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE
                TrafficMode
                 =  NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
    LPWSTR      *pszPortRules       = NULL;
    UINT        NumPortRules        = 0;
    DWORD       HostPriority        = 0;
    LPWSTR      szDedicatedNetworkAddress = NULL;
    NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE
                ClusterModeOnStart
                  =  NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED;
    BOOL        RemoteControlEnabled= FALSE;

#if 0
    [OUT] uint32  Generation,
    [OUT] String  NetworkAddresses[], // "10.1.1.1/255.0.0.0"
    [OUT] Boolean NLBBound,
    [OUT] String  ClusterNetworkAddress, // "10.1.1.1/255.0.0.0"
    [OUT] String  ClusterName,
    [OUT] String  TrafficMode, // UNICAST MULTICAST IGMPMULTICAST
    [OUT] String  PortRules[],
    [OUT] uint32  HostPriority,
    [OUT] String  DedicatedNetworkAddress, // "10.1.1.1/255.0.0.0"
    [OUT] Boolean ClusterModeOnStart,
    [OUT] Boolean RemoteControlEnabled
#endif // 0

    Status = CfgUtilGetWmiDWORDParam(
                spWbemOutput,
                L"Generation",      // <--------------------------------
                &Generation
                );
    if (FAILED(Status))
    {
        wprintf(L"Attempt to read Generation failed. Error=0x%08lx\n",
             (UINT) Status);
        goto end;
    }

    Status = CfgUtilGetWmiStringArrayParam(
                spWbemOutput,
                L"NetworkAddresses", // <--------------------------------
                &pszNetworkAddresses,
                &NumNetworkAddresses
                );
    if (FAILED(Status))
    {
        wprintf(L"Attempt to read Network addresses failed. Error=0x%08lx\n",
             (UINT) Status);
        goto end;
    }

    Status = CfgUtilGetWmiBoolParam(
                    spWbemOutput,
                    L"NLBBound",    // <--------------------------------
                    &NlbBound
                    );

    if (FAILED(Status))
    {
        wprintf(L"Attempt to read NLBBound failed. Error=0x%08lx\n",
             (UINT) Status);
        goto end;
    }


    do // while false -- just to allow us to break out
    {
        ValidNlbCfg = FALSE;

        if (!NlbBound)
        {
            wprintf(L"NLB is UNBOUND\n");
            break;
        }
    
        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"ClusterNetworkAddress", // <-------------------------
                        &szClusterNetworkAddress
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read Cluster IP failed. Error=0x%08lx\n",
                    (UINT) Status);
            break;
        }
    
        wprintf(L"NLB is BOUND, and the cluster address is %ws\n",
                szClusterNetworkAddress);
    
    
        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"ClusterName", // <-------------------------
                        &szClusterName
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read Cluster Name failed. Error=0x%08lx\n",
                    (UINT) Status);
            break;
        }
    
        //
        // Traffic mode
        //
        {
            Status = CfgUtilGetWmiStringParam(
                            spWbemOutput,
                            L"TrafficMode", // <-------------------------
                            &szTrafficMode
                            );
        
            if (FAILED(Status))
            {
                wprintf(L"Attempt to read Traffic Mode failed. Error=0x%08lx\n",
                        (UINT) Status);
                break;
            }
    
            if (!_wcsicmp(szTrafficMode, L"UNICAST"))
            {
                TrafficMode =
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
            }
            else if (!_wcsicmp(szTrafficMode, L"MULTICAST"))
            {
                TrafficMode =
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST;
            }
            else if (!_wcsicmp(szTrafficMode, L"IGMPMULTICAST"))
            {
                TrafficMode =
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST;
            }
        }
    
        // TODO: [OUT] String  PortRules[],
    
        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"HostPriority",      // <--------------------------------
                    &HostPriority
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read HostPriority failed. Error=0x%08lx\n",
                 (UINT) Status);
            break;
        }
    
        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"DedicatedNetworkAddress", // <-------------------------
                        &szDedicatedNetworkAddress
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read dedicated IP failed. Error=0x%08lx\n",
                    (UINT) Status);
            break;
        }
        
        //
        // StartMode
        //
        {
            BOOL StartMode = FALSE;
            Status = CfgUtilGetWmiBoolParam(
                            spWbemOutput,
                            L"ClusterModeOnStart",   // <-------------------------
                            &StartMode
                            );
        
            if (FAILED(Status))
            {
                wprintf(L"Attempt to read ClusterModeOnStart failed. Error=0x%08lx\n",
                     (UINT) Status);
                break;
            }
            if (StartMode)
            {
                ClusterModeOnStart = 
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STARTED;
            }
            else
            {
                ClusterModeOnStart = 
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED;
            }
        }
    
        Status = CfgUtilGetWmiBoolParam(
                        spWbemOutput,
                        L"RemoteControlEnabled",   // <----------------------------
                        &RemoteControlEnabled
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read RemoteControlEnabled failed. Error=0x%08lx\n",
                 (UINT) Status);
            break;
        }

        ValidNlbCfg = TRUE;

    } while (FALSE) ;
    
    //
    // Now let's set all the the parameters in Cfg
    //
    {
        pCfg->Generation = Generation;
        pCfg->fBound    = NlbBound;
        Status = pCfg->SetNetworkAddresses(
                    (LPCWSTR*) pszNetworkAddresses,
                    NumNetworkAddresses
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to set NetworkAddresses failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
        pCfg->fValidNlbCfg  = ValidNlbCfg;
        pCfg->SetClusterName(szClusterName);
        pCfg->SetClusterNetworkAddress(szClusterNetworkAddress);
        pCfg->SetTrafficMode(TrafficMode);
        Status = pCfg->SetPortRules((LPCWSTR*)pszPortRules, NumPortRules);
        Status = WBEM_NO_ERROR; // TODO -- change once port rules is done

        if (FAILED(Status))
        {
            wprintf(L"Attempt to set PortRules failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
        pCfg->SetHostPriority(HostPriority);
        pCfg->SetDedicatedNetworkAddress(szDedicatedNetworkAddress);
        pCfg->SetClusterModeOnStart(ClusterModeOnStart);
        pCfg->SetRemoteControlEnabled(RemoteControlEnabled);
    }
    
end:

    delete szClusterNetworkAddress;
    delete pszNetworkAddresses;
    delete szClusterName;
    delete szTrafficMode;
    delete pszPortRules;
    delete szDedicatedNetworkAddress;

    return Status;
}

WBEMSTATUS
setup_UpdateClusterConfiguration_input_params(
    IN LPCWSTR                              szNic,
    IN PNLB_EXTENDED_CLUSTER_CONFIGURATION  pCfg,
    IN IWbemClassObjectPtr                  spWbemInput
    )
/*
    Setup the input wmi parameters for the UpdateGetClusterConfiguration method

            [IN] String  ClientDescription,
            [IN] String  AdapterGuid,
            [IN] uint32  Generation,
            [IN] Boolean PartialUpdate,
            [IN] String  NetworkAddresses[], // "10.1.1.1/255.255.255.255"
            [IN] Boolean NLBBound,
            [IN] String  ClusterNetworkAddress, // "10.1.1.1/255.0.0.0"
            [IN] String  ClusterName,
            [IN] String  TrafficMode, // UNICAST MULTICAST IGMPMULTICAST
            [IN] String  PortRules[],
            [IN] uint32  HostPriority,
            [IN] String  DedicatedNetworkAddress, // "10.1.1.1/255.0.0.0"
            [IN] Boolean ClusterModeOnStart,
            [IN] Boolean RemoteControlEnabled,
            [IN] String  Password,
*/
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    Status =  CfgUtilSetWmiStringParam(
                    spWbemInput,
                    L"AdapterGuid",
                    szNic
                    );
    //
    // Fill in NetworkAddresses[]
    //
    {
        LPWSTR *pszAddresses = NULL;
        UINT NumAddresses = 0;
        Status = pCfg->GetNetworkAddresses(
                        &pszAddresses,
                        &NumAddresses
                        );
        if (FAILED(Status))
        {
            printf(
              "Setup update params: couldn't extract network addresses from Cfg"
                " for NIC %ws\n",
                szNic
                );
            goto end;
        }

        //
        // Note it's ok to not specify  any IP addresses -- in which case
        // the default ip addresses will be set up.
        //
        if (pszAddresses != NULL)
        {
            Status = CfgUtilSetWmiStringArrayParam(
                        spWbemInput,
                        L"NetworkAddresses",
                        (LPCWSTR *)pszAddresses,
                        NumAddresses
                        );
            delete pszAddresses;
            pszAddresses = NULL;
        }
    }

    if (!pCfg->IsNlbBound())
    {
        //
        // NLB is not bound
        //

        Status = CfgUtilSetWmiBoolParam(spWbemInput, L"NLBBound", FALSE);
        goto end;
    }
    else if (!pCfg->IsValidNlbConfig())
    {
        printf(
            "Setup update params: NLB-specific configuration on NIC %ws is invalid\n",
            szNic
            );
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    Status = CfgUtilSetWmiBoolParam(spWbemInput, L"NLBBound", TRUE);
    if (FAILED(Status))
    {
        printf("Error trying to set NLBBound parameter\n");
    }

    
    //
    // NLB is bound
    //

    CfgUtilSetWmiBoolParam(spWbemInput, L"NLBBound", TRUE);


    //
    // Cluster name
    //
    {
        LPWSTR szName = NULL;
        Status = pCfg->GetClusterName(&szName);

        if (FAILED(Status))
        {
            printf(
              "Setup update params: Could not extract cluster name for NIC %ws\n",
                szNic
                );
            goto end;
        }
        CfgUtilSetWmiStringParam(spWbemInput, L"ClusterName", szName);
        delete (szName);
        szName = NULL;
    }
    
    //
    // Cluster and dedicated network addresses
    //
    {
        LPWSTR szAddress = NULL;
        Status = pCfg->GetClusterNetworkAddress(&szAddress);

        if (FAILED(Status))
        {
            printf(
           "Setup update params: Could not extract cluster address for NIC %ws\n",
                szNic
                );
            goto end;
        }
        CfgUtilSetWmiStringParam(
            spWbemInput,
            L"ClusterNetworkAddress",
            szAddress
            );
        delete (szAddress);
        szAddress = NULL;

        Status = pCfg->GetDedicatedNetworkAddress(&szAddress);

        if (FAILED(Status))
        {
            printf(
         "Setup update params: Could not extract dedicated address for NIC %ws\n",
                szNic
                );
            goto end;
        }
        CfgUtilSetWmiStringParam(
            spWbemInput,
            L"DedicatedNetworkAddress",
            szAddress
            );
        delete (szAddress);
        szAddress = NULL;
    }

    //
    // TrafficMode
    //
    {
        LPCWSTR szMode = NULL;
        switch(pCfg->GetTrafficMode())
        {
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST:
            szMode = L"UNICAST";
            break;
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST:
            szMode = L"MULTICAST";
            break;
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST:
            szMode = L"IGMPMULTICAST";
            break;
        default:
            assert(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        CfgUtilSetWmiStringParam(spWbemInput, L"TrafficMode", szMode);
    }

    CfgUtilSetWmiDWORDParam(
        spWbemInput,
        L"HostPriority",
        pCfg->GetHostPriority()
        );

    if (pCfg->GetClusterModeOnStart() ==
        NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STARTED)
    {
        CfgUtilSetWmiBoolParam(spWbemInput, L"ClusterModeOnStart", TRUE);
    }
    else
    {
        CfgUtilSetWmiBoolParam(spWbemInput, L"ClusterModeOnStart", FALSE);
    }

    CfgUtilSetWmiBoolParam(
        spWbemInput,
        L"RemoteControlEnabled",
        pCfg->GetRemoteControlEnabled()
        );

    //
    // TODO: get port rules
    // [OUT] String  PortRules[],
    //
    

    Status = WBEM_NO_ERROR;

end:

    wprintf(L"<-Setup update params returns 0x%08lx\n", (UINT) Status);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\nlbhost_ping.cpp ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost_ping.cpp

Abstract:

    Implementation of Ping-related functionality of class NLBHost

    This code is adapted from the "ping" utility.

History:

    03/31/01    JosephJ Created

--*/

#include "tprov.h"
#include "ipexport.h"
#include "icmpapi.h"

#if 0
struct IPErrorTable {
    IP_STATUS  Error;                   // The IP Error
    DWORD ErrorNlsID;                   // NLS string ID
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,         PING_BUF_TOO_SMALL},
    { IP_DEST_NET_UNREACHABLE,  PING_DEST_NET_UNREACHABLE},
    { IP_DEST_HOST_UNREACHABLE, PING_DEST_HOST_UNREACHABLE},
    { IP_DEST_PROT_UNREACHABLE, PING_DEST_PROT_UNREACHABLE},
    { IP_DEST_PORT_UNREACHABLE, PING_DEST_PORT_UNREACHABLE},
    { IP_NO_RESOURCES,          PING_NO_RESOURCES},
    { IP_BAD_OPTION,            PING_BAD_OPTION},
    { IP_HW_ERROR,              PING_HW_ERROR},
    { IP_PACKET_TOO_BIG,        PING_PACKET_TOO_BIG},
    { IP_REQ_TIMED_OUT,         PING_REQ_TIMED_OUT},
    { IP_BAD_REQ,               PING_BAD_REQ},
    { IP_BAD_ROUTE,             PING_BAD_ROUTE},
    { IP_TTL_EXPIRED_TRANSIT,   PING_TTL_EXPIRED_TRANSIT},
    { IP_TTL_EXPIRED_REASSEM,   PING_TTL_EXPIRED_REASSEM},
    { IP_PARAM_PROBLEM,         PING_PARAM_PROBLEM},
    { IP_SOURCE_QUENCH,         PING_SOURCE_QUENCH},
    { IP_OPTION_TOO_BIG,        PING_OPTION_TOO_BIG},
    { IP_BAD_DESTINATION,       PING_BAD_DESTINATION},
    { IP_NEGOTIATING_IPSEC,     PING_NEGOTIATING_IPSEC},
    { IP_GENERAL_FAILURE,       PING_GENERAL_FAILURE}
};
#endif // 0


UINT
NLBHost::mfn_ping(
    VOID
    )
{
    UINT Status = ERROR_SUCCESS;
    LONG inaddr;
    char rgchBindString[1024];

    mfn_Log(L"NLBHost -- pinging (%s).", (LPCWSTR) m_BindString);

    //
    // Convert to ANSI.
    //


    //
    // Resolve to an IP address...
    //
    inaddr = inet_addr(m_BindString);
    if (inaddr == -1L)
    {
        struct hostent *hostp = NULL;
        hostp = gethostbyname(m_BindString);
        if (hostp) {
            unsigned char *pc = (unsigned char *) & inaddr;
            // If we find a host entry, set up the internet address
            inaddr = *(long *)hostp->h_addr;
            mfn_Log(
                L"NLBHost -- resolved to IP address %d.%d.%d.%d.",
                pc[0],
                pc[1],
                pc[2],
                pc[3]
                );
        } else {
            // Neither dotted, not name.
            Status = WSAGetLastError();
            mfn_Log(L"NLBHost -- could not resolve bind address.");
            goto end;
        }
    }

    //
    // Send Icmp echo.
    //
    HANDLE  IcmpHandle;

    IcmpHandle = IcmpCreateFile();
    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        mfn_Log(L"Unable to contact IP driver, error code %d.",Status);
        goto end;
    }

    const int Count = 4;
    const int Timeout = 1000;
    const int MinInterval = 500;

    for (int i = 0; i < Count; i++)
    {
        static BYTE SendBuffer[32];
        BYTE RcvBuffer[1024];
        int  numberOfReplies;
        numberOfReplies = IcmpSendEcho2(IcmpHandle,
                                        0,
                                        NULL,
                                        NULL,
                                        inaddr,
                                        SendBuffer,
                                        sizeof(SendBuffer),
                                        NULL,
                                        RcvBuffer,
                                        sizeof(RcvBuffer),
                                        Timeout
                                        );

        if (numberOfReplies == 0) {

            int errorCode = GetLastError();
            mfn_Log(L"ICMP Error %d", errorCode );

        
            // TODO: look at ping sources for proper error reporting
            // (host unreachable, etc...)

            if (i < (Count - 1)) {
                Sleep(MinInterval);
            }
        }
        else
        {
            mfn_Log(L"Ping succeeded.");
            Status = ERROR_SUCCESS;
            break;
        }
    }

end:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\resource.h ===
// Used by tprov.rc
//
#define IDS_HELLO                       1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\tmgr.cpp ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost.cpp

Abstract:

    Implementation of class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created

--*/


#include "tprov.h"


VOID
MyLogger(
    PVOID           Context,
    const   WCHAR * Text
    )
{
    wprintf(L"LOG: %s", Text);
    wprintf(L"\n");
}


void test_tmgr(int argc, WCHAR* argv[])
{

    WCHAR wszBuf[1024];
    NLBHost * pHost = NULL;
    WBEMSTATUS Status;
    NLBHost::HostInformation *pHostInfo = NULL;

    pHost = new NLBHost(
                    L"JOSEPHJ4E",
                    L"JosephJ's Dev Machine",
                    MyLogger,
                    NULL        // Logger context
                    );
    
    if (pHost == NULL)
    {
        MyLogger(NULL, L"Could not create an instance of NLBHost.");
        goto end;
    }

    UINT PingStatus = pHost->Ping();

    if (PingStatus!=ERROR_SUCCESS) goto end;


    Status = pHost->GetHostInformation(
                &pHostInfo
                );

    if (FAILED(Status))
    {
        pHostInfo = NULL;
        goto end;
    }

    int NumNics = pHostInfo->NumNics;

    wsprintf(
        wszBuf,
        L"Processing host with MachineName %s(NumNics=%d)",
        (LPCWSTR)pHostInfo->MachineName,
        NumNics
        );
    MyLogger(NULL, wszBuf);

    for( int i = 0; i < NumNics; i++)
    {
        NLBHost::NicInformation *pNicInfo;
        NLB_EXTENDED_CLUSTER_CONFIGURATION ClusterConfig;
        UINT GenerationId=0;
        UINT RequestId;

        pNicInfo = &pHostInfo->nicInformation[i];
        wsprintf(
            wszBuf,
            L"Processing NIC %s (%s)\n",
            (LPCWSTR) pNicInfo->adapterGuid,
            (LPCWSTR) pNicInfo->friendlyName
            );
        MyLogger(NULL, wszBuf);

        Status =  pHost->GetClusterConfiguration(
                            pNicInfo->adapterGuid,
                            &ClusterConfig
                            );
        if (FAILED(Status))
        {
            // Failure...
            continue;
        }


        Status = pHost->SetClusterConfiguration(
                            pNicInfo->adapterGuid,
                            &ClusterConfig,
                            GenerationId,
                            &RequestId
                            );

        if (Status == WBEM_S_PENDING)
        {
            INT Delay = 1000; // 1 sec

            // Give some time for the remote host's connectivity to be lost...
            //
            MyLogger(NULL, L"Sleeping for 5 seconds.");
            Sleep(5000);

            // Now wait until we can ping the host, then query for the async
            // result of the SetClusterConfiguration operation.
            // We keep polling for the result, sleeping increasing amounts
            // in between.
            //
            MyLogger(NULL, L"Pinging the host ....");
            while (pHost->Ping() == ERROR_SUCCESS)
            {
                UINT ResultCode;
                _bstr_t ResultText;

                MyLogger(NULL, L"Checking for asynchronous completion...");
                Status =  pHost->GetAsyncResult(
                                    RequestId,
                                    &GenerationId,
                                    &ResultCode,
                                    &ResultText
                                    );
                if (Status == WBEM_S_PENDING)
                {
                    break;
                }
                MyLogger(NULL, L"Operation still pending...");
                MyLogger(NULL, L"Waiting to try again ....");
                Sleep(Delay);
                MyLogger(NULL, L"Pinging the host ....");
                Delay *=2;
            }

        }
    }

end:

    if (pHostInfo != NULL)
    {
        delete pHostInfo;
        pHostInfo = NULL;
    }

    if (pHost != NULL)
    {
        delete pHost;
        pHost = NULL;
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\tprov.cpp ===
/*++
Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    tprov.cpp

Abstract:

    Test harness for nlb manager provider code

History:

    04/08/01    JosephJ Created

--*/

#include "tprov.h"
#include "tprov.tmh"

BOOL g_Silent = FALSE;

typedef enum 
{
    DO_USAGE,
    DO_NICLIST,
    DO_IPADDR,
    DO_NLBCFG,
    DO_NLBBIND,
    DO_UPDATE,
    DO_WMIUPDATE,
    DO_CLEANREG

} COMMAND_TYPE;

VOID do_usage(VOID);
VOID do_niclist(VOID);
VOID do_ipaddr(VOID);
VOID do_nlbcfg(VOID);
VOID do_nlbbind(VOID);
VOID do_update(VOID);
VOID do_wmiupdate(VOID);
VOID do_cleanreg(VOID);

VOID test_add_ips(LPCWSTR szNic);
VOID test_bind_nlb(LPCWSTR szNic);
VOID test_cfg_nlb(LPCWSTR szNic);
VOID test_update(LPCWSTR szMachine, LPCWSTR szNic);
void test(int argc, WCHAR* argv[]);
void test(int argc, WCHAR* argv[]);
void test_safearray(void);
VOID test_exfcfgclass(void);

BOOL read_guid(LPWSTR *pszNic);
BOOL read_machinename(LPWSTR *pszNic);

COMMAND_TYPE
parse_args(int argc, WCHAR* argv[]);

void
display_config(
    LPCWSTR szNicGuid,
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg
    );

VOID
display_ip_info(
    IN  UINT NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    );

WBEMSTATUS
read_ip_info(
    IN  LPCWSTR             szNic,
    OUT UINT                *pNumIpAddresses,
    OUT NLB_IP_ADDRESS_INFO **ppIpInfo
    );

int __cdecl wmain(int argc, WCHAR* argv[], WCHAR* envp[])
{
	int nRetCode = 0;

    //
    // Enable tracing
    //
    WPP_INIT_TRACING(L"Microsoft\\NLB\\TPROV");

#if 0
    // test_port_rule_string();
    // test_safearray();
    // test_tmgr(argc, argv);
    test_exfcfgclass();
        
#else
    NlbConfigurationUpdate::Initialize();
    test(argc, argv);
    NlbConfigurationUpdate::Deinitialize();
#endif

    //
    // Disable tracing
    //
    WPP_CLEANUP();

	return nRetCode;
}

NLB_EXTENDED_CLUSTER_CONFIGURATION MyOldCfg;
NLB_EXTENDED_CLUSTER_CONFIGURATION MyNewCfg;

VOID
display_log(WCHAR *pLog)
{
    static UINT previous_length;
    UINT current_length;
    current_length = wcslen(pLog);
    if (previous_length > current_length)
    {
        previous_length = 0;
    }

    wprintf(pLog+previous_length);

    previous_length = current_length;
}


LPCWSTR NicGuids[]  = {
    L"{AD4DA14D-CAAE-42DD-97E3-5355E55247C2}",
    L"{B2CD5533-5091-4F49-B80F-A07844B14209}",
    L"{EBE09517-07B4-4E88-AAF1-E06F5540608B}",
    L"{ABEA4318-5EE8-4DEC-AF3C-B4AEDE61454E}",
    L"{66A1869A-BF85-4D95-BBAB-07FA5B4449D4}",
    L"{AEEE83AF-AA48-4599-94BB-7C458D63CEED}",
    L"{D0536EEE-2CE0-4E8D-BFEC-0A608CFD81B9}"
};

UINT Trial;

void test(int argc, WCHAR* argv[])
{
    COMMAND_TYPE cmd;
    cmd = parse_args(argc, argv);

    switch(cmd)
    {
    case DO_USAGE: do_usage();
         break;
    case DO_NICLIST: do_niclist();
         break;
    case DO_IPADDR: do_ipaddr();
         break;
    case DO_NLBCFG: do_nlbcfg();
         break;
    case DO_NLBBIND: do_nlbbind();
         break;
    case DO_UPDATE: do_update();
         break;
    case DO_WMIUPDATE: do_wmiupdate();
         break;
    case DO_CLEANREG: do_cleanreg();
         break;
    }

    return;

}


void
display_config(
    LPCWSTR szNicGuid,
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg
    )
{
    if (g_Silent) return;

    printf("\nNLB Configuration for NIC %ws\n", szNicGuid);
    printf("\tfValidNlbCfg=%d\n", pCfg->fValidNlbCfg);
    printf("\tGeneration=%d\n", pCfg->Generation);
    printf("\tfBound=%d\n", pCfg->fBound);
    printf("\tfAddDedicatedIp=%d\n", pCfg->fAddDedicatedIp);
    
    UINT AddrCount = pCfg->NumIpAddresses;
    display_ip_info(AddrCount, pCfg->pIpAddressInfo);

    if (pCfg->fBound)
    {
        printf("\n");
        printf("\tNLB configuration:\n");
        if (pCfg->fValidNlbCfg)
        {
            printf("\t\tClusterIP: {%ws,%ws}\n",
                pCfg->NlbParams.cl_ip_addr,
                pCfg->NlbParams.cl_net_mask
                );
            printf("\t\tDedicatedIP: {%ws,%ws}\n",
                pCfg->NlbParams.ded_ip_addr,
                pCfg->NlbParams.ded_net_mask
                );
        }
        else
        {
            printf("**invalid configuration**\n");
        }
    }
    printf("\n");
    
    return;

}


VOID
test_add_ips(LPCWSTR szNic)
//
// Go through a set of IPs on this NIC
//
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    UINT NumIpAddresses= 0;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;

    while(1)
    {
        //
        // Get the current list of ip addresses
        //
        Status = CfgUtilGetIpAddressesAndFriendlyName(
                    szNic,
                    &NumIpAddresses,
                    &pIpInfo,
                    NULL // szFriendly name
                    );
    
        if (FAILED(Status))
        {
            printf("Error 0x%08lx getting ip address list for %ws\n",
                    (UINT) Status,  szNic);
            pIpInfo = NULL;
            goto end;
        }
    
        //
        //  display what we find.
        //
        display_ip_info(NumIpAddresses, pIpInfo);
        if (pIpInfo!=NULL)
        {
            delete pIpInfo;
            pIpInfo = NULL;
        }

    
        //
        // Read the list ip address and subnet masks from the input
        //
        Status = read_ip_info(szNic, &NumIpAddresses, &pIpInfo);
        if (FAILED(Status))
        {
            printf("Quitting test_add_ips\n");
            break;
        }
    
        //
        // Set the specified IPs
        //
        1 && (Status =  CfgUtilSetStaticIpAddresses(
                        szNic,
                        NumIpAddresses,
                        pIpInfo
                        ));

        if (FAILED(Status))
        { 
            printf("CfgUtilSetStaticIpAddresses failed with status 0x%08lx\n",
                    Status);
        }
        else
        {
            printf("Successfully set the specified IPs on the NIC\n");
        }

    }

end:

    if (pIpInfo != NULL)
    {
        delete pIpInfo;
    }
}

VOID
test_bind_nlb(LPCWSTR szNic)
{
    WBEMSTATUS Status;
    BOOL        fBound = FALSE;

    printf("\nRunning bind/unbind test for NIC %ws...\n\n", szNic);

    while(1)
    {
        //
        // Check NLB bind state
        //
        printf("Checking if NLB is bound...\n");
        Status =  CfgUtilCheckIfNlbBound(szNic, &fBound);
        if (FAILED(Status))
        {
            printf("CfgUtilCheckIfNlbBound fails with error 0x%08lx\n", (UINT)Status);
            break;
        }
        printf(
            "NLB is %wsbound\n\n",
            (fBound) ? L"" : L"NOT "
            );
            
    
        printf("Enter 'b' to bind, 'u' to unbind or 'q' to quit\n:");
        WCHAR Temp[32] = L"";
        while (wscanf(L" %1[buq]", Temp)!=1)
        {
            printf("Incorrect input. Try again.\n");
        }

        if (*Temp == 'b')
        {
            printf("Attempting to bind NLB...\n");
            fBound = TRUE;
        }
        else if (*Temp == 'u')
        {
            printf("Attempting to unbind NLB\n");
            fBound = FALSE;
        }
        else
        {
            printf("Quitting\n");
            break;
        }


    #if 1
        Status =  CfgUtilChangeNlbBindState(szNic, fBound);
        if (FAILED(Status))
        {
            printf("CfgUtilChangeNlbBindState fails with error %08lx\n",
                (UINT) Status);
        }
        else
        {
            printf(
                "%ws completed successfully\n",
                (fBound) ? L"Bind" : L"Unbind"
                );
        }
    #endif // 0
        printf("\n");
    
    }
}


VOID
test_cfg_nlb(LPCWSTR szNic)
{
    WBEMSTATUS Status;

    printf("\nRunning update NLB config test for NIC %ws...\n\n", szNic);

    while (1)
    {
        WLBS_REG_PARAMS Params;
        ZeroMemory(&Params, sizeof(Params));

        //
        // Read NLB config
        //
        Status =  CfgUtilGetNlbConfig(szNic, &Params);
        if (FAILED(Status))
        {
            printf("CfgUtilGetNlbConfig fails with error 0x%08lx\n", (UINT)Status);
            break;
        }

        printf("NLB configuration:\n");
        printf(
            "\tClusterIP: {%ws,%ws}\n",
            Params.cl_ip_addr,
            Params.cl_net_mask
            );
    
        //
        // Make some modifications
        //
        printf("\nEnter new {cluster-ip-addr,subnet-mask} or 'q' to quit\n:");
        while(1)
        {
            NLB_IP_ADDRESS_INFO Info;
            INT i =  wscanf(
                        L" { %15[0-9.] , %15[0-9.] }",
                        Info.IpAddress,
                        Info.SubnetMask
                        );
            if (i!=2)
            {
                WCHAR Temp[100] = L"";
                wscanf(L"%64ws", Temp);
                if (!_wcsicmp(Temp, L"q"))
                {
                    printf("Quitting\n");
                    goto end;
                }
                else
                {
                    printf("Badly formed input. Try again\n");
                }
            }
            else
            {
                wcscpy(Params.cl_ip_addr, Info.IpAddress);
                wcscpy(Params.cl_net_mask, Info.SubnetMask);
                break;
            }
        }
    
        //
        // Write NLB config
        //
    #if 1
        printf("\nAttempting to update NLB configuration...\n");
        Status = CfgUtilSetNlbConfig(szNic, &Params);
        if (FAILED(Status))
        {
            printf("CfgUtilSetNlbConfig fails with error %08lx\n",
                (UINT) Status);
        }
        else
        {
            printf("change completed successfully\n");
        }
    #endif // 0
        printf("\n");
    }

end:
    return;
    
}

VOID
test_update(
    LPCWSTR szMachineName, // NULL == don't use wmi
    LPCWSTR szNicGuid
    )
{
    WBEMSTATUS Status;
    WCHAR  *pLog = NULL;
    WBEMSTATUS  CompletionStatus;
    UINT   Generation;


    printf("\nRunning high-level update NLB config test for NIC %ws...\n\n", szNicGuid);

    while(1)
    {
        BOOL fSetDefaults = FALSE;
        UINT NumIpAddresses = 0;
        NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
        BOOL fUnbind = FALSE;

        //
        // Clean up config info
        //
        if (MyOldCfg.pIpAddressInfo!=NULL)
        {
            delete MyOldCfg.pIpAddressInfo;
        }
        ZeroMemory(&MyOldCfg, sizeof(MyOldCfg));
        if (MyNewCfg.pIpAddressInfo!=NULL)
        {
            delete MyNewCfg.pIpAddressInfo;
        }
        ZeroMemory(&MyNewCfg, sizeof(MyNewCfg));
    
        printf("TEST: Going to get configuration for NIC %ws\n", szNicGuid);
    
        MyBreak(L"Break before calling GetConfiguration.\n");

        if (szMachineName==NULL)
        {

            Status = NlbConfigurationUpdate::GetConfiguration(
                        szNicGuid,
                        &MyOldCfg
                        );
        }
        else
        {
            Status = NlbHostGetConfiguration(
                        szMachineName,
                        szNicGuid,
                        &MyOldCfg
                        );
        }
    
        if (FAILED(Status))
        {
            goto end;
        }

        display_config(szNicGuid, &MyOldCfg);
        
        if (MyOldCfg.fBound)
        {
            printf("\nEnter 2 or more {cluster-ip-addr,subnet-mask} or none to unbind or 'q' to quit. The first entry is the dedicated-ip.\n");
            if (!MyOldCfg.fValidNlbCfg)
            {
                //
                // We're bound, but nlb params are bad. Set defaults.
                //
                fSetDefaults = TRUE;
            }
        }
        else
        {
            //
            // We're previously unbound. Set defaults.
            //
            fSetDefaults = TRUE;

            printf("\nEnter 2 or more {cluster-ip-addr,subnet-mask} or 'q' to quit. The first entry is the dedicated-ip.\n");
        }


        while(1)
        {
            //
            // Read the list ip address and subnet masks from the input
            //
            Status = read_ip_info(szNicGuid, &NumIpAddresses, &pIpInfo);
            if (FAILED(Status))
            {
                printf("Quitting\n");
                goto end;
            }

            if (NumIpAddresses < 2)
            {
                if (MyOldCfg.fBound)
                {
                    if (NumIpAddresses == 0)
                    {
                        fUnbind = TRUE;
                        break;
                    }
                    else
                    {
                        printf("Wrong number of IP addresses -- enter either 0 or >= 2.\n");
                    }
                }
                else
                {
                    printf("Wrong number of IP addresses. Enter >= 2 IP addresses.");
                }
            }
            else
            {
                //
                //  >= 2 addresses. First one is the dip and the 2nd is the vip.
                //
                break;
            }

            if (pIpInfo != NULL)
            {
                delete pIpInfo;
                pIpInfo = NULL;
            }

        }
    
        if (fUnbind)
        {
            //
            // We're to unbind.
            //

            ZeroMemory(&MyNewCfg, sizeof(MyNewCfg));
            MyNewCfg.fValidNlbCfg = TRUE;
            MyNewCfg.fBound = FALSE;

            //
            // Set the list of ip address to have present on unbind to
            // be the dedicated ip address, if there is one, otherwise zero,
            // in which case the adapter will be switched to DHCP after NLB
            // is unbound
            //

            if (MyOldCfg.NlbParams.ded_ip_addr[0]!=0)
            {
                NLB_IP_ADDRESS_INFO *pIpInfo;
                pIpInfo = new NLB_IP_ADDRESS_INFO;
                if (pIpInfo == NULL)
                {
                    printf("TEST: allocation failure; can't add IP on unbind.\n");
                }
                else
                {
                    wcscpy(pIpInfo->IpAddress, MyOldCfg.NlbParams.ded_ip_addr);
                    wcscpy(pIpInfo->SubnetMask, MyOldCfg.NlbParams.ded_net_mask);
                    MyNewCfg.NumIpAddresses = 1;
                    MyNewCfg.pIpAddressInfo = pIpInfo;
                }
            }

        }
        else
        {
            if (fSetDefaults)
            {
                CfgUtilInitializeParams(&MyNewCfg.NlbParams);
                MyNewCfg.fValidNlbCfg = TRUE;
                MyNewCfg.fBound = TRUE;
            }
            else
            {
                MyNewCfg = MyOldCfg; // struct copy
                ASSERT(MyNewCfg.fValidNlbCfg == TRUE);
                ASSERT(MyNewCfg.fBound == TRUE);
            }

            //
            // Now Add the dedicated and cluster IPs.
            //
            ASSERT(NumIpAddresses >= 2);
            wcscpy(MyNewCfg.NlbParams.ded_ip_addr, pIpInfo[0].IpAddress);
            wcscpy(MyNewCfg.NlbParams.ded_net_mask, pIpInfo[0].SubnetMask);
            wcscpy(MyNewCfg.NlbParams.cl_ip_addr, pIpInfo[1].IpAddress);
            wcscpy(MyNewCfg.NlbParams.cl_net_mask, pIpInfo[1].SubnetMask);
    
            //
            // If more IPs, we explicitly add the ip list, else leave it null.
            //
            if (NumIpAddresses > 2)
            {
                MyNewCfg.pIpAddressInfo = pIpInfo;
                MyNewCfg.NumIpAddresses = NumIpAddresses;
            }
            else
            {
                MyNewCfg.fAddDedicatedIp = TRUE; // says to add dedicated ip.
                MyNewCfg.pIpAddressInfo=NULL;
                MyNewCfg.NumIpAddresses=0;
                delete pIpInfo;
                pIpInfo = NULL;
            }
        }

        display_config(szNicGuid, &MyNewCfg);
    
        printf("Going to update configuration for NIC %ws\n", szNicGuid);

        MyBreak(L"Break before calling DoUpdate.\n");
    
        if (szMachineName==NULL)
        {
            Status = NlbConfigurationUpdate::DoUpdate(
                        szNicGuid,
                        L"tprov.exe",
                        &MyNewCfg,
                        &Generation,
                        &pLog
                        );
        }
        else
        {
            Status = NlbHostDoUpdate(
                        szMachineName,
                        szNicGuid,
                        L"tprov.exe",
                        &MyNewCfg,
                        &Generation,
                        &pLog
                        );
        }
    
        if (pLog != NULL)
        {
            display_log(pLog);
            delete pLog;
            pLog = NULL;
        }
    
        if (Status == WBEM_S_PENDING)
        {
            printf(
                "Waiting for pending operation %d...\n",
                Generation
                );
        }

        while (Status == WBEM_S_PENDING)
        {
            Sleep(1000);
    
            if (szMachineName == NULL)
            {
                Status = NlbConfigurationUpdate::GetUpdateStatus(
                            szNicGuid,
                            Generation,
                            FALSE,  // FALSE == Don't delete completion record
                            &CompletionStatus,
                            &pLog
                            );
            }
            else
            {
                Status = NlbHostGetUpdateStatus(
                            szMachineName,
                            szNicGuid,
                            Generation,
                            &CompletionStatus,
                            &pLog
                            );
            }
            if (pLog != NULL)
            {
                display_log(pLog);
                delete pLog;
                pLog = NULL;
            }
            if (!FAILED(Status))
            {
                Status = CompletionStatus;
            }
        }
    
        printf(
            "Final status of update %d is 0x%08lx\n",
            Generation,
            Status
            );
    }
end:
    return;
}



VOID
display_ip_info(
    IN  UINT NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    )
{
    UINT AddrCount = NumIpAddresses;
    printf("\tNumIpAddresses=%d\n", AddrCount);
    
    if (AddrCount != 0)
    {
        printf("\tAddress\t\tMask\n");
        if (pIpInfo == NULL)
        {
            printf("ERROR: IpAddressInfo is NULL!\n");
            goto end;
        }
        
        for (UINT u=0;u<AddrCount; u++)
        {
            printf(
                "\t{%-15ws, %ws}\n",
                pIpInfo[u].IpAddress,
                pIpInfo[u].SubnetMask
                );
        }
    }

end:
    return;
}

WBEMSTATUS
read_ip_info(
    IN  LPCWSTR             szNic,
    OUT UINT                *pNumIpAddresses,
    OUT NLB_IP_ADDRESS_INFO **ppIpInfo
    )
{
    NLB_IP_ADDRESS_INFO *pIpInfo;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    #define MAX_READ_IPS 10

    printf("Enter zero or more {ip-address,subnet-mask} followed by '.'\n"
           "(or 'q' to quit)\n:");
    pIpInfo = new NLB_IP_ADDRESS_INFO[MAX_READ_IPS];

    if (pIpInfo == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }
    for (UINT Index=0; Index<MAX_READ_IPS; Index++)
    {
        NLB_IP_ADDRESS_INFO *pInfo = pIpInfo+Index;
        INT i =  wscanf(
                    //L" { %15ws , %15ws }",
                    //L"{%15ws,%15ws}",
                    //L"{%ws,%ws}",
                    //L"{%[0-9.],%[0-9.]}",
                    L" { %15[0-9.] , %15[0-9.] }",
                    pInfo->IpAddress,
                    pInfo->SubnetMask
                    );
        if (i!=2)
        {
            WCHAR Temp[100];
            wscanf(L"%64ws", Temp);
            if (!_wcsicmp(Temp, L"q"))
            {
                Status = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            else if (!_wcsicmp(Temp, L"."))
            {
                break;
            }
            else
            {
                printf("Badly formed input. Try again\n");
                Index--;
            }
        }
    }

    *pNumIpAddresses = Index;

end:

    if (FAILED(Status))
    {
        if (pIpInfo != NULL)
        {
            delete pIpInfo;
            pIpInfo = NULL;
        }
    }
    *ppIpInfo = pIpInfo;

    return Status;
}


COMMAND_TYPE
parse_args(int argc, WCHAR* argv[])
/*++
tprov [niclist|ipaddr|nlbcfg|nlbbind]
--*/
{
    COMMAND_TYPE ret = DO_USAGE;

    if (argc!=2)
    {
        if (argc!=1)
        {
            printf("ERROR: wrong number of arguments\n");
        }
        goto end;
    }

    if (!wcscmp(argv[1], L"niclist"))
    {
        ret = DO_NICLIST;
    }
    else if (!wcscmp(argv[1], L"ipaddr"))
    {
        ret = DO_IPADDR;
    }
    else if (!wcscmp(argv[1], L"nlbcfg"))
    {
        ret = DO_NLBCFG;
    }
    else if (!wcscmp(argv[1], L"nlbbind"))
    {
        ret = DO_NLBBIND;
    }
    else if (!wcscmp(argv[1], L"update"))
    {
        ret = DO_UPDATE;
    }
    else if (!wcscmp(argv[1], L"wmiupdate"))
    {
        ret = DO_WMIUPDATE;
    }
    else if (!wcscmp(argv[1], L"cleanreg"))
    {
        ret = DO_CLEANREG;
    }
    else
    {
        printf("ERROR: unknown argument\n");
    }

end:

    return ret;
}

VOID
do_usage(VOID)
{
    printf("Usage:\n\n\tprov [niclist|ipaddr|nlbbind|nlbcfg]\n");
    printf("\tniclist    -- display the list of NICs\n");
    printf("\tipaddr     -- change the static ip addresses on a NIC\n");
    printf("\tnlbbind    -- bind NLB to or unbind NLB from a NIC\n");
    printf("\tnlbcfg     -- change NLB configuration on a NIC\n");
    printf("\tupdate     -- update overall configuration on a NIC\n");
    printf("\twmiupdate  -- WMI version of the update\n");
    printf("\n");
}

VOID do_niclist(VOID)
{
    LPWSTR *pszNics = NULL;
    UINT   NumNics = 0;
    UINT   NumNlbBound = 0;
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    // printf("\n\tniclist is unimplemented.\n");
    Status =  CfgUtilsGetNlbCompatibleNics(&pszNics, &NumNics, &NumNlbBound);

    if (FAILED(Status))
    {
        printf("CfgUtilsGetNlbCompatibleNics returns error 0x%08lx\n",
                    (UINT) Status);
        pszNics = NULL;
        goto end;
    }

    if (NumNics == 0)
    {
        printf("No compatible local adapter guids.\n");
    }
    else
    {
        printf("Local Adapter Guids (%lu bound to NLB):\n", NumNlbBound);
        for (UINT u = 0; u<NumNics; u++)
        {

            LPCWSTR szNic           = pszNics[u];
            LPWSTR  szFriendlyName  = NULL;
            UINT NumIpAddresses= 0;
            NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
    
            //
            // Get the current list of ip addresses
            //
            Status = CfgUtilGetIpAddressesAndFriendlyName(
                        szNic,
                        &NumIpAddresses,
                        &pIpInfo,
                        &szFriendlyName
                        );
        
            if (FAILED(Status))
            {
                pIpInfo = NULL;
                szFriendlyName = NULL;
                // wprintf(L"%ws\t<null>\t<null>\n", szNic);
                wprintf(L"Error getting ip addresses for %ws\n", szNic);
            }
            else
            {
                LPCWSTR szCIpAddress    = L"";
                LPCWSTR szCFriendlyName = L"";
        
                if (NumIpAddresses>0)
                {
                    szCIpAddress =  pIpInfo[0].IpAddress;
                }

                if (szFriendlyName != NULL)
                {
                    szCFriendlyName = szFriendlyName;
                }

                wprintf(
                    L"%ws  %-15ws  \"%ws\"\n",
                    szNic,
                    szCIpAddress,
                    szCFriendlyName
                    );
            }

            if (pIpInfo != NULL)
            {
                delete pIpInfo;
                pIpInfo = NULL;
            }

            if (szFriendlyName != NULL)
            {
                delete szFriendlyName;
                szFriendlyName = NULL;
            }
        }
    }

end:

    if (pszNics != NULL)
    {
        delete pszNics;
        pszNics = NULL;
    }
        
}


VOID do_ipaddr(VOID)
{
    LPWSTR szNic = NULL;

    if (!read_guid(&szNic))
    {
        szNic = NULL;
        goto end;
    }

    test_add_ips(szNic);

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    
}


VOID do_nlbcfg(VOID)
{
    LPWSTR szNic = NULL;

    if (!read_guid(&szNic))
    {
        szNic = NULL;
        goto end;
    }

    test_cfg_nlb(szNic);

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    
}


VOID do_nlbbind(VOID)
{
    LPWSTR szNic = NULL;

    if (!read_guid(&szNic))
    {
        szNic = NULL;
        goto end;
    }

    test_bind_nlb(szNic);

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    
}


VOID do_update(VOID)
{
    LPWSTR szNic = NULL;

    if (!read_guid(&szNic))
    {
        szNic = NULL;
        goto end;
    }

    test_update(NULL, szNic); // NULL == don't use WMI

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    
}

VOID do_wmiupdate(VOID)
{
    LPWSTR szNic = NULL;
    LPWSTR szMachineName = NULL;

    if (!read_machinename(&szMachineName))
    {
        szMachineName = NULL;
        goto end;
    }
    if (!read_guid(&szNic))
    {
        szNic = NULL;
        goto end;
    }

    test_update(szMachineName, szNic); // TRUE == use WMI

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    if (szMachineName!=NULL)
    {
        delete szMachineName;
    }
    
}


VOID do_cleanreg(VOID)
{
   printf("Unimplemented\n");
}

BOOL read_guid(
        LPWSTR *pszNic
        )
{
    BOOL fRet = FALSE;

#if 1
    WCHAR rgTemp[256];
    printf("\nEnter NIC GUID\n:");
    while (wscanf(L" %40[-{}a-fA-F0-9]", rgTemp)!=1)
    {
        wscanf(L" %200s", rgTemp);
        printf("Incorrect format. Please try again.\n");
    }
#else
    LPCWSTR rgTemp = L"{AD4DA14D-CAAE-42DD-97E3-5355E55247C2}";
#endif // 0

    LPWSTR szNic = new WCHAR[wcslen(rgTemp)+1];

    if (szNic != NULL)
    {
        wcscpy(szNic, rgTemp);
        fRet = TRUE;
    }

    *pszNic = szNic;
    return fRet;
}

BOOL read_machinename(
        LPWSTR *pszMachineName
        )
{
    BOOL fRet = FALSE;
#if 0
    WCHAR rgTemp[256];
    printf("\nEnter Machine Name (or '.' for local)\n:");
    while (wscanf(L" %[a-zA-Z0-9._-]", rgTemp)!=1)
    {
        wscanf(L" %200s", rgTemp);
        printf("Incorrect format. Please try again.\n");
    }
    if (!wcscmp(rgTemp, L"."))
    {
        // convert "." to ""
        *rgTemp=0;
    }
#else
    LPCWSTR rgTemp = L"JOSEPHJ4E";
#endif

    LPWSTR szMachineName = new WCHAR[wcslen(rgTemp)+1];

    if (szMachineName != NULL)
    {
        wcscpy(szMachineName, rgTemp);
        fRet = TRUE;
    }

    *pszMachineName = szMachineName;
    return fRet;
}


void test_safearray(void)
{
    SAFEARRAY   *pSA;
    LPCWSTR     pInStrings[] =
       {
       L"String1",
    #if 1
       L"String2",
       L"String3",
    #endif // 0
        NULL // must be last.
       };
    LPWSTR     *pOutStrings;
    UINT NumInStrings=0;
    UINT NumOutStrings=0;
    WBEMSTATUS Status;

    //
    // Find count of strings...
    //
    for (NumInStrings=0; pInStrings[NumInStrings]!=NULL; NumInStrings++)
    {
        ;
    }

    Status = CfgUtilSafeArrayFromStrings(
                pInStrings,
                NumInStrings,
                &pSA
                );

    if (FAILED(Status))
    {
        printf("CfgUtilSafeArrayFromStrings failed with error 0x%08lx\n", (UINT)Status);
        pSA = NULL;
        goto end;
    }


    Status = CfgUtilStringsFromSafeArray(
                pSA,
                &pOutStrings,
                &NumOutStrings
                );

    if (FAILED(Status))
    {
        printf("CfgUtilStringsFromSafeArray failed with error 0x%08lx\n", (UINT)Status);
        pOutStrings = NULL;
        goto end;
    }


    //
    // Check that they match
    //
    if (NumOutStrings != NumInStrings)
    {
        printf("ERROR: NumOutStrings != NumInStrings.\n");
        goto end;
    }

    for (UINT u=0; u < NumInStrings; u++)
    {
        if (wcscmp(pInStrings[u], pOutStrings[u]))
        {
            printf("MISMATCH: %ws->%ws\n",  pInStrings[u], pOutStrings[u]);
        }
        else
        {
            printf("MATCH: %ws->%ws\n",  pInStrings[u], pOutStrings[u]);
        }
    }

end:
    if (pSA!=NULL)
    {
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }
    if (pOutStrings!=NULL)
    {
        delete pOutStrings;
        pOutStrings = NULL;
    }
    return;
}

VOID test_exfcfgclass(void)
/*
    tests some of the methods of class  NLB_EXTENDED_CLUSTER_CONFIGURATION

    1. Initialize Cfg
    2. Set a bunch of fields
    3. display Cfg
    4. Get and set a bunch of fields on new
    5. display cfg

*/
{
    typedef enum
    {
        DO_STRINGS,
        DO_SAFEARRAY,
        DO_STRINGPAIR,
        DO_END
    } TEST_COMMAND;

    TEST_COMMAND cmd;

    printf("Test of NLB_EXTENDED_CLUSTER_CONFIGURATION methods...\n");

    UINT u1=100000L;
    while(u1--> 0)
    {
        g_Silent = TRUE;

    for (cmd=DO_STRINGS; cmd<DO_END; cmd=(TEST_COMMAND)((UINT)cmd + 1))
    {
    
    
        NLB_EXTENDED_CLUSTER_CONFIGURATION Cfg;
        NLB_EXTENDED_CLUSTER_CONFIGURATION NewCfg;
        WBEMSTATUS  Status = WBEM_NO_ERROR;
    
    
        CfgUtilInitializeParams(&Cfg.NlbParams);
        CfgUtilInitializeParams(&NewCfg.NlbParams);
    
    
        //
        // Set a bunch of fields in Cfg
        //
        {
            #define TPROV_NUM_ADDRESSES 2
            #define TPROV_NUM_PORTS 1
            LPCWSTR     rgszNetworkAddresses[TPROV_NUM_ADDRESSES] = {
                            L"10.0.0.1/255.0.0.0",
                            L"10.0.0.2/255.0.0.0"
                            };
            LPCWSTR     rgszIpAddresses[TPROV_NUM_ADDRESSES] = {
                            L"10.0.0.1",
                            L"10.0.0.2"
                            };
            LPCWSTR     rgszSubnetMasks[TPROV_NUM_ADDRESSES] = {
                            L"255.255.255.0",
                            L"255.255.0.0"
                            };
            LPCWSTR     rgszPortRules[TPROV_NUM_PORTS] = {
                            L"ip=1.1.1.1 protocol=TCP start=80 end=288 mode=SINGLE"
                            };
            UINT        NumOldNetworkAddresses = TPROV_NUM_ADDRESSES;
            UINT        NumOldPortRules=TPROV_NUM_PORTS;
    
            Cfg.fValidNlbCfg = TRUE;
            Cfg.Generation = 123;
            Cfg.fBound = TRUE;
    
            if (cmd == DO_STRINGS)
            {
                Status =  Cfg.SetNetworkAddresses(
                                rgszNetworkAddresses,
                                NumOldNetworkAddresses
                                );
            }
            else if (cmd == DO_SAFEARRAY)
            {
                SAFEARRAY   *pOldSA = NULL;
                Status = CfgUtilSafeArrayFromStrings(
                            rgszNetworkAddresses,
                            NumOldNetworkAddresses,
                            &pOldSA
                            );
                if (FAILED(Status))
                {
                    printf("ERROR: couldn't create safe array!\n");
                    pOldSA = NULL;
                }
                if (pOldSA != NULL)
                {
                    Status = Cfg.SetNetworkAddressesSafeArray(pOldSA);
                    SafeArrayDestroy(pOldSA);
                    pOldSA = NULL;
        
                }
            }
            else if (cmd = DO_STRINGPAIR)
            {
    
                Status =  Cfg.SetNetworkAddresPairs(
                            rgszIpAddresses,
                            rgszSubnetMasks,
                            NumOldNetworkAddresses
                            );
            }

            Status =  Cfg.SetPortRules(rgszPortRules, NumOldPortRules);
            Cfg.SetClusterNetworkAddress(L"10.0.0.11/255.0.0.0");
            Cfg.SetDedicatedNetworkAddress(L"10.0.0.1/255.0.0.0");
            Cfg.SetTrafficMode(
                NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST
                );
            Cfg.SetHostPriority(10);
            Cfg.SetClusterModeOnStart(
                NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED
                );
            Cfg.SetRemoteControlEnabled(TRUE);
            Cfg.fValidNlbCfg = TRUE;
        }
    
        display_config(L"<dummy nic:old>", &Cfg);
    
        //
        // Get all the fields and push it into NewCfg;
        //
        {
            UINT        NumNetworkAddresses = 0;
            UINT        NumPortRules=0;
            LPWSTR      *pszNetworkAddresses=NULL;
            LPWSTR      *pszIpAddresses=NULL;
            LPWSTR      *pszSubnetMasks=NULL;
            LPWSTR      *pszPortRules=NULL;
            LPWSTR      szClusterAddress = NULL;
            LPWSTR      szDedicatedAddress = NULL;
            UINT        Generation=0;
            BOOL        NlbBound=FALSE;
            BOOL        ValidNlbConfig=FALSE;
            SAFEARRAY   *pSA = NULL;
            NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE
                TrafficMode=NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
            NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE
                StartMode=NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED;
            UINT        HostPriority=0;
            BOOL        RemoteControlEnabled=FALSE;
    
            //
            // GET
            //
    
            Generation  = Cfg.GetGeneration();
            NlbBound = Cfg.IsNlbBound();
            ValidNlbConfig = Cfg.IsValidNlbConfig();
        
            if (cmd == DO_STRINGS)
            {
                Status =  Cfg.GetNetworkAddresses(
                                &pszNetworkAddresses,    
                                &NumNetworkAddresses
                                );
            }
            else if (cmd == DO_SAFEARRAY)
            {
                Status =  Cfg.GetNetworkAddressesSafeArray(&pSA);
                if (FAILED(Status))
                {
                    pSA = NULL;
                }
            }
            else if (cmd = DO_STRINGPAIR)
            {
                Status =  Cfg.GetNetworkAddressPairs(
                            &pszIpAddresses,   // free using delete
                            &pszSubnetMasks,   // free using delete
                            &NumNetworkAddresses
                            );
            }

    
            Status =  Cfg.GetPortRules(&pszPortRules, &NumPortRules);
            Status =  Cfg.GetClusterNetworkAddress(&szClusterAddress);
            Status =  Cfg.GetDedicatedNetworkAddress(&szDedicatedAddress);
            TrafficMode =     Cfg.GetTrafficMode();
            HostPriority =  Cfg.GetHostPriority();
            StartMode = Cfg.GetClusterModeOnStart();
            RemoteControlEnabled = Cfg.GetRemoteControlEnabled();
    
            //
            // SET
            //
    
            NewCfg.fValidNlbCfg = ValidNlbConfig;
            NewCfg.Generation = Generation;
            NewCfg.fBound = NlbBound;
    
            if (cmd == DO_STRINGS)
            {
                Status =  NewCfg.SetNetworkAddresses(
                                (LPCWSTR*) pszNetworkAddresses,
                                NumNetworkAddresses
                                );
            }
            else if (cmd == DO_SAFEARRAY)
            {
                if (pSA != NULL)
                {
                    Status = NewCfg.SetNetworkAddressesSafeArray(pSA);
                    SafeArrayDestroy(pSA);
                    pSA = NULL;
                }
            }
            else if (cmd = DO_STRINGPAIR)
            {
                Status =  NewCfg.SetNetworkAddresPairs(
                            (LPCWSTR*) pszIpAddresses,
                            (LPCWSTR*) pszSubnetMasks,
                            NumNetworkAddresses
                            );
            }
    
            Status =  NewCfg.SetPortRules((LPCWSTR*)pszPortRules, NumPortRules);
            NewCfg.SetClusterNetworkAddress(szClusterAddress);
            NewCfg.SetDedicatedNetworkAddress(szDedicatedAddress);
            NewCfg.SetTrafficMode(TrafficMode);
            NewCfg.SetHostPriority(HostPriority);
            NewCfg.SetClusterModeOnStart(StartMode);
            NewCfg.SetRemoteControlEnabled(RemoteControlEnabled);
    
            delete (pszNetworkAddresses);
            delete (pszIpAddresses);
            delete (pszSubnetMasks);
            delete (pszPortRules);
            delete (szClusterAddress);
            delete (szDedicatedAddress);

        }
    
        display_config(L"<dummy nic:new>", &NewCfg);
    }
    }

    printf("... end test\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\tprov.h ===
#include "private.h"
#include "winsock2.h"
#include "nlbhost.h"
void test_tmgr(int argc, WCHAR* argv[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\nlbhost.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost.h

Abstract:

    Header file for class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created

--*/

// #include <vector>
// using namespace std;

#if 0
class MgrHostInformation
{

public:

    HostInformation();
    Get
};
#endif // 0

typedef
VOID
(*PFN_LOGGER)(
    PVOID           Context,
    const   WCHAR * Text
    );


typedef struct
{
    WLBS_REG_PARAMS wlbsRegParams; // Use wlbs APIs (wlbsconfig.h) 

} MGR_RAW_CLUSTER_CONFIGURATION, *PMGR_RAW_CLUSTER_CONFIGURATION;

class NLBHost
{

public:

#if 1
	class NicInformation
    {
    public:
        _bstr_t fullNicName;
        _bstr_t adapterGuid;
        _bstr_t friendlyName;

        BOOL   isDHCPEnabled;

        vector<_bstr_t> ipsOnNic;
        vector<_bstr_t> subnetMasks;

        BOOL    isBoundToNLB;
    };


	class HostInformation
    {
    public:
        _bstr_t MachineName;
         vector<NicInformation> nicInformation;
    };


#endif // 0

    NLBHost(
        const WCHAR *   pBindString,
        const WCHAR *   pFriendlyName,
        PFN_LOGGER      pfnLogger,
        PVOID           pLoggerContext
        );

    ~NLBHost();

    
    UINT
    Ping(
        VOID
        );
    
#if 1
    UINT GetHostInformation(
    	OUT HostInformation **ppHostInfo 
		);
#endif // 0


//
// Configuration operations:
//

    UINT
    GetClusterConfiguration(
        IN const    WCHAR *                         pNicGuid,
        OUT         PMGR_RAW_CLUSTER_CONFIGURATION  pClusterConfig,
        OUT         UINT *                          pGenerationId
        );

    UINT
    SetClusterConfiguration(
        IN const    WCHAR *                         pNicGuid,
        IN const    PMGR_RAW_CLUSTER_CONFIGURATION  pClusterConfig,
        IN          UINT                            GenerationId,
        OUT         UINT *                          pRequestId
        );

    UINT
    GetAsyncResult(
        IN          UINT                            RequestId,
        OUT         UINT *                          pGenerationId,
        OUT         UINT *                          ResultCode,
        OUT         _bstr_t *                       pResultText
        );

#if 0
    VOID
    CancelOperation(
        VOID
        );
#endif // 0

//
// Management operations:
//
//
//    GetClusterState(NIC-Guid, &ClusterState)
//    SetClusterState(NIC-Guid, ClusterState)
//

private:

    static WSADATA      s_WsaData;
    static LONG         s_InstanceCount;
    static BOOL         s_FatalError;
    static BOOL         s_ComInitialized;
    static BOOL         s_WsaInitialized;
    static IWbemStatusCodeTextPtr s_sp_werr; //Smart pointer

    _bstr_t             m_BindString;
    _bstr_t             m_FriendlyName;
    PFN_LOGGER          m_pfnLogger;
    PVOID       	    m_pLoggerContext;
    BOOL				m_fProcessing;	// Already processing some method.
    IWbemLocatorPtr     m_sp_pwl; // Smart pointer
 	IWbemServicesPtr    m_sp_pws; // Smart pointer
    CRITICAL_SECTION    m_Lock;

    UINT
    mfn_connect(
        VOID
        );

    VOID
    mfn_disconnect(
        VOID
        );


    VOID
    mfn_lock(
        VOID
        );

    VOID
    mfn_unlock(
        VOID
        );
    

    VOID
    mfn_Log(
        UINT ID,
        ...
        );

    VOID
    mfn_Log(
        LPCWSTR pwszMessage,
        ...
        );


    VOID
    mfn_LogHr(
        LPCWSTR pwszMessage,
        HRESULT hr
        );

    UINT
    mfn_ping(
        VOID
        );


    VOID
    mfn_InitializeStaticFields(
            VOID
            );

    VOID
    mfn_DeinitializeStaticFields(
            VOID
            );

};


//
// NLBH_SUCCESS takes a UINT return value of an NLBHost method and
// returns TRUE if the result is sucessful and FALSE otherwise
#define NLBH_SUCCESS(_retval) \
        ((_retval)==0)

#define NLBH_PENDING(_retval) \
        ((_retval)==STATUS_PENDING)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\nlbhost.cpp ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost.cpp

Abstract:

    Implementation of class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created

--*/

#include "stdafx.h"
#include "private.h"


//
// Static members of class NLBHost.
//
WSADATA      NLBHost::s_WsaData;
LONG         NLBHost::s_InstanceCount;
BOOL         NLBHost::s_FatalError;
BOOL         NLBHost::s_WsaInitialized;
BOOL         NLBHost::s_ComInitialized;
IWbemStatusCodeTextPtr NLBHost::s_sp_werr; // Smart pointer


VOID
NLBHost::mfn_Log(
    UINT ID,
    ...
    )
{
    WCHAR wszBuffer[1024];
    LPCWSTR pwszMessage;
    CString FormatString;
    if (!FormatString.LoadString(ID))
    {
        wsprintf(wszBuffer, L"Error loading string resource ID %d", ID);
    }
    else
    {

        try {
    
           va_list arglist;
           va_start (arglist, ID);
           int cch = vswprintf(wszBuffer, FormatString, arglist);
           va_end (arglist);
        }
        catch(...)
        {
            wsprintf(wszBuffer, L"Exception writing out log entry for resource ID %d", ID);
        }
    }

    m_pfnLogger(m_pLoggerContext, wszBuffer);

}


VOID
NLBHost::mfn_LogHr(
        LPCWSTR pwszMessage,
        HRESULT hr
        )
{

    if (s_sp_werr)
    {
        BSTR  bstr1 = 0;
        BSTR  bstr2 = 0;

        SCODE sc;
            
        sc = s_sp_werr->GetFacilityCodeText( hr, 
                                           0,
                                           0,
                                           &bstr1 );
        if( sc != S_OK )
        {
            bstr2 = L"Unknown Error";
        }
    
    
        sc = s_sp_werr->GetErrorCodeText( hr, 
                                        0,
                                        0,
                                        &bstr2 );
        if( sc != S_OK )
        {
            bstr2 = L"Unknown Code";
        }
    
        mfn_Log(
            L"%s %s: %s(hr=0x%08lx)",
            pwszMessage,
            (LPCWSTR) bstr1,
            (LPCWSTR) bstr2,
            hr
            );
    
        SysFreeString( bstr1 );
        SysFreeString( bstr2 );
    }
    else
    {
        mfn_Log(
            L"%s (hr=0x%08lx)",
            pwszMessage,
            hr
            );
    }
}


VOID
NLBHost::mfn_Log(
        LPCWSTR pwszMessage,
        ...
        )
{
   WCHAR wszBuffer[1024];
   wszBuffer[0] = 0;

   va_list arglist;
   va_start (arglist, pwszMessage);
   int cch = vswprintf(wszBuffer, pwszMessage, arglist);
   va_end (arglist);

   m_pfnLogger(m_pLoggerContext, wszBuffer);
}



NLBHost::NLBHost(
    const WCHAR *   pBindString,
    const WCHAR *   pFriendlyName,
    PFN_LOGGER      pfnLogger,
    PVOID           pLoggerContext
    )
/*++

Routine Description:

    Constructor for NLBHost.

    The constructor does not initiate any connections to the host. Connections
    to the host are initiated on demand (based on method calls).

Arguments:

    pBindString     - String used to connect to the remote host.
    pFriendlyName   - Descriptive name of the host. Used for logging.
    pfnLogger       - Function called to log textual information.
    pLoggerContext  - Caller's context, passed in calls to pfnLogger
    
--*/
{
    m_BindString        = pBindString;      // implicit copy
    m_FriendlyName      = pFriendlyName;    // implicit copy
    m_pfnLogger         = pfnLogger;
    m_pLoggerContext    = pLoggerContext;

    if (InterlockedIncrement(&s_InstanceCount) == 1)
    {
        mfn_InitializeStaticFields();

    }

    InitializeCriticalSection(&m_Lock);

    mfn_Log(
        L"NLBHost(BindString=%s, FriendlyName=%s) constructor succeeded.",
        (LPCWSTR) pBindString,
        (LPCWSTR) pFriendlyName
        );
}

NLBHost::~NLBHost()
/*++

Routine Description:

    Destructor for NLBHost.

--*/
{
    mfn_Log(L"NLBHost distructor(%s).", (LPCWSTR) m_FriendlyName);

    ASSERT(m_fProcessing == FALSE);	// Shouldn't be doing any processing when
                                    // calling the distructor.

    if (InterlockedDecrement(&s_InstanceCount)==0)
    {
        mfn_DeinitializeStaticFields();
    }
    
    DeleteCriticalSection(&m_Lock);

}

    
UINT
NLBHost::Ping(
    VOID
    )
{
    if (s_FatalError) return ERROR_INTERNAL_ERROR;

    return mfn_ping();
}
    
UINT
NLBHost::GetHostInformation(
    OUT HostInformation **ppHostInfo 
    )
{
    UINT Status;
    HostInformation *pHostInfo = new HostInformation;
    BOOL fConnected = FALSE;
    NicInformation NicInfo;

    if (s_FatalError) return ERROR_INTERNAL_ERROR;

    pHostInfo = new HostInformation;
    if (pHostInfo == NULL) 
    {
        Status = ERROR_OUTOFMEMORY;
        goto end;
    }

    //
    // Connect to the host.
    //
    Status = mfn_connect();

    if (!NLBH_SUCCESS(Status)) goto end;
    
    fConnected = TRUE;

#if 0
    //
    // Now find the instance and execute the method to get the host info.
    //
    mfn_find_host_instance();
    ... stuff parameters ...
    mfn_execute_method();
#endif // 

    pHostInfo->MachineName = L"ACME-Machine-Name";


    NicInfo.fullNicName = L"ACME Full Nic Name";
    NicInfo.adapterGuid = L"8829d17b-b0b7-4ce8-ba50-71af38792a6f";
    NicInfo.friendlyName = L"ACME Friendly Name";

    pHostInfo->nicInformation.push_back(NicInfo);

    NicInfo.fullNicName = L"ACME2 Full Nic Name";
    NicInfo.adapterGuid = L"fa770233-31c3-4475-aa96-1190058d326a";
    NicInfo.friendlyName = L"ACME2 Friendly Name";
    pHostInfo->nicInformation.push_back(NicInfo);

end:

    if (fConnected)
    {
        mfn_disconnect();
    }

    if (!NLBH_SUCCESS(Status))
    {
       if (pHostInfo != NULL) 
       {
            delete pHostInfo;
       }
       pHostInfo = NULL;
    }

    *ppHostInfo = pHostInfo;

    return Status;
}


//
// Configuration operations:
//

UINT
NLBHost::GetClusterConfiguration(
    IN const    WCHAR*                          pNicGuid,
    OUT         PMGR_RAW_CLUSTER_CONFIGURATION  pClusterConfig,
    OUT         UINT *                          pGenerationId
    )
{
    if (s_FatalError) return ERROR_INTERNAL_ERROR;

    mfn_Log(
        L"NLBHost -- getting cluster configuration on NIC (%s).",
        pNicGuid
        );
    *pGenerationId = 1;
    return 0;
}




UINT
NLBHost::SetClusterConfiguration(
    IN const    WCHAR *                         pNicGuid,
    IN const    PMGR_RAW_CLUSTER_CONFIGURATION  pClusterConfig,
    IN          UINT                            GenerationId,
    OUT         UINT *                          pRequestId
    )
{
    if (s_FatalError) return ERROR_INTERNAL_ERROR;

    mfn_Log(
        L"NLBHost -- setting cluster configuration on NIC (%s).",
        pNicGuid
        );
    *pRequestId = 123;

    return STATUS_PENDING;
}



UINT
NLBHost::GetAsyncResult(
    IN          UINT                            RequestId,
    OUT         UINT *                          pGenerationId,
    OUT         UINT *                          pResultCode,
    OUT         _bstr_t *                       pResultText
    )
{
    if (s_FatalError) return ERROR_INTERNAL_ERROR;

    mfn_Log(
        L"NLBHost -- checking result of Async operation %d\n",
        RequestId
        );
    *pGenerationId = 1;
    *pResultCode = 1;
    *pResultText = L"Result";
    return 0;
}


UINT
NLBHost::mfn_connect(
    VOID
    )
{
    UINT Status = ERROR_INTERNAL_ERROR;
	HRESULT hr;
    _bstr_t                serverPath;

    hr = CoCreateInstance(CLSID_WbemLocator, 0, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IWbemLocator, 
                          (LPVOID *) &m_sp_pwl);
 
    if (FAILED(hr))
    {
        mfn_LogHr(L"CoCreateInstance  IWebmLocator failed", hr);
        m_sp_pwl = NULL;
        goto end;
    }

    //

    serverPath =  _bstr_t(L"\\\\") + m_BindString + L"\\root\\microsoftnlb";


    hr = m_sp_pwl->ConnectServer(
            serverPath,
            NULL, // strUser,
            NULL, // strPassword,
            NULL,
            0,
            NULL,
            NULL,
            &m_sp_pws
         );
    // these have been found to be special cases where retrying may help.
    if( ( hr == 0x800706bf ) || ( hr == 0x80070767 ) || ( hr == 0x80070005 )  )
    {
    	int delay = 250; // milliseconds
        int timesToRetry = 20;
    	
        for( int i = 0; i < timesToRetry; ++i )
        {
        	Sleep(delay);
            mfn_Log(L"connectserver recoverable failure, retrying.");
            hr = m_sp_pwl->ConnectServer(
                serverPath,
                NULL, // strUser,
                NULL, // strPassword,
                NULL,
                0,
                NULL,
                NULL,
                &m_sp_pws );
            if( !FAILED( hr) )
            {
                break;
            }
        }
    }
    else if ( hr == 0x80041064 )
    {
        // trying to connect to local machine.  Cannot use credentials.
        mfn_Log(L"Connecting to self.  Retrying without using credentials");
        hr = m_sp_pwl->ConnectServer(
            serverPath,
            NULL,
            NULL,
            0,                                  
            NULL,
            0,
            0,       
            &m_sp_pws 
            );
    }


    if (FAILED(hr))
    {
        mfn_LogHr(L"Error connecting to server", hr);
        m_sp_pws = NULL;
        goto end;
    }
    else
    {
        mfn_Log(L"Successfully connected to server %s", serverPath);
    }

    
    // Set the proxy so that impersonation of the client occurs.
    //
    hr = CoSetProxyBlanket(
            m_sp_pws,
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_DEFAULT,      // RPC_C_AUTHZ_NAME,
            COLE_DEFAULT_PRINCIPAL,   // NULL,
            RPC_C_AUTHN_LEVEL_DEFAULT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            COLE_DEFAULT_AUTHINFO, // NULL,
            EOAC_DEFAULT // EOAC_NONE
            );

    if (FAILED(hr))
    {
        mfn_LogHr(L"Error setting proxy blanket", hr);
        goto end;
    }
    else
    {
        mfn_Log(L"Successfully set up proxy settings.");
    }

    Status = ERROR_SUCCESS;


end:
	if (!NLBH_SUCCESS(Status))
	{
	    if (m_sp_pws != NULL)
	    {
	        // Smart pointer.
	        m_sp_pws = NULL;
	    }

	    if (m_sp_pwl != NULL)
	    {
	        // Smart pointer.
	        m_sp_pwl = NULL;
	    }
    }

    return Status;
}


VOID
NLBHost::mfn_disconnect(
    VOID
    )
{
    mfn_Log(L"Disconnecting from host %s", m_BindString);
    if (m_sp_pws != NULL)
    {
       // Smart pointer
        m_sp_pws = NULL;
    }

    if (m_sp_pwl != NULL)
    {
        // Smart pointer
        m_sp_pwl = NULL;
    }
}


VOID
NLBHost::mfn_InitializeStaticFields(
    VOID
    )
{
    s_FatalError = TRUE;

    // Initialize com.
    //
    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    if ( FAILED(hr) )
    {
        mfn_Log(L"Failed to initialize COM library (hr=0x%08lx)", hr);
        goto end;
    }
    s_ComInitialized = TRUE;


    //
    // Initialize Winsock
    //
    int err = WSAStartup(MAKEWORD(2,2), &s_WsaData);
    mfn_Log(L"Initializing Winsock");
    err = WSAStartup(MAKEWORD(2,2), &s_WsaData);
    if (err) {
        mfn_Log(L"PING_WSASTARTUP_FAILED %d", GetLastError());
        goto end;
    }
    s_WsaInitialized = TRUE;
    s_FatalError = FALSE;


    //
    // Get some WMI interface pointers...
    //
    SCODE sc = CoCreateInstance(
                CLSID_WbemStatusCodeText,
                0,
                CLSCTX_INPROC_SERVER,
                IID_IWbemStatusCodeText,
                (LPVOID *) &s_sp_werr
                );
    if( sc != S_OK )
    {
        s_sp_werr = NULL;
        mfn_Log(L"CoCreateInstance IWbemStatusCodeText failure\n");
    }

end:

    if (s_FatalError)
    {
        mfn_DeinitializeStaticFields();
    }

}

VOID
NLBHost::mfn_DeinitializeStaticFields(
    VOID
    )
{
        if (s_sp_werr != NULL)
        {
            s_sp_werr = NULL; // Smart pointer
        }

        if (s_WsaInitialized)
        {
            mfn_Log(L"Deinitializing Winsock");
            WSACleanup();
            s_WsaInitialized = FALSE;
        }

        if (s_ComInitialized)
        {
            mfn_Log(L"Deinitializing COM");
            CoUninitialize();
            s_ComInitialized = FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\private.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    private.h

Abstract:

    Internal headers


History:

    03/31/01    JosephJ Created

--*/

_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));


#include "nlbhost.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by tmgr.rc
//
#define IDS_HELLO                       1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\nprov.cpp ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost.cpp

Abstract:

    Implementation of class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created

--*/

#include "stdafx.h"
#include "private.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	tmgr.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\nlbhost_ping.cpp ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost_ping.cpp

Abstract:

    Implementation of Ping-related functionality of class NLBHost

    This code is adapted from the "ping" utility.

History:

    03/31/01    JosephJ Created

--*/

#include "stdafx.h"
#include "ipexport.h"
#include "icmpapi.h"
#include "private.h"

#if 0
struct IPErrorTable {
    IP_STATUS  Error;                   // The IP Error
    DWORD ErrorNlsID;                   // NLS string ID
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,         PING_BUF_TOO_SMALL},
    { IP_DEST_NET_UNREACHABLE,  PING_DEST_NET_UNREACHABLE},
    { IP_DEST_HOST_UNREACHABLE, PING_DEST_HOST_UNREACHABLE},
    { IP_DEST_PROT_UNREACHABLE, PING_DEST_PROT_UNREACHABLE},
    { IP_DEST_PORT_UNREACHABLE, PING_DEST_PORT_UNREACHABLE},
    { IP_NO_RESOURCES,          PING_NO_RESOURCES},
    { IP_BAD_OPTION,            PING_BAD_OPTION},
    { IP_HW_ERROR,              PING_HW_ERROR},
    { IP_PACKET_TOO_BIG,        PING_PACKET_TOO_BIG},
    { IP_REQ_TIMED_OUT,         PING_REQ_TIMED_OUT},
    { IP_BAD_REQ,               PING_BAD_REQ},
    { IP_BAD_ROUTE,             PING_BAD_ROUTE},
    { IP_TTL_EXPIRED_TRANSIT,   PING_TTL_EXPIRED_TRANSIT},
    { IP_TTL_EXPIRED_REASSEM,   PING_TTL_EXPIRED_REASSEM},
    { IP_PARAM_PROBLEM,         PING_PARAM_PROBLEM},
    { IP_SOURCE_QUENCH,         PING_SOURCE_QUENCH},
    { IP_OPTION_TOO_BIG,        PING_OPTION_TOO_BIG},
    { IP_BAD_DESTINATION,       PING_BAD_DESTINATION},
    { IP_NEGOTIATING_IPSEC,     PING_NEGOTIATING_IPSEC},
    { IP_GENERAL_FAILURE,       PING_GENERAL_FAILURE}
};
#endif // 0


UINT
NLBHost::mfn_ping(
    VOID
    )
{
    UINT Status = ERROR_SUCCESS;
    LONG inaddr;
    char rgchBindString[1024];

    mfn_Log(L"NLBHost -- pinging (%s).", (LPCWSTR) m_BindString);

    //
    // Convert to ANSI.
    //


    //
    // Resolve to an IP address...
    //
    inaddr = inet_addr(m_BindString);
    if (inaddr == -1L)
    {
        struct hostent *hostp = NULL;
        hostp = gethostbyname(m_BindString);
        if (hostp) {
            unsigned char *pc = (unsigned char *) & inaddr;
            // If we find a host entry, set up the internet address
            inaddr = *(long *)hostp->h_addr;
            mfn_Log(
                L"NLBHost -- resolved to IP address %d.%d.%d.%d.",
                pc[0],
                pc[1],
                pc[2],
                pc[3]
                );
        } else {
            // Neither dotted, not name.
            Status = WSAGetLastError();
            mfn_Log(L"NLBHost -- could not resolve bind address.");
            goto end;
        }
    }

    //
    // Send Icmp echo.
    //
    HANDLE  IcmpHandle;

    IcmpHandle = IcmpCreateFile();
    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        mfn_Log(L"Unable to contact IP driver, error code %d.",Status);
        goto end;
    }

    const int Count = 4;
    const int Timeout = 1000;
    const int MinInterval = 500;

    for (int i = 0; i < Count; i++)
    {
        static BYTE SendBuffer[32];
        BYTE RcvBuffer[1024];
        int  numberOfReplies;
        numberOfReplies = IcmpSendEcho2(IcmpHandle,
                                        0,
                                        NULL,
                                        NULL,
                                        inaddr,
                                        SendBuffer,
                                        sizeof(SendBuffer),
                                        NULL,
                                        RcvBuffer,
                                        sizeof(RcvBuffer),
                                        Timeout
                                        );

        if (numberOfReplies == 0) {

            int errorCode = GetLastError();
            mfn_Log(L"ICMP Error %d", errorCode );

        
            // TODO: look at ping sources for proper error reporting
            // (host unreachable, etc...)

            if (i < (Count - 1)) {
                Sleep(MinInterval);
            }
        }
        else
        {
            mfn_Log(L"Ping succeeded.");
            Status = ERROR_SUCCESS;
            break;
        }
    }

end:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\tmgr.cpp ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost.cpp

Abstract:

    Implementation of class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created

--*/


#include "stdafx.h"
#include "private.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// The one and only application object

CWinApp theApp;


void test(int argc, WCHAR* argv[]);

int __cdecl wmain(int argc, WCHAR* argv[], WCHAR* envp[])
{
	int nRetCode = 0;

	// initialize MFC and print and error on failure
	if (!AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))
	{
		// TODO: change error code to suit your needs
		cerr << L"Fatal Error: MFC initialization failed" << endl;
		nRetCode = 1;
	}
	else
	{
        test(argc, argv);
	}

	return nRetCode;
}


VOID
MyLogger(
    PVOID           Context,
    const   WCHAR * Text
    )
{
    wprintf(L"LOG: %s", Text);
    wprintf(L"\n");
}

void test(int argc, WCHAR* argv[])
{

    WCHAR wszBuf[1024];
    NLBHost * pHost = NULL;
    UINT Status = 0;
    NLBHost::HostInformation *pHostInfo = NULL;

    pHost = new NLBHost(
                    L"JOSEPHJ1C",
                    L"JosephJ's Dev Machine",
                    MyLogger,
                    NULL        // Logger context
                    );
    
    if (pHost == NULL)
    {
        MyLogger(NULL, L"Could not create an instance of NLBHost.");
        goto end;
    }

    Status = pHost->Ping();

    if (!NLBH_SUCCESS(Status)) goto end;


    Status = pHost->GetHostInformation(
                &pHostInfo
                );

    if (!NLBH_SUCCESS(Status))
    {
        pHostInfo = NULL;
        goto end;
    }

    int NumNics = pHostInfo->nicInformation.size();

    wsprintf(
        wszBuf,
        L"Processing host with MachineName %s(NumNics=%d)",
        (LPCWSTR)pHostInfo->MachineName,
        NumNics
        );
    MyLogger(NULL, wszBuf);

    for( int i = 0; i < NumNics; i++)
    {
        NLBHost::NicInformation *pNicInfo;
        MGR_RAW_CLUSTER_CONFIGURATION  ClusterConfig;
        UINT GenerationId;
        UINT RequestId;

        pNicInfo = &pHostInfo->nicInformation[i];
        wsprintf(
            wszBuf,
            L"Processing NIC %s (%s)\n",
            (LPCWSTR) pNicInfo->adapterGuid,
            (LPCWSTR) pNicInfo->friendlyName
            );
        MyLogger(NULL, wszBuf);

        Status =  pHost->GetClusterConfiguration(
                            pNicInfo->adapterGuid,
                            &ClusterConfig,
                            &GenerationId
                            );
        if (!NLBH_SUCCESS(Status))
        {
            // Failure...
            continue;
        }


        Status = pHost->SetClusterConfiguration(
                            pNicInfo->adapterGuid,
                            &ClusterConfig,
                            GenerationId,
                            &RequestId
                            );

        if (NLBH_PENDING(Status))
        {
            INT Delay = 1000; // 1 sec

            // Give some time for the remote host's connectivity to be lost...
            //
            MyLogger(NULL, L"Sleeping for 5 seconds.");
            Sleep(5000);

            // Now wait until we can ping the host, then query for the async
            // result of the SetClusterConfiguration operation.
            // We keep polling for the result, sleeping increasing amounts
            // in between.
            //
            MyLogger(NULL, L"Pinging the host ....");
            while (NLBH_SUCCESS(pHost->Ping()))
            {
                UINT ResultCode;
                _bstr_t ResultText;

                MyLogger(NULL, L"Checking for asynchronous completion...");
                Status =  pHost->GetAsyncResult(
                                    RequestId,
                                    &GenerationId,
                                    &ResultCode,
                                    &ResultText
                                    );
                if (!NLBH_PENDING(Status))
                {
                    break;
                }
                MyLogger(NULL, L"Operation still pending...");
                MyLogger(NULL, L"Waiting to try again ....");
                Sleep(Delay);
                MyLogger(NULL, L"Pinging the host ....");
                Delay *=2;
            }

        }
    }

end:

    if (pHostInfo != NULL)
    {
        delete pHostInfo;
        pHostInfo = NULL;
    }

    if (pHost != NULL)
    {
        delete pHost;
        pHost = NULL;
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mipaddress.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MIPAddressAdmin
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MIPAddress.h"
#include "WTokens.h"
#include "wlbsutil.h"

// checkIfValid
//
bool
MIPAddress::checkIfValid( const _bstr_t&  ipAddrToCheck )
{
    // The validity rules are as follows
    //
    // The first byte (FB) has to be : 0 < FB < 224 && FB != 127
    // Note that 127 is loopback address.
    // hostid portion of an address cannot be zero.
    //
    // class A range is 1 - 126.  hostid portion is last 3 bytes.
    // class B range is 128 - 191 hostid portion is last 2 bytes
    // class C range is 192 - 223 hostid portion is last byte.

    // split up the ipAddrToCheck into its 4 bytes.
    //

    WTokens tokens;
    tokens.init( wstring( ipAddrToCheck ) , L".");
    vector<wstring> byteTokens = tokens.tokenize();
    if( byteTokens.size() != 4 )
    {
        return false;
    }

    int firstByte = _wtoi( byteTokens[0].c_str() );
    int secondByte = _wtoi( byteTokens[1].c_str() );
    int thirdByte = _wtoi( byteTokens[2].c_str() );
    int fourthByte = _wtoi( byteTokens[3].c_str() );

    // check firstByte
    if ( ( firstByte > 0 )
         &&
         ( firstByte < 224 )
         && 
         ( firstByte != 127 )
         )
    {
        // check that host id portion is not zero.
        IPClass ipClass;
        getIPClass( ipAddrToCheck, ipClass );
        switch( ipClass )
        {
            case classA :
                // last three bytes should not be zero.
                if( ( _wtoi( byteTokens[1].c_str() ) == 0 )
                    &&
                    ( _wtoi( byteTokens[2].c_str() )== 0 )
                    &&
                    ( _wtoi( byteTokens[3].c_str() )== 0 )
                    )
                {
                    return false;
                }
                break;

            case classB :
                // last two bytes should not be zero.
                if( ( _wtoi( byteTokens[2].c_str() )== 0 )
                    &&
                    ( _wtoi( byteTokens[3].c_str() )== 0 )
                    )
                {
                    return false;
                }
                break;

            case classC :
                // last byte should not be zero.
                if( _wtoi( byteTokens[3].c_str() ) 
                    == 0 )
                {
                    return false;
                }
                break;

            default :
                // this should not have happened.
                return false;
                break;
        }
                
        return true;
    }
    else
    {
        return false;
    }
}


// getDefaultSubnetMask
//
bool
MIPAddress::getDefaultSubnetMask( const _bstr_t&  ipAddr,
                                 _bstr_t&        subnetMask )
{
    
    // first ensure that the ip is valid.
    //
    bool isValid = checkIfValid( ipAddr );
    if( isValid == false )
    {
        return false;
    }

    // get the class to which this ip belongs.
    // as this determines the subnet.
    IPClass ipClass;

    getIPClass( ipAddr,
                ipClass );

    switch( ipClass )
    {
        case classA :
            subnetMask = L"255.0.0.0";
            break;

        case classB :
            subnetMask = L"255.255.0.0";
            break;

        case classC :
            subnetMask = L"255.255.255.0";
            break;

        default :
                // this should not have happened.
                return false;
                break;
    }

    return true;
}


// getIPClass
//
bool
MIPAddress::getIPClass( const _bstr_t& ipAddr,
                        IPClass&        ipClass )
{

    // get the first byte of the ipAddr
    
    WTokens tokens;
    tokens.init( wstring( ipAddr ) , L".");
    vector<wstring> byteTokens = tokens.tokenize();

    if( byteTokens.size() == 0 )
    {
        return false;
    }

    int firstByte = _wtoi( byteTokens[0].c_str() );

    if( ( firstByte >= 1 )
        &&
        ( firstByte <= 126  )
        )
    {
        // classA
        ipClass = classA;
        return true;
    }
    else if( (firstByte >= 128 )
             && 
             (firstByte <= 191 )
             )
    {
        // classB
        ipClass = classB;
        return true;
    }
    else if( (firstByte  >= 192 )
             && 
             (firstByte <= 223 )
             )
    {
        // classC
        ipClass = classC;
        return true;
    }
    else if( (firstByte  >= 224 )
             && 
             (firstByte <= 239 )
             )
    {
        // classD
        ipClass = classD;
        return true;
    }
    else if( (firstByte  >= 240 )
             && 
             (firstByte <= 247 )
             )
    {
        // classE
        ipClass = classE;
        return true;
    }
    else
    {
        // invalid net portiion.
        return false;
    }
}

    
                        
bool
MIPAddress::isValidIPAddressSubnetMaskPair( const _bstr_t& ipAddress,
                                            const _bstr_t& subnetMask )
{
    if( IsValidIPAddressSubnetMaskPair( ipAddress, subnetMask ) == TRUE )
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool
MIPAddress::isContiguousSubnetMask( const _bstr_t& subnetMask )
{
    if( IsContiguousSubnetMask( subnetMask ) == TRUE )
    {
        return true;
    }
    else
    {
        return false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__DF7B1252_2C62_4552_817F_F912F756FD19__INCLUDED_)
#define AFX_STDAFX_H__DF7B1252_2C62_4552_817F_F912F756FD19__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls

#include <iostream>
#include <comdef.h>
#include <vector>
#include <winsock2.h>

#include <wbemidl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

using namespace std;

#include "resource.h"
#include "wlbsconfig.h"



#endif // !defined(AFX_STDAFX_H__DF7B1252_2C62_4552_817F_F912F756FD19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\meventlog.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MEventLog
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MEventLog.h"
#include "MWmiParameter.h"
#include "MWmiInstance.h"
#include "MTrace.h"

// constructor for remote operations
//
MEventLog::MEventLog( _bstr_t machineIP )
        : _mIP ( machineIP ),
          machine( machineIP,
                   L"root\\cimv2",
                   NLBMGR_USERNAME,
                   NLBMGR_PASSWORD )
{
}

// constructor for local operations
//
MEventLog::MEventLog()
        : _mIP ( L"Not Set"),
          machine( L"root\\cimv2" )
{
}


// copy constructor
//
MEventLog::MEventLog( const MEventLog& obj )
        : _mIP( obj._mIP ),
          machine( machine )
{
}

// assignment operator
//
MEventLog&
MEventLog::operator=(const MEventLog& rhs )
{
    _mIP = rhs._mIP;

    machine = rhs.machine;

    return *this;
}


// destructor
//
MEventLog::~MEventLog()
{
}

// getEvents
//
MEventLog::MEventLog_Error
MEventLog::getEvents( vector< Event >* eventContainer )
{
    MWmiObject::MWmiObject_Error errO;

    vector< MWmiInstance > instanceStore;

    machine.getInstances( L"Win32_NTLogEvent",
                          &instanceStore );

    // set parameters to get.
    vector<MWmiParameter* >   parameterStore;

    MWmiParameter RecordNumber(L"RecordNumber");
    parameterStore.push_back( &RecordNumber );

    MWmiParameter Logfile(L"LogFile");
    parameterStore.push_back( &Logfile );

    MWmiParameter EventIdentifier(L"EventIdentifier");
    parameterStore.push_back( &EventIdentifier );

    MWmiParameter EventCode(L"EventCode");
    parameterStore.push_back( &EventCode );

    MWmiParameter SourceName(L"SourceName");
    parameterStore.push_back( &SourceName );

    MWmiParameter Type(L"Type");
    parameterStore.push_back( &Type );

    MWmiParameter Category(L"Category");
    parameterStore.push_back( &Category );

    MWmiParameter ComputerName(L"ComputerName");
    parameterStore.push_back( &ComputerName );

    MWmiParameter Message(L"Message");
    parameterStore.push_back( &Message );

    MWmiInstance::MWmiInstance_Error errI;
    Event msg;

    for( int i = 0; i < instanceStore.size(); ++i )
    {
        instanceStore[i].getParameters( parameterStore );

        msg.RecordNumber =  long ( RecordNumber.getValue() );
        msg.Logfile = Logfile.getValue();
        msg.EventIdentifier = ( long )EventIdentifier.getValue();
        msg.EventCode = ( long ) EventCode.getValue();
        msg.SourceName = SourceName.getValue();
        msg.Type = Type.getValue();
        msg.Category = ( long ) Category.getValue();
        msg.ComputerName = ComputerName.getValue();
        msg.Message = Message.getValue();

        eventContainer->push_back( msg );
    }

    return MEventLog_SUCCESS;
}

// getEvents
//
MEventLog::MEventLog_Error
MEventLog::getEvents( map< unsigned int, UniqueEvent >& systemEvents,
                      map< unsigned int, UniqueEvent >& applicationEvents ) 
{
    MWmiObject::MWmiObject_Error errO;

    vector< MWmiInstance > instanceStore;

    machine.getInstances( L"Win32_NTLogEvent",
                          &instanceStore );

    // set parameters to get.
    vector<MWmiParameter* >   parameterStore;

    MWmiParameter Logfile(L"LogFile");
    parameterStore.push_back( &Logfile );

    MWmiParameter EventCode(L"EventCode");
    parameterStore.push_back( &EventCode );

    MWmiParameter SourceName(L"SourceName");
    parameterStore.push_back( &SourceName );

    MWmiParameter Type(L"Type");
    parameterStore.push_back( &Type );

    MWmiParameter Category(L"Category");
    parameterStore.push_back( &Category );

    MWmiParameter ComputerName(L"ComputerName");
    parameterStore.push_back( &ComputerName );

    MWmiParameter Message(L"Message");
    parameterStore.push_back( &Message );

    MWmiInstance::MWmiInstance_Error errI;


    for( int i = 0; i < instanceStore.size(); ++i )
    {
        instanceStore[i].getParameters( parameterStore );

        UniqueEvent msg;
        msg.Logfile = Logfile.getValue();
        msg.EventCode = ( long ) EventCode.getValue();
        msg.SourceName = SourceName.getValue();
        msg.Type = Type.getValue();
        msg.Category = ( long ) Category.getValue();
        msg.ComputerName = ComputerName.getValue();
        msg.Message = Message.getValue();

        if( msg.Logfile == _bstr_t( L"Application" ) )
        {
            if( applicationEvents.find( msg.EventCode ) != applicationEvents.end() )
            {
                // this event has occured previously
                applicationEvents[ msg.EventCode ].Count++;
            }
            else
            {
                // first occurence.
                msg.Count = 1;
                applicationEvents[msg.EventCode] = msg;
            }
        }
        else if( msg.Logfile == _bstr_t( L"System") )
        {
            if( systemEvents.find( msg.EventCode ) != systemEvents.end() )
            {
                // this event has occured previously
                systemEvents[ msg.EventCode].Count++;
            }
            else
            {
                // first occurence.
                msg.Count = 1;
                systemEvents[msg.EventCode] = msg;
            }
        }
        else
        {
            cout << "should not be here" << endl;
        }
    }

    return MEventLog_SUCCESS;
}

MEventLog::MEventLog_Error
MEventLog::getEvents(  map< _bstr_t, map< unsigned int, UniqueEvent > >& Events )
{
    MWmiObject::MWmiObject_Error errO;

    vector< MWmiInstance > instanceStore;

    machine.getInstances( L"Win32_NTLogEvent",
                          &instanceStore );

    // set parameters to get.
    vector<MWmiParameter* >   parameterStore;

    MWmiParameter Logfile(L"LogFile");
    parameterStore.push_back( &Logfile );

    MWmiParameter EventCode(L"EventCode");
    parameterStore.push_back( &EventCode );

    MWmiParameter SourceName(L"SourceName");
    parameterStore.push_back( &SourceName );

    MWmiParameter Type(L"Type");
    parameterStore.push_back( &Type );

    MWmiParameter Category(L"Category");
    parameterStore.push_back( &Category );

    MWmiParameter ComputerName(L"ComputerName");
    parameterStore.push_back( &ComputerName );

    MWmiParameter Message(L"Message");
    parameterStore.push_back( &Message );

    MWmiInstance::MWmiInstance_Error errI;

    map< unsigned int, UniqueEvent >::iterator top;
    map< unsigned int, UniqueEvent > temp;

    for( int i = 0; i < instanceStore.size(); ++i )
    {
        instanceStore[i].getParameters( parameterStore );

        UniqueEvent msg;
        msg.Logfile = Logfile.getValue();
        msg.EventCode = ( long ) EventCode.getValue();
        msg.SourceName = SourceName.getValue();
        msg.Type = Type.getValue();
        msg.Category = ( long ) Category.getValue();
        msg.ComputerName = ComputerName.getValue();
        msg.Message = Message.getValue();

        if( Events.find( msg.Logfile ) != Events.end() )
        {
            
            if( ( top = Events[msg.Logfile].find( msg.EventCode )) != Events[msg.Logfile].end() )
            {
                // this event has occured previously
                (*top).second.Count++;
            }
            else
            {
                // first occurence.
                msg.Count = 1;
                (*top).second = msg;
            }
        }
        else
        {
            // first occurence of this logfile
            msg.Count = 1;
            temp[msg.EventCode] = msg;
            Events[msg.Logfile] = temp;
        }
            
    }

    return MEventLog_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mipaddress.h ===
#ifndef _MIPADDRESS_HH
#define _MIPADDRESS_HH


// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intendd publication of such source code.
//
// OneLiner  : Interface for MIPAddress.
// DevUnit   : wlbstest
// Author    : Murtaza Hakim
//
// Description: 
// ------------
// Provides static methods for checking if ip address is valid or not,
// finding subnet, etc.

// Include Files

#include <vector>
#include <wbemidl.h>
#include <comdef.h>

using namespace std;

// Class Definition
class MIPAddress
{
public:

    enum IPClass
    {
        classA,
        classB,
        classC,
        classD,
        classE
    };

    // Description
    // -----------
    // Checks if the ip address supplied is valid.
    //
    // IP address needs to be in dotted decimal 
    // for eg. 192.31.56.2, 128.1.1.1, 1.1.1.1 etc.
    // ip addresses in the form 192.31 are not allowed.
    // There must be exactly four parts.
    //
    //
    // Parameters
    // ----------
    // ipAddrToCheck   in     : ipAddr to check in dotted dec notation.
    //
    // Returns
    // -------
    // true if valid else false.

    static
    bool
    checkIfValid(const _bstr_t&  ipAddrToCheck );

    // Description
    // -----------
    // Gets the default subnet mask for ip address.  The ip address 
    // needs to be valid for operation to be successful.
    //
    // IP address needs to be in dotted decimal 
    // for eg. 192.31.56.2, 128.1.1.1, 1.1.1.1 etc.
    // ip addresses in the form 192.31 are not allowed.
    // There must be exactly four parts.
    //
    // Parameters
    // ----------
    // ipAddress     IN     : ip address for which default subnet required.
    // subnetMask    OUT    : default subnet mask for ip.
    //
    // Returns
    // -------
    // true if able to find default subnet or false if ipAddress was
    // invalid.

    static
    bool
    getDefaultSubnetMask( const _bstr_t& ipAddr,
                          _bstr_t&       subnetMask  );

    // Description
    // -----------
    // Gets the class to which this ip address belongs.
    // class A: 1   - 126
    // class B: 128 - 191
    // class C: 192 - 223
    // class D: 224 - 239
    // class D: 240 - 247
    //
    // IP address needs to be in dotted decimal 
    // for eg. 192.31.56.2, 128.1.1.1, 1.1.1.1 etc.
    // ip addresses in the form 192.31 are not allowed.
    // There must be exactly four parts.
    //
    // Parameters
    // ----------
    // ipAddress     IN     : ip address for which class is to be found.
    // ipClass       OUT    : class to which ip belongs.
    //
    // Returns
    // -------
    // true if able to find class or false if not able to find.
    // 

    static
    bool
    getIPClass( const _bstr_t& ipAddr, 
                IPClass&       ipClass );
    
    static
    bool
    isValidIPAddressSubnetMaskPair( const _bstr_t& ipAddress,
                                    const _bstr_t& subnetMask );

    static
    bool
    isContiguousSubnetMask( const _bstr_t& subnetMask );

private:

};
//------------------------------------------------------
//
//------------------------------------------------------
// Inline Functions
//------------------------------------------------------
//
//------------------------------------------------------
// Ensure Type Safety
//------------------------------------------------------
typedef class MIPAddress MIPAddress;
//------------------------------------------------------
// 
#endif _MIPADDRESS_HH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\meventlog.h ===
#ifndef _MEVENTLOG_HH
#define _MEVENTLOG_HH


// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intendd publication of such source code.
//
// OneLiner  : Interface for MEventLog
// DevUnit   : wlbstest
// Author    : Murtaza Hakim
//
// Description: 
// ------------
// Gets event logs from a remote machine.

// Include Files
#include "MWmiObject.h"

#include <vector>
#include <map>

#include <wbemidl.h>
#include <comdef.h>

using namespace std;



class MEventLog
{
public:
    
    class Event
    {
    public:
        unsigned long      RecordNumber;
        _bstr_t            Logfile;
        unsigned long      EventIdentifier;
        unsigned int       EventCode;
        _bstr_t            SourceName;
        _bstr_t            Type;
        unsigned int       Category;
        _bstr_t            ComputerName;
        _bstr_t            Message;
    };


    class UniqueEvent
    {
    public:
        unsigned long      Count;      // represents how many times event with this eventcode has happened.

        _bstr_t            Logfile;
        unsigned int       EventCode;
        _bstr_t            SourceName;
        _bstr_t            Type;
        unsigned int       Category;
        _bstr_t            ComputerName;
        _bstr_t            Message;
    };

    enum MEventLog_Error
    {
        MEventLog_SUCCESS = 0,
        COM_FAILURE       = 1,
        UNCONSTRUCTED     = 2,
    };

    
    // constructor
    //
    MEventLog( _bstr_t machineIP );

    // constructor for local machine
    //
    MEventLog();

    // copy constructor
    //
    MEventLog( const MEventLog& obj);

    // assignment operator
    //
    MEventLog&
    operator=(const MEventLog& rhs );

    // destructor
    //
    ~MEventLog();

    // gets all event messages on remote machine.
    MEventLog_Error
    getEvents( vector< Event >* eventContainer );

    // gets all event messages on remote machine.
    MEventLog_Error
    getEvents(  map< unsigned int, UniqueEvent >& systemEvents,
                map< unsigned int, UniqueEvent >& applicationEvents ); 

    // gets all event messages on remote machine.
    MEventLog_Error
    getEvents(  map< _bstr_t, map< unsigned int, UniqueEvent > >& Events );


    // refresh connection
    MEventLog_Error
    refreshConnection();
    
private:

    _bstr_t _mIP;

    MWmiObject machine;
};

//------------------------------------------------------
// Ensure Type Safety
//------------------------------------------------------
typedef class MIPAddressAdmin MIPAddressAdmin;
//------------------------------------------------------
// 
#endif _MEVENTLOG_HH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mipaddressadmin.h ===
#ifndef _MIPADDRESSADMIN_HH
#define _MIPADDRESSADMIN_HH


// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intendd publication of such source code.
//
// OneLiner  : Interface for MIPAddressAdmin.
// DevUnit   : wlbstest
// Author    : Murtaza Hakim
//
// Description: 
// ------------
// Manages adding, deleting and querying for IP addresses on 
// a nic using wmi.


// Include Files

#include "MWmiObject.h"
#include "MWmiInstance.h"

#include <vector>
#include <wbemidl.h>
#include <comdef.h>

using namespace std;



// Class Definition
class MIPAddressAdmin
{
public:

    enum MIPAddressAdmin_Error
    {
        MIPAddressAdmin_SUCCESS = 0,
        
        COM_FAILURE = 1,

        UNCONSTRUCTED = 2,

        NO_SUCH_NIC = 3,

        NO_SUCH_IP = 4,

        NOT_SUPPORTED = 5,
    };

    // Description
    // -----------
    // Constructor.
    //
    // Parameters
    // ----------
    // machineIP         IN    : ip of machine to administer.
    // nicName           IN    : name of nic to administer.
    //
    // Returns
    // -------
    // none.
    //

    MIPAddressAdmin( const _bstr_t& machineIP,
                     const _bstr_t& nicName );

    // use this when doing locally.
    //
    MIPAddressAdmin( const _bstr_t& nicName );


    // Description
    // -----------
    // Copy Constructor.
    //
    // Parameters
    // ----------
    // obj    : object to copy.
    //
    // Returns
    // -------
    // none.
    //

    MIPAddressAdmin( const MIPAddressAdmin& obj );


    // Description
    // -----------
    // Assignment operator
    //
    // Parameters
    // ----------
    // rhs    : object to assign.
    //
    // Returns
    // -------
    // self.
    //
    MIPAddressAdmin&
    operator=(const MIPAddressAdmin& rhs );

    // Description
    // -----------
    // Destructor
    //
    //
    // Parameters
    // ----------
    // none
    //
    // Returns
    // -------
    // none.
    //

    ~MIPAddressAdmin();


    // Description
    // -----------
    // Adds IP address to interface.
    //
    // Parameters
    // ----------
    // ipAddrToAdd     in     : ipAddr to add in dotted dec notation.
    // subnetMask      in     : subnet mask in dotted dec notation.
    //
    // Returns
    // -------
    // success else error code.

    MIPAddressAdmin_Error
    addIPAddress(const _bstr_t&  ipAddrToAdd,
                 const _bstr_t&  subnetMask);


    // Description
    // -----------
    // Deletes IP address from interface.
    //
    // Parameters
    // ----------
    // none
    //
    // Returns
    // -------
    // SUCCESS else error code.
    //

    MIPAddressAdmin_Error
    deleteIPAddress( const _bstr_t&  ipAddrToDelete );


    // Description
    // -----------
    // Gets all ip addresses on nic
    //
    // Parameters
    // ----------
    // ipAddress     OUT    : list of ip addresses on nic.
    // subnetMask    OUT    : list of subnet mask for each ip.
    //
    // Returns
    // -------
    // SUCCESS else error code.
    //

    MIPAddressAdmin_Error
    getIPAddresses( vector<_bstr_t>* ipAddress,
                    vector<_bstr_t>* subnetMask );

    // Description
    // -----------
    // Checks whether the nic we are administering
    // has dhcp enabled or not.
    //
    // Parameters
    // ----------
    // dhcpEnabled               OUT   : is set to true if dhcp, else set to false.
    //
    // Returns
    // -------
    // SUCCESS else error code.
    //

    MIPAddressAdmin_Error
    isDHCPEnabled( bool& dhcpEnabled );


    // Description
    // -----------
    // Enables dhcp on this nic.
    //
    // Parameters
    // ----------
    // none.
    //
    // Returns
    // -------
    // SUCCESS else error code.
    //

    MIPAddressAdmin_Error
    enableDHCP();


    // refresh connection
    //

    MIPAddressAdmin_Error
    refreshConnection();

private:

    _bstr_t _machineIP;
    _bstr_t _nicName;


    MIPAddressAdmin_Error status;

    MWmiObject machine;

    MIPAddressAdmin_Error
    checkStatus( vector<MWmiInstance>* nicInstance );

};
//------------------------------------------------------
//
//------------------------------------------------------
// Inline Functions
//------------------------------------------------------
//
//------------------------------------------------------
// Ensure Type Safety
//------------------------------------------------------
typedef class MIPAddressAdmin MIPAddressAdmin;
//------------------------------------------------------
// 
#endif _MIPADDRESSADMIN_HH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mipaddressadmin.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MIPAddressAdmin
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MIPAddressAdmin.h"
#include "MWmiParameter.h"
#include "Mtrace.h"
#include "NICCard.h"

#include <algorithm>
using namespace std;

// constructor for doing remotely.
//
MIPAddressAdmin::MIPAddressAdmin( const _bstr_t& machineIP,
                                  const _bstr_t& nicName )
        : _machineIP( machineIP ),
          _nicName( nicName ),
          machine( machineIP,
                   L"root\\cimv2",
                   NLBMGR_USERNAME,
                   NLBMGR_PASSWORD)
{
}

// constructor for doing things locally.
//
MIPAddressAdmin::MIPAddressAdmin( const _bstr_t& nicName )
        : _machineIP( L"Not Set" ),
          _nicName( nicName ),
          machine( L"root\\cimv2" )
{
}


// copy constructor
//
MIPAddressAdmin::MIPAddressAdmin( const MIPAddressAdmin& obj )
        : _machineIP( obj._machineIP ),
          _nicName( obj._nicName ),
          machine( obj.machine )
{
}

// assignment operator
//
MIPAddressAdmin&
MIPAddressAdmin::operator=(const MIPAddressAdmin& rhs )
{
    _machineIP = rhs._machineIP;
    _nicName = rhs._nicName;
    machine = rhs.machine;

    return *this;
}


// destructor
//
MIPAddressAdmin::~MIPAddressAdmin()
{
}

MIPAddressAdmin::MIPAddressAdmin_Error
MIPAddressAdmin::refreshConnection()
{
    return status;
}

// addIPAddress
//
MIPAddressAdmin::MIPAddressAdmin_Error
MIPAddressAdmin::addIPAddress(const _bstr_t&  ipAddrToAdd,
                              const _bstr_t&  subnetMask)
{
    // do basic verification.
    //
    // ensure that machine specified exists.
    vector<MWmiInstance>      nicInstance;
    checkStatus( &nicInstance );

    // get present ip addresses.
    //
    vector<_bstr_t> ipAddressStore;
    vector<_bstr_t> subnetMaskStore;

    bool dhcpEnabled;
    isDHCPEnabled( dhcpEnabled );
    if( dhcpEnabled == false )
    {
        getIPAddresses( &ipAddressStore,
                        &subnetMaskStore );
    }

    if( find( ipAddressStore.begin(), 
          ipAddressStore.end(), 
          ipAddrToAdd )
        != ipAddressStore.end() )
    {
        // the ip to add already exists.
        // thus just return at this point.
        return MIPAddressAdmin_SUCCESS;
    }
        
    ipAddressStore.push_back( ipAddrToAdd );
    subnetMaskStore.push_back( subnetMask );

    // form the safearray.
    //
    
    // array has one dimension.
    //
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = ipAddressStore.size();

    SAFEARRAY* psaIPAddress  = SafeArrayCreate( VT_BSTR, 1, rgsabound );
    SAFEARRAY* psaSubnetMask = SafeArrayCreate( VT_BSTR, 1, rgsabound );

    long rgIndices;
    HRESULT hr;
    
    for( int i = 0; i < ipAddressStore.size(); ++i )
    {
        rgIndices = i;
        hr = SafeArrayPutElement( psaIPAddress, 
                                  &rgIndices, 
                                  ( wchar_t *) ipAddressStore[i]
                                  );

        hr = SafeArrayPutElement( psaSubnetMask,
                                  &rgIndices, 
                                  ( wchar_t *) subnetMaskStore[i]
                                  );
    }

    // run enable static method.

    VARIANT ipsV;
    VARIANT ipaV;

    VariantInit( &ipsV );
    VariantInit( &ipaV );

    ipaV.parray = psaIPAddress;
    ipaV.vt = VT_ARRAY | VT_BSTR;

    ipsV.parray = psaSubnetMask;
    ipsV.vt = VT_ARRAY | VT_BSTR;

    vector<MWmiParameter *> inputParameters;
    MWmiParameter ipa(L"IPAddress");
    ipa.setValue( ipaV );
    inputParameters.push_back( &ipa );

    MWmiParameter ips(L"SubnetMask");
    ips.setValue( ipsV );
    inputParameters.push_back( &ips );

    // set output parameters
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    nicInstance[0].runMethod(L"EnableStatic",
                             inputParameters,
                             outputParameters );

    VariantClear( &ipsV );
    VariantClear( &ipaV );

//    SafeArrayDestroy( psaIPAddress );
//    SafeArrayDestroy( psaSubnetMask );

    if( long( returnValue.getValue()) == 0 )
    {
        return MIPAddressAdmin_SUCCESS;
    }
    else
    {
        cout << "enablestatic has return " << long( returnValue.getValue() ) << endl;
    #if DBG
    	WCHAR buf[256];
    	wsprintf(buf, L"EnableStatic failed with error 0x%08lx\n", long( returnValue.getValue() ) );
        OutputDebugString(buf);
    #endif // DBG
        return COM_FAILURE;
    }
}

// deleteIPAddress
//
MIPAddressAdmin::MIPAddressAdmin_Error
MIPAddressAdmin::deleteIPAddress(const _bstr_t&  ipAddrToDelete )
{
    // do basic verification.
    //
    // ensure that machine specified exists with nic.
    vector<MWmiInstance> nicInstance;
    checkStatus( &nicInstance );

    // check if dhcp is enabled,
    // if enabled we cannot delete anything
    bool dhcpEnabled;
    isDHCPEnabled( dhcpEnabled );
    if( dhcpEnabled == true )
    {
        return NOT_SUPPORTED;
    }

    // get present ip addresses.
    //
    vector<_bstr_t> ipAddressStore;
    vector<_bstr_t> subnetMaskStore;

    getIPAddresses( &ipAddressStore,
                    &subnetMaskStore );

    // check if ip address to delete exists.
    //
    vector<_bstr_t>::iterator posnToDelete;
    posnToDelete = find( ipAddressStore.begin(), 
                         ipAddressStore.end(), 
                         ipAddrToDelete );
    if( posnToDelete
        == ipAddressStore.end() )
    {
        // the ip to delete does not exist.
        return NO_SUCH_IP;
    }

    // remove this ip.
    vector<_bstr_t> ipAddressNewStore;
    vector<_bstr_t> subnetMaskNewStore;
    bool ipAddrToDeleteFound = false;

    for( int i = 0; i < ipAddressStore.size(); ++i )
    {
        if( ipAddressStore[i] == ipAddrToDelete )
        {
            ipAddrToDeleteFound = true;
        }
        else
        {
            ipAddressNewStore.push_back( ipAddressStore[i] );
            subnetMaskNewStore.push_back( subnetMaskStore[i] );
        }
    }

    if( ipAddrToDeleteFound == false )
    {
        // ip to delete does not exist on
        // this nic.

        return NO_SUCH_IP;
    }

    if( ipAddressNewStore.size() == 0 )
    {
        // the ip to remove is the last ip which exists.
        // thus need to switch to dhcp.
        //

        return enableDHCP();
    }

    // form the safearray.
    // array has one dimension.
    //
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = ipAddressNewStore.size();

    SAFEARRAY* psaIPAddress  = SafeArrayCreate( VT_BSTR, 1, rgsabound );
    SAFEARRAY* psaSubnetMask = SafeArrayCreate( VT_BSTR, 1, rgsabound );

    long rgIndices[1];
    HRESULT hr;
    
    for( int i = 0; i < ipAddressNewStore.size(); ++i )
    {
        rgIndices[0] = i;
        hr = SafeArrayPutElement( psaIPAddress, 
                                  rgIndices, 
                                  ( wchar_t *) ipAddressNewStore[i]
                                  );

        hr = SafeArrayPutElement( psaSubnetMask,
                                  rgIndices, 
                                  ( wchar_t *) subnetMaskNewStore[i]
                                  );
    }

    // run enable static method.

    VARIANT ipsV;
    VARIANT ipaV;

    ipsV.parray = psaSubnetMask;
    ipsV.vt = VT_ARRAY | VT_BSTR;

    ipaV.parray = psaIPAddress;
    ipaV.vt = VT_ARRAY | VT_BSTR;

    vector<MWmiParameter *> inputParameters;
    MWmiParameter ipa(L"IPAddress");
    ipa.setValue( ipaV );
    inputParameters.push_back( &ipa );

    MWmiParameter ips(L"SubnetMask");
    ips.setValue( ipsV );
    inputParameters.push_back( &ips );

    // set output parameters
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    nicInstance[0].runMethod(L"EnableStatic",
                             inputParameters,
                             outputParameters );

    VariantClear( &ipsV );
    VariantClear( &ipaV );

//    SafeArrayDestroy( psaIPAddress );
//    SafeArrayDestroy( psaSubnetMask );

    if( long( returnValue.getValue()) == 0 )
    {
        return MIPAddressAdmin_SUCCESS;
    }
    else
    {
        cout << "enablestatic has return " << long( returnValue.getValue() ) << endl;
        return COM_FAILURE;
    }

    return MIPAddressAdmin_SUCCESS;

}

// getIPAddresses
//
MIPAddressAdmin::MIPAddressAdmin_Error
MIPAddressAdmin::getIPAddresses( vector<_bstr_t>* ipAddress,
                                 vector<_bstr_t>* subnetMask )
{
    // do basic verification.
    //
    // ensure that machine specified exists.
    vector<MWmiInstance> nicInstance;
    checkStatus( &nicInstance );

    // get the present values for ip address and subnet
    //
    vector<MWmiParameter* >   parameterStore;
    MWmiParameter ipsPresent(L"IPSubnet");
    parameterStore.push_back( &ipsPresent );

    MWmiParameter ipaPresent(L"IPAddress");
    parameterStore.push_back( &ipaPresent );

    nicInstance[0].getParameters( parameterStore );

    _variant_t ipsT = ipsPresent.getValue();
    VARIANT    ipsV = ipsT.Detach();

    _variant_t ipaT = ipaPresent.getValue();
    VARIANT    ipaV = ipaT.Detach();

    if (    (ipsV.vt != (VT_ARRAY | VT_BSTR))
        ||  (ipaV.vt != (VT_ARRAY | VT_BSTR)))
    {
        // Ugh, let's pretend we didn't get anything.
        goto end;
    }

    LONG count = ipsV.parray->rgsabound[0].cElements;
    HRESULT hr;

    BSTR* pbstr;
    BSTR* pbstr1;

    if( SUCCEEDED( SafeArrayAccessData( ipaV.parray, ( void **) &pbstr)))
    {
        hr = SafeArrayAccessData( ipsV.parray, (void **) &pbstr1 );

        for( LONG x = 0; x < count; x++ )
        {
            ipAddress->push_back( _bstr_t( pbstr[x] ) );
            subnetMask->push_back( _bstr_t( pbstr1[x] ) );
        }

        hr = SafeArrayUnaccessData( ipsV.parray );
        hr = SafeArrayUnaccessData( ipaV.parray );
    }

end:

    VariantClear( &ipsV );
    VariantClear( &ipaV );

    return MIPAddressAdmin_SUCCESS;
}

// checkStatus
MIPAddressAdmin::MIPAddressAdmin_Error
MIPAddressAdmin::checkStatus( vector<MWmiInstance>* nicInstance )
{
    _bstr_t temp;

    if( _machineIP == _bstr_t( L"Not Set") )
    {
        NICCard::NICCard_Error errN;
        vector< NICCard::Info > nicList;
        errN = NICCard::getNics( &nicList );
        if( errN != NICCard::NICCard_SUCCESS )
        {
            throw _com_error( WBEM_E_NOT_FOUND );
        }

        bool foundNic = false;
        _bstr_t myguid;
        for( int i = 0; i < nicList.size(); ++i )
        {
            if( _bstr_t( nicList[i].fullName.c_str() ) == _nicName )
            {
                // found nic
                foundNic = true;
                myguid = _bstr_t( nicList[i].guid.c_str() );
                break;
            }
        }

        if( foundNic == false )
        {
            throw _com_error( WBEM_E_NOT_FOUND );      
        }

        vector< MWmiInstance >    instanceStore;
        machine.getInstances( L"Win32_NetworkAdapterConfiguration",
                              &instanceStore );
        
        // set parameters to get.
        vector<MWmiParameter* >   parameterStore;
        
        MWmiParameter SettingID(L"SettingID");
        parameterStore.push_back( &SettingID );
        
        for( int i = 0; i < instanceStore.size(); ++i )
        {
            instanceStore[i].getParameters( parameterStore );
            temp = SettingID.getValue();
            
            if( myguid == temp )
            {
                nicInstance->push_back( instanceStore[i] );
                
                return MIPAddressAdmin_SUCCESS;
            }
        }
        
        throw _com_error( WBEM_E_NOT_FOUND );
    }
    else
    {
        //
        // ensure that the nic specified exists.
        //
        MWmiObject machineNlbsNic( _machineIP,
                                   L"root\\microsoftnlb",
                                   NLBMGR_USERNAME,
                                   NLBMGR_PASSWORD);
        
        vector< MWmiInstance >    instanceStoreNlbsNic;
        _bstr_t relPath = 
            L"NlbsNic.FullName=\"" + _nicName + "\"";
        machineNlbsNic.getSpecificInstance( L"NlbsNic",
                                            relPath,
                                            &instanceStoreNlbsNic );
        // set parameters to get.
        vector<MWmiParameter* >   parameterStoreNlbsNic;
        
        MWmiParameter AdapterGuid(L"AdapterGuid");
        parameterStoreNlbsNic.push_back( &AdapterGuid );
        
        instanceStoreNlbsNic[0].getParameters( parameterStoreNlbsNic );
        
        vector< MWmiInstance >    instanceStore;
        machine.getInstances( L"Win32_NetworkAdapterConfiguration",
                              &instanceStore );
        
        // set parameters to get.
        vector<MWmiParameter* >   parameterStore;
        
        MWmiParameter SettingID(L"SettingID");
        parameterStore.push_back( &SettingID );
        
        for( int i = 0; i < instanceStore.size(); ++i )
        {
            instanceStore[i].getParameters( parameterStore );
            temp = SettingID.getValue();
            
            if( _bstr_t( AdapterGuid.getValue() ) == temp )
            {
                nicInstance->push_back( instanceStore[i] );
                
                return MIPAddressAdmin_SUCCESS;
            }
        }
        
        throw _com_error( WBEM_E_NOT_FOUND );
    }
}

// isDHCPEnabled
//
MIPAddressAdmin::MIPAddressAdmin_Error
MIPAddressAdmin::isDHCPEnabled( bool& dhcpEnabled )
{
    
    // do basic verification.
    //
    // ensure that machine specified exists.

    vector<MWmiInstance>      nicInstance;
    checkStatus( &nicInstance );

    // get the present value for DHCPEnabled
    //
    vector<MWmiParameter* >   parameterStore;
    MWmiParameter DHCPEnabled( L"DHCPEnabled" );
    parameterStore.push_back( &DHCPEnabled );
    
    nicInstance[0].getParameters( parameterStore );

    dhcpEnabled = DHCPEnabled.getValue();

    return MIPAddressAdmin_SUCCESS;
}

// enableDHCP
//
MIPAddressAdmin::MIPAddressAdmin_Error
MIPAddressAdmin::enableDHCP()
{
    // do basic verification.
    //
    // ensure that machine specified exists.
    vector<MWmiInstance>      nicInstance;
    checkStatus( &nicInstance );

    bool dhcpEnabled;
    isDHCPEnabled( dhcpEnabled );
    if( dhcpEnabled == true )
    {
        // dhcp is already enabled.
        return MIPAddressAdmin_SUCCESS;
    }

    // set input parameters.
    // no input parameters.
    vector<MWmiParameter *> inputParameters;

    // set output parameters
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    nicInstance[0].runMethod(L"EnableDHCP",
                             inputParameters,
                             outputParameters );

    if( long ( returnValue.getValue() ) == 0 )
    {
        return MIPAddressAdmin_SUCCESS;
    }
    else
    {
        cout << "enablestatic has return " << long( returnValue.getValue() ) << endl;
        return COM_FAILURE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\musingcom.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MUsingCom
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim


// include files

#include "MUsingCom.h"

#include <iostream>

using namespace std;

MUsingCom::MUsingCom( DWORD type )
        : status( MUsingCom_SUCCESS )
{
    HRESULT hr;

    // Initialize com.
    hr = CoInitializeEx(0, type );
    if ( FAILED(hr) )
    {
        cout << "Failed to initialize COM library" << hr << endl;
        status = COM_FAILURE;
    }
}

// destructor
MUsingCom::~MUsingCom()
{
    CoUninitialize();
}    

// getStatus
MUsingCom::MUsingCom_Error
MUsingCom::getStatus()
{
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mtrace.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MWmiInstance
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MTrace.h"
#include <time.h>

// initialize static variables.
//
MTrace* MTrace::_instance = 0;

// constructor
//
MTrace::MTrace()
        : _traceFile( "tracedata.txt"),
          _level( WARNING )
{}


// Instance
//
MTrace*
MTrace::Instance()
{
    if( _instance == 0 )
    {
        _instance = new MTrace;
    }

    return _instance;
}

// Initialize
// traceFile specified.
void
MTrace::Initialize( TraceLevel      level,
                    string          traceFile )
{

    char temp[MAX_MESSAGE_SIZE];

   _traceFile = traceFile;

   FILE* stream = fopen( _traceFile.c_str(), "w");
   if( stream == 0 )
   {
       cout << "not able to initialize trace file " << _traceFile.c_str() << endl;
   }
   else
   {
       fclose( stream );
   }

    _level       = level;
}

// Initialize
// no trace file specified.  Data written to tracedata.txt
void
MTrace::Initialize( TraceLevel      level )
{
   FILE* stream = fopen( _traceFile.c_str(), "w");
   if( stream == 0 )
   {
       cout << "not able to initialize trace file " << _traceFile.c_str() << endl;
   }
   else
   {
       fclose( stream );
   }

    _level       = level;
}

// SendTraceOutput
// wchar interface.
void
MTrace::SendTraceOutput( TraceLevel    level,
                         wstring       traceMessage )
{
    FILE* stream;

    if( level >= _level )
    {

        char temp[ MAX_MESSAGE_SIZE ];
        
        WCharToChar( (unsigned short *) traceMessage.c_str(), wcslen( traceMessage.c_str() ) + 1,
                     temp, MAX_MESSAGE_SIZE );
                 
        FormatOutput( level,
                      temp );
    }            
}


    
// SendTraceOutput
// char interface.
void
MTrace::SendTraceOutput( TraceLevel    level,
                         string        traceMessage )
{
    if( level >= _level )
    {
        FormatOutput( level, traceMessage );
    }            
}


void
MTrace::FormatOutput( TraceLevel level,
                      string     traceMessage )
{
    FILE* stream;
    string levelToPrint;

    switch( level )
    {
        case INFO:
            levelToPrint = "INFO               :";
            break;

        case WARNING:
            levelToPrint = "WARNING            :";
            break;

        case SEVERE_ERROR:
            levelToPrint = "SEVERE_ERROR       :";
            break;

        default :
            levelToPrint = "Unknown Level      :";
            break;
    }

    // get time.
    struct tm when;
    time_t now;

    time( &now );
    when = *( localtime( &now ) );

    // write to standard output
    cout << levelToPrint << asctime( &when ) << traceMessage << endl;


    // write to trace file
    stream = fopen( _traceFile.c_str(), "a+");     
    if( stream == 0 )
    {
        cout << "not able to write trace data to file" << endl;
    }
    else
    {
        fprintf( stream, levelToPrint.c_str() );
        fprintf( stream, asctime( &when )  );
        fprintf( stream, traceMessage.c_str() );
        fclose( stream );
    }
}

// GetLevel
//
MTrace::TraceLevel
MTrace::GetLevel()
{
    return _level;
}

// SetLevel
//
void
MTrace::SetLevel( TraceLevel level)
{
    _level = level;
}


// TRACE
// char version
void
MYTRACE( int lineNum, string fileName, MTrace::TraceLevel level, string  traceMessage )
{
    MTrace* instance = MTrace::Instance();

    // use lineNum information to send to output string.

    char temp[100];
    sprintf( temp, "%d", lineNum );

    string newMessage = fileName + " :" + string( temp ) + " : " + traceMessage;

    instance->SendTraceOutput( level, newMessage );
}

// TRACE
// wchar version
void
MYTRACE( int lineNum, string fileName, MTrace::TraceLevel level, wstring  traceMessage )
{
    MTrace* instance = MTrace::Instance();

    wchar_t temp[100];
    swprintf( temp, L"%d", lineNum );
    
    wchar_t  fileName_wc[1000];

    CharToWChar( (char *) fileName.c_str(), strlen( fileName.c_str() ) + 1,
                 fileName_wc, 1000 );

    wstring newMessage =  wstring( fileName_wc )  + L" :" + wstring( temp ) + L" :" + traceMessage;

    instance->SendTraceOutput( level, newMessage );
}

// utility functions.
//
void
CharToWChar( PCHAR pchCharString, 
                      int iSizeOfCharString, 
                      PWCHAR pwchCharString,
                      int iSizeOfWideCharString )
{
    
    for (int i=0; i<= iSizeOfCharString; i++) 
    {
       pwchCharString[i] = (CHAR)(pchCharString[i]);
    }
}

void
WCharToChar( PWCHAR  pwchWideCharString, 
                      int iSizeOfWCharString, 
                      PCHAR pchCharString,
                      int iSizeOfCharString )
{
    
    for (int i=0; i<= iSizeOfWCharString; i++) 
    {
       pchCharString[i] = (CHAR)(pwchWideCharString[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmidefs.h ===
#ifndef _MWMIDEFS_H
#define _MWMIDEFS_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MWMIDefs interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

// include files
//
#include <wbemidl.h>
#include <comdef.h>

// typedefs for _com_ptr_t

_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));


#define NLBMGR_USERNAME (const BSTR) NULL
#define NLBMGR_PASSWORD (const BSTR) NULL

//
// Ensure type safety

typedef class MWmiInstance WmiInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmierror.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MWmiError
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MWmiError.h"
#include "MTrace.h"

// initialize static variables.
//
MWmiError* MWmiError::_instance = 0;

// constructor
//
MWmiError::MWmiError()
        : pStatus(NULL)
{
    SCODE sc;

    sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
                          IID_IWbemStatusCodeText, (LPVOID *) &pStatus);
    if( sc != S_OK )
    {
        TRACE(MTrace::SEVERE_ERROR, L"CoCreateInstance failure\n");
        throw( WBEM_E_UNEXPECTED );
    }
}


// Instance
//
MWmiError*
MWmiError::Instance()
{
    if( _instance == 0 )
    {
        _instance = new MWmiError;
    }

    return _instance;
}

// GetErrorCodeText
//
MWmiError::MWmiError_Error
MWmiError::GetErrorCodeText( const HRESULT   hr,
                             _bstr_t&  errText )
{
    MWmiError_Error   err;
    SCODE sc;
    BSTR  bstr = 0;
        
    sc = pStatus->GetFacilityCodeText( hr, 
                                       0,
                                       0,
                                       &bstr );
    if( sc != S_OK )
    {
        TRACE(MTrace::SEVERE_ERROR, L"CoCreateInstance failure\n");
        throw( WBEM_E_UNEXPECTED );
    }

    errText = bstr;
     
    SysFreeString( bstr );
    bstr = 0;

    sc = pStatus->GetErrorCodeText( hr, 
                                    0,
                                    0,
                                    &bstr );
    if( sc != S_OK )
    {
        TRACE(MTrace::SEVERE_ERROR, L"CoCreateInstance failure\n");
        throw( WBEM_E_UNEXPECTED );
    }

    errText = errText + L": " + bstr;

    SysFreeString( bstr );
    bstr = 0;

    return MWmiError_SUCCESS;

}

// GetErrorCodeText
//
MWmiError::MWmiError_Error
GetErrorCodeText( const HRESULT hr, _bstr_t& errText )
{
    static MWmiError* wmiErr = MWmiError::Instance();

    return wmiErr->GetErrorCodeText( hr, errText );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\musingcom.h ===
#ifndef _MUSINGCOM_H
#define _MUSINGCOM_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MUsingCom interface
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------


// Include Files
#include <comdef.h>

class MUsingCom
{
public:

    enum MUsingCom_Error
    {
        MUsingCom_SUCCESS = 0,
        
        COM_FAILURE       = 1,
    };


    // constructor
    MUsingCom( DWORD  type = COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    // destructor
    ~MUsingCom();

    //
    MUsingCom_Error
    getStatus();

private:
    MUsingCom_Error status;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mtrace.h ===
#ifndef _MTRACE_H
#define _MTRACE_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MWMIObject interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

// include files
//

#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <windows.h>
#include <winbase.h>
#include <wbemidl.h>
#include <comdef.h>

using namespace std;

//
// use this call to do tracing.
// eg usage. 
// TRACE( MTrace::WARNING, "running out of non paged pool\n");

#define TRACE(traceLevel, traceMessage)  MYTRACE( (__LINE__ ), (__FILE__), (traceLevel), (traceMessage) );

class MTrace
{
public:

    // the trace levels which can be set.
    enum TraceLevel
    {
        FULL_TRACE       = 0,

        INFO             = 1,
        WARNING          = 2,
        SEVERE_ERROR     = 3,

        NO_TRACE         = 100,
    };

    
    // the maximum single message size which can be logged.
    enum
    {
        MAX_MESSAGE_SIZE = 2000,
    };


    //
    // Description:
    // -----------
    // gets instance of MTrace singleton class.
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // the MTrace singleton object.
    
    static MTrace*
    Instance();

    //
    // Description:
    // -----------
    // Initialize.  The trace object will write the trace data to the screen and the traceFile
    // if file is specified.
    // 
    // Parameters:
    // ----------
    // level            IN     :  level  determines what is the high threshold for data to be output.
    // traceFile        IN     :  file to store trace output to.  Any previous file is deleted when call is
    //                            made.
    // 
    // Returns:
    // -------
    // none

    void
    Initialize( TraceLevel         level,
                string            traceFile );


    void
    Initialize( TraceLevel         level );



    //
    // Description:
    // -----------
    // Initializes the objects to which the singleton object will write data to.
    // 
    // Parameters:
    // ----------
    // level            IN     :  level  determines what is the high threshold for data to be output.
    // traceMessage     IN     :  trace message to be logged.
    // 
    // Returns:
    // -------
    // none

    void
    SendTraceOutput( TraceLevel    level,
                     wstring        traceMessage );

    void
    SendTraceOutput( TraceLevel    level,
                     string        traceMessage );


    //
    // Description:
    // -----------
    // Gets the present trace level
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // trace level set.

    TraceLevel
    GetLevel();

    //
    // Description:
    // -----------
    // Sets the trace level.
    // 
    // Parameters:
    // ----------
    // level         IN    : level to set.
    // 
    // Returns:
    // -------
    // none

    void
    SetLevel(TraceLevel level );


protected:
    MTrace();

private:
    static MTrace*   _instance;

    string            _traceFile;

    TraceLevel        _level;

    void
    FormatOutput( TraceLevel level,
                  string     traceMessage );

};

//
// Ensure type safety

typedef class MTrace MTrace;

// helper functions.
//

void
MYTRACE( int lineNum,  string fileName, MTrace::TraceLevel level, string   traceMessage );

void
MYTRACE( int lineNum, string fileName, MTrace::TraceLevel level, wstring  traceMessage );


// utility functions
void
CharToWChar( PCHAR pchCharString, 
                      int iSizeOfCharString, 
                      PWCHAR pwchCharString,
                      int iSizeOfWideCharString );

void
WCharToChar( PWCHAR  pwchWideCharString, 
                      int iSizeOfWCharString, 
                      PCHAR pchCharString,
                      int iSizeOfCharString );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	nlbmanager1.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmierror.h ===
#ifndef _MWMIError_H
#define _MWMIError_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MWmi interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------
// Singleton
//
// include files
//
#include "mwmidefs.h"

#include <wbemidl.h>
#include <comdef.h>

class MWmiError
{
public:

    enum MWmiError_Error
    {
        MWmiError_SUCCESS = 0,
        COM_FAILURE       = 1,
    };
    
    //
    // Description:
    // -----------
    // gets instance of MWmiError singleton class.
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // the MWmiError singleton object.
    
    static MWmiError*
    Instance();

    //
    // Description:
    // -----------
    // gets text corresponding to the HRESULT value.
    // 
    // Parameters:
    // ----------
    // hr          IN     :  error code for which text representation requested.
    // errText     OUT    :  the text corresponding to error code.
    // 
    // Returns:
    // -------
    // MWmiError_SUCCESS else error.
    
    MWmiError_Error
    GetErrorCodeText( const HRESULT  hr, 
                      _bstr_t&  errText );

protected:
    MWmiError();

private:
    static MWmiError*   _instance;

    IWbemStatusCodeTextPtr pStatus;
};

//
// Ensure type safety

typedef class MWmiError MWmiError;


// helper function
//

MWmiError::MWmiError_Error
GetErrorCodeText( const HRESULT hr, _bstr_t& errText );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmiinstance.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MWmiInstance
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MWmiInstance.h"
#include "MTrace.h"
#include "MWmiError.h"
#include "WTokens.h"

#include <iostream>

using namespace std;

// default constructor is purposely left undefined.  No one should use it.

// constructor
//
MWmiInstance::MWmiInstance( 
    const _bstr_t&         objectName,
    const _bstr_t&         path,
    IWbemLocatorPtr    pwl,
    IWbemServicesPtr   pws )
        :
        _objectName( objectName ),
        _path( path ),
        _pwl( pwl ),
        _pws( pws )
{
    TRACE(MTrace::INFO, L"mwmiinstance  constructor\n" );
}


// copy constructor
//
MWmiInstance::MWmiInstance( const MWmiInstance&  obj)
        :
        _path( obj._path ),
        _pwl( obj._pwl ),
        _pws( obj._pws ),
        _objectName( obj._objectName )

{
    TRACE(MTrace::INFO, L"mwmiinstance copy constructor\n" );
}
    

// assignment operator
//
MWmiInstance&
MWmiInstance::operator=( const MWmiInstance& rhs )
{
    _path = rhs._path;
    _pwl = rhs._pwl;
    _pws = rhs._pws;
    _objectName = rhs._objectName;

    TRACE(MTrace::INFO, L"mwmiinstance assignment operator\n" );
    return *this;
}


// destructor
MWmiInstance::~MWmiInstance()
{
    TRACE(MTrace::INFO, L"mwmiinstance destructor\n" );
}


// runMethod
MWmiInstance::MWmiInstance_Error
MWmiInstance::runMethod(    
    const _bstr_t&                     methodToRun,
    const vector<MWmiParameter *>&     inputParameters,
    vector<MWmiParameter *>&           outputParameters
    )
{
    HRESULT            hr;

    _variant_t         v_retVal;
    

    IWbemClassObjectPtr      pwcoClass;
    IWbemClassObjectPtr      pwcoOutput;
    IWbemClassObjectPtr      pwcoInput;
    IWbemClassObjectPtr      pwcoInputInstance;

    hr = _pws->GetObject( _objectName,
                          0,
                          NULL,
                          &pwcoClass,
                          NULL );
    if(  FAILED(hr) )
    {
        TRACE(MTrace::SEVERE_ERROR, L"IWbemServices::GetObject failure\n");
        throw _com_error( hr );
    }

    // check if any input parameters specified.
    if( inputParameters.size() != 0 )
    {

        hr = pwcoClass->GetMethod( methodToRun,
                                   0,
                                   &pwcoInput,
                                   NULL );
        if( FAILED( hr) )
        {
            TRACE(MTrace::SEVERE_ERROR, L"IWbemClassObject::GetMethod failure\n");
            throw _com_error( hr );
        }
        
        hr = pwcoInput->SpawnInstance( 0, &pwcoInputInstance );
        if( FAILED( hr) )
        {
            TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::SpawnInstance failure. Unable to spawn instance.\n" );
            throw _com_error( hr );
        }
        
        for( int i = 0; i < inputParameters.size(); ++i )
        {
            hr = pwcoInputInstance->Put( inputParameters[i]->getName(),
                                         0,
                                         &(inputParameters[i]->getValue() ),
                                         0 );
            
            if( FAILED( hr ) )
            {
                TRACE(MTrace::SEVERE_ERROR, L"IWbemClassObject::Put failure\n");
                throw _com_error( hr );
            }
        }
    }

    // execute method.
    hr = _pws->ExecMethod( _path,
                           methodToRun,
                           0, 
                           NULL, 
                           pwcoInputInstance,
                           &pwcoOutput, 
                           NULL);                          
    if( FAILED( hr) )
    {
        TRACE(MTrace::SEVERE_ERROR, L"IWbemServices::ExecMethod failure\n");
        throw _com_error( hr );
    }

    // get output parameters
    for( int i = 0; i < outputParameters.size(); ++i )
    {
        hr = pwcoOutput->Get(  outputParameters[i]->getName(),
                               0,
                               &v_retVal,
                               NULL,
                               NULL );
        if( FAILED( hr) )
        {
            TRACE(MTrace::SEVERE_ERROR, L"IWbemClassObject::Get failure\n");
            throw _com_error( hr );
        }

        outputParameters[i]->setValue( v_retVal );

        v_retVal.Clear();
    }

    return MWmiInstance_SUCCESS;
}

// getParameters
//
MWmiInstance::MWmiInstance_Error
MWmiInstance::getParameters( vector<MWmiParameter *>& parametersToGet )
{
    HRESULT     hr;

    IEnumWbemClassObjectPtr  pewco;
    IWbemClassObjectPtr      pwco;

    unsigned long         count;

    _variant_t            v_path;

    bool found;

    CIMTYPE   vtype;

    _variant_t   v_value;

    // get object corresponding to this path.
    hr = _pws->GetObject( _path,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pwco,
                          NULL );
    if(  hr == 0x8004100c || hr == 0x8004100a )
    {
        TRACE(MTrace::INFO, L"as this is not supported, trying different mechanism\n");

        hr = _pws->CreateInstanceEnum( _objectName,
                                      WBEM_FLAG_RETURN_IMMEDIATELY,
                                      NULL,
                                      &pewco );
        if ( FAILED(hr))
        {
            TRACE(MTrace::SEVERE_ERROR, L"IWbemServices::CreateInstanceEnum failure\n");
            throw _com_error( hr );
        }

        // there may be multiple instances.
        count = 1;
        while ( (hr = pewco->Next( INFINITE,
                                   1,
                                   &pwco,
                                   &count ) )  == S_OK )
        {
            hr = pwco->Get( _bstr_t(L"__RELPATH"), 0, &v_path, NULL, NULL );
            if( FAILED(hr) )
            {
                TRACE(MTrace::SEVERE_ERROR, L"IWbemServices::CreateInstanceEnum failure\n");
                throw _com_error( hr );
            }

            if( _bstr_t( v_path ) == _path )
            {
                // required instance found
                found = true;
                v_path.Clear();
                break;
            }
        
            count = 1;
            
            v_path.Clear();
        }

        if( found == false )
        {
            TRACE( MTrace::SEVERE_ERROR, "unable to find instance with path specified\n");
            throw _com_error( WBEM_E_NOT_FOUND );
        }
    }
    else if ( FAILED(hr) )
    {
        TRACE( MTrace::SEVERE_ERROR, L"IWbemServices::GetObject failure\n");
        throw _com_error( hr );
    }

    for( int i = 0; i < parametersToGet.size(); ++i )
    {
        hr = pwco->Get( parametersToGet[i]->getName(),
                        0,
                        &v_value,
                        &vtype,
                        NULL );
        if( FAILED( hr ) )
        {
            TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::Get failure\n");
            throw _com_error(hr);
        }

        parametersToGet[i]->setValue( v_value );
        v_value.Clear();
    }

    return MWmiInstance_SUCCESS;
}    

// setParameters
//
MWmiInstance::MWmiInstance_Error
MWmiInstance::setParameters( const vector<MWmiParameter *>& parametersToSet )
{
    HRESULT     hr;
    IWbemClassObjectPtr pwco = NULL;

    _variant_t   v_value;

    // get object corresponding to this path.
    hr = _pws->GetObject( _path,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pwco,
                          NULL );
    if( FAILED( hr ) )
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemServices::GetObject failure\n");
        throw _com_error( hr );
    }

    for( int i = 0; i < parametersToSet.size(); ++i )
    {
        v_value = parametersToSet[i]->getValue();

        hr = pwco->Put( parametersToSet[i]->getName(),
                        0,
                        &v_value,
                        NULL );
        if( FAILED( hr ) )
        {
            TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::Get failure\n");
            throw _com_error( hr );
        }
        
        v_value.Clear();
    }

    hr = _pws->PutInstance( pwco,
                            WBEM_FLAG_UPDATE_ONLY,
                            NULL,
                            NULL );
    if( FAILED(hr) )
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemServices::PutInstance failure\n");
        throw _com_error( hr );
    }
    
    return MWmiInstance_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmiparameter.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MWmiParameter
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MWmiParameter.h"

// constructor
//
MWmiParameter::MWmiParameter( const _bstr_t& name )
        : _name( name )
{}


// destructor
//
MWmiParameter::~MWmiParameter()
{
    _value.Clear();
}

// copy constructor
//
MWmiParameter::MWmiParameter( const MWmiParameter& obj )
        : _name( obj._name ),
          _value( obj._value )
{
}

// assignment operator
//
MWmiParameter&
MWmiParameter::operator=( const MWmiParameter& rhs )
{
    _name = rhs._name;

    _value.Clear();

    _value = rhs._value;

    return (*this);
}


// setValue
//
void
MWmiParameter::setValue( const _variant_t& value )
{
    _value.Clear();

    _value = value;
}

// getValue
//
_variant_t
MWmiParameter::getValue()
{
    return _value;
}

// getName
//
_bstr_t
MWmiParameter::getName()
{
    return _name;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmiinstance.h ===
#ifndef _MWMIINSTANCE_H
#define _MWMIINSTANCE_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MWMIInstance interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

// include files
//

#include "MWmiInstance.h"
#include "MWmiParameter.h"
#include "MWmiDefs.h"

#include <vector>
#include <wbemidl.h>
#include <comdef.h>

class MWmiObject;

using namespace std;

class MWmiInstance
{
public:
    enum MWmiInstance_Error
    {
        MWmiInstance_SUCCESS      = 0,

        NO_SUCH_OBJECT            = 1,
        NO_SUCH_METHOD            = 2,
        COM_FAILURE               = 3,
        NO_SUCH_INPUT_PARAMETER   = 4,
        NO_SUCH_OUTPUT_PARAMETER  = 5,
        NO_SUCH_PARAMETER         = 6,
    };


    //
    // Description:
    // -----------
    // default constructor is purposely left undefined.  No one should use it.
    // 
    // Parameters:
    // ----------
    // none
    //
    // Returns:
    // -------
    // none.

    MWmiInstance();

    //
    // Description:
    // -----------
    // copy constructor.
    // 
    // Parameters:
    // ----------
    // obj               IN  : object to copy
    //
    // Returns:
    // -------
    // none.

    MWmiInstance( const MWmiInstance&  obj);


    //
    // Description:
    // -----------
    // assignment operator.
    // 
    // Parameters:
    // ----------
    // rhs                     IN  : obj to assign.
    // 
    // Returns:
    // -------
    // self.

    MWmiInstance&
    operator=( const MWmiInstance& rhs );

    //
    // Description:
    // -----------
    // destructor.
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // none

    ~MWmiInstance();

    //
    // Description:
    // -----------
    // executes a method on the instance.
    // 
    // Parameters:
    // ----------
    // methodToRun        IN   : method to run
    // inputParameters    IN   : input parameters to method.
    // outputParameters   IN   : output parameters of interest.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MWmiInstance_Error
    runMethod(
        const _bstr_t&                     methodToRun,
        const vector<MWmiParameter *>&     inputParameters,
        vector<MWmiParameter *>&           outputParameters
        );


    //
    // Description:
    // -----------
    // gets parameters of an instance.
    // 
    // Parameters:
    // ----------
    // parametersToGet    IN   : parameters of interest to get.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MWmiInstance_Error
    getParameters( vector<MWmiParameter *>& parametersToGet );

    //
    // Description:
    // -----------
    // sets parameters of an instance.
    // 
    // Parameters:
    // ----------
    // parametersToSet    IN   : parameters of interest to set.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MWmiInstance_Error
    setParameters( const vector<MWmiParameter *>& parametersToSet );

private:
    _bstr_t          _path;
    IWbemServicesPtr    _pws;
    IWbemLocatorPtr     _pwl;
    _bstr_t          _objectName;

    //
    // Description:
    // -----------
    // private constructor.  Only MWmiObject can construct us.
    // 
    // Parameters:
    // ----------
    // objectName              IN      : name of class.
    // path                    IN      : path to class
    // pwl                     IN      : wmi locator
    // pws                     IN      : wmi services
    // 
    // Returns:
    // -------
    // none.

    MWmiInstance( const _bstr_t&         objectName,
                  const _bstr_t&         path,
                  IWbemLocatorPtr    pwl,
                  IWbemServicesPtr   pws );


    friend MWmiObject;
};

//
// Ensure type safety

typedef class MWmiInstance WmiInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmiparameter.h ===
#ifndef _MWMIPARAMETER_H
#define _MWMIPARAMETER_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MWmiParameter interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

// include files
//

#include <comdef.h>
#include <vector>
using namespace std;

class MWmiParameter
{
public:

    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // name                      IN      : name of parameter corresponding to a wmi object.
    // 
    // Returns:
    // -------
    // none.

    MWmiParameter( const _bstr_t& name );

    // destructor
    ~MWmiParameter();

    // copy constructor
    MWmiParameter( const MWmiParameter& obj );

    // assignment operato
    MWmiParameter&
    operator=( const MWmiParameter& rhs );

    //
    // Description:
    // -----------
    // sets the parameters value.
    // 
    // Parameters:
    // ----------
    // value                      IN      : parameters associated value.
    // 
    // Returns:
    // -------
    // none.

    void
    setValue( const _variant_t& value );


    //
    // Description:
    // -----------
    // gets the parameters value.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // gets the parameters associated value.

    _variant_t
    getValue();

    //
    // Description:
    // -----------
    // gets the parameters name
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // gets the parameters name corresponding to a member of a wmi object.

    _bstr_t
    getName();

private:
    _bstr_t          _name;
    _variant_t       _value;

};


//
// Ensure type safety

typedef class MWmiParameter MWmiParameter;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmiobject.h ===
#ifndef _MWMIOBJECT_H
#define _MWMIOBJECT_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MWmiObject interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

// include files
//

#include "MWMIInstance.h"
#include "MWMIDefs.h"

#include <wbemidl.h>
#include <comdef.h>

#include <vector>
using namespace std;


class MWmiObject
{
public:

    enum MWmiObject_Error
    {
        MWmiObject_SUCCESS   = 0,

        CONNECT_FAILED       = 1,
        COM_FAILURE          = 2,

        NO_SUCH_OBJECT       = 3,
        NO_SUCH_PARAMETER    = 4,

        NO_SUCH_PATH         = 5,
    };


    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // ipAddr                      IN      : ip address of machine to contact.
    // nameSpace                   IN      : namespace to connect to.
    // loginName                   IN      : name to log as.
    // passWord                    IN      : password to use.
    // 
    // Returns:
    // -------
    // none.
    
    MWmiObject( const _bstr_t& ipAddr,
                const _bstr_t& nameSpace,
                const _bstr_t& loginName,
                const _bstr_t& passWord );

    //
    // Description:
    // -----------
    // constructor for connecting to local machine.
    // 
    // Parameters:
    // ----------
    // nameSpace                   IN      : namespace to connect to.
    // 
    // Returns:
    // -------
    // none.
    
    MWmiObject( const _bstr_t& nameSpace );


    //
    // Description:
    // -----------
    // copy constructor.
    // 
    // Parameters:
    // ----------
    // mwmiobj             IN  :  object to copy.
    // 
    // Returns:
    // -------
    // none.

    MWmiObject( const MWmiObject& mwmiobj );


    //
    // Description:
    // -----------
    // assignment operator.
    // 
    // Parameters:
    // ----------
    // rhs                     IN  : obj to assign.
    // 
    // Returns:
    // -------
    // self.

    MWmiObject&
    MWmiObject::operator=(const MWmiObject& rhs );


    //
    // Description:
    // -----------
    // destructor.
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // none

    ~MWmiObject();


    //
    // Description:
    // -----------
    // gets instances of a particular class.
    // 
    // Parameters:
    // ----------
    // objectToGetInstancesOf           IN  :  class whose instances to be retrieved.
    // instanceStore                    OUT :  vector containing instances.
    // 
    // Returns:
    // -------
    // SUCCESS else errorcode

    MWmiObject_Error
    getInstances( 
        const _bstr_t&           objectToGetInstancesOf,
        vector< MWmiInstance >*  instanceStore );


    //
    // Description:
    // -----------
    // gets instances of a particular class having specific __RELPATH
    // 
    // Parameters:
    // ----------
    // objectToGetInstancesOf           IN  :  class whose instances to be retrieved.
    // relPath                          IN  :  instances __RELPATH
    // instanceStore                    OUT :  vector containing instances.
    // 
    // Returns:
    // -------
    // SUCCESS else errorcode

    MWmiObject_Error
    getSpecificInstance( 
        const _bstr_t&           objectToGetInstancesOf,
        const _bstr_t&           relPath,
        vector< MWmiInstance >*  instanceStore );

    //
    // Description:
    // -----------
    // gets instances of a particular class having specific __RELPATH
    // 
    // Parameters:
    // ----------
    // objectToGetInstancesOf           IN  :  class whose instances to be retrieved.
    // query                            IN  :  the query to be run.
    // instanceStore                    OUT :  vector containing instances.
    // 
    // Returns:
    // -------
    // SUCCESS else errorcode

    MWmiObject_Error
    getQueriedInstances( 
        const _bstr_t&           objectToGetInstancesOf,
        const _bstr_t&           query,
        vector< MWmiInstance >*  instanceStore );

    //
    // Description:
    // -----------
    // creates instance of a particular class.
    // 
    // Parameters:
    // ----------
    // objectToCreateInstancesOf           IN  :  class whose instances to be created
    // instanceParameters                  IN  :  parameters for the instance to be created.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MWmiObject_Error
    createInstance( 
        const _bstr_t&              objectToCreateInstancesOf,
        vector<MWmiParameter *>&    instanceParameters );
//        MWmiInstance*              instanceCreated );

    //
    // Description:
    // -----------
    // deletes instance.
    // 
    // Parameters:
    // ----------
    // instanceToDelete      IN  : instance to delete.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MWmiObject_Error
    deleteInstance( MWmiInstance& instanceToDelete );

    //
    // Description:
    // -----------
    // gets status of object.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.
    
    MWmiObject_Error
    getStatus();
    
private:

    enum
    {
        timesToRetry = 20,
    };


    IWbemLocatorPtr        pwl;
    IWbemServicesPtr       pws;

    _bstr_t                _nameSpace;
    
    MWmiObject_Error       status;

    MWmiObject_Error
    getPath( const _bstr_t& objectToRunMethodOn,
             vector<_bstr_t> *pathStore );

    MWmiObject_Error
    getSpecificPath( const _bstr_t& objectToRunMethodOn,
                     const _bstr_t& relPath,
                     vector<_bstr_t> *pathStore );

    MWmiObject_Error
    getQueriedPath( const _bstr_t&           objectToRunMethodOn,
                    const _bstr_t&           query,
                    vector<_bstr_t>*         pathStore );

    HRESULT 
    MWmiObject::betterConnectServer(
        const BSTR strNetworkResource, 
        const BSTR strUser,
        const BSTR strPassword,
        const BSTR strLocale,
        LONG lSecurityFlags,
        const BSTR strAuthority,
        IWbemContext *pCtx, 
        IWbemServices **ppNamespace 
        );



};

//
// Ensure type safety

typedef class MWmiObject MWmiObject;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\mwmiobject.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MWmiObject
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MWmiObject.h"

#include "MWmiError.h"
#include "mtrace.h"

using namespace std;



// constructor
//
MWmiObject::MWmiObject( const _bstr_t& ipAddr,
                        const _bstr_t& nameSpace,
                        const _bstr_t& loginName,
                        const _bstr_t& passWord )
        :
        _nameSpace( nameSpace )
{
    HRESULT hr;

    hr = CoCreateInstance(CLSID_WbemLocator, 0, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IWbemLocator, 
                          (LPVOID *) &pwl);
 
    if (FAILED(hr))
    {
        TRACE( MTrace::SEVERE_ERROR, "CoCreateInstance failure\n");
        throw _com_error( hr );
    }

    //
    _bstr_t                serverPath;

    serverPath =  _bstr_t(L"\\\\") + ipAddr +  _bstr_t(L"\\") + nameSpace;

    betterConnectServer(
          serverPath,
          loginName,
          passWord,
          0,                                  
          NULL,
          0,
          0,                                  
          &pws
          );
    
    // Set the proxy so that impersonation of the client occurs.
    //
    CoSetProxyBlanket(pws,
                      RPC_C_AUTHN_WINNT,
                      RPC_C_AUTHZ_DEFAULT,      // RPC_C_AUTHZ_NAME,
                      COLE_DEFAULT_PRINCIPAL,   // NULL,
                      RPC_C_AUTHN_LEVEL_DEFAULT,
                      RPC_C_IMP_LEVEL_IMPERSONATE,
                      COLE_DEFAULT_AUTHINFO, // NULL,
                      EOAC_DEFAULT // EOAC_NONE
                      );

    TRACE(MTrace::INFO, L"mwmiobject constructor\n" );
}

// constructor
//
MWmiObject::MWmiObject( const _bstr_t& nameSpace )
        :
          _nameSpace( nameSpace )
{
    HRESULT hr;

//    hr = CoCreateInstance(CLSID_WbemLocator, 0, 
    hr = CoCreateInstance(CLSID_WbemUnauthenticatedLocator, 0, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IWbemLocator, 
                          (LPVOID *) &pwl);
    if (FAILED(hr))
    {
        TRACE( MTrace::SEVERE_ERROR, "CoCreateInstance failure\n");
        throw _com_error( hr );
    }

    betterConnectServer(
        nameSpace,
        NULL,
        NULL,
        0,                                  
        NULL,
        0,
        0,                                  
        &pws
        );

    // Set the proxy so that impersonation of the client occurs.
    //
    CoSetProxyBlanket(pws,
                      RPC_C_AUTHN_WINNT,
                      RPC_C_AUTHZ_NAME,
                      NULL,
                      RPC_C_AUTHN_LEVEL_DEFAULT,
                      RPC_C_IMP_LEVEL_IMPERSONATE,
                      NULL,
                      EOAC_NONE
                      );
    TRACE(MTrace::INFO, L"mwmiobject constructor\n" );
}    

// copy constructor
//
MWmiObject::MWmiObject( const MWmiObject& obj )
        : status( obj.status ),
          pwl( obj.pwl ),
          pws( obj.pws ),
          _nameSpace( obj._nameSpace )
{
    TRACE(MTrace::INFO, L"mwmiobject copy constructor\n" );
}

// assignment operator
//
MWmiObject&
MWmiObject::operator=(const MWmiObject& rhs )
{
    status = rhs.status;

    _nameSpace = rhs._nameSpace;

    pwl = rhs.pwl;
    pws = rhs.pws;

    TRACE(MTrace::INFO, L"mwmiobject assignment operator\n" );
    return *this;
}


    
// destructor
//
MWmiObject::~MWmiObject()
{
    TRACE(MTrace::INFO, L"mwmiobject destructor\n" );
}

// getInstances
//
MWmiObject::MWmiObject_Error
MWmiObject::getInstances( 
    const _bstr_t&          objectToGetInstancesOf,
    vector< MWmiInstance >* instanceStore )
{
    vector<_bstr_t>       pathStore;

    // get paths to all instances.
    getPath( objectToGetInstancesOf,
             &pathStore );

    // form instances
    for( int i = 0; i < pathStore.size(); ++i )
    {
        instanceStore->push_back( MWmiInstance( objectToGetInstancesOf,
                                                pathStore[i],
                                                pwl,
                                                pws ) );
    }

    return MWmiObject_SUCCESS;
}

// getSpecificInstance
//
MWmiObject::MWmiObject_Error
MWmiObject::getSpecificInstance( 
    const _bstr_t&          objectToGetInstancesOf,
    const _bstr_t&          relPath,
    vector< MWmiInstance >* instanceStore )
{

    vector<_bstr_t>       pathStore;

    // get paths to all instances.
    getSpecificPath( objectToGetInstancesOf,
                     relPath,
                     &pathStore );

    // form instances
    for( int i = 0; i < pathStore.size(); ++i )
    {
        instanceStore->push_back( MWmiInstance( objectToGetInstancesOf,
                                                pathStore[i],
                                                pwl,
                                                pws ) );

    }

    return MWmiObject_SUCCESS;
}

// getQueriedInstances
// 
MWmiObject::MWmiObject_Error
MWmiObject::getQueriedInstances( const _bstr_t&           objectToGetInstancesOf,
                                 const _bstr_t&           query,
                                 vector< MWmiInstance >*  instanceStore )
{
    vector<_bstr_t>       pathStore;

    // get paths to all instances.
   getQueriedPath( objectToGetInstancesOf,
                   query,
                   &pathStore );

    // form instances
    for( int i = 0; i < pathStore.size(); ++i )
    {
        instanceStore->push_back( MWmiInstance( objectToGetInstancesOf,
                                                pathStore[i],
                                                pwl,
                                                pws ) );

    }

    return MWmiObject_SUCCESS;
}


// getPath
//
MWmiObject::MWmiObject_Error
MWmiObject::getPath( const _bstr_t& objectToRunMethodOn,
                     vector<_bstr_t> *pathStore )
{

    HRESULT        hr;

    IEnumWbemClassObjectPtr  pewco;
    IWbemClassObjectPtr      pwco; 

    _variant_t            v_path;
    
    unsigned long         count;

    // get instances of object
    //
    hr = pws->CreateInstanceEnum( objectToRunMethodOn,
                                  WBEM_FLAG_RETURN_IMMEDIATELY,
                                  NULL,
                                  &pewco );
    if ( FAILED(hr))
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemServices::CreateInstanceEnum failure\n" );
        throw _com_error( hr ) ;
    }

    // there may be multiple instances.

#if 1
    // Set the proxy so that impersonation of the client occurs.
    //
    CoSetProxyBlanket(pewco,
                      RPC_C_AUTHN_WINNT,
                      RPC_C_AUTHZ_NAME,
                      NULL,
                      RPC_C_AUTHN_LEVEL_DEFAULT,
                      RPC_C_IMP_LEVEL_IMPERSONATE,
                      NULL,
                      EOAC_NONE
                      );

    count = 1;
    while ( (hr = pewco->Next( INFINITE,
                               1,
                               &pwco,
                               &count ) )  == S_OK )
    {
        hr = pwco->Get( _bstr_t(L"__RELPATH"), 0, &v_path, NULL, NULL );
        if( FAILED(hr) )
        {
            TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::Get failure\n" );
            throw _com_error( hr );
        }

        pathStore->push_back( _bstr_t(v_path) );

        count = 1;
     
        v_path.Clear();
    }

#endif

#if 0
    count = 1;
    hr = WBEM_S_NO_ERROR;

    while ( hr == WBEM_S_NO_ERROR )
    {
        hr = pewco->Next( INFINITE,
                          1,
                          &pwco,
                          &count );
        if( FAILED( hr ) )
        {
            TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::Get failure\n" );
            _bstr_t errText;
            GetErrorCodeText( hr, errText );
            throw _com_error( hr );
        }

        HRESULT hrGet;
        hrGet = pwco->Get( _bstr_t(L"__RELPATH"), 0, &v_path, NULL, NULL );
        if( FAILED(hrGet ) )
        {
            TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::Get failure\n" );
            throw _com_error( hrGet );
        }

        pathStore->push_back( _bstr_t(v_path) );

        count = 1;
     
        v_path.Clear();
    }

#endif

    return MWmiObject_SUCCESS;
}

// getSpecificPath
//
MWmiObject::MWmiObject_Error
MWmiObject::getSpecificPath( const _bstr_t& objectToRunMethodOn,
                             const _bstr_t& relPath, 
                             vector<_bstr_t> *pathStore )
{

    HRESULT        hr;

    IWbemClassObjectPtr      pwcoInstance;

    IEnumWbemClassObjectPtr  pewco;
    IWbemClassObjectPtr      pwco;

    unsigned long         count;

    _variant_t            v_path;

    bool found;

    int i;
    
    _variant_t   v_value;

    hr = pws->GetObject( relPath,
                         0,
                         NULL,
                         &pwcoInstance,
                         NULL );
    if(  hr == 0x8004100c )
    {
        // this is for setting class instances.
        //
        TRACE(MTrace::INFO, L"as this is not supported, trying different mechanism\n");
        hr = pws->CreateInstanceEnum( objectToRunMethodOn,
                                      WBEM_FLAG_RETURN_IMMEDIATELY,
                                      NULL,
                                      &pewco );
        if ( FAILED(hr))
        {
            TRACE(MTrace::SEVERE_ERROR, L"IWbemServices::CreateInstanceEnum failure\n");
            throw _com_error( hr );
        }

        // there may be multiple instances.
        count = 1;
        while ( (hr = pewco->Next( INFINITE,
                                   1,
                                   &pwco,
                                   &count ) )  == S_OK )
        {
            hr = pwco->Get( _bstr_t(L"__RELPATH"), 0, &v_path, NULL, NULL );
            if ( FAILED(hr))
            {
                TRACE(MTrace::SEVERE_ERROR, L"IWbemClassObject::Get failure\n");
                throw _com_error( hr );
            }

            if( _bstr_t( v_path ) == relPath )
            {
                // required instance found
                found = true;

                v_path.Clear();
                break;
            }
        
            count = 1;
            
            v_path.Clear();
        }

        if( found == false )
        {
            TRACE( MTrace::SEVERE_ERROR, "unable to find instance with path specified\n");
            throw _com_error( WBEM_E_INVALID_OBJECT_PATH );
        }
    }
    else if( FAILED (hr) )
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemServices::GetObject failure\n");
        throw _com_error( hr );
    }

    pathStore->push_back( relPath );

    return MWmiObject_SUCCESS;    
}

// getQueriedPath
//
MWmiObject::MWmiObject_Error
MWmiObject::getQueriedPath( const _bstr_t&   objectToRunMethodOn,
                             const _bstr_t&   query,
                            vector<_bstr_t>* pathStore )
{

    HRESULT        hr;

    IEnumWbemClassObjectPtr  pewco;
    IWbemClassObjectPtr      pwco; 

    _variant_t            v_path;
    
    unsigned long         count;

    // get instances of object
    //
    hr = pws->ExecQuery( L"WQL",
                         query,
                         WBEM_FLAG_FORWARD_ONLY,
                         NULL,
                         &pewco );
    if ( FAILED(hr))
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemServices::CreateInstanceEnum failure\n" );
        throw _com_error( hr ) ;
    }

    // there may be multiple instances.
    count = 1;
    while ( (hr = pewco->Next( INFINITE,
                               1,
                               &pwco,
                               &count ) )  == S_OK )
    {
        hr = pwco->Get( _bstr_t(L"__RELPATH"), 0, &v_path, NULL, NULL );
        if( FAILED(hr) )
        {
            TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::Get failure\n" );
            throw _com_error( hr );
        }

        pathStore->push_back( _bstr_t(v_path) );

        count = 1;
     
        v_path.Clear();
    }

    return MWmiObject_SUCCESS;
}


// createInstance
//
MWmiObject::MWmiObject_Error
MWmiObject::createInstance(
    const _bstr_t&                    objectToCreateInstancesOf,
    vector<MWmiParameter *>&    instanceParameters )
//        MWmiInstance*              instanceCreated )
{
    HRESULT  hr;

    IWbemStatusCodeText  *pStatus = NULL;

    IWbemClassObjectPtr      pwcoClass;
    IWbemClassObjectPtr      pwcoInstance;

    // Get object required.
    hr = pws->GetObject( objectToCreateInstancesOf,
                         0,
                         NULL,
                         &pwcoClass,
                         NULL );
    if( FAILED (hr) )
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemServices::GetObject failure\n");
        throw _com_error( hr );        
    }

    hr = pwcoClass->SpawnInstance( 0, &pwcoInstance );
    if( FAILED (hr) )
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::SpawnInstance failure\n");
        throw _com_error( hr );        
    }

    for( int i = 0; i < instanceParameters.size(); ++i )
    {
        hr = pwcoInstance->Put( instanceParameters[i]->getName(),
                                0,
                                &(instanceParameters[i]->getValue() ),
                                0 );
        
        if( FAILED( hr ) )
        {
            TRACE( MTrace::SEVERE_ERROR, "IWbemClassObject::Put failure\n");
            throw _com_error( hr );        
        }
    }

    hr = pws->PutInstance( pwcoInstance,
                           WBEM_FLAG_CREATE_OR_UPDATE,
                           NULL,
                           NULL );
    if( FAILED(hr) )
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemServices::PutInstance failure\n");
        throw _com_error( hr );        
    }

    return MWmiObject_SUCCESS;
}

        
    
MWmiObject::MWmiObject_Error
MWmiObject::deleteInstance( MWmiInstance& instanceToDelete )
{
    HRESULT  hr;

    IWbemCallResultPtr       pwcr;

    hr = pws->DeleteInstance( instanceToDelete._path,
                              WBEM_FLAG_RETURN_IMMEDIATELY,
                              NULL,
                              &pwcr );
    if( FAILED(hr) )
    {
        TRACE( MTrace::SEVERE_ERROR, "IWbemServices::DeleteInstance failure\n");
        throw _com_error( hr );        
    }

    return MWmiObject_SUCCESS;
}
    
// getStatus
//        
MWmiObject::MWmiObject_Error
MWmiObject::getStatus()
{
    return MWmiObject_SUCCESS;
}
    

// betterConnectServer
//
HRESULT 
MWmiObject::betterConnectServer(
    const BSTR strNetworkResource, 
    const BSTR strUser,
    const BSTR strPassword,
    const BSTR strLocale,
    LONG lSecurityFlags,
    const BSTR strAuthority,
    IWbemContext *pCtx, 
    IWbemServices **ppNamespace 
    )
{
    HRESULT hr;

    hr = pwl->ConnectServer(
        strNetworkResource,
        NULL, // strUser,
        NULL, // strPassword,
        strLocale,
        lSecurityFlags,
        strAuthority,
        pCtx,
        ppNamespace );
    // these have been found to be special cases where retrying may help.
    if( ( hr == 0x800706bf ) || ( hr == 0x80070767 ) || ( hr == 0x80070005 )  )
    {
    	int delay = 250; // milliseconds
    	
        for( int i = 0; i < timesToRetry; ++i )
        {
        	Sleep(delay);
            TRACE( MTrace::SEVERE_ERROR, L"connectserver recoverable failure, retrying\n");
            hr = pwl->ConnectServer(
                strNetworkResource,
                NULL, // strUser,
                NULL, // strPassword,
                strLocale,
                lSecurityFlags,
                strAuthority,
                pCtx,
                ppNamespace );
            if( !FAILED( hr) )
            {
                break;
            }
        }
    }
    else if ( hr == 0x80041064 )
    {
        // trying to connect to local machine.  Cannot use credentials.
        TRACE( MTrace::INFO, L"connecting to self.  Retrying without using credentials\n");
        hr = pwl->ConnectServer(
            strNetworkResource,
            NULL,
            NULL,
            0,                                  
            NULL,
            0,
            0,       
            ppNamespace 
            );
    }
    else if( hr == 0x80004002 )
    {
        // being connected to by a provider itself.
        TRACE( MTrace::INFO, L"connecting client may be a wmi provider itself.  Retrying\n");

        // we have to get a new wbemlocatar.
        //
        hr = CoCreateInstance(CLSID_WbemUnauthenticatedLocator, 0, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IWbemLocator, 
                              (LPVOID *) &pwl);
        if (FAILED(hr))
        {
            TRACE(MTrace::SEVERE_ERROR, L"CoCreateInstance failure\n");
            throw _com_error( hr );
        }

        hr = pwl->ConnectServer(
            strNetworkResource,
            NULL, // strUser,
            NULL, // strPassword,
            strLocale,
            lSecurityFlags,
            strAuthority,
            pCtx,
            ppNamespace );
    }

    if (FAILED(hr))
    {
    	// no hosts are in this cluster.  Cannot proceed reliably.
    	WCHAR hrValue[32];
    	_bstr_t errText;
    	wstring errString;
    	wsprintfW(hrValue, L"hr=0x%08lx", hr);
        GetErrorCodeText(hr, errText );
    	errString = L"betterConnectServer failure. " + wstring(hrValue);
    	errString += " (" + errText + L").\n";
        TRACE( MTrace::SEVERE_ERROR, errString );     
        throw _com_error( hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\wtokens.h ===
#ifndef _WTOKENS_HH
#define _WTOKENS_HH
//
// Copyright (c) 1997 Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intendd publication of such source code.
//
// OneLiner: 
// DevUnit: 
// Author: Murtaza Hakim
//
// Description: 
// ------------
//
//------------------------------------------------------
// Include Files
#include <string>
#include <vector>
using namespace std;


//
//------------------------------------------------------
//
//------------------------------------------------------
// External References
//------------------------------------------------------
//
//------------------------------------------------------
// Constant Definitions
//
//------------------------------------------------------
class WTokens
{
public:
    //
    //    
    // data
    // none
    //
    // constructor
    //------------------------------------------------------
    // Description
    // -----------
    // constructor
    //
    // Returns
    // -------
    // none.
    //
    //------------------------------------------------------
    WTokens( 
        wstring strToken,     // IN: Wstring to tokenize.
        wstring strDelimit ); // IN: Delimiter.
    //
    //------------------------------------------------------
    // Description
    // -----------
    // Default constructor
    //
    // Returns
    // -------
    // none.
    //
    //------------------------------------------------------
    WTokens();
    //
    // destructor
    //------------------------------------------------------
    // Description
    // -----------
    // destructor
    //
    // Returns
    // -------
    // none.
    //------------------------------------------------------
    ~WTokens();
    //
    // member functions
    //------------------------------------------------------
    // Description
    // -----------
    //
    // Returns
    // -------
    // The tokens.
    //------------------------------------------------------
    vector<wstring>
    tokenize();
    //
    //------------------------------------------------------
    // Description
    // -----------
    // constructor
    //
    // Returns
    // -------
    // none.
    //
    //------------------------------------------------------
    void
    init( 
        wstring strToken,     // IN: Wstring to tokenize.
        wstring strDelimit ); // IN: Delimiter.
    //
protected:
    // Data
    // none
    //
    // Constructors
    // none
    //
    // Destructor
    // none
    //
    // Member Functions
    // none
    //
private:
    //
    /// Data
    wstring _strToken;
    wstring _strDelimit;
    //
    /// Constructors
    /// none
    //
    /// Destructor
    /// none
    //
    /// Member Functions
    /// none
    //
};
//
//------------------------------------------------------
// Inline Functions
//------------------------------------------------------
//
//------------------------------------------------------
// Ensure Type Safety
//------------------------------------------------------
typedef class WTokens WTokens;
//------------------------------------------------------
// 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
#define AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#include <comdef.h>
#include <wbemidl.h>

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\wmibase\wtokens.cpp ===
//
//-------------------------------------------------------------
// Copyright (c) 1997 Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//-------------------------------------------------------------
//
//-------------------------------------------------------------
// OneLiner: Tokenizer.
// DevUnit:  
// Author:  Murtaza Hakim
//-------------------------------------------------------------
//-------------------------------------------------------------
// Description: 
// ------------
// Gets the tokens in the string.
// 
//-------------------------------------------------------------
//
//-------------------------------------------------------------
// include files:
#include "WTokens.h"
#include <stdio.h>

//
//-------------------------------------------------------------
//
//-------------------------------------------------------------
// External References
// none
//-------------------------------------------------------------
//
//-------------------------------------------------------------
// global variables
// none
//-------------------------------------------------------------
//
//-------------------------------------------------------------
// static variables
// none
//-------------------------------------------------------------
//
//-------------------------------------------------------------
// global function declarations
// none
//-------------------------------------------------------------
//
//-------------------------------------------------------------
// static function declarations
// none
//-------------------------------------------------------------
//
// constructor
WTokens::WTokens( wstring strToken, wstring strDelimit )
        : _strToken( strToken ), _strDelimit( strDelimit )
{}
//
// default constructor
WTokens::WTokens()
{}
//
// destructor
WTokens::~WTokens()
{}
//
// tokenize
vector<wstring>
WTokens::tokenize()
{
    vector<wstring> vecTokens;
    wchar_t* token;

    token = wcstok( (wchar_t *) _strToken.c_str() , _strDelimit.c_str() );
    while( token != NULL )
    {
        vecTokens.push_back( token );
        token = wcstok( NULL, _strDelimit.c_str() );
    }
    return vecTokens;
}
//
void
WTokens::init( 
    wstring strToken,
    wstring strDelimit )
{
    _strToken = strToken;
    _strDelimit = strDelimit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\util\precomp.h ===
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <winuser.h>
#include <tchar.h>
#include <winsock2.h>

#include "tracelog.h"
#include "wlbsparm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\util\debugimpl.cpp ===
//+----------------------------------------------------------------------------
//
// File: debugimpl.cpp    	 
//
// Module:	Network Load Balancing Service 
//
// Synopsis: Provide the common functionality of ASSERT and TRACE .
//  The build enviorment does not allow to have a source file from another directory
//  Include the this cpp file directly.
//  Another approach is to have a shared lib.
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:	 fengsun Created    8/3/98
//
//+----------------------------------------------------------------------------
#include "precomp.h"

#include "debug.h"

#if	( defined(DEBUG) || defined(_DEBUG) || defined (DBG))

#ifndef MB_SERVICE_NOTIFICATION
#define MB_SERVICE_NOTIFICATION 0
#endif

static long dwAssertCount = 0;  // Avoid another assert while the messagebox is up


//+----------------------------------------------------------------------------
//
// Function:  TraceMessage
//
// Synopsis:  Output debug string
//
// Arguments: const char *pszFmt ...-  Printf style arguments list
//             
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void TraceMessageW(const TCHAR *pszFmt, ...) 
{
	va_list valArgs;
	TCHAR szOutput[512];

	va_start(valArgs,pszFmt);
	wvsprintf(szOutput,pszFmt,valArgs);
	va_end(valArgs);
	
	lstrcat(szOutput,TEXT("\r\n"));
	
	OutputDebugString(szOutput);

}




//+----------------------------------------------------------------------------
//
// Function:  AssertMessage
//
// Synopsis:  Popup a message box for asserting failure.  Has three options:
//            ignore/debug/abort.
//
// Arguments: const char *pszFile - File name
//            unsigned nLine - Line number
//            const char *pszMsg - Message in the dialog box
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void AssertMessageW(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg) 
{
	TCHAR szOutput[1024];

	wsprintf(szOutput,TEXT("%s(%u) - %s\n"),pszFile,nLine,pszMsg);
	OutputDebugString(szOutput);

	wsprintf(szOutput,TEXT("%s(%u) - %s\n( Press Retry to debug )"),pszFile,nLine,pszMsg);
    int nCode = IDIGNORE;


    //
    // If there is no Assertion messagebox, popup one
    //
    if (dwAssertCount <2 )
    {
		dwAssertCount++;

        //
        // Title format: Assertion Failed - hello.dll
        //

        //
        // Find the base address of this module.
        //

        MEMORY_BASIC_INFORMATION mbi;
        mbi.AllocationBase = NULL; // current process by if VirtualQuery failed
        VirtualQuery(
                    AssertMessageW,   // any pointer with in the module
                    &mbi,
                    sizeof(mbi) );

        //
        // Get the module filename.
        //

        WCHAR szFileName[MAX_PATH + 1];
        szFileName[0] = L'\0';   // in case of failure

        GetModuleFileNameW(
                    (HINSTANCE)mbi.AllocationBase,
                    szFileName,
                    MAX_PATH );

        //
        // Get the filename out of the full path
        //
        for (int i=lstrlen(szFileName);i != 0 && szFileName[i-1] != L'\\'; i--)
           ;

        WCHAR szTitle[48];
        lstrcpyW(szTitle, L"Assertion Failed - ");
        lstrcpynW(&szTitle[lstrlenW(szTitle)], szFileName+i, 
                sizeof(szTitle)/sizeof(szTitle[0]) - lstrlenW(szTitle) -1);  // there is no lstrcatn


		nCode = MessageBoxEx(NULL,szOutput,szTitle,
			MB_TOPMOST | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);


	    dwAssertCount--;
    }


    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        
#ifdef _X86_
		//
		// break into the debugger .
		// Step out of this fuction to get to your ASSERT() code
		//
        _asm { int 3 };     
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}




//+----------------------------------------------------------------------------
//
// Function:  TraceMessage
//
// Synopsis:  Output debug string
//
// Arguments: const char *pszFmt ...-  Printf style arguments list
//             
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void TraceMessageA(const CHAR *pszFmt, ...) 
{
	va_list valArgs;
	CHAR szOutput[512];

	va_start(valArgs,pszFmt);
	wvsprintfA(szOutput,pszFmt,valArgs);
	va_end(valArgs);
	
	lstrcatA(szOutput,("\r\n"));
	
	OutputDebugStringA(szOutput);

}




//+----------------------------------------------------------------------------
//
// Function:  AssertMessageA
//
// Synopsis:  Popup a message box for asserting failure.  Has three options:
//            ignore/debug/abort.
//
// Arguments: const char *pszFile - File name
//            unsigned nLine - Line number
//            const char *pszMsg - Message in the dialog box
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void AssertMessageA(const CHAR *pszFile, unsigned nLine, const CHAR *pszMsg) 
{
	CHAR szOutput[1024];

	wsprintfA(szOutput,("%s(%u) - %s\n"),pszFile,nLine,pszMsg);
	OutputDebugStringA(szOutput);

	wsprintfA(szOutput,("%s(%u) - %s\n( Press Retry to debug )"),pszFile,nLine,pszMsg);
    int nCode = IDIGNORE;

    //
    // If there is no Assertion messagebox, popup one
    //
    if (dwAssertCount <2 )
    {
		dwAssertCount++;

        //
        // Title format: Assertion Failed - hello.dll
        //

        //
        // Find the base address of this module.
        //

        MEMORY_BASIC_INFORMATION mbi;
        mbi.AllocationBase = NULL; // current process by if VirtualQuery failed
        VirtualQuery(
                    AssertMessageW,   // any pointer with in the module
                    &mbi,
                    sizeof(mbi) );

        //
        // Get the module filename.
        //

        CHAR szFileName[MAX_PATH + 1];
        szFileName[0] = '\0';   // in case of failure

        GetModuleFileNameA(
                    (HINSTANCE)mbi.AllocationBase,
                    szFileName,
                    MAX_PATH );

        //
        // Get the filename out of the full path
        //
        for (int i=lstrlenA(szFileName);i != 0 && szFileName[i-1] != '\\'; i--)
           ;

        CHAR szTitle[48];
        lstrcpyA(szTitle, "Assertion Failed - ");
        lstrcpynA(&szTitle[lstrlenA(szTitle)], szFileName+i, 
                sizeof(szTitle)/sizeof(szTitle[0]) - lstrlenA(szTitle) -1);  // there is no lstrcatn

        nCode = MessageBoxExA(NULL,szOutput,szTitle,
			MB_TOPMOST | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);

	    dwAssertCount--;
    }

    dwAssertCount--;

    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        
#ifdef _X86_
		//
		// break into the debugger .
		// Step out of this fuction to get to your ASSERT() code
		//
        _asm { int 3 };     
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\util\tracelogimpl.cpp ===
#include "precomp.h"

#include "debug.h"

static DWORD  sg_dwTraceID = INVALID_TRACEID;
static char    sg_szTraceName[100];   // Used for OutputDebugString

#ifdef DBG
DWORD   sg_dwTracingToDebugger = 1;  // Enable OutputDebugString for debug version by default
#else
DWORD   sg_dwTracingToDebugger = 0;  // call OutputDebugString
#endif

DWORD   sg_dwDebuggerMask      = 0;


inline const char *TraceLevel(DWORD dwDbgLevel)
{
    switch(dwDbgLevel)
    {
        case TL_ERROR: return "ERROR";
        case TL_WARN:  return "WARN ";
        case TL_INFO:  return "INFO ";
//        case TL_TRACE: return "TRACE";
//        case TL_EVENT: return "EVENT";
        default:       return " ??? ";
    }
}

BOOL TRACELogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "FileTracingMask";

    //
    // Register Tracing, this creates the registry entries 
    // (HKEY_LOCAL_MACHINE\Software\Microsoft\Tracing\"szName") 
    // (if they did not exist previously)
    //
    if ((sg_dwTraceID = TraceRegister(szName)) == INVALID_TRACEID) 
        return FALSE;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    return TRUE;
}


void TRACELogDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{
    #define MAXDEBUGSTRINGLENGTH 1024
    char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( dwDbgLevel & sg_dwDebuggerMask ) )
    {

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u:] [%s] ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  TraceLevel(dwDbgLevel));

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
		
    }
    
	if (sg_dwTraceID != INVALID_TRACEID && ( dwDbgLevel & sg_dwDebuggerMask ))
    {
		wsprintfA(szTraceBuf, "[%s] %s", TraceLevel(dwDbgLevel), lpszFormat);

		va_start(arglist, lpszFormat);
		TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
		va_end(arglist);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\util\utils.cpp ===
#include "precomp.h"

#include "debug.h"

#define MAXIPSTRLEN 20

//+----------------------------------------------------------------------------
//
// Function:  IpAddressFromAbcdWsz
//
// Synopsis:Converts caller's a.b.c.d IP address string to a network byte order IP 
//          address. 0 if formatted incorrectly.    
//
// Arguments: IN const WCHAR*  wszIpAddress - ip address in a.b.c.d unicode string
//
// Returns:   DWORD - IPAddr, return INADDR_NONE on failure
//
// History:   fengsun Created Header    12/8/98
//
//+----------------------------------------------------------------------------
DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress)
{   
    CHAR    szIpAddress[MAXIPSTRLEN + 1];
    DWORD  nboIpAddr;    

    ASSERT(lstrlen(wszIpAddress) < MAXIPSTRLEN);

    WideCharToMultiByte(CP_ACP, 0, wszIpAddress, -1, 
		    szIpAddress, sizeof(szIpAddress), NULL, NULL);

    nboIpAddr = inet_addr(szIpAddress);

    return(nboIpAddr);
}

//+----------------------------------------------------------------------------
//
// Function:  IpAddressToAbcdWsz
//
// Synopsis:  
//    Converts IpAddr to a string in the a.b.c.d form and returns same in 
//    caller's wszIpAddress buffer. The buffer should be at least 
//    MAXIPSTRLEN + 1 characters long.
//
// Arguments: IPAddr IpAddress - 
//            OUT WCHAR* wszIpAddress -  buffer at least MAXIPSTRLEN
//
// Returns:   void 
//
// History:   fengsun Created Header    12/21/98
//
//+----------------------------------------------------------------------------
VOID
WINAPI AbcdWszFromIpAddress(
    IN  DWORD  IpAddress,    
    OUT WCHAR*  wszIpAddress)
{
    ASSERT(wszIpAddress);

    LPSTR AnsiAddressString = inet_ntoa( *(struct in_addr *)&IpAddress );

    ASSERT(AnsiAddressString);

    if (AnsiAddressString == NULL)
    {
        lstrcpyW(wszIpAddress, L"");
        return ; 
    }


    MultiByteToWideChar(CP_ACP, 0, AnsiAddressString,  -1 , 
        wszIpAddress,  MAXIPSTRLEN + 1);
}

/*
 * Function: GetIPAddressOctets
 * Description: Turn an IP Address string into its 4 integer components.
 * Author: shouse 7.24.00
 */
VOID GetIPAddressOctets (PCWSTR pszIpAddress, DWORD ardw[4]) {
    DWORD dwIpAddr = IpAddressFromAbcdWsz(pszIpAddress);
    const BYTE * bp = (const BYTE *)&dwIpAddr;

    ardw[0] = (DWORD)bp[0];
    ardw[1] = (DWORD)bp[1];
    ardw[2] = (DWORD)bp[2];
    ardw[3] = (DWORD)bp[3];
}

/*
 * Function: IsValidIPAddressSubnetMaskPair
 * Description: Checks for valid IP address/netmask pairs.
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcperror.cpp
 */
BOOL IsValidIPAddressSubnetMaskPair (PCWSTR szIp, PCWSTR szSubnet) {
    BOOL fNoError = TRUE;
    DWORD ardwNetID[4];
    DWORD ardwHostID[4];
    DWORD ardwIp[4];
    DWORD ardwMask[4];

    GetIPAddressOctets(szIp, ardwIp);
    GetIPAddressOctets(szSubnet, ardwMask);

    INT nFirstByte = ardwIp[0] & 0xFF;

    // setup Net ID
    ardwNetID[0] = ardwIp[0] & ardwMask[0] & 0xFF;
    ardwNetID[1] = ardwIp[1] & ardwMask[1] & 0xFF;
    ardwNetID[2] = ardwIp[2] & ardwMask[2] & 0xFF;
    ardwNetID[3] = ardwIp[3] & ardwMask[3] & 0xFF;

    // setup Host ID
    ardwHostID[0] = ardwIp[0] & (~(ardwMask[0]) & 0xFF);
    ardwHostID[1] = ardwIp[1] & (~(ardwMask[1]) & 0xFF);
    ardwHostID[2] = ardwIp[2] & (~(ardwMask[2]) & 0xFF);
    ardwHostID[3] = ardwIp[3] & (~(ardwMask[3]) & 0xFF);

    // check each case
    if( ((nFirstByte & 0xF0) == 0xE0)  || // Class D
        ((nFirstByte & 0xF0) == 0xF0)  || // Class E
        (ardwNetID[0] == 127) ||          // NetID cannot be 127...
        ((ardwNetID[0] == 0) &&           // netid cannot be 0.0.0.0
         (ardwNetID[1] == 0) &&
         (ardwNetID[2] == 0) &&
         (ardwNetID[3] == 0)) ||
        // netid cannot be equal to sub-net mask
        ((ardwNetID[0] == ardwMask[0]) &&
         (ardwNetID[1] == ardwMask[1]) &&
         (ardwNetID[2] == ardwMask[2]) &&
         (ardwNetID[3] == ardwMask[3])) ||
        // hostid cannot be 0.0.0.0
        ((ardwHostID[0] == 0) &&
         (ardwHostID[1] == 0) &&
         (ardwHostID[2] == 0) &&
         (ardwHostID[3] == 0)) ||
        // hostid cannot be 255.255.255.255
        ((ardwHostID[0] == 0xFF) &&
         (ardwHostID[1] == 0xFF) &&
         (ardwHostID[2] == 0xFF) &&
         (ardwHostID[3] == 0xFF)) ||
        // test for all 255
        ((ardwIp[0] == 0xFF) &&
         (ardwIp[1] == 0xFF) &&
         (ardwIp[2] == 0xFF) &&
         (ardwIp[3] == 0xFF)))
    {
        fNoError = FALSE;
    }

    return fNoError;
}

/*
 * Function: IsContiguousSubnetMask
 * Description: Makes sure the netmask is contiguous
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcputil.cpp
 */
BOOL IsContiguousSubnetMask (PCWSTR pszSubnet) {
    DWORD ardwSubnet[4];

    GetIPAddressOctets(pszSubnet, ardwSubnet);

    DWORD dwMask = (ardwSubnet[0] << 24) + (ardwSubnet[1] << 16)
        + (ardwSubnet[2] << 8) + ardwSubnet[3];
    
    
    DWORD i, dwContiguousMask;
    
    // Find out where the first '1' is in binary going right to left
    dwContiguousMask = 0;

    for (i = 0; i < sizeof(dwMask)*8; i++) {
        dwContiguousMask |= 1 << i;
        
        if (dwContiguousMask & dwMask)
            break;
    }
    
    // At this point, dwContiguousMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwContiguousMask = dwMask | ~dwContiguousMask;

    // If the new mask is different, correct it here
    if (dwMask != dwContiguousMask)
        return FALSE;
    else
        return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  Params_ip2sub
//
// Description:  
//
// Arguments: WSTR          ip - 
//            PWSTR          sub - 
//
// Returns:   BOOL - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
BOOL ParamsGenerateSubnetMask (PWSTR ip, PWSTR sub) {
    DWORD               b [4];

    swscanf (ip, L"%d.%d.%d.%d", b, b+1, b+2, b+3);

    if ((b [0] >= 1) && (b [0] <= 126)) {
        b [0] = 255;
        b [1] = 0;
        b [2] = 0;
        b [3] = 0;
    } else if ((b [0] >= 128) && (b [0] <= 191)) {
        b [0] = 255;
        b [1] = 255;
        b [2] = 0;
        b [3] = 0;
    } else if ((b [0] >= 192) && (b [0] <= 223)) {
        b [0] = 255;
        b [1] = 255;
        b [2] = 255;
        b [3] = 0;
    } else {
        b [0] = 0;
        b [1] = 0;
        b [2] = 0;
        b [3] = 0;
    };

    swprintf (sub, L"%d.%d.%d.%d",
              b [0], b [1], b [2], b [3]);

    return((b[0] + b[1] + b[2] + b[3]) > 0);
}

/*
 * Function: ParamsGenerateMAC
 * Description: Calculate the generated field in the structure
 * History: fengsun Created 3.27.00
 *          shouse Modified 7.12.00 
 */
void ParamsGenerateMAC (const WCHAR * szClusterIP, 
                               OUT WCHAR * szClusterMAC, 
                               OUT WCHAR * szMulticastIP, 
                               BOOL fConvertMAC, 
                               BOOL fMulticast, 
                               BOOL fIGMP, 
                               BOOL fUseClusterIP) {
    DWORD dwIp;    
    const BYTE * bp;

    if (!fConvertMAC) return;

    /* Unicast mode. */
    if (!fMulticast) {
        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        bp = (const BYTE *)&dwIp;
        
        swprintf(szClusterMAC, L"02-bf-%02x-%02x-%02x-%02x", bp[0], bp[1], bp[2], bp[3]);

        return;
    }

    /* Multicast without IGMP. */
    if (!fIGMP) {
        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        bp = (const BYTE *)&dwIp;
        
        swprintf(szClusterMAC, L"03-bf-%02x-%02x-%02x-%02x", bp[0], bp[1], bp[2], bp[3]);

        return;
    }
    
    /* Multicast with IGMP. */
    if (fUseClusterIP) {
        /* 239.255.x.x */
        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        dwIp = 239 + (255 << 8) + (dwIp & 0xFFFF0000);
        AbcdWszFromIpAddress(dwIp, szMulticastIP);
    }

    dwIp = IpAddressFromAbcdWsz(szMulticastIP);
    bp = (const BYTE*)&dwIp;
        
    swprintf(szClusterMAC, L"01-00-5e-%02x-%02x-%02x", (bp[1] & 0x7f), bp[2], bp[3]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\clusterwrapper.cpp ===
#include <crtdbg.h>
#include <comdef.h>
#include <iostream>
#include <memory>
#include <string>
#include <wbemprov.h>
#include <genlex.h>   //for wmi object path parser
#include <objbase.h>
#include <wlbsconfig.h> 
#include <ntrkcomm.h>

using namespace std;

#include "objpath.h"
#include "debug.h"
#include "wlbsiocl.h"
#include "controlwrapper.h"
#include "clusterwrapper.h"
#include "utils.h"
#include "wlbsparm.h"
#include "cluster.h"
#include "wlbsutil.h"



////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::GetClusterConfig
//
// Purpose: This is used to obtain the current
//          cluster configuration.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::GetClusterConfig( CClusterConfiguration& a_WlbsConfig )
{
  WLBS_REG_PARAMS WlbsParam;

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwWlbsRegRes != WLBS_OK )
    throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );

  a_WlbsConfig.szClusterName = WlbsParam.domain_name;
  a_WlbsConfig.szClusterIPAddress = WlbsParam.cl_ip_addr;
  a_WlbsConfig.szClusterNetworkMask = WlbsParam.cl_net_mask;
  a_WlbsConfig.szClusterMACAddress = WlbsParam.cl_mac_addr;

  a_WlbsConfig.bMulticastSupportEnable = ( WlbsParam.mcast_support != 0);
  a_WlbsConfig.bRemoteControlEnabled   = ( WlbsParam.rct_enabled != 0 );
  a_WlbsConfig.nMaxNodes               = WLBS_MAX_HOSTS;

  a_WlbsConfig.bIgmpSupport            = (WlbsParam.fIGMPSupport != FALSE);
  a_WlbsConfig.bClusterIPToMulticastIP = (WlbsParam.fIpToMCastIp != FALSE);
  a_WlbsConfig.szMulticastIPAddress    = WlbsParam.szMCastIpAddress;

  a_WlbsConfig.bBDATeamActive          = (WlbsParam.bda_teaming.active != 0);

  if (a_WlbsConfig.bBDATeamActive)
  {
      a_WlbsConfig.szBDATeamId         = WlbsParam.bda_teaming.team_id;
      a_WlbsConfig.bBDATeamMaster      = (WlbsParam.bda_teaming.master != 0);
      a_WlbsConfig.bBDAReverseHash     = (WlbsParam.bda_teaming.reverse_hash != 0);
  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::GetNodeConfig
//
// Purpose: This function retrieves the current WLBS configuration and selects
//          only NodeSetting pertinent information. The information is passed
//          back in a CNodeConfiguration class instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::GetNodeConfig( CNodeConfiguration& a_WlbsConfig )
{
  WLBS_REG_PARAMS WlbsParam;

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwWlbsRegRes != WLBS_OK )
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );

  a_WlbsConfig.szDedicatedIPAddress = WlbsParam.ded_ip_addr;
  a_WlbsConfig.szDedicatedNetworkMask = WlbsParam.ded_net_mask;

  a_WlbsConfig.bClusterModeOnStart = ( WlbsParam.cluster_mode != 0 );
  //a_WlbsConfig.bNBTSupportEnable   = ( WlbsParam.nbt_support  != 0 );
  a_WlbsConfig.bMaskSourceMAC      = ( WlbsParam.mask_src_mac != 0 );

  a_WlbsConfig.dwNumberOfRules        = WlbsGetNumPortRules(&WlbsParam);
  a_WlbsConfig.dwCurrentVersion       = WlbsParam.alive_period;
  a_WlbsConfig.dwHostPriority         = WlbsParam.host_priority;
  a_WlbsConfig.dwAliveMsgPeriod       = WlbsParam.alive_period;
  a_WlbsConfig.dwAliveMsgTolerance    = WlbsParam.alive_tolerance;
  a_WlbsConfig.dwRemoteControlUDPPort = WlbsParam.rct_port;
  a_WlbsConfig.dwDescriptorsPerAlloc  = WlbsParam.dscr_per_alloc;
  a_WlbsConfig.dwMaxDescriptorAllocs  = WlbsParam.max_dscr_allocs;
  a_WlbsConfig.dwNumActions           = WlbsParam.num_actions;
  a_WlbsConfig.dwNumPackets           = WlbsParam.num_packets;
  a_WlbsConfig.dwNumAliveMsgs         = WlbsParam.num_send_msgs;
  a_WlbsConfig.szDedicatedIPAddress   = WlbsParam.ded_ip_addr;
  a_WlbsConfig.dwEffectiveVersion     = WlbsGetEffectiveVersion(&WlbsParam);
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetClusterConfig
//
// Purpose: This is used to update the registry with values that originate from 
//          the MOF ClusterSetting class.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::PutClusterConfig( const CClusterConfiguration &a_WlbsConfig )
{

  WLBS_REG_PARAMS NlbRegData;

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&NlbRegData );

  if( dwWlbsRegRes != WLBS_OK )
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );

  wcsncpy
    ( 
      NlbRegData.domain_name, 
      a_WlbsConfig.szClusterName.c_str(), 
      WLBS_MAX_DOMAIN_NAME
    );

  wcsncpy
    ( 
      NlbRegData.cl_net_mask, 
      a_WlbsConfig.szClusterNetworkMask.c_str(), 
      WLBS_MAX_CL_NET_MASK
    );

  wcsncpy
    ( 
      NlbRegData.cl_ip_addr , 
      a_WlbsConfig.szClusterIPAddress.c_str(), 
      WLBS_MAX_CL_IP_ADDR
    );

  NlbRegData.mcast_support = a_WlbsConfig.bMulticastSupportEnable;
  NlbRegData.rct_enabled   = a_WlbsConfig.bRemoteControlEnabled;

  NlbRegData.fIGMPSupport = a_WlbsConfig.bIgmpSupport;
  NlbRegData.fIpToMCastIp = a_WlbsConfig.bClusterIPToMulticastIP;

  wcsncpy
    ( 
      NlbRegData.szMCastIpAddress , 
      a_WlbsConfig.szMulticastIPAddress.c_str(), 
      WLBS_MAX_CL_IP_ADDR
    );

  // Fill in BDA information, if active
  NlbRegData.bda_teaming.active =  a_WlbsConfig.bBDATeamActive;
  if (NlbRegData.bda_teaming.active)
  {
      wcsncpy
        ( 
          NlbRegData.bda_teaming.team_id, 
          a_WlbsConfig.szBDATeamId.c_str(), 
          WLBS_MAX_BDA_TEAM_ID
        );

      NlbRegData.bda_teaming.master = a_WlbsConfig.bBDATeamMaster;
      NlbRegData.bda_teaming.reverse_hash = a_WlbsConfig.bBDAReverseHash;
  }
  
  dwWlbsRegRes = CWlbsCluster::WriteConfig(&NlbRegData );

  if( dwWlbsRegRes != WLBS_OK )
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsWriteReg );

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::PutNodeConfig
//
// Purpose:This is used to update the registry with values that originate from 
//         the MOF NodeSetting class.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::PutNodeConfig( const CNodeConfiguration& a_WlbsConfig )
{
  WLBS_REG_PARAMS NlbRegData;

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&NlbRegData);

  if( dwWlbsRegRes != WLBS_OK )
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );

  NlbRegData.host_priority   = a_WlbsConfig.dwHostPriority;
  NlbRegData.alive_period    = a_WlbsConfig.dwAliveMsgPeriod;
  NlbRegData.alive_tolerance = a_WlbsConfig.dwAliveMsgTolerance;
  NlbRegData.cluster_mode    = a_WlbsConfig.bClusterModeOnStart;
//  NlbRegData.nbt_support     = a_WlbsConfig.bNBTSupportEnable;
  NlbRegData.rct_port        = a_WlbsConfig.dwRemoteControlUDPPort;
  NlbRegData.mask_src_mac    = a_WlbsConfig.bMaskSourceMAC;
  NlbRegData.dscr_per_alloc  = a_WlbsConfig.dwDescriptorsPerAlloc;
  NlbRegData.max_dscr_allocs = a_WlbsConfig.dwMaxDescriptorAllocs;
  NlbRegData.num_actions     = a_WlbsConfig.dwNumActions;
  NlbRegData.num_packets     = a_WlbsConfig.dwNumPackets;
  NlbRegData.num_send_msgs   = a_WlbsConfig.dwNumAliveMsgs;

  //set dedicated IP
  wcsncpy
    ( 
      NlbRegData.ded_ip_addr, 
      a_WlbsConfig.szDedicatedIPAddress.c_str(), 
      WLBS_MAX_DED_IP_ADDR
    );

  //set dedicated mask
  wcsncpy
    ( 
      NlbRegData.ded_net_mask, 
      a_WlbsConfig.szDedicatedNetworkMask.c_str(), 
      WLBS_MAX_DED_NET_MASK
    );

  dwWlbsRegRes = CWlbsCluster::WriteConfig(&NlbRegData);

  if( dwWlbsRegRes != WLBS_OK )
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsWriteReg );

}



////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::Commit
//
// Purpose: This function invokes WlbsCommitChanges, which causes the driver to
//          load the current registry parameters.
//
// Return:  This function returns either WLBS_OK or WLBS_REBOOT. All other
//          Wlbs return values cause this function to throw WBEM_E_FAILED.
//
// Note:    The wlbs API currently caches the cluster and dedicated IP addreses.
//          As a result, if a user changes these values via a source external
//          to this provider, the cached values will fall out of sync. To
//          prevent this, a WlbsWriteReg is invoked to force the cache to
//          update.
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsClusterWrapper::Commit(CWlbsControlWrapper* pControl)
{

  WLBS_REG_PARAMS WlbsRegData;
  DWORD dwExtRes;


  dwExtRes = CWlbsCluster::CommitChanges(&pControl->m_WlbsControl);

  if( !(dwExtRes != WLBS_OK || dwExtRes != WLBS_REBOOT) )
    throw CErrorWlbsControl( dwExtRes, CmdWlbsCommitChanges );

  return dwExtRes;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetPassword
//
// Purpose: This function encodes the WLBS remote control password and saves 
//          it in the registry.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::SetPassword( LPWSTR a_szPassword )
{
  WLBS_REG_PARAMS RegData;

  DWORD dwRes = CWlbsCluster::ReadConfig(&RegData );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );

  dwRes = WlbsSetRemotePassword( &RegData, a_szPassword );

  if( dwRes != WLBS_OK )
    throw CErrorWlbsControl( dwRes, CmdWlbsSetRemotePassword );


  dwRes = CWlbsCluster::WriteConfig( &RegData );

  if( dwRes != WLBS_OK )
    throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );

}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::GetPortRule
//
// Purpose: This function retrieves the port rule that encompasses the requested
//          port.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::GetPortRule( DWORD a_dwVip, DWORD a_dwPort, PWLBS_PORT_RULE a_pPortRule )
{

  WLBS_REG_PARAMS WlbsParam;

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwWlbsRegRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );

  DWORD dwRes = WlbsGetPortRule( &WlbsParam, a_dwVip, a_dwPort, a_pPortRule );

  if( dwRes == WLBS_NOT_FOUND )
    throw _com_error( WBEM_E_NOT_FOUND );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsGetPortRule );
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::EnumPortRules
//
// Purpose: This function retrieves all of the port rules of a given type. The
//          function allocates memory for the received port rules. It is up
//          to the caller to free the memory. The number of rules retrieved is
//          placed in the a_dwNumRules parameter.
//
// Note:    Setting a_FilteringMode = 0 instructs function to retrieve all the
//          port rules.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::EnumPortRules
  ( 
    WLBS_PORT_RULE** a_ppPortRule,
    LPDWORD          a_pdwNumRules,
    DWORD            a_FilteringMode
  )
{

  WLBS_PORT_RULE  AllPortRules[WLBS_MAX_RULES];
  DWORD           dwTotalNumRules = WLBS_MAX_RULES;

  ASSERT( a_ppPortRule );

  WLBS_REG_PARAMS WlbsParam;
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );

  dwRes = WlbsEnumPortRules( &WlbsParam, AllPortRules, &dwTotalNumRules );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsEnumPortRules );

  if( dwTotalNumRules == 0 ) {
    a_pdwNumRules = 0;
    return;
  }

  long  nMaxSelRuleIndex = -1;
  DWORD  dwSelectedPortRules[WLBS_MAX_RULES];

  //loop through all of the port rules
  for( DWORD i = 0; i < dwTotalNumRules; i++) {
    if( a_FilteringMode == 0 || AllPortRules[i].mode == a_FilteringMode )
      dwSelectedPortRules[++nMaxSelRuleIndex] = i;
  }

  //if rule counter is less than zero, then return not found
  if( nMaxSelRuleIndex < 0 ) {
    a_pdwNumRules = 0;
    return;
  }
  
  *a_ppPortRule = new WLBS_PORT_RULE[nMaxSelRuleIndex+1];

  if( !*a_ppPortRule )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  PWLBS_PORT_RULE pRule = *a_ppPortRule;
  for( i = 0; i <= (DWORD)nMaxSelRuleIndex; i++ ) {
    CopyMemory( pRule++, 
                &AllPortRules[dwSelectedPortRules[i]],
                sizeof( WLBS_PORT_RULE ) );
  }

  *a_pdwNumRules = nMaxSelRuleIndex + 1;
  return;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::RuleExists
//
// Purpose: This function checks for the existence of a rule that has start
//          and end ports that match the input values.
//
////////////////////////////////////////////////////////////////////////////////
bool CWlbsClusterWrapper::RuleExists(DWORD a_dwVip, DWORD a_dwStartPort )
{

  WLBS_REG_PARAMS WlbsParam;
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );

  WLBS_PORT_RULE PortRule;
  
  dwRes = WlbsGetPortRule( &WlbsParam, a_dwVip, a_dwStartPort, &PortRule );

  if( dwRes == WLBS_NOT_FOUND )
    return false;

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsGetPortRule );

  if( PortRule.start_port == a_dwStartPort )
    return true;

  return false;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::DeletePortRule
//
// Purpose: This function deletes the rule that contains the input port.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::DeletePortRule(DWORD a_dwVip, DWORD a_dwPort )
{

  WLBS_REG_PARAMS WlbsParam;

  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  
  dwRes = WlbsDeletePortRule( &WlbsParam, a_dwVip, a_dwPort );

  if( dwRes == WBEM_E_NOT_FOUND )
    throw _com_error( WBEM_E_NOT_FOUND );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsDeletePortRule );

  dwRes = CWlbsCluster::WriteConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );
 
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::PutPortRule
//
// Purpose: This function adds a rule.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::PutPortRule(const PWLBS_PORT_RULE a_pPortRule)
{

  WLBS_REG_PARAMS WlbsParam;

  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );

  dwRes = WlbsAddPortRule( &WlbsParam, a_pPortRule );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsAddPortRule );

  dwRes = CWlbsCluster::WriteConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );

  return;
}


DWORD CWlbsClusterWrapper::GetClusterIpOrIndex(CWlbsControlWrapper* pControl)
{
    return CWlbsCluster::GetClusterIpOrIndex(&pControl->m_WlbsControl);
}



////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::GetHostID
//
// Purpose: Obtain ID of the local host.
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsClusterWrapper::GetHostID()
{
    return CWlbsCluster::GetHostID();
/*
  WLBS_RESPONSE WlbsResponse;
  DWORD dwResSize = 1;

  //get the cluster and HostID
  DWORD dwRes    = WlbsQuery( CWlbsCluster::GetClusterIp(),
                              WLBS_LOCAL_HOST,
                              &WlbsResponse, 
                              &dwResSize, 
                              NULL, 
                              NULL );

  //analyze query results for errors
  switch( dwRes ) {
    case WLBS_OK:
    case WLBS_STOPPED:
    case WLBS_CONVERGING:
    case WLBS_CONVERGED:
    case WLBS_DEFAULT:
    case WLBS_DRAINING:
    case WLBS_SUSPENDED:
      break;
    default:
      throw CErrorWlbsControl( dwRes, CmdWlbsQuery );
  }

  return WlbsResponse.id;
*/
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetNodeDefaults
//
// Purpose: This routine obtains the default configuration and sets the node
//          setting properties to their defaults without affecting the other
//          values.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::SetNodeDefaults()
{
  WLBS_REG_PARAMS WlbsConfiguration;
  WLBS_REG_PARAMS WlbsDefaultConfiguration;

  //get current configuration
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );

	//get the default configuration
  dwRes = WlbsSetDefaults(&WlbsDefaultConfiguration );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsSetDefaults );

  //modify current configuration with
	//default configuration
  WlbsConfiguration.host_priority   = WlbsDefaultConfiguration.host_priority;
  WlbsConfiguration.alive_period    = WlbsDefaultConfiguration.alive_period;
  WlbsConfiguration.alive_tolerance = WlbsDefaultConfiguration.alive_tolerance;
  WlbsConfiguration.cluster_mode    = WlbsDefaultConfiguration.cluster_mode;
  WlbsConfiguration.rct_port        = WlbsDefaultConfiguration.rct_port;
  WlbsConfiguration.mask_src_mac    = WlbsDefaultConfiguration.mask_src_mac;
  WlbsConfiguration.dscr_per_alloc  = WlbsDefaultConfiguration.dscr_per_alloc;
  WlbsConfiguration.max_dscr_allocs = WlbsDefaultConfiguration.max_dscr_allocs;
  WlbsConfiguration.num_actions     = WlbsDefaultConfiguration.num_actions;
  WlbsConfiguration.num_packets     = WlbsDefaultConfiguration.num_packets;
  WlbsConfiguration.num_send_msgs   = WlbsDefaultConfiguration.num_send_msgs;

  //set dedicated IP
  wcsncpy
    ( 
      WlbsConfiguration.ded_ip_addr, 
      WlbsDefaultConfiguration.ded_ip_addr, 
      WLBS_MAX_DED_IP_ADDR
    );

  //set dedicated mask
  wcsncpy
    ( 
      WlbsConfiguration.ded_net_mask, 
      WlbsDefaultConfiguration.ded_net_mask, 
      WLBS_MAX_DED_NET_MASK
    );

	//write the default configuration
  dwRes = CWlbsCluster::WriteConfig(&WlbsConfiguration);

  if( dwRes != WLBS_OK )
      throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetClusterDefaults
//
// Purpose: This routine obtains the default configuration and sets the cluster
//          setting properties to their defaults without affecting the other
//          values.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::SetClusterDefaults()
{
  WLBS_REG_PARAMS WlbsConfiguration;
  WLBS_REG_PARAMS WlbsDefaultConfiguration;

  //get current configuration
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK )
      throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );

	//get the default configuration
  dwRes = WlbsSetDefaults(&WlbsDefaultConfiguration );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsSetDefaults );

	//modify current configuration
  wcsncpy
    ( 
      WlbsConfiguration.domain_name, 
      WlbsDefaultConfiguration.domain_name, 
      WLBS_MAX_DOMAIN_NAME
    );

  wcsncpy
    ( 
      WlbsConfiguration.cl_net_mask, 
      WlbsDefaultConfiguration.cl_net_mask, 
      WLBS_MAX_CL_NET_MASK
    );

  wcsncpy
    ( 
      WlbsConfiguration.cl_ip_addr , 
      WlbsDefaultConfiguration.cl_ip_addr, 
      WLBS_MAX_CL_IP_ADDR
    );

  WlbsConfiguration.mcast_support = WlbsDefaultConfiguration.mcast_support;
  WlbsConfiguration.rct_enabled   = WlbsDefaultConfiguration.rct_enabled;
  
  WlbsConfiguration.fIGMPSupport   = WlbsDefaultConfiguration.fIGMPSupport;
  WlbsConfiguration.fIpToMCastIp   = WlbsDefaultConfiguration.fIpToMCastIp;
  wcsncpy
    ( 
      WlbsConfiguration.szMCastIpAddress , 
      WlbsDefaultConfiguration.szMCastIpAddress, 
      WLBS_MAX_CL_IP_ADDR
    );

  // Copy over BDA values
  WlbsConfiguration.bda_teaming.active = WlbsDefaultConfiguration.bda_teaming.active;
  if (WlbsConfiguration.bda_teaming.active) 
  {
      wcsncpy
        ( 
          WlbsConfiguration.bda_teaming.team_id, 
          WlbsDefaultConfiguration.bda_teaming.team_id, 
          WLBS_MAX_BDA_TEAM_ID
        );

      WlbsConfiguration.bda_teaming.master = WlbsDefaultConfiguration.bda_teaming.master;
      WlbsConfiguration.bda_teaming.reverse_hash = WlbsDefaultConfiguration.bda_teaming.reverse_hash;
  }

  //write the default configuration
  dwRes = CWlbsCluster::WriteConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK )
      throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetPortRuleDefaults
//
// Purpose: This routine obtains the current NLB configuration and the default
//          configuration. All of the port rules are removed in the current
//          configuration and replaced by the default configuration.
//
// Note:    The routine only uses WLBS API calls to replace the current port
//          rule configuration with the default configuration. This is not 
//          the most efficient method, but it avoids making assumptions
//          about the underlying data structure.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::SetPortRuleDefaults()
{
  WLBS_REG_PARAMS WlbsConfiguration;
  WLBS_REG_PARAMS WlbsDefaultConfiguration;
  WLBS_PORT_RULE  PortRules[WLBS_MAX_RULES];
  DWORD           dwNumRules = WLBS_MAX_RULES;

  //get current configuration
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );

	//get the default configuration
  dwRes = WlbsSetDefaults(&WlbsDefaultConfiguration );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsSetDefaults );

  //get the current port rules
  dwRes = WlbsEnumPortRules( &WlbsConfiguration,
                             PortRules,
                             &dwNumRules );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsEnumPortRules );

  //remove all of the current port rules
  DWORD i = 0;
  for( i = 0; i < dwNumRules; i++ )
  {
    //make sure that this works as expected i.e. the indexes must be valid
    dwRes = WlbsDeletePortRule( &WlbsConfiguration, IpAddressFromAbcdWsz(PortRules[i].virtual_ip_addr), PortRules[i].start_port );

    if( dwRes != WLBS_OK ) 
      throw CErrorWlbsControl( dwRes, CmdWlbsDeletePortRule );
  }

  //get the default port rules
  dwNumRules = WLBS_MAX_RULES;

  dwRes = WlbsEnumPortRules( &WlbsDefaultConfiguration,
                             PortRules,
                             &dwNumRules );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsEnumPortRules );

  //add the default port rules
  for( i = 0; i < dwNumRules; i++ )
  {

    dwRes = WlbsAddPortRule( &WlbsConfiguration, &PortRules[i] );

    if( dwRes != WLBS_OK ) 
      throw CErrorWlbsControl( dwRes, CmdWlbsAddPortRule );
  }

  dwRes = CWlbsCluster::WriteConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK ) 
    throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );

  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\clusterwrapper.h ===
#include "wlbsiocl.h"
#include "wlbsparm.h"
#include "cluster.h"

class CWlbsControlWrapper;  // forward declaration
class CWlbsCluster;

struct CClusterConfiguration
{
  wstring     szClusterName;
  wstring     szClusterIPAddress;
  wstring     szClusterNetworkMask;
  wstring     szClusterMACAddress;
  long        nMaxNodes;
  bool        bMulticastSupportEnable;
  bool        bRemoteControlEnabled;
  bool        bIgmpSupport;
  bool        bClusterIPToMulticastIP;
  wstring     szMulticastIPAddress;
  bool        bBDATeamActive;
  wstring     szBDATeamId;
  bool        bBDATeamMaster;
  bool        bBDAReverseHash;
};

struct CNodeConfiguration
{

  /* obtained from the registry */
  DWORD       dwNumberOfRules;
  DWORD       dwCurrentVersion;
  DWORD       dwHostPriority;
  wstring     szDedicatedIPAddress;
  wstring     szDedicatedNetworkMask;
  DWORD       dwAliveMsgPeriod;
  DWORD       dwAliveMsgTolerance;
  bool        bClusterModeOnStart;
  //bool        bNBTSupportEnable;
  bool        bMaskSourceMAC;
  DWORD       dwRemoteControlUDPPort;
  DWORD       dwDescriptorsPerAlloc;
  DWORD       dwMaxDescriptorAllocs;
  DWORD       dwNumActions;
  DWORD       dwNumPackets;
  DWORD       dwNumAliveMsgs;
  DWORD       dwEffectiveVersion;
};


class CWlbsClusterWrapper : public CWlbsCluster
{
public:
    DWORD GetHostID();
    DWORD GetClusterIP() {return CWlbsCluster::GetClusterIp();}

    DWORD GetClusterIpOrIndex(CWlbsControlWrapper* pControl);

    void SetPortRuleDefaults();
    void GetPortRule( DWORD dwVip, DWORD dwStartPort, PWLBS_PORT_RULE pPortRule );
    void PutPortRule(const PWLBS_PORT_RULE a_pPortRule);
    void EnumPortRules(PWLBS_PORT_RULE* ppPortRule, DWORD* pdwNumRules, DWORD dwFilteringMode);
    void DeletePortRule(DWORD dwVip, DWORD dwStartPort);
    bool RuleExists(DWORD dwVip, DWORD dwStartPort);

    void GetClusterConfig( CClusterConfiguration& a_WlbsConfig);
    void GetNodeConfig( CNodeConfiguration& a_WlbsConfig);
    void PutClusterConfig( const CClusterConfiguration &a_WlbsConfig);
    void PutNodeConfig( const CNodeConfiguration& a_WlbsConfig );
    void SetNodeDefaults();
    void SetClusterDefaults();
    GUID GetAdapterGuid() {return CWlbsCluster::GetAdapterGuid();}



    DWORD Commit(CWlbsControlWrapper* pControl);

    void SetPassword( LPWSTR a_szPassword );



private:
    CWlbsClusterWrapper() : CWlbsCluster(0){};  // Helper class, no instance
    ~CWlbsClusterWrapper() {};  // can not delete
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\genlex.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\controlwrapper.cpp ===
#include <crtdbg.h>
#include <comdef.h>
#include <iostream>
#include <memory>
#include <string>
#include <wbemprov.h>
#include <genlex.h>   //for wmi object path parser
#include <objbase.h>
#include <wlbsconfig.h> 
#include <ntrkcomm.h>

using namespace std;

#include "objpath.h"
#include "debug.h"
#include "controlwrapper.h"
#include "clusterwrapper.h"
#include "utils.h"
#include "wlbsparm.h"
#include "control.h"


#define NLB_DEFAULT_TIMEOUT 10


////////////////////////////////////////////////////////////////////////////////
//
// FillResponseClass
//
// Purpose: This function is obsolete. It was used in old versions to fill a
//          a response parameter that was returned from the control methods
//          of the Node and Cluster classes.
//
////////////////////////////////////////////////////////////////////////////////
void FillResponseClass
(
  DWORD               a_dwNumHosts, 
  const WLBS_RESPONSE a_Response[], 
  WLBS_RESPONSE      a_cResponse[], 
  LPCSTR              a_szcommand
)
{

  ASSERT( a_szcommand );

  if( a_Response && a_cResponse ) {
    for( DWORD nIter = 0; nIter < a_dwNumHosts; nIter++ ) {
      a_cResponse [nIter] = a_Response[nIter];
      //GetStatusDesc( a_cResponse[nIter].status, a_szcommand, a_cResponse[nIter].m_szStatus );
    }
  }
}


void CWlbsControlWrapper::Initialize()
{
  DWORD dwRet = m_WlbsControl.Initialize();

  if( dwRet != WLBS_PRESENT && dwRet != WLBS_LOCAL_ONLY)
    throw CErrorWlbsControl( dwRet, CmdWlbsInit );

  m_WlbsControl.WlbsTimeoutSet( WLBS_ALL_CLUSTERS, NLB_DEFAULT_TIMEOUT );

  CWlbsCluster** ppCluster;
  DWORD dwNumClusters = 0;
  
  //
  // Use the local password for local query
  //
  m_WlbsControl.EnumClusterObjects( ppCluster, &dwNumClusters);

  for (int i=0;i<dwNumClusters;i++)
  {
      m_WlbsControl.WlbsCodeSet( ppCluster[i]->GetClusterIp(), 
        ppCluster[i]->GetPassword() );
  }
}


void CWlbsControlWrapper::ReInitialize()
{
  m_WlbsControl.ReInitialize();
  
  CWlbsCluster** ppCluster;
  DWORD dwNumClusters = 0;
  
  //
  // In case pasword is changed, use the local password for local query
  //
  m_WlbsControl.EnumClusterObjects( ppCluster, &dwNumClusters);

  for (int i=0;i<dwNumClusters;i++)
  {
      //
      // If the change is not commited, the driver will still has the old password
      //
      if (!ppCluster[i]->IsCommitPending())
      {
          m_WlbsControl.WlbsCodeSet( ppCluster[i]->GetClusterIp(), 
            ppCluster[i]->GetPassword() );
      }
  }
}


void CWlbsControlWrapper::EnumClusters(CWlbsClusterWrapper** & ppCluster, DWORD* pdwNumClusters)
{
    m_WlbsControl.EnumClusterObjects( (CWlbsCluster** &) ppCluster, pdwNumClusters);
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Disable
//
// Purpose: Disable ALL traffic handling for the rule containing the 
//          specified port on specified host or all cluster hosts. Only rules 
//          that are set for multiple host filtering mode are affected.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Disable
  ( 
    DWORD           a_dwCluster  ,
    DWORD           a_dwHost     ,
    WLBS_RESPONSE*  a_pResponse  , 
    DWORD&          a_dwNumHosts ,
    DWORD           a_dwVip      ,
    DWORD           a_dwPort    
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwNumHosts == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;


  dwRet = m_WlbsControl.WlbsDisable( a_dwCluster   , 
                       a_dwHost      , 
                       Response      ,
                      &dwNumHosts    ,
                       a_dwVip       ,
                       a_dwPort
                     );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch( dwRet ) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      throw CErrorWlbsControl( dwRet, CmdWlbsDisable, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  FillResponseClass( dwNumHosts, Response, a_pResponse, "disable" );

  return dwRet;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Enable
//
// Purpose:     Enable traffic handling for rule containing the 
//              specified port on specified host or all cluster hosts. Only rules 
//              that are set for multiple host filtering mode are affected.
//
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Enable
  ( 
    DWORD           a_dwCluster  ,
    DWORD           a_dwHost     ,
    WLBS_RESPONSE* a_pResponse  , 
    DWORD&          a_dwNumHosts ,
    DWORD           a_dwVip      ,
    DWORD           a_dwPort    
  )
{
  DWORD dwRet;
  
  BOOL bClusterWide = ( a_dwNumHosts == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;

  dwRet = m_WlbsControl.WlbsEnable( a_dwCluster , 
                      a_dwHost    , 
                      Response    ,
                      &dwNumHosts ,
                      a_dwVip     ,
                      a_dwPort
                    );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      throw CErrorWlbsControl( dwRet, CmdWlbsEnable, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  FillResponseClass( dwNumHosts, Response, a_pResponse, "enable" );

  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Drain
//
// Purpose: Disable NEW traffic handling for rule containing the specified 
//          port on specified host or all cluster hosts. Only rules that are 
//          set for multiple host filtering mode are affected.

//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Drain
  ( 
    DWORD           a_dwCluster  ,
    DWORD           a_dwHost     ,
    WLBS_RESPONSE* a_pResponse  , 
    DWORD&          a_dwNumHosts ,
    DWORD           a_dwVip      ,
    DWORD           a_dwPort    
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwNumHosts == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;

  dwRet = m_WlbsControl.WlbsDrain( a_dwCluster , 
                     a_dwHost    , 
                     Response    ,
                     &dwNumHosts ,
                     a_dwVip     ,
                     a_dwPort
                   );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      throw CErrorWlbsControl( dwRet, CmdWlbsDrain, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  FillResponseClass( dwNumHosts, Response, a_pResponse, "drain" );

  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::DrainStop
//
// Purpose: Enter draining mode on specified host or all cluster hosts. 
//          New connections will not be accepted. Cluster mode will be stopped 
//          when all existing connections finish. While draining, host will 
//          participate in convergence and remain part of the cluster.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::DrainStop
  (  
    DWORD           a_dwCluster ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwNumHosts == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;

  dwRet = m_WlbsControl.WlbsDrainStop( a_dwCluster , 
                         a_dwHost      , 
                         Response    ,
                         &dwNumHosts 
                       );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      throw CErrorWlbsControl( dwRet, CmdWlbsDrainStop, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  FillResponseClass( dwNumHosts, Response, a_pResponse, "drainstop" );

  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Resume
//
// Purpose: Resume cluster operation control on specified host or all 
//          cluster hosts.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Resume
  (  
    DWORD           a_dwCluster ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwNumHosts == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;

  dwRet = m_WlbsControl.WlbsResume( 
                      a_dwCluster , 
                      a_dwHost    , 
                      Response    ,
                      &dwNumHosts 
                    );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      throw CErrorWlbsControl( dwRet, CmdWlbsResume, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  FillResponseClass( dwNumHosts, Response, a_pResponse, "resume" );

  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Start
//
// Purpose: Start cluster operations on specified host or all cluster hosts.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Start
  (  
    DWORD           a_dwCluster  ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwNumHosts == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;

  dwRet = m_WlbsControl.WlbsStart( a_dwCluster , 
                     a_dwHost      , 
                     Response    ,
                     &dwNumHosts 
                   );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      throw CErrorWlbsControl( dwRet, CmdWlbsStart, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  FillResponseClass( dwNumHosts, Response, a_pResponse, "start" );

  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Stop
//
// Purpose: Stop cluster operations on specified host or all cluster hosts.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Stop
  (  
    DWORD           a_dwCluster ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwNumHosts == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;

  dwRet = m_WlbsControl.WlbsStop( 
                    a_dwCluster , 
                    a_dwHost    , 
                    Response    ,
                    &dwNumHosts 
                   );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      throw CErrorWlbsControl( dwRet, CmdWlbsStop, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  FillResponseClass( dwNumHosts, Response, a_pResponse, "stop" );

  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Suspend
//
// Purpose: Suspend cluster operation control on specified host or 
//          all cluster hosts.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Suspend
  (  
    DWORD           a_dwCluster ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwNumHosts == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;

  dwRet = m_WlbsControl.WlbsSuspend( a_dwCluster , 
                       a_dwHost    , 
                       Response    ,
                       &dwNumHosts 
                     );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      throw CErrorWlbsControl( dwRet, CmdWlbsSuspend, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  FillResponseClass( dwNumHosts, Response, a_pResponse, "suspend" );

  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Query
//
// Purpose: This invokes WlbsQuery and returns a response structure along
//          with other parameters if requested.
// 
// Errors:  The function throws CErrorWlbsControl.
//
// Return:  Status value returned by the target host
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Query
  ( 
    CWlbsClusterWrapper* pCluster,
    DWORD           a_dwHost      ,
    WLBS_RESPONSE* a_pResponse   , 
    PDWORD          a_pdwNumHosts , 
    PDWORD          a_pdwHostMap
  )
{
  DWORD dwResponseSize = 0;
  if (a_pdwNumHosts)
  {
      dwResponseSize = *a_pdwNumHosts;
      *a_pdwNumHosts = 0;
  }


  DWORD dwRet;
  BOOL bClusterWide = 0;

  bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  DWORD dwNumHosts = WLBS_MAX_HOSTS;

  dwRet = m_WlbsControl.WlbsQuery( 
                     (CWlbsCluster*)pCluster , 
                     a_dwHost    , 
                     Response    , 
                     &dwNumHosts , 
                     a_pdwHostMap, 
                     NULL
                   );

  string strOut;

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch( dwRet ) {
      case WLBS_INIT_ERROR:
      case WLBS_BAD_PASSW:
      case WLBS_TIMEOUT:
      case WLBS_LOCAL_ONLY:
      case WLBS_REMOTE_ONLY:
      case WLBS_IO_ERROR:
      
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //local queries do not return the dedicated IP
  //get the dedicated IP and fill the structure
  if( a_dwHost == WLBS_LOCAL_HOST )
  {
    Response[0].address = pCluster->GetDedicatedIp();
  }

  if( a_pdwNumHosts ) 
  {
    *a_pdwNumHosts = _MIN(dwResponseSize, dwNumHosts);
    FillResponseClass( dwNumHosts, Response, a_pResponse, "query" );
  }

  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::CheckMembership
//
// Purpose: This verifies that the local host is a member of the cluster
//          specified by the Cluster IP in the registry. At the time this
//          was written, there was a remote chance that a user can modify the
//          IP address in the registry prior to the load of this DLL.
//
//          Note, this call is only required for the Node, Cluster and linked
//          associations and should not be invoked for any of the Setting classes.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsControlWrapper::CheckMembership()
{
// todo: make sure the host is in at least one cluster

/*
  WLBS_RESPONSE WlbsResponse;
  DWORD dwResSize = 1;

  //get the cluster and HostID
  DWORD dwRes    = pControl->Query( m_pWlbsCluster->GetClusterIp(),
                              WLBS_LOCAL_HOST,
                              &WlbsResponse, 
                              &dwResSize, 
                              NULL);

  switch( dwRes ) {
    case WLBS_SUSPENDED:
    case WLBS_STOPPED:
    case WLBS_CONVERGING:
    case WLBS_DRAINING:
    case WLBS_CONVERGED:
    case WLBS_DEFAULT:
      break;
    default:
      throw CErrorWlbsControl( dwRes, CmdWlbsQuery );
  }
*/
  // DWORD dwClusterIP;
  // GetClusterIP( &dwClusterIP );

  //if( dwClusterIP == 0 )
    //throw _com_error( WBEM_E_NOT_FOUND );

  //*******************************
  //this section does not work when the remote control is disabled
  //on the local host
  //*******************************

  //call the query function
//  dwRes = WlbsQuery( dwClusterIP, 
//                     WlbsResponse.id, 
//                     NULL, 
//                     NULL, 
//                     NULL, 
//                     NULL );

  //analyze query results for errors
//  switch( dwRes ) {
//    case WLBS_OK:
//    case WLBS_STOPPED:
//    case WLBS_CONVERGING:
//    case WLBS_CONVERGED:
//    case WLBS_DEFAULT:
//    case WLBS_DRAINING:
//    case WLBS_SUSPENDED:
//      return;
//    default:
//      throw CErrorWlbsControl( dwRes, CmdWlbsQuery );
//  }

  //*******************************
  //this section does not work when the remote control is disabled
  //on the local host
  //*******************************

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\makefile.inc ===
$(O)\wlbsprov.mof $(O)\wlbsprov.mfl: wlbsprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wlbsprov.mof -MFL:$(O)\wlbsprov.mfl wlbsprov.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\controlwrapper.h ===
#ifndef CONTROLWRAPPER_H
#define CONTROLWRAPPER_H

#include "wlbsparm.h"
#include "wlbsiocl.h"
#include "control.h"


class CWlbsControlWrapper
{
friend class CWlbsClusterWrapper;
public:
    CWlbsClusterWrapper* GetClusterFromIpOrIndex(DWORD dwClusterIpOrIndex)
    {
        return (CWlbsClusterWrapper*)m_WlbsControl.GetClusterFromIpOrIndex(
            dwClusterIpOrIndex);
    }
    void EnumClusters(CWlbsClusterWrapper** & ppCluster, DWORD* pdwNumClusters);
    void CheckMembership();

    void Initialize();
    void ReInitialize();
    DWORD Disable
      ( 
        DWORD           a_dwCluster  ,
        DWORD           a_dwHost     ,
        WLBS_RESPONSE* a_pResponse  , 
        DWORD&          a_dwNumHosts ,
        DWORD           a_dwVip,
        DWORD           a_dwPort    
      );
    DWORD Enable
      ( 
        DWORD           a_dwCluster  ,
        DWORD           a_dwHost     ,
        WLBS_RESPONSE* a_pResponse  , 
        DWORD&          a_dwNumHosts ,
        DWORD           a_dwVip,
        DWORD           a_dwPort    
      );
    DWORD Drain
      ( 
        DWORD           a_dwCluster  ,
        DWORD           a_dwHost     ,
        WLBS_RESPONSE* a_pResponse  , 
        DWORD&          a_dwNumHosts ,
        DWORD           a_dwVip,
        DWORD           a_dwPort    
      );
    DWORD DrainStop
      (  
        DWORD           a_dwCluster ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Start
      (  
        DWORD           a_dwCluster  ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Stop
      (  
        DWORD           a_dwCluster ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Suspend
      (  
        DWORD           a_dwCluster ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Resume
      (  
        DWORD           a_dwCluster ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Query
      ( 
        CWlbsClusterWrapper* pCluster,
        DWORD           a_dwHost      ,
        WLBS_RESPONSE* a_pResponse   , 
        PDWORD          a_pdwNumHosts , 
        PDWORD          a_pdwHostMap 
      );


protected:
    CWlbsControl m_WlbsControl;
};

#endif //CONTROLWRAPPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\genlex.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
	{
		if (!m_pSrcBuf)
			return 0;
		else
			return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
	}

    void Pushback(wchar_t)
	{
		if (m_pSrcBuf)
			--m_pSrcBuf;
	}

    void Reset() { m_pSrcBuf = m_pStart; }
	void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class POLARITY CGenLexer
{
    wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\opathlex.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\objpath.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    OBJPATH.H

Abstract:

    object path parser

History:

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <comdef.h>
#include <wbemprov.h>
#include <opathlex.h>

#define DELETE_ME

struct KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
};

struct ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    static const DWORD  m_scdwAllocNamespaceChunkSize;    // Grow m_paNamespaces in units of this quantity
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    static const DWORD  m_scdwAllocKeysChunkSize;         // Grow m_paKeys in units of this quantity
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
private:
    BOOL IncreaseNumAllocKeys();
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter, OutOfMemory };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
    void Free( LPWSTR wszUnparsedPath );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\utils.h ===
void AddressToString( DWORD a_dwAddress, wstring& a_szIPAddress );

void WlbsFormatMessageWrapper
  (
    DWORD        a_dwError, 
    WLBS_COMMAND a_Command, 
    BOOL         a_bClusterWide, 
    wstring&     a_wstrMessage
  );

BOOL ClusterStatusOK(DWORD a_dwStatus);


////////////////////////////////////////////////////////////////////////////////
//
// class CErrorWlbsControl
//
// Purpose: This encapsulates all WLBS errors and descriptions.
//
//
////////////////////////////////////////////////////////////////////////////////
class CErrorWlbsControl
{
private:

  CErrorWlbsControl();
public:
	_bstr_t Description();
  DWORD   Error();

  CErrorWlbsControl( DWORD        a_dwError, 
                     WLBS_COMMAND a_CmdCommand, 
                     BOOL         a_bAllClusterCall = FALSE );

  virtual ~CErrorWlbsControl() {}
  
private:
  wstring   m_wstrDescription;
  DWORD     m_dwError;

};

inline _bstr_t CErrorWlbsControl::Description()
{
  return _bstr_t( m_wstrDescription.c_str() );
}

inline DWORD CErrorWlbsControl::Error()
{
  return m_dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\ntrkcomm.cpp ===
#include <ntrkcomm.h>
#include <objbase.h>


CWbemServices::CWbemServices(
    IWbemServices* pNamespace)
    :m_pWbemServices(NULL)
{
    m_pWbemServices = pNamespace;
    if(m_pWbemServices != NULL)
        m_pWbemServices->AddRef();
}

CWbemServices::~CWbemServices()
{
    if(m_pWbemServices != NULL)
        m_pWbemServices->Release();
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::CreateClassEnum(
  /* [in] */ BSTR Superclass,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
  ) 
{
  HRESULT hr = m_pWbemServices->CreateClassEnum(
      Superclass,
      lFlags,
      pCtx,
      ppEnum);

  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::CreateInstanceEnum(
  /* [in] */ BSTR Class,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
  HRESULT hr = m_pWbemServices->CreateInstanceEnum(
      Class,
      lFlags,
      pCtx,
      ppEnum);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::DeleteClass(
  /* [in] */ BSTR Class,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
  HRESULT hr = m_pWbemServices->DeleteClass(
      Class,
      lFlags,
      pCtx,
      ppCallResult);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::DeleteInstance(
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
  HRESULT hr = m_pWbemServices->DeleteInstance(
      ObjectPath,
      lFlags,
      pCtx,
      ppCallResult);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::ExecMethod(
  BSTR strObjectPath, 
  BSTR MethodName, 
  long lFlags, 
  IWbemContext* pCtx,
    IWbemClassObject* pInParams,
  IWbemClassObject** ppOurParams, 
  IWbemCallResult** ppCallResult) 
{
  HRESULT hr = m_pWbemServices->ExecMethod(
      strObjectPath, 
      MethodName, 
      lFlags, 
      pCtx,
      pInParams,
      ppOurParams, 
      ppCallResult) ;
  return hr;  
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::ExecNotificationQuery(
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
  HRESULT hr = m_pWbemServices->ExecNotificationQuery(
      QueryLanguage,
      Query,
      lFlags,
      pCtx,
      ppEnum);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::ExecQuery(
  /* [in] */ BSTR QueryLanguage,
  /* [in] */ BSTR Query,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
  HRESULT hr = m_pWbemServices->ExecQuery(
      QueryLanguage,
      Query,
      lFlags,
      pCtx,
      ppEnum);
  return hr;
}

HRESULT
CWbemServices::GetObject(
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    HRESULT hr = m_pWbemServices->GetObject(
        ObjectPath,
        lFlags,
        pCtx,
        ppObject,
        ppCallResult);
    return hr;
}
 
// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
  HRESULT hr = m_pWbemServices->PutClass(
      pObject,
      lFlags,
      pCtx,
      ppCallResult);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{ 

  HRESULT hr = m_pWbemServices->PutInstance(
      pInst,
      lFlags,
      pCtx,
      ppCallResult);
  return hr;
}

/*CImpersonatedProvider
*  Purpose: provide a general solution for impersonate client for 
*  Wbem providers.
*  USAGE:
*  Inherit from this class, and implement abstact virtual functions.
*  child class should implement function prefixed with "Do".
* ******************************************/
CImpersonatedProvider::CImpersonatedProvider(
    BSTR ObjectPath,
    BSTR User, 
    BSTR Password, 
    IWbemContext * pCtx)
    :m_cRef(0), m_pNamespace(NULL)
{

}
CImpersonatedProvider::~CImpersonatedProvider()
{
  if(m_pNamespace)
      delete m_pNamespace;
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}
STDMETHODIMP 
CImpersonatedProvider::QueryInterface(
    REFIID riid, 
    PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP 
CImpersonatedProvider::Initialize(
    LPWSTR pszUser, LONG lFlags,
    LPWSTR pszNamespace, LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lStatus = WBEM_S_INITIALIZED;
    m_pNamespace = new CWbemServices(pNamespace); 
    if(m_pNamespace == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        lStatus = WBEM_E_FAILED;
    }
        
    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(lStatus,0);
    return hr;
}


HRESULT
CImpersonatedProvider::CreateInstanceEnumAsync(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoCreateInstanceEnumAsync(
                Class,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;
}

HRESULT
CImpersonatedProvider::DeleteInstanceAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoDeleteInstanceAsync(
                ObjectPath,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;
}

HRESULT
CImpersonatedProvider::ExecMethodAsync(
    const BSTR strObjectPath,
    const BSTR MethodName, 
    long lFlags, 
    IWbemContext* pCtx,
    IWbemClassObject* pInParams,
    IWbemObjectSink* pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoExecMethodAsync(
                strObjectPath,
                MethodName,
                lFlags,
                pCtx,
                pInParams,
                pResponseHandler);
    }
    return hr;
}

HRESULT
CImpersonatedProvider::ExecQueryAsync(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoExecQueryAsync(
                QueryLanguage,
                Query,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;
}

HRESULT
CImpersonatedProvider::GetObjectAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoGetObjectAsync(
                ObjectPath,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;  
}

HRESULT
CImpersonatedProvider::PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoPutInstanceAsync(
                pInst,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;
}

// CWbemInstanceMgr
CWbemInstanceMgr::CWbemInstanceMgr(
    IWbemObjectSink* pHandler,
    DWORD dwSize)
    :m_pSink(NULL), m_ppInst(NULL), m_dwIndex(0)
{
    m_pSink = pHandler;
    if(m_pSink != NULL)
        m_pSink->AddRef();
    m_dwThreshHold = dwSize;
    m_ppInst = new IWbemClassObject*[dwSize];
    for(DWORD i = 0; i < dwSize; i++)
        m_ppInst[i] = NULL;
}
CWbemInstanceMgr::~CWbemInstanceMgr()
{
    if(m_ppInst != NULL)
    {
        if(m_dwIndex >0)
        {
            m_pSink->Indicate(
                m_dwIndex,
                m_ppInst);
        }

        for(DWORD i =0; i<m_dwIndex; i++)
        {
            if(m_ppInst[i] != NULL)
                (m_ppInst[i])->Release();
        }
        delete [] m_ppInst;
    }
    if(m_pSink != NULL)
        m_pSink->Release();

}

void
CWbemInstanceMgr::Indicate(IWbemClassObject* pInst)
{
    if(pInst == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    m_ppInst[m_dwIndex++] = pInst;
    pInst->AddRef();
    if(m_dwIndex == m_dwThreshHold)
    {

        SCODE  sc = m_pSink->Indicate(
            m_dwIndex,
            m_ppInst);
        if(sc != S_OK)
            throw sc;
        
        // reset state
        for(DWORD i=0; i< m_dwThreshHold; i++)
        {
            if(m_ppInst[i] != NULL)
                (m_ppInst[i])->Release();
            m_ppInst[i] = NULL;
        }
        m_dwIndex = 0;
    
    }
    return;
}

void
CWbemInstanceMgr::SetStatus(
    LONG lFlags,
    HRESULT hr,
    BSTR strParam,
    IWbemClassObject* pObjParam)
{
    m_pSink->SetStatus(
        lFlags,
        hr,
        strParam,
        pObjParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\utils.cpp ===
#include <crtdbg.h>
#include <comdef.h>
#include <iostream>
#include <memory>
#include <string>
#include <wbemprov.h>
#include <genlex.h>   //for wmi object path parser
#include <objbase.h>
#include <wlbsconfig.h> 
#include <ntrkcomm.h>

using namespace std;

#include "objpath.h"
#include "debug.h"
#include "utils.h"


////////////////////////////////////////////////////////////////////////////////
//
// CErrorWlbsControl::CErrorWlbsControl
//
// Purpose: This object is ultimately caught and used to send WLBS error codes
//          back to the user via an __ExtendedStatus object. Strings are not
//          sent back in release mode due to localization concerns.
//
////////////////////////////////////////////////////////////////////////////////
CErrorWlbsControl::CErrorWlbsControl
  ( 
    DWORD         a_dwError, 
    WLBS_COMMAND  a_CmdCommand,
    BOOL          a_bAllClusterCall
  )
{
#ifdef DBG
	static char* pszWlbsCommand[] =
	{
		"WlbsAddPortRule",
		"WlbsAddressToName",
		"WlbsAddressToString",
		"WlbsAdjust",
		"WlbsCommitChanges",
		"WlbsDeletePortRule",
		"WlbsDestinationSet",
		"WlbsDisable",
		"WlbsDrain",
		"WlbsDrainStop",
		"WlbsEnable",
		"WlbsFormatMessage",
		"WlbsGetEffectiveVersion",
		"WlbsGetNumPortRules",
		"WlbsEnumPortRules",
		"WlbsGetPortRule",
		"WlbsInit",
		"WlbsPasswordSet",
		"WlbsPortSet",
		"WlbsQuery",
		"WlbsReadReg",
		"WlbsResolve",
		"WlbsResume",
		"WlbsSetDefaults",
		"WlbsSetRemotePassword",
		"WlbsStart",
		"WlbsStop",
		"WlbsSuspend",
		"WlbsTimeoutSet",
		"WlbsWriteReg"
	};

	char buf[512];

	if (a_CmdCommand <= CmdWlbsWriteReg) 
	{
	    if (a_CmdCommand != CmdWlbsQuery || a_dwError != WLBS_TIMEOUT)
	    {
    		sprintf(buf, "wlbsprov: %s failed, AllCluster = %d, error = %d\n", 
	    		pszWlbsCommand[a_CmdCommand], (int)a_bAllClusterCall, a_dwError);    
	    }
	}
	else
	{
		sprintf(buf, "wlbsprov: %d failed, AllCluster = %d, error = %d\n", 
			a_CmdCommand, (int)a_bAllClusterCall, a_dwError);    
	}

	OutputDebugStringA(buf);

#endif

    WlbsFormatMessageWrapper( a_dwError, 
                                   a_CmdCommand, 
                                   a_bAllClusterCall, 
                                   m_wstrDescription );

    m_dwError = a_dwError;

}


////////////////////////////////////////////////////////////////////////////////
//
// AddressToString
//
// Purpose: Converts a DWORD address to a wstring in dotted notation. This 
//          function wraps the WlbsAddressToString function.
//
//
////////////////////////////////////////////////////////////////////////////////
void AddressToString( DWORD a_dwAddress, wstring& a_szIPAddress )
{
  DWORD dwLenIPAddress = 32;

  WCHAR *szIPAddress = new WCHAR[dwLenIPAddress];

  if( !szIPAddress )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  try {
    for( short nTryTwice = 2; nTryTwice > 0; nTryTwice--) {

        if( ::WlbsAddressToString( a_dwAddress, szIPAddress, &dwLenIPAddress ) )
        break;

      delete [] szIPAddress;
      szIPAddress = new WCHAR[dwLenIPAddress];

      if( !szIPAddress )
        throw _com_error( WBEM_E_OUT_OF_MEMORY );
    }

    if( !nTryTwice )
      throw _com_error( WBEM_E_FAILED );

    a_szIPAddress = szIPAddress;

    if ( szIPAddress ) {
      delete [] szIPAddress;
      szIPAddress = NULL;
    }

  }

  catch(...) {

    if ( szIPAddress )
      delete [] szIPAddress;

    throw;

  }
}



////////////////////////////////////////////////////////////////////////////////
//
// CWmiWlbsCluster::FormatMessage
//
// Purpose: Obtains a descriptive string associated with a WLBS return value.
//
////////////////////////////////////////////////////////////////////////////////
void WlbsFormatMessageWrapper
  (
    DWORD        a_dwError, 
    WLBS_COMMAND a_Command, 
    BOOL         a_bClusterWide, 
    wstring&     a_wstrMessage
  )
{
  DWORD dwBuffSize = 255;
  TCHAR* pszMessageBuff = new WCHAR[dwBuffSize];

  if( !pszMessageBuff )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  try {

    for( short nTryTwice = 2; nTryTwice > 0; nTryTwice-- ) {

    if( WlbsFormatMessage( a_dwError, 
                           a_Command, 
                           a_bClusterWide, 
                           pszMessageBuff, 
                           &dwBuffSize)
      ) break;

      delete [] pszMessageBuff;
      pszMessageBuff = new WCHAR[dwBuffSize];

      if( !pszMessageBuff )
        throw _com_error( WBEM_E_OUT_OF_MEMORY );

    }

    if( !nTryTwice )
      throw _com_error( WBEM_E_FAILED );

    a_wstrMessage = pszMessageBuff;
    delete pszMessageBuff;

  } catch (...) {

    if( pszMessageBuff )
      delete [] pszMessageBuff;

    throw;
  }

}


////////////////////////////////////////////////////////////////////////////////
//
// ClusterStatusOK
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
BOOL ClusterStatusOK(DWORD a_dwStatus)
{
  if( a_dwStatus > 0 && a_dwStatus <= WLBS_MAX_HOSTS )
    return TRUE;

  switch( a_dwStatus ) {
    case WLBS_SUSPENDED:
    case WLBS_STOPPED:
    case WLBS_DRAINING:
    case WLBS_CONVERGING:
    case WLBS_CONVERGED:
      return TRUE;
      break;
    default:
      return FALSE;
  }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\ntrkcomm.h ===
#ifndef __provider_lib__
#define __provider_lib__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <wbemprov.h>
#include <objbase.h>


typedef LPVOID * PPVOID;

class CWbemServices
{
protected:
	IWbemServices* m_pWbemServices;
public:
	CWbemServices(IWbemServices* );
	virtual ~CWbemServices();
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecMethod( 
		BSTR, 
		BSTR, 
		long, 
		IWbemContext*,
        IWbemClassObject*,
		IWbemClassObject**, 
		IWbemCallResult**) ;
		

};


class CImpersonatedProvider : public IWbemServices, public IWbemProviderInit 
{
protected:
    ULONG              m_cRef;         //Object reference count
    CWbemServices*  m_pNamespace;
 
public:
	CImpersonatedProvider(BSTR =NULL, BSTR =NULL , BSTR =NULL, IWbemContext* =NULL);
	virtual ~CImpersonatedProvider();

	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

            //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
                    );

     //IWbemServices  

	  HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};

    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethod( 
		const BSTR, 
		const BSTR, 
		long, 
		IWbemContext*,
        IWbemClassObject*,
		IWbemClassObject**, 
		IWbemCallResult**) 
		{return WBEM_E_NOT_SUPPORTED;}

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(
		const BSTR,
		const BSTR, 
		long, 
        IWbemContext*,
		IWbemClassObject*,
		IWbemObjectSink*);
protected:
	virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
		/* [in] */ BSTR,	// Class,
		/* [in] */ long,	// lFlags,
		/* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		)=0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        /* [in] */ BSTR ,	//ObjectPath,
        /* [in] */ long,	// lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		) =0;

	virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
		BSTR,
		BSTR, 
		long, 
        IWbemContext*,
		IWbemClassObject*,
		IWbemObjectSink*
		)=0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        /* [in] */ BSTR, // QueryLanguage,
        /* [in] */ BSTR, // Query,
        /* [in] */ long, // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,   // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR * //pResponseHandler
		) =0;
	virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
		/* [in] */ BSTR ObjectPath,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
		)=0;


	virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
		/* [in] */ IWbemClassObject __RPC_FAR *,	//pInst,
		/* [in] */ long	,	// lFlags,
		/* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		) =0;



};

class CWbemInstanceMgr
{
	
protected:
	IWbemObjectSink* m_pSink;
	IWbemClassObject **m_ppInst;
	DWORD m_dwThreshHold;
	DWORD m_dwIndex;
public:

	CWbemInstanceMgr(
		IWbemObjectSink*,
		DWORD =50);
	virtual ~CWbemInstanceMgr();
	void Indicate(IWbemClassObject*);
	void SetStatus(
		LONG,
		HRESULT,
		BSTR, 
		IWbemClassObject*);
};



#endif // end of provlib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\objpath.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include <windows.h>
#include <stdio.h>
#include <oleauto.h>
#include <genlex.h>
#include <opathlex.h>
#include "objpath.h"

inline WCHAR* Macro_CloneLPWSTR(const WCHAR* x) 
{
    if (x == NULL)
    {
        return NULL;
    }

    WCHAR* pwszRet = new wchar_t[wcslen(x) + 1];
    if (pwszRet)
    {
        wcscpy(pwszRet, x);
    }

    return pwszRet;
}

const DWORD ParsedObjectPath::m_scdwAllocNamespaceChunkSize = 2;
const DWORD ParsedObjectPath::m_scdwAllocKeysChunkSize = 2;

ParsedObjectPath::ParsedObjectPath()
{
    unsigned int i;
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 0;        // Initialize to 0, assuming m_paNamespaces allocation will fail
    m_paNamespaces = new LPWSTR[m_scdwAllocNamespaceChunkSize];

    if (NULL != m_paNamespaces)
    {
        m_dwAllocNamespaces = m_scdwAllocNamespaceChunkSize;
        for (i = 0; i < m_dwAllocNamespaces; i++)
            m_paNamespaces[i] = 0;
    }

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 0;              // Initialize to 0, assuming m_paKeys allocation will fail
    m_paKeys = new KeyRef *[m_scdwAllocKeysChunkSize];
    if (NULL != m_paKeys)
    {
        m_dwAllocKeys = m_scdwAllocKeysChunkSize;
        for (i = 0; i < m_dwAllocKeys; i++)
            m_paKeys[i] = 0;
    }
}

ParsedObjectPath::~ParsedObjectPath()
{
    delete m_pServer;
    for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        delete m_paNamespaces[dwIx];
    delete [] m_paNamespaces;
    delete m_pClass;

    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        delete m_paKeys[dwIx];
    delete [] m_paKeys;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    delete [] m_pClass;
    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
        if (NULL == m_pClass)
            return FALSE;
    }

    return TRUE;
}

// ChrisDar 20 March 2001
// Keeping IsClass in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree except IsInstance, which is not called by any method.
BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

// ChrisDar 20 March 2001
// Keeping IsInstance in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree except IsInstance, which is not called by any method.
BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

// ChrisDar 20 March 2001
// Keeping IsObject in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree except IsInstance, which is not called by any method.
BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if (NULL == wszNamespace || 0 == *wszNamespace)
        return FALSE;

    if(0 == m_dwAllocNamespaces || m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        // Here if array is full or allocation failed previously

        DWORD dwNewAllocNamespaces = 0;
        if (0 == m_dwAllocNamespaces)
        {
            dwNewAllocNamespaces = m_scdwAllocNamespaceChunkSize;
        }
        else
        {
            dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        }

        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];

        if (paNewNamespaces == NULL)
        {
            return FALSE;
        }

        unsigned int i = 0;
        // Initialize the array to NULLs
        for (i = 0; i < dwNewAllocNamespaces; i++)
            paNewNamespaces[i] = 0;

        if (NULL != m_paNamespaces)
        {
            // Here only if we previously had an allocation success

            memcpy(paNewNamespaces, m_paNamespaces,
                   sizeof(LPWSTR) * m_dwNumNamespaces);
            delete [] m_paNamespaces;
        }
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces] = Macro_CloneLPWSTR(wszNamespace);
    if (NULL == m_paNamespaces[m_dwNumNamespaces])
        return FALSE;

    m_dwNumNamespaces++;

    return TRUE;
}

// ChrisDar 20 March 2001
// Keeping AddKeyRefEx in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree.
// ChrisDar 22 March 2001
// This really needs to be modified to return more info than pass/fail. Should reflect enums in CObjectPathParser
BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    // ChrisDar 20 March 2001
    // Notes:
    // 1. wszKeyName is allowed to be NULL. It acts as a signal to remove all existing keys,
    //    then add an unnamed key with this value. It is unclear why removing all keys is required.
    //    Perhaps this supports only one key when the key is unnamed...
    // 2. This code is riddled with places where memory allocations could screw up state. Some are
    //    "new"s while there are also calls to VariantCopy.
    // 3. VariantClear and VariantCopy have return values and they are not being checked.
    // 4. AddKeyRef can fail but it being called without checking the return value.
    // 5. Apparently pvValue must be non-NULL, but it isn't being validated before being dereferenced.
    // 6. bStatus is for the return value but it is never modified. Changed to return TRUE;.

    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue );

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys [ dwIndex ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) ;
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys [ 0 ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;

                VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;

                m_dwNumKeys = 1 ;
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_dwAllocKeys = 0;              // Initialize to 0, assuming m_paKeys allocation will fail
    m_paKeys = new KeyRef *[m_scdwAllocKeysChunkSize];

    if (NULL != m_paKeys)
    {
        m_dwAllocKeys = m_scdwAllocKeysChunkSize;
        for (unsigned int i = 0; i < m_dwAllocKeys; i++)
            m_paKeys[i] = 0;
    }
}

// ChrisDar 22 March 2001
// This really needs to be modified to return more info than pass/fail. Should reflect enums in CObjectPathParser
BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    // Unnamed keys are allowed, i.e., NULL == wszKeyName. But pvValue must be valid.
    if (NULL == pvValue)
        return FALSE;

    if(0 == m_dwAllocKeys || m_dwNumKeys == m_dwAllocKeys)
    {
        if (!IncreaseNumAllocKeys())
            return FALSE;
    }

    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    if (NULL == m_paKeys[m_dwNumKeys])
        return FALSE;

    m_dwNumKeys++;
    return TRUE;
}

// ChrisDar 22 March 2001
// This really needs to be modified to return more info than pass/fail. Should reflect enums in CObjectPathParser
BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if (NULL == pAcquireRef)
        return FALSE;

    if(0 == m_dwAllocKeys || m_dwNumKeys == m_dwAllocKeys)
    {
        if (!IncreaseNumAllocKeys())
            return FALSE;
    }

    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    // An unnamed key (wszKeyName is NULL) is legal, but pvValue can't be NULL.
    if (NULL == pvValue)
    {
        // Our input argument is invalid. What do we do? For now, throw a generic WBEM exception
        throw _com_error(WBEM_E_FAILED);
    }

    m_pName = Macro_CloneLPWSTR(wszKeyName);
    if (NULL != wszKeyName && NULL == m_pName)
    {
        // Memory allocation failed. We can't fail the call since we are in a constructor, so throw exception.
        throw _com_error(WBEM_E_OUT_OF_MEMORY);
    }

    VariantInit(&m_vValue);

    HRESULT hr = VariantCopy(&m_vValue, (VARIANT*)pvValue);
    if (S_OK != hr)
    {
        // What do we do? Throw WBEM exception for now.
        WBEMSTATUS ws = WBEM_E_FAILED;
        if (E_OUTOFMEMORY == hr)
            ws = WBEM_E_OUT_OF_MEMORY;
        throw _com_error(ws);
    }
}

KeyRef::~KeyRef()
{
    delete m_pName;
    // No check of return value here since we are destroying the object.
    VariantClear(&m_vValue);
}

int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    // ChrisDar 20 March 2001
    // I AM CONCERNED ABOUT THE "DELETE_ME" IN THE ARG OF CALL. #define'd IN OBJPATH.H TO "". REMOVE IT?
    // This is a confusing method. pInput must be a valid pointer. pwszPath MUST be a valid pointer initialized to NULL.
    // This method's job is to allocate a path as a string and pass it back to the caller
    // in pwszPath. It needs pInput to determine the path.

    if (NULL == pInput || pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];
    if (NULL == wszPath)
        return CObjectPathParser::OutOfMemory;

    wcscpy(wszPath, pInput->m_pClass);

    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                wcscat(wszPath, L".");
        }
        else
        {
            wcscat(wszPath, L",");
        }
        if(pKey->m_pName)
            wcscat(wszPath, pKey->m_pName);
        wcscat(wszPath, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            wcscat(wszPath, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    wcscat(wszPath, L"\\");
                }
                str[0] = *pwc;
                wcscat(wszPath, str);
                pwc++;
            }

            wcscat(wszPath, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            swprintf(wszTemp, L"%d", V_I4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            swprintf(wszTemp, L"%u", V_UI4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            swprintf(wszTemp, L"%hd", V_I2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            swprintf(wszTemp, L"%hu", V_UI2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            swprintf(wszTemp, L"%d", V_I1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            swprintf(wszTemp, L"%u", V_UI1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.
    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        wcscat(wszPath, L"=@");

    *pwszPath = wszPath;

    return CObjectPathParser::NoError;
}

// ChrisDar 20 March 2001
// Keeping GetRelativePath in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree.
LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    // ChrisDar 20 March 2001
    // wszFullPath is no being validated before use.
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}

void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
	m_pLexer = 0;
    delete m_pInitialIdent;
	m_pInitialIdent = 0;
    delete m_pTmpKeyRef;
	m_pTmpKeyRef = 0;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    // ChrisDar 20 March 2001
    // This method creates a ParsedObjectPath (if possible) and passes it back to the user by pointer.
    // It also ensures that the pointer is not retained within the class. It is the user's responsibiliy
    // to delete the memory. It is also the user's responsibility to ensure that pOutput is a valid
    // pointer that does not point to an existing instances of a ParsedObjectPath*. Otherwise, this method
    // could cause a memory leak, since we overwrite the pointer.
    //
    // This is an extremely dangerous way to use a private data member. Other methods use m_pOutput and
    // are currently only called by this method or a method that only this one calls. Though the methods
    // are private, anyone maintaining the code needs to know not to use this variable or these methods
    // because m_pOutput is valid only so long as this method is executing... I have changed this so that
    // m_pOutput is passed among the private methods that need it. It is cumbersome but safer.

    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================
    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return CObjectPathParser::InvalidParameter;

    // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;
    if (NULL == m_pOutput)
        return CObjectPathParser::OutOfMemory;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================
            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                m_pOutput = 0;
                return CObjectPathParser::SyntaxError;
            }
            else    // A lone server name is legal.
            {
                m_pOutput->m_pServer = new WCHAR[wcslen(pwcStart)+1];
                if (NULL == m_pOutput->m_pServer)
                {
                    delete m_pOutput;
                    m_pOutput = 0;
                    return CObjectPathParser::OutOfMemory;
                }

                wcscpy(m_pOutput->m_pServer, pwcStart);
                *pOutput = m_pOutput;
                m_pOutput = 0;

                return CObjectPathParser::NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            m_pOutput = 0;
            return CObjectPathParser::SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        if (m_pOutput->m_pServer == NULL)
        {
            delete m_pOutput;
            m_pOutput = 0;
            return CObjectPathParser::OutOfMemory;
        }

        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================
    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);
    if (m_pLexer == NULL)
    {
        delete m_pOutput;
        m_pOutput = 0;
        return CObjectPathParser::OutOfMemory;
    }

    // Go.
    // ===
    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        m_pOutput = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        m_pOutput = 0;
        return CObjectPathParser::SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            m_pOutput = 0;
            return CObjectPathParser::SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            if (NULL == m_pOutput->m_pServer)
            {
                delete m_pOutput;
                m_pOutput = 0;
                return CObjectPathParser::OutOfMemory;
            }

            wcscpy(m_pOutput->m_pServer, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================
    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }

    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return CObjectPathParser::NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}

void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return CObjectPathParser::SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (NULL == m_pInitialIdent)
            return CObjectPathParser::OutOfMemory;

        if (!NextToken())
        {
            delete m_pInitialIdent;
			m_pInitialIdent = 0;
            return CObjectPathParser::SyntaxError;
        }

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================
        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================
    return CObjectPathParser::SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================
        return CObjectPathParser::SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return CObjectPathParser::NoError;

    return CObjectPathParser::SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return CObjectPathParser::NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return CObjectPathParser::SyntaxError;
    if (!NextToken())
        return CObjectPathParser::SyntaxError;
    return objref();
}

//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    int iStatus = CObjectPathParser::NoError;

    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        iStatus = ident_becomes_ns();
        if (CObjectPathParser::NoError != iStatus)
            return iStatus;

        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        iStatus = ident_becomes_ns();
        if (CObjectPathParser::NoError != iStatus)
            return iStatus;

        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return CObjectPathParser::NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return CObjectPathParser::SyntaxError;
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return objref();
    }

    // Else
    // ====
    iStatus = ident_becomes_class();
    if (CObjectPathParser::NoError != iStatus)
        return iStatus;

    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return CObjectPathParser::SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
    if (NULL == m_pOutput->m_pClass)
        return CObjectPathParser::OutOfMemory;

    // On failure here, don't free memory allocated by clone above. The ::Parse method takes care of this.
    if (!NextToken())
        return CObjectPathParser::SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        if (!m_pOutput->AddNamespace(m_pLexer->GetTokenText()))
            return CObjectPathParser::OutOfMemory;

        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return ns_list_rest();
    }

    return CObjectPathParser::SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    int iStatus = CObjectPathParser::NoError;

    if(!m_pOutput->AddNamespace(m_pInitialIdent))
        iStatus = CObjectPathParser::OutOfMemory;

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return iStatus;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;

    if (NULL == m_pOutput->m_pClass)
        return CObjectPathParser::OutOfMemory;

    return CObjectPathParser::NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.
        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return CObjectPathParser::SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return CObjectPathParser::NoError;
        }

        m_pTmpKeyRef = new KeyRef;
        if (NULL == m_pTmpKeyRef)
            return CObjectPathParser::OutOfMemory;

        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        if(!m_pOutput->AddKeyRef(m_pTmpKeyRef))
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return CObjectPathParser::OutOfMemory;
        }
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return keyref_list();
    }

    return CObjectPathParser::NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return ns_list();
    }
    return CObjectPathParser::NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        wchar_t *pTokenText = m_pLexer->GetTokenText();
        if (NULL == pTokenText)
            return CObjectPathParser::SyntaxError;
        BSTR bstr = SysAllocString(pTokenText);
        if (NULL == bstr)
            return CObjectPathParser::OutOfMemory;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = bstr;
        // Keeping the original code commented out for now. Replacement is complicated
        // because several failures could have occured and those would be obscured in the
        // previous version.
//      V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());
//      if (NULL == pKeyRef->m_vValue)
//          return CObjectPathParser::OutOfMemory;
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return CObjectPathParser::SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return CObjectPathParser::SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return CObjectPathParser::SyntaxError;
    }
    else return CObjectPathParser::SyntaxError;

    if (!NextToken())
        return CObjectPathParser::SyntaxError;

    return CObjectPathParser::NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;
    if (m_pTmpKeyRef == NULL)
    {
        return CObjectPathParser::OutOfMemory;
    }

    int nRes = propname();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return CObjectPathParser::SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return CObjectPathParser::SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (!m_pOutput->AddKeyRef(m_pTmpKeyRef))
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return CObjectPathParser::OutOfMemory;
    }
    m_pTmpKeyRef = 0;

    return CObjectPathParser::NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return keyref_list();
    }

    return CObjectPathParser::NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return CObjectPathParser::SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
    if (NULL == m_pTmpKeyRef->m_pName)
        return CObjectPathParser::OutOfMemory;

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return CObjectPathParser::SyntaxError;
    }

    return CObjectPathParser::NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];

        if (pTmp)
            wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================
    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    if (NULL == pRetVal)
        return NULL;

    wchar_t Tmp[32];
    long nVal;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================
    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================
    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============
    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if (wszOut == NULL)
        return NULL;

    *wszOut = 0;

    // Output
    // ======
    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================
    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============
    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if (NULL == wszOut)
        return NULL;

    *wszOut = 0;

    // Output
    // ======
    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IncreaseNumAllocKeys()
{
    if(0 == m_dwAllocKeys || m_dwNumKeys == m_dwAllocKeys)
    {
        // Here if array is full or allocation failed previously
        DWORD dwNewAllocKeys = 0;
        if (0 == m_dwAllocKeys)
        {
            dwNewAllocKeys = m_scdwAllocKeysChunkSize;
        }
        else
        {
            dwNewAllocKeys = m_dwAllocKeys * 2;
        }

        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if (paNewKeys == NULL)
        {
            return FALSE;
        }

        unsigned int i = 0;
        // Initialize the new array to NULLs
        for (i = 0; i < dwNewAllocKeys; i++)
            paNewKeys[i] = 0;

        if (NULL != m_paKeys)
        {
            // Here only if we previously had an allocation success
            memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwNumKeys);
            delete [] m_paKeys;
        }
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    return TRUE;
}

////////////////////////////////////////////////////////
//
// Test object path parser by parsing all objects
// in the input file (one object path per line).
// 
////////////////////////////////////////////////////////

#ifdef TEST
void xmain(int argc, wchar_t * argv[])
{
//    printf("Object Path Test\n");
//    if (argc < 2 || strchr(argv[1], '?') != NULL)
//    {
//        printf("Usage: objpath input-file\n");
//        return;
//    }

    int nLine = 1;
    char buf[2048];
	printf("Your argument was: %s\n", argv[1]);
	return;
//    FILE *f = fopen(argv[1], "rt");
    FILE *f = fopen("junk.txt", "rt");
    if (f == NULL)
    {
        printf("Usage: objpath input-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // Get rid of newline and trailing spaces.
        // =======================================

        char* ptr = strchr(buf, '\n');
        if (ptr != NULL)
        {
            *ptr = ' ';
            while (ptr >= buf && *ptr == ' ')
            {
                *ptr = '\0'; 
                ptr--;
            }
        }

        // Get rid of leading spaces.
        // ==========================

        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // Convert to wide char and parse.  Ignore blank lines.
        // ====================================================

        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            printf("----Object path----\n");
            printf("%S\n", buf2);

            ParsedObjectPath* pOutput = 0;
            CObjectPathParser p(e_ParserAcceptAll);
            int nStatus = p.Parse(buf2,  &pOutput);

            if (nStatus != 0)
            {
                printf("ERROR: return code is %d\n", nStatus);
                continue;
            }
            printf("No errors.\n");

            printf("------Output------\n");

            LPWSTR pKey = pOutput->GetKeyString();
            printf("Key String = <%S>\n", pKey);
            delete pKey;

            printf("Server = %S\n", pOutput->m_pServer);
            printf("Namespace Part = %S\n", pOutput->GetNamespacePart());
            printf("Parent Part    = %S\n", pOutput->GetParentNamespacePart());

            for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
            {
                printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
            }

            printf("Class = <%S>\n", pOutput->m_pClass);

            // If here, the key ref is complete.
            // =================================

            for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
            {
                KeyRef *pTmp = pOutput->m_paKeys[dwIx];
                printf("*** KeyRef contents:\n");
                printf("    Name = %S   Value=", pTmp->m_pName);
                switch (V_VT(&pTmp->m_vValue))
                {
                    case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
                    case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
                    case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
                    default:
                        printf("BAD KEY REF\n");
                }
                printf("\n");
            }

            p.Free(pOutput);
        }
    }
}

int __cdecl wmain(int argc, wchar_t * argv[])
{
    xmain(argc, argv);
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_clusclussetting.h ===
#ifndef _NODENODESETTING_INCLUDED_
#define _NODENODESETTING_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_ClusClusSetting
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF ClusterSetting class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_ClusClusSetting : public CWlbs_Root
{
public:
  CWLBS_ClusClusSetting(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);
  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0, IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

private:

  //methods
  void FillWbemInstance  (CWlbsClusterWrapper* pCluster,
            IWbemClassObject* a_pWbemInstance );

  void FindInstance( IWbemClassObject**      a_ppWbemInstance );

};

#endif //_NODENODESETTING_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_cluster.h ===
#ifndef _WLBSCLUSTER_INCLUDED_
#define _WLBSCLUSTER_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_Cluster
//
// Purpose: 
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_Cluster : public CWlbs_Root
{
public:

  CWLBS_Cluster(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

  HRESULT ExecMethod( 
                      const ParsedObjectPath* a_pParsedPath, 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags            = 0, 
                      IWbemContext*           a_pIContex          = NULL, 
                      IWbemClassObject*       a_pIInParams        = NULL
                    );

private:

  void FillWbemInstance( IWbemClassObject*   a_pWbemInstance, 
			            CWlbsClusterWrapper* pCluster,
                        const DWORD          a_dwStatus );

};

#endif _WLBSCLUSTER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_clustersetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_clustersetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "param.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::CWLBS_ClusterSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_ClusterSetting::CWLBS_ClusterSetting
  ( 
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_ClusterSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_ClusterSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::GetInstance
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusterSetting::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    wstring wstrHostName;
    
    //get the name key property and convert to wstring
    //throws _com_error
    
    wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    //get the cluster
    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    
    if (pCluster == NULL)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    //get the Wbem class instance
    SpawnInstance( MOF_CLUSTERSETTING::szName, &pWlbsInstance );

    //Convert status to string description
    FillWbemInstance( pWlbsInstance, pCluster );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    
    //transform Win32 error to a WBEM error
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::EnumInstances
//
// Purpose: This function obtains the clustersetting data for the current host.
//          The node does not have to be a member of a cluster for this 
//          to succeed. However, WLBS must be installed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusterSetting::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject*    pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i < dwNumClusters; i++)
    {
        //get the Wbem class instance
        SpawnInstance( MOF_CLUSTERSETTING::szName, &pWlbsInstance );

        //get the cluster configuration
        FillWbemInstance( pWlbsInstance , ppCluster[i]);

        //send the results back to WinMgMt
        m_pResponseHandler->Indicate( 1, &pWlbsInstance );

        if( pWlbsInstance ) {

          pWlbsInstance->Release();
          pWlbsInstance = NULL;

        }
    }

    

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    
    //transform Win32 error to a WBEM error
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND ;
  }

  catch(...) {

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::PutInstance
//
// Purpose: This function updates an instance of a MOF ClusterSetting 
//          class. The node does not have to be a member of a cluster. However,
//          WLBS must be installed for this function to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusterSetting::PutInstance
  ( 
    IWbemClassObject* a_pInstance,
    long              /* a_lFlags */,
    IWbemContext*     /* a_pIContex */
  )
{
  HRESULT            hRes = 0;
  VARIANT            vHostName;

  try {

    VariantInit( &vHostName );

    //get the host name value
    hRes = a_pInstance->Get( _bstr_t( MOF_CLUSTERSETTING::pProperties[MOF_CLUSTERSETTING::NAME] ),
                             0,
                             &vHostName,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, vHostName.bstrVal);
    
    if (pCluster == NULL)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }


    //get the cluster IP value
    _variant_t vClusterIp;

    hRes = a_pInstance->Get( _bstr_t( MOF_CLUSTERSETTING::pProperties[MOF_CLUSTERSETTING::CLUSIPADDRESS] ),
                             0,
                             &vClusterIp,
                             NULL,
                             NULL );

    DWORD dwClusterIp = IpAddressFromAbcdWsz(vClusterIp.bstrVal);
    
    //
    // Make sure the non-zero cluster IP is unique
    //
    if (dwClusterIp != 0)
    {
        CWlbsClusterWrapper* pTmpCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIp);

        if (pTmpCluster && pCluster != pTmpCluster)
        {
            TRACE_ERROR1("CWLBS_ClusterSetting::PutInstance duplicate cluster IP found %ws", 
                vClusterIp.bstrVal);

            throw CErrorWlbsControl( WLBS_REG_ERROR, CmdWlbsWriteReg );
        }
    }
    
    UpdateConfiguration( a_pInstance, pCluster );

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vHostName ))
       throw _com_error( WBEM_E_FAILED );

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;

  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vHostName ))
       throw _com_error( WBEM_E_FAILED );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    hRes = HResErr.Error();
  }

  catch (...) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    throw;
  }

  return hRes;

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::ExecMethod
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusterSetting::ExecMethod    
  (
    const ParsedObjectPath* a_pParsedPath, 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*           /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams
  )
{
  
  IWbemClassObject* pOutputInstance   = NULL;
  VARIANT           vValue;
  HRESULT           hRes = 0;

  try {

    VariantInit( &vValue );

    CWlbsClusterWrapper* pCluster = NULL;
    
    if (a_pParsedPath->m_paKeys == NULL)
    {
        // 
        // No cluster IP specified
        //
        throw _com_error( WBEM_E_INVALID_PARAMETER );
    }
    else
    {
        const wchar_t* wstrRequestedClusterName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

        pCluster = GetClusterFromHostName(g_pWlbsControl, wstrRequestedClusterName);

    }

    if (pCluster == NULL)
        throw _com_error( WBEM_E_NOT_FOUND );

    //determine the method being executed
    if( _wcsicmp( a_strMethodName, MOF_CLUSTERSETTING::pMethods[MOF_CLUSTERSETTING::SETPASS] ) == 0 )  {

      //get the password
      hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::PASSW ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

      if( vValue.vt != VT_BSTR )
        throw _com_error ( WBEM_E_INVALID_PARAMETER );

      pCluster->SetPassword( vValue.bstrVal );

    } else if( _wcsicmp( a_strMethodName, MOF_CLUSTERSETTING::pMethods[MOF_CLUSTERSETTING::LDSETT] ) == 0 ) {
    //get the output object instance
      GetMethodOutputInstance( MOF_CLUSTERSETTING::szName, 
                               a_strMethodName, 
                               &pOutputInstance);

      DWORD dwReturnValue = pCluster->Commit(g_pWlbsControl);
      
      //set the return value
      vValue.vt   = VT_I4;
      vValue.lVal = static_cast<long>(dwReturnValue);
      hRes = pOutputInstance->Put(_bstr_t(L"ReturnValue"), 0, &vValue, 0);

      if( FAILED( hRes ) ) {
        throw _com_error( hRes );
      }

      if( pOutputInstance ) {
        hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }
      }

    } else if( _wcsicmp( a_strMethodName, MOF_CLUSTERSETTING::pMethods[MOF_CLUSTERSETTING::SETDEF] ) == 0 ) {
      pCluster->SetClusterDefaults();
    } else {
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    //get the parameters
    //call the underlying API
    //set the function return parameter
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
       throw _com_error( WBEM_E_FAILED );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;

  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    hRes = HResErr.Error();
  }

  catch ( ... ) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::FillWbemInstance
//
// Purpose: This function copies all of the data from a cluster configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ClusterSetting::FillWbemInstance( IWbemClassObject* a_pWbemInstance,
                    CWlbsClusterWrapper* pCluster)
{
  namespace CLUSTER = MOF_CLUSTERSETTING;

  ASSERT( a_pWbemInstance );
  ASSERT(pCluster );

  CClusterConfiguration ClusterConfig;

  pCluster->GetClusterConfig( ClusterConfig );

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  //NAME
  a_pWbemInstance->Put
    (
      
      _bstr_t( CLUSTER::pProperties[CLUSTER::NAME] ) ,
      0                                              ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  //CLUSNAME
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSNAME] ),
      0                                                  ,
      &_variant_t(ClusterConfig.szClusterName.c_str()),
      NULL
    );

  //CLUSIPADDRESS
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSIPADDRESS] ),
      0                                                  ,
      &_variant_t(ClusterConfig.szClusterIPAddress.c_str()),
      NULL
    );

  //CLUSNETMASK
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSNETMASK] ),
      0                                                ,
      &_variant_t(ClusterConfig.szClusterNetworkMask.c_str()),
      NULL
    );

  //CLUSMAC
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSMAC] ),
      0                                                ,
      &_variant_t(ClusterConfig.szClusterMACAddress.c_str()),
      NULL
    );

  //MULTIENABLE
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::MULTIENABLE] ),
      0                                                ,
      &_variant_t(ClusterConfig.bMulticastSupportEnable),
      NULL
    );


  //REMCNTEN
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::REMCNTEN] ),
      0                                                ,
      &_variant_t(ClusterConfig.bRemoteControlEnabled),
      NULL
    );

  //IGMPSUPPORT
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::IGMPSUPPORT] ),
      0                                                ,
      &_variant_t(ClusterConfig.bIgmpSupport),
      NULL
    );
    
  //CLUSTERIPTOMULTICASTIP
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSTERIPTOMULTICASTIP] ),
      0                                                ,
      &_variant_t(ClusterConfig.bClusterIPToMulticastIP),
      NULL
    );
  //MULTICASTIPADDRESS
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::MULTICASTIPADDRESS] ),
      0                                                ,
      &_variant_t(ClusterConfig.szMulticastIPAddress.c_str()),
      NULL
    );

  //ADAPTERGUID 

  GUID AdapterGuid = pCluster->GetAdapterGuid();
  
  WCHAR szAdapterGuid[128];
  StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );
  
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::ADAPTERGUID] ),
      0                                                ,
      &_variant_t(szAdapterGuid),
      NULL
    );

  //BDA Team Active
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::BDATEAMACTIVE] ),
      0                                                ,
      &_variant_t(ClusterConfig.bBDATeamActive),
      NULL
    );

  if (ClusterConfig.bBDATeamActive) 
  {
      //BDA Team Id
      a_pWbemInstance->Put
        (
          _bstr_t( CLUSTER::pProperties[CLUSTER::BDATEAMID] ),
          0                                                ,
          &_variant_t(ClusterConfig.szBDATeamId.c_str()),
          NULL
        );

      //BDA Team Master
      a_pWbemInstance->Put
        (
          _bstr_t( CLUSTER::pProperties[CLUSTER::BDATEAMMASTER] ),
          0                                                ,
          &_variant_t(ClusterConfig.bBDATeamMaster),
          NULL
        );

      //BDA Reverse Hash 
      a_pWbemInstance->Put
        (
          _bstr_t( CLUSTER::pProperties[CLUSTER::BDAREVERSEHASH] ),
          0                                                ,
          &_variant_t(ClusterConfig.bBDAReverseHash),
          NULL
        );
  }

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::UpdateConfiguration
//
// Purpose: This function updates the configuration data for a member node or a
//          potential WLBS cluster node.
//    
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ClusterSetting::UpdateConfiguration
  ( 
    IWbemClassObject* a_pInstance, 
    CWlbsClusterWrapper* pCluster
  )
{
  namespace CLUSTER = MOF_CLUSTERSETTING;

  CClusterConfiguration NewConfiguration;
  CClusterConfiguration OldConfiguration;

  pCluster->GetClusterConfig( OldConfiguration );

  //Cluster Name
  UpdateConfigProp
    ( 
      NewConfiguration.szClusterName,
      OldConfiguration.szClusterName,
      CLUSTER::pProperties[CLUSTER::CLUSNAME],
      a_pInstance 
    );

  //Cluster IP
  UpdateConfigProp
    ( 
      NewConfiguration.szClusterIPAddress,
      OldConfiguration.szClusterIPAddress,
      CLUSTER::pProperties[CLUSTER::CLUSIPADDRESS],
      a_pInstance 
    );

  //Cluster Network Mask
  UpdateConfigProp
    ( 
      NewConfiguration.szClusterNetworkMask,
      OldConfiguration.szClusterNetworkMask,
      CLUSTER::pProperties[CLUSTER::CLUSNETMASK],
      a_pInstance 
    );

  //Cluster enable remote control
  UpdateConfigProp
    ( 
      NewConfiguration.bRemoteControlEnabled,
      OldConfiguration.bRemoteControlEnabled,
      CLUSTER::pProperties[CLUSTER::REMCNTEN],
      a_pInstance 
    );

  //Cluster enable multicast support
  UpdateConfigProp
    ( 
      NewConfiguration.bMulticastSupportEnable,
      OldConfiguration.bMulticastSupportEnable,
      CLUSTER::pProperties[CLUSTER::MULTIENABLE],
      a_pInstance 
    );


  //IGMPSUPPORT
  UpdateConfigProp
    ( 
      NewConfiguration.bIgmpSupport,
      OldConfiguration.bIgmpSupport,
      CLUSTER::pProperties[CLUSTER::IGMPSUPPORT],
      a_pInstance 
    );


  //CLUSTERIPTOMULTICASTIP
  UpdateConfigProp
    ( 
      NewConfiguration.bClusterIPToMulticastIP,
      OldConfiguration.bClusterIPToMulticastIP,
      CLUSTER::pProperties[CLUSTER::CLUSTERIPTOMULTICASTIP],
      a_pInstance 
    );


  //MULTICASTIPADDRESS
  UpdateConfigProp
    ( 
      NewConfiguration.szMulticastIPAddress,
      OldConfiguration.szMulticastIPAddress,
      CLUSTER::pProperties[CLUSTER::MULTICASTIPADDRESS],
      a_pInstance 
    );

  //BDA Teaming Active ?
  UpdateConfigProp
    ( 
       NewConfiguration.bBDATeamActive,
       OldConfiguration.bBDATeamActive,
       CLUSTER::pProperties[CLUSTER::BDATEAMACTIVE],
       a_pInstance 
    );

  // Set the other BDA properties only if the "Active" property is set
  if (NewConfiguration.bBDATeamActive)
  {
      //BDA Team ID
      UpdateConfigProp
        ( 
          NewConfiguration.szBDATeamId,
          OldConfiguration.szBDATeamId,
          CLUSTER::pProperties[CLUSTER::BDATEAMID],
          a_pInstance 
        );

      //BDA Team Master
      UpdateConfigProp
        ( 
          NewConfiguration.bBDATeamMaster,
          OldConfiguration.bBDATeamMaster,
          CLUSTER::pProperties[CLUSTER::BDATEAMMASTER],
          a_pInstance 
        );

      //BDA Team Reverse Hash
      UpdateConfigProp
        ( 
          NewConfiguration.bBDAReverseHash,
          OldConfiguration.bBDAReverseHash,
          CLUSTER::pProperties[CLUSTER::BDAREVERSEHASH],
          a_pInstance 
        );

  }

  pCluster->PutClusterConfig( NewConfiguration );
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_cluster.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_Cluster.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "param.h"
#include "wlbsutil.h"
#include "wlbs_cluster.tmh" // for event tracing

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::CWLBS_Cluster
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_Cluster::CWLBS_Cluster( CWbemServices*   a_pNameSpace, 
                              IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_Cluster::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_Cluster( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::GetInstance
//
// Purpose: This function retrieves an instance of a MOF Cluster class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Cluster::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    /*a_lFlags*/,
    IWbemContext*           a_pIContex
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //get the name key property and convert to wstring
    //throws _com_error

    const WCHAR* wstrRequestedClusterName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwNumHosts  = 0;

    //check to see if the requested cluster name matches the configured value
    // The name does not have host id in it.

    DWORD dwClusterIpOrIndex = IpAddressFromAbcdWsz(wstrRequestedClusterName);
    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);

    if (pCluster == NULL)
        throw _com_error( WBEM_E_NOT_FOUND );


    BOOL bGetStatus = TRUE;

    //this is an optimization check
    //if WinMgMt is calling this prior to an Exec call, then this
    //routine will not perform a cluster query call since the
    //status of the cluster is not required in this case
    if (a_pIContex) {

        VARIANT v;

        VariantInit( &v );

        HRESULT hRes = a_pIContex->GetValue(L"__GET_EXT_KEYS_ONLY", 0, &v);

        if ( FAILED( hRes ) ) {
        throw _com_error( WBEM_E_FAILED );
        }

        bGetStatus = FALSE;

        // CLD: Need to check return code for error
        if (S_OK != VariantClear( &v ))
            throw _com_error( WBEM_E_FAILED );
    }

    //call the API query function
    //dwStatus contains a cluster-wide status number
    DWORD   dwStatus = 0;
    if ( bGetStatus ) 
    {
      dwStatus = g_pWlbsControl->Query( pCluster    ,
                                            WLBS_ALL_HOSTS , 
                                            NULL           , 
                                            &dwNumHosts    , 
                                            NULL );

      if( !ClusterStatusOK( dwStatus ) )
        throw _com_error( WBEM_E_FAILED );
    }
    
    //get the Wbem class instance
    SpawnInstance( MOF_CLUSTER::szName, &pWlbsInstance );

    //Convert status to string description
    FillWbemInstance( pWlbsInstance, pCluster, dwStatus );
    
    //Send results to Wbem
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }
  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    hRes = HResErr.Error();
    
    //transform Win32 error to a WBEM error
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
  }

  catch(...) {

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }
    
    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::EnumInstances
//
// Purpose: This function determines if the current host is in the cluster 
//          and then obtains the configuration information for the cluster.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Cluster::EnumInstances
  ( 
    BSTR             /*a_bstrClass*/,
    long             /*a_lFlags*/, 
    IWbemContext*    a_pIContex
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    BOOL bGetStatus = TRUE;

    //this is an optimization check
    //if WinMgMt is calling this prior to an Exec call, then this
    //routine will not perform a cluster query call since the
    //status of the cluster is not required in this case
      if (a_pIContex)   {

      VARIANT v;

      VariantInit( &v );

        HRESULT hRes = a_pIContex->GetValue(L"__GET_EXT_KEYS_ONLY", 0, &v);

        if ( FAILED( hRes ) ) {
        throw _com_error( WBEM_E_FAILED );
      }

      bGetStatus = FALSE;

      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &v ))
          throw _com_error( WBEM_E_FAILED );
    }
    
    for (DWORD i=0; i<dwNumClusters; i++)
    {

        //call the API query function
        //dwStatus contains a cluster-wide status number
        DWORD   dwStatus = 0;
        if ( bGetStatus ) 
        {
          DWORD dwNumHosts = 0;

          try {
              dwStatus = g_pWlbsControl->Query( ppCluster[i],
                                                WLBS_ALL_HOSTS , 
                                                NULL           , 
                                                &dwNumHosts    , 
                                                NULL);
          } catch (CErrorWlbsControl Err)
          {
            //
            // Skip this cluster
            //
            TRACE_ERROR1("CWLBS_Cluster::EnumInstances skiped cluster %x", 
                    ppCluster[i]->GetClusterIP());
            continue;
          }


          if( !ClusterStatusOK( dwStatus ) )
          {
            //
            // Skip this cluster
            //
            TRACE_ERROR1("CWLBS_Cluster::EnumInstances skiped cluster %x", 
                    ppCluster[i]->GetClusterIP());
            continue;
          }
        }
    
        //get the Wbem class instance
        SpawnInstance( MOF_CLUSTER::szName, &pWlbsInstance );

        //Convert status to string description
        FillWbemInstance( pWlbsInstance, ppCluster[i], dwStatus );
    
        //send the results back to WinMgMt
        m_pResponseHandler->Indicate( 1, &pWlbsInstance );
        if( pWlbsInstance )
          pWlbsInstance->Release();
    }
    
    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );
    hRes = WBEM_S_NO_ERROR;
    
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat  = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch( _com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
    {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    hRes = HResErr.Error();
    
    //transform Win32 error to a WBEM error
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND ;
  }

  catch(...) {

    if( pWlbsInstance )
    {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::ExecMethod
//
// Purpose: This executes the methods associated with the MOF
//          Cluster class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Cluster::ExecMethod
  (
    const ParsedObjectPath* a_pParsedPath, 
    const BSTR&             a_strMethodName, 
    long                    /*a_lFlags*/, 
    IWbemContext*           /*a_pIContex*/, 
    IWbemClassObject*       a_pIInParams
  )
{

  IWbemClassObject* pOutputInstance   = NULL;
  HRESULT hRes = 0;

  BSTR        strPortNumber = NULL;
  BSTR        strNumNodes   = NULL;

  VARIANT     vValue;
  CNodeConfiguration NodeConfig;

  VariantInit( &vValue  );
  
  TRACE_VERB(L"-> CWLBS_Cluster::ExecMethod(%ws)", (WCHAR *) a_strMethodName);

  try {
    CWlbsClusterWrapper* pCluster = NULL;
    
    if (a_pParsedPath->m_paKeys == NULL)
    {
        // 
        // No cluster IP specified
        //
        throw _com_error( WBEM_E_INVALID_PARAMETER );
    }
    else
    {
        const wchar_t* wstrRequestedClusterName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

        //check to see if the requested cluster name matches the configured value
        // The name does not have host id in it.
        DWORD dwClusterIpOrIndex = IpAddressFromAbcdWsz(wstrRequestedClusterName);

        pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);
    }

    if (pCluster == NULL)
        throw _com_error( WBEM_E_NOT_FOUND );

    DWORD         dwNumHosts = WLBS_MAX_HOSTS;
    DWORD         dwReturnValue;
    DWORD         dwClustIP;

    strPortNumber = SysAllocString( MOF_PARAM::PORT_NUMBER );
    strNumNodes   = SysAllocString( MOF_PARAM::NUM_NODES );

    if( !strPortNumber || !strNumNodes )
      throw _com_error( WBEM_E_OUT_OF_MEMORY );

    dwClustIP = pCluster->GetClusterIpOrIndex(g_pWlbsControl);

    //get the output object instance
    GetMethodOutputInstance( MOF_CLUSTER::szName, 
                             a_strMethodName, 
                             &pOutputInstance);

    //*************************************************************************
    //
    //Determine and execute the MOF method
    //
    //*************************************************************************
    if( _wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::DISABLE] ) == 0)  {
    
      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Disable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );
      
      //get the port number
      hRes = a_pIInParams->Get
                (  strPortNumber, 
                   0, 
                   &vValue, 
                   NULL, 
                   NULL
                 );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //range checking is done by the API
      if( vValue.vt != VT_I4 ) 
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      //call Disable method
      dwReturnValue = g_pWlbsControl->Disable
                        (
                          dwClustIP,
                          WLBS_ALL_HOSTS, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          vValue.lVal
                        );

    } else if(_wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::ENABLE] ) == 0)  {

      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Enable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );
      
      //get the port number
      hRes = a_pIInParams->Get
               ( 
                 strPortNumber, 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //range checking is done by the API
      if( vValue.vt != VT_I4 ) 
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      //call Enable method
      dwReturnValue = g_pWlbsControl->Enable
        (
          dwClustIP,
          WLBS_ALL_HOSTS, 
          NULL, 
          dwNumHosts, 
          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
          vValue.lVal
        );

    } else if( _wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::DRAIN] ) == 0 )  {

      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Drain" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );
      
      //get the port number
      hRes = a_pIInParams->Get
               ( 
                 strPortNumber, 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //range checking is done by the API
      if( vValue.vt != VT_I4 ) 
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      //call Drain method
      dwReturnValue = g_pWlbsControl->Drain
                        (
                          dwClustIP,
                          WLBS_ALL_HOSTS, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          vValue.lVal
                        );

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::DRAINSTOP]) == 0)  {

      //call DrainStop method
      dwReturnValue = g_pWlbsControl->DrainStop(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::RESUME]   ) == 0)  {

      //call Resume method
      dwReturnValue = g_pWlbsControl->Resume(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::START]    ) == 0)  {

      //call Start method
      dwReturnValue = g_pWlbsControl->Start(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::STOP]     ) == 0)  {

      //call Stop method
      dwReturnValue = g_pWlbsControl->Stop(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::SUSPEND]  ) == 0)  {

      //call Suspend method
      dwReturnValue = g_pWlbsControl->Suspend(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else {
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    //*************************************************************************
    //
    //Output Results
    //
    //*************************************************************************

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
            throw _com_error( WBEM_E_FAILED );

    //set the return value
    vValue.vt   = VT_I4;
    vValue.lVal = static_cast<long>(dwReturnValue);
    hRes = pOutputInstance->Put(_bstr_t(L"ReturnValue"), 0, &vValue, 0);

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }

    //set the number of hosts property
    vValue.vt   = VT_I4;
    vValue.lVal = static_cast<long>(dwNumHosts);
    hRes = pOutputInstance->Put(strNumNodes, 0, &vValue, 0);

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    //send the results back to WinMgMt
    hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    m_pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);


    //*************************************************************************
    //
    //Release Resources
    //
    //*************************************************************************

    //COM Interfaces
    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //**** BSTRs ****
    if( strPortNumber ) {
      SysFreeString( strPortNumber );
      strPortNumber = NULL;
    }

    if( strNumNodes ) {
      SysFreeString( strNumNodes );
      strNumNodes = NULL;
    }

    //**** VARIANTs ****
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat  = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    //COM Interfaces
    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //**** BSTRs ****
    if( strPortNumber ) {
      SysFreeString( strPortNumber );
      strPortNumber = NULL;
    }

    if( strNumNodes ) {
      SysFreeString( strNumNodes );
      strNumNodes = NULL;
    }

    //**** VARIANTs ****
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception. Also, given the comment below, not sure
    // what exception we'd return...
    VariantClear( &vValue );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch( _com_error HResErr ) {

    //COM Interfaces
    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //**** BSTRs ****
    if( strPortNumber ) {
      SysFreeString( strPortNumber );
      strPortNumber = NULL;
    }

    if( strNumNodes ) {
      SysFreeString( strNumNodes );
      strNumNodes = NULL;
    }

    //**** VARIANTs ****
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);
    hRes = HResErr.Error();
  }

  catch(...) {

    //COM Interfaces
    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //**** BSTRs ****
    if( strPortNumber ) {
      SysFreeString( strPortNumber );
      strPortNumber = NULL;
    }

    if( strNumNodes ) {
      SysFreeString( strNumNodes );
      strNumNodes = NULL;
    }

    //**** VARIANTs ****
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception
    VariantClear( &vValue );

    throw;

  }

  TRACE_VERB(L"<- CWLBS_Cluster::ExecMethod(%ws) returns 0x%08lx",
             (WCHAR *) a_strMethodName, (UINT) hRes);

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::FillWbemInstance
//
// Purpose: This function copies all of the data from a cluster configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Cluster::FillWbemInstance
  ( 
          IWbemClassObject*   a_pWbemInstance, 
          CWlbsClusterWrapper* pCluster,
          const DWORD               a_dwStatus
  )
{
  namespace CLUSTER = MOF_CLUSTER;

  ASSERT( a_pWbemInstance );
  ASSERT(pCluster);

  CClusterConfiguration ClusterConfig;
  pCluster->GetClusterConfig( ClusterConfig );


  //InterconnectAddress
  wstring wstrClusterIp;
  AddressToString( pCluster->GetClusterIP(), wstrClusterIp );

  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::IPADDRESS] ),
      0                                                  ,
      &_variant_t(wstrClusterIp.c_str()),
      NULL
    );

  //Name
  wstring wstrClusterIndex;
  AddressToString( pCluster->GetClusterIpOrIndex(g_pWlbsControl), wstrClusterIndex );

  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::NAME] ),
      0                                                  ,
      &_variant_t(wstrClusterIndex.c_str()),
      NULL
    );

  //MaxNodes
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::MAXNODES] ),
      0                                                ,
      &_variant_t(ClusterConfig.nMaxNodes),
      NULL
    );

  //ClusterState
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSSTATE] ),
      0                                                ,
      &_variant_t((short)a_dwStatus),
      NULL
    );

  //CREATCLASS 
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CREATCLASS] ),
      0                                                ,
      &_variant_t(CLUSTER::szName),
      NULL
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_clusclussetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_ClusClusSetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::CWLBS_ClusClusSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_ClusClusSetting::CWLBS_ClusClusSetting(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_ClusClusSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_ClusClusSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::GetInstance
//
// Purpose:
//
// TODO: Implement later
//       Not critical
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusClusSetting::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    a_lFlags,
    IWbemContext*           a_pIContex
  )
{
  IWbemClassObject* pWlbsInstance = NULL;

  try {

    //TODO: remove
    throw _com_error( WBEM_E_NOT_SUPPORTED );
/*
    //get the node
    FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }
*/
    return WBEM_S_NO_ERROR;
  }

  catch(...) {

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    throw;

  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::EnumInstances
//
// Purpose: This verifies cluster existence and constructs associator.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusClusSetting::EnumInstances
  ( 
    BSTR             a_bstrClass,
    long             a_lFlags, 
    IWbemContext*    a_pIContex
  )
{
  IWbemClassObject* pWlbsInstance    = NULL;
  HRESULT hRes = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i < dwNumClusters; i++)
    {
        //spawn an instance of the associator
        SpawnInstance(MOF_CLUSCLUSSETTING::szName, &pWlbsInstance );

        FillWbemInstance(ppCluster[i], pWlbsInstance);

        //send the results back to WinMgMt
        hRes= m_pResponseHandler->Indicate( 1, &pWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( pWlbsInstance )
          pWlbsInstance->Release();
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat  = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch( _com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::FillWbemInstance
//
// Purpose: This constructs the wbem associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ClusClusSetting::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance
  )
{
  namespace CCS = MOF_CLUSCLUSSETTING;

  ASSERT( a_pWbemInstance );

  ParsedObjectPath ClusSetPath;
  ParsedObjectPath ClusterPath;
  LPWSTR           szClusSetPath = NULL;
  LPWSTR           szClusterPath = NULL;

  try {

  //set the names of the classes
  if( !ClusSetPath.SetClassName( MOF_CLUSTERSETTING::szName ) )
    throw _com_error( WBEM_E_FAILED );

  if( !ClusterPath.SetClassName( MOF_CLUSTER::szName ) )
    throw _com_error( WBEM_E_FAILED );

  //Get the cluster name

  DWORD   dwClusterIpOrIndex = pCluster->GetClusterIpOrIndex(g_pWlbsControl);

  wstring wstrHostName;
  ConstructHostName( wstrHostName,  dwClusterIpOrIndex, pCluster->GetHostID());

  _variant_t vString;


  //set the keys for the node and cluster
  vString = wstrHostName.c_str();
  if( !ClusSetPath.AddKeyRef( MOF_CLUSTERSETTING::pProperties[MOF_CLUSTERSETTING::NAME],
         &vString ) )
    throw _com_error( WBEM_E_FAILED );

  wstring wstrClusterIndex;
  AddressToString( dwClusterIpOrIndex, wstrClusterIndex );
  vString = wstrClusterIndex.c_str();
  if( !ClusterPath.AddKeyRef( MOF_CLUSTER::pProperties[MOF_CLUSTER::NAME],
         &vString ) )
    throw _com_error( WBEM_E_FAILED );

  //convert parsed object paths to strings
  if (CObjectPathParser::Unparse(&ClusSetPath, &szClusSetPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );
  if (CObjectPathParser::Unparse(&ClusterPath, &szClusterPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );

  //Node reference
  vString = szClusSetPath;
  HRESULT hRes = a_pWbemInstance->Put
    (
      _bstr_t( CCS::pProperties[CCS::CLUSSET] ),
      0,
      &vString,
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //Cluster reference
  vString = szClusterPath;
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( CCS::pProperties[CCS::CLUSTER] ),
      0,
      &vString,
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //free resources
  ClusterPath.ClearKeys();
  ClusSetPath.ClearKeys();

  if( szClusSetPath )
    delete (szClusSetPath);

  if( szClusterPath )
    delete (szClusterPath);

  } catch (...) {

    ClusterPath.ClearKeys();
    ClusSetPath.ClearKeys();

    if( szClusSetPath )
      delete (szClusSetPath);

    if( szClusterPath )
      delete (szClusterPath);

    throw;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_clustersetting.h ===
#ifndef _CLUSTERSETTING_INCLUDED_
#define _CLUSTERSETTING_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_ClusterSetting
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node configuration class.

//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_ClusterSetting : public CWlbs_Root
{
public:

  CWLBS_ClusterSetting(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

  HRESULT PutInstance( 
                       IWbemClassObject* a_pInstance,
                       long              a_lFlags            = 0,
                       IWbemContext*     a_pIContex          = NULL
                     );

  HRESULT ExecMethod( 
                      const ParsedObjectPath* a_pParsedPath, 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags            = 0, 
                      IWbemContext*           a_pIContex          = NULL, 
                      IWbemClassObject*       a_pIInParams        = NULL 
                    );

private:

  void FillWbemInstance( IWbemClassObject*   a_pWbemInstance,
		  CWlbsClusterWrapper* pCluster);

  void UpdateConfiguration( IWbemClassObject* a_pInstance,
  		    CWlbsClusterWrapper* pCluster);

};

#endif //_CLUSTERSETTING_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_guids.cpp ===
//WLBSGuids.cpp
#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_dllmain.cpp ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation.
//
//  File:   WLBSMain.CPP
// 
//  Module: WLBS Instance provider code
//
//  Purpose: Contains DLL entry points.  Also containts code that controls
//           when the DLL can be unloaded by tracking the number of
//           components and sever locks as well as routines that support
//           self registration.
//
//      History:
//
//***************************************************************************

#include "WLBS_Provider.h"
#include <objbase.h>
#include "ControlWrapper.h"
#include "WLBS_DllMain.tmh" // for event tracing

#define THIS_PROVIDERS_NAME L"Microsoft NLB Instance Provider"

//CLSID for provider
// {FB223274-D72E-11d2-A420-00C04F68FE28}
static const GUID CLSID_WLBSProvider = 
{ 0xfb223274, 0xd72e, 0x11d2, { 0xa4, 0x20, 0x0, 0xc0, 0x4f, 0x68, 0xfe, 0x28 } };


static HMODULE    g_hModule      = NULL; //DLL Module Handle
CWlbsControlWrapper*     g_pWlbsControl = NULL;

//Track number of objects and number of locks.
long g_cComponents  = 0;    //Count of active components
long g_cServerLocks = 0;    //Count of server locks

//***************************************************************************
//
// DllMain
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE a_hInstance,    // handle to DLL module
    DWORD     a_fdwReason,    // reason for calling function
    LPVOID    /* a_lpvReserved */   // reserved
  )
{
  
  if (a_fdwReason == DLL_PROCESS_ATTACH) {

  //set the global module handle
    g_hModule = a_hInstance;

    //
    // Enable tracing
    //
    WPP_INIT_TRACING(L"Microsoft\\NLB");
  }

  if (a_fdwReason == DLL_PROCESS_DETACH) {

    if( g_pWlbsControl != NULL ) {
      delete g_pWlbsControl;
    }

    //
    // Disable tracing
    //
    WPP_CLEANUP();
  }

  return TRUE;
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by OLE when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************
STDAPI DllGetClassObject(REFCLSID a_rclsid, REFIID a_riid, PPVOID a_ppv)
{
  HRESULT hr;
  CWLBSClassFactory *pWLBSFacObj;

  if ( a_rclsid != CLSID_WLBSProvider )
      return CLASS_E_CLASSNOTAVAILABLE;

  pWLBSFacObj = new CWLBSClassFactory();

  if ( pWLBSFacObj == NULL )
      return E_OUTOFMEMORY;

  hr=pWLBSFacObj->QueryInterface( a_riid, a_ppv );

  pWLBSFacObj->Release();

  return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************
STDAPI DllCanUnloadNow(void)
{
  SCODE   SCode;

  //It is OK to unload if there are no objects or locks on the 
  // class factory.
  
  SCode = (g_cComponents == 0L && g_cServerLocks == 0L) ? S_OK : S_FALSE;

  // Do not let this provider unload implicitly. The API is maintaining a
  // cache that must persist in order for proper operation.
  // return S_FALSE;

  return SCode;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
STDAPI DllRegisterServer(void)
{   
  WCHAR   wcID[128];
  WCHAR   szCLSID[128];
  WCHAR   szModule[MAX_PATH];
  const WCHAR * pName = THIS_PROVIDERS_NAME;
  const WCHAR * pThreadingModel = L"Apartment";
  HKEY    hKey1, hKey2;
  LONG    nRet;
  
  
  // Create the path.

  StringFromGUID2(CLSID_WLBSProvider, wcID, 128);
  wcscpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
  wcscat(szCLSID, wcID);

  // Create entries under CLSID

  nRet = RegCreateKey( HKEY_LOCAL_MACHINE, szCLSID, &hKey1 );
  nRet = RegSetValueEx( hKey1, 
                        NULL, 
                        0, 
                        REG_SZ, 
                        (BYTE *)pName, 
                        (wcslen(pName)+1) * sizeof(WCHAR) );

  nRet = RegCreateKey( hKey1, L"InprocServer32", &hKey2 );

  GetModuleFileName( g_hModule, szModule,  MAX_PATH );
  nRet = RegSetValueEx( hKey2, 
                        NULL, 
                        0, 
                        REG_SZ, 
                        (BYTE *)szModule, 
                        (wcslen(szModule)+1) * sizeof(WCHAR) );

  nRet = RegSetValueEx( hKey2, 
                        L"ThreadingModel", 
                        0, 
                        REG_SZ, 
                        (BYTE *)pThreadingModel, 
                        (wcslen(pThreadingModel)+1) * sizeof(WCHAR) );

  nRet = RegCloseKey(hKey1);
  nRet = RegCloseKey(hKey2);

  // 12/11/00 JosephJ
  // We used to compile the MOF file here. However, this has
  // moved to indirect compilation via an entry for wlbsprov.mof in
  // \nt\MergedComponents\SetupInfs\wbemoc.inx
  //

#if 0
  /* shouse 6.20.00 - Adding MOF compile support to assure that the WLBS MOF gets compiled when necessary. */
  IMofCompiler * pMofComp = NULL;
  WBEM_COMPILE_STATUS_INFO Info;
  WCHAR szMOFPath[MAX_PATH];
  HRESULT hrStatus = S_OK;

  /* shouse 6.20.00 - Zero the memory contents. */
  ZeroMemory((VOID *)&Info, sizeof(WBEM_COMPILE_STATUS_INFO));
  ZeroMemory((VOID *)szMOFPath, sizeof(szMOFPath));

  /* shouse 6.20.00 - Query the system root directory. */
  if (!GetWindowsDirectory(szMOFPath, MAX_PATH)) {
      hrStatus = GetLastError();
      TRACE_ERROR1("GetWindowsDirectory failed: %d\n", hrStatus);
      return hrStatus;
  }

  /* shouse 6.20.00 - Concatenate the windows system path with the MOF path. */
  lstrcat(szMOFPath, L"\\system32\\wbem\\wlbsprov.mof");

  /* shouse 6.20.00 - Create an instance of the MOF compiler. */
  if ((hrStatus = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *)&pMofComp)) != S_OK) {
      TRACE_ERROR1("CoCreateInstance failed: %d\n", hrStatus);
      return hrStatus;
  }
  
  /* shouse 6.20.00 - Compile the WLBS provider. */
  if ((hrStatus = pMofComp->CompileFile((LPWSTR)szMOFPath, NULL, NULL, NULL, NULL, 0, 0, 0, &Info)) != WBEM_S_NO_ERROR) {
      TRACE_ERROR2("CompileFile failed: %d:0x%x\n", hrStatus, Info.hRes);
      return hrStatus;
  }
  
  /* shouse 6.20.00 - Release the MOF compiler. */
  pMofComp->Release();

#endif // 0

  return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
STDAPI DllUnregisterServer(void)
{
  WCHAR szCLSID[128];

  WCHAR wcID[128];
  HKEY  hKey;

  // Create the path using the CLSID

  StringFromGUID2(CLSID_WLBSProvider, wcID, 128);
  wcscpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
  wcscat(szCLSID, wcID);

  // First delete the InProcServer subkey.

  DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
  if(dwRet == NO_ERROR)
  {
      RegDeleteKey(hKey, L"InProcServer32");
      RegCloseKey(hKey);
  }

  dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, L"Software\\classes\\CLSID", &hKey);
  if(dwRet == NO_ERROR)
  {
      RegDeleteKey(hKey,wcID);
      RegCloseKey(hKey);
  }

  return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_moflists.h ===
//GENERATE_VALUE_LIST changes how LIST_ITEM appears when
//expanded by the preprocessor. 

//When GENERATE_VALUE_LIST is not defined,
//LIST_ITEM expands to the first column, which is utilized
//within WLBS_MOFData.h to define enumarated types that
//act as keys to their correlated arrays. 

//When GENERATE_VALUE_LIST is defined, LIST_ITEM
//expands to the second column which is utilized within
//WLBS_MOFData.cpp to initialize arrays of strings.

#ifdef GENERATE_VALUE_LIST

# ifdef LIST_ITEM
#   undef LIST_ITEM
# endif

# define LIST_ITEM(WLBS_KEY, WLBS_VALUE) WLBS_VALUE

#else

# ifdef LIST_ITEM
#   undef LIST_ITEM
# endif

# define LIST_ITEM(WLBS_KEY, WLBS_VALUE) WLBS_KEY

#endif

//The first columns represent arrays of keys and are defined in
//enumerated types. The second columns are values that are
//stored in arrays of strings. The arrays are stored within
//namespaces and are initialized in WLBS_MOFData.cpp. The 
//enumerated types are also scoped within namespaces and are
//defined in WLBS_MOFData.h.

#define MOF_NODE_PROPERTY_LIST \
  LIST_ITEM(NAME,       L"Name")                  , \
  LIST_ITEM(HOSTID,     L"HostPriority")          , \
  LIST_ITEM(IPADDRESS,  L"DedicatedIPAddress")    , \
  LIST_ITEM(STATUS,     L"StatusCode")				        , \
  LIST_ITEM(CREATCLASS, L"CreationClassName")

#define MOF_NODE_METHOD_LIST \
  LIST_ITEM(DISABLE,   L"Disable")  , \
  LIST_ITEM(ENABLE,    L"Enable")   , \
  LIST_ITEM(DRAIN,     L"Drain")    , \
  LIST_ITEM(DRAINSTOP, L"DrainStop"), \
  LIST_ITEM(RESUME,    L"Resume")   , \
  LIST_ITEM(START,     L"Start")    , \
  LIST_ITEM(STOP,      L"Stop")     , \
  LIST_ITEM(SUSPEND,   L"Suspend")

#define MOF_CLUSTER_PROPERTY_LIST \
  LIST_ITEM(NAME,       L"Name")                , \
  LIST_ITEM(IPADDRESS,  L"InterconnectAddress") , \
  LIST_ITEM(MAXNODES,   L"MaxNumberOfNodes")    , \
  LIST_ITEM(CLUSSTATE,  L"ClusterState")        , \
  LIST_ITEM(CREATCLASS, L"CreationClassName")   , \
  LIST_ITEM(STATUS,     L"ClusterState")

#define MOF_CLUSTER_METHOD_LIST \
  LIST_ITEM(DISABLE,   L"Disable")  , \
  LIST_ITEM(ENABLE,    L"Enable")   , \
  LIST_ITEM(DRAIN,     L"Drain")    , \
  LIST_ITEM(DRAINSTOP, L"DrainStop"), \
  LIST_ITEM(RESUME,    L"Resume")   , \
  LIST_ITEM(START,     L"Start")    , \
  LIST_ITEM(STOP,      L"Stop")     , \
  LIST_ITEM(SUSPEND,   L"Suspend")

#define MOF_CLUSTERSETTING_PROPERTY_LIST \
  LIST_ITEM(NAME,             L"Name")                    , \
  LIST_ITEM(CLUSNAME,         L"ClusterName")             , \
  LIST_ITEM(CLUSIPADDRESS,    L"ClusterIPAddress")        , \
  LIST_ITEM(CLUSNETMASK,      L"ClusterNetworkMask")      , \
  LIST_ITEM(CLUSMAC,          L"ClusterMACAddress")       , \
  LIST_ITEM(MULTIENABLE,      L"MulticastSupportEnabled") , \
  LIST_ITEM(REMCNTEN,         L"RemoteControlEnabled")    , \
  LIST_ITEM(IGMPSUPPORT,      L"IgmpSupport") , \
  LIST_ITEM(CLUSTERIPTOMULTICASTIP,      L"ClusterIPToMulticastIP") , \
  LIST_ITEM(MULTICASTIPADDRESS,      L"MulticastIPAddress") , \
  LIST_ITEM(ADAPTERGUID,      L"AdapterGuid")             , \
  LIST_ITEM(BDATEAMACTIVE,    L"BDATeamActive")           , \
  LIST_ITEM(BDATEAMID,        L"BDATeamId")               , \
  LIST_ITEM(BDATEAMMASTER,    L"BDATeamMaster")           , \
  LIST_ITEM(BDAREVERSEHASH,   L"BDAReverseHash") 

#define MOF_CLUSTERSETTING_METHOD_LIST \
  LIST_ITEM(SETPASS,   L"SetPassword")              , \
  LIST_ITEM(LDSETT,    L"LoadAllSettings")          , \
  LIST_ITEM(SETDEF,    L"SetDefaults")

#define MOF_NODESETTING_PROPERTY_LIST \
  LIST_ITEM(NAME,             L"Name")                  , \
  LIST_ITEM(DEDIPADDRESS,     L"DedicatedIPAddress")    , \
  LIST_ITEM(DEDNETMASK,       L"DedicatedNetworkMask")  , \
  LIST_ITEM(NUMRULES,         L"NumberOfRules")         , \
  LIST_ITEM(HOSTPRI,          L"HostPriority")          , \
  LIST_ITEM(MSGPERIOD,        L"AliveMessagePeriod")    , \
  LIST_ITEM(MSGTOLER,         L"AliveMessageTolerance") , \
  LIST_ITEM(CLUSMODEONSTART,  L"ClusterModeOnStart")    , \
  LIST_ITEM(REMOTEUDPPORT,    L"RemoteControlUDPPort")  , \
  LIST_ITEM(MASKSRCMAC,       L"MaskSourceMAC")         , \
  LIST_ITEM(DESCPERALLOC,     L"DescriptorsPerAlloc")   , \
  LIST_ITEM(MAXDESCALLOCS,    L"MaxDescriptorsPerAlloc"), \
  LIST_ITEM(NUMACTIONS,       L"NumActions")            , \
  LIST_ITEM(NUMPACKETS,       L"NumPackets")            , \
  LIST_ITEM(NUMALIVEMSGS,     L"NumAliveMessages")      , \
  LIST_ITEM(ADAPTERGUID,      L"AdapterGuid")           
             

//Removed per kyrilf request 8-12-1999
//  LIST_ITEM(NBTENABLE,        L"NBTSupportEnable")    , \

#define MOF_NODESETTING_METHOD_LIST \
  LIST_ITEM(GETPORT,  L"GetPortRule")                , \
  LIST_ITEM(LDSETT,   L"LoadAllSettings")            , \
  LIST_ITEM(SETDEF,   L"SetDefaults")

#define MOF_PORTRULE_PROPERTY_LIST \
  LIST_ITEM(NAME,   L"Name")      , \
  LIST_ITEM(STPORT, L"StartPort") , \
  LIST_ITEM(EDPORT, L"EndPort")   , \
  LIST_ITEM(PROT,   L"Protocol"), \
  LIST_ITEM(ADAPTERGUID, L"AdapterGuid")


#define MOF_PORTRULE_METHOD_LIST \
  LIST_ITEM(SETDEF,    L"SetDefaults")

#define MOF_PRFAIL_PROPERTY_LIST \
  LIST_ITEM(PRIO, L"Priority")

#define MOF_PRLOADBAL_PROPERTY_LIST \
  LIST_ITEM(EQLD,  L"EqualLoad")  , \
  LIST_ITEM(LDWT,  L"LoadWeight") , \
  LIST_ITEM(AFFIN, L"Affinity")

#define MOF_PARTICIPATINGNODE_PROPERTY_LIST \
  LIST_ITEM(CLUSTER, L"Dependent")    , \
  LIST_ITEM(NODE,    L"Antecedent")

#define MOF_NODESETTINGPORTRULE_PROPERTY_LIST \
  LIST_ITEM(NODESET,  L"GroupComponent")    , \
  LIST_ITEM(PORTRULE, L"PartComponent")

#define MOF_CLUSCLUSSETTING_PROPERTY_LIST \
  LIST_ITEM(CLUSTER, L"Element")    , \
  LIST_ITEM(CLUSSET, L"Setting")

#define MOF_NODENODESETTING_PROPERTY_LIST \
  LIST_ITEM(NODE,    L"Element")    , \
  LIST_ITEM(NODESET, L"Setting")

#define MOF_CLASS_LIST \
  LIST_ITEM(CLUSTER,     L"MicrosoftNLB_Cluster")              , \
  LIST_ITEM(NODE,        L"MicrosoftNLB_Node")                 , \
  LIST_ITEM(CLUSSET,     L"MicrosoftNLB_ClusterSetting")       , \
  LIST_ITEM(NODESET,     L"MicrosoftNLB_NodeSetting")          , \
  LIST_ITEM(PORTRULE,    L"MicrosoftNLB_PortRule")             , \
  LIST_ITEM(PRFAIL,      L"MicrosoftNLB_PortRuleFailover")     , \
  LIST_ITEM(PRDIS,       L"MicrosoftNLB_PortRuleDisabled")     , \
  LIST_ITEM(PRLOADB,     L"MicrosoftNLB_PortRuleLoadbalanced") , \
  LIST_ITEM(PARTNODE,    L"MicrosoftNLB_ParticipatingNode")    , \
  LIST_ITEM(NODESETPR,   L"MicrosoftNLB_NodeSettingPortRule")  , \
  LIST_ITEM(CLUSCLUSSET, L"MicrosoftNLB_ClusterClusterSetting"), \
  LIST_ITEM(NODENODESET, L"MicrosoftNLB_NodeNodeSetting")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_node.h ===
#ifndef _WLBSNODE_INCLUDED_
#define _WLBSNODE_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_Node
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_Node : public CWlbs_Root
{
public:
  CWLBS_Node(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );


  HRESULT ExecMethod( 
                      const ParsedObjectPath* a_pParsedPath, 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags            = 0, 
                      IWbemContext*           a_pIContex          = NULL, 
                      IWbemClassObject*       a_pIInParams        = NULL
                    );

  void FillWbemInstance  ( CWlbsClusterWrapper* pCluster,
  						   IWbemClassObject*   a_pWbemInstance, 
                           WLBS_RESPONSE*     a_pResponse    );

  void FindInstance( IWbemClassObject**       a_ppWbemInstance,
                     const ParsedObjectPath*  a_pParsedPath );

  void FindAllInstances(CWlbsClusterWrapper* pCluster,
   						WLBS_RESPONSE** a_ppResponse,
					    long&     a_nNumNodes );

};

#endif //_WLBSNODE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_mofdata.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_MOFData.h"

#define GENERATE_VALUE_LIST
#include "WLBS_MofLists.h"

namespace MOF_CLASSES
{
  LPWSTR g_szMOFClassList[] = { MOF_CLASS_LIST };
  PCREATE g_pCreateFunc[] = 
  { CWLBS_Cluster::Create, 
    CWLBS_Node::Create, 
    CWLBS_ClusterSetting::Create,
    CWLBS_NodeSetting::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_ParticipatingNode::Create,
    CWLBS_NodeSetPortRule::Create,
    CWLBS_ClusClusSetting::Create,
    CWLBS_NodeNodeSetting::Create
  };
  DWORD  NumClasses = sizeof(g_szMOFClassList)/sizeof(LPWSTR);
};

//MOF_NODE namespace initialization
namespace MOF_NODE
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODE];
  LPWSTR   pProperties[] = { MOF_NODE_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_NODE_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_CLUSTER namespace initialization
namespace MOF_CLUSTER
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSTER];
  LPWSTR   pProperties[] = { MOF_CLUSTER_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_CLUSTER_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_CLUSTERSETTING namespace initialization
namespace MOF_CLUSTERSETTING
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSSET];
  LPWSTR   pProperties[] = { MOF_CLUSTERSETTING_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_CLUSTERSETTING_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_NODESETTING namespace initialization
namespace MOF_NODESETTING
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODESET];
  LPWSTR   pProperties[] = { MOF_NODESETTING_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_NODESETTING_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_PORTRULE namespace initialization
namespace MOF_PORTRULE
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE];
  LPWSTR   pProperties[] = { MOF_PORTRULE_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_PORTRULE_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_PRFAIL namespace initialization
namespace MOF_PRFAIL
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRFAIL];
  LPWSTR   pProperties[] = { MOF_PRFAIL_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_PRLOADBAL namespace initialization
namespace MOF_PRLOADBAL
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRLOADB];
  LPWSTR   pProperties[] = { MOF_PRLOADBAL_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_PRDIS namespace initialization
namespace MOF_PRDIS
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRDIS];
};

//MOF_PARTICIPATINGNODE namespace initialization
namespace MOF_PARTICIPATINGNODE
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PARTNODE];
  LPWSTR   pProperties[] = { MOF_PARTICIPATINGNODE_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_NODESETTINGPORTRULE namespace initialization
namespace MOF_NODESETTINGPORTRULE
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODESETPR];
  LPWSTR   pProperties[] = { MOF_NODESETTINGPORTRULE_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_CLUSCLUSSETTING namespace initialization
namespace MOF_CLUSCLUSSETTING
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSCLUSSET];
  LPWSTR   pProperties[] = { MOF_CLUSCLUSSETTING_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_NODENODESETTING namespace initialization
namespace MOF_NODENODESETTING
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODENODESET];
  LPWSTR   pProperties[] = { MOF_NODENODESETTING_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

namespace MOF_PARAM
{
  LPWSTR PORT_NUMBER  = L"Port";
  LPWSTR HOST_ID      = L"HostID";
  LPWSTR NUM_NODES    = L"NumNodes";
  LPWSTR CLUSIP       = L"ClusterIPAddress";
  LPWSTR CLUSNETMASK  = L"ClusterNetworkMask";
  LPWSTR PASSW        = L"Password";
  LPWSTR DEDIP        = L"DedicatedIPAddress";
  LPWSTR DEDNETMASK   = L"DedicatedNetworkMask";
  LPWSTR PORTRULE     = L"PortRule";
  LPWSTR NODEPATH     = L"Node";
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_mofdata.h ===
//WLBS_MOFData.h
#ifndef _WLBSMOFDATA_INCLUDED_
#define _WLBSMOFDATA_INCLUDED_

#include "WLBS_MofLists.h"

//forward declaration
class CWlbs_Root;

typedef CWlbs_Root* (*PCREATE)(CWbemServices*   a_pNameSpace, 
                               IWbemObjectSink* a_pResponseHandler);

namespace MOF_CLASSES
{
  enum { MOF_CLASS_LIST };
  extern LPWSTR  g_szMOFClassList[];
  extern PCREATE g_pCreateFunc[];
  extern DWORD  NumClasses;
};


//MOF_NODE namespace declaration
namespace MOF_NODE
{
  enum{MOF_NODE_PROPERTY_LIST};
  enum{MOF_NODE_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_NODE_PROPERTY_LIST
#undef MOF_NODE_METHOD_LIST

//MOF_CLUSTER namespace declaration
namespace MOF_CLUSTER
{
  enum{MOF_CLUSTER_PROPERTY_LIST};
  enum{MOF_CLUSTER_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_CLUSTER_PROPERTY_LIST
#undef MOF_CLUSTER_METHOD_LIST

//MOF_CLUSTERSETTING namespace declaration
namespace MOF_CLUSTERSETTING
{
  enum{MOF_CLUSTERSETTING_PROPERTY_LIST};
  enum{MOF_CLUSTERSETTING_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_CLUSTERSETTING_PROPERTY_LIST
#undef MOF_CLUSTERSETTING_METHOD_LIST

//MOF_NODESETTING namespace declaration
namespace MOF_NODESETTING
{
  enum{MOF_NODESETTING_PROPERTY_LIST};
  enum{MOF_NODESETTING_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_NODESETTING_PROPERTY_LIST
#undef MOF_NODESETTING_METHOD_LIST

//MOF_PORTRULE namespace initialization
namespace MOF_PORTRULE
{
  enum { MOF_PORTRULE_PROPERTY_LIST };
  enum {MOF_PORTRULE_METHOD_LIST};

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern LPWSTR   pMethods[];
  extern DWORD    NumProperties;
  extern DWORD    NumMethods;
};

#undef MOF_PORTRULE_PROPERTY_LIST

//MOF_PRFAIL namespace initialization
namespace MOF_PRFAIL
{
  enum { MOF_PRFAIL_PROPERTY_LIST };

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern DWORD    NumProperties;
};

#undef MOF_PRFAIL_PROPERTY_LIST

//MOF_PRLOADBAL namespace initialization
namespace MOF_PRLOADBAL
{
  enum { MOF_PRLOADBAL_PROPERTY_LIST };

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern DWORD    NumProperties;
};

#undef MOF_PRLOADBAL_PROPERTY_LIST

namespace MOF_PRDIS
{
  extern LPWSTR   szName;
};

//MOF_PARTICIPATINGNODE namespace initialization
namespace MOF_PARTICIPATINGNODE
{
  enum { MOF_PARTICIPATINGNODE_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};

#undef MOF_PARTICIPATINGNODE_PROPERTY_LIST

//MOF_NODESETTINGPORTRULE namespace initialization
namespace MOF_NODESETTINGPORTRULE
{
  enum { MOF_NODESETTINGPORTRULE_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_NODESETTINGPORTRULE_PROPERTY_LIST

//MOF_CLUSCLUSSETTING namespace initialization
namespace MOF_CLUSCLUSSETTING
{
  enum { MOF_CLUSCLUSSETTING_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_CLUSCLUSSETTING_PROPERTY_LIST

//MOF_NODENODESETTING namespace initialization
namespace MOF_NODENODESETTING
{
  enum { MOF_NODENODESETTING_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_NODENODESETTING_PROPERTY_LIST

//MOF_PARAM namespace declaration
namespace MOF_PARAM
{
  extern LPWSTR PORT_NUMBER;
  extern LPWSTR HOST_ID;
  extern LPWSTR NUM_NODES;
  extern LPWSTR CLUSIP;
  extern LPWSTR CLUSNETMASK;
  extern LPWSTR PASSW;
  extern LPWSTR DEDIP;
  extern LPWSTR DEDNETMASK;
  extern LPWSTR PORTRULE;
  extern LPWSTR NODEPATH;
};

#endif //_WLBSMOFDATA_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_nodenodesetting.h ===
#ifndef _CLUSCLUSSETTING_INCLUDED_
#define _CLUSCLUSSETTING_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_NodeNodeSetting
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_NodeNodeSetting : public CWlbs_Root
{
public:
  CWLBS_NodeNodeSetting(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

private:

  //methods
  void FillWbemInstance  (CWlbsClusterWrapper* pCluster,
  							IWbemClassObject* a_pWbemInstance );

  void FindInstance( IWbemClassObject**      a_ppWbemInstance );

};

#endif //_CLUSCLUSSETTING_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_nodenodesetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_NodeNodeSetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::CWLBS_NodeNodeSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_NodeNodeSetting::CWLBS_NodeNodeSetting(CWbemServices* a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_NodeNodeSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_NodeNodeSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::GetInstance
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeNodeSetting::GetInstance
  (
    const ParsedObjectPath* /* a_pParsedPath */,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //TODO: remove
    throw _com_error( WBEM_E_NOT_SUPPORTED );
    //get the node
    //FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::EnumInstances
//
// Purpose: This verifies node existence and constructs associator.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeNodeSetting::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject*    pWlbsInstance    = NULL;
  HRESULT hRes = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i < dwNumClusters; i++)
    {
        //spawn an instance of the associator
        SpawnInstance(MOF_NODENODESETTING::szName, &pWlbsInstance );

        FillWbemInstance(ppCluster[i] , pWlbsInstance);

        //send the results back to WinMgMt
        hRes= m_pResponseHandler->Indicate( 1, &pWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( pWlbsInstance )
          pWlbsInstance->Release();
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::FindInstance
//
// Purpose: This routine determines if a host is within the local cluster. If
//          it is, then the requested associator is returned.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeNodeSetting::FindInstance
  ( 
    IWbemClassObject**       /*a_ppWbemInstance*/
  )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::FillWbemInstance
//
// Purpose: This constructs the wbem associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeNodeSetting::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance
  )
{
  namespace NNS = MOF_NODENODESETTING;

  ASSERT( a_pWbemInstance );

  ParsedObjectPath NodeSetPath;
  ParsedObjectPath NodePath;
  LPWSTR           szNodeSetPath = NULL;
  LPWSTR           szNodePath = NULL;

  try {

  //set the names of the classes
  if( !NodeSetPath.SetClassName( MOF_NODESETTING::szName ) )
    throw _com_error( WBEM_E_FAILED );

  if( !NodePath.SetClassName( MOF_NODE::szName ) )
    throw _com_error( WBEM_E_FAILED );

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  //set the keys for the node and cluster
  if( !NodeSetPath.AddKeyRef( MOF_NODESETTING::pProperties[MOF_NODESETTING::NAME],
         &_variant_t(wstrHostName.c_str()) ) )
    throw _com_error( WBEM_E_FAILED );

  if( !NodePath.AddKeyRef( MOF_NODE::pProperties[MOF_NODE::NAME],
         &_variant_t(wstrHostName.c_str()) ) )
    throw _com_error( WBEM_E_FAILED );

  //convert parsed object paths to strings
  if (CObjectPathParser::Unparse(&NodeSetPath, &szNodeSetPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );
  if (CObjectPathParser::Unparse(&NodePath,    &szNodePath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );

  //Node reference
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( NNS::pProperties[NNS::NODESET] ),
      0,
      &_variant_t(szNodeSetPath),
      NULL
    );
  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //Cluster reference
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NNS::pProperties[NNS::NODE] ),
      0,
      &_variant_t(szNodePath),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //free resources
  NodePath.ClearKeys();
  NodeSetPath.ClearKeys();

  if( szNodePath )
      delete (szNodePath );
 
  if( szNodeSetPath )
    delete (szNodeSetPath);

  } catch (...) {

    NodePath.ClearKeys();
    NodeSetPath.ClearKeys();

    if( szNodePath )
      delete (szNodePath);

    if( szNodeSetPath )
      delete (szNodeSetPath);

      throw;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_node.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_Node.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::CWLBS_Node
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_Node::CWLBS_Node(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_Node::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_Node( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::GetInstance
//
// Purpose: Queries WLBS for desired node instance and sends results back
//          to WinMgMt.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //g_pWlbsControl->CheckConfiguration();

    //get the node
    FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat  = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::EnumInstances
//
// Purpose: Executes a WlbsQuery and sends data back to WinMgMt.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject**   ppWlbsInstance    = NULL;
  WLBS_RESPONSE*      pResponse         = NULL;
  HRESULT hRes = 0;

  BSTR strClassName = NULL;
  long nNumNodes = 0;
  
  //g_pWlbsControl->CheckConfiguration();

  try {

    strClassName = SysAllocString( MOF_NODE::szName );

    if( !strClassName )
      throw _com_error( WBEM_E_OUT_OF_MEMORY );

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsNodeClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      strClassName,  
      0,                          
      NULL,                       
      &pWlbsNodeClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }


    for (DWORD iCluster=0; iCluster<dwNumClusters; iCluster++)
    {

        //call the API query function to find the nodes
        
        try {
            FindAllInstances(ppCluster[iCluster], &pResponse, nNumNodes );
        } catch (CErrorWlbsControl Err)
        {
            //
            // Skip this cluster
            //
            TRACE_ERROR1("CWLBS_Node::EnumInstances skiped cluster %x", 
                    ppCluster[iCluster]->GetClusterIP());
            continue;
        }
    

        //spawn an instance of the Node MOF class for each node found
        ppWlbsInstance = new IWbemClassObject *[nNumNodes];

        if( !ppWlbsInstance )
          throw _com_error( WBEM_E_OUT_OF_MEMORY );

        //initialize array
        ZeroMemory( ppWlbsInstance, nNumNodes * sizeof(IWbemClassObject *) );

        for(int i = 0; i < nNumNodes; i ++ ) {
          hRes = pWlbsNodeClass->SpawnInstance( 0, &ppWlbsInstance[i] );

        if( FAILED( hRes ) )
            throw _com_error( hRes );

        FillWbemInstance(ppCluster[iCluster], ppWlbsInstance[i], pResponse + i );
        }

        //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( nNumNodes, ppWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < nNumNodes; i++ ) {
            if( ppWlbsInstance[i] ) {
                ppWlbsInstance[i]->Release();
            }
          }
            delete [] ppWlbsInstance;
        }

        if( pResponse ) 
        delete [] pResponse;
    }

    if( strClassName )
      SysFreeString(strClassName);

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    hRes = HResErr.Error();
  }

  catch(...) {

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::ExecMethod
//
// Purpose: This executes the methods associated with the MOF
//          Node class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::ExecMethod
  (
    const ParsedObjectPath* a_pParsedPath, 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*           /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams
  )
{

  DWORD dwNumHosts = 1;
  DWORD dwReturnValue;

  HRESULT       hRes = 0;

  _variant_t vMofResponse;
  _variant_t vReturnValue;
  _variant_t vInputPortNumber;
  CNodeConfiguration NodeConfig;

  BSTR       strPortNumber = NULL;

  IWbemClassObject* pOutputInstance = NULL;

  try {

    strPortNumber = SysAllocString( MOF_PARAM::PORT_NUMBER );

    if( !strPortNumber )
      throw _com_error( WBEM_E_OUT_OF_MEMORY );

    //get the host ID address
    DWORD dwHostID = 0;
    DWORD dwClusterIpOrIndex = 0;
    
    dwHostID = ExtractHostID( wstring( (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal ) );
    if ((DWORD)-1 == dwHostID)
        throw _com_error( WBEM_E_NOT_FOUND );

    dwClusterIpOrIndex = ExtractClusterIP( wstring( (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal ) );
    if ((DWORD)-1 == dwClusterIpOrIndex)
        throw _com_error( WBEM_E_NOT_FOUND );
 
    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);

    if (pCluster == NULL)
        throw _com_error( WBEM_E_NOT_FOUND );
    
    //always let the provider peform control operations on the local host
    if( dwHostID == pCluster->GetHostID() ) 
      dwHostID    = WLBS_LOCAL_HOST;
    //get the output object instance
    GetMethodOutputInstance( MOF_NODE::szName, 
                             a_strMethodName, 
                             &pOutputInstance );

    //determine and execute the MOF method
    if( _wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DISABLE] ) == 0)  {
    
      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Disable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );

      //get the port number
      hRes = a_pIInParams->Get
                  (  strPortNumber, 
                     0, 
                     &vInputPortNumber, 
                     NULL, 
                     NULL
                   );

      if( FAILED( hRes ) ) {
        throw _com_error( hRes );
      }

      //make sure the port number is not NULL
      if( vInputPortNumber.vt != VT_I4) 
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      //call Disable method
      dwReturnValue = g_pWlbsControl->Disable
                        (
                          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                          dwHostID, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          (long)vInputPortNumber
                        );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::ENABLE]   ) == 0)  {

      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Enable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );

      //get the port number
      hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vInputPortNumber, 
                   NULL, 
                   NULL
                 );

      if( FAILED( hRes ) ) {
        throw _com_error( hRes );
      }

      if( vInputPortNumber.vt != VT_I4) 
        throw _com_error(WBEM_E_INVALID_PARAMETER);

      //call Enable method
      dwReturnValue = g_pWlbsControl->Enable
        (
          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
          dwHostID, 
          NULL, 
          dwNumHosts, 
          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
          (long)vInputPortNumber
        );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DRAIN]    ) == 0)  {

      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Drain" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );

      //get the port number
      hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vInputPortNumber, 
                   NULL, 
                   NULL
                 );

      if( FAILED( hRes ) ) {
        throw _com_error( hRes );
      }

      if( vInputPortNumber.vt != VT_I4) 
        throw _com_error(WBEM_E_INVALID_PARAMETER);

      //call Drain method
      dwReturnValue = g_pWlbsControl->Drain
                        (
                          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                          dwHostID, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          (long)vInputPortNumber
                        );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DRAINSTOP]) == 0)  {

      //call DrainStop method
      dwReturnValue = g_pWlbsControl->DrainStop( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::RESUME]   ) == 0)  {

      //call Resume method
      dwReturnValue = g_pWlbsControl->Resume( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::START]    ) == 0)  {

      //call Start method
      dwReturnValue = g_pWlbsControl->Start( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::STOP]     ) == 0)  {

      //call Stop method
      dwReturnValue = g_pWlbsControl->Stop( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::SUSPEND]  ) == 0)  {

      //call Suspend method
      dwReturnValue = g_pWlbsControl->Suspend( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else {

      throw _com_error(WBEM_E_METHOD_NOT_IMPLEMENTED);
    }

    //set the return value
    vReturnValue = (long)dwReturnValue;
    hRes = pOutputInstance->Put( _bstr_t(L"ReturnValue"), 0, &vReturnValue, 0 );

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }
    
    //send the results back to WinMgMt
    hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    if( pWbemExtStat )
      pWbemExtStat->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    hRes = HResErr.Error();
  }

  catch(...) {

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FindInstance
//
// Purpose: This routine determines if a host is within the local cluster. If
//          it is, then the host's data is obtained and returned via the 
//          IWbemClassObject interface.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FindInstance

  ( 
    IWbemClassObject**       a_ppWbemInstance,
    const ParsedObjectPath*  a_pParsedPath
  )

{
  try {
    //get the key property
    //throws _com_error
    //get the name key property and convert to ANSI
    //throws _com_error
    wstring szRequestedHostName = ( *a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwClustIpOrIndex = ExtractClusterIP( szRequestedHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL )
      throw _com_error( WBEM_E_NOT_FOUND );

    WLBS_RESPONSE Response;

    DWORD dwHostID = ExtractHostID( szRequestedHostName );
    if ((DWORD)-1 == dwHostID)
        throw _com_error( WBEM_E_NOT_FOUND );

    //always let the provider peform control operations on the local host
    if( dwHostID == pCluster->GetHostID() ) 
    {
      dwHostID = WLBS_LOCAL_HOST;
    }

    DWORD dwNumHosts  =  1;
    //call the api query function
    g_pWlbsControl->Query( pCluster,
                           dwHostID  , 
                           &Response   , 
                           &dwNumHosts, 
                           NULL );

    if( dwNumHosts == 0 )
      throw _com_error( WBEM_E_NOT_FOUND );

    //if requested, fill a MOF instance structure
    if(a_ppWbemInstance) {

      //get the Wbem class instance
      SpawnInstance( MOF_NODE::szName, a_ppWbemInstance );

      //Convert status to string description
      FillWbemInstance(pCluster, *a_ppWbemInstance, &Response );

    }
  }
  catch(...) {

    if( *a_ppWbemInstance ) {

      delete *a_ppWbemInstance;
      *a_ppWbemInstance = NULL;

    }

    throw;

  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FindAllInstances
//
// Purpose: This executes a WLBS query and returns Response structures upon
//          success. It always performs a local query to get the local host
//          so that disabling remote control will not prevent it from
//          enumerating. The dedicated IP address is added to the structure
//          within the CWlbsControlWrapper::Query call.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FindAllInstances
  (
  CWlbsClusterWrapper* pCluster,
   WLBS_RESPONSE**      a_ppResponse,
   long&                 a_nNumNodes
  )
{
  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  WLBS_RESPONSE LocalResponse;

  ASSERT(pCluster);
  
  ZeroMemory(Response, WLBS_MAX_HOSTS * sizeof(WLBS_RESPONSE));
  DWORD dwNumHosts  =  WLBS_MAX_HOSTS;

  a_nNumNodes = 0;  //this will contain the number of nodes returned


  try {

      //get the local host
      DWORD dwLocalNode = 1;
      g_pWlbsControl->Query( pCluster,
                               WLBS_LOCAL_HOST, 
                               &LocalResponse, 
                               &dwLocalNode, 
                               NULL);

      try {

          //we only want remote hosts
          if( pCluster->GetClusterIP() != 0 ) 
          {
              g_pWlbsControl->Query( pCluster,
                                     WLBS_ALL_HOSTS, 
                                     Response, 
                                     &dwNumHosts, 
                                     NULL );
          } 
          else 
          {
              dwNumHosts = 0;
          }
      } catch (CErrorWlbsControl Err) {
          dwNumHosts = 0;
          if (Err.Error() != WLBS_TIMEOUT)
          {
              throw;
          }
      }

      //this wastes memory if the local node
      //has remote control enabled
      a_nNumNodes = dwNumHosts + 1;

      if( a_ppResponse ) {
          *a_ppResponse = new WLBS_RESPONSE[a_nNumNodes];

          if( !*a_ppResponse )
            throw _com_error( WBEM_E_OUT_OF_MEMORY );

            //copy the local host
          (*a_ppResponse)[0] = LocalResponse;

          int j = 1;
          for(DWORD i = 1; i <= dwNumHosts; i++ ) 
          {
            //do not copy the local host again should it have remote control enabled
            if( Response[i-1].id == LocalResponse.id ) 
            {
              //we received the local node twice, so we reduce the count
              //by one
              a_nNumNodes--;
              continue;
            }
            (*a_ppResponse)[j] = Response[i-1];
            j++;
          }

        }
  } catch (...) {

      if ( *a_ppResponse )
      {
          delete [] *a_ppResponse;
          *a_ppResponse = NULL;
      }

      throw;
  }
}



////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance, 
    WLBS_RESPONSE*   a_pResponse   
  )
{
  namespace NODE = MOF_NODE;

  ASSERT( a_pWbemInstance );
  ASSERT( a_pResponse );

  wstring wstrHostName;

  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      a_pResponse->id );

  //HOST NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( NODE::pProperties[NODE::NAME] ) ,
      0                                        ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //HOST ID
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::HOSTID] )         ,
      0                                                  ,
      &_variant_t((long)(a_pResponse->id)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //CREATCLASS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::CREATCLASS] ),
      0                                            ,
      &_variant_t(NODE::szName),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //IP ADDRESS
  wstring szIPAddress;
  AddressToString( a_pResponse->address, szIPAddress );
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::IPADDRESS] ),
      0                                            ,
      &_variant_t(szIPAddress.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //STATUS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::STATUS] )         ,
      0                                                  ,
      &_variant_t((long)a_pResponse->status),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_nodesetportrule.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_NodeSetPortRule.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::CWLBS_NodeSetPortRule
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_NodeSetPortRule::CWLBS_NodeSetPortRule(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_NodeSetPortRule::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_NodeSetPortRule( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::GetInstance
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetPortRule::GetInstance
  (
    const ParsedObjectPath* /* a_pParsedPath */,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //TODO: remove
    throw _com_error( WBEM_E_NOT_SUPPORTED );
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::EnumInstances
//
// Purpose: Queries WLBS for desired node instances then constructs an 
//          an associator for each node found.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetPortRule::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject**   ppWlbsInstance    = NULL;
  PWLBS_PORT_RULE      pPortRules     = NULL;
  DWORD                dwNumRules     = 0;
  HRESULT              hRes           = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      _bstr_t( MOF_NODESETTINGPORTRULE::szName ),  
      0,                          
      NULL,                       
      &pWlbsClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }
    
    for (DWORD iCluster=0; iCluster < dwNumClusters; iCluster++)
    {

        // The "NodeSettingPortRule" class associates an instance of "NodeSetting" class
        // with an instance of "PortRule" class. The PortRule class does NOT contain
        // VIP as a property, so we do not want to return any instance of the "NodeSettingPortRule" 
        // class that associates a port rule that is specific to a vip (other than the "all vip").
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        ppCluster[iCluster]->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
            continue;

        //call the API query function to find all the port rules
         ppCluster[iCluster]->EnumPortRules( &pPortRules, &dwNumRules, 0 );

         if( dwNumRules == 0 )
           continue;


        //spawn an instance of the nodesetting portrule associator
        //for each portrule found
        ppWlbsInstance = new IWbemClassObject *[dwNumRules];

        if( !ppWlbsInstance )
          throw _com_error( WBEM_E_OUT_OF_MEMORY );

        //initialize array
        ZeroMemory( ppWlbsInstance, dwNumRules * sizeof(IWbemClassObject *) );

        for(DWORD i = 0; i < dwNumRules; i ++ ) {
          hRes = pWlbsClass->SpawnInstance( 0, &ppWlbsInstance[i] );

        if( FAILED( hRes ) )
            throw _com_error( hRes );

        FillWbemInstance(ppCluster[iCluster], *(ppWlbsInstance + i), pPortRules + i );
        }
         //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( dwNumRules, ppWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < dwNumRules; i++ ) {
            if( ppWlbsInstance[i] ) {
              ppWlbsInstance[i]->Release();
            }
          }
          delete [] ppWlbsInstance;
        }

        if( pPortRules ) 
          delete [] pPortRules;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( ppWlbsInstance ) {
      for(DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( ppWlbsInstance ) {
      for(DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    hRes = HResErr.Error();
  }

  catch(...) {

    if( ppWlbsInstance ) {
      for(DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::FindInstance
//
// Purpose: Returns the requested associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetPortRule::FindInstance

  ( 
    IWbemClassObject**       /* a_ppWbemInstance */,
    const ParsedObjectPath*  /* a_pParsedPath */
  )

{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::FillWbemInstance
//
// Purpose: This constructs the ParticipatingNode wbem associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetPortRule::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance, 
    PWLBS_PORT_RULE   a_pPortRule   
  )
{
  namespace NSPR = MOF_NODESETTINGPORTRULE;

  ASSERT( a_pWbemInstance );
  ASSERT( a_pPortRule );

  ParsedObjectPath NodeSetPath;
  ParsedObjectPath PRPath;
  LPWSTR           szNodeSetPath = NULL;
  LPWSTR           szPRPath      = NULL;

  try {

  //set the names of the classes
  if( !NodeSetPath.SetClassName( MOF_NODESETTING::szName ) )
    throw _com_error( WBEM_E_FAILED );

  //determine the type of port rule to create
  switch( a_pPortRule->mode ) {
    case WLBS_SINGLE:
      if( !PRPath.SetClassName( MOF_PRFAIL::szName ) )
        throw _com_error( WBEM_E_FAILED );
      break;
    case WLBS_MULTI:
      if( !PRPath.SetClassName( MOF_PRLOADBAL::szName ) )
        throw _com_error( WBEM_E_FAILED );
      break;
    case WLBS_NEVER:
      if( !PRPath.SetClassName( MOF_PRDIS::szName ) )
        throw _com_error( WBEM_E_FAILED );
      break;
    default:
      throw _com_error( WBEM_E_FAILED );

  }

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  
  //set the keys for the node setting
  if( !NodeSetPath.AddKeyRef( MOF_NODESETTING::pProperties[MOF_NODESETTING::NAME],
               &_variant_t(wstrHostName.c_str()) ) )
    throw _com_error( WBEM_E_FAILED );

  //set the keys for the port rule
  if( !PRPath.AddKeyRef( MOF_PORTRULE::pProperties[MOF_PORTRULE::NAME],
               &_variant_t(wstrHostName.c_str())) )
    throw _com_error( WBEM_E_FAILED );

  //start port key
  if( !PRPath.AddKeyRef( MOF_PORTRULE::pProperties[MOF_PORTRULE::STPORT],
               &_variant_t((long)a_pPortRule->start_port)) )
    throw _com_error( WBEM_E_FAILED );

  //convert parsed object paths to strings
  if (CObjectPathParser::Unparse(&NodeSetPath, &szNodeSetPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );
  if (CObjectPathParser::Unparse(&PRPath,      &szPRPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );

  //Node setting reference
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( NSPR::pProperties[NSPR::NODESET] ),
      0,
      &_variant_t(szNodeSetPath),
      NULL
    );
  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //Port rule reference
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NSPR::pProperties[NSPR::PORTRULE] ),
      0,
      &_variant_t(szPRPath),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //free resources
  NodeSetPath.ClearKeys();
  PRPath.ClearKeys();

  if( szNodeSetPath )
    delete (szNodeSetPath);

  if( szPRPath )
    delete (szPRPath);

  } catch (...) {

  NodeSetPath.ClearKeys();
  PRPath.ClearKeys();

  if( szNodeSetPath )
    delete (szNodeSetPath);

  if( szPRPath )
    delete (szPRPath);

    throw;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_nodesetportrule.h ===
#ifndef _NODESETPORTRULE_INCLUDED_
#define _NODESETPORTRULE_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_NodeSetPortRule
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_NodeSetPortRule : public CWlbs_Root
{
public:
  CWLBS_NodeSetPortRule(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances ( 
                          BSTR             a_bstrClass         = NULL,
                          long             a_lFlags            = 0, 
                          IWbemContext*    a_pIContex          = NULL
                        );

private:

  //methods
  void FillWbemInstance  ( CWlbsClusterWrapper* pCluster,
  						   IWbemClassObject* a_pWbemInstance, 
                           PWLBS_PORT_RULE   a_pPortRule    );

  void FindInstance( IWbemClassObject**       a_ppWbemInstance,
                     const ParsedObjectPath*  a_pParsedPath );

  //void FindAllInstances( WLBS_RESPONSE**      a_ppResponse,
	//				               long&                 a_nNumNodes );
};

#endif //_NODESETPORTRULE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_nodesetting.h ===
#ifndef _NODESETTING_INCLUDED_
#define _NODESETTING_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_NodeSetting
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node configuration class.

//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_NodeSetting : public CWlbs_Root
{
public:

  CWLBS_NodeSetting(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                      );

  HRESULT EnumInstances( 
                          BSTR             a_bstrClass         = NULL,
                          long             a_lFlags            = 0, 
                          IWbemContext*    a_pIContex          = NULL
                       );

  HRESULT PutInstance( 
                       IWbemClassObject* a_pInstance,
                       long              a_lFlags            = 0,
                       IWbemContext*     a_pIContex          = NULL
                     );

  HRESULT ExecMethod( 
                      const ParsedObjectPath* a_pParsedPath  , 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags            = 0, 
                      IWbemContext*           a_pIContex          = NULL, 
                      IWbemClassObject*       a_pIInParams        = NULL 
                    );

private:

  void FillWbemInstance( CWlbsClusterWrapper* pCluster,
		IWbemClassObject*   a_pWbemInstance );

  void UpdateConfiguration(CWlbsClusterWrapper* pCluster,
  						IWbemClassObject* a_pInstance );

};

#endif //_NODESETTING_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_participatingnode.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_ParticipatingNode.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::CWLBS_ParticipatingNode
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_ParticipatingNode::CWLBS_ParticipatingNode(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler ), m_pNode(NULL)
{

  m_pNode    = new CWLBS_Node   ( a_pNameSpace, a_pResponseHandler );
  if( !m_pNode )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::~CWLBS_ParticipatingNode
//
// Purpose: Destructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_ParticipatingNode::~CWLBS_ParticipatingNode()
{

  if( m_pNode )
    delete m_pNode;

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_ParticipatingNode::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_ParticipatingNode( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::GetInstance
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ParticipatingNode::GetInstance
  (
   const ParsedObjectPath* /* a_pParsedPath */,
   long                    /* a_lFlags */,
   IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT           hRes          = 0;

  try {

    //TODO: remove
    throw _com_error( WBEM_E_NOT_SUPPORTED );
/*
    //get the node
    FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );
*/
    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::EnumInstances
//
// Purpose: Queries WLBS for desired node instances then constructs an 
//          an associator for each node found.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ParticipatingNode::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject**   ppWlbsInstance    = NULL;
  WLBS_RESPONSE*      pResponse         = NULL;
  HRESULT              hRes              = 0;

  long nNumNodes = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      _bstr_t( MOF_PARTICIPATINGNODE::szName ),  
      0,                          
      NULL,                       
      &pWlbsClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }

    for (DWORD iCluster=0; iCluster<dwNumClusters; iCluster++)
    {

        //call the API query function to find the nodes
        try {
            m_pNode->FindAllInstances(ppCluster[iCluster], &pResponse, nNumNodes );
        } catch (CErrorWlbsControl Err)  {

            //
            // Skip this cluster
            //
            TRACE_ERROR1("CWLBS_ParticipatingNode::EnumInstances skiped cluster %x", 
                    ppCluster[iCluster]->GetClusterIP());
            continue;
        }

        //spawn an instance of the participating node associator
        //for each node found
        ppWlbsInstance = new IWbemClassObject *[nNumNodes];

        if( !ppWlbsInstance )
          throw _com_error( WBEM_E_OUT_OF_MEMORY );

        //initialize array
        ZeroMemory( ppWlbsInstance, nNumNodes * sizeof(IWbemClassObject *) );

        for(int i = 0; i < nNumNodes; i ++ ) {
          hRes = pWlbsClass->SpawnInstance( 0, &ppWlbsInstance[i] );

          if( FAILED( hRes ) )
            throw _com_error( hRes );

          FillWbemInstance(ppCluster[iCluster], *(ppWlbsInstance + i), pResponse + i );
        }

        //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( nNumNodes, ppWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < nNumNodes; i++ ) {
            if( ppWlbsInstance[i] ) {
              ppWlbsInstance[i]->Release();
            }
          }
          delete [] ppWlbsInstance;
        }

        if( pResponse ) 
          delete [] pResponse;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    hRes = HResErr.Error();
  }

  catch(...) {

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::FindInstance
//
// Purpose: This routine determines if a host is within the local cluster. If
//          it is, then the requested associator is returned.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ParticipatingNode::FindInstance

  ( 
    IWbemClassObject**       /* a_ppWbemInstance */,
    const ParsedObjectPath*  /* a_pParsedPath */
  )

{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::FillWbemInstance
//
// Purpose: This constructs the ParticipatingNode wbem associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ParticipatingNode::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance, 
    WLBS_RESPONSE*   a_pResponse   
  )
{
  namespace PNODE = MOF_PARTICIPATINGNODE;

  ASSERT( a_pWbemInstance );
  ASSERT( a_pResponse );


  ParsedObjectPath NodePath;
  ParsedObjectPath ClusterPath;
  LPWSTR           szNodePath    = NULL;
  LPWSTR           szClusterPath = NULL;

  try {

  //set the names of the classes
  if( !NodePath.SetClassName( MOF_NODE::szName ) )
    throw _com_error( WBEM_E_FAILED );

  if( !ClusterPath.SetClassName( MOF_CLUSTER::szName ) )
    throw _com_error( WBEM_E_FAILED );

  //Get the node name

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      a_pResponse->id );

  //Get the cluster name
  wstring wstrClusterName;
  AddressToString( pCluster->GetClusterIpOrIndex(g_pWlbsControl), wstrClusterName );

  //set the keys for the node and cluster
  if( !NodePath.AddKeyRef( MOF_NODE::pProperties[MOF_NODE::NAME],
               &_variant_t(wstrHostName.c_str()) ) )
    throw _com_error( WBEM_E_FAILED );


  if( !ClusterPath.AddKeyRef( MOF_CLUSTER::pProperties[MOF_CLUSTER::NAME],
               &_variant_t(wstrClusterName.c_str())) )
    throw _com_error( WBEM_E_FAILED );

  //convert parsed object paths to strings
  if (CObjectPathParser::Unparse(&NodePath,    &szNodePath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );
  if (CObjectPathParser::Unparse(&ClusterPath, &szClusterPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );

  //Node reference
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( PNODE::pProperties[PNODE::NODE] ),
      0,
      &_variant_t(szNodePath),
      NULL
    );
  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //Cluster reference
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PNODE::pProperties[PNODE::CLUSTER] ),
      0,
      &_variant_t(szClusterPath),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //free resources
  ClusterPath.ClearKeys();
  NodePath.ClearKeys();

  if( szNodePath )
    delete (szNodePath);

  if( szClusterPath )
    delete (szClusterPath);

  } catch (...) {

    ClusterPath.ClearKeys();
    NodePath.ClearKeys();

    if( szNodePath )
      delete (szNodePath);

    if( szClusterPath )
      delete (szClusterPath);

    throw;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_nodesetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_NodeSetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::CWLBS_NodeSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_NodeSetting::CWLBS_NodeSetting
  ( 
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_NodeSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_NodeSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::GetInstance
//
// Purpose: This function retrieves an instance of a MOF NodeSetting 
//          class. The node does not have to be a member of a cluster. However,
//          WLBS must be installed for this function to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::GetInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //get the name key property and convert to wstring
    const wchar_t* wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    DWORD dwHostID = ExtractHostID( wstrHostName );

    if (pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
        throw _com_error( WBEM_E_NOT_FOUND );

    //get the Wbem class instance
    SpawnInstance( MOF_NODESETTING::szName, &pWlbsInstance );

    //Convert status to string description
    FillWbemInstance(pCluster, pWlbsInstance );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    //if( pWbemExtStat )
      //pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
    
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::EnumInstances
//
// Purpose: This function obtains the NodeSetting data for the current host.
//          The node does not have to be a member of a cluster for this 
//          to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::EnumInstances
  ( 
    BSTR             /*a_bstrClass*/,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject*    pWlbsInstance = NULL;
  HRESULT              hRes          = 0;

  try {


    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i<dwNumClusters; i++)
    {
        //get the Wbem class instance
        SpawnInstance( MOF_NODESETTING::szName, &pWlbsInstance );

        //Convert status to string description
        FillWbemInstance(ppCluster[i], pWlbsInstance );

        //send the results back to WinMgMt
        m_pResponseHandler->Indicate( 1, &pWlbsInstance );
    }

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::PutInstance
//
// Purpose: This function updates an instance of a MOF NodeSetting 
//          class. The node does not have to be a member of a cluster.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::PutInstance
  ( 
   IWbemClassObject* a_pInstance,
   long              /* a_lFlags */,
   IWbemContext*     /* a_pIContex */
  ) 
{
  VARIANT vHostName;
  HRESULT hRes = 0;

  try {

    VariantInit( &vHostName );

    //get the host name value
    hRes = a_pInstance->Get( _bstr_t( MOF_NODESETTING::pProperties[MOF_NODESETTING::NAME] ),
                             0,
                             &vHostName,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    wstring wstrHostName( vHostName.bstrVal );
     
    DWORD dwClustIpOrIndex = ExtractClusterIP( wstrHostName );
    DWORD dwHostID = ExtractHostID( wstrHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
      throw _com_error( WBEM_E_NOT_FOUND );

    UpdateConfiguration(pCluster, a_pInstance );

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vHostName ))
        throw _com_error( WBEM_E_FAILED );

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    hRes = HResErr.Error();
  }

  catch (...) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::ExecMethod
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::ExecMethod    
  ( 
    const ParsedObjectPath* a_pParsedPath , 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*          /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams 
  ) 
{
  
  IWbemClassObject* pOutputInstance   = NULL;
  IWbemClassObject* pWbemPortRule = NULL;
  HRESULT           hRes = 0;
  CNodeConfiguration NodeConfig;

  VARIANT           vValue ;

  try {
    VariantInit( &vValue );
    
    VARIANT vHostName ;
    VariantInit( &vHostName );

    if (a_pParsedPath->m_paKeys == NULL)
    {
        // 
        // No name specified
        //
        throw _com_error( WBEM_E_INVALID_PARAMETER );
    }
    wstring  wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwClustIpOrIndex = ExtractClusterIP( wstrHostName );
    DWORD dwHostID = ExtractHostID( wstrHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
      throw _com_error( WBEM_E_NOT_FOUND );


    //determine the method being executed
    if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::GETPORT] ) == 0 )  {
      WLBS_PORT_RULE PortRule;

      // The GetPort method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );

      //get the output object instance
      GetMethodOutputInstance( MOF_NODESETTING::szName, 
                               a_strMethodName, 
                               &pOutputInstance);

      //get the Port
      hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::PORT_NUMBER ), 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( vValue.vt != VT_I4 )
        throw _com_error ( WBEM_E_INVALID_PARAMETER );

      // Get the "All Vip" port rule for this vip
      pCluster->GetPortRule(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), static_cast<DWORD>( vValue.lVal ), &PortRule );
      
      //create the appropriate port rule class
      switch( PortRule.mode ) {
        case WLBS_SINGLE:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRFAIL], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(pCluster, pWbemPortRule, &PortRule );
          break;

        case WLBS_MULTI:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRLOADB], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(pCluster, pWbemPortRule, &PortRule );
          break;

        case WLBS_NEVER:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRDIS], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(pCluster, pWbemPortRule, &PortRule );
          break;
      }

      vValue.vt = VT_UNKNOWN;
      vValue.punkVal = pWbemPortRule;
      pWbemPortRule->AddRef();

      hRes = pOutputInstance->Put( _bstr_t(MOF_PARAM::PORTRULE),
                                   0,
                                   &vValue,
                                   0 );


      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vValue ))
          throw _com_error( WBEM_E_FAILED );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      if( pOutputInstance ) {
        hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

        if( FAILED( hRes ) )
          throw _com_error( hRes );
      }

    } else if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::LDSETT] ) == 0 ) {
      DWORD dwReturnValue = pCluster->Commit(g_pWlbsControl);

      vValue.vt   = VT_I4;
      vValue.lVal = static_cast<long>(dwReturnValue);

      //get the output object instance
      GetMethodOutputInstance( MOF_NODESETTING::szName, 
                               a_strMethodName, 
                               &pOutputInstance);

      hRes = pOutputInstance->Put(_bstr_t(L"ReturnValue"), 0, &vValue, 0);


      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vValue ))
          throw _com_error( WBEM_E_FAILED );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      if( pOutputInstance ) {
        hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

        if( FAILED( hRes ) )
          throw _com_error( hRes );
      }

    } else if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::SETDEF] ) == 0 ) {
      pCluster->SetNodeDefaults();
    } else {
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    //send the results back to WinMgMt
    //set the return value

    //release resources
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    hRes = HResErr.Error();
  }

  catch ( ... ) {
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetting::FillWbemInstance(CWlbsClusterWrapper* pCluster,
                IWbemClassObject* a_pWbemInstance )
{
  namespace NODE = MOF_NODESETTING;

  ASSERT( a_pWbemInstance );

  CNodeConfiguration NodeConfig;

  pCluster->GetNodeConfig( NodeConfig );

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  //NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NAME] ) ,
      0                                              ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DEDIPADDRESS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DEDIPADDRESS] ),
      0                                                  ,
      &_variant_t(NodeConfig.szDedicatedIPAddress.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DEDNETMASK
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DEDNETMASK] ),
      0                                                ,
      &_variant_t(NodeConfig.szDedicatedNetworkMask.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMRULES
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMRULES] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumberOfRules),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //HOSTPRI
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::HOSTPRI] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwHostPriority),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MSGPERIOD 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MSGPERIOD] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwAliveMsgPeriod),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MSGTOLER 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MSGTOLER] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwAliveMsgTolerance),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //CLUSMODEONSTART 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::CLUSMODEONSTART] ),
      0                                                ,
      &_variant_t(NodeConfig.bClusterModeOnStart),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );


  //NBTENABLE 
//  hRes = a_pWbemInstance->Put
//    (
//      _bstr_t( NODE::pProperties[NODE::NBTENABLE] ),
//      0                                                ,
//      &( _variant_t( NodeConfig.bNBTSupportEnable ) )        ,
//      NULL
//    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //REMOTEUDPPORT 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::REMOTEUDPPORT] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwRemoteControlUDPPort),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MASKSRCMAC 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MASKSRCMAC] ),
      0                                                ,
      &_variant_t(NodeConfig.bMaskSourceMAC),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DESCPERALLOC 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DESCPERALLOC] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwDescriptorsPerAlloc),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MAXDESCALLOCS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MAXDESCALLOCS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwMaxDescriptorAllocs),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMACTIONS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMACTIONS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumActions),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMPACKETS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMPACKETS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumPackets),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMALIVEMSGS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMALIVEMSGS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumAliveMsgs),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );


  //ADAPTERGUID 
  GUID AdapterGuid = pCluster->GetAdapterGuid();
  
  WCHAR szAdapterGuid[128];
  StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );

  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::ADAPTERGUID] ),
      0                                                ,
      &_variant_t(szAdapterGuid),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::UpdateConfiguration
//
// Purpose: This function updates the configuration data for a member node or a
//          potential WLBS cluster node.
//    
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetting::UpdateConfiguration
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pInstance 
  )
{
  namespace NODE = MOF_NODESETTING;

  CNodeConfiguration NewConfiguration;
  CNodeConfiguration OldConfiguration;

  pCluster->GetNodeConfig( OldConfiguration );

  //Dedicated IP
  UpdateConfigProp
    ( 
      NewConfiguration.szDedicatedIPAddress,
      OldConfiguration.szDedicatedIPAddress,
      NODE::pProperties[NODE::DEDIPADDRESS],
      a_pInstance 
    );

  //Dedicate Network Mask
  UpdateConfigProp
    ( 
      NewConfiguration.szDedicatedNetworkMask,
      OldConfiguration.szDedicatedNetworkMask,
      NODE::pProperties[NODE::DEDNETMASK],
      a_pInstance 
    );

  //HostPriority
  UpdateConfigProp
    ( 
      NewConfiguration.dwHostPriority,
      OldConfiguration.dwHostPriority,
      NODE::pProperties[NODE::HOSTPRI],
      a_pInstance 
    );

  //AliveMsgPeriod
  UpdateConfigProp
    ( 
      NewConfiguration.dwAliveMsgPeriod,
      OldConfiguration.dwAliveMsgPeriod,
      NODE::pProperties[NODE::MSGPERIOD],
      a_pInstance 
    );

  //AliveMsgTolerance
  UpdateConfigProp
    ( 
      NewConfiguration.dwAliveMsgTolerance,
      OldConfiguration.dwAliveMsgTolerance,
      NODE::pProperties[NODE::MSGTOLER],
      a_pInstance 
    );

  //ClusterModeOnStart
  UpdateConfigProp
    ( 
      NewConfiguration.bClusterModeOnStart,
      OldConfiguration.bClusterModeOnStart,
      NODE::pProperties[NODE::CLUSMODEONSTART],
      a_pInstance 
    );

  //NBTSupportEnable
//  UpdateConfigProp
//    ( 
//      NewConfiguration.bNBTSupportEnable,
//      OldConfiguration.bNBTSupportEnable,
//      NODE::pProperties[NODE::NBTENABLE],
//      a_pInstance 
//    );

  //RemoteControlUDPPort
  UpdateConfigProp
    ( 
      NewConfiguration.dwRemoteControlUDPPort,
      OldConfiguration.dwRemoteControlUDPPort,
      NODE::pProperties[NODE::REMOTEUDPPORT],
      a_pInstance 
    );

  //MaskSourceMAC
  UpdateConfigProp
    ( 
      NewConfiguration.bMaskSourceMAC,
      OldConfiguration.bMaskSourceMAC,
      NODE::pProperties[NODE::MASKSRCMAC],
      a_pInstance 
    );

  //DescriptorsPerAlloc
  UpdateConfigProp
    ( 
      NewConfiguration.dwDescriptorsPerAlloc,
      OldConfiguration.dwDescriptorsPerAlloc,
      NODE::pProperties[NODE::DESCPERALLOC],
      a_pInstance 
    );

  //MaxDescriptorAllocs
  UpdateConfigProp
    ( 
      NewConfiguration.dwMaxDescriptorAllocs,
      OldConfiguration.dwMaxDescriptorAllocs,
      NODE::pProperties[NODE::MAXDESCALLOCS],
      a_pInstance 
    );

  //NumActions
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumActions,
      OldConfiguration.dwNumActions,
      NODE::pProperties[NODE::NUMACTIONS],
      a_pInstance 
    );

  //NumPackets
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumPackets,
      OldConfiguration.dwNumPackets,
      NODE::pProperties[NODE::NUMPACKETS],
      a_pInstance 
    );

  //NumAliveMsgs
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumAliveMsgs,
      OldConfiguration.dwNumAliveMsgs,
      NODE::pProperties[NODE::NUMALIVEMSGS],
      a_pInstance 
    );

  pCluster->PutNodeConfig( NewConfiguration );
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_portrule.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_PortRule.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"


extern CWlbsControlWrapper* g_pWlbsControl;

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::CWLBS_PortRule
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_PortRule::CWLBS_PortRule
  ( 
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_PortRule::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_PortRule( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::ExecMethod
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::ExecMethod    
  (
    const ParsedObjectPath* /* a_pParsedPath */, 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*           /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams
  )
{
  
  IWbemClassObject* pOutputInstance   = NULL;
  VARIANT           vValue;
  HRESULT           hRes = 0;

  try {

    VariantInit( &vValue );

    //determine the method being executed
    if( _wcsicmp( a_strMethodName, MOF_PORTRULE::pMethods[MOF_PORTRULE::SETDEF] ) == 0 )  
    {

      //get the node path
      hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::NODEPATH ), 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( FAILED( hRes) ) 
      {
        throw _com_error( WBEM_E_FAILED );
      }

      //this check may not be necessary since WMI will do some
      //parameter validation
      //if( vValue.vt != VT_BSTR )
      //  throw _com_error ( WBEM_E_INVALID_PARAMETER );

      //parse node path
      CObjectPathParser PathParser;
      ParsedObjectPath *pParsedPath = NULL;

      try {

        int nStatus = PathParser.Parse( vValue.bstrVal, &pParsedPath );
        if(nStatus != 0) {
    
          if (NULL != pParsedPath)
          {
            PathParser.Free( pParsedPath );
            pParsedPath = NULL;
          }

          throw _com_error( WBEM_E_INVALID_PARAMETER );

        }

        //get the name key, which should be the only key
        if( *pParsedPath->m_paKeys == NULL )
        {
          throw _com_error( WBEM_E_INVALID_PARAMETER );
        }
 
        DWORD dwReqClusterIpOrIndex = ExtractClusterIP( (*pParsedPath->m_paKeys)->m_vValue.bstrVal);
        DWORD dwReqHostID = ExtractHostID(    (*pParsedPath->m_paKeys)->m_vValue.bstrVal);
      
        CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(
                dwReqClusterIpOrIndex);

        if (pCluster == NULL || (DWORD)-1 == dwReqHostID)
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to operate on any cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        pCluster->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
            throw _com_error( WBEM_E_INVALID_OPERATION );

        //validate host ID
        if( dwReqHostID != pCluster->GetHostID())
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        //invoke method
        pCluster->SetPortRuleDefaults();
      }
      catch( ... ) {

        if( pParsedPath )
        {
          PathParser.Free( pParsedPath );
          pParsedPath = NULL;
        }

        throw;
      }

    } else {
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;

  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    hRes = HResErr.Error();
  }

  catch ( ... ) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::GetInstance
//
// Purpose: This function retrieves an instance of a MOF PortRule 
//          class. The node does not have to be a member of a cluster. 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::GetInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT           hRes          = 0;

  try {

    if( !a_pParsedPath )
      throw _com_error( WBEM_E_FAILED );

    wstring wstrHostName;

    wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 1))->m_vValue.lVal );

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
    // so, we do not want to operate on any cluster that has a port rule
    // that is specific to a vip (other than the "all vip")
    // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
    // see of there is any port rule that is specific to a vip
    CNodeConfiguration NodeConfig;
    pCluster->GetNodeConfig(NodeConfig);
    if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
         throw _com_error( WBEM_E_INVALID_OPERATION );

    WLBS_PORT_RULE PortRule;

    pCluster->GetPortRule(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), dwReqStartPort, &PortRule );

    if( dwReqStartPort != PortRule.start_port )
      throw _com_error( WBEM_E_NOT_FOUND );

    SpawnInstance( a_pParsedPath->m_pClass, &pWlbsInstance );
    FillWbemInstance(pCluster, pWlbsInstance, &PortRule );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance )
      pWlbsInstance->Release();

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::EnumInstances
//
// Purpose: This function obtains the PortRule data for the current host.
//          The node does not have to be a member of a cluster for this 
//          to succeed. However, NLB must be installed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::EnumInstances
  ( 
    BSTR             a_bstrClass,
    long             /*a_lFlags*/, 
    IWbemContext*    /*a_pIContex*/
  )
{
  IWbemClassObject**   ppWlbsInstance = NULL;
  HRESULT              hRes           = 0;
  PWLBS_PORT_RULE      pPortRules     = NULL;
  DWORD                dwNumRules     = 0;
  CNodeConfiguration   NodeConfig;

  try {

    DWORD dwFilteringMode;

    if( _wcsicmp( a_bstrClass, MOF_PRFAIL::szName ) == 0 ) {
      dwFilteringMode = WLBS_SINGLE;
    } else if( _wcsicmp( a_bstrClass, MOF_PRLOADBAL::szName ) == 0 ) {
      dwFilteringMode = WLBS_MULTI;
    } else if( _wcsicmp( a_bstrClass, MOF_PRDIS::szName ) == 0 ) {
      dwFilteringMode = WLBS_NEVER;
    } else {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      a_bstrClass,  
      0,                          
      NULL,                       
      &pWlbsClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }


    for (DWORD iCluster=0; iCluster<dwNumClusters; iCluster++)
    {
        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to return any port rule for a cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        ppCluster[iCluster]->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
            continue;

        //call the API query function to find the port rules

        ppCluster[iCluster]->EnumPortRules( &pPortRules, &dwNumRules, dwFilteringMode );
        if( dwNumRules == 0 ) 
          throw _com_error( WBEM_E_NOT_FOUND );


        //spawn an instance of the MOF class for each rule found
        ppWlbsInstance = new IWbemClassObject *[dwNumRules];

        if( !ppWlbsInstance )
          throw _com_error( WBEM_E_OUT_OF_MEMORY );

        //initialize array
        ZeroMemory( ppWlbsInstance, dwNumRules * sizeof(IWbemClassObject *) );

        for( DWORD i = 0; i < dwNumRules; i ++ ) {
          hRes = pWlbsClass->SpawnInstance( 0, &ppWlbsInstance[i] );

          if( FAILED( hRes ) )
            throw _com_error( hRes );

          FillWbemInstance(ppCluster[iCluster], *(ppWlbsInstance + i), pPortRules + i );
        }

        //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( dwNumRules, ppWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < dwNumRules; i++ ) {
            if( ppWlbsInstance[i] ) {
              ppWlbsInstance[i]->Release();
            }
          }
          delete [] ppWlbsInstance;
          ppWlbsInstance = NULL;
          dwNumRules = NULL;

        }

        if( pPortRules ) 
        {
          delete [] pPortRules;
          pPortRules = NULL;
        }
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    hRes = HResErr.Error();
  }

  catch(...) {

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::DeleteInstance
//
// Purpose: This function deletes an instance of a MOF PortRule 
//          class. The node does not have to be a member of a cluster. However,
//          WLBS must be installed for this function to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::DeleteInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /*a_lFlags*/,
    IWbemContext*           /*a_pIContex*/
  )
{

  HRESULT hRes = 0;

  try {
    if( !a_pParsedPath )
      throw _com_error( WBEM_E_FAILED );

    wstring wstrHostName;

    wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 1))->m_vValue.lVal );

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
    // so, we do not want to operate on any cluster that has a port rule
    // that is specific to a vip (other than the "all vip")
    // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
    // see of there is any port rule that is specific to a vip
    CNodeConfiguration NodeConfig;
    pCluster->GetNodeConfig(NodeConfig);
    if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
         throw _com_error( WBEM_E_INVALID_OPERATION );

    WLBS_PORT_RULE PortRule;

    // Get the "All Vip" port rule for this port
    pCluster->GetPortRule(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), dwReqStartPort, &PortRule );

    if( dwReqStartPort != PortRule.start_port )
      throw _com_error( WBEM_E_NOT_FOUND );

    // Delete the "All Vip" port rule for this port
    pCluster->DeletePortRule(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), dwReqStartPort );

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    hRes = HResErr.Error();
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::PutInstance
//
// Purpose: This function updates an instance of a PortRule 
//          class. The host does not have to be a member of a cluster.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::PutInstance
  ( 
    IWbemClassObject* a_pInstance,
    long              /*a_lFlags*/,
    IWbemContext*     /*a_pIContex*/
  )
{
  VARIANT vValue;
  HRESULT hRes = 0;

  WLBS_PORT_RULE NewRule; //the instance to put


  try {

    VariantInit( &vValue );

    //get the host name value
    hRes = a_pInstance->Get( _bstr_t( MOF_PORTRULE::pProperties[MOF_PORTRULE::NAME] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    wstring wstrHostName( vValue.bstrVal );

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
    // so, we do not want to operate on any cluster that has a port rule
    // that is specific to a vip (other than the "all vip")
    // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
    // see of there is any port rule that is specific to a vip
    CNodeConfiguration NodeConfig;
    pCluster->GetNodeConfig(NodeConfig);
    if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
         throw _com_error( WBEM_E_INVALID_OPERATION );

    //retrieve start and end ports
    hRes = a_pInstance->Get( _bstr_t( MOF_PORTRULE::pProperties[MOF_PORTRULE::STPORT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    NewRule.start_port = static_cast<DWORD>( vValue.lVal );

    hRes = a_pInstance->Get( _bstr_t( MOF_PORTRULE::pProperties[MOF_PORTRULE::EDPORT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    NewRule.end_port   = static_cast<DWORD>( vValue.lVal );

    //get the protocol
    hRes = a_pInstance->Get( _bstr_t( MOF_PORTRULE::pProperties[MOF_PORTRULE::PROT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    NewRule.protocol = static_cast<DWORD>( vValue.lVal );

    //get the class name to determine port rule mode
    hRes = a_pInstance->Get( _bstr_t( L"__Class" ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    if( _wcsicmp( vValue.bstrVal, MOF_PRDIS::szName ) == 0 ) {
      NewRule.mode = WLBS_NEVER;

    } else if(_wcsicmp( vValue.bstrVal, MOF_PRFAIL::szName ) == 0 ) {
      NewRule.mode = WLBS_SINGLE;

      VARIANT vRulePriority;
      VariantInit( &vRulePriority );

      try {
        //get the rule priority
        hRes = a_pInstance->Get( _bstr_t( MOF_PRFAIL::pProperties[MOF_PRFAIL::PRIO] ),
                                 0,
                                 &vRulePriority,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

      } 
      catch( ... ) {

        // CLD: Need to check return code for error
        // No throw here since we are already throwing an exception.
        VariantClear( &vRulePriority );
        throw;
      }

      
      NewRule.mode_data.single.priority = static_cast<DWORD>( vRulePriority.lVal );

      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vRulePriority ))
          throw _com_error( WBEM_E_FAILED );

    } else if(_wcsicmp( vValue.bstrVal, MOF_PRLOADBAL::szName ) == 0 ) {
      NewRule.mode = WLBS_MULTI;

      VARIANT v;

      VariantInit( &v );

      try {
        //get the affinity
        hRes = a_pInstance->Get( _bstr_t( MOF_PRLOADBAL::pProperties[MOF_PRLOADBAL::AFFIN] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        NewRule.mode_data.multi.affinity = static_cast<WORD>( v.lVal );

        //get the equal load boolean
        hRes = a_pInstance->Get( _bstr_t( MOF_PRLOADBAL::pProperties[MOF_PRLOADBAL::EQLD] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        if( v.boolVal == -1 ) {
          NewRule.mode_data.multi.equal_load = 1;
        } else {
          NewRule.mode_data.multi.equal_load = 0;
        }

        //get the load
        hRes = a_pInstance->Get( _bstr_t( MOF_PRLOADBAL::pProperties[MOF_PRLOADBAL::LDWT] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        if( v.vt != VT_NULL )
          NewRule.mode_data.multi.load = static_cast<DWORD>( v.lVal );
        else
          NewRule.mode_data.multi.load = 0;

      } catch( ... ) {

        // CLD: Need to check return code for error
        // No throw here since we are already throwing an exception.
        VariantClear( &v );

        throw;
      }

      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &v ))
          throw _com_error( WBEM_E_FAILED );
    }

    //delete the port rule but cache in case of failure
    WLBS_PORT_RULE OldRule;
    bool bOldRuleSaved = false;
    lstrcpy(NewRule.virtual_ip_addr, CVY_DEF_ALL_VIP);
    if( pCluster->RuleExists(IpAddressFromAbcdWsz(NewRule.virtual_ip_addr), NewRule.start_port ) ) {
      pCluster->GetPortRule(IpAddressFromAbcdWsz(NewRule.virtual_ip_addr), NewRule.start_port, &OldRule );
      bOldRuleSaved = true;

      pCluster->DeletePortRule(IpAddressFromAbcdWsz(NewRule.virtual_ip_addr), NewRule.start_port );
    }

    //add the port rule, roll back if failed
    try {
      pCluster->PutPortRule( &NewRule );

    } catch(...) {

      if( bOldRuleSaved )
        pCluster->PutPortRule( &OldRule );

      throw;
    }

    //release resources
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    hRes = HResErr.Error();
  }

  catch (...) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_PortRule::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject*      a_pWbemInstance, 
    const PWLBS_PORT_RULE& a_pPortRule
  )
{
  namespace PRFO = MOF_PRFAIL;
  namespace PRLB = MOF_PRLOADBAL;
  namespace PR   = MOF_PORTRULE;

  ASSERT( a_pWbemInstance );

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID());


  //NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::NAME] ) ,
      0                                              ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //STPORT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::STPORT] ),
      0                                                  ,
      &_variant_t(static_cast<long>(a_pPortRule->start_port)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //EDPORT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::EDPORT] ),
      0                                                ,
      &_variant_t(static_cast<long>(a_pPortRule->end_port)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //ADAPTERGUID 
  GUID AdapterGuid = pCluster->GetAdapterGuid();
  
  WCHAR szAdapterGuid[128];
  StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );
  
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::ADAPTERGUID] ),
      0                                                ,
      &_variant_t(szAdapterGuid),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //PROT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::PROT] ),
      0,
      &_variant_t(static_cast<long>(a_pPortRule->protocol)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );


  switch( a_pPortRule->mode ) {
    case WLBS_SINGLE:
      //PRIO
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( MOF_PRFAIL::pProperties[MOF_PRFAIL::PRIO] ),
          0                                                ,
          &_variant_t(static_cast<long>(a_pPortRule->mode_data.single.priority)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      break;
    case WLBS_MULTI:
      //EQLD
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PRLB::pProperties[PRLB::EQLD] ),
          0                                                ,
          &_variant_t((a_pPortRule->mode_data.multi.equal_load != 0)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //LDWT
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PRLB::pProperties[PRLB::LDWT] ),
          0                                                ,
         &_variant_t(static_cast<long>(a_pPortRule->mode_data.multi.load)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //AFFIN
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PRLB::pProperties[PRLB::AFFIN] ),
          0                                                ,
          &_variant_t(static_cast<long>(a_pPortRule->mode_data.multi.affinity)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      break;
    case WLBS_NEVER:
      //there are no properties
      break;
    default:
      throw _com_error( WBEM_E_FAILED );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_participatingnode.h ===
#ifndef _PARTICIPATINGNODE_INCLUDED_
#define _PARTICIPATINGNODE_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_ParticipatingNode
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_ParticipatingNode : public CWlbs_Root
{
public:
  CWLBS_ParticipatingNode(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);
  ~CWLBS_ParticipatingNode();

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

private:

  //data
  CWLBS_Node*     m_pNode;   

  //methods
  void FillWbemInstance  ( CWlbsClusterWrapper* pCluster,
  						   IWbemClassObject*   a_pWbemInstance, 
                           WLBS_RESPONSE*     a_pResponse    );

  void FindInstance( IWbemClassObject**       a_ppWbemInstance,
                     const ParsedObjectPath*  a_pParsedPath );

  //void FindAllInstances( WLBS_RESPONSE**      a_ppResponse,
	//				               long&                 a_nNumNodes );
};

#endif //_PARTICIPATINGNODE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_provider.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation.
//
//  File:   WLBS_Provider.h
//
//  Module: WLBS instance provider main project header file
//
//  Purpose: General purpose include file.
//
//	History:
//
//  Author: drbeck
//
//***************************************************************************

#ifndef _WLBSPROVIDER_INCLUDED_
#define _WLBSPROVIDER_INCLUDED_

#include <crtdbg.h>
#include <comdef.h>
#include <iostream>
#include <memory>
#include <string>
#include <wbemprov.h>
#include <genlex.h>   //for wmi object path parser
#include <objbase.h>
#include <wlbsconfig.h> 
#include <ntrkcomm.h>

using namespace std;

#include "objpath.h"
#include "WLBS_MOFData.h"
#include "WLBS_Root.h"
#include "WLBS_Node.h"
#include "WLBS_Cluster.h"
#include "WLBS_NodeSetting.h"
#include "WLBS_ClusterSetting.h"
#include "WLBS_PortRule.h"
#include "WLBS_ParticipatingNode.h"
#include "WLBS_NodeSetPortRule.h"
#include "WLBS_ClusClusSetting.h"
#include "WLBS_NodeNodeSetting.h"

typedef LPVOID * PPVOID;

class CWLBSProvider : public CImpersonatedProvider
{
private:
	void GetClass(IWbemClassObject *a_pClassObject, wstring& a_szClass);

	void ParseObjectPath(const BSTR a_strObjectPath, ParsedObjectPath **a_pParsedObjectPath);

  HRESULT GetMOFSupportClass( LPCWSTR              a_szObjectClass, 
                           auto_ptr<CWlbs_Root> &a_pMofClass,
                           IWbemObjectSink*     a_pResponseHandler );

public:

	CWLBSProvider( BSTR           ObjectPath = NULL, 
                 BSTR           User       = NULL, 
                 BSTR           Password   = NULL, 
                 IWbemContext  *pCtx       = NULL );

	virtual ~CWLBSProvider();

        HRESULT STDMETHODCALLTYPE DoGetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        
        HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
            {return WBEM_E_NOT_SUPPORTED;}
        

        HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
			                 BSTR,
			                 BSTR, 
			                 long, 
                       IWbemContext*,
			                 IWbemClassObject*,
			                 IWbemObjectSink* );

        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
          LPWSTR                   pszUser,
          LONG                     lFlags,
          LPWSTR                   pszNamespace,
          LPWSTR                   pszLocale,
          IWbemServices         *  pNamespace,
          IWbemContext          *  pCtx,
          IWbemProviderInitSink *  pInitSink
        );

};

// Provider interfaces are provided by objects of this class
/* 
class CWLBSProvider : public IWbemServices, public IWbemProviderInit
{
private:
	void GetClass(IWbemClassObject *a_pClassObject, wstring& a_szClass);
	void ParseObjectPath(const BSTR a_strObjectPath, ParsedObjectPath **a_pParsedObjectPath);

  void GetMOFSupportClass(LPCWSTR a_szObjectClass, 
                          auto_ptr<CWlbs_Root> &a_pMofClass,
                          IWbemObjectSink * a_pResponseHandler);

protected:
//  long             m_cRef;         //Object reference count
//  IWbemServices*   m_pNamespace;   //Pointer to namespace passed in by WinMgMt
public:

  //constructor
  CWLBSProvider(
    BSTR ObjectPath     = NULL, 
    BSTR User           = NULL, 
    BSTR Password       = NULL, 
    IWbemContext * pCtx = NULL
  );

  //destructor
  ~CWLBSProvider(void);

  //Non-delegating object IUnknown

  STDMETHODIMP         QueryInterface (REFIID, PPVOID);
  STDMETHODIMP_(ULONG) AddRef         (void);
  STDMETHODIMP_(ULONG) Release        (void);

  //IWbemServices  

  //***************************************************************************
  //      Supported Methods
  //***************************************************************************

  HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
    BSTR               a_strClass,
    long               a_lFlags,
    IWbemContext     * a_pIContex,
    IWbemObjectSink  * a_pIResponseHandler
  );

  HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
    BSTR               a_strObjectPath, 
    BSTR               a_strMethodName, 
    long               a_lFlags, 
    IWbemContext     * a_pIContex, 
    IWbemClassObject * a_pIInParams, 
    IWbemObjectSink  * a_pIResponseHandler
  );

  HRESULT STDMETHODCALLTYPE GetObjectAsync( 
    BSTR               a_strObjectPath,
    long               a_lFlags,
    IWbemContext     * a_pIContex,
    IWbemObjectSink  * a_pIResponseHandler
  );

  HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
    IWbemClassObject * a_pInst,
    long               a_lFlags,
    IWbemContext     * a_pIContex,
    IWbemObjectSink  * a_pIResponseHandler
  );

    //***************************************************************************
  //      Unsupported methods
  //***************************************************************************
  
  HRESULT STDMETHODCALLTYPE OpenNamespace( 
    BSTR                Namespace,
    long                lFlags,
    IWbemContext     *  pCtx,
    IWbemServices   **  ppWorkingNamespace,
    IWbemCallResult **  ppResult) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
    IWbemObjectSink  *pSink) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE QueryObjectSink( 
    long                lFlags,
    IWbemObjectSink **  ppResponseHandler) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE GetObject( 
    BSTR                  ObjectPath,
    long                  lFlags,
    IWbemContext       *  pCtx,
    IWbemClassObject  **  ppObject,
    IWbemCallResult   **  ppCallResult) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE PutClass( 
    IWbemClassObject *  pObject,
    long                lFlags,
    IWbemContext     *  pCtx,
    IWbemCallResult **  ppCallResult) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE PutClassAsync( 
    IWbemClassObject * pObject,
    long               lFlags,
    IWbemContext     * pCtx,
    IWbemObjectSink  * pResponseHandler) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE DeleteClass( 
    BSTR                Class,
    long                lFlags,
    IWbemContext     *  pCtx,
    IWbemCallResult **  ppCallResult) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
    BSTR               Class,
    long               lFlags,
    IWbemContext     * pCtx,
    IWbemObjectSink  * pResponseHandler) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE CreateClassEnum( 
    BSTR                      Superclass,
    long                      lFlags,
    IWbemContext           *  pCtx,
    IEnumWbemClassObject  **  ppEnum) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
    BSTR               Superclass,
    long               lFlags,
    IWbemContext     * pCtx,
    IWbemObjectSink  * pResponseHandler) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE PutInstance( 
    IWbemClassObject *  pInst,
    long                lFlags,
    IWbemContext     *  pCtx,
    IWbemCallResult **  ppCallResult) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE DeleteInstance( 
    BSTR                ObjectPath,
    long                lFlags,
    IWbemContext     *  pCtx,
    IWbemCallResult **  ppCallResult) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
    BSTR               ObjectPath,
    long               lFlags,
    IWbemContext     * pCtx,
    IWbemObjectSink  * pResponseHandler) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
    BSTR                      Class,
    long                      lFlags,
    IWbemContext           *  pCtx,
    IEnumWbemClassObject  **  ppEnum) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE ExecQuery( 
    BSTR                      QueryLanguage,
    BSTR                      Query,
    long                      lFlags,
    IWbemContext           *  pCtx,
    IEnumWbemClassObject  **  ppEnum) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
    BSTR               QueryLanguage,
    BSTR               Query,
    long               lFlags,
    IWbemContext     * pCtx,
    IWbemObjectSink  * pResponseHandler) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
    BSTR                      QueryLanguage,
    BSTR                      Query,
    long                      lFlags,
    IWbemContext           *  pCtx,
    IEnumWbemClassObject  **  ppEnum) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
    BSTR               QueryLanguage,
    BSTR               Query,
    long               lFlags,
    IWbemContext     * pCtx,
    IWbemObjectSink  * pResponseHandler) {
    return WBEM_E_NOT_SUPPORTED;
  }

  HRESULT STDMETHODCALLTYPE ExecMethod( 
    BSTR                  ObjectPath, 
    BSTR                  MethodName, 
    long                  lFlags, 
    IWbemContext       *  pCtx,
    IWbemClassObject   *  pInParams, 
    IWbemClassObject  **  ppOutParams, 
    IWbemCallResult   **  ppCallResult) {
    return WBEM_E_NOT_SUPPORTED;
  }

};
*/

typedef CWLBSProvider * PCWLBSProvider;

// This class is the class factory for CWLBSProvider objects.

class CWLBSClassFactory : public IClassFactory
{
protected:
  long           m_cRef;

public:
  CWLBSClassFactory(void);
  ~CWLBSClassFactory(void);

  //IUnknown members
  STDMETHODIMP         QueryInterface(REFIID, PPVOID);
  STDMETHODIMP_(ULONG) AddRef(void);
  STDMETHODIMP_(ULONG) Release(void);

  //IClassFactory members
  STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                           ,PPVOID);
  STDMETHODIMP         LockServer(BOOL);
};

typedef CWLBSClassFactory *PCWLBSClassFactory;
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, _uuidof(IWbemClassObject)); 
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, _uuidof(IWbemQualifierSet)); 

//Global Variables

// These variables keep track of when the module can be unloaded
extern long         g_cComponents;
extern long         g_cServerLocks;

//The one and only instance of the WLBS control class. All
//WLBS control commands are implemented via this class.
class CWlbsControlWrapper;
extern CWlbsControlWrapper* g_pWlbsControl;

// General purpose utilities.  

             
SCODE CreateInst( IWbemServices     * pNamespace, 
                  LPWSTR              pKey, 
                  long                lVal, 
                  IWbemClassObject ** pNewInst,
                  WCHAR             * pwcClassName,
                  IWbemContext      * pCtx); 

#endif //_WLBSPROVIDER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_portrule.h ===
#ifndef _PORTRULE_INCLUDED_
#define _PORTRULE_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_PortRule
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node configuration class.

//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_PortRule : public CWlbs_Root
{
public:

  CWLBS_PortRule(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT DeleteInstance( 
                          const ParsedObjectPath* a_pParsedPath,
                          long                    a_lFlags            = 0,
                          IWbemContext*           a_pIContex          = NULL
                        );

  HRESULT PutInstance( 
                       IWbemClassObject* a_pInstance,
                       long              a_lFlags            = 0,
                       IWbemContext*     a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

  HRESULT ExecMethod(
                      const ParsedObjectPath* a_pParsedPath, 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags, 
                      IWbemContext*           a_pIContex, 
                      IWbemClassObject*       a_pIInParams
                    );

  static void FillWbemInstance( CWlbsClusterWrapper* pCluster,
                                IWbemClassObject*      a_pWbemInstance, 
                                const PWLBS_PORT_RULE& a_pPortRule );

private:

};

#endif //_PORTRULE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_root.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_Root.h"
#include "utils.h"
#include "controlwrapper.h"
#include "param.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::CWlbs_Root
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root::CWlbs_Root(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: m_pNameSpace(NULL), m_pResponseHandler(NULL)
{

  //m_pNameSpace and m_pResponseHandler are initialized to NULL
  //by CWlbs_Root
  if(!a_pNameSpace || !a_pResponseHandler)
    throw _com_error( WBEM_E_INVALID_PARAMETER );

    m_pNameSpace = a_pNameSpace;

    m_pResponseHandler = a_pResponseHandler;
    m_pResponseHandler->AddRef();

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::~CWlbs_Root
//
// Purpose: Destructor
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root::~CWlbs_Root()
{

  if( m_pNameSpace )
    m_pNameSpace = NULL;

  if( m_pResponseHandler ) {
    m_pResponseHandler->Release();
    m_pResponseHandler = NULL;
  }

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::SpawnInstance
//
// Purpose: This obtains an instance of a WBEM class.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::SpawnInstance 
  ( 
    LPCWSTR               a_szClassName, 
    IWbemClassObject**    a_ppWbemInstance 
  )
{
  HRESULT hResult;
  IWbemClassObjectPtr pWlbsClass;

  //get the MOF class object
  hResult = m_pNameSpace->GetObject(
    _bstr_t( a_szClassName ),  
    0,                          
    NULL,                       
    &pWlbsClass,            
    NULL);                      

  if( FAILED(hResult) ) {
    throw _com_error(hResult);
  }

  //spawn an instance
  hResult = pWlbsClass->SpawnInstance( 0, a_ppWbemInstance );

  if( FAILED( hResult ) )
    throw _com_error( hResult );

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::GetMethodOutputInstance
//
// Purpose: This obtains an IWbemClassObject that is used to store the 
//          output parameters for a method call. The caller is responsible for
//          releasing the output object.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::GetMethodOutputInstance
  (
   LPCWSTR              a_szMethodClass,
   const BSTR           a_strMethodName,
   IWbemClassObject**   a_ppOutputInstance
  )
{

  IWbemClassObjectPtr pMethClass;
  IWbemClassObjectPtr pOutputClass;
  IWbemClassObjectPtr pOutParams;
  BSTR strMethodClass = NULL;

  HRESULT hResult;

  ASSERT( a_szMethodClass );

  try {

    strMethodClass = SysAllocString( a_szMethodClass );

    if( !strMethodClass )
      throw _com_error( WBEM_E_OUT_OF_MEMORY );

    hResult = m_pNameSpace->GetObject
      ( strMethodClass, 
        0, 
        NULL, 
        &pMethClass, 
        NULL
      );

    if( FAILED( hResult ) )
      throw _com_error( hResult );

    hResult = pMethClass->GetMethod( a_strMethodName, 0, NULL, &pOutputClass );

    if( FAILED( hResult ) )
      throw _com_error( hResult );

    hResult = pOutputClass->SpawnInstance( 0, a_ppOutputInstance );

    if( FAILED( hResult ) ) {
      throw _com_error(hResult);
    }

    if( strMethodClass ) {

      SysFreeString( strMethodClass );
      strMethodClass = NULL;

    }

  }
  catch(...) {

    if( strMethodClass ) {

      SysFreeString( strMethodClass );
      strMethodClass = NULL;

    }

    throw;
  }

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::UpdateConfigProp
//
// Purpose: This extracts the propery name and value from the WBEM object and if
//          the property is not set to VT_NULL then the configuration is updated
//          else the original configuration, the Src parameter, is used.
//    
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::UpdateConfigProp
  ( 
          wstring&    a_szDest, 
    const wstring&    a_szSrc,
          LPCWSTR     a_szPropName, 
    IWbemClassObject* a_pNodeInstance 
  )
{

  HRESULT hRes        = NULL;
  
  VARIANT vNewValue;

  try {
    VariantInit( &vNewValue );

    hRes = a_pNodeInstance->Get( _bstr_t( a_szPropName ),
                                  0,
                                  &vNewValue,
                                  NULL,
                                  NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    if( vNewValue.vt != VT_NULL )
      a_szDest.assign( vNewValue.bstrVal ); //update to new value
    else
      a_szDest = a_szSrc;                   //keep original value

    // CLD: Need to check return code for error
    if (S_OK != VariantClear(  &vNewValue  ))
        throw _com_error( WBEM_E_FAILED );
  }
  catch(...) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vNewValue );

    throw;
  }


}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::UpdateConfigProp
//
// Purpose: This extracts the propery name and value from the WBEM object and if
//          the property is not set to VT_NULL then the configuration is updated
//          else the original configuration, the Src parameter, is used.
//    
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::UpdateConfigProp
  ( 
    bool&              a_bDest, 
    bool               a_bSrc,
    LPCWSTR            a_szPropName, 
    IWbemClassObject*  a_pNodeInstance  
  )
{

  BSTR    strPropName = NULL;
  HRESULT hRes        = NULL;
  
  VARIANT vNewValue;

  try {

    VariantInit( &vNewValue );

    hRes = a_pNodeInstance->Get
      (
        _bstr_t( a_szPropName ),
        0,
        &vNewValue,
        NULL,
        NULL 
      );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    if( vNewValue.vt != VT_NULL )
      a_bDest = (vNewValue.boolVal != 0); //update to new value
    else
      a_bDest = a_bSrc;                   //keep original value

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vNewValue ))
        throw _com_error( WBEM_E_FAILED );
    SysFreeString( strPropName );

  }
  catch(...) {
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vNewValue );

    throw;
  }

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::UpdateConfigProp
//
// Purpose: This extracts the propery name and value from the WBEM object and if
//          the property is not set to VT_NULL then the configuration is updated
//          else the original configuration, the Src parameter, is used.
//    
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::UpdateConfigProp
  ( 
    DWORD&             a_dwDest, 
    DWORD              a_dwSrc,
    LPCWSTR            a_szPropName, 
    IWbemClassObject*  a_pNodeInstance 
  )
{

  HRESULT hRes = NULL;
  
  VARIANT vNewValue;

  try {
    VariantInit( &vNewValue );

    hRes = a_pNodeInstance->Get(  _bstr_t( a_szPropName ),
                                  0,
                                  &vNewValue,
                                  NULL,
                                  NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    if( vNewValue.vt != VT_NULL )
      a_dwDest = vNewValue.lVal;
    else
      a_dwDest = a_dwSrc;

    // CLD: Need to check return code for error
    if (S_OK != VariantClear(  &vNewValue  ))
        throw _com_error( WBEM_E_FAILED );
  }
  catch(...) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vNewValue );

    throw;
  }

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::CreateExtendedStatus
//
// Purpose: Spawn and fill a Wbem extended status object with error
//          information.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::CreateExtendedStatus
  (
    CWbemServices*      a_pNameSpace,
    IWbemClassObject**  a_ppWbemInstance,
    DWORD               a_dwErrorCode,
    LPCWSTR             /*a_szDescription*/
  )
{
  HRESULT hResult;
  IWbemClassObjectPtr  pWlbsExtendedObject;

  try {
    ASSERT(a_ppWbemInstance);
    ASSERT(a_pNameSpace );

    //this is the only routine that references
    //the MicrosoftNLB_ExtendedStatus object
    //if other routines start to use the class,
    //or if it adds additional properties, then
    //is should be added to the MOF data files
    //along with the other classes
    //get the MOF class object
    hResult = a_pNameSpace->GetObject(
      _bstr_t( L"MicrosoftNLB_ExtendedStatus" ),  
      0,                          
      NULL,                       
      &pWlbsExtendedObject,            
      NULL);                      

    if( FAILED(hResult) ) {
      throw _com_error(hResult);
    }

    //spawn an instance
    hResult = pWlbsExtendedObject->SpawnInstance( 0, a_ppWbemInstance );

    if( FAILED( hResult ) )
      throw _com_error( hResult );

//this is omitted in release due to internationalization concerns
/*
#if 0

    //fill instance with data
    //add description
    hResult = (*a_ppWbemInstance)->Put
    (
  
      _bstr_t( L"Description" ) ,
      0                                        ,
      &( _variant_t( a_szDescription ) )   ,
      NULL
    );

#endif
*/
    if( FAILED( hResult ) )
      throw _com_error( hResult );

    //add status code
    hResult = (*a_ppWbemInstance)->Put
    (
  
      _bstr_t( L"StatusCode" ) ,
      0                                        ,
      &( _variant_t( (long)a_dwErrorCode ) )   ,
      NULL
    );

    if( FAILED( hResult ) )
      throw _com_error( hResult );
  }
  
  catch(...) {
    if( *a_ppWbemInstance )
      (*a_ppWbemInstance)->Release();

    throw;
  }
}




//+----------------------------------------------------------------------------
//
// Function:  CWlbs_Root::ExtractHostID
//
// Description:  Extract the Host ID from name "clusterIp:HostId"
//
// Arguments: const wstring& a_wstrName - 
//            
//
// Returns:   DWORD  - Host ID, or -1 if failed
//
// History: fengsun  Created Header    7/13/00
//
//+----------------------------------------------------------------------------
DWORD CWlbs_Root::ExtractHostID(const wstring& a_wstrName)
{
  long nColPos;

  nColPos = a_wstrName.find( L":" );

  if (nColPos == wstring::npos)
  {
      //
      // Not found
      //

      TRACE_ERROR1("CWlbs_Root::ExtractHostID invalid name %ws", a_wstrName.c_str());
      return (DWORD)-1;
  }

  wstring wstrHostID = a_wstrName.substr( nColPos+1, a_wstrName.size()-1 );
  return _wtol( wstrHostID.c_str() );
}



//+----------------------------------------------------------------------------
//
// Function:  CWlbs_Root::ExtractClusterIP
//
// Description:  Extract the cluster IP address from name "clusterIp:HostId"
//
// Arguments: const wstring& a_wstrName - 
//            
//
// Returns:   DWORD - Cluster IP, or INADDR_NONE (-1) if falied
//
// History: fengsun  Created Header    7/13/00
//
//+----------------------------------------------------------------------------
DWORD CWlbs_Root::ExtractClusterIP(const wstring& a_wstrName)
{
  long nColPos;

  nColPos = a_wstrName.find( L":" );

  if (nColPos == wstring::npos)
  {
      //
      // Not found
      //

      TRACE_ERROR1("CWlbs_Root::ExtractClusterIP invalid name %ws", a_wstrName.c_str());
      return (DWORD)-1;
  }

  wstring wstrClusterIP = a_wstrName.substr( 0, nColPos );

  return WlbsResolve( wstrClusterIP.c_str() );
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::ConstructHostName
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::ConstructHostName
  ( 
    wstring& a_wstrHostName, 
    DWORD    a_dwClusIP, 
    DWORD    a_dwHostID 
  )
{
  WCHAR wszHostID[40];
  
  AddressToString( a_dwClusIP, a_wstrHostName );
  a_wstrHostName += L':';
  a_wstrHostName += _ltow( a_dwHostID, wszHostID, 10 );

}



CWlbsClusterWrapper* GetClusterFromHostName(CWlbsControlWrapper* pControl, 
                                            wstring wstrHostName)
{
    DWORD dwClusterIpOrIndex = CWlbs_Root::ExtractClusterIP(wstrHostName);

    return pControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_provclassfac.cpp ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation.
//
//  File :  WLBSProvClassFac.cpp
//
//  Module: WLBS Instance provider class factory
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//	History:
//
//***************************************************************************

#include "WLBS_Provider.h"

//***************************************************************************
//
// CWLBSClassFactory::CWLBSClassFactory
// CWLBSClassFactory::~CWLBSClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************
CWLBSClassFactory::CWLBSClassFactory()
: m_cRef(1)
{
  return;
}

CWLBSClassFactory::~CWLBSClassFactory(void)
{
  return;
}

//***************************************************************************
//
// CWLBSClassFactory::QueryInterface
// CWLBSClassFactory::AddRef
// CWLBSClassFactory::Release
//
// Purpose: Standard OLE routines needed for all interfaces
//
//***************************************************************************
STDMETHODIMP CWLBSClassFactory::QueryInterface(REFIID a_riid, PPVOID a_ppv)
{
  *a_ppv = NULL;

  if (IID_IUnknown==a_riid || IID_IClassFactory==a_riid)
    *a_ppv = static_cast<IClassFactory *>(this);

  if (*a_ppv != NULL) {
    reinterpret_cast<IUnknown *>(*a_ppv)->AddRef();
    return S_OK;
  }

  return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CWLBSClassFactory::AddRef(void)
{
  return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CWLBSClassFactory::Release(void)
{
  if (InterlockedDecrement(&m_cRef) == 0) {
    delete this;
    return 0;
  }

  return m_cRef;
}

//***************************************************************************
//
// CWLBSClassFactory::CreateInstance
//
// Purpose: Instantiates a provider object returning an interface pointer.
//
// Parameters:
//  a_pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                    being used in an aggregation.
//  a_riid            REFIID identifying the interface the caller
//                    desires to have for the new object.
//  a_ppvObj          PPVOID in which to store the desired
//                    interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************
STDMETHODIMP CWLBSClassFactory::CreateInstance(
    LPUNKNOWN a_pUnkOuter, 
    REFIID    a_riid, 
    PPVOID    a_ppvObj
  )
{
  CWLBSProvider * pObj = NULL;
  HRESULT         hr;

  *a_ppvObj = NULL;

  // This object doesnt support aggregation.
  if (a_pUnkOuter != NULL)
      return CLASS_E_NOAGGREGATION;

  // Create the object.
  pObj = new CWLBSProvider();

  if (pObj == NULL)
      return E_OUTOFMEMORY;

  hr = pObj->QueryInterface(a_riid, a_ppvObj);

  if( FAILED(hr) ) {
    delete pObj;
    pObj = NULL;
  }

  return hr;
}

//***************************************************************************
//
// CWLBSClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************
STDMETHODIMP CWLBSClassFactory::LockServer(BOOL a_bLock)
{
  if (a_bLock)
      InterlockedIncrement(&g_cServerLocks);
  else
      InterlockedDecrement(&g_cServerLocks);

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_root.h ===
#ifndef _WLBSCLASSES_INCLUDED_
#define _WLBSCLASSES_INCLUDED_

#include <atlbase.h>
#include <wbemprov.h>
#include "debug.h"

//forward declarations
struct ParsedObjectPath;

////////////////////////////////////////////////////////////////////////////////
//
// class CWlbs_Root
//
// Purpose: This class servers as the base for all classes that implement 
//          specific Wbem classes. A pointer to this class is utilized
//          polymorphically within CWLBSProvider.
//
////////////////////////////////////////////////////////////////////////////////
class CWlbs_Root

{
public:
           CWlbs_Root(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);
  virtual ~CWlbs_Root();

	static void CreateExtendedStatus( CWbemServices*     a_pNameSpace,
                             IWbemClassObject** a_ppWbemInstance,
                             DWORD              a_dwErrorCode     = 0,
                             LPCWSTR            a_szDescription   = NULL
                           );

  HRESULT virtual GetInstance( 
                              const ParsedObjectPath* a_pParsedPath,
                              long                    a_lFlags = 0, 
                              IWbemContext*           a_pIContex = NULL) = 0;

  HRESULT virtual DeleteInstance( 
                                 const ParsedObjectPath* a_pParsedPath,
                                 long                    a_lFlags            = 0,
                                 IWbemContext*           a_pIContex          = NULL
                                )
                                {
                                  throw _com_error( WBEM_E_NOT_SUPPORTED ); 
                                  return WBEM_E_FAILED;
                                }

  HRESULT virtual PutInstance( 
                               IWbemClassObject* a_pInstance,
                               long              a_lFlags            = 0,
                               IWbemContext*     a_pIContex          = NULL
                             ) 
                              {
                               throw _com_error( WBEM_E_NOT_SUPPORTED ); 
                               return WBEM_E_FAILED;
                              }

  HRESULT virtual EnumInstances( 
                                BSTR             a_bstrClass         = NULL,
                                long             a_lFlags            = 0, 
                                IWbemContext*    a_pIContex          = NULL
                               ) = 0;

  HRESULT virtual ExecMethod( 
                             const ParsedObjectPath* a_pParsedPath  , 
                             const BSTR&             a_strMethodName, 
                             long                    a_lFlags            = 0, 
                             IWbemContext*           a_pIContex          = NULL, 
                             IWbemClassObject*       a_pIInParams        = NULL
                            )
                            {
                             throw _com_error(WBEM_E_NOT_SUPPORTED); 
                             return WBEM_E_NOT_SUPPORTED;
                            }

  void SpawnInstance ( LPCWSTR            a_szClassName, 
                       IWbemClassObject** a_ppWbemInstance );

protected:
  CWbemServices*    m_pNameSpace;
  IWbemObjectSink*  m_pResponseHandler;

  void virtual GetMethodOutputInstance( LPCWSTR             a_szMethodClass,
                                        const BSTR          a_strMethodName,
                                        IWbemClassObject**  a_ppOutputInstance);

  void UpdateConfigProp(       wstring&    a_szDest, 
                         const wstring&    a_szSrc,
                         LPCWSTR           a_szPropName, 
                         IWbemClassObject* a_pNodeInstance );

  void UpdateConfigProp( bool&             a_bDest, 
                         bool              a_bSrc,
                         LPCWSTR           a_szPropName, 
                         IWbemClassObject* a_pNodeInstance );

  void UpdateConfigProp( DWORD&            a_bDest, 
                         DWORD             a_bSrc,
                         LPCWSTR           a_szPropName, 
                         IWbemClassObject* a_pNodeInstance );

  static void ConstructHostName( wstring& a_wstrHostName, 
                          DWORD    a_dwClusIP, 
                          DWORD    a_dwHostID );

public:
  static DWORD ExtractHostID   (const wstring& a_wstrName);
  static DWORD ExtractClusterIP(const wstring& a_wstrName);

private:
  //This constructor must not be used.
  CWlbs_Root();

};

class CWlbsClusterWrapper;
class CWlbsControlWrapper;

CWlbsClusterWrapper* GetClusterFromHostName(CWlbsControlWrapper* pControl, 
                                            wstring wstrHostName);


#endif //_WLBSCLASSES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\wlbs_provider.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-1999 Microsoft Corporation.
//
//  File:   WLBSProvider.CPP
//
//  Module: WLBS Instance Provider
//
//  Purpose: Defines the CWLBSProvider class.  An object of this class is
//           created by the class factory for each connection.
//
//  History:
//
////////////////////////////////////////////////////////////////////////////////
#define ENABLE_PROFILE

#include <objbase.h>
#include <process.h>
#include "WLBS_Provider.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
//CWLBSProvider::CWLBSProvider
// CWLBSProvider::~CWLBSProvider
//
////////////////////////////////////////////////////////////////////////////////
CWLBSProvider::CWLBSProvider(
    BSTR            a_strObjectPath, 
    BSTR            a_strUser, 
    BSTR            a_strPassword, 
    IWbemContext *  a_pContex
  )
{
  m_pNamespace = NULL;
  InterlockedIncrement(&g_cComponents);

  return;
}

CWLBSProvider::~CWLBSProvider(void)
{
  InterlockedDecrement(&g_cComponents);

  return;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                      
//   CWLBSProvider::Initialize                                          
//                                                                      
//   Purpose: This is the implementation of IWbemProviderInit. The method  
//   is called by WinMgMt.                                    
//                                                                      
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::Initialize(
    LPWSTR                  a_pszUser, 
    LONG                    a_lFlags,
    LPWSTR                  a_pszNamespace, 
    LPWSTR                  a_pszLocale,
    IWbemServices         * a_pNamespace, 
    IWbemContext          * a_pCtx,
    IWbemProviderInitSink * a_pInitSink
  )
{
  PROFILE("CWLBSProvider::Initialize");
 
  try {

    //!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      //g_pWlbsControl must be initialized when the first COM instance is invoked 
      //and it must stay alive for the lifetime of the DLL, i.e. do NOT DESTROY
      //it in the destructor of this CLASS until the API cache of the Cluster IP
      //and Password are REMOVED.

      //DO NOT INITIALIZE g_pWlbsControl in DLLMain. DLLMain is invoked with regsvr32
      //and we do not want to initialize WinSock at that time!!! This will BREAK the
      //installation process of the provider.
    //!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if( g_pWlbsControl == NULL ) {

      g_pWlbsControl = new CWlbsControlWrapper();

      if( g_pWlbsControl == NULL)
        throw _com_error( WBEM_E_OUT_OF_MEMORY );

      }

    g_pWlbsControl->Initialize();

    return CImpersonatedProvider::Initialize
      (
        a_pszUser, 
        a_lFlags,
        a_pszNamespace, 
        a_pszLocale,
        a_pNamespace, 
        a_pCtx,
        a_pInitSink
      );
  }

  catch (...) 
  {
#ifdef DBG  // In debug version, popup a message box for AV
    MessageBoxExA(NULL,"Wlbs Provider Failure.","Wlbs Provider Access Violation",
        MB_TOPMOST | MB_ICONHAND | MB_OK | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);
#endif

    return WBEM_E_FAILED;
  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoCreateInstanceEnumAsync(  
    BSTR                  a_strClass, 
    long                  a_lFlags, 
    IWbemContext        * a_pIContex,
    IWbemObjectSink     * a_pIResponseHandler
  )
{
  ASSERT(g_pWlbsControl);

  if (g_pWlbsControl)
  {
    //
    // Re-enumerate all the clusters
    //
    g_pWlbsControl->ReInitialize();
  }
 
  try {
    auto_ptr<CWlbs_Root>  pMofClass;

    //create an instance of the appropriate MOF support class
    HRESULT hRes = GetMOFSupportClass(a_strClass, pMofClass, a_pIResponseHandler);

    //call the appropriate wrapper class GetInstance method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->EnumInstances( a_strClass );
  
    return hRes;
  } 

  catch(_com_error HResErr ) {

    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    return HResErr.Error();
  }

  catch(...) {

#ifdef DBG  // In debug version, popup a message box for AV
    MessageBoxExA(NULL,"Wlbs Provider Failure.","Wlbs Provider Access Violation",
        MB_TOPMOST | MB_ICONHAND | MB_OK | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);
#endif

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);
    return WBEM_E_FAILED;

  }

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::GetObjectAsync
//
// Purpose: Gets an instance for a particular object path
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoGetObjectAsync(
    BSTR              a_strObjectPath,
    long              a_lFlags,
    IWbemContext    * a_pIContex,
    IWbemObjectSink * a_pIResponseHandler
  )
{
  ASSERT(g_pWlbsControl);

  if (g_pWlbsControl)
  {
    //
    // Re-enumerate all the clusters
    //
    g_pWlbsControl->ReInitialize();
  }
 

  ParsedObjectPath* pParsedPath = NULL;

  try {
    auto_ptr<CWlbs_Root>  pMofClass;

    //parse the object path
    ParseObjectPath( a_strObjectPath, &pParsedPath );

    //create an instance of the appropriate MOF support class
    HRESULT hRes = GetMOFSupportClass( pParsedPath->m_pClass, pMofClass, a_pIResponseHandler );

    //call the appropriate wrapper class GetInstance method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->GetInstance( pParsedPath );
  
    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    return hRes;
  } 

  catch(_com_error HResErr) {

    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    return HResErr.Error();
    
  }

  catch(...) {

#ifdef DBG  // In debug version, popup a message box for AV
    MessageBoxExA(NULL,"Wlbs Provider Failure.","Wlbs Provider Access Violation",
        MB_TOPMOST | MB_ICONHAND | MB_OK | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);
#endif

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);

    return WBEM_E_FAILED;

  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::DoDeleteInstanceAsync
//
// Purpose: Gets an instance from a particular object path
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoDeleteInstanceAsync(
    BSTR              a_strObjectPath,
    long              a_lFlags,
    IWbemContext    * a_pIContex,
    IWbemObjectSink * a_pIResponseHandler
  )
{
  ASSERT(g_pWlbsControl);

  if (g_pWlbsControl)
  {
    //
    // Re-enumerate all the clusters
    //
    g_pWlbsControl->ReInitialize();
  }
 

  ParsedObjectPath* pParsedPath = NULL;

  try {
    auto_ptr<CWlbs_Root>  pMofClass;

    //parse the object path
    ParseObjectPath( a_strObjectPath, &pParsedPath );

    //create an instance of the appropriate MOF support class
    HRESULT hRes = GetMOFSupportClass( pParsedPath->m_pClass, pMofClass, a_pIResponseHandler );

    //call the appropriate wrapper class GetInstance method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->DeleteInstance( pParsedPath );
  
    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    return hRes;
  }

  catch(_com_error HResErr) {

    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    return HResErr.Error();
    
  }

  catch(...) {

#ifdef DBG  // In debug version, popup a message box for AV
    MessageBoxExA(NULL,"Wlbs Provider Failure.","Wlbs Provider Access Violation",
        MB_TOPMOST | MB_ICONHAND | MB_OK | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);
#endif

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);
    return WBEM_E_FAILED;

  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::ExecMethodAsync
//
// Purpose: Executes a MOF class method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoExecMethodAsync(
    BSTR               a_strObjectPath, 
    BSTR               a_strMethodName, 
    long               a_lFlags, 
    IWbemContext     * a_pIContex, 
    IWbemClassObject * a_pIInParams, 
    IWbemObjectSink  * a_pIResponseHandler
  )
{
  ASSERT(g_pWlbsControl);

  if (g_pWlbsControl)
  {
    //
    // Re-enumerate all the clusters
    //
    g_pWlbsControl->ReInitialize();
  }
 

  ParsedObjectPath* pParsedPath   = NULL;

  try {

    //parse the object path
    auto_ptr<CWlbs_Root>  pMofClass;

    //parse the object path
    ParseObjectPath(a_strObjectPath, &pParsedPath);

    //create an instance of the appropriate MOF support class
    HRESULT hRes = GetMOFSupportClass(pParsedPath->m_pClass, pMofClass, a_pIResponseHandler);

    //execute MOF class method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->ExecMethod( pParsedPath, 
                                    a_strMethodName,
                                    0,
                                    NULL,
                                    a_pIInParams );

    if( pParsedPath )
       CObjectPathParser().Free( pParsedPath );

    return hRes;

  }

  catch(_com_error HResErr) {

    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    return HResErr.Error();
  }

  catch(...) {

#ifdef DBG  // In debug version, popup a message box for AV
    MessageBoxExA(NULL,"Wlbs Provider Failure.","Wlbs Provider Access Violation",
        MB_TOPMOST | MB_ICONHAND | MB_OK | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);
#endif

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);
    return WBEM_E_FAILED;

  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::PutInstanceAsync
//
// Purpose: Creates or modifies an instance
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoPutInstanceAsync
  ( 
    IWbemClassObject* a_pInst,
    long              a_lFlags,
    IWbemContext*     a_pIContex,
    IWbemObjectSink*  a_pIResponseHandler
  ) 
{
  ASSERT(g_pWlbsControl);

  if (g_pWlbsControl)
  {
    //
    // Re-enumerate all the clusters
    //
    g_pWlbsControl->ReInitialize();
  }
 

  ParsedObjectPath* pParsedPath  = NULL;
  HRESULT hRes = 0;

  try {
    
    wstring szClass;

    auto_ptr<CWlbs_Root>  pMofClass;

    //retrieve the class name
    GetClass( a_pInst, szClass );

    //create an instance of the appropriate MOF support class
    hRes = GetMOFSupportClass( szClass.c_str(), pMofClass, a_pIResponseHandler );

    //call the appropriate wrapper class PutInstance method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->PutInstance( a_pInst );
  
    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

  } 

  catch(_com_error HResErr) {

    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    hRes = HResErr.Error();
  }

  catch(...) {

#ifdef DBG  // In debug version, popup a message box for AV
    MessageBoxExA(NULL,"Wlbs Provider Failure.","Wlbs Provider Access Violation",
        MB_TOPMOST | MB_ICONHAND | MB_OK | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);
#endif

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);

    hRes = WBEM_E_FAILED;

  }

    return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::GetMOFSupportClass
//
// Purpose: Determines which MOF class is requested and instantiates the 
//          appropriate internal support class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBSProvider::GetMOFSupportClass(
  LPCWSTR               a_szObjectClass, 
  auto_ptr<CWlbs_Root>& a_pMofClass,
  IWbemObjectSink*      a_pResponseHandler )
{

  HRESULT hRes = 0;

  try {
    for( DWORD i = 0; i < MOF_CLASSES::NumClasses; i++ ) {
      if( _wcsicmp( a_szObjectClass, MOF_CLASSES::g_szMOFClassList[i] ) == 0) {
        a_pMofClass = auto_ptr<CWlbs_Root> 
          (MOF_CLASSES::g_pCreateFunc[i]( m_pNamespace, a_pResponseHandler ));
        break;
      }
    }
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat  = NULL;

    CWlbs_Root::CreateExtendedStatus( m_pNamespace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    a_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;

    pWbemExtStat->Release();
  }

  return hRes;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::ParseObjectPath
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
void CWLBSProvider::ParseObjectPath(
  const             BSTR a_strObjectPath, 
  ParsedObjectPath  **a_pParsedObjectPath )
{
  CObjectPathParser PathParser;

  ASSERT( a_pParsedObjectPath );

  //make sure this is NULL
  *a_pParsedObjectPath = NULL;


  int nStatus = PathParser.Parse(a_strObjectPath,  a_pParsedObjectPath);

  if(nStatus != 0) {
    
    if( *a_pParsedObjectPath) 
      PathParser.Free( *a_pParsedObjectPath );

    throw _com_error( WBEM_E_FAILED );

  }

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::GetClass
//
// Purpose: Retrieve the class name from an IWbemClassObject.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBSProvider::GetClass(
  IWbemClassObject* a_pClassObject, 
  wstring&          a_szClass )
{
  BSTR      strClassName = NULL;
  VARIANT   vClassName;
  HRESULT   hRes;

  try {

    VariantInit( &vClassName );

    strClassName = SysAllocString( L"__Class" );

    if( !strClassName )
      throw _com_error( WBEM_E_OUT_OF_MEMORY );

    hRes = a_pClassObject->Get( strClassName,
                                0,
                                &vClassName,
                                NULL,
                                NULL);

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    a_szClass.assign( static_cast<LPWSTR>(vClassName.bstrVal) );

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vClassName ))
        throw _com_error( WBEM_E_FAILED );

    if( strClassName ) {
      SysFreeString( strClassName );
      strClassName = NULL;
    }

  }
  catch( ... ) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vClassName );

    if( strClassName ) {
      SysFreeString( strClassName );
      strClassName = NULL;
    }

    throw;
  }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi2\wlbs_mofdata.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_MOFData.h"

#define GENERATE_VALUE_LIST
#include "WLBS_MofLists.h"

namespace MOF_CLASSES
{
  LPWSTR g_szMOFClassList[] = { MOF_CLASS_LIST };
  PCREATE g_pCreateFunc[] = 
  { CWLBS_Cluster::Create, 
    CWLBS_Node::Create, 
    CWLBS_ClusterSetting::Create,
    CWLBS_NodeSetting::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create, // For PortRuleEx
    CWLBS_ParticipatingNode::Create,
    CWLBS_NodeSetPortRule::Create,
    CWLBS_ClusClusSetting::Create,
    CWLBS_NodeNodeSetting::Create
  };
  DWORD  NumClasses = sizeof(g_szMOFClassList)/sizeof(LPWSTR);
};

//MOF_NODE namespace initialization
namespace MOF_NODE
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODE];
  LPWSTR   pProperties[] = { MOF_NODE_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_NODE_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_CLUSTER namespace initialization
namespace MOF_CLUSTER
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSTER];
  LPWSTR   pProperties[] = { MOF_CLUSTER_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_CLUSTER_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_CLUSTERSETTING namespace initialization
namespace MOF_CLUSTERSETTING
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSSET];
  LPWSTR   pProperties[] = { MOF_CLUSTERSETTING_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_CLUSTERSETTING_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_NODESETTING namespace initialization
namespace MOF_NODESETTING
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODESET];
  LPWSTR   pProperties[] = { MOF_NODESETTING_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_NODESETTING_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_PORTRULE namespace initialization
namespace MOF_PORTRULE
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE];
  LPWSTR   pProperties[] = { MOF_PORTRULE_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_PORTRULE_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_PRFAIL namespace initialization
namespace MOF_PRFAIL
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRFAIL];
  LPWSTR   pProperties[] = { MOF_PRFAIL_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_PRLOADBAL namespace initialization
namespace MOF_PRLOADBAL
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRLOADB];
  LPWSTR   pProperties[] = { MOF_PRLOADBAL_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_PRDIS namespace initialization
namespace MOF_PRDIS
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRDIS];
};

// MOF_PORTRULE_EX namespace initialization
namespace MOF_PORTRULE_EX
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORT_RULE_EX];
  LPWSTR   pProperties[] = { MOF_PORTRULE_EX_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_PORTRULE_EX_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_PARTICIPATINGNODE namespace initialization
namespace MOF_PARTICIPATINGNODE
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PARTNODE];
  LPWSTR   pProperties[] = { MOF_PARTICIPATINGNODE_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_NODESETTINGPORTRULE namespace initialization
namespace MOF_NODESETTINGPORTRULE
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODESETPR];
  LPWSTR   pProperties[] = { MOF_NODESETTINGPORTRULE_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_CLUSCLUSSETTING namespace initialization
namespace MOF_CLUSCLUSSETTING
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSCLUSSET];
  LPWSTR   pProperties[] = { MOF_CLUSCLUSSETTING_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_NODENODESETTING namespace initialization
namespace MOF_NODENODESETTING
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODENODESET];
  LPWSTR   pProperties[] = { MOF_NODENODESETTING_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

namespace MOF_PARAM
{
  LPWSTR PORT_NUMBER  = L"Port";
  LPWSTR HOST_ID      = L"HostID";
  LPWSTR NUM_NODES    = L"NumNodes";
  LPWSTR CLUSIP       = L"ClusterIPAddress";
  LPWSTR CLUSNETMASK  = L"ClusterNetworkMask";
  LPWSTR PASSW        = L"Password";
  LPWSTR DEDIP        = L"DedicatedIPAddress";
  LPWSTR DEDNETMASK   = L"DedicatedNetworkMask";
  LPWSTR PORTRULE     = L"PortRule";
  LPWSTR NODEPATH     = L"Node";
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi2\wlbs_moflists.h ===
//GENERATE_VALUE_LIST changes how LIST_ITEM appears when
//expanded by the preprocessor. 

//When GENERATE_VALUE_LIST is not defined,
//LIST_ITEM expands to the first column, which is utilized
//within WLBS_MOFData.h to define enumarated types that
//act as keys to their correlated arrays. 

//When GENERATE_VALUE_LIST is defined, LIST_ITEM
//expands to the second column which is utilized within
//WLBS_MOFData.cpp to initialize arrays of strings.

#ifdef GENERATE_VALUE_LIST

# ifdef LIST_ITEM
#   undef LIST_ITEM
# endif

# define LIST_ITEM(WLBS_KEY, WLBS_VALUE) WLBS_VALUE

#else

# ifdef LIST_ITEM
#   undef LIST_ITEM
# endif

# define LIST_ITEM(WLBS_KEY, WLBS_VALUE) WLBS_KEY

#endif

//The first columns represent arrays of keys and are defined in
//enumerated types. The second columns are values that are
//stored in arrays of strings. The arrays are stored within
//namespaces and are initialized in WLBS_MOFData.cpp. The 
//enumerated types are also scoped within namespaces and are
//defined in WLBS_MOFData.h.

#define MOF_NODE_PROPERTY_LIST \
  LIST_ITEM(NAME,       L"Name")                  , \
  LIST_ITEM(HOSTID,     L"HostPriority")          , \
  LIST_ITEM(IPADDRESS,  L"DedicatedIPAddress")    , \
  LIST_ITEM(STATUS,     L"StatusCode")				        , \
  LIST_ITEM(CREATCLASS, L"CreationClassName")

#define MOF_NODE_METHOD_LIST \
  LIST_ITEM(DISABLE,   L"Disable")  , \
  LIST_ITEM(ENABLE,    L"Enable")   , \
  LIST_ITEM(DRAIN,     L"Drain")    , \
  LIST_ITEM(DISABLE_EX,L"DisableEx"), \
  LIST_ITEM(ENABLE_EX, L"EnableEx") , \
  LIST_ITEM(DRAIN_EX,  L"DrainEx")  , \
  LIST_ITEM(DRAINSTOP, L"DrainStop"), \
  LIST_ITEM(RESUME,    L"Resume")   , \
  LIST_ITEM(START,     L"Start")    , \
  LIST_ITEM(STOP,      L"Stop")     , \
  LIST_ITEM(SUSPEND,   L"Suspend")

#define MOF_CLUSTER_PROPERTY_LIST \
  LIST_ITEM(NAME,       L"Name")                , \
  LIST_ITEM(IPADDRESS,  L"InterconnectAddress") , \
  LIST_ITEM(MAXNODES,   L"MaxNumberOfNodes")    , \
  LIST_ITEM(CLUSSTATE,  L"ClusterState")        , \
  LIST_ITEM(CREATCLASS, L"CreationClassName")   , \
  LIST_ITEM(STATUS,     L"ClusterState")

#define MOF_CLUSTER_METHOD_LIST \
  LIST_ITEM(DISABLE,   L"Disable")  , \
  LIST_ITEM(ENABLE,    L"Enable")   , \
  LIST_ITEM(DRAIN,     L"Drain")    , \
  LIST_ITEM(DRAINSTOP, L"DrainStop"), \
  LIST_ITEM(RESUME,    L"Resume")   , \
  LIST_ITEM(START,     L"Start")    , \
  LIST_ITEM(STOP,      L"Stop")     , \
  LIST_ITEM(SUSPEND,   L"Suspend")

#define MOF_CLUSTERSETTING_PROPERTY_LIST \
  LIST_ITEM(NAME,             L"Name")                    , \
  LIST_ITEM(CLUSNAME,         L"ClusterName")             , \
  LIST_ITEM(CLUSIPADDRESS,    L"ClusterIPAddress")        , \
  LIST_ITEM(CLUSNETMASK,      L"ClusterNetworkMask")      , \
  LIST_ITEM(CLUSMAC,          L"ClusterMACAddress")       , \
  LIST_ITEM(MULTIENABLE,      L"MulticastSupportEnabled") , \
  LIST_ITEM(REMCNTEN,         L"RemoteControlEnabled")    , \
  LIST_ITEM(IGMPSUPPORT,      L"IgmpSupport") , \
  LIST_ITEM(CLUSTERIPTOMULTICASTIP,      L"ClusterIPToMulticastIP") , \
  LIST_ITEM(MULTICASTIPADDRESS,      L"MulticastIPAddress") , \
  LIST_ITEM(ADAPTERGUID,      L"AdapterGuid")             , \
  LIST_ITEM(BDATEAMACTIVE,    L"BDATeamActive")           , \
  LIST_ITEM(BDATEAMID,        L"BDATeamId")               , \
  LIST_ITEM(BDATEAMMASTER,    L"BDATeamMaster")           , \
  LIST_ITEM(BDAREVERSEHASH,   L"BDAReverseHash") 

#define MOF_CLUSTERSETTING_METHOD_LIST \
  LIST_ITEM(SETPASS,   L"SetPassword")              , \
  LIST_ITEM(LDSETT,    L"LoadAllSettings")          , \
  LIST_ITEM(SETDEF,    L"SetDefaults")

#define MOF_NODESETTING_PROPERTY_LIST \
  LIST_ITEM(NAME,             L"Name")                  , \
  LIST_ITEM(DEDIPADDRESS,     L"DedicatedIPAddress")    , \
  LIST_ITEM(DEDNETMASK,       L"DedicatedNetworkMask")  , \
  LIST_ITEM(NUMRULES,         L"NumberOfRules")         , \
  LIST_ITEM(HOSTPRI,          L"HostPriority")          , \
  LIST_ITEM(MSGPERIOD,        L"AliveMessagePeriod")    , \
  LIST_ITEM(MSGTOLER,         L"AliveMessageTolerance") , \
  LIST_ITEM(CLUSMODEONSTART,  L"ClusterModeOnStart")    , \
  LIST_ITEM(REMOTEUDPPORT,    L"RemoteControlUDPPort")  , \
  LIST_ITEM(MASKSRCMAC,       L"MaskSourceMAC")         , \
  LIST_ITEM(DESCPERALLOC,     L"DescriptorsPerAlloc")   , \
  LIST_ITEM(MAXDESCALLOCS,    L"MaxDescriptorsPerAlloc"), \
  LIST_ITEM(NUMACTIONS,       L"NumActions")            , \
  LIST_ITEM(NUMPACKETS,       L"NumPackets")            , \
  LIST_ITEM(NUMALIVEMSGS,     L"NumAliveMessages")      , \
  LIST_ITEM(ADAPTERGUID,      L"AdapterGuid")           
             

//Removed per kyrilf request 8-12-1999
//  LIST_ITEM(NBTENABLE,        L"NBTSupportEnable")    , \

#define MOF_NODESETTING_METHOD_LIST \
  LIST_ITEM(GETPORT,  L"GetPortRule")                , \
  LIST_ITEM(GETPORT_EX,L"GetPortRuleEx")             , \
  LIST_ITEM(LDSETT,   L"LoadAllSettings")            , \
  LIST_ITEM(SETDEF,   L"SetDefaults")

#define MOF_PORTRULE_PROPERTY_LIST \
  LIST_ITEM(NAME,   L"Name")      , \
  LIST_ITEM(STPORT, L"StartPort") , \
  LIST_ITEM(EDPORT, L"EndPort")   , \
  LIST_ITEM(PROT,   L"Protocol"), \
  LIST_ITEM(ADAPTERGUID, L"AdapterGuid")


#define MOF_PORTRULE_METHOD_LIST \
  LIST_ITEM(SETDEF,    L"SetDefaults")

#define MOF_PRFAIL_PROPERTY_LIST \
  LIST_ITEM(PRIO, L"Priority")

#define MOF_PRLOADBAL_PROPERTY_LIST \
  LIST_ITEM(EQLD,  L"EqualLoad")  , \
  LIST_ITEM(LDWT,  L"LoadWeight") , \
  LIST_ITEM(AFFIN, L"Affinity")

#define MOF_PORTRULE_EX_PROPERTY_LIST \
  LIST_ITEM(NAME,   L"Name")            , \
  LIST_ITEM(VIP,    L"VirtualIPAddress"), \
  LIST_ITEM(STPORT, L"StartPort")       , \
  LIST_ITEM(EDPORT, L"EndPort")         , \
  LIST_ITEM(PROT,   L"Protocol")        , \
  LIST_ITEM(ADAPTERGUID, L"AdapterGuid"), \
  LIST_ITEM(FILTERINGMODE, L"FilteringMode"), \
  LIST_ITEM(EQLD,   L"EqualLoad")       , \
  LIST_ITEM(LDWT,   L"LoadWeight")      , \
  LIST_ITEM(AFFIN,  L"Affinity")        , \
  LIST_ITEM(PRIO,   L"Priority")


#define MOF_PARTICIPATINGNODE_PROPERTY_LIST \
  LIST_ITEM(CLUSTER, L"Dependent")    , \
  LIST_ITEM(NODE,    L"Antecedent")

#define MOF_NODESETTINGPORTRULE_PROPERTY_LIST \
  LIST_ITEM(NODESET,  L"GroupComponent")    , \
  LIST_ITEM(PORTRULE, L"PartComponent")

#define MOF_CLUSCLUSSETTING_PROPERTY_LIST \
  LIST_ITEM(CLUSTER, L"Element")    , \
  LIST_ITEM(CLUSSET, L"Setting")

#define MOF_NODENODESETTING_PROPERTY_LIST \
  LIST_ITEM(NODE,    L"Element")    , \
  LIST_ITEM(NODESET, L"Setting")

#define MOF_CLASS_LIST \
  LIST_ITEM(CLUSTER,     L"MicrosoftNLB_Cluster")              , \
  LIST_ITEM(NODE,        L"MicrosoftNLB_Node")                 , \
  LIST_ITEM(CLUSSET,     L"MicrosoftNLB_ClusterSetting")       , \
  LIST_ITEM(NODESET,     L"MicrosoftNLB_NodeSetting")          , \
  LIST_ITEM(PORTRULE,    L"MicrosoftNLB_PortRule")             , \
  LIST_ITEM(PRFAIL,      L"MicrosoftNLB_PortRuleFailover")     , \
  LIST_ITEM(PRDIS,       L"MicrosoftNLB_PortRuleDisabled")     , \
  LIST_ITEM(PRLOADB,     L"MicrosoftNLB_PortRuleLoadbalanced") , \
  LIST_ITEM(PORTRULE_EX, L"MicrosoftNLB_PortRuleEx")           , \
  LIST_ITEM(PARTNODE,    L"MicrosoftNLB_ParticipatingNode")    , \
  LIST_ITEM(NODESETPR,   L"MicrosoftNLB_NodeSettingPortRule")  , \
  LIST_ITEM(CLUSCLUSSET, L"MicrosoftNLB_ClusterClusterSetting"), \
  LIST_ITEM(NODENODESET, L"MicrosoftNLB_NodeNodeSetting")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi2\wlbs_mofdata.h ===
//WLBS_MOFData.h
#ifndef _WLBSMOFDATA_INCLUDED_
#define _WLBSMOFDATA_INCLUDED_

#include "WLBS_MofLists.h"

//forward declaration
class CWlbs_Root;

typedef CWlbs_Root* (*PCREATE)(CWbemServices*   a_pNameSpace, 
                               IWbemObjectSink* a_pResponseHandler);

namespace MOF_CLASSES
{
  enum { MOF_CLASS_LIST };
  extern LPWSTR  g_szMOFClassList[];
  extern PCREATE g_pCreateFunc[];
  extern DWORD  NumClasses;
};


//MOF_NODE namespace declaration
namespace MOF_NODE
{
  enum{MOF_NODE_PROPERTY_LIST};
  enum{MOF_NODE_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_NODE_PROPERTY_LIST
#undef MOF_NODE_METHOD_LIST

//MOF_CLUSTER namespace declaration
namespace MOF_CLUSTER
{
  enum{MOF_CLUSTER_PROPERTY_LIST};
  enum{MOF_CLUSTER_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_CLUSTER_PROPERTY_LIST
#undef MOF_CLUSTER_METHOD_LIST

//MOF_CLUSTERSETTING namespace declaration
namespace MOF_CLUSTERSETTING
{
  enum{MOF_CLUSTERSETTING_PROPERTY_LIST};
  enum{MOF_CLUSTERSETTING_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_CLUSTERSETTING_PROPERTY_LIST
#undef MOF_CLUSTERSETTING_METHOD_LIST

//MOF_NODESETTING namespace declaration
namespace MOF_NODESETTING
{
  enum{MOF_NODESETTING_PROPERTY_LIST};
  enum{MOF_NODESETTING_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_NODESETTING_PROPERTY_LIST
#undef MOF_NODESETTING_METHOD_LIST

//MOF_PORTRULE namespace initialization
namespace MOF_PORTRULE
{
  enum { MOF_PORTRULE_PROPERTY_LIST };
  enum {MOF_PORTRULE_METHOD_LIST};

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern LPWSTR   pMethods[];
  extern DWORD    NumProperties;
  extern DWORD    NumMethods;
};

#undef MOF_PORTRULE_PROPERTY_LIST

//MOF_PRFAIL namespace initialization
namespace MOF_PRFAIL
{
  enum { MOF_PRFAIL_PROPERTY_LIST };

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern DWORD    NumProperties;
};

#undef MOF_PRFAIL_PROPERTY_LIST

//MOF_PRLOADBAL namespace initialization
namespace MOF_PRLOADBAL
{
  enum { MOF_PRLOADBAL_PROPERTY_LIST };

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern DWORD    NumProperties;
};

#undef MOF_PRLOADBAL_PROPERTY_LIST

namespace MOF_PRDIS
{
  extern LPWSTR   szName;
};

//MOF_PORTRULE_EX namespace initialization
namespace MOF_PORTRULE_EX
{
  enum { MOF_PORTRULE_EX_PROPERTY_LIST };
  enum {MOF_PORTRULE_EX_METHOD_LIST};

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern LPWSTR   pMethods[];
  extern DWORD    NumProperties;
  extern DWORD    NumMethods;
};

#undef MOF_PORTRULE_EX_PROPERTY_LIST
#undef MOF_PORTRULE_EX_METHOD_LIST

//MOF_PARTICIPATINGNODE namespace initialization
namespace MOF_PARTICIPATINGNODE
{
  enum { MOF_PARTICIPATINGNODE_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};

#undef MOF_PARTICIPATINGNODE_PROPERTY_LIST

//MOF_NODESETTINGPORTRULE namespace initialization
namespace MOF_NODESETTINGPORTRULE
{
  enum { MOF_NODESETTINGPORTRULE_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_NODESETTINGPORTRULE_PROPERTY_LIST

//MOF_CLUSCLUSSETTING namespace initialization
namespace MOF_CLUSCLUSSETTING
{
  enum { MOF_CLUSCLUSSETTING_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_CLUSCLUSSETTING_PROPERTY_LIST

//MOF_NODENODESETTING namespace initialization
namespace MOF_NODENODESETTING
{
  enum { MOF_NODENODESETTING_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_NODENODESETTING_PROPERTY_LIST

//MOF_PARAM namespace declaration
namespace MOF_PARAM
{
  extern LPWSTR PORT_NUMBER;
  extern LPWSTR HOST_ID;
  extern LPWSTR NUM_NODES;
  extern LPWSTR CLUSIP;
  extern LPWSTR CLUSNETMASK;
  extern LPWSTR PASSW;
  extern LPWSTR DEDIP;
  extern LPWSTR DEDNETMASK;
  extern LPWSTR PORTRULE;
  extern LPWSTR NODEPATH;
};

#endif //_WLBSMOFDATA_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi2\wlbs_portrule.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_PortRule.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"


extern CWlbsControlWrapper* g_pWlbsControl;

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::CWLBS_PortRule
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_PortRule::CWLBS_PortRule
  ( 
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_PortRule::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_PortRule( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::ExecMethod
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::ExecMethod    
  (
    const ParsedObjectPath* /* a_pParsedPath */, 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*           /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams
  )
{
  
  IWbemClassObject* pOutputInstance   = NULL;
  VARIANT           vValue;
  HRESULT           hRes = 0;

  try {

    VariantInit( &vValue );

    //determine the method being executed
    if( _wcsicmp( a_strMethodName, MOF_PORTRULE::pMethods[MOF_PORTRULE::SETDEF] ) == 0 )  
    {

      //get the node path
      hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::NODEPATH ), 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( FAILED( hRes) ) 
      {
        throw _com_error( WBEM_E_FAILED );
      }

      //this check may not be necessary since WMI will do some
      //parameter validation
      //if( vValue.vt != VT_BSTR )
      //  throw _com_error ( WBEM_E_INVALID_PARAMETER );

      //parse node path
      CObjectPathParser PathParser;
      ParsedObjectPath *pParsedPath = NULL;

      try {

        int nStatus = PathParser.Parse( vValue.bstrVal, &pParsedPath );
        if(nStatus != 0) {
    
          if (NULL != pParsedPath)
          {
            PathParser.Free( pParsedPath );
            pParsedPath = NULL;
          }

          throw _com_error( WBEM_E_INVALID_PARAMETER );

        }

        //get the name key, which should be the only key
        if( *pParsedPath->m_paKeys == NULL )
        {
          throw _com_error( WBEM_E_INVALID_PARAMETER );
        }
 
        DWORD dwReqClusterIpOrIndex = ExtractClusterIP( (*pParsedPath->m_paKeys)->m_vValue.bstrVal);
        DWORD dwReqHostID = ExtractHostID(    (*pParsedPath->m_paKeys)->m_vValue.bstrVal);
      
        CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(
                dwReqClusterIpOrIndex);

        if (pCluster == NULL || (DWORD)-1 == dwReqHostID)
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to operate on any cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        pCluster->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
            throw _com_error( WBEM_E_INVALID_OPERATION );

        //validate host ID
        if( dwReqHostID != pCluster->GetHostID())
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        //invoke method
        pCluster->SetPortRuleDefaults();
      }
      catch( ... ) {

        if( pParsedPath )
        {
          PathParser.Free( pParsedPath );
          pParsedPath = NULL;
        }

        throw;
      }

    } else {
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;

  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    hRes = HResErr.Error();
  }

  catch ( ... ) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::GetInstance
//
// Purpose: This function retrieves an instance of a MOF PortRule 
//          class. The node does not have to be a member of a cluster. 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::GetInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT           hRes          = 0;

  try {

    if( !a_pParsedPath )
      throw _com_error( WBEM_E_FAILED );

    wstring wstrHostName;

    wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 1))->m_vValue.lVal );

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
    // so, we do not want to operate on any cluster that has a port rule
    // that is specific to a vip (other than the "all vip")
    // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
    // see of there is any port rule that is specific to a vip
    CNodeConfiguration NodeConfig;
    pCluster->GetNodeConfig(NodeConfig);
    if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
         throw _com_error( WBEM_E_INVALID_OPERATION );

    WLBS_PORT_RULE PortRule;

    pCluster->GetPortRule(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), dwReqStartPort, &PortRule );

    if( dwReqStartPort != PortRule.start_port )
      throw _com_error( WBEM_E_NOT_FOUND );

    SpawnInstance( a_pParsedPath->m_pClass, &pWlbsInstance );
    FillWbemInstance(a_pParsedPath->m_pClass, pCluster, pWlbsInstance, &PortRule );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance )
      pWlbsInstance->Release();

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::EnumInstances
//
// Purpose: This function obtains the PortRule data for the current host.
//          The node does not have to be a member of a cluster for this 
//          to succeed. However, NLB must be installed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::EnumInstances
  ( 
    BSTR             a_bstrClass,
    long             /*a_lFlags*/, 
    IWbemContext*    /*a_pIContex*/
  )
{
  IWbemClassObject**   ppWlbsInstance = NULL;
  HRESULT              hRes           = 0;
  PWLBS_PORT_RULE      pPortRules     = NULL;
  DWORD                dwNumRules     = 0;
  CNodeConfiguration   NodeConfig;

  try {

    DWORD dwFilteringMode;

    if( _wcsicmp( a_bstrClass, MOF_PRFAIL::szName ) == 0 ) {
      dwFilteringMode = WLBS_SINGLE;
    } else if( _wcsicmp( a_bstrClass, MOF_PRLOADBAL::szName ) == 0 ) {
      dwFilteringMode = WLBS_MULTI;
    } else if( _wcsicmp( a_bstrClass, MOF_PRDIS::szName ) == 0 ) {
      dwFilteringMode = WLBS_NEVER;
    } else {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      a_bstrClass,  
      0,                          
      NULL,                       
      &pWlbsClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }


    for (DWORD iCluster=0; iCluster<dwNumClusters; iCluster++)
    {
        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to return any port rule for a cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        ppCluster[iCluster]->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
            continue;

        //call the API query function to find the port rules

        ppCluster[iCluster]->EnumPortRules( &pPortRules, &dwNumRules, dwFilteringMode );
        if( dwNumRules == 0 ) 
          throw _com_error( WBEM_E_NOT_FOUND );


        //spawn an instance of the MOF class for each rule found
        ppWlbsInstance = new IWbemClassObject *[dwNumRules];

        if( !ppWlbsInstance )
          throw _com_error( WBEM_E_OUT_OF_MEMORY );

        //initialize array
        ZeroMemory( ppWlbsInstance, dwNumRules * sizeof(IWbemClassObject *) );

        for( DWORD i = 0; i < dwNumRules; i ++ ) {
          hRes = pWlbsClass->SpawnInstance( 0, &ppWlbsInstance[i] );

          if( FAILED( hRes ) )
            throw _com_error( hRes );

          FillWbemInstance(a_bstrClass, ppCluster[iCluster], *(ppWlbsInstance + i), pPortRules + i );
        }

        //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( dwNumRules, ppWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < dwNumRules; i++ ) {
            if( ppWlbsInstance[i] ) {
              ppWlbsInstance[i]->Release();
            }
          }
          delete [] ppWlbsInstance;
          ppWlbsInstance = NULL;
          dwNumRules = NULL;

        }

        if( pPortRules ) 
        {
          delete [] pPortRules;
          pPortRules = NULL;
        }
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    hRes = HResErr.Error();
  }

  catch(...) {

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::DeleteInstance
//
// Purpose: This function deletes an instance of a MOF PortRule 
//          class. The node does not have to be a member of a cluster. However,
//          WLBS must be installed for this function to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::DeleteInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /*a_lFlags*/,
    IWbemContext*           /*a_pIContex*/
  )
{

  HRESULT hRes = 0;

  try {
    if( !a_pParsedPath )
      throw _com_error( WBEM_E_FAILED );

    wstring wstrHostName;
    DWORD   dwVip, dwReqStartPort;

    wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // If the instance to be deleted is of type "PortRuleEx", then, retreive the vip, otherwise
    // verify that we are operating in the "all vip" mode
    if (_wcsicmp(a_pParsedPath->m_pClass, MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRVIP]) == 0)
    {
        dwVip = IpAddressFromAbcdWsz((*(a_pParsedPath->m_paKeys + 1))->m_vValue.bstrVal);
        dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 2))->m_vValue.lVal );
    }
    else
    {
        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to operate on any cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        pCluster->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
             throw _com_error( WBEM_E_INVALID_OPERATION );

        dwVip = IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP);
        dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 1))->m_vValue.lVal );
    }

    WLBS_PORT_RULE PortRule;

    // Get the port rule for this vip & port
    pCluster->GetPortRule(dwVip, dwReqStartPort, &PortRule );

    if( (dwVip != IpAddressFromAbcdWsz(PortRule.virtual_ip_addr)) || (dwReqStartPort != PortRule.start_port) )
      throw _com_error( WBEM_E_NOT_FOUND );

    // Delete the port rule for this vip & port
    pCluster->DeletePortRule(dwVip, dwReqStartPort );

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    hRes = HResErr.Error();
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::PutInstance
//
// Purpose: This function updates an instance of a PortRule 
//          class. The host does not have to be a member of a cluster.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::PutInstance
  ( 
    IWbemClassObject* a_pInstance,
    long              /*a_lFlags*/,
    IWbemContext*     /*a_pIContex*/
  )
{
  VARIANT vValue;
  HRESULT hRes = 0;

  WLBS_PORT_RULE NewRule; //the instance to put
  namespace PR, PRFO, PRLB;
  bool bPREx;


  try {

    VariantInit( &vValue );

    //get the class name to determine port rule mode
    hRes = a_pInstance->Get( _bstr_t( L"__Class" ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    wcscpy(szClassName, vValue.bstrVal);

    // If it is a port rule class containing the VIP, then, the namespaces are different
    if (_wcsicmp(szClassName, MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]) == 0)
    {
        bPREx = true;
        PR = PRFO = PRLB = MOF_PORTRULE_EX;
    }
    else
    {
        bPREx = false;
        PR    = MOF_PORTRULE;
        PRFO  = MOF_PRFAIL;
        PRLB  = MOF_PRLOADBAL;
    }

    // Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    //get the host name value
    hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::NAME] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    wstring wstrHostName( vValue.bstrVal );

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    // If the instance to be put is of type "PortRuleEx", then, retreive the vip, otherwise
    // verify that we are operating in the "all vip" mode
    if (bPREx)
    {
        //get the vip
        hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::VIP] ),
                                 0,
                                 &vValue,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        wcscpy(NewRule.virtual_ip_addr, vValue.bstrVal);

        if (S_OK != VariantClear( &vValue ))
            throw _com_error( WBEM_E_FAILED );
    }
    else
    {
        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to operate on any cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        pCluster->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
             throw _com_error( WBEM_E_INVALID_OPERATION );

        wcscpy(NewRule.virtual_ip_addr, CVY_DEF_ALL_VIP);
    }

    //retrieve start and end ports
    hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::STPORT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    NewRule.start_port = static_cast<DWORD>( vValue.lVal );

    hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::EDPORT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    NewRule.end_port   = static_cast<DWORD>( vValue.lVal );

    //get the protocol
    hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::PROT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    NewRule.protocol = static_cast<DWORD>( vValue.lVal );

    if( _wcsicmp( szClassName, MOF_PRDIS::szName ) == 0 ) {
      NewRule.mode = WLBS_NEVER;

    } else if(_wcsicmp( szClassName, PRFO::szName ) == 0 ) {
      NewRule.mode = WLBS_SINGLE;

      VARIANT vRulePriority;
      VariantInit( &vRulePriority );

      try {
        //get the rule priority
        hRes = a_pInstance->Get( _bstr_t( PRFO::pProperties[PRFO::PRIO] ),
                                 0,
                                 &vRulePriority,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

      } 
      catch( ... ) {

        // CLD: Need to check return code for error
        // No throw here since we are already throwing an exception.
        VariantClear( &vRulePriority );
        throw;
      }

      
      NewRule.mode_data.single.priority = static_cast<DWORD>( vRulePriority.lVal );

      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vRulePriority ))
          throw _com_error( WBEM_E_FAILED );

    } else if(_wcsicmp( szClassName, PRLB::szName ) == 0 ) {
      NewRule.mode = WLBS_MULTI;

      VARIANT v;

      VariantInit( &v );

      try {
        //get the affinity
        hRes = a_pInstance->Get( _bstr_t( PRLB::pProperties[PRLB::AFFIN] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        NewRule.mode_data.multi.affinity = static_cast<WORD>( v.lVal );

        //get the equal load boolean
        hRes = a_pInstance->Get( _bstr_t( PRLB::pProperties[PRLB::EQLD] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        if( v.boolVal == -1 ) {
          NewRule.mode_data.multi.equal_load = 1;
        } else {
          NewRule.mode_data.multi.equal_load = 0;
        }

        //get the load
        hRes = a_pInstance->Get( _bstr_t( PRLB::pProperties[PRLB::LDWT] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        if( v.vt != VT_NULL )
          NewRule.mode_data.multi.load = static_cast<DWORD>( v.lVal );
        else
          NewRule.mode_data.multi.load = 0;

      } catch( ... ) {

        // CLD: Need to check return code for error
        // No throw here since we are already throwing an exception.
        VariantClear( &v );

        throw;
      }

      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &v ))
          throw _com_error( WBEM_E_FAILED );
    }

    //delete the port rule but cache in case of failure
    WLBS_PORT_RULE OldRule;
    bool bOldRuleSaved = false;

    if( pCluster->RuleExists(IpAddressFromAbcdWsz(NewRule.virtual_ip_addr), NewRule.start_port ) ) {
      pCluster->GetPortRule(IpAddressFromAbcdWsz(NewRule.virtual_ip_addr), NewRule.start_port, &OldRule );
      bOldRuleSaved = true;

      pCluster->DeletePortRule(IpAddressFromAbcdWsz(NewRule.virtual_ip_addr), NewRule.start_port );
    }

    //add the port rule, roll back if failed
    try {
      pCluster->PutPortRule( &NewRule );

    } catch(...) {

      if( bOldRuleSaved )
        pCluster->PutPortRule( &OldRule );

      throw;
    }

    //release resources
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    hRes = HResErr.Error();
  }

  catch (...) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_PortRule::FillWbemInstance
  ( 
    LPCWSTR              a_szClassName,
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject*      a_pWbemInstance, 
    const PWLBS_PORT_RULE& a_pPortRule
  )
{
  namespace PR, PRFO, PRLB;
  bool bPRVip;

  ASSERT( a_pWbemInstance );

  // If it is a port rule class containing the VIP, then, the namespaces are different
  if (_wcsicmp(a_szClassName, MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]) == 0)
  {
      bPRVip = true;
      PR = PRFO = PRLB = MOF_PORTRULE_EX;
  }
  else
  {
      bPRVip = false;
      PR     = MOF_PORTRULE;
      PRFO   = MOF_PRFAIL;
      PRLB   = MOF_PRLOADBAL;
  }

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID());


  //NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::NAME] ) ,
      0                                              ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  // Fill in VIP if it is a port rule class containing VIP
  if (bPRVip) {

      HRESULT hRes = a_pWbemInstance->Put
        (
          _bstr_t( PR::pProperties[PR::VIP] ) ,
          0                                              ,
          &_variant_t(a_pPortRule->virtual_ip_addr),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );
  }

  //STPORT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::STPORT] ),
      0                                                  ,
      &_variant_t(static_cast<long>(a_pPortRule->start_port)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //EDPORT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::EDPORT] ),
      0                                                ,
      &_variant_t(static_cast<long>(a_pPortRule->end_port)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //ADAPTERGUID 
  GUID AdapterGuid = pCluster->GetAdapterGuid();
  
  WCHAR szAdapterGuid[128];
  StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );
  
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::ADAPTERGUID] ),
      0                                                ,
      &_variant_t(szAdapterGuid),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //PROT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::PROT] ),
      0,
      &_variant_t(static_cast<long>(a_pPortRule->protocol)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  // If it is a port rule class containing all parameters of all filtering modes, 
  // initialize them with a "don't care" value (zero). The appropriate fields (depending on filtering mode)
  // are filled in later.
  if (bPRVip) {
      hRes = a_pWbemInstance->Put ( _bstr_t( PRLB::pProperties[PRLB::EQLD] ), 0, &_variant_t(0), NULL);
      if( FAILED( hRes ) )
          throw _com_error( hRes );
      hRes = a_pWbemInstance->Put ( _bstr_t( PRLB::pProperties[PRLB::LDWT] ), 0, &_variant_t(0), NULL);
      if( FAILED( hRes ) )
          throw _com_error( hRes );
      hRes = a_pWbemInstance->Put ( _bstr_t( PRLB::pProperties[PRLB::AFFIN] ), 0, &_variant_t(0), NULL);
      if( FAILED( hRes ) )
          throw _com_error( hRes );
      hRes = a_pWbemInstance->Put (_bstr_t( PRFO::pProperties[PRFO::PRIO] ), 0, &_variant_t(0), NULL);
      if( FAILED( hRes ) )
          throw _com_error( hRes );
  }

  // TO BE DONE : Fill in the "FilteringMode" for the PortRuleEx class

  switch( a_pPortRule->mode ) {
    case WLBS_SINGLE:
      //PRIO
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PRFO::pProperties[PRFO::PRIO] ),
          0                                                ,
          &_variant_t(static_cast<long>(a_pPortRule->mode_data.single.priority)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      break;
    case WLBS_MULTI:
      //EQLD
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PRLB::pProperties[PRLB::EQLD] ),
          0                                                ,
          &_variant_t((a_pPortRule->mode_data.multi.equal_load != 0)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //LDWT
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PRLB::pProperties[PRLB::LDWT] ),
          0                                                ,
         &_variant_t(static_cast<long>(a_pPortRule->mode_data.multi.load)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //AFFIN
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PRLB::pProperties[PRLB::AFFIN] ),
          0                                                ,
          &_variant_t(static_cast<long>(a_pPortRule->mode_data.multi.affinity)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      break;
    case WLBS_NEVER:
      //there are no properties
      break;
    default:
      throw _com_error( WBEM_E_FAILED );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\main.cpp ===
/*
 * Filename: Main.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include "stdafx.h"

#include <stdio.h>
#include <string.h>

#include "NLB_XMLParser.h"

#include <vector>
using namespace std;

int __cdecl wmain (int argc, WCHAR ** argv) {
    vector<NLB_Cluster> Clusters;
    bool bValidateOnly = false;
    bool bShowPopups = true;
    NLB_XMLParser * pParser;
    NLB_XMLError error;
    HRESULT hr = S_OK;
    int arg;

    if (argc < 2) {
        goto usage;
    }

    for (arg = 2; arg < argc; arg++) {
        if (argv[arg][0] == L'-') {
            if (!lstrcmpi(argv[arg] + 1, L"validate")) {
                bValidateOnly = true;
            } else if (!lstrcmpi(argv[arg] + 1, L"nopopups")) {
                bShowPopups = false;
            } else {
                printf("Invalid argument: %ls\n", argv[arg]);
                goto usage;
            }
                
        } else {
            printf("Invalid argument: %ls\n", argv[arg]);
            goto usage;
        }
    }

    pParser = new NLB_XMLParser(!bShowPopups);

    if (bValidateOnly) {
        printf("\nValidating XML document...\n");
        hr = pParser->Parse(argv[1]);
    } else {
        printf("\nParsing XML document...\n");
        hr = pParser->Parse(argv[1], &Clusters);
    }

    if (!bShowPopups) {
        printf("\n");

        if (hr != S_OK) { 
            pParser->GetParseError(&error);
            
            fprintf(stderr, "Error 0x%08x:\n\n%ls\n", error.code, error.wszReason);
            
            if (error.line > 0) {
                fprintf(stderr, "Error on line %d, position %d in \"%ls\".\n", 
                        error.line, error.character, error.wszURL);
            }
            
            return -1;
        } else {
            fprintf(stderr, "XML document loaded successfully...\n");
        }
    }

    if (!bValidateOnly)
        pParser->Print();

    return 0;

 usage:
    printf("Usage: %ls <XML filename> [-validate] [-nopopups]\n", argv[0]);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi2\wlbs_node.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_Node.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::CWLBS_Node
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_Node::CWLBS_Node(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_Node::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_Node( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::GetInstance
//
// Purpose: Queries WLBS for desired node instance and sends results back
//          to WinMgMt.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //g_pWlbsControl->CheckConfiguration();

    //get the node
    FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat  = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::EnumInstances
//
// Purpose: Executes a WlbsQuery and sends data back to WinMgMt.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject**   ppWlbsInstance    = NULL;
  WLBS_RESPONSE*      pResponse         = NULL;
  HRESULT hRes = 0;

  BSTR strClassName = NULL;
  long nNumNodes = 0;
  
  //g_pWlbsControl->CheckConfiguration();

  try {

    strClassName = SysAllocString( MOF_NODE::szName );

    if( !strClassName )
      throw _com_error( WBEM_E_OUT_OF_MEMORY );

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsNodeClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      strClassName,  
      0,                          
      NULL,                       
      &pWlbsNodeClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }


    for (DWORD iCluster=0; iCluster<dwNumClusters; iCluster++)
    {

        //call the API query function to find the nodes
        
        try {
            FindAllInstances(ppCluster[iCluster], &pResponse, nNumNodes );
        } catch (CErrorWlbsControl Err)
        {
            //
            // Skip this cluster
            //
            TRACE_ERROR1("CWLBS_Node::EnumInstances skiped cluster %x", 
                    ppCluster[iCluster]->GetClusterIP());
            continue;
        }
    

        //spawn an instance of the Node MOF class for each node found
        ppWlbsInstance = new IWbemClassObject *[nNumNodes];

        if( !ppWlbsInstance )
          throw _com_error( WBEM_E_OUT_OF_MEMORY );

        //initialize array
        ZeroMemory( ppWlbsInstance, nNumNodes * sizeof(IWbemClassObject *) );

        for(int i = 0; i < nNumNodes; i ++ ) {
          hRes = pWlbsNodeClass->SpawnInstance( 0, &ppWlbsInstance[i] );

        if( FAILED( hRes ) )
            throw _com_error( hRes );

        FillWbemInstance(ppCluster[iCluster], ppWlbsInstance[i], pResponse + i );
        }

        //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( nNumNodes, ppWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < nNumNodes; i++ ) {
            if( ppWlbsInstance[i] ) {
                ppWlbsInstance[i]->Release();
            }
          }
            delete [] ppWlbsInstance;
        }

        if( pResponse ) 
        delete [] pResponse;
    }

    if( strClassName )
      SysFreeString(strClassName);

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    hRes = HResErr.Error();
  }

  catch(...) {

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::ExecMethod
//
// Purpose: This executes the methods associated with the MOF
//          Node class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::ExecMethod
  (
    const ParsedObjectPath* a_pParsedPath, 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*           /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams
  )
{

  DWORD dwNumHosts = 1;
  DWORD dwReturnValue;

  HRESULT       hRes = 0;

  _variant_t vMofResponse;
  _variant_t vReturnValue;
  _variant_t vVip, vInputPortNumber;
  CNodeConfiguration NodeConfig;
  DWORD      dwVip, dwPort;
  VARIANT    vValue;

  BSTR       strPortNumber = NULL;

  IWbemClassObject* pOutputInstance = NULL;

  try {

    strPortNumber = SysAllocString( MOF_PARAM::PORT_NUMBER );

    if( !strPortNumber )
      throw _com_error( WBEM_E_OUT_OF_MEMORY );

    //get the host ID address
    DWORD dwHostID = 0;
    DWORD dwClusterIpOrIndex = 0;
    
    dwHostID = ExtractHostID( wstring( (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal ) );
    if ((DWORD)-1 == dwHostID)
        throw _com_error( WBEM_E_NOT_FOUND );

    dwClusterIpOrIndex = ExtractClusterIP( wstring( (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal ) );
    if ((DWORD)-1 == dwClusterIpOrIndex)
        throw _com_error( WBEM_E_NOT_FOUND );
 
    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);

    if (pCluster == NULL)
        throw _com_error( WBEM_E_NOT_FOUND );
    
    //always let the provider peform control operations on the local host
    if( dwHostID == pCluster->GetHostID() ) 
      dwHostID    = WLBS_LOCAL_HOST;
    //get the output object instance
    GetMethodOutputInstance( MOF_NODE::szName, 
                             a_strMethodName, 
                             &pOutputInstance );

    //determine and execute the MOF method
    if( _wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DISABLE] ) == 0)  {
    
      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Disable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );

      //get the port number
      hRes = a_pIInParams->Get
                  (  strPortNumber, 
                     0, 
                     &vInputPortNumber, 
                     NULL, 
                     NULL
                   );

      if( FAILED( hRes ) ) {
        throw _com_error( hRes );
      }

      //make sure the port number is not NULL
      if( vInputPortNumber.vt != VT_I4) 
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      //call Disable method
      dwReturnValue = g_pWlbsControl->Disable
                        (
                          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                          dwHostID, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          (long)vInputPortNumber
                        );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::ENABLE]   ) == 0)  {

      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Enable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );

      //get the port number
      hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vInputPortNumber, 
                   NULL, 
                   NULL
                 );

      if( FAILED( hRes ) ) {
        throw _com_error( hRes );
      }

      if( vInputPortNumber.vt != VT_I4) 
        throw _com_error(WBEM_E_INVALID_PARAMETER);

      //call Enable method
      dwReturnValue = g_pWlbsControl->Enable
        (
          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
          dwHostID, 
          NULL, 
          dwNumHosts, 
          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
          (long)vInputPortNumber
        );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DRAIN]    ) == 0)  {

      if( !a_pIInParams )
        throw _com_error( WBEM_E_INVALID_PARAMETER );

      // The "Drain" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );

      //get the port number
      hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vInputPortNumber, 
                   NULL, 
                   NULL
                 );

      if( FAILED( hRes ) ) {
        throw _com_error( hRes );
      }

      if( vInputPortNumber.vt != VT_I4) 
        throw _com_error(WBEM_E_INVALID_PARAMETER);

      //call Drain method
      dwReturnValue = g_pWlbsControl->Drain
                        (
                          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                          dwHostID, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          (long)vInputPortNumber
                        );

    }else if( _wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::DISABLE_EX] ) == 0)  {

        if( !a_pIInParams )
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        //get the vip
        hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::VIP ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

        if( vValue.vt != VT_BSTR )
            throw _com_error ( WBEM_E_INVALID_PARAMETER );

        dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );
        
        //get the port number
        hRes = a_pIInParams->Get
                  (  strPortNumber, 
                     0, 
                     &vValue, 
                     NULL, 
                     NULL
                   );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        //range checking is done by the API
        if( vValue.vt != VT_I4 ) 
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        dwPort = vValue.lVal;

        //call Disable method
        dwReturnValue = g_pWlbsControl->Disable
                          (
                            pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                            dwHostID, 
                            NULL, 
                            dwNumHosts, 
                            dwVip,
                            dwPort
                          );

      } else if(_wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::ENABLE_EX] ) == 0)  {

        if( !a_pIInParams )
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        //get the vip
        hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::VIP ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

        if( vValue.vt != VT_BSTR )
            throw _com_error ( WBEM_E_INVALID_PARAMETER );

        dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );

        //get the port number
        hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vValue, 
                   NULL, 
                   NULL
                 );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        //range checking is done by the API
        if( vValue.vt != VT_I4 ) 
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        dwPort = vValue.lVal;

        //call Enable method
        dwReturnValue = g_pWlbsControl->Enable
          (
            pCluster->GetClusterIpOrIndex(g_pWlbsControl),
            dwHostID, 
            NULL, 
            dwNumHosts, 
            dwVip,
            dwPort
          );

      } else if( _wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::DRAIN_EX] ) == 0 )  {

        if( !a_pIInParams )
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        //get the vip
        hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::VIP ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

        if( vValue.vt != VT_BSTR )
            throw _com_error ( WBEM_E_INVALID_PARAMETER );

        dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );

        //get the port number
        hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vValue, 
                   NULL, 
                   NULL
                 );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        //range checking is done by the API
        if( vValue.vt != VT_I4 ) 
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        dwPort = vValue.lVal;

        //call Drain method
        dwReturnValue = g_pWlbsControl->Drain
                          (
                            pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                            dwHostID, 
                            NULL, 
                            dwNumHosts, 
                            dwVip,
                            dwPort
                          );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DRAINSTOP]) == 0)  {

      //call DrainStop method
      dwReturnValue = g_pWlbsControl->DrainStop( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::RESUME]   ) == 0)  {

      //call Resume method
      dwReturnValue = g_pWlbsControl->Resume( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::START]    ) == 0)  {

      //call Start method
      dwReturnValue = g_pWlbsControl->Start( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::STOP]     ) == 0)  {

      //call Stop method
      dwReturnValue = g_pWlbsControl->Stop( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::SUSPEND]  ) == 0)  {

      //call Suspend method
      dwReturnValue = g_pWlbsControl->Suspend( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else {

      throw _com_error(WBEM_E_METHOD_NOT_IMPLEMENTED);
    }

    //set the return value
    vReturnValue = (long)dwReturnValue;
    hRes = pOutputInstance->Put( _bstr_t(L"ReturnValue"), 0, &vReturnValue, 0 );

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }
    
    //send the results back to WinMgMt
    hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    if( pWbemExtStat )
      pWbemExtStat->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    hRes = HResErr.Error();
  }

  catch(...) {

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FindInstance
//
// Purpose: This routine determines if a host is within the local cluster. If
//          it is, then the host's data is obtained and returned via the 
//          IWbemClassObject interface.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FindInstance

  ( 
    IWbemClassObject**       a_ppWbemInstance,
    const ParsedObjectPath*  a_pParsedPath
  )

{
  try {
    //get the key property
    //throws _com_error
    //get the name key property and convert to ANSI
    //throws _com_error
    wstring szRequestedHostName = ( *a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwClustIpOrIndex = ExtractClusterIP( szRequestedHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL )
      throw _com_error( WBEM_E_NOT_FOUND );

    WLBS_RESPONSE Response;

    DWORD dwHostID = ExtractHostID( szRequestedHostName );
    if ((DWORD)-1 == dwHostID)
        throw _com_error( WBEM_E_NOT_FOUND );

    //always let the provider peform control operations on the local host
    if( dwHostID == pCluster->GetHostID() ) 
    {
      dwHostID = WLBS_LOCAL_HOST;
    }

    DWORD dwNumHosts  =  1;
    //call the api query function
    g_pWlbsControl->Query( pCluster,
                           dwHostID  , 
                           &Response   , 
                           &dwNumHosts, 
                           NULL );

    if( dwNumHosts == 0 )
      throw _com_error( WBEM_E_NOT_FOUND );

    //if requested, fill a MOF instance structure
    if(a_ppWbemInstance) {

      //get the Wbem class instance
      SpawnInstance( MOF_NODE::szName, a_ppWbemInstance );

      //Convert status to string description
      FillWbemInstance(pCluster, *a_ppWbemInstance, &Response );

    }
  }
  catch(...) {

    if( *a_ppWbemInstance ) {

      delete *a_ppWbemInstance;
      *a_ppWbemInstance = NULL;

    }

    throw;

  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FindAllInstances
//
// Purpose: This executes a WLBS query and returns Response structures upon
//          success. It always performs a local query to get the local host
//          so that disabling remote control will not prevent it from
//          enumerating. The dedicated IP address is added to the structure
//          within the CWlbsControlWrapper::Query call.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FindAllInstances
  (
  CWlbsClusterWrapper* pCluster,
   WLBS_RESPONSE**      a_ppResponse,
   long&                 a_nNumNodes
  )
{
  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  WLBS_RESPONSE LocalResponse;

  ASSERT(pCluster);
  
  ZeroMemory(Response, WLBS_MAX_HOSTS * sizeof(WLBS_RESPONSE));
  DWORD dwNumHosts  =  WLBS_MAX_HOSTS;

  a_nNumNodes = 0;  //this will contain the number of nodes returned


  try {

      //get the local host
      DWORD dwLocalNode = 1;
      g_pWlbsControl->Query( pCluster,
                               WLBS_LOCAL_HOST, 
                               &LocalResponse, 
                               &dwLocalNode, 
                               NULL);

      try {

          //we only want remote hosts
          if( pCluster->GetClusterIP() != 0 ) 
          {
              g_pWlbsControl->Query( pCluster,
                                     WLBS_ALL_HOSTS, 
                                     Response, 
                                     &dwNumHosts, 
                                     NULL );
          } 
          else 
          {
              dwNumHosts = 0;
          }
      } catch (CErrorWlbsControl Err) {
          dwNumHosts = 0;
          if (Err.Error() != WLBS_TIMEOUT)
          {
              throw;
          }
      }

      //this wastes memory if the local node
      //has remote control enabled
      a_nNumNodes = dwNumHosts + 1;

      if( a_ppResponse ) {
          *a_ppResponse = new WLBS_RESPONSE[a_nNumNodes];

          if( !*a_ppResponse )
            throw _com_error( WBEM_E_OUT_OF_MEMORY );

            //copy the local host
          (*a_ppResponse)[0] = LocalResponse;

          int j = 1;
          for(DWORD i = 1; i <= dwNumHosts; i++ ) 
          {
            //do not copy the local host again should it have remote control enabled
            if( Response[i-1].id == LocalResponse.id ) 
            {
              //we received the local node twice, so we reduce the count
              //by one
              a_nNumNodes--;
              continue;
            }
            (*a_ppResponse)[j] = Response[i-1];
            j++;
          }

        }
  } catch (...) {

      if ( *a_ppResponse )
      {
          delete [] *a_ppResponse;
          *a_ppResponse = NULL;
      }

      throw;
  }
}



////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance, 
    WLBS_RESPONSE*   a_pResponse   
  )
{
  namespace NODE = MOF_NODE;

  ASSERT( a_pWbemInstance );
  ASSERT( a_pResponse );

  wstring wstrHostName;

  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      a_pResponse->id );

  //HOST NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( NODE::pProperties[NODE::NAME] ) ,
      0                                        ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //HOST ID
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::HOSTID] )         ,
      0                                                  ,
      &_variant_t((long)(a_pResponse->id)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //CREATCLASS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::CREATCLASS] ),
      0                                            ,
      &_variant_t(NODE::szName),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //IP ADDRESS
  wstring szIPAddress;
  AddressToString( a_pResponse->address, szIPAddress );
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::IPADDRESS] ),
      0                                            ,
      &_variant_t(szIPAddress.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //STATUS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::STATUS] )         ,
      0                                                  ,
      &_variant_t((long)a_pResponse->status),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi2\wlbs_nodesetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_NodeSetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::CWLBS_NodeSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_NodeSetting::CWLBS_NodeSetting
  ( 
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_NodeSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_NodeSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::GetInstance
//
// Purpose: This function retrieves an instance of a MOF NodeSetting 
//          class. The node does not have to be a member of a cluster. However,
//          WLBS must be installed for this function to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::GetInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //get the name key property and convert to wstring
    const wchar_t* wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    DWORD dwHostID = ExtractHostID( wstrHostName );

    if (pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
        throw _com_error( WBEM_E_NOT_FOUND );

    //get the Wbem class instance
    SpawnInstance( MOF_NODESETTING::szName, &pWlbsInstance );

    //Convert status to string description
    FillWbemInstance(pCluster, pWlbsInstance );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    //if( pWbemExtStat )
      //pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
    
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::EnumInstances
//
// Purpose: This function obtains the NodeSetting data for the current host.
//          The node does not have to be a member of a cluster for this 
//          to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::EnumInstances
  ( 
    BSTR             /*a_bstrClass*/,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject*    pWlbsInstance = NULL;
  HRESULT              hRes          = 0;

  try {


    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i<dwNumClusters; i++)
    {
        //get the Wbem class instance
        SpawnInstance( MOF_NODESETTING::szName, &pWlbsInstance );

        //Convert status to string description
        FillWbemInstance(ppCluster[i], pWlbsInstance );

        //send the results back to WinMgMt
        m_pResponseHandler->Indicate( 1, &pWlbsInstance );
    }

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::PutInstance
//
// Purpose: This function updates an instance of a MOF NodeSetting 
//          class. The node does not have to be a member of a cluster.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::PutInstance
  ( 
   IWbemClassObject* a_pInstance,
   long              /* a_lFlags */,
   IWbemContext*     /* a_pIContex */
  ) 
{
  VARIANT vHostName;
  HRESULT hRes = 0;

  try {

    VariantInit( &vHostName );

    //get the host name value
    hRes = a_pInstance->Get( _bstr_t( MOF_NODESETTING::pProperties[MOF_NODESETTING::NAME] ),
                             0,
                             &vHostName,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    wstring wstrHostName( vHostName.bstrVal );
     
    DWORD dwClustIpOrIndex = ExtractClusterIP( wstrHostName );
    DWORD dwHostID = ExtractHostID( wstrHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
      throw _com_error( WBEM_E_NOT_FOUND );

    UpdateConfiguration(pCluster, a_pInstance );

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vHostName ))
        throw _com_error( WBEM_E_FAILED );

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    hRes = HResErr.Error();
  }

  catch (...) {

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::ExecMethod
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::ExecMethod    
  ( 
    const ParsedObjectPath* a_pParsedPath , 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*          /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams 
  ) 
{
  
  IWbemClassObject* pOutputInstance   = NULL;
  IWbemClassObject* pWbemPortRule = NULL;
  HRESULT           hRes = 0;
  CNodeConfiguration NodeConfig;

  VARIANT           vValue ;

  try {
    VariantInit( &vValue );
    
    VARIANT vHostName ;
    VariantInit( &vHostName );

    if (a_pParsedPath->m_paKeys == NULL)
    {
        // 
        // No name specified
        //
        throw _com_error( WBEM_E_INVALID_PARAMETER );
    }
    wstring  wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwClustIpOrIndex = ExtractClusterIP( wstrHostName );
    DWORD dwHostID = ExtractHostID( wstrHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
      throw _com_error( WBEM_E_NOT_FOUND );


    //determine the method being executed
    if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::GETPORT] ) == 0 )  {
      WLBS_PORT_RULE PortRule;

      // The GetPort method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
          throw _com_error( WBEM_E_INVALID_OPERATION );

      //get the output object instance
      GetMethodOutputInstance( MOF_NODESETTING::szName, 
                               a_strMethodName, 
                               &pOutputInstance);

      //get the Port
      hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::PORT_NUMBER ), 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( vValue.vt != VT_I4 )
        throw _com_error ( WBEM_E_INVALID_PARAMETER );

      // Get the "All Vip" port rule for this vip
      pCluster->GetPortRule(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), static_cast<DWORD>( vValue.lVal ), &PortRule );
      
      //create the appropriate port rule class
      switch( PortRule.mode ) {
        case WLBS_SINGLE:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRFAIL], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRFAIL], pCluster, pWbemPortRule, &PortRule );
          break;

        case WLBS_MULTI:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRLOADB], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRLOADB], pCluster, pWbemPortRule, &PortRule );
          break;

        case WLBS_NEVER:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRDIS], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRDIS], pCluster, pWbemPortRule, &PortRule );
          break;
      }

      vValue.vt = VT_UNKNOWN;
      vValue.punkVal = pWbemPortRule;
      pWbemPortRule->AddRef();

      hRes = pOutputInstance->Put( _bstr_t(MOF_PARAM::PORTRULE),
                                   0,
                                   &vValue,
                                   0 );


      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vValue ))
          throw _com_error( WBEM_E_FAILED );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      if( pOutputInstance ) {
        hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

        if( FAILED( hRes ) )
          throw _com_error( hRes );
      }

    } else if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::GETPORT_EX] ) == 0 )  {
        WLBS_PORT_RULE PortRule;
        DWORD          dwPort, dwVip;

        //get the output object instance
        GetMethodOutputInstance( MOF_NODESETTING::szName, 
                                 a_strMethodName, 
                                 &pOutputInstance);

                //get the vip
        hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::VIP ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

        if( vValue.vt != VT_BSTR )
            throw _com_error ( WBEM_E_INVALID_PARAMETER );

        dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );
        
        //get the Port
        hRes = a_pIInParams->Get
                 ( 
                   _bstr_t( MOF_PARAM::PORT_NUMBER ), 
                   0, 
                   &vValue, 
                   NULL, 
                   NULL
                 );

        if( vValue.vt != VT_I4 )
          throw _com_error ( WBEM_E_INVALID_PARAMETER );

        dwPort = vValue.lVal;

        // Get the port rule for this vip & this port
        pCluster->GetPortRule(dwVip, dwPort, &PortRule );

        //create the vip port rule class
        SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRVIP], &pWbemPortRule  );
        CWLBS_PortRule::FillWbemInstance(MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX], pCluster, pWbemPortRule, &PortRule );

        vValue.vt = VT_UNKNOWN;
        vValue.punkVal = pWbemPortRule;
        pWbemPortRule->AddRef();

        hRes = pOutputInstance->Put( _bstr_t(MOF_PARAM::PORTRULE_EX),
                                     0,
                                     &vValue,
                                     0 );


        VariantClear( &vValue );

        if( FAILED( hRes ) )
          throw _com_error( hRes );

        if( pOutputInstance ) {
          hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

          if( FAILED( hRes ) )
            throw _com_error( hRes );
        }

    } else if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::LDSETT] ) == 0 ) {
      DWORD dwReturnValue = pCluster->Commit(g_pWlbsControl);

      vValue.vt   = VT_I4;
      vValue.lVal = static_cast<long>(dwReturnValue);

      //get the output object instance
      GetMethodOutputInstance( MOF_NODESETTING::szName, 
                               a_strMethodName, 
                               &pOutputInstance);

      hRes = pOutputInstance->Put(_bstr_t(L"ReturnValue"), 0, &vValue, 0);


      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vValue ))
          throw _com_error( WBEM_E_FAILED );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      if( pOutputInstance ) {
        hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

        if( FAILED( hRes ) )
          throw _com_error( hRes );
      }

    } else if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::SETDEF] ) == 0 ) {
      pCluster->SetNodeDefaults();
    } else {
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    //send the results back to WinMgMt
    //set the return value

    //release resources
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
        throw _com_error( WBEM_E_FAILED );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    hRes = HResErr.Error();
  }

  catch ( ... ) {
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    throw;
  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetting::FillWbemInstance(CWlbsClusterWrapper* pCluster,
                IWbemClassObject* a_pWbemInstance )
{
  namespace NODE = MOF_NODESETTING;

  ASSERT( a_pWbemInstance );

  CNodeConfiguration NodeConfig;

  pCluster->GetNodeConfig( NodeConfig );

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  //NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NAME] ) ,
      0                                              ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DEDIPADDRESS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DEDIPADDRESS] ),
      0                                                  ,
      &_variant_t(NodeConfig.szDedicatedIPAddress.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DEDNETMASK
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DEDNETMASK] ),
      0                                                ,
      &_variant_t(NodeConfig.szDedicatedNetworkMask.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMRULES
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMRULES] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumberOfRules),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //HOSTPRI
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::HOSTPRI] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwHostPriority),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MSGPERIOD 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MSGPERIOD] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwAliveMsgPeriod),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MSGTOLER 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MSGTOLER] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwAliveMsgTolerance),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //CLUSMODEONSTART 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::CLUSMODEONSTART] ),
      0                                                ,
      &_variant_t(NodeConfig.bClusterModeOnStart),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );


  //NBTENABLE 
//  hRes = a_pWbemInstance->Put
//    (
//      _bstr_t( NODE::pProperties[NODE::NBTENABLE] ),
//      0                                                ,
//      &( _variant_t( NodeConfig.bNBTSupportEnable ) )        ,
//      NULL
//    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //REMOTEUDPPORT 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::REMOTEUDPPORT] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwRemoteControlUDPPort),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MASKSRCMAC 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MASKSRCMAC] ),
      0                                                ,
      &_variant_t(NodeConfig.bMaskSourceMAC),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DESCPERALLOC 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DESCPERALLOC] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwDescriptorsPerAlloc),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MAXDESCALLOCS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MAXDESCALLOCS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwMaxDescriptorAllocs),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMACTIONS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMACTIONS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumActions),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMPACKETS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMPACKETS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumPackets),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMALIVEMSGS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMALIVEMSGS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumAliveMsgs),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );


  //ADAPTERGUID 
  GUID AdapterGuid = pCluster->GetAdapterGuid();
  
  WCHAR szAdapterGuid[128];
  StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );

  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::ADAPTERGUID] ),
      0                                                ,
      &_variant_t(szAdapterGuid),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::UpdateConfiguration
//
// Purpose: This function updates the configuration data for a member node or a
//          potential WLBS cluster node.
//    
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetting::UpdateConfiguration
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pInstance 
  )
{
  namespace NODE = MOF_NODESETTING;

  CNodeConfiguration NewConfiguration;
  CNodeConfiguration OldConfiguration;

  pCluster->GetNodeConfig( OldConfiguration );

  //Dedicated IP
  UpdateConfigProp
    ( 
      NewConfiguration.szDedicatedIPAddress,
      OldConfiguration.szDedicatedIPAddress,
      NODE::pProperties[NODE::DEDIPADDRESS],
      a_pInstance 
    );

  //Dedicate Network Mask
  UpdateConfigProp
    ( 
      NewConfiguration.szDedicatedNetworkMask,
      OldConfiguration.szDedicatedNetworkMask,
      NODE::pProperties[NODE::DEDNETMASK],
      a_pInstance 
    );

  //HostPriority
  UpdateConfigProp
    ( 
      NewConfiguration.dwHostPriority,
      OldConfiguration.dwHostPriority,
      NODE::pProperties[NODE::HOSTPRI],
      a_pInstance 
    );

  //AliveMsgPeriod
  UpdateConfigProp
    ( 
      NewConfiguration.dwAliveMsgPeriod,
      OldConfiguration.dwAliveMsgPeriod,
      NODE::pProperties[NODE::MSGPERIOD],
      a_pInstance 
    );

  //AliveMsgTolerance
  UpdateConfigProp
    ( 
      NewConfiguration.dwAliveMsgTolerance,
      OldConfiguration.dwAliveMsgTolerance,
      NODE::pProperties[NODE::MSGTOLER],
      a_pInstance 
    );

  //ClusterModeOnStart
  UpdateConfigProp
    ( 
      NewConfiguration.bClusterModeOnStart,
      OldConfiguration.bClusterModeOnStart,
      NODE::pProperties[NODE::CLUSMODEONSTART],
      a_pInstance 
    );

  //NBTSupportEnable
//  UpdateConfigProp
//    ( 
//      NewConfiguration.bNBTSupportEnable,
//      OldConfiguration.bNBTSupportEnable,
//      NODE::pProperties[NODE::NBTENABLE],
//      a_pInstance 
//    );

  //RemoteControlUDPPort
  UpdateConfigProp
    ( 
      NewConfiguration.dwRemoteControlUDPPort,
      OldConfiguration.dwRemoteControlUDPPort,
      NODE::pProperties[NODE::REMOTEUDPPORT],
      a_pInstance 
    );

  //MaskSourceMAC
  UpdateConfigProp
    ( 
      NewConfiguration.bMaskSourceMAC,
      OldConfiguration.bMaskSourceMAC,
      NODE::pProperties[NODE::MASKSRCMAC],
      a_pInstance 
    );

  //DescriptorsPerAlloc
  UpdateConfigProp
    ( 
      NewConfiguration.dwDescriptorsPerAlloc,
      OldConfiguration.dwDescriptorsPerAlloc,
      NODE::pProperties[NODE::DESCPERALLOC],
      a_pInstance 
    );

  //MaxDescriptorAllocs
  UpdateConfigProp
    ( 
      NewConfiguration.dwMaxDescriptorAllocs,
      OldConfiguration.dwMaxDescriptorAllocs,
      NODE::pProperties[NODE::MAXDESCALLOCS],
      a_pInstance 
    );

  //NumActions
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumActions,
      OldConfiguration.dwNumActions,
      NODE::pProperties[NODE::NUMACTIONS],
      a_pInstance 
    );

  //NumPackets
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumPackets,
      OldConfiguration.dwNumPackets,
      NODE::pProperties[NODE::NUMPACKETS],
      a_pInstance 
    );

  //NumAliveMsgs
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumAliveMsgs,
      OldConfiguration.dwNumAliveMsgs,
      NODE::pProperties[NODE::NUMALIVEMSGS],
      a_pInstance 
    );

  pCluster->PutNodeConfig( NewConfiguration );
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb_cluster.h ===
/*
 * Filename: NLB_Cluster.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_CLUSTER_H__
#define __NLB_CLUSTER_H__

#include "NLB_Common.h"
#include "NLB_Host.h"
#include "NLB_PortRule.h"

class NLB_Cluster {
public:
    NLB_Cluster() {
        SecondaryIPAddressList.clear();
        HostList.clear();
        PortRuleList.clear();
    }

    ~NLB_Cluster() {}
    
    NLB_Name              Name;
    NLB_Label             Label;
    NLB_ClusterMode       ClusterMode;
    NLB_DomainName        DomainName;
    NLB_NetworkAddress    NetworkAddress;
    NLB_RemoteControl     RemoteControl;

    NLB_IPAddress         PrimaryIPAddress;
    NLB_IPAddress         IGMPMulticastIPAddress;

    vector<NLB_IPAddress> SecondaryIPAddressList;    
    vector<NLB_Host>      HostList;
    vector<NLB_PortRule>  PortRuleList;

private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb_common.cpp ===
/*
 * Filename: NLB_Common.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include "NLB_Common.h"

/*************************************************
 * Class: NLB_Label                              *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Label::NLB_Label () {
    
    Text[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Label::~NLB_Label () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Label::IsValid () { 

    return (Text[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Label::GetText (PWSTR * outText) { 
    
    *outText = SysAllocString(Text); 
    
    return IsValid();
 }

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Label::SetText (PWSTR inText) {
    
    if (lstrlen(inText) > NLB_MAX_LABEL) return false;
    
    lstrcpy(Text, inText);
    
    return true;
}

/*************************************************
 * Class: NLB_Name                        *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Name::NLB_Name () {
    
    Name[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Name::~NLB_Name () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Name::IsValid () { 

    return (Name[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Name::GetName (PWSTR * outName) { 
    
    *outName = SysAllocString(Name); 
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Name::SetName (PWSTR inName) {
    
    if (lstrlen(inName) > NLB_MAX_NAME) return false;
    
    lstrcpy(Name, inName);
    
    return true;
}

/*************************************************
 * Class: NLB_HostID                             *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostID::NLB_HostID () {
    
    ID = -1;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostID::~NLB_HostID () {
 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostID::IsValid () { 

    return (ID != -1); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostID::GetID (int * outID) { 
    
    *outID = ID;
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostID::SetID (int inID) {
    
    if ((inID > NLB_MAX_HOST_ID) || (inID < NLB_MIN_HOST_ID)) return false;
    
    ID = inID;
    
    return true;
}

/*************************************************
 * Class: NLB_HostName                           *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostName::NLB_HostName () {
    
    Name[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostName::~NLB_HostName () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostName::IsValid () { 

    return (Name[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostName::GetName (PWSTR * outName) { 
    
    *outName = SysAllocString(Name); 
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostName::SetName (PWSTR inName) {
    
    if (lstrlen(inName) > NLB_MAX_HOST_NAME) return false;
    
    lstrcpy(Name, inName);
    
    return true;
}

/*************************************************
 * Class: NLB_RemoteControl                      *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_RemoteControl::NLB_RemoteControl () {

    Enabled = Invalid;
    Password[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_RemoteControl::~NLB_RemoteControl () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_RemoteControl::IsValid () { 
    
    return (Enabled != Invalid); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_RemoteControl::GetEnabled (NLB_RemoteControlEnabled * outEnabled) { 

    *outEnabled = Enabled;

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_RemoteControl::GetPassword (PWSTR * outPassword) { 

    *outPassword = SysAllocString(Password); 

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_RemoteControl::SetEnabled (NLB_RemoteControlEnabled inEnabled) {
        
    switch(inEnabled) {
    case No:            
        Enabled = No;
        break;
    case Yes:
        Enabled = Yes;
        break;
    default:
        return false;
    }
        
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_RemoteControl::SetPassword (PWSTR inPassword) {
        
    if (lstrlen(inPassword) > NLB_MAX_PASSWORD) return false;

    lstrcpy(Password, inPassword);
        
    return true;
}

/*************************************************
 * Class: NLB_DomainName                         *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_DomainName::NLB_DomainName () {
    
    Domain[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_DomainName::~NLB_DomainName () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_DomainName::IsValid () { 

    return (Domain[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_DomainName::GetDomain (PWSTR * outDomain) { 
    
    *outDomain = SysAllocString(Domain); 
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_DomainName::SetDomain (PWSTR inDomain) {
    
    if (lstrlen(inDomain) > NLB_MAX_DOMAIN_NAME) return false;
    
    lstrcpy(Domain, inDomain);
    
    return true;
}

/*************************************************
 * Class: NLB_NetworkAddress                     *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_NetworkAddress::NLB_NetworkAddress () {
    
    Address[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_NetworkAddress::~NLB_NetworkAddress () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_NetworkAddress::IsValid () { 

    return (Address[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_NetworkAddress::GetAddress (PWSTR * outAddress) { 
    
    *outAddress = SysAllocString(Address); 
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_NetworkAddress::SetAddress (PWSTR inAddress) {
    
    if (lstrlen(inAddress) > NLB_MAX_NETWORK_ADDRESS) return false;
    
    lstrcpy(Address, inAddress);
    
    return true;
}

/*************************************************
 * Class: NLB_ClusterMode                        *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterMode::NLB_ClusterMode () { 

    Mode = Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterMode::~NLB_ClusterMode () { 

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterMode::IsValid () { 

    return (Mode != Invalid); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterMode::GetMode (NLB_ClusterModeType * outMode) { 
        
    *outMode = Mode;

    return IsValid(); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterMode::SetMode (NLB_ClusterModeType inMode) {

    switch (inMode) {
    case Unicast:
        Mode = Unicast;
        break;
    case Multicast:
        Mode = Multicast;
        break;
    case IGMP:
        Mode = IGMP;
        break;
    default:
        return false;
    }

    return true;
}

/*************************************************
 * Class: NLB_HostState                          *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostState::NLB_HostState () { 

    State = Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostState::~NLB_HostState () { 

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostState::IsValid () { 

    return (State != Invalid); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostState::GetState (NLB_HostStateType * outState) { 
        
    *outState = State;

    return IsValid(); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostState::SetState (NLB_HostStateType inState) {

    switch (inState) {
    case Started:
        State = Started;
        break;
    case Stopped:
        State = Stopped;
        break;
    case Suspended:
        State = Suspended;
        break;
    default:
        return false;
    }

    return true;
}

/*************************************************
 * Class: NLB_Adapter                            *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Adapter::NLB_Adapter () {

    IdentifiedBy = Invalid;
    Name[0] = L'\0';
    GUID[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Adapter::~NLB_Adapter () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::IsValid () { 
    
    return (IdentifiedBy != Invalid); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::GetIdentifiedBy (NLB_AdapterIdentifier * outIdentifiedBy) { 

    *outIdentifiedBy = IdentifiedBy;

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::GetAdapter (PWSTR * outAdapter) { 

    switch(IdentifiedBy) {
    case ByGUID:
        *outAdapter = SysAllocString(GUID); 
        break;
    case ByName:
        *outAdapter = SysAllocString(Name); 
        break;
    default:
        *outAdapter = NULL;
        break;
    }

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::SetIdentifiedBy (NLB_AdapterIdentifier inIdentifiedBy) {
        
    switch(inIdentifiedBy) {
    case ByGUID:            
        IdentifiedBy = ByGUID;
        break;
    case ByName:
        IdentifiedBy = ByName;
        break;
    default:
        return false;
    }
        
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::SetAdapter (PWSTR inAdapter) {
        
    switch(IdentifiedBy) {
    case ByGUID:            
        if (lstrlen(inAdapter) > NLB_MAX_ADAPTER_GUID) return false;
        lstrcpy(GUID, inAdapter);
        break;
    case ByName:
        if (lstrlen(inAdapter) > NLB_MAX_ADAPTER_NAME) return false;
        lstrcpy(Name, inAdapter);
        break;
    default:
        return false;
    }
        
    return true;
}

/*************************************************
 * Class: NLB_IPAddress                          *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_IPAddress::NLB_IPAddress () {
    Type = Invalid;
    lstrcpy(IPAddress, CVY_DEF_CL_IP_ADDR);
    lstrcpy(SubnetMask, CVY_DEF_CL_NET_MASK);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_IPAddress::~NLB_IPAddress () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::IsValid () { 

    return (Type != Invalid); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::GetIPAddressType (NLB_IPAddressType * outType) { 
    
    *outType = Type;

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::GetIPAddress (PWSTR * outIPAddress) { 

    *outIPAddress = SysAllocString(IPAddress); 
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::GetSubnetMask (PWSTR * outSubnetMask) { 

    *outSubnetMask = SysAllocString(SubnetMask); 
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::SetIPAddressType (NLB_IPAddressType inType) {

    switch (inType) {
    case Primary:
        Type = Primary;
        break;
    case Secondary:
        Type = Secondary;
        break;
    case Virtual:
        Type = Virtual;
        break;
    case IGMP:
        Type = IGMP;
        break;
    case Dedicated:
        Type = Dedicated;
        break;
    case Connection:
        Type = Connection;
        break;
    default:
        return false;
    }
        
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::SetIPAddress (PWSTR inIPAddress) {

    if (lstrlen(inIPAddress) > NLB_MAX_IPADDRESS) return false;

    lstrcpy(IPAddress, inIPAddress);

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::SetSubnetMask (PWSTR inSubnetMask) {

    if (lstrlen(inSubnetMask) > NLB_MAX_SUBNETMASK) return false;

    lstrcpy(SubnetMask, inSubnetMask);

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: Returning a pointer to a private member is voodoo, but do it anway.
 */
NLB_Adapter * NLB_IPAddress::GetAdapter () { 

    return &Adapter; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb_xmlerror.h ===
/*
 * Filename: NLB_XMLError.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_XMLERROR_H__
#define __NLB_XMLERROR_H__

typedef struct _NLB_XMLError {
    LONG code;
    LONG line;
    LONG character;
    WCHAR wszURL[MAX_PATH];
    WCHAR wszReason[MAX_PATH];
} NLB_XMLError;

#define FACILITY_NLB                  49

#define NLB_XML_E_IPADDRESS_ADAPTER   1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb_portrule.h ===
/*
 * Filename: NLB_PortRule.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_PORTRULE_H__
#define __NLB_PORTRULE_H__

#include "NLB_Common.h"
#include "NLB_Cluster.h"
#include "NLB_Host.h"

class NLB_PortRule {
public:

private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb_xmlparser.cpp ===
/*
 * Filename: NLB_XMLParser.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include "stdafx.h"

#include "NLB_XMLParser.h"

#define NLB_XML_ELEMENT_CLUSTER        L"Cluster"
#define NLB_XML_ELEMENT_PROPERTIES     L"Properties"
#define NLB_XML_ELEMENT_HOSTS          L"Hosts"
#define NLB_XML_ELEMENT_HOST           L"Host"
#define NLB_XML_ELEMENT_PORTRULES      L"PortRules"
#define NLB_XML_ELEMENT_IPADDRESS      L"IPAddress"
#define NLB_XML_ELEMENT_ADDRESS        L"Address"
#define NLB_XML_ELEMENT_SUBNETMASK     L"SubnetMask"
#define NLB_XML_ELEMENT_ADAPTER        L"Adapter"
#define NLB_XML_ELEMENT_GUID           L"GUID"
#define NLB_XML_ELEMENT_NAME           L"Name"
#define NLB_XML_ELEMENT_DOMAINNAME     L"DomainName"
#define NLB_XML_ELEMENT_HOSTNAME       L"HostName"
#define NLB_XML_ELEMENT_NETWORKADDRESS L"NetworkAddress"
#define NLB_XML_ELEMENT_CLUSTER_MODE   L"Mode"
#define NLB_XML_ELEMENT_REMOTE_CONTROL L"RemoteControl"
#define NLB_XML_ELEMENT_PASSWORD       L"Password"

#define NLB_XML_ATTRIBUTE_NAME         L"Name"
#define NLB_XML_ATTRIBUTE_TYPE         L"Type"
#define NLB_XML_ATTRIBUTE_TEXT         L"Text"
#define NLB_XML_ATTRIBUTE_ENABLED      L"Enabled"
#define NLB_XML_ATTRIBUTE_HOSTID       L"HostID"
#define NLB_XML_ATTRIBUTE_STATE        L"State"

#define NLB_XML_VALUE_PRIMARY          L"Primary"
#define NLB_XML_VALUE_SECONDARY        L"Secondary"
#define NLB_XML_VALUE_VIRTUAL          L"Virtual"
#define NLB_XML_VALUE_DEDICATED        L"Dedicated"
#define NLB_XML_VALUE_CONNECTION       L"Connection"
#define NLB_XML_VALUE_IGMP             L"IGMP"
#define NLB_XML_VALUE_UNICAST          L"Unicast"
#define NLB_XML_VALUE_MULTICAST        L"Multicast"
#define NLB_XML_VALUE_YES              L"Yes"
#define NLB_XML_VALUE_NO               L"No"
#define NLB_XML_VALUE_STARTED          L"Started"
#define NLB_XML_VALUE_STOPPED          L"Stopped"
#define NLB_XML_VALUE_SUSPENDED        L"Suspended"

#define NLB_XML_PARSE_ERROR_IPADDRESS_ADAPTER_CODE   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_XML_E_IPADDRESS_ADAPTER)
#define NLB_XML_PARSE_ERROR_IPADDRESS_ADAPTER_REASON L"Only \"Dedicated\" and \"Connection\" IP address types may specify <Adapter> child elements."

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_XMLParser::NLB_XMLParser () {
	
    pDoc = NULL;
    pSchema = NULL;

    bShowErrorPopups = true;

    ClusterList.clear();

    ZeroMemory(&ParseError, sizeof(NLB_XMLError));
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_XMLParser::NLB_XMLParser (bool bSilent) {
	
    pDoc = NULL;
    pSchema = NULL;

    bShowErrorPopups = !bSilent;

    ClusterList.clear();

    ZeroMemory(&ParseError, sizeof(NLB_XMLError));
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_XMLParser::~NLB_XMLParser () {

}

/*
 * Method: 
 * Description: 
 * Author: 
 */
void NLB_XMLParser::GetParseError (NLB_XMLError * pError) {

    *pError = ParseError;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
void NLB_XMLParser::SetParseError (HRESULT hrCode, PWSTR pwszReason) {

    ParseError.code = hrCode;
    
    lstrcpy(ParseError.wszReason, pwszReason);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::LoadDocument (BSTR pBURL) {
    VARIANT                           vURL;
    VARIANT_BOOL                      vb;
    VARIANT                           varValue;
    HRESULT                           hr = S_OK;
    IErrorInfo * perror;
    BSTR foo;

    CHECKHR(pDoc->put_async(VARIANT_FALSE));

    VariantInit(&vURL);

    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = pBURL;

    CHECKHR(CoCreateInstance(MSXML2::CLSID_XMLSchemaCache, NULL, CLSCTX_SERVER, 
                             MSXML2::IID_IXMLDOMSchemaCollection, (LPVOID*)(&pSchema)));
    
    if (pSchema) {
        pSchema->add(L"x-schema:MicrosoftNLB", _variant_t(L"MicrosoftNLB.xml"));
        
        varValue.vt = VT_DISPATCH;
        varValue.pdispVal = pSchema;
        
        CHECKHR(pDoc->putref_schemas(varValue));
        
        CHECKHR(pDoc->load(vURL, &vb));
        
        CHECKHR(CheckDocumentLoad());
    }

 CleanUp:
    SAFERELEASE(pSchema);
   
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::CheckDocumentLoad () {
    MSXML2::IXMLDOMParseError * pXMLError = NULL;
    HRESULT                     hr = S_OK;

    CHECKHR(pDoc->get_parseError(&pXMLError));

    CHECKHR(pXMLError->get_errorCode(&ParseError.code));

    if (ParseError.code != 0) {
        BSTR pBURL;
        BSTR pBReason;

        CHECKHR(pXMLError->get_line(&ParseError.line));

        CHECKHR(pXMLError->get_linepos(&ParseError.character));
		
        CHECKHR(pXMLError->get_URL(&pBURL));
        lstrcpy(ParseError.wszURL, pBURL);

        CHECKHR(pXMLError->get_reason(&pBReason));
        lstrcpy(ParseError.wszReason, pBReason);

        SysFreeString(pBURL);
        SysFreeString(pBReason);
    }

    if (bShowErrorPopups) {
        WCHAR reason[2048];
        WCHAR details[2048];

        if (ParseError.code != 0) {
            wsprintf(reason, L"Error 0x%08x:\n\n%ls\n", ParseError.code, ParseError.wszReason);

            if (ParseError.line > 0) {
                wsprintf(details, L"Error on line %d, position %d in \"%ls\".\n", 
                         ParseError.line, ParseError.character, ParseError.wszURL);

                lstrcat(reason, details);
            }
		
            ::MessageBox(NULL, reason, L"NLB XML Document Error", 
                         MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        } else {
            wsprintf(reason, L"XML Document successfully loaded.");

            ::MessageBox(NULL, reason, L"NLB XML Document Information", 
                         MB_APPLMODAL | MB_ICONINFORMATION | MB_OK);
        }
    }

 CleanUp:
    
    SAFERELEASE(pXMLError);
    
    return ParseError.code;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
BSTR NLB_XMLParser::AsciiToBSTR (const char * pszName) {
    WCHAR wszString[MAX_PATH];

    ::MultiByteToWideChar(CP_ACP, 0, pszName, -1, wszString, MAX_PATH);
    
    return SysAllocString(wszString);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
CHAR * NLB_XMLParser::BSTRToAscii (const WCHAR * pwszName) {
    CHAR szString[MAX_PATH];

    ::WideCharToMultiByte(CP_ACP, 0, pwszName, -1, szString, MAX_PATH, NULL, NULL);
    
    return _strdup(szString);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_IPAddress::NLB_IPAddressType NLB_XMLParser::StringToIPAddressType (const WCHAR * pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_PRIMARY)) {
        return NLB_IPAddress::Primary;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_SECONDARY)) {
        return NLB_IPAddress::Secondary;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_VIRTUAL)) {
        return NLB_IPAddress::Virtual;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_DEDICATED)) {
        return NLB_IPAddress::Dedicated;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_CONNECTION)) {
        return NLB_IPAddress::Connection;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_IGMP)) {
        return NLB_IPAddress::IGMP;
    }
	
    return NLB_IPAddress::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_ClusterMode::NLB_ClusterModeType NLB_XMLParser::StringToClusterMode (const WCHAR * pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_UNICAST)) {
        return NLB_ClusterMode::Unicast;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_MULTICAST)) {
        return NLB_ClusterMode::Multicast;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_IGMP)) {
        return NLB_ClusterMode::IGMP;
    }
	
    return NLB_ClusterMode::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_HostState::NLB_HostStateType NLB_XMLParser::StringToHostState (const WCHAR * pwszState) {

    if (!lstrcmpi(pwszState, NLB_XML_VALUE_STARTED)) {
        return NLB_HostState::Started;
    } else if (!lstrcmpi(pwszState, NLB_XML_VALUE_STOPPED)) {
        return NLB_HostState::Stopped;
    } else if (!lstrcmpi(pwszState, NLB_XML_VALUE_SUSPENDED)) {
        return NLB_HostState::Suspended;
    }
	
    return NLB_HostState::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_RemoteControl::NLB_RemoteControlEnabled NLB_XMLParser::StringToRemoteControlEnabled (const WCHAR * pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_YES)) {
        return NLB_RemoteControl::Yes;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_NO)) {
        return NLB_RemoteControl::No;
    }
	
    return NLB_RemoteControl::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::PrintTree(MSXML2::IXMLDOMNode * pNode, int level) {
    MSXML2::IXMLDOMNamedNodeMap * pAttrs = NULL;
    MSXML2::IXMLDOMNode *         pChild = NULL;
    MSXML2::IXMLDOMNode *         pNext = NULL;
    BSTR                          BNodeName = NULL;
    VARIANT                       value;

    pNode->get_nodeName(&BNodeName);
    
    for (int i = 0; i < level; i++)
        printf(" ");
    
    printf("%ls", BNodeName);
    
    if (!lstrcmpi(BNodeName, L"#text")) {
        pNode->get_nodeValue(&value);

        if (value.vt == VT_BSTR) 
            printf(" %ls", V_BSTR(&value));

        VariantClear(&value);
    }

    SysFreeString(BNodeName);

    if (SUCCEEDED(pNode->get_attributes(&pAttrs)) && (pAttrs != NULL)) {
        pAttrs->nextNode(&pChild);

        while (pChild) {
            BSTR name;
            VARIANT value;

            pChild->get_nodeName(&name);
            
            printf(" %ls='", name);
            
            SysFreeString(name);

            pChild->get_nodeValue(&value);

            if (value.vt == VT_BSTR)
                printf("%ls", V_BSTR(&value));
 
            printf("'");
 
            VariantClear(&value);
            
            pChild->Release();
            
            pAttrs->nextNode(&pChild);
        }

        pAttrs->Release();
    }

    printf("\n");

    pNode->get_firstChild(&pChild);
    
    while (pChild) {
        PrintTree(pChild, level + 1);
        
        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
    }

    return S_OK;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::ParseClusterPortRules (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    HRESULT hr = S_OK;

//CleanUp:
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::ParseHost (MSXML2::IXMLDOMNode * pNode, NLB_Host * pHost) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    MSXML2::IXMLDOMNode *    pChild = NULL;
    MSXML2::IXMLDOMNode *    pNext = NULL;
    BSTR                     BNodeName = NULL;
    BSTR                     BAttribute = NULL;
    VARIANT                  value;
    HRESULT                  hr = S_OK;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement,(void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(NLB_XML_ATTRIBUTE_NAME)));

    CHECKHR(pElement->getAttribute(BAttribute, &value));
	
    if (hr == S_OK)
        pHost->Name.SetName(V_BSTR(&value));
    else if (hr == S_FALSE)
        hr = S_OK;

    VariantClear(&value);

    SAFEFREESTRING(BAttribute);

    CHECKALLOC((BAttribute = SysAllocString(NLB_XML_ATTRIBUTE_TEXT)));

    CHECKHR(pElement->getAttribute(BAttribute, &value));
	
    if (hr == S_OK)
        pHost->Label.SetText(V_BSTR(&value));
    else if (hr == S_FALSE)
        hr = S_OK;

    VariantClear(&value);

    SAFEFREESTRING(BAttribute);

    CHECKALLOC((BAttribute = SysAllocString(NLB_XML_ATTRIBUTE_HOSTID)));

    CHECKHR(pElement->getAttribute(BAttribute, &value));
	
    if (hr == S_OK)
        pHost->HostID.SetID(_wtoi(V_BSTR(&value)));
    else if (hr == S_FALSE)
        hr = S_OK;

    VariantClear(&value);

    SAFEFREESTRING(BAttribute);

    CHECKALLOC((BAttribute = SysAllocString(NLB_XML_ATTRIBUTE_STATE)));

    CHECKHR(pElement->getAttribute(BAttribute, &value));
	
    if (hr == S_OK)
        pHost->HostState.SetState(StringToHostState(V_BSTR(&value)));
    else if (hr == S_FALSE)
        hr = S_OK;

    VariantClear(&value);

    SAFEFREESTRING(BAttribute);

    SAFERELEASE(pElement);

    pNode->get_firstChild(&pChild);

    while (pChild) {
        pChild->get_nodeName(&BNodeName);
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_HOSTNAME)) {
          pChild->get_firstChild(&pNext);

            pNext->get_nodeValue(&value);

            if (value.vt != VT_BSTR) {
                hr = E_FAIL;
                goto CleanUp;
            }
			
            pHost->HostName.SetName(V_BSTR(&value));

            VariantClear(&value);

            SAFERELEASE(pNext);
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_IPADDRESS)) {
            NLB_IPAddress::NLB_IPAddressType Type;
            NLB_IPAddress                    IPAddress;

            CHECKHR(ParseIPAddress(pChild, &IPAddress));
            
            IPAddress.GetIPAddressType(&Type);

            switch (Type) {
            case NLB_IPAddress::Connection:
                CopyMemory(&pHost->ConnectionIPAddress, &IPAddress, sizeof(NLB_IPAddress));
                break;
            case NLB_IPAddress::Dedicated:
                CopyMemory(&pHost->DedicatedIPAddress, &IPAddress, sizeof(NLB_IPAddress));
                break;
            case NLB_IPAddress::IGMP:
            case NLB_IPAddress::Virtual:
            case NLB_IPAddress::Primary:
            case NLB_IPAddress::Secondary:
            default:
                hr = E_FAIL;
                goto CleanUp;
                break;
            }
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_ADAPTER)) {
            CHECKHR(ParseAdapter(pChild, &pHost->Adapter));
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);
    SAFEFREESTRING(BAttribute);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::ParseClusterHosts (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    BSTR                  BNodeName = NULL;
    VARIANT               value;
    HRESULT               hr = S_OK;

    pNode->get_firstChild(&pChild);

    while (pChild) {

        pChild->get_nodeName(&BNodeName);
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_HOST)) {
            NLB_Host Host;

            CHECKHR(ParseHost(pChild, &Host));

            pCluster->HostList.push_back(Host);
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::ParseRemoteControl (MSXML2::IXMLDOMNode * pNode, NLB_RemoteControl * pControl) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    MSXML2::IXMLDOMNode *    pChild = NULL;
    MSXML2::IXMLDOMNode *    pNext = NULL;
    BSTR                     BAttribute = NULL;
    BSTR                     BNodeName = NULL;
    HRESULT                  hr = S_OK;
    VARIANT                  value;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement,(void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(NLB_XML_ATTRIBUTE_ENABLED)));

    CHECKHR(pElement->getAttribute(BAttribute, &value));
	
    pControl->SetEnabled(StringToRemoteControlEnabled(V_BSTR(&value)));

    VariantClear(&value);

    SAFERELEASE(pElement);

    pNode->get_firstChild(&pChild);

    while (pChild) {
        pChild->get_nodeName(&BNodeName);
				
        CHECKALLOC(BNodeName);

        if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_PASSWORD)) {
            NLB_RemoteControl::NLB_RemoteControlEnabled Enabled;

            pControl->GetEnabled(&Enabled);

            if (Enabled == NLB_RemoteControl::Yes) {
                pChild->get_firstChild(&pNext);
                
                pNext->get_nodeValue(&value);
                
                if (value.vt != VT_BSTR) {
                    hr = E_FAIL;
                    goto CleanUp;
                }
                
                pControl->SetPassword(V_BSTR(&value));
                
                VariantClear(&value);
                
                SAFERELEASE(pNext);
            } else {
                hr = E_FAIL;
                goto CleanUp;
            }
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pElement);
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);
	
    SAFEFREESTRING(BNodeName);
    SAFEFREESTRING(BAttribute);
	
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::ParseAdapter (MSXML2::IXMLDOMNode * pNode, NLB_Adapter * pAdapter) {
    MSXML2::IXMLDOMNode *    pChild = NULL;
    MSXML2::IXMLDOMNode *    pNext = NULL;
    BSTR                     BNodeName = NULL;
    HRESULT                  hr = S_OK;
    VARIANT                  value;

    pNode->get_firstChild(&pChild);

    while (pChild) {
        pChild->get_nodeName(&BNodeName);
				
        CHECKALLOC(BNodeName);

        if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_GUID)) {
            pChild->get_firstChild(&pNext);

            pNext->get_nodeValue(&value);

            if (value.vt != VT_BSTR) {
                hr = E_FAIL;
                goto CleanUp;
            }

            pAdapter->SetIdentifiedBy(NLB_Adapter::ByGUID);
            pAdapter->SetAdapter(V_BSTR(&value));

            VariantClear(&value);

            SAFERELEASE(pNext);
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_NAME)) {
            pChild->get_firstChild(&pNext);

            pNext->get_nodeValue(&value);

            if (value.vt != VT_BSTR) {
                hr = E_FAIL;
                goto CleanUp;
            }
			
            pAdapter->SetIdentifiedBy(NLB_Adapter::ByName);
            pAdapter->SetAdapter(V_BSTR(&value));

            VariantClear(&value);

            SAFERELEASE(pNext);
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);
	
    SAFEFREESTRING(BNodeName);
	
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::ParseIPAddress (MSXML2::IXMLDOMNode * pNode, NLB_IPAddress * pIPAddress) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    MSXML2::IXMLDOMNode *    pChild = NULL;
    MSXML2::IXMLDOMNode *    pNext = NULL;
    BSTR                     BAttribute = NULL;
    BSTR                     BNodeName = NULL;
    HRESULT                  hr = S_OK;
    VARIANT                  value;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement,(void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(NLB_XML_ATTRIBUTE_TYPE)));

    CHECKHR(pElement->getAttribute(BAttribute, &value));
	
    pIPAddress->SetIPAddressType(StringToIPAddressType(V_BSTR(&value)));

    VariantClear(&value);

    SAFERELEASE(pElement);

    pNode->get_firstChild(&pChild);

    while (pChild) {
        pChild->get_nodeName(&BNodeName);
				
        CHECKALLOC(BNodeName);

        if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_ADDRESS)) {
            pChild->get_firstChild(&pNext);

            pNext->get_nodeValue(&value);

            if (value.vt != VT_BSTR) {
                hr = E_FAIL;
                goto CleanUp;
            }

            pIPAddress->SetIPAddress(V_BSTR(&value));

            VariantClear(&value);

            SAFERELEASE(pNext);
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_SUBNETMASK)) {
            pChild->get_firstChild(&pNext);

            pNext->get_nodeValue(&value);

            if (value.vt != VT_BSTR) {
                hr = E_FAIL;
                goto CleanUp;
            }
			
            pIPAddress->SetSubnetMask(V_BSTR(&value));

            VariantClear(&value);

            SAFERELEASE(pNext);
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_ADAPTER)) {
            NLB_IPAddress::NLB_IPAddressType Type;

            pIPAddress->GetIPAddressType(&Type);

            switch (Type) {
            case NLB_IPAddress::Connection:
            case NLB_IPAddress::Dedicated:
                CHECKHR(ParseAdapter(pChild, pIPAddress->GetAdapter()));
                break;
            case NLB_IPAddress::Primary:
            case NLB_IPAddress::Secondary:
            case NLB_IPAddress::IGMP:
            case NLB_IPAddress::Virtual:
//                SetParseError(NLB_XML_PARSE_ERROR_IPADDRESS_ADAPTER_CODE, NLB_XML_PARSE_ERROR_IPADDRESS_ADAPTER_REASON);
            default:
                hr = E_FAIL;
                goto CleanUp;
                break;
            }
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pElement);
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);
	
    SAFEFREESTRING(BNodeName);
    SAFEFREESTRING(BAttribute);
	
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::ParseClusterProperties (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;
    VARIANT               value;

    pNode->get_firstChild(&pChild);

    while (pChild) {
        pChild->get_nodeName(&BNodeName);
				
        CHECKALLOC(BNodeName);

        if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_IPADDRESS)) {
            NLB_IPAddress::NLB_IPAddressType Type;
            NLB_IPAddress                    IPAddress;

            CHECKHR(ParseIPAddress(pChild, &IPAddress));
            
            IPAddress.GetIPAddressType(&Type);

            switch (Type) {
            case NLB_IPAddress::Primary:
                CopyMemory(&pCluster->PrimaryIPAddress, &IPAddress, sizeof(NLB_IPAddress));
                break;
            case NLB_IPAddress::Secondary:
                pCluster->SecondaryIPAddressList.push_back(IPAddress);
                break;
            case NLB_IPAddress::IGMP:
                CopyMemory(&pCluster->IGMPMulticastIPAddress, &IPAddress, sizeof(NLB_IPAddress));
                break;
            case NLB_IPAddress::Virtual:
            case NLB_IPAddress::Connection:
            case NLB_IPAddress::Dedicated:
            default:
                hr = E_FAIL;
                goto CleanUp;
                break;
            }
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_DOMAINNAME)) {
            pChild->get_firstChild(&pNext);

            pNext->get_nodeValue(&value);

            if (value.vt != VT_BSTR) {
                hr = E_FAIL;
                goto CleanUp;
            }

            pCluster->DomainName.SetDomain(V_BSTR(&value));

            VariantClear(&value);

            SAFERELEASE(pNext);
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_NETWORKADDRESS)) {
            pChild->get_firstChild(&pNext);

            pNext->get_nodeValue(&value);

            if (value.vt != VT_BSTR) {
                hr = E_FAIL;
                goto CleanUp;
            }

            pCluster->NetworkAddress.SetAddress(V_BSTR(&value));

            VariantClear(&value);

            SAFERELEASE(pNext);
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_CLUSTER_MODE)) {
            pChild->get_firstChild(&pNext);

            pNext->get_nodeValue(&value);

            if (value.vt != VT_BSTR) {
                hr = E_FAIL;
                goto CleanUp;
            }

            pCluster->ClusterMode.SetMode(StringToClusterMode(V_BSTR(&value)));

            VariantClear(&value);

            SAFERELEASE(pNext);
        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_REMOTE_CONTROL)) {
            CHECKHR(ParseRemoteControl(pChild, &pCluster->RemoteControl));
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::ParseCluster (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    MSXML2::IXMLDOMNode *    pChild = NULL;
    MSXML2::IXMLDOMNode *    pNext = NULL;
    BSTR                     BNodeName = NULL;
    BSTR                     BAttribute = NULL;
    VARIANT                  value;
    HRESULT                  hr = S_OK;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement,(void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(NLB_XML_ATTRIBUTE_NAME)));

    CHECKHR(pElement->getAttribute(BAttribute, &value));
	
    if (hr == S_OK)
        pCluster->Name.SetName(V_BSTR(&value));
    else if (hr == S_FALSE)
        hr = S_OK;

    VariantClear(&value);

    SAFEFREESTRING(BAttribute);

    CHECKALLOC((BAttribute = SysAllocString(NLB_XML_ATTRIBUTE_TEXT)));

    CHECKHR(pElement->getAttribute(BAttribute, &value));
	
    if (hr == S_OK)
        pCluster->Label.SetText(V_BSTR(&value));
    else if (hr == S_FALSE)
        hr = S_OK;

    VariantClear(&value);

    SAFEFREESTRING(BAttribute);

    SAFERELEASE(pElement);

    pNode->get_firstChild(&pChild);

    while (pChild) {
        pChild->get_nodeName(&BNodeName);
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_PROPERTIES)) {
            CHECKHR(ParseClusterProperties(pChild, pCluster));
        } else if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_HOSTS)) {
            CHECKHR(ParseClusterHosts(pChild, pCluster));
        } else if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_PORTRULES)) {
            CHECKHR(ParseClusterPortRules(pChild, pCluster));
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);
    SAFEFREESTRING(BAttribute);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::Parse (WCHAR * wszFileName, vector<NLB_Cluster> * pClusters) {
    MSXML2::IXMLDOMNodeList * pList = NULL;
    MSXML2::IXMLDOMNode     * pNode = NULL;
    BSTR                      BURL = NULL;
    BSTR                      BTag = NULL;
    HRESULT                   hr = S_OK;
    NLB_Cluster               cluster;
    LONG                      length;    
    LONG                      index;

    CoInitialize(NULL);

    CHECKHR(CoCreateInstance(MSXML2::CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                             MSXML2::IID_IXMLDOMDocument2, (void**)&pDoc));

    CHECKALLOC(pDoc);

    CHECKALLOC((BURL = SysAllocString(wszFileName)));

    CHECKALLOC((BTag = SysAllocString(NLB_XML_ELEMENT_CLUSTER)));

    CHECKHR(LoadDocument(BURL));

    CHECKHR(pDoc->getElementsByTagName(BTag, &pList));

    CHECKALLOC(pList);

    CHECKHR(pList->get_length(&length));

    CHECKHR(pList->reset());

    for (index = 0; index < length; index++) {
        NLB_Cluster cluster;

        CHECKHR(pList->get_item(index, &pNode));
	
        CHECKALLOC(pNode);

        CHECKHR(ParseCluster(pNode, &cluster));

        ClusterList.push_back(cluster);

        SAFERELEASE(pNode);
    }

    *pClusters = ClusterList;
    
 CleanUp:
    SAFERELEASE(pList);
    SAFERELEASE(pNode);
    SAFERELEASE(pDoc);

    SAFEFREESTRING(BURL);
    SAFEFREESTRING(BTag);
    
    CoUninitialize();

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::Parse (WCHAR * wszFileName) {
    BSTR    BURL = NULL;
    HRESULT hr = S_OK;
        
    CoInitialize(NULL);

    CHECKHR(CoCreateInstance(MSXML2::CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                             MSXML2::IID_IXMLDOMDocument2, (void**)&pDoc));
	
    CHECKALLOC(pDoc);

    CHECKALLOC((BURL = SysAllocString(wszFileName)));

    CHECKHR(LoadDocument(BURL));

 CleanUp:
    SAFERELEASE(pDoc);

    SAFEFREESTRING(BURL);
    
    CoUninitialize();

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLParser::Parse (WCHAR * wszFileName, bool bPrintTree) {
    MSXML2::IXMLDOMNode * pNode = NULL;
    BSTR                  BURL = NULL;
    HRESULT               hr = S_OK;
        
    CoInitialize(NULL);

    CHECKHR(CoCreateInstance(MSXML2::CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                             MSXML2::IID_IXMLDOMDocument2, (void**)&pDoc));

    CHECKALLOC(pDoc);

    CHECKALLOC((BURL = SysAllocString(wszFileName)));

    CHECKHR(LoadDocument(BURL));

    if (bPrintTree) {
        CHECKHR(pDoc->QueryInterface(MSXML2::IID_IXMLDOMNode,(void**)&pNode));

        CHECKALLOC(pNode);

        CHECKHR(PrintTree(pNode, 0));
    }

 CleanUp:
    SAFERELEASE(pDoc);
    SAFERELEASE(pNode);

    SAFEFREESTRING(BURL);
    
    CoUninitialize();

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
void NLB_XMLParser::Print () {

    Print(ClusterList);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
void NLB_XMLParser::Print (vector<NLB_Cluster> Clusters) {
    vector<NLB_Cluster>::iterator icluster;

    for (icluster = Clusters.begin(); icluster != Clusters.end(); icluster++) {
        vector<NLB_IPAddress>::iterator iaddress;
        vector<NLB_Host>::iterator ihost;
        NLB_Cluster * cluster = icluster;

        NLB_RemoteControl::NLB_RemoteControlEnabled enabled;
        NLB_ClusterMode::NLB_ClusterModeType mode;
        NLB_Adapter::NLB_AdapterIdentifier by;
        NLB_Adapter * adapter;
        PWSTR buffer;
        
        if (cluster->Name.GetName(&buffer))
            printf("\nCluster name: %ls ", buffer);
        
        SAFEFREESTRING(buffer);

        if (cluster->Label.GetText(&buffer))
            printf("(%ls)", buffer);
        
        printf("\n");

        SAFEFREESTRING(buffer);

        if (cluster->PrimaryIPAddress.GetIPAddress(&buffer))
            printf("    Primary Cluster IP Address:   %ls\n", buffer);

        SAFEFREESTRING(buffer);

        if (cluster->PrimaryIPAddress.GetSubnetMask(&buffer))
            printf("                   Subnet Mask:   %ls\n", buffer);

        SAFEFREESTRING(buffer);

        if (cluster->ClusterMode.GetMode(&mode)) {
            switch (mode) {
            case NLB_ClusterMode::Unicast:
                printf("                  Cluster Mode:   Unicast\n");
                break;
            case NLB_ClusterMode::Multicast:
                printf("                  Cluster Mode:   Multicast\n");
                break;
            case NLB_ClusterMode::IGMP:
                printf("                  Cluster Mode:   IGMP\n");
                break;
            default:
                break;
            }
        }
        
        if (cluster->IGMPMulticastIPAddress.GetIPAddress(&buffer))
            printf("     IGMP Multicast IP Address:   %ls\n", buffer);

        SAFEFREESTRING(buffer);

        if (cluster->DomainName.GetDomain(&buffer))
            printf("                   Domain Name:   %ls\n", buffer);
        
        SAFEFREESTRING(buffer);

        if (cluster->NetworkAddress.GetAddress(&buffer))
            printf("               Network Address:   %ls\n", buffer);
        
        SAFEFREESTRING(buffer);

        if (cluster->RemoteControl.GetEnabled(&enabled)) {
            switch (enabled) {
            case NLB_RemoteControl::Yes:
                printf("                Remote Control:   Enabled ");
                
                if (cluster->RemoteControl.GetPassword(&buffer))
                    printf("(Password=%ls)", buffer);

                printf("\n");

                SAFEFREESTRING(buffer);

                break;
            case NLB_RemoteControl::No:
                printf("                Remote Control:   Disabled\n");
                break;
            default:
                break;
            }
        }

        for (iaddress = cluster->SecondaryIPAddressList.begin(); iaddress != cluster->SecondaryIPAddressList.end(); iaddress++) {
            NLB_IPAddress * address = iaddress;
        
            if (address->GetIPAddress(&buffer))
                printf("  Secondary Cluster IP Address:   %ls\n", buffer);

            SAFEFREESTRING(buffer);

            if (address->GetSubnetMask(&buffer))
                printf("                   Subnet Mask:   %ls\n", buffer);

            SAFEFREESTRING(buffer);

            adapter = address->GetAdapter();

            if (adapter->GetIdentifiedBy(&by)) {
                adapter->GetAdapter(&buffer);

                switch (by) {
                case NLB_Adapter::ByName:
                    printf("                Adapter Name:   %ls\n", buffer);
                    break;
                case NLB_Adapter::ByGUID:
                    printf("                Adapter GUID:   %ls\n", buffer);
                    break;
                default:
                    break;
                }
            }

            SAFEFREESTRING(buffer);
        }

        for (ihost = cluster->HostList.begin(); ihost != cluster->HostList.end(); ihost++) {
            NLB_HostState::NLB_HostStateType state;
            NLB_Host * host = ihost;
            int id;

            if (host->Name.GetName(&buffer))
                printf("\nHost name: %ls ", buffer);
            
            SAFEFREESTRING(buffer);
            
            if (host->Label.GetText(&buffer))
                printf("(%ls)", buffer);
            
            printf("\n");
            
            SAFEFREESTRING(buffer);

            if (host->Adapter.GetIdentifiedBy(&by)) {
                host->Adapter.GetAdapter(&buffer);

                switch (by) {
                case NLB_Adapter::ByName:
                    printf("                  Adapter Name:   %ls\n", buffer);
                    break;
                case NLB_Adapter::ByGUID:
                    printf("                  Adapter GUID:   %ls\n", buffer);
                    break;
                default:
                    break;
                }
            }

            SAFEFREESTRING(buffer);
            if (host->HostID.GetID(&id))
                printf("                       Host ID:   %d\n", id);

            if (host->HostState.GetState(&state)) {
                switch (state) {
                case NLB_HostState::Started:
                    printf("                    Host State:   Started\n");
                    break;
                case NLB_HostState::Stopped:
                    printf("                    Host State:   Stopped\n");
                    break;
                case NLB_HostState::Suspended:
                    printf("                    Host State:   Suspended\n");
                    break;
                default:
                    break;
                }
            }

            if (host->HostName.GetName(&buffer))
                printf("                      Hostname:   %ls\n", buffer);
            
            SAFEFREESTRING(buffer);

            if (host->DedicatedIPAddress.GetIPAddress(&buffer))
                printf("  Dedicated Cluster IP Address:   %ls\n", buffer);
            
            SAFEFREESTRING(buffer);
            
            if (host->DedicatedIPAddress.GetSubnetMask(&buffer))
                printf("                   Subnet Mask:   %ls\n", buffer);
            
            SAFEFREESTRING(buffer);

            adapter = host->DedicatedIPAddress.GetAdapter();

            if (adapter->GetIdentifiedBy(&by)) {
                adapter->GetAdapter(&buffer);

                switch (by) {
                case NLB_Adapter::ByName:
                    printf("                Adapter Name:   %ls\n", buffer);
                    break;
                case NLB_Adapter::ByGUID:
                    printf("                Adapter GUID:   %ls\n", buffer);
                    break;
                default:
                    break;
                }
            }

            SAFEFREESTRING(buffer);

            if (host->ConnectionIPAddress.GetIPAddress(&buffer))
                printf(" Connection Cluster IP Address:   %ls\n", buffer);
            
            SAFEFREESTRING(buffer);
            
            if (host->ConnectionIPAddress.GetSubnetMask(&buffer))
                printf("                   Subnet Mask:   %ls\n", buffer);
            
            SAFEFREESTRING(buffer);

            adapter = host->ConnectionIPAddress.GetAdapter();

            if (adapter->GetIdentifiedBy(&by)) {
                adapter->GetAdapter(&buffer);

                switch (by) {
                case NLB_Adapter::ByName:
                    printf("                  Adapter Name:   %ls\n", buffer);
                    break;
                case NLB_Adapter::ByGUID:
                    printf("                  Adapter GUID:   %ls\n", buffer);
                    break;
                default:
                    break;
                }
            }

            SAFEFREESTRING(buffer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb_host.h ===
/*
 * Filename: NLB_Host.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_HOST_H__
#define __NLB_HOST_H__

#include "NLB_Common.h"
#include "NLB_Cluster.h"
#include "NLB_PortRule.h"

class NLB_Host {
public:
    NLB_Host() {
        PortRuleList.clear();
    }

    ~NLB_Host() {}

    NLB_Name      Name;
    NLB_HostName  HostName;
    NLB_Label     Label;
    NLB_HostID    HostID;
    NLB_HostState HostState;
    NLB_IPAddress DedicatedIPAddress;
    NLB_IPAddress ConnectionIPAddress;
    NLB_Adapter   Adapter;

    vector<NLB_PortRule> PortRuleList;

private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\stdafx.cpp ===
////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------
// Copyright (c) 1999-2000  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//--------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////





// stdafx.cpp : source file that includes just the standard includes
//	samples.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb_common.h ===
/*
 * Filename: NLB_Common.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_COMMON_H__
#define __NLB_COMMON_H__

#include "stdafx.h"

#include "wlbsparm.h"

#include <vector>
using namespace std;

#define NLB_MAX_NAME                100
#define NLB_MAX_HOST_NAME           100
#define NLB_MAX_DOMAIN_NAME         100
#define NLB_MAX_IPADDRESS           15
#define NLB_MAX_SUBNETMASK          15
#define NLB_MAX_NETWORK_ADDRESS     17
#define NLB_MAX_ADAPTER_GUID        40
#define NLB_MAX_ADAPTER_NAME        100
#define NLB_MAX_LABEL               100
#define NLB_MAX_PASSWORD            16
#define NLB_MIN_HOST_ID             0
#define NLB_MAX_HOST_ID             32

class NLB_Label {
public:
    NLB_Label ();
    ~NLB_Label ();
    
    bool IsValid ();
    bool GetText (PWSTR * outText);
    bool SetText (PWSTR inText);

private:
    WCHAR Text[NLB_MAX_LABEL + 1];
};

class NLB_Name {
public:
    NLB_Name ();
    ~NLB_Name ();
    
    bool IsValid ();
    bool GetName (PWSTR * outName);
    bool SetName (PWSTR inName);

private:
    WCHAR Name[NLB_MAX_NAME + 1];
};

class NLB_HostID {
public:
    NLB_HostID ();
    ~NLB_HostID ();
    
    bool IsValid ();
    bool GetID (int * outID);
    bool SetID (int inID);

private:
    int ID;
};

class NLB_HostName {
public:
    NLB_HostName ();
    ~NLB_HostName ();
    
    bool IsValid ();
    bool GetName (PWSTR * outName);
    bool SetName (PWSTR inName);

private:
    WCHAR Name[NLB_MAX_HOST_NAME + 1];
};

class NLB_RemoteControl {
public:
    typedef enum {
        Invalid = -1,
        No,
        Yes
    } NLB_RemoteControlEnabled;

    NLB_RemoteControl ();
    ~NLB_RemoteControl ();
    
    bool IsValid ();
    bool GetPassword (PWSTR * outName);
    bool GetEnabled (NLB_RemoteControlEnabled * outEnabled);
    bool SetPassword (PWSTR inName);
    bool SetEnabled (NLB_RemoteControlEnabled inEnabled);

private:
    NLB_RemoteControlEnabled Enabled;
    WCHAR Password[NLB_MAX_PASSWORD + 1];
};

class NLB_DomainName {
public:
    NLB_DomainName ();
    ~NLB_DomainName ();
    
    bool IsValid ();
    bool GetDomain (PWSTR * outDomain);
    bool SetDomain (PWSTR inDomain);

private:
    WCHAR Domain[NLB_MAX_DOMAIN_NAME + 1];
};

class NLB_NetworkAddress {
public:
    NLB_NetworkAddress ();
    ~NLB_NetworkAddress ();
    
    bool IsValid ();
    bool GetAddress (PWSTR * outAddress);
    bool SetAddress (PWSTR inAddress);

private:
    WCHAR Address[NLB_MAX_NETWORK_ADDRESS + 1];
};

class NLB_ClusterMode {
public:
    typedef enum {
        Invalid = -1,
        Unicast,
        Multicast,
        IGMP
    } NLB_ClusterModeType;

    NLB_ClusterMode ();
    ~NLB_ClusterMode ();

    bool IsValid ();
    bool GetMode (NLB_ClusterModeType * outMode);
    bool SetMode (NLB_ClusterModeType inMode);

private:
    NLB_ClusterModeType Mode;
};

class NLB_HostState {
public:
    typedef enum {
        Invalid = -1,
        Started,
        Stopped,
        Suspended
    } NLB_HostStateType;

    NLB_HostState ();
    ~NLB_HostState ();

    bool IsValid ();
    bool GetState (NLB_HostStateType * outState);
    bool SetState (NLB_HostStateType inState);

private:
    NLB_HostStateType State;
};

class NLB_Adapter {
public:
    typedef enum {
        Invalid = -1,
        ByGUID,
        ByName
    } NLB_AdapterIdentifier;

    NLB_Adapter ();
    ~NLB_Adapter ();

    bool IsValid ();
    bool GetAdapter (PWSTR * outAdapter);
    bool GetIdentifiedBy (NLB_AdapterIdentifier * outIdentifiedBy); 
    bool SetAdapter (PWSTR inAdapter);
    bool SetIdentifiedBy (NLB_AdapterIdentifier inIdentifiedBy);

private:        
    NLB_AdapterIdentifier IdentifiedBy;

    struct {
        WCHAR Name[NLB_MAX_ADAPTER_NAME + 1];
        WCHAR GUID[NLB_MAX_ADAPTER_GUID + 1];
    };
};

class NLB_IPAddress {
public:
    typedef enum {
        Invalid = -1,
        Primary,
        Secondary,
        Virtual,
        Dedicated,
        Connection,
        IGMP
    } NLB_IPAddressType;

    NLB_IPAddress ();
    ~NLB_IPAddress ();

    bool IsValid ();
    bool GetIPAddressType (NLB_IPAddressType * outType);
    bool GetIPAddress (PWSTR * outIPAddress);
    bool GetSubnetMask (PWSTR * outSubnetMask);
    bool SetIPAddressType (NLB_IPAddressType inType);
    bool SetIPAddress (PWSTR inIPAddress);
    bool SetSubnetMask (PWSTR inSubnetMask);

    NLB_Adapter * GetAdapter ();
    
private:
    NLB_IPAddressType Type;
    NLB_Adapter       Adapter;
    WCHAR             IPAddress[NLB_MAX_IPADDRESS + 1];
    WCHAR             SubnetMask[NLB_MAX_SUBNETMASK + 1];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\stdafx.h ===
////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------
// Copyright (c) 1999-2000  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//--------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////





// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__DDD12AB8_AB09_11D2_9CDE_0060B0EC3D39__INCLUDED_)
#define AFX_STDAFX_H__DDD12AB8_AB09_11D2_9CDE_0060B0EC3D39__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN

#include <stdio.h>

// TODO: reference additional headers your program requires here

#import "msxml3.dll" no_auto_exclude named_guids raw_interfaces_only

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DDD12AB8_AB09_11D2_9CDE_0060B0EC3D39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb_xmlparser.h ===
/*
 * Filename: NLB_XMLParser.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_XMLPARSER_H__
#define __NLB_XMLPARSER_H__

#include "NLB_Common.h"
#include "NLB_Cluster.h"
#include "NLB_Host.h"
#include "NLB_PortRule.h"
#include "NLB_XMLError.h"

#define CHECKHR(x) {hr = x; if (FAILED(hr)) {goto CleanUp;}}
#define CHECKALLOC(x) {if (!x) {hr = E_FAIL; goto CleanUp;}}
#define SAFERELEASE(p) {if (p) {(p)->Release(); p = NULL;}}
#define SAFEFREESTRING(p) {if (p) {SysFreeString(p); p = NULL;}}

class NLB_XMLParser {
public:
    NLB_XMLParser ();
    NLB_XMLParser (bool bSilent);

    ~NLB_XMLParser ();

    HRESULT Parse (WCHAR * wszFileName);
    HRESULT Parse (WCHAR * wszFileName, bool bPrintTree);
    HRESULT Parse (WCHAR * wszFileName, vector<NLB_Cluster> * pClusters);

    void Print ();
    void Print (vector<NLB_Cluster> Clusters);

    void GetParseError(NLB_XMLError * pError);

private:
    BSTR AsciiToBSTR (const char * pszName);
    CHAR * BSTRToAscii (const WCHAR * pwszName);

    NLB_IPAddress::NLB_IPAddressType StringToIPAddressType (const WCHAR * pwszType);
    NLB_ClusterMode::NLB_ClusterModeType StringToClusterMode (const WCHAR * pwszType);
    NLB_RemoteControl::NLB_RemoteControlEnabled StringToRemoteControlEnabled (const WCHAR * pwszType);
    NLB_HostState::NLB_HostStateType StringToHostState (const WCHAR * pwszState);

    HRESULT LoadDocument (BSTR pBURL);
    HRESULT CheckDocumentLoad ();

    void SetParseError (HRESULT hrCode, PWSTR pwszReason);

    HRESULT PrintTree (MSXML2::IXMLDOMNode* node, int level);

    HRESULT ParseCluster (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT ParseClusterProperties (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT ParseClusterHosts (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT ParseClusterPortRules (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);

    HRESULT ParseIPAddress (MSXML2::IXMLDOMNode * pNode, NLB_IPAddress * pIPAddress);
    HRESULT ParseAdapter (MSXML2::IXMLDOMNode * pNode, NLB_Adapter * pAdapter);
    HRESULT ParseRemoteControl (MSXML2::IXMLDOMNode * pNode, NLB_RemoteControl * pControl);    
    HRESULT ParseHost (MSXML2::IXMLDOMNode * pNode, NLB_Host * pHost);

private:
    vector<NLB_Cluster> ClusterList;
	
    MSXML2::IXMLDOMDocument2 * pDoc;
    MSXML2::IXMLDOMSchemaCollection * pSchema;
	
    NLB_XMLError ParseError;
	
    bool bShowErrorPopups;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd ddk_printscan.ini ddk $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\dload\printscanpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\dload\sti.c ===
#include "printscanpch.h"
#pragma hdrstop
#include <objbase.h>
#include <sti.h>


static
HRESULT 
StiCreateInstanceW(
    HINSTANCE hinst, 
    DWORD dwVer, 
    IStillImageW **ppSti, 
    LPUNKNOWN punkOuter)
{
    if (ppSti)
    {
        *ppSti = NULL;
    }
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(sti)
{
    DLPENTRY(StiCreateInstanceW)
};

DEFINE_PROCNAME_MAP(sti)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\dload\printui.c ===
#include "printscanpch.h"
#pragma hdrstop

#include <objbase.h>
#include <shtypes.h>
#include <prsht.h>
#include <winspool.h>
#include <winprtp.h>


static
VOID
vPrinterPropPages(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    )
{
    return;
}

static
HRESULT
ShowErrorMessageHR(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  HRESULT              hr
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
RegisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder,
    OUT  PBOOL                   pbAdministrator OPTIONAL
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
UnregisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
bFolderRefresh(
    IN   HANDLE                  hFolder,
    OUT  PBOOL                   pbAdministrator
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
ShowErrorMessageSC(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  DWORD                dwCode
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
bFolderGetPrinter(
    IN   HANDLE                  hFolder,
    IN   LPCTSTR                 pszPrinter,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
bFolderEnumPrinters(
    IN   HANDLE                  hFolder,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded,
    OUT  PDWORD                  pcbReturned
    )
{
    return FALSE;
}

static
VOID
vQueueCreate(
    HWND    hwndOwner,
    LPCTSTR pszPrinter,
    INT     nCmdShow,
    LPARAM  lParam
    )
{
    return;
}

static
VOID
vServerPropPages(
    HWND    hwndOwner,
    LPCTSTR pszServerName,
    INT     nCmdShow,
    LPARAM  lParam
    )
{
    return;
}

static
VOID
vDocumentDefaults(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    )
{
    return;
}

static
BOOL
bPrinterSetup(
    HWND    hwnd,
    UINT    uAction,
    UINT    cchPrinterName,
    LPTSTR  pszPrinterName,
    UINT*   pcchPrinterName,
    LPCTSTR pszServerName
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(printui)
{
    DLPENTRY(RegisterPrintNotify)
    DLPENTRY(ShowErrorMessageHR)
    DLPENTRY(ShowErrorMessageSC)
    DLPENTRY(UnregisterPrintNotify)
    DLPENTRY(bFolderEnumPrinters)
    DLPENTRY(bFolderGetPrinter)
    DLPENTRY(bFolderRefresh)
    DLPENTRY(bPrinterSetup)
    DLPENTRY(vDocumentDefaults)
    DLPENTRY(vPrinterPropPages)
    DLPENTRY(vQueueCreate)
    DLPENTRY(vServerPropPages)
};

DEFINE_PROCNAME_MAP(printui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxsrc.inc ===
#
# All binaries will end up in the fax directory
#
#ALT_PROJECT_TARGET=fax

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG -DFAX_HEAP_DEBUG
!endif

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS=$(FAXROOT)\util\unicode\$O\faxutil.lib
!else
LINKLIBS=$(FAXROOT)\util\ansii\$O\faxutil.lib
!endif

C_DEFINES=$(C_DEFINES) -DTAPI_CURRENT_VERSION=0x00020000

FAXLIB=$(FAXROOT)\lib

INCLUDES=$(FAXROOT)\inc;$(WINDOWS_INC_PATH);

MSC_WARNING_LEVEL=/W3 /WX

PROJECT_COMPILER_WARNINGS=-FI$(FAXROOT)\inc\warning.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\dload\winspool.c ===
#include "printscanpch.h"
#pragma hdrstop

#include <winspool.h>

static
BOOL
WINAPI
AbortPrinter(
    HANDLE  hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddFormW(
    IN HANDLE   hPrinter,
    IN DWORD    Level,
    IN LPBYTE   pForm
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddJobW(
    IN HANDLE    hPrinter,
    IN DWORD     Level,
    OUT LPBYTE   pData,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddMonitorW(
    IN LPWSTR  pName,
    IN DWORD   Level,
    IN LPBYTE  pMonitors
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPortW(
    IN LPWSTR   pName,
    IN HWND     hWnd,
    IN LPWSTR   pMonitorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPrinterConnectionW(
    IN LPWSTR pName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPrinterDriverExW(
    IN LPWSTR   pName,
    IN DWORD    Level,
    IN PBYTE    pDriverInfo,
    IN DWORD    dwFileCopyFlags
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPrinterDriverW(
    IN LPWSTR   pName,
    IN DWORD    Level,
    IN PBYTE    pDriverInfo
    )
{
    return FALSE;
}

static
HANDLE
WINAPI
AddPrinterW(
    IN LPWSTR   pName,
    IN DWORD    Level,
    IN LPBYTE   pPrinter
    )
{
    return NULL;
}

static
BOOL
WINAPI
AddPrintProcessorW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN LPWSTR   pPathName,
    IN LPWSTR   pPrintProcessorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPrintProvidorW(
    IN LPWSTR  pName,
    IN DWORD   level,
    IN LPBYTE  pProvidorInfo
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ClosePrinter(
    HANDLE  hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ConfigurePortW(
    IN LPWSTR   pName,
    IN HWND     hWnd,
    IN LPWSTR   pPortName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeleteFormW(
    IN HANDLE   hPrinter,
    IN LPWSTR   pFormName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeleteMonitorW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN LPWSTR   pMonitorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeletePortW(
    IN LPWSTR   pName,
    IN HWND     hWnd,
    IN LPWSTR   pPortName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeletePrinter(
    IN HANDLE    hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeletePrinterConnectionW(
    IN LPWSTR    pName
    )
{
    return FALSE;
}

static
DWORD
WINAPI
DeletePrinterDataExW(
    IN HANDLE    hPrinter,
    IN LPCWSTR    pKeyName,
    IN LPCWSTR    pValueName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DeletePrinterDataW(
    IN HANDLE    hPrinter,
    IN LPWSTR    pValueName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
DeletePrinterDriverExW(
    IN LPWSTR    pName,
    IN LPWSTR    pEnvironment,
    IN LPWSTR    pDriverName,
    IN DWORD     dwDeleteFlag,
    IN DWORD     dwVersionFlag
    )
{
    return FALSE;
}


static
BOOL
WINAPI
DeletePrinterDriverW(
    IN LPWSTR    pName,
    IN LPWSTR    pEnvironment,
    IN LPWSTR    pDriverName
    )
{
    return FALSE;
}

static
DWORD
WINAPI
DeletePrinterKeyW(
    IN HANDLE    hPrinter,
    IN LPCWSTR   pKeyName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
DeletePrintProcessorW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN LPWSTR   pPrintProcessorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeletePrintProvidorW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN LPWSTR   pPrintProvidorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EndDocPrinter(
    HANDLE  hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EndPagePrinter(
    HANDLE  hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumJobsW(
    IN HANDLE   hPrinter,
    IN DWORD    FirstJob,
    IN DWORD    NoJobs,
    IN DWORD    Level,
    OUT LPBYTE  pJob,
    IN DWORD    cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumMonitorsW(
    IN LPWSTR    pName,
    IN DWORD     Level,
    OUT LPBYTE   pMonitors,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT LPDWORD  pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumPortsW(
    IN LPWSTR    pName,
    IN DWORD     Level,
    OUT LPBYTE   pPorts,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT LPDWORD  pcReturned
    )
{
    return FALSE;
}

static
DWORD
WINAPI
EnumPrinterDataExW(
    IN HANDLE    hPrinter,
    IN LPCWSTR   pKeyName,
    OUT LPBYTE   pEnumValues,
    IN DWORD     cbEnumValues,
    OUT LPDWORD  pcbEnumValues,
    OUT LPDWORD  pnEnumValues
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
EnumPrinterDataW(
    IN HANDLE    hPrinter,
    IN DWORD     dwIndex,
    OUT LPWSTR  pValueName,
    IN DWORD     cbValueName,
    OUT LPDWORD  pcbValueName,
    OUT LPDWORD  pType,
    OUT LPBYTE   pData,
    IN DWORD     cbData,
    OUT LPDWORD  pcbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
EnumPrinterDriversW(
    IN LPWSTR    pName,
    IN LPWSTR    pEnvironment,
    IN DWORD     Level,
    IN LPBYTE    pDriverInfo,
    IN DWORD     cbBuf,
    IN LPDWORD   pcbNeeded,
    IN LPDWORD   pcReturned
    )
{
    return FALSE;
}

static
DWORD
WINAPI
EnumPrinterKeyW(
    IN HANDLE    hPrinter,
    IN LPCWSTR   pKeyName,
    OUT LPWSTR   pSubkey,
    IN DWORD     cbSubkey,
    OUT LPDWORD  pcbSubkey
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
EnumPrintProcessorDatatypesW(
    IN LPWSTR    pName,
    IN LPWSTR    pPrintProcessorName,
    IN DWORD     Level,
    OUT LPBYTE   pDatatypes,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT LPDWORD  pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumPrintProcessorsW(
    IN LPWSTR    pName,
    IN LPWSTR    pEnvironment,
    IN DWORD     Level,
    OUT LPBYTE   pPrintProcessorInfo,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT LPDWORD  pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
FindClosePrinterChangeNotification(
    IN HANDLE    hChange
    )
{
    return FALSE;
}

static
BOOL
WINAPI
FlushPrinter(
    IN HANDLE    hPinter,
    IN LPVOID    pBuf,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcWritten,
    IN DWORD     cSleep
    )
{
    return FALSE;
}


static
BOOL
WINAPI
GetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetJobW(
    IN HANDLE    hPrinter,
    IN DWORD     JobId,
    IN DWORD     Level,
    OUT LPBYTE   pJob,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded
    )
{
    return FALSE;
}

static
DWORD
GetPrinterDataExW(
    IN HANDLE    hPrinter,
    IN LPCWSTR   pKeyName,
    IN LPCWSTR   pValueName,
    OUT LPDWORD  pType,
    OUT LPBYTE   pData,
    IN DWORD     nSize,
    OUT LPDWORD  pcbNeeded
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
GetPrintProcessorDirectoryW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pPrintProcessorInfo,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
DWORD
WINAPI
GetPrinterDataW(
    HANDLE   hPrinter,
    LPWSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
GetPrinterDriverDirectoryW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pDriverDirectory,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
OpenPrinterW(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ReadPrinter(
    IN HANDLE    hPrinter,
    OUT LPVOID   pBuf,
    IN DWORD     cbBuf,
    OUT LPDWORD  pNoBytesRead
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ResetPrinterW(
    IN HANDLE             hPrinter,
    IN LPPRINTER_DEFAULTS pDefault
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ScheduleJob(
    IN HANDLE    hPrinter,
    IN DWORD     dwJobID
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SetFormW(
    IN HANDLE    hPrinter,
    IN LPWSTR    pFormName,
    IN DWORD     Level,
    IN LPBYTE    pForm
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SetJobW(
    IN HANDLE    hPrinter,
    IN DWORD     JobId,
    IN DWORD     Level,
    IN LPBYTE    pJob,
    IN DWORD     Command
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SetPortW(
    IN LPWSTR    pName,
    IN LPWSTR    pPortName,
    IN DWORD     dwLevel,
    IN LPBYTE    pPortInfo
    )
{
    return FALSE;
}

static
DWORD
WINAPI
SetPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
    )
{
    return FALSE;
}

static
DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
StartPagePrinter(
    HANDLE hPrinter
)
{
    return FALSE;
}

static
DWORD
WINAPI
WaitForPrinterChange(
    IN HANDLE  hPrinter,
    IN DWORD   Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumPrintersW(
    IN DWORD   Flags,
    IN LPWSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
    )
{
    return FALSE;
}

static
LONG
WINAPI
DocumentPropertiesW(
    IN HWND      hWnd,
    IN HANDLE    hPrinter,
    IN LPWSTR   pDeviceName,
    OUT PDEVMODEW pDevModeOutput,
    IN PDEVMODEW pDevModeInput,
    IN DWORD     fMode
    )
{
    return -1;
}

static
HANDLE
WINAPI
ConnectToPrinterDlg(
    IN HWND    hwnd,
    IN DWORD   Flags
    )
{
    return NULL;
}

static
LONG
WINAPI
AdvancedDocumentPropertiesW(
    IN HWND    hWnd,
    IN HANDLE  hPrinter,
    IN LPWSTR   pDeviceName,
    OUT PDEVMODEW pDevModeOutput,
    IN PDEVMODEW pDevModeInput
    )
{
    return 0;
}

static
int
WINAPI
DeviceCapabilitiesW(
    IN LPCWSTR pszDevice,
    IN LPCWSTR pszPort,
    IN WORD fwCapability,
    OUT LPWSTR pszOutput,
    IN CONST DEVMODEW* pDevMode
    )
{
    return -1;
}

static
LONG
WINAPI
ExtDeviceMode(
    HWND        hWnd,
    HANDLE      hInst,
    LPDEVMODEA  pDevModeOutput,
    LPSTR       pDeviceName,
    LPSTR       pPort,
    LPDEVMODEA  pDevModeInput,
    LPSTR       pProfile,
    DWORD       fMode
    )
{
    return -1;
}

static
BOOL
WINAPI
GetDefaultPrinterW(
    LPWSTR szDefaultPrinter,
    LPDWORD pcch
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SpoolerInit(
    VOID
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(winspool)
{
    DLOENTRY(203, GetDefaultPrinterW)
};

DEFINE_ORDINAL_MAP(winspool)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(winspool)
{
    DLPENTRY(AbortPrinter)
    DLPENTRY(AddFormW)
    DLPENTRY(AddJobW)
    DLPENTRY(AddMonitorW)
    DLPENTRY(AddPortW)
    DLPENTRY(AddPrintProcessorW)
    DLPENTRY(AddPrintProvidorW)
    DLPENTRY(AddPrinterConnectionW)
    DLPENTRY(AddPrinterDriverExW)
    DLPENTRY(AddPrinterDriverW)
    DLPENTRY(AddPrinterW)
    DLPENTRY(AdvancedDocumentPropertiesW)
    DLPENTRY(ClosePrinter)
    DLPENTRY(ConfigurePortW)
    DLPENTRY(ConnectToPrinterDlg)
    DLPENTRY(DeleteFormW)
    DLPENTRY(DeleteMonitorW)
    DLPENTRY(DeletePortW)
    DLPENTRY(DeletePrintProcessorW)
    DLPENTRY(DeletePrintProvidorW)
    DLPENTRY(DeletePrinter)
    DLPENTRY(DeletePrinterConnectionW)
    DLPENTRY(DeletePrinterDataExW)
    DLPENTRY(DeletePrinterDataW)
    DLPENTRY(DeletePrinterDriverExW)
    DLPENTRY(DeletePrinterDriverW)
    DLPENTRY(DeletePrinterKeyW)
    DLPENTRY(DeviceCapabilitiesW)
    DLPENTRY(DocumentPropertiesW)
    DLPENTRY(EndDocPrinter)
    DLPENTRY(EndPagePrinter)
    DLPENTRY(EnumFormsW)
    DLPENTRY(EnumJobsW)
    DLPENTRY(EnumMonitorsW)
    DLPENTRY(EnumPortsW)
    DLPENTRY(EnumPrintProcessorDatatypesW)
    DLPENTRY(EnumPrintProcessorsW)
    DLPENTRY(EnumPrinterDataExW)
    DLPENTRY(EnumPrinterDataW)
    DLPENTRY(EnumPrinterDriversW)
    DLPENTRY(EnumPrinterKeyW)
    DLPENTRY(EnumPrintersW)
    DLPENTRY(ExtDeviceMode)
    DLPENTRY(FindClosePrinterChangeNotification)
    DLPENTRY(FlushPrinter)
    DLPENTRY(GetFormW)
    DLPENTRY(GetJobW)
    DLPENTRY(GetPrintProcessorDirectoryW)
    DLPENTRY(GetPrinterDataExW)
    DLPENTRY(GetPrinterDataW)
    DLPENTRY(GetPrinterDriverDirectoryW)
    DLPENTRY(GetPrinterDriverW)
    DLPENTRY(GetPrinterW)
    DLPENTRY(OpenPrinterW)
    DLPENTRY(ReadPrinter)
    DLPENTRY(ResetPrinterW)
    DLPENTRY(ScheduleJob)
    DLPENTRY(SetFormW)
    DLPENTRY(SetJobW)
    DLPENTRY(SetPortW)
    DLPENTRY(SetPrinterDataExW)
    DLPENTRY(SetPrinterDataW)
    DLPENTRY(SetPrinterW)
    DLPENTRY(SpoolerInit)
    DLPENTRY(StartDocPrinterW)
    DLPENTRY(StartPagePrinter)
    DLPENTRY(WaitForPrinterChange)
    DLPENTRY(WritePrinter)
};

DEFINE_PROCNAME_MAP(winspool)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxcom.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxitg.cpp

Abstract:

    This file implements the dll exports from this
    control(s).

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"


#include "faxcom_i.c"
#include "faxtiff.h"
#include "faxsvr.h"
#include "Status.h"
#include "FaxJob.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_FaxTiff, CFaxTiff)
    OBJECT_ENTRY(CLSID_FaxServer, CFaxServer)	
END_OBJECT_MAP()

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    } else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
    }
    return TRUE;
}


STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


STDAPI DllRegisterServer(void)
{
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxdoc.h ===
// FaxDoc.h : Declaration of the CFaxDoc

#ifndef __FAXDOC_H_
#define __FAXDOC_H_

#include "resource.h"       // main symbols
#include "faxsvr.h"
#include <winfax.h>
#ifdef FAXBROADCAST_ENABLED
   #include "adoid.h"
   #include "adoint.h"
#endif
/////////////////////////////////////////////////////////////////////////////
// CFaxDoc
class ATL_NO_VTABLE CFaxDoc : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxDoc, &CLSID_FaxDoc>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxDoc, &IID_IFaxDoc, &LIBID_FAXCOMLib>
{
public:
	CFaxDoc()
	{
        m_DiscountSend = FALSE;
        m_SendCoverpage = FALSE;
        m_FaxCoverpageInfo = NULL;
        m_FaxJobParams = NULL;
        m_FileName = NULL;
        m_JobId = 0;
        m_TapiConnectionObject = NULL;

        CFaxServer* m_pFaxServer = NULL;
        m_FaxNumber = NULL;
        m_Tsid = NULL;
        m_BillingCode = NULL;
        m_EmailAddress = NULL;;
        m_DocumentName = NULL;;    
        m_Note = NULL;
        m_Subject = NULL;
        m_CoverpageName = NULL;
        m_RecipientName = NULL;
        m_RecipientNumber = NULL;
        m_RecipientCompany = NULL;
        m_RecipientAddress = NULL;
        m_RecipientCity = NULL;
        m_RecipientState = NULL;
        m_RecipientZip = NULL;
        m_RecipientCountry = NULL;
        m_RecipientTitle = NULL;
        m_RecipientDepartment = NULL;
        m_RecipientOffice = NULL;
        m_RecipientHomePhone = NULL;
        m_RecipientOfficePhone = NULL;
        m_SenderName = NULL;
        m_SenderCompany = NULL;
        m_SenderAddress = NULL;
        m_SenderTitle = NULL;
        m_SenderDepartment = NULL;
        m_SenderOfficeLocation = NULL;
        m_SenderHomePhone = NULL;
        m_SenderOfficePhone = NULL;
        m_SenderFax = NULL;


        //
        // prefill in the params...
        //

        FaxCompleteJobParams(&m_FaxJobParams,&m_FaxCoverpageInfo);

        if (m_FaxJobParams && m_FaxCoverpageInfo) {
        
            m_CoverpageName        =SysAllocString(m_FaxCoverpageInfo->CoverPageName);
            m_RecipientName        =SysAllocString(m_FaxCoverpageInfo->RecName);
            m_RecipientNumber      =SysAllocString(m_FaxCoverpageInfo->RecFaxNumber);
            m_RecipientCompany     =SysAllocString(m_FaxCoverpageInfo->RecCompany);
            m_RecipientAddress     =SysAllocString(m_FaxCoverpageInfo->RecStreetAddress);
            m_RecipientCity        =SysAllocString(m_FaxCoverpageInfo->RecCity);
            m_RecipientState       =SysAllocString(m_FaxCoverpageInfo->RecState);
            m_RecipientZip         =SysAllocString(m_FaxCoverpageInfo->RecZip);
            m_RecipientCountry     =SysAllocString(m_FaxCoverpageInfo->RecCountry);
            m_RecipientTitle       =SysAllocString(m_FaxCoverpageInfo->RecTitle);
            m_RecipientDepartment  =SysAllocString(m_FaxCoverpageInfo->RecDepartment);
            m_RecipientOffice      =SysAllocString(m_FaxCoverpageInfo->RecOfficeLocation);
            m_RecipientHomePhone   =SysAllocString(m_FaxCoverpageInfo->RecHomePhone);
            m_RecipientOfficePhone =SysAllocString(m_FaxCoverpageInfo->RecOfficePhone);
            m_SenderName           =SysAllocString(m_FaxCoverpageInfo->SdrName);
            m_SenderFax            =SysAllocString(m_FaxCoverpageInfo->SdrFaxNumber);
            m_SenderCompany        =SysAllocString(m_FaxCoverpageInfo->SdrCompany);
            m_SenderAddress        =SysAllocString(m_FaxCoverpageInfo->SdrAddress);
            m_SenderTitle          =SysAllocString(m_FaxCoverpageInfo->SdrTitle);
            m_SenderDepartment     =SysAllocString(m_FaxCoverpageInfo->SdrDepartment);
            m_SenderOfficeLocation =SysAllocString(m_FaxCoverpageInfo->SdrOfficeLocation);
            m_SenderHomePhone      =SysAllocString(m_FaxCoverpageInfo->SdrHomePhone);
            m_SenderOfficePhone    =SysAllocString(m_FaxCoverpageInfo->SdrOfficePhone);
            m_Note                 =SysAllocString(m_FaxCoverpageInfo->Note);
            m_Subject              =SysAllocString(m_FaxCoverpageInfo->Subject);               
            m_Tsid                 =SysAllocString(m_FaxJobParams->Tsid);
            m_BillingCode          =SysAllocString(m_FaxJobParams->BillingCode);
            m_EmailAddress         =SysAllocString(m_FaxJobParams->DeliveryReportAddress);
            m_DocumentName         =SysAllocString(m_FaxJobParams->DocumentName);
        
        }

	}
    

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDOC)

BEGIN_COM_MAP(CFaxDoc)
	COM_INTERFACE_ENTRY(IFaxDoc)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxDoc
public:
    ~CFaxDoc();
	BOOL Init(BSTR FileName,CFaxServer *pFaxServer);
	BOOL SetJob();
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR newVal);
	STDMETHOD(Send)(/*[out, retval]*/long *pVal);
	STDMETHOD(get_DisplayName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DisplayName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_EmailAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EmailAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BillingCode)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Tsid)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CoverpageSubject)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageSubject)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CoverpageNote)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageNote)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_SenderFax)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderFax)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderOfficePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderOfficePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderHomePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderHomePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderOffice)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderOffice)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderDepartment)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderDepartment)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderTitle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderTitle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderCompany)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientOfficePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientOfficePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientHomePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientHomePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientOffice)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientOffice)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientDepartment)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientDepartment)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientTitle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientTitle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCountry)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCountry)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientZip)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientZip)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientState)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientState)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCity)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCity)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCompany)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_DiscountSend)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_DiscountSend)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_ServerCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ServerCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_SendCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_SendCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_CoverpageName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FileName)(/*[in]*/ BSTR newVal);
   STDMETHOD(putref_ConnectionObject)(/*[in]*/ IDispatch* newVal);
   STDMETHOD(get_CallHandle)(/*[out, retval]*/ long *pVal);
   STDMETHOD(put_CallHandle)(/*[in]*/ long newVal);
#ifdef FAXBROADCAST_ENABLED
   STDMETHOD(Broadcast)(VARIANT pVal);

   friend BOOL CALLBACK BroadcastCallback(HANDLE FaxHandle,
                                DWORD RecipientNumber,
                                LPVOID Context,
                                PFAX_JOB_PARAMW JobParams,
                                PFAX_COVERPAGE_INFOW CoverpageInfo
                                );
#endif

private:
	CFaxServer* m_pFaxServer;
	BOOL m_DiscountSend;
	BOOL m_SendCoverpage;
	DWORD m_JobId;
	PFAX_COVERPAGE_INFO m_FaxCoverpageInfo;
	PFAX_JOB_PARAM m_FaxJobParams;
	BSTR m_FileName;
   IDispatch* m_TapiConnectionObject;
   
   VARIANT* m_pVariant;

    //
    // job info
    //
    BSTR m_FaxNumber;
    BSTR m_Tsid;
    BSTR m_BillingCode;
    BSTR m_EmailAddress;
    BSTR m_DocumentName;
    //
    // coverpage info
    //
    BSTR m_Note;
    BSTR m_Subject;
    BSTR m_CoverpageName;
    BSTR m_RecipientName;
    BSTR m_RecipientNumber;
    BSTR m_RecipientCompany;
    BSTR m_RecipientAddress;
    BSTR m_RecipientCity;
    BSTR m_RecipientState;
    BSTR m_RecipientZip;
    BSTR m_RecipientCountry;
    BSTR m_RecipientTitle;
    BSTR m_RecipientDepartment;
    BSTR m_RecipientOffice;
    BSTR m_RecipientHomePhone;
    BSTR m_RecipientOfficePhone;
    BSTR m_SenderName;    
    BSTR m_SenderCompany;
    BSTR m_SenderAddress;
    BSTR m_SenderTitle;
    BSTR m_SenderDepartment;
    BSTR m_SenderOfficeLocation;
    BSTR m_SenderHomePhone;
    BSTR m_SenderOfficePhone;
    BSTR m_SenderFax;

#ifdef FAXBROADCAST_ENABLED
    BOOL FreeCoverpageAndJobInfo(PFAX_JOB_PARAMW JobParams,
                              PFAX_COVERPAGE_INFOW CoverpageInfo
                              );    
  
    VOID InsertTextIntoStructure(LPTSTR txt,
                                 long i,
                                 PFAX_JOB_PARAMW pjp,
                                 PFAX_COVERPAGE_INFOW pci
                                 );
    
    BOOL RetrieveRecipientData(VARIANT* theData,
                               DWORD DataIndex, 
                               PFAX_JOB_PARAMW JobParams,
                               PFAX_COVERPAGE_INFOW CoverpageInfo
                               );
    
    BOOL RetrieveSenderData(PFAX_JOB_PARAMW pjp,
                            PFAX_COVERPAGE_INFOW pci
                            );

#endif
};

#endif //__FAXDOC_H_

#ifdef FAXBROADCAST_ENABLED
   BOOL CALLBACK BroadcastCallback(HANDLE FaxHandle,
                                   DWORD RecipientNumber,
                                   LPVOID Context,
                                   PFAX_JOB_PARAMW JobParams,
                                   PFAX_COVERPAGE_INFOW CoverpageInfo
                                   );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxdoc.cpp ===
// FaxDoc.cpp : Implementation of CFaxDoc
#include "stdafx.h"
#include "FaxDoc.h"
#include "faxutil.h"

long TotalRows;
long IndexMax = 2;


/////////////////////////////////////////////////////////////////////////////
// CFaxDoc

STDMETHODIMP CFaxDoc::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxDoc,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CFaxDoc::get_FileName(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FileName);
    if (!tmp && m_FileName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_FileName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_FileName) {
        SysFreeString( m_FileName);
    }
    m_FileName = tmp;    
    
	return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->CoverPageName);
    if (!tmp && m_FaxCoverpageInfo->CoverPageName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
       
}

STDMETHODIMP CFaxDoc::put_CoverpageName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_CoverpageName) {
        SysFreeString( m_CoverpageName);
    }
    m_CoverpageName = tmp;

    m_FaxCoverpageInfo->CoverPageName = m_CoverpageName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SendCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_SendCoverpage;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_SendCoverpage(BOOL newVal)
{
	m_SendCoverpage = newVal;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_ServerCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_FaxCoverpageInfo->UseServerCoverPage;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_ServerCoverpage(BOOL newVal)
{
	m_FaxCoverpageInfo->UseServerCoverPage = newVal;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_DiscountSend(BOOL * pVal)
{
    
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_DiscountSend;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_DiscountSend(BOOL newVal)
{
	m_DiscountSend = newVal;
	m_FaxJobParams->ScheduleAction = m_DiscountSend ? JSA_DISCOUNT_PERIOD : JSA_NOW;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecName);
    if (!tmp && m_FaxCoverpageInfo->RecName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientName) {
        SysFreeString( m_RecipientName);
    }
    m_RecipientName = tmp;

    m_FaxCoverpageInfo->RecName = m_RecipientName;
    m_FaxJobParams->RecipientName = m_RecipientName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCompany(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCompany);
    if (!tmp && m_FaxCoverpageInfo->RecCompany) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientCompany(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCompany) {
        SysFreeString( m_RecipientCompany);
    }
    m_RecipientCompany = tmp;

    m_FaxCoverpageInfo->RecCompany= m_RecipientCompany;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientAddress(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecStreetAddress);
    if (!tmp && m_FaxCoverpageInfo->RecStreetAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;

}

STDMETHODIMP CFaxDoc::put_RecipientAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientAddress) {
        SysFreeString( m_RecipientAddress);
    }
    m_RecipientAddress = tmp;

    m_FaxCoverpageInfo->RecStreetAddress = m_RecipientAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCity(BSTR * pVal)
{

    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCity);
    if (!tmp && m_FaxCoverpageInfo->RecCity) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_RecipientCity(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCity) {
        SysFreeString( m_RecipientCity);
    }
    m_RecipientCity = tmp;

    m_FaxCoverpageInfo->RecCity = m_RecipientCity;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientState(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecState);
    if (!tmp && m_FaxCoverpageInfo->RecState) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientState(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientState) {
        SysFreeString( m_RecipientState);
    }
    m_RecipientState = tmp;

    m_FaxCoverpageInfo->RecState = m_RecipientState;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientZip(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecZip);
    if (!tmp && m_FaxCoverpageInfo->RecZip) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientZip(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientZip) {
        SysFreeString( m_RecipientZip);
    }
    m_RecipientZip = tmp;

    m_FaxCoverpageInfo->RecZip = m_RecipientZip;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCountry(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCountry);
    if (!tmp && m_FaxCoverpageInfo->RecCountry) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientCountry(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCountry) {
        SysFreeString( m_RecipientCountry);
    }
    m_RecipientCountry = tmp;

    m_FaxCoverpageInfo->RecCountry = m_RecipientCountry;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientTitle(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecTitle);
    if (!tmp && m_FaxCoverpageInfo->RecTitle) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientTitle(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientTitle) {
        SysFreeString( m_RecipientTitle);
    }
    m_RecipientTitle = tmp;

    m_FaxCoverpageInfo->RecTitle = m_RecipientTitle;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientDepartment(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecDepartment);
    if (!tmp && m_FaxCoverpageInfo->RecDepartment) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientDepartment(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientDepartment) {
        SysFreeString( m_RecipientDepartment);
    }
    m_RecipientDepartment = tmp;

    m_FaxCoverpageInfo->RecDepartment = m_RecipientDepartment;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientOffice(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecOfficeLocation);
    if (!tmp && m_FaxCoverpageInfo->RecOfficeLocation) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientOffice(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientOffice) {
        SysFreeString( m_RecipientOffice);
    }
    m_RecipientOffice = tmp;

    m_FaxCoverpageInfo->RecOfficeLocation = m_RecipientOffice;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientHomePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecHomePhone);
    if (!tmp && m_FaxCoverpageInfo->RecHomePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientHomePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientHomePhone) {
        SysFreeString( m_RecipientHomePhone);
    }
    m_RecipientHomePhone = tmp;

    m_FaxCoverpageInfo->RecHomePhone = m_RecipientHomePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientOfficePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecOfficePhone);
    if (!tmp && m_FaxCoverpageInfo->RecOfficePhone ) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_RecipientOfficePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientOfficePhone) {
        SysFreeString( m_RecipientOfficePhone);
    }
    m_RecipientOfficePhone = tmp;

    m_FaxCoverpageInfo->RecOfficePhone = m_RecipientOfficePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderFax(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_SenderFax);
    if (!tmp && m_SenderFax) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_SenderFax(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderFax) {
        SysFreeString( m_SenderFax);
    }
    m_SenderFax = tmp;

    m_FaxCoverpageInfo->SdrFaxNumber = m_SenderFax;

    return S_OK;
}


STDMETHODIMP CFaxDoc::get_SenderName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrName);
    if (!tmp && m_FaxCoverpageInfo->SdrName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderName) {
        SysFreeString( m_SenderName);
    }
    m_SenderName = tmp;

    m_FaxCoverpageInfo->SdrName = m_SenderName;
    m_FaxJobParams->SenderName = m_SenderName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderCompany(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrCompany);
    if (!tmp && m_FaxCoverpageInfo->SdrCompany) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderCompany(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderCompany) {
        SysFreeString( m_SenderCompany);
    }
    m_SenderCompany = tmp;

    m_FaxCoverpageInfo->SdrCompany = m_SenderCompany;
    m_FaxJobParams->SenderCompany = m_SenderCompany;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderAddress(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrAddress);
    if (!tmp && m_FaxCoverpageInfo->SdrAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_SenderAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderAddress) {
        SysFreeString( m_SenderAddress);
    }
    m_SenderAddress = tmp;

    m_FaxCoverpageInfo->SdrAddress = m_SenderAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderTitle(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrTitle);
    if (!tmp && m_FaxCoverpageInfo->SdrTitle) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_SenderTitle(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderTitle) {
        SysFreeString( m_SenderTitle);
    }
    m_SenderTitle = tmp;

    m_FaxCoverpageInfo->SdrTitle = m_SenderTitle;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderDepartment(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrDepartment);
    if (!tmp && m_FaxCoverpageInfo->SdrDepartment) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderDepartment(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderDepartment) {
        SysFreeString( m_SenderDepartment);
    }
    m_SenderDepartment = tmp;

    m_FaxCoverpageInfo->SdrDepartment = m_SenderDepartment;
    m_FaxJobParams->SenderDept = m_SenderDepartment;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderOffice(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrOfficeLocation);
    if (!tmp && m_FaxCoverpageInfo->SdrOfficeLocation) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderOffice(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderOfficeLocation) {
        SysFreeString( m_SenderOfficeLocation);
    }
    m_SenderOfficeLocation = tmp;

    m_FaxCoverpageInfo->SdrOfficeLocation = m_SenderOfficeLocation;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderHomePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrHomePhone);
    if (!tmp && m_FaxCoverpageInfo->SdrHomePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderHomePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderHomePhone) {
        SysFreeString( m_SenderHomePhone);
    }
    m_SenderHomePhone = tmp;

    m_FaxCoverpageInfo->SdrHomePhone = m_SenderHomePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderOfficePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrOfficePhone);
    if (!tmp && m_FaxCoverpageInfo->SdrOfficePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_SenderOfficePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_SenderOfficePhone) {
        SysFreeString( m_SenderOfficePhone);
    }
    m_SenderOfficePhone = tmp;

    m_FaxCoverpageInfo->SdrOfficePhone = m_SenderOfficePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageNote(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->Note);
    if (!tmp && m_FaxCoverpageInfo->Note) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_CoverpageNote(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Note) {
        SysFreeString( m_Note);
    }
    m_Note = tmp;

    m_FaxCoverpageInfo->Note = m_Note;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageSubject(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->Subject);
    if (!tmp && m_FaxCoverpageInfo->Subject) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_CoverpageSubject(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Subject) {
        SysFreeString( m_Subject);
    }
    m_Subject = tmp;

    m_FaxCoverpageInfo->Subject = m_Subject;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_Tsid(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->Tsid);
    if (!tmp && m_FaxJobParams->Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_Tsid(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Tsid) {
        SysFreeString( m_Tsid);
    }
    m_Tsid = tmp;

    m_FaxJobParams->Tsid = m_Tsid;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_BillingCode(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->BillingCode);
    if (!tmp && m_FaxJobParams->BillingCode) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_BillingCode(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_BillingCode) {
        SysFreeString( m_BillingCode );
    }
    m_BillingCode = tmp;

    m_FaxJobParams->BillingCode = m_BillingCode;
        
    return S_OK;
}

STDMETHODIMP CFaxDoc::get_EmailAddress(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->DeliveryReportAddress);
    if (!tmp && m_FaxJobParams->DeliveryReportAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_EmailAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_EmailAddress) {
        SysFreeString( m_EmailAddress);
    }
    m_EmailAddress = tmp;

    m_FaxJobParams->DeliveryReportAddress = m_EmailAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_DisplayName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->DocumentName);
    if (!tmp && m_FaxJobParams->DocumentName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_DisplayName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_DocumentName) {
        SysFreeString( m_DocumentName);
    }
    m_DocumentName = tmp;

    m_FaxJobParams->DocumentName = m_DocumentName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::Send(long * pVal)
{
    
    //
    // user must specify a file name.
    // if user specifies a fax number, use that. 
    // else use the tapi call handle or connection object if it's there
    //
    if (!m_FileName) {
       return E_INVALIDARG;
    }

    if (!m_FaxJobParams->RecipientNumber) {
       //
       // see if they have a call handle or a connection object
       //
       if (!m_FaxJobParams->CallHandle) {       
          if (!m_TapiConnectionObject) {        
              return E_INVALIDARG;
          } else {
             m_FaxJobParams->Reserved[0] = 0xFFFF1234;
             m_FaxJobParams->Reserved[1] = (ULONG_PTR)m_TapiConnectionObject;
          }
       }
    }
    
    if (!FaxSendDocument(m_pFaxServer->GetFaxHandle(),
                         m_FileName,
                         m_FaxJobParams,
                         m_SendCoverpage ? m_FaxCoverpageInfo : NULL,
                         &m_JobId) ) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (m_TapiConnectionObject) {
       m_TapiConnectionObject->Release();
       m_TapiConnectionObject = NULL;
    }

    *pVal = m_JobId;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_FaxNumber(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->RecipientNumber);
    if (!tmp && m_FaxJobParams->RecipientNumber) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;

}

STDMETHODIMP CFaxDoc::put_FaxNumber(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_FaxNumber) {
        SysFreeString( m_FaxNumber);
    }
    m_FaxNumber = tmp;

    m_FaxCoverpageInfo->RecFaxNumber = m_FaxNumber;
    m_FaxJobParams->RecipientNumber = m_FaxNumber;

    return S_OK;
}

CFaxDoc::~CFaxDoc()
{
    if (m_FaxJobParams) {
        FaxFreeBuffer(m_FaxJobParams);
    }

    if (m_FaxCoverpageInfo) {
    FaxFreeBuffer(m_FaxCoverpageInfo);
    }

    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }

    if (m_FileName) {
        SysFreeString( m_FileName);
    }

    if (m_FaxNumber) {
        SysFreeString( m_FaxNumber);
    }

    if (m_Tsid) {
        SysFreeString( m_Tsid);
    }
    if (m_BillingCode) {
        SysFreeString( m_BillingCode);
    }
    if (m_EmailAddress) {
        SysFreeString( m_EmailAddress);
    }
    if (m_DocumentName) {
        SysFreeString(m_DocumentName);
    }
    if (m_Note) {
        SysFreeString( m_Note);
    }
    if (m_Subject) {
        SysFreeString( m_Subject);
    }
    if (m_CoverpageName) {
        SysFreeString( m_CoverpageName);
    }
    if (m_RecipientName) {
        SysFreeString( m_RecipientName);
    }
    if (m_RecipientNumber) {
        SysFreeString( m_RecipientNumber);
    }
    if (m_RecipientCompany) {
        SysFreeString( m_RecipientCompany);
    }
    if (m_RecipientAddress) {
        SysFreeString(m_RecipientAddress);
    }
    if (m_RecipientCity) {
        SysFreeString(m_RecipientCity);
    }
    if (m_RecipientState) {
        SysFreeString(m_RecipientState);
    }
    if (m_RecipientZip) {
        SysFreeString(m_RecipientZip);
    }
    if (m_RecipientCountry) {
        SysFreeString(m_RecipientCountry);
    }
    if (m_RecipientTitle) {
        SysFreeString(m_RecipientTitle);
    }
    if (m_RecipientDepartment) {
        SysFreeString(m_RecipientDepartment);
    }
    if (m_RecipientOffice) {
        SysFreeString(m_RecipientOffice);
    }
    if (m_RecipientHomePhone) {
        SysFreeString(m_RecipientHomePhone);
    }
    if (m_RecipientOfficePhone) {
        SysFreeString(m_RecipientOfficePhone);
    }
    if (m_SenderName) {
        SysFreeString(m_SenderName);
    }
    if (m_SenderCompany) {
        SysFreeString(m_SenderCompany);
    }
    if (m_SenderAddress) {
        SysFreeString(m_SenderAddress);
    }
    if (m_SenderTitle) {
        SysFreeString(m_SenderTitle);
    }
    if (m_SenderDepartment) {
        SysFreeString(m_SenderDepartment);
    }
    if (m_SenderFax) {
        SysFreeString(m_SenderFax);
    }    
    if (m_SenderOfficeLocation) {
        SysFreeString(m_SenderOfficeLocation);
    }
    if (m_SenderHomePhone) {
        SysFreeString(m_SenderHomePhone);
    }
    if (m_SenderOfficePhone) {
        SysFreeString(m_SenderOfficePhone);
    }

}

BOOL CFaxDoc::Init(BSTR FileName, CFaxServer * pFaxServer)
{
    HRESULT hr;
    
    m_pFaxServer = pFaxServer;

    //
    // make sure our fax handle doesn't get destroyed
    //
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    //
    // save our filename
    // 
    hr = put_FileName(FileName);
    if (FAILED(hr)) {
        return FALSE;
    }

    return TRUE;

}

STDMETHODIMP CFaxDoc::putref_ConnectionObject(IDispatch* newVal)
{
    if (!newVal) {
       return E_POINTER;
    }

    if (m_TapiConnectionObject) {
        m_TapiConnectionObject->Release();
        m_TapiConnectionObject = NULL;
    }

    HRESULT hr = newVal->QueryInterface(IID_IDispatch,(void**) &m_TapiConnectionObject);
    if (FAILED(hr)) {
       return hr;
    }
        
    return S_OK;
}

STDMETHODIMP CFaxDoc::put_CallHandle(long newVal)
{
    if (!newVal) {
       return E_INVALIDARG;
    }
    
    m_FaxJobParams->CallHandle = (HCALL)newVal;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CallHandle(long *pVal)
{	    
    if (!pVal) {
       return E_POINTER;
    }
    
    __try {
        *pVal = (long)m_FaxJobParams->CallHandle;
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return S_OK;
}

#ifdef FAXBROADCAST_ENABLED
STDMETHODIMP CFaxDoc::Broadcast(VARIANT pVal)
{
    IDispatch* pDisp;
//    IUnknown* pUnk;
    ADORecordset* prs;
    HRESULT hr;
    long CurrentRow = 0;    
    VARIANT vBookmark, rgvFields;
    VARIANT cRows;
//    VARIANT varField, varNewField;    

    //
    // user must specify a file name.
    //
    if (!m_FileName) {
       return E_INVALIDARG;
    }

    if (pVal.vt != VT_DISPATCH) {
       return E_FAIL;
    }

    pDisp = pVal.pdispVal;

    hr = pDisp->QueryInterface( IID_IADORecordset, (void**) prs );
    if (FAILED(hr)) {
       return hr;
    }

    //
    //Start from the current place
    //
    vBookmark.vt = VT_ERROR;
    vBookmark.scode = DISP_E_PARAMNOTFOUND;
    
    //
    // Get all columns
    //
    rgvFields.vt = VT_ERROR;
    rgvFields.scode = DISP_E_PARAMNOTFOUND;
         
    //
    // get the rows
    //
    hr = prs->GetRows(adGetRowsRest,
                      vBookmark,
                      rgvFields,
                      &cRows );
    if (FAILED(hr)) {
       DebugPrint(( TEXT("GetRows failed, ec = %x\n"), hr ));       
       prs->Release();
       return hr;;
    }
   
    m_pVariant = &cRows;

    //
    // find out the number of rows retreived
    //
    hr = SafeArrayGetUBound(cRows.parray, 2, &TotalRows);
    if (FAILED(hr)) {
       DebugPrint(( TEXT("SafeArrayGetUBound failed, ec=%x\n"), hr ));       
       prs->Release();
       return hr;
    }
   
    DebugPrint(( TEXT("There are %d rows in the datasource\n"), TotalRows ));

        
    if (!FaxSendDocumentForBroadcast(m_pFaxServer->GetFaxHandle(),
                                     m_DocumentName,
                                     &m_JobId,
                                     BroadcastCallback,
                                     (VOID *)this) ) {
        prs->Release();
        return HRESULT_FROM_WIN32(GetLastError());
    }

    prs->Release();

    return S_OK;
}

LPTSTR
StringDup(
   LPTSTR src
   )
{
   LPTSTR dst;

   if (!src) {
      return NULL;
   }

   dst = (LPTSTR) HeapAlloc( GetProcessHeap(), 0, (lstrlen(src)+1)*sizeof(TCHAR) );
   if (!dst) {
      return NULL;
   }

   lstrcpy(dst, src);

   return dst;

}


BOOL 
CFaxDoc::FreeCoverpageAndJobInfo(PFAX_JOB_PARAMW JobParams,PFAX_COVERPAGE_INFOW CoverpageInfo) {


#define MyFreeString(TargetString) if (TargetString) { \
        HeapFree(GetProcessHeap(), 0, TargetString); \
        }

  MyFreeString(JobParams->RecipientNumber);
  MyFreeString(JobParams->RecipientName);
  MyFreeString(JobParams->Tsid);
  MyFreeString(JobParams->SenderName);
  MyFreeString(JobParams->SenderDept);
  MyFreeString(JobParams->SenderCompany);
  MyFreeString(JobParams->BillingCode);
  MyFreeString(JobParams->DeliveryReportAddress);
  MyFreeString(JobParams->DocumentName);
  
  MyFreeString(CoverpageInfo->CoverPageName);
  MyFreeString(CoverpageInfo->RecName);
  MyFreeString(CoverpageInfo->RecFaxNumber);
  MyFreeString(CoverpageInfo->RecCompany);
  MyFreeString(CoverpageInfo->RecStreetAddress);
  MyFreeString(CoverpageInfo->RecCity);
  MyFreeString(CoverpageInfo->RecState);
  MyFreeString(CoverpageInfo->RecZip);
  MyFreeString(CoverpageInfo->RecCountry);
  MyFreeString(CoverpageInfo->RecTitle);
  MyFreeString(CoverpageInfo->RecDepartment);
  MyFreeString(CoverpageInfo->RecOfficeLocation);
  MyFreeString(CoverpageInfo->RecHomePhone);
  MyFreeString(CoverpageInfo->RecOfficePhone);
  MyFreeString(CoverpageInfo->SdrName);
  MyFreeString(CoverpageInfo->SdrFaxNumber);
  MyFreeString(CoverpageInfo->SdrCompany);
  MyFreeString(CoverpageInfo->SdrAddress);
  MyFreeString(CoverpageInfo->SdrTitle);
  MyFreeString(CoverpageInfo->SdrDepartment);
  MyFreeString(CoverpageInfo->SdrOfficeLocation);
  MyFreeString(CoverpageInfo->SdrHomePhone);
  MyFreeString(CoverpageInfo->SdrOfficePhone);
  MyFreeString(CoverpageInfo->Note);
  MyFreeString(CoverpageInfo->Subject);  
  
  return TRUE;
}



BOOL CALLBACK
BroadcastCallback(
   HANDLE FaxHandle,
   DWORD RecipientNumber,
   LPVOID Context,
   PFAX_JOB_PARAMW JobParams,
   PFAX_COVERPAGE_INFOW CoverpageInfo OPTIONAL
   )
/*++

Routine Description:

    main faxback callback function

Arguments:

    FaxHandle - handle to fax service
    RecipientNumber - number of times this function has been called
    Context - context info (in our case, a ADORecordset pointer)
    JobParams - pointer to a FAX_JOB_PARAM structure to receive our information
    CoverpageInfo - pointer to a FAX_COVERPAGE_INFO structure to receive our information

Return Value:

    TRUE -- use the data we set, FALSE, done sending data back to fax service.                                             

--*/

{
   CFaxDoc* pFaxDoc = (CFaxDoc*) Context;
   VARIANT* theData = pFaxDoc->m_pVariant;

   if (RecipientNumber > (DWORD) TotalRows) {
      return FALSE;
   }

   //
   // get the next recipient
   //
   pFaxDoc->RetrieveRecipientData(theData,RecipientNumber, JobParams, CoverpageInfo);
   pFaxDoc->RetrieveSenderData(JobParams,CoverpageInfo);

   if (!JobParams->RecipientNumber) {
      DebugPrint(( TEXT("required data RecipientNumber not retreived\n") ));
      pFaxDoc->FreeCoverpageAndJobInfo(JobParams, CoverpageInfo);
      return FALSE;
   }

   return TRUE;

}

VOID
CFaxDoc::InsertTextIntoStructure(
   LPTSTR txt,
   long i,
   PFAX_JOB_PARAMW pjp,
   PFAX_COVERPAGE_INFOW pci
   ) 
{

   switch(i) {
      case 0:
         pjp->RecipientNumber = txt;
         pci->RecFaxNumber = txt;
         break;
      case 1:
         pjp->RecipientName = txt;
         pci->RecName;
         break;
      case 2:
         pci->Note = txt;
         break;
      case 3:
         pci->Subject = txt;
         break;      
      case 4:
         pci->CoverPageName = txt;
         break;
      case 5:
         pci->RecCompany = txt;
         break;
      case 6:
         pci->RecStreetAddress = txt;
         break;
      case 7:
         pci->RecCity = txt;
         break;
      case 8:
         pci->RecState = txt;
         break;
      case 9:
         pci->RecZip = txt;
         break;
      case 10:
         pci->RecCountry = txt;
         break;
      case 11:
         pci->RecTitle = txt;
         break;
      case 12:
         pci->RecDepartment = txt;
         break;
      case 13:
         pci->RecOfficeLocation = txt;
         break;
      case 14:
         pci->RecHomePhone = txt;
         break;
      case 15:
         pci->RecOfficePhone = txt;
         break;      

   }

   return;

}


BOOL
CFaxDoc::RetrieveRecipientData(
   VARIANT* theData,
   DWORD DataIndex, 
   PFAX_JOB_PARAMW JobParams,
   PFAX_COVERPAGE_INFOW CoverpageInfo)
{

   long Index[2];
//   BSTR strData;
   VARIANT vData, vNew;
   LPTSTR txtData;
   HRESULT hr;

   Index[1] = DataIndex;
   Index[0] = 0;

   for (Index[0] = 0; Index[0] < IndexMax ; Index[0]++) {  
       hr = SafeArrayGetElement( theData->parray, &Index[0], &vData );
       if (FAILED(hr)) {
          DebugPrint(( TEXT("SafeArrayGetElement failed, ec=hr\n"), hr ));
          return FALSE;
       }

       //
       // make sure it's a string
       //
       hr = VariantChangeType(&vNew, &vData, 0, VT_BSTR);
       if (FAILED(hr)) {
          DebugPrint(( TEXT("VariantChangeType failed, ec=hr\n"), hr ));
          return FALSE;
       }

       txtData = StringDup( vNew.bstrVal );
       InsertTextIntoStructure( txtData, Index[0], JobParams, CoverpageInfo );

   }

   return TRUE;

}

BOOL
CFaxDoc::RetrieveSenderData(
   PFAX_JOB_PARAMW pjp,
   PFAX_COVERPAGE_INFOW pci)
{

   pjp->Tsid = StringDup(m_FaxJobParams->Tsid);
   pjp->SenderName = StringDup(m_FaxJobParams->SenderName);
   pjp->SenderCompany = StringDup(m_FaxJobParams->SenderCompany);
   pjp->SenderDept= StringDup(m_FaxJobParams->SenderDept);
   pjp->BillingCode = StringDup(m_FaxJobParams->BillingCode);
   pjp->ScheduleAction = JSA_NOW; // when to schedule the fax, see JSA defines
   pjp->DeliveryReportAddress = StringDup(m_FaxJobParams->EmailAddress); // email address for delivery report (ndr or dr)
   pjp->DeliveryReportType = pjp->DeliveryReportAddress ? DRT_INBOX : DRT_NONE; // delivery report type, see DRT defines
   pjp->DocumentName = StringDup(m_FaxJobParams->DocumentName);
      
   pci->SdrName = StringDup(m_FaxCoverpageInfo->SdrName);
   pci->SdrFaxNumber = StringDup(m_FaxCoverpageInfo->SdrFaxNumber);
   pci->SdrCompany = StringDup(m_FaxCoverpageInfo->SdrCompany);
   pci->SdrAddress = StringDup(m_FaxCoverpageInfo->SdrAddress);
   pci->SdrTitle = StringDup(m_FaxCoverpageInfo->SdrTitle);
   pci->SdrDepartment = StringDup(m_FaxCoverpageInfo->SdrDepartment);
   pci->SdrOfficeLocation = StringDup(m_FaxCoverpageInfo->SdrOfficeLocation);
   pci->SdrHomePhone = StringDup(m_FaxCoverpageInfo->SdrHomePhone);
   pci->SdrOfficePhone = StringDup(m_FaxCoverpageInfo->SdrOfficePhone);

   return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxjob.cpp ===
// FaxJob.cpp : Implementation of CFaxJobs
#include "stdafx.h"
#include "FaxJob.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxJobs

CFaxJobs::~CFaxJobs()
{
	if (m_pFaxServer) {
		m_pFaxServer->Release();
	}

    if (m_VarVect) {
        delete [] m_VarVect;
    }
}

BOOL CFaxJobs::Init(CFaxServer * pFaxServer)
{
    PFAX_JOB_ENTRYW     JobEntry = NULL;
    DWORD               PortInfoSize = 0;
    HRESULT             hr;

    //
    // get the ports from the server
    //
    if (!pFaxServer) {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxEnumJobsW( m_pFaxServer->GetFaxHandle(), &JobEntry, &m_Jobs)) {
        m_LastFaxError = GetLastError();        
        return FALSE;
    }

    //
    // enumerate the ports
    //

    m_VarVect = new CComVariant[m_Jobs];
    if (!m_VarVect) {
        FaxFreeBuffer( JobEntry );
        m_LastFaxError = ERROR_OUTOFMEMORY;
        return FALSE;
    }

    for (DWORD i=0; i<m_Jobs; i++) {

        //
        // create the object
        //

        CComObject<CFaxJob> *pFaxJob;
        HRESULT hr = CComObject<CFaxJob>::CreateInstance( &pFaxJob );
        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }

        //
        // set the values
        //

        if (!pFaxJob->Initialize(
            m_pFaxServer,
            JobEntry[i].JobId,
			JobEntry[i].UserName,
            JobEntry[i].JobType,
            JobEntry[i].QueueStatus,
            JobEntry[i].Status,
			JobEntry[i].PageCount,
			JobEntry[i].RecipientNumber,
			JobEntry[i].RecipientName,
			JobEntry[i].Tsid,
			JobEntry[i].SenderName,
			JobEntry[i].SenderCompany,
			JobEntry[i].SenderDept,
			JobEntry[i].BillingCode,
			JobEntry[i].ScheduleAction,
			JobEntry[i].DocumentName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxJob->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //

        CComVariant &var = m_VarVect[i];
        var.vt = VT_DISPATCH;
        var.pdispVal = lpDisp;

    }

    FaxFreeBuffer( JobEntry );

    return TRUE;

}

STDMETHODIMP CFaxJobs::get_Count(long * pVal)
{
	if (!pVal)
        return E_POINTER;
    
    __try {

        *pVal = m_Jobs;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

	return E_UNEXPECTED;
}

STDMETHODIMP CFaxJobs::get_Item(long Index, VARIANT * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    //
    // use 1-based index, VB like
    //

    if ((Index < 1) || (Index > (long) m_Jobs)) {
        return E_INVALIDARG;
    }


    __try {                 
        
        VariantInit( pVal );

        pVal->vt = VT_UNKNOWN;
        pVal->punkVal = NULL;
    
        return VariantCopy( pVal, &m_VarVect[Index-1] );        

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;	

}



/////////////////////////////////////////////////////////////////////////////
// CFaxJob


STDMETHODIMP CFaxJob::get_JobId(long * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_JobId;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
    }
        
	return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_Type(long * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_JobType;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
    }
        
	return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_UserName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_UserName);

    if (!Copy  && m_UserName) {
        return E_OUTOFMEMORY;
    }    

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);    
    }
        
	return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxJob::get_QueueStatus(BSTR * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_szQueueStatus);

    if (!Copy  && m_szQueueStatus) {
        return E_OUTOFMEMORY;
    }
    
    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxJob::get_DeviceStatus(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_szDeviceStatus);

    if (!Copy  && m_szDeviceStatus) {
        return E_OUTOFMEMORY;
    }
    
    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxJob::get_PageCount(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_PageCount;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
    }
        
	return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxJob::get_FaxNumber(BSTR * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_RecipientNumber);

    if (!Copy  && m_RecipientNumber) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxJob::get_RecipientName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_RecipientName);

    if (!Copy  && m_RecipientName) {
        return E_OUTOFMEMORY;
    }
    
    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;	
}

STDMETHODIMP CFaxJob::get_Tsid(BSTR * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Tsid);

    if (!Copy  && m_Tsid) {
        return E_OUTOFMEMORY;
    }
    
    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_SenderName(BSTR * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderName);

    if (!Copy  && m_SenderName) {
        return E_OUTOFMEMORY;
    }
    
    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_SenderCompany(BSTR * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderCompany);

    if (!Copy  && m_SenderCompany) {
        return E_OUTOFMEMORY;
    }
    
    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_SenderDept(BSTR * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderDept);

    if (!Copy  && m_SenderDept) {
        return E_OUTOFMEMORY;
    }
    
    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_BillingCode(BSTR * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_BillingCode);

    if (!Copy  && m_BillingCode) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_DisplayName(BSTR * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_DisplayName);

    if (!Copy  && m_DisplayName) {
        return E_OUTOFMEMORY;
    }
    
    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
        
	return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxJob::get_DiscountSend(BOOL * pVal)
{
	if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_DiscountTime;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
    }
        
	return E_UNEXPECTED;    
}

CFaxJob::~CFaxJob()
{
	if (m_UserName) {
		SysFreeString(m_UserName);
	}	
	if (m_szQueueStatus ) {
		SysFreeString(m_szQueueStatus);
	}
	if (m_szDeviceStatus ) {
		SysFreeString(m_szDeviceStatus);
	}
	if (m_RecipientNumber ) {
		SysFreeString(m_RecipientNumber);
	}
	if (m_RecipientName ) {
		SysFreeString(m_RecipientName);
	}
	if (m_Tsid ) {
		SysFreeString(m_Tsid);
	}
	if (m_SenderName  ) {
		SysFreeString(m_SenderName);
	}
	if (m_SenderCompany) {
		SysFreeString(m_SenderCompany);
	}
	if (m_SenderDept) {
		SysFreeString(m_SenderDept);
	}
	if (m_BillingCode ) {
		SysFreeString(m_BillingCode);
	}
	if (m_DisplayName  ) {
		SysFreeString(m_DisplayName);
	}
	if (m_pFaxServer) {
		m_pFaxServer->Release();
	}
}

BOOL CFaxJob::Initialize(
	CFaxServer *pFaxServer,
	DWORD JobId,
	LPCWSTR UserName,
	DWORD JobType,
	DWORD QueueStatus,
	DWORD DeviceStatus,
	DWORD PageCount,
	LPCWSTR RecipientNumber,
	LPCWSTR RecipientName,
	LPCWSTR Tsid,
	LPCWSTR SenderName,
	LPCWSTR SenderCompany,
	LPCWSTR SenderDept,
	LPCWSTR BillingCode,
	DWORD ScheduleAction,
	LPCWSTR DisplayName)
{
	HRESULT hr;
    BOOL err;

    if (!pFaxServer) {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;

    hr = m_pFaxServer->AddRef();
    
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

	m_JobId = JobId;

    m_UserName = SysAllocString(UserName);
    if (!m_UserName && UserName) {
        err = TRUE;
        goto e1;
    }

	m_JobType = JobType;

	m_QueueStatus = QueueStatus;

	m_DeviceStatus = DeviceStatus;

    m_szQueueStatus = GetQueueStatus(m_QueueStatus);
    if (!m_szQueueStatus) {
        err = TRUE;
        goto e2;
    }

    m_szDeviceStatus = GetDeviceStatus(m_DeviceStatus);
    if (!m_szDeviceStatus) {
        err = TRUE;
        goto e3;
    }
	
	m_PageCount = PageCount;

    m_RecipientNumber   = SysAllocString(RecipientNumber);
    if (!m_RecipientNumber && RecipientNumber) {
        goto e4;
    }
    m_RecipientName     = SysAllocString(RecipientName);
    if (!m_RecipientName && RecipientName) {
        goto e5;
    }
    m_Tsid              = SysAllocString(Tsid);
    if (!m_Tsid && Tsid) {
        goto e6;
    }
    m_SenderName        = SysAllocString(SenderName);
    if (!m_SenderName && SenderName) {
        goto e7;
    }
    m_SenderCompany     = SysAllocString(SenderCompany);
    if (!m_SenderCompany && SenderCompany) {
        goto e8;
    }
    m_SenderDept        = SysAllocString(SenderDept);
    if (!m_SenderDept && SenderDept) {
        goto e9;
    }
    m_BillingCode       = SysAllocString(BillingCode);
    if (!m_BillingCode && BillingCode) {
        goto e10;
    }
    m_DisplayName       = SysAllocString(DisplayName);
    if (!m_DisplayName && DisplayName) {
        goto e11;
    }

	m_DiscountTime = (ScheduleAction == JSA_DISCOUNT_PERIOD) ? TRUE : FALSE;

    return TRUE;

e11:
    SysFreeString(m_BillingCode);
e10:
    SysFreeString(m_SenderDept);
e9:
    SysFreeString(m_SenderCompany);
e8:
    SysFreeString(m_SenderName);
e7:
    SysFreeString(m_Tsid);
e6:
    SysFreeString(m_RecipientName);
e5:
    SysFreeString(m_RecipientNumber);
e4:
    SysFreeString(m_szDeviceStatus);
e3:
    SysFreeString(m_szQueueStatus);
e2:
    SysFreeString(m_UserName);
e1:
    m_pFaxServer->Release();
    
    m_pFaxServer = NULL;

    return(FALSE);

}

BOOL CFaxJob::SetJob()
{
	FAX_JOB_ENTRYW FaxJobEntry;

	ZeroMemory(&FaxJobEntry,sizeof(FAX_JOB_ENTRYW) );
	FaxJobEntry.SizeOfStruct = sizeof(FAX_JOB_ENTRYW);
	FaxJobEntry.JobId = m_JobId;
	FaxJobEntry.UserName = m_UserName;
	FaxJobEntry.JobType = m_JobType;
	FaxJobEntry.QueueStatus = m_QueueStatus;
	FaxJobEntry.Status = m_DeviceStatus;
	FaxJobEntry.PageCount = m_PageCount;
	FaxJobEntry.RecipientNumber = m_RecipientNumber;
	FaxJobEntry.RecipientName = m_RecipientName;
	FaxJobEntry.Tsid = m_Tsid;
	FaxJobEntry.SenderName = m_SenderName;
	FaxJobEntry.SenderCompany = m_SenderCompany;
	FaxJobEntry.SenderDept = m_SenderDept;
	FaxJobEntry.BillingCode = m_BillingCode;
	FaxJobEntry.ScheduleAction = m_DiscountTime ? JSA_DISCOUNT_PERIOD : JSA_NOW;
	FaxJobEntry.DocumentName = m_DisplayName;


	if (!FaxSetJobW(m_pFaxServer->GetFaxHandle(),m_JobId,m_Command,&FaxJobEntry) ) {
		return FALSE;
	}

	return TRUE;

}

STDMETHODIMP CFaxJob::SetStatus(long Command)
{
	m_Command = Command;

	if (!SetJob())
        return HRESULT_FROM_WIN32(GetLastError());

	return S_OK;
}

STDMETHODIMP CFaxJob::Refresh()
{
	PFAX_JOB_ENTRYW FaxJobEntry;
    HRESULT hr = S_OK;

	if (!FaxGetJobW(m_pFaxServer->GetFaxHandle(),m_JobId,&FaxJobEntry) ) {
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if (m_UserName) {
		SysFreeString(m_UserName);		
	}	
	m_UserName = SysAllocString(FaxJobEntry->UserName);
    
	m_JobType = FaxJobEntry->JobType;

	m_QueueStatus = FaxJobEntry->QueueStatus;

	m_DeviceStatus = FaxJobEntry->Status;

    if (m_szQueueStatus) {
        SysFreeString(m_szQueueStatus);
    }
    m_szQueueStatus = GetQueueStatus(m_QueueStatus);

    if (m_szDeviceStatus) {
        SysFreeString(m_szDeviceStatus);
    }
    m_szDeviceStatus = GetDeviceStatus(m_DeviceStatus);
	
	m_PageCount = FaxJobEntry->PageCount;

	if (m_RecipientNumber ) {
		SysFreeString(m_RecipientNumber);
	}
	m_RecipientNumber = SysAllocString(FaxJobEntry->RecipientNumber);

	if (m_RecipientName ) {
		SysFreeString(m_RecipientName);
	}
	m_RecipientName = SysAllocString(FaxJobEntry->RecipientName);

	if (m_Tsid ) {
		SysFreeString(m_Tsid);
	}
	m_Tsid = SysAllocString(FaxJobEntry->Tsid);

	if (m_SenderName  ) {
		SysFreeString(m_SenderName);
	}
	m_SenderName = SysAllocString(FaxJobEntry->SenderName);

	if (m_SenderCompany) {
		SysFreeString(m_SenderCompany);
	}
	m_SenderCompany = SysAllocString(FaxJobEntry->SenderCompany);

	if (m_SenderDept) {
		SysFreeString(m_SenderDept);
	}
	m_SenderDept = SysAllocString(FaxJobEntry->SenderDept);

	if (m_BillingCode ) {
		SysFreeString(m_BillingCode);
	}
	m_BillingCode = SysAllocString(FaxJobEntry->BillingCode);

	if (m_DisplayName) {
		SysFreeString(m_DisplayName);
	}
	m_DisplayName = SysAllocString(FaxJobEntry->DocumentName);

	m_DiscountTime = (FaxJobEntry->ScheduleAction == JSA_DISCOUNT_PERIOD) ? TRUE : FALSE;

    

    if (!m_szQueueStatus || !m_szDeviceStatus  ||
        (!m_UserName && FaxJobEntry->UserName) ||
        (!m_RecipientNumber && FaxJobEntry->RecipientNumber) ||
        (!m_RecipientName && FaxJobEntry->RecipientName) ||
        (!m_Tsid && FaxJobEntry->Tsid) ||
        (!m_SenderName && FaxJobEntry->SenderName) ||
        (!m_SenderCompany && FaxJobEntry->SenderCompany) ||
        (!m_SenderDept && FaxJobEntry->SenderDept) ||
        (!m_BillingCode && FaxJobEntry->BillingCode) ||
        (!m_DisplayName && FaxJobEntry->DocumentName) ) {
        
        hr = E_OUTOFMEMORY;

    }

    FaxFreeBuffer(FaxJobEntry);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxjob.h ===
// FaxJob.h : Declaration of the CFaxJobs

#ifndef __FAXJOBS_H_
#define __FAXJOBS_H_

#include "resource.h"       // main symbols
#include <winfax.h>
#include "faxsvr.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxJobs
class ATL_NO_VTABLE CFaxJobs : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxJobs, &CLSID_FaxJobs>,
	public IDispatchImpl<IFaxJobs, &IID_IFaxJobs, &LIBID_FAXCOMLib>
{
public:
	CFaxJobs()
	{
		m_Jobs = 0;
		m_LastFaxError = 0;
		m_pFaxServer = NULL;
		m_VarVect = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXJOBS)

BEGIN_COM_MAP(CFaxJobs)
	COM_INTERFACE_ENTRY(IFaxJobs)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxJobs
public:
	STDMETHOD(get_Item)(long Index, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
	BOOL Init(CFaxServer *pFaxServer);
	 ~CFaxJobs();
private:
	CComVariant* m_VarVect;
	CFaxServer* m_pFaxServer;
	DWORD m_Jobs;
	DWORD m_LastFaxError;
};


/////////////////////////////////////////////////////////////////////////////
// CFaxJob
class ATL_NO_VTABLE CFaxJob : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxJob, &CLSID_FaxJob>,
	public IDispatchImpl<IFaxJob, &IID_IFaxJob, &LIBID_FAXCOMLib>
{
public:
	CFaxJob()
	{
		m_JobId = 0;
		m_UserName = NULL;
		m_JobType = JT_UNKNOWN;
		m_QueueStatus = 0 ;
		m_DeviceStatus = 0 ;
		m_szQueueStatus = NULL;
		m_szDeviceStatus = NULL;
		m_PageCount=0;
		m_RecipientNumber = NULL;
		m_RecipientName = NULL;
		m_Tsid = NULL;
		m_SenderName = NULL;
		m_SenderCompany = NULL;
		m_SenderDept = NULL;
		m_BillingCode = NULL;
		m_DiscountTime = FALSE;
		m_DisplayName = NULL;
		m_Command = JC_UNKNOWN;
		m_pFaxServer = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXJOB)

BEGIN_COM_MAP(CFaxJob)
	COM_INTERFACE_ENTRY(IFaxJob)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxJob
public:
	STDMETHOD(Refresh)();
	STDMETHOD(SetStatus)(long Command);
	BOOL SetJob();
	 ~CFaxJob();
	BOOL Initialize(CFaxServer *pFaxServer,DWORD JobId,LPCWSTR UserName,DWORD JobType,DWORD QueueStatus,DWORD DeviceStatus,DWORD PageCount,LPCWSTR RecipientNumber,LPCWSTR RecipientName,LPCWSTR Tsid,LPCWSTR SenderName,LPCWSTR SenderCompany,LPCWSTR SenderDept,LPCWSTR BillingCode,DWORD ScheduleAction,LPCWSTR DisplayName);
	STDMETHOD(get_DiscountSend)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_DisplayName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderDept)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_PageCount)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_DeviceStatus)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_QueueStatus)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_UserName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Type)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_JobId)(/*[out, retval]*/ long *pVal);
private:
	DWORD m_JobId;
	BSTR  m_UserName;
	DWORD m_JobType;
	DWORD m_QueueStatus;
	DWORD m_DeviceStatus;
	BSTR  m_szQueueStatus;
	BSTR  m_szDeviceStatus;
	DWORD m_PageCount;
	BSTR  m_RecipientNumber;
	BSTR  m_RecipientName;
	BSTR  m_Tsid;
	BSTR  m_SenderName;
	BSTR  m_SenderCompany;
	BSTR  m_SenderDept;
	BSTR  m_BillingCode;
	BOOL  m_DiscountTime;
	BSTR  m_DisplayName;
	DWORD m_Command;
	CFaxServer * m_pFaxServer;
};

#endif //__FAXJOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxport.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxport.h

Abstract:

    This module contains the port class definitions.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#ifndef __FAXPORT_H_
#define __FAXPORT_H_

#include "resource.h"
#include <winfax.h>
#include "faxsvr.h"


class ATL_NO_VTABLE CFaxPorts :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CFaxPorts, &CLSID_FaxPorts>,
        public IDispatchImpl<IFaxPorts, &IID_IFaxPorts, &LIBID_FAXCOMLib>
{
public:
        CFaxPorts();
        ~CFaxPorts();
        BOOL Init(CFaxServer *pFaxServer);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXPORTS)

BEGIN_COM_MAP(CFaxPorts)
        COM_INTERFACE_ENTRY(IFaxPorts)
        COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxPorts
public:
        STDMETHOD(get_Item)(long Index, /*[out, retval]*/ VARIANT *pVal);
        STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

private:
    CFaxServer         *m_pFaxServer;
    DWORD               m_LastFaxError;
    DWORD               m_PortCount;
    CComVariant        *m_VarVect;

};

class ATL_NO_VTABLE CFaxPort :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxPort, &CLSID_FaxPort>,
    public IDispatchImpl<IFaxPort, &IID_IFaxPort, &LIBID_FAXCOMLib>
{
public:
    CFaxPort();
    ~CFaxPort();
    BOOL Initialize(CFaxServer*,DWORD,DWORD,DWORD,DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
    HANDLE GetPortHandle() { return m_FaxPortHandle; };
    DWORD GetDeviceId() { return m_DeviceId; };
    BSTR GetDeviceName() { return m_Name; };

DECLARE_REGISTRY_RESOURCEID(IDR_FAXPORT)

BEGIN_COM_MAP(CFaxPort)
    COM_INTERFACE_ENTRY(IFaxPort)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(GetStatus)(/*[out, retval]*/ VARIANT* retval);
    STDMETHOD(GetRoutingMethods)(VARIANT* retval);
    STDMETHOD(get_CanModify)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_Priority)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_Priority)(/*[in]*/ long newVal);
    STDMETHOD(get_Receive)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Receive)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Send)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Send)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Tsid)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Csid)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Rings)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_Rings)(/*[in]*/ long newVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);

private:
    BOOL ChangePort();

    CFaxServer         *m_pFaxServer;
    HANDLE              m_FaxPortHandle;
    BOOL                m_Send;
    BOOL                m_Receive;
    BOOL                m_Modify;
    BSTR                m_Name;
    BSTR                m_Csid;
    BSTR                m_Tsid;
    DWORD               m_LastFaxError;
    DWORD               m_DeviceId;
    DWORD               m_Rings;
    DWORD               m_Priority;

};

#endif //__FAXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxport.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxport.cpp

Abstract:

    This module implements the port interface/object.

Author:

    Wesley Witt (wesw) 20-May-1997

Revision History:

--*/

#include "stdafx.h"
#include "faxport.h"
#include "faxroute.h"
#include "status.h"



CFaxPort::CFaxPort()
{
    m_pFaxServer    = NULL;
    m_FaxPortHandle = NULL;
    m_LastFaxError  = NO_ERROR;
    m_DeviceId      = 0;
    m_Rings         = 0;
    m_Send          = FALSE;
    m_Receive       = FALSE;
    m_Name          = NULL;
    m_Csid          = NULL;
    m_Tsid          = NULL;
    m_Modify        = FALSE;
}


CFaxPort::~CFaxPort()
{
    if (m_FaxPortHandle) {
        FaxClose( m_FaxPortHandle );
    }
    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }
    if (m_Name) {
        SysFreeString( m_Name );
    }
    if (m_Csid) {
        SysFreeString( m_Csid );
    }
    if (m_Tsid) {
        SysFreeString( m_Tsid );
    }
}


BOOL
CFaxPort::Initialize(
    CFaxServer *i_pFaxServer,
    DWORD       i_DeviceId,
    DWORD       i_Rings,
    DWORD       i_Priority,
    DWORD       i_Flags,
    LPCWSTR     i_Csid,
    LPCWSTR     i_Tsid,
    LPCWSTR     i_DeviceName
    )
{
    HRESULT hr;
    
    m_pFaxServer = i_pFaxServer;
    m_DeviceId   = i_DeviceId;
    m_Rings      = i_Rings;
    m_Priority   = i_Priority;
    m_Csid       = SysAllocString( i_Csid);
    m_Tsid       = SysAllocString( i_Tsid);
    m_Name       = SysAllocString( i_DeviceName );
    m_Send       = i_Flags & FPF_SEND;
    m_Receive    = i_Flags & FPF_RECEIVE;    

    if ((!m_Csid && i_Csid) ||
        (!m_Tsid && i_Tsid) ||
        (!m_Name && i_DeviceName)) {
        SysFreeString( m_Csid );
        SysFreeString( m_Tsid );
        SysFreeString( m_Name );
        return FALSE;
    }

    if (!m_pFaxServer) {
        return FALSE;
    }

    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxOpenPort( m_pFaxServer->GetFaxHandle(), m_DeviceId, PORT_OPEN_MODIFY | PORT_OPEN_QUERY, &m_FaxPortHandle )) {
        if (GetLastError() == ERROR_ACCESS_DENIED) {
            if (!FaxOpenPort( m_pFaxServer->GetFaxHandle(), m_DeviceId, PORT_OPEN_QUERY, &m_FaxPortHandle )) {
                m_LastFaxError = GetLastError();
                return FALSE;
            }
        } else {
            m_LastFaxError = GetLastError();
            return FALSE;
        }
    } else {
        m_Modify = TRUE;
    }

    return TRUE;
}


STDMETHODIMP CFaxPort::get_CanModify(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Modify;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


BOOL CFaxPort::ChangePort()
{
    if (!m_Modify) {
        return FALSE;
    }

    //
    // get the current port configuration
    //

    PFAX_PORT_INFOW PortInfo = NULL;
    DWORD PortInfoSize = 0;

    if (!FaxGetPort( m_FaxPortHandle, &PortInfo )) {
        m_LastFaxError = GetLastError();
        return FALSE;
    }

    //
    // set the values
    //

    PortInfo->Rings     = m_Rings;
    PortInfo->Priority  = m_Priority;
    PortInfo->Flags     = (PortInfo->Flags &~ (FPF_SEND | FPF_RECEIVE)) | (m_Send ? FPF_SEND : 0) | (m_Receive ? FPF_RECEIVE : 0);
    PortInfo->Csid      = m_Csid;
    PortInfo->Tsid      = m_Tsid;

    //
    // change the server's port configuration
    //

    if (!FaxSetPort( m_FaxPortHandle, PortInfo )) {
        m_LastFaxError = GetLastError();
        FaxFreeBuffer( PortInfo );
        return FALSE;
    }

    //
    // clean up and bail
    //

    FaxFreeBuffer( PortInfo );

    return TRUE;
}


STDMETHODIMP CFaxPort::get_Name(BSTR *pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Name);

    if (!Copy  && m_Name) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
        
}


STDMETHODIMP CFaxPort::get_DeviceId(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
    
}


STDMETHODIMP CFaxPort::get_Rings(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Rings;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Rings(long newVal)
{
    long old = m_Rings;
    
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Rings = newVal;

    if (!ChangePort()) {
        m_Rings = old;
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;
}


STDMETHODIMP CFaxPort::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Csid);

    if (!Copy  && m_Csid) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Csid(BSTR newVal)
{
    BSTR old = m_Csid;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    BSTR tmp = SysAllocString(newVal);
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    m_Csid = tmp;
    
    if (!ChangePort()) {
        m_Csid = old;
        SysFreeString(tmp);
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }

    SysFreeString(old);

    return S_OK;

}


STDMETHODIMP CFaxPort::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Tsid);

    if (!Copy  && m_Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( m_Csid );
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Tsid(BSTR newVal)
{
    BSTR old = m_Tsid;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    BSTR tmp = SysAllocString(newVal);
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    m_Tsid = tmp;
    
    if (!ChangePort()) {
        m_Tsid = old;
        SysFreeString(tmp);
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }

    SysFreeString(old);
    return S_OK;

}


STDMETHODIMP CFaxPort::get_Send(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Send;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPort::put_Send(BOOL newVal)
{
    BOOL old = m_Send;

    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Send = newVal;
    
    if (!ChangePort()) {
        m_Send = old;
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;
}


STDMETHODIMP CFaxPort::get_Receive(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Receive;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Receive(BOOL newVal)
{
    BOOL old = m_Receive;
    
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Receive = newVal;

    if (!ChangePort()) {
        m_Receive = old;
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;

}


STDMETHODIMP CFaxPort::get_Priority(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Priority;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Priority(long newVal)
{
    long old = m_Priority;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }

    m_Priority = newVal;

    if (!ChangePort()) {
        m_Priority = old;
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;

}


STDMETHODIMP CFaxPort::GetRoutingMethods(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }
    
    CComObject<CFaxRoutingMethods>* p = new CComObject<CFaxRoutingMethods>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    __try {

        VariantInit(retval);
        
        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    pDisp->Release();
    delete p;

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPort::GetStatus(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }
    
    CComObject<CFaxStatus>* p = new CComObject<CFaxStatus>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    __try {

        VariantInit(retval);
        
        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    pDisp->Release();
    delete p;

    return E_UNEXPECTED;           
}


CFaxPorts::CFaxPorts()
{
    m_pFaxServer    = NULL;
    m_LastFaxError  = 0;
    m_PortCount     = 0;
    m_VarVect       = NULL;
}


CFaxPorts::~CFaxPorts()
{
    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }

    if (m_VarVect) {
        delete [] m_VarVect;
    }
    
}


BOOL CFaxPorts::Init(CFaxServer *pFaxServer)
{
    PFAX_PORT_INFOW     PortInfo = NULL;
    DWORD               PortInfoSize = 0;
    HRESULT             hr;

    //
    // get the ports from the server
    //
    if (!pFaxServer) {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxEnumPortsW( m_pFaxServer->GetFaxHandle(), &PortInfo, &m_PortCount )) {
        m_LastFaxError = GetLastError();
        return FALSE;
    }

    //
    // enumerate the ports
    //

    m_VarVect = new CComVariant[m_PortCount];
    if (!m_VarVect) {
        m_LastFaxError = ERROR_OUTOFMEMORY;
        FaxFreeBuffer( PortInfo );
        return FALSE;
    }

    for (DWORD i=0; i<m_PortCount; i++) {

        //
        // create the object
        //

        CComObject<CFaxPort> *pFaxPort;
        HRESULT hr = CComObject<CFaxPort>::CreateInstance( &pFaxPort );

        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;            
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        if (!pFaxPort->Initialize(
            pFaxServer,
            PortInfo[i].DeviceId,
            PortInfo[i].Rings,
            PortInfo[i].Priority,
            PortInfo[i].Flags,
            PortInfo[i].Csid,
            PortInfo[i].Tsid,
            PortInfo[i].DeviceName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = GetLastError();
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxPort->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //
        __try {
            CComVariant &var = m_VarVect[i];
            var.vt = VT_DISPATCH;
            var.pdispVal = lpDisp;

            hr = S_OK;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = E_UNEXPECTED;
        }

        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

    }

    FaxFreeBuffer( PortInfo );

    return TRUE;
}


STDMETHODIMP CFaxPorts::get_Count(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_PortCount;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPorts::get_Item(long Index, VARIANT *retval)
{       
    if (!retval) {
        return E_POINTER;
    }

    if ((Index < 1) || (Index > (long) m_PortCount)) {
        return E_INVALIDARG;
    }
    
    

    __try {
        VariantInit( retval );

        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        //
        // use 1-based index, VB like
        //
    
        return VariantCopy( retval, &m_VarVect[Index-1] );        

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxroute.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxroute.h

Abstract:

    This file implements the faxroute interface/object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXROUTE_H_
#define __FAXROUTE_H_

#include "resource.h"       // main symbols
#include "faxport.h"
#include <winfax.h>


class ATL_NO_VTABLE CFaxRoutingMethods :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxRoutingMethods, &CLSID_FaxRoutingMethods>,
    public IDispatchImpl<IFaxRoutingMethods, &IID_IFaxRoutingMethods, &LIBID_FAXCOMLib>
{
public:
    CFaxRoutingMethods();
    ~CFaxRoutingMethods();
    BOOL Init(CFaxPort *pFaxPort);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXROUTINGMETHODS)

BEGIN_COM_MAP(CFaxRoutingMethods)
    COM_INTERFACE_ENTRY(IFaxRoutingMethods)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:    
    STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Item)(/*[in]*/ long Index, /*[out, retval]*/ VARIANT *pVal);

private:
    DWORD               m_LastFaxError;
    CFaxPort           *m_pFaxPort;
    DWORD               m_MethodCount;
    CComVariant        *m_VarVect;
};


class ATL_NO_VTABLE CFaxRoutingMethod :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxRoutingMethod, &CLSID_FaxRoutingMethod>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxRoutingMethod, &IID_IFaxRoutingMethod, &LIBID_FAXCOMLib>
{
public:
    CFaxRoutingMethod();
    ~CFaxRoutingMethod();
    BOOL Initialize(CFaxPort *pFaxPort,DWORD,BOOL,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXROUTINGMETHOD)
DECLARE_NOT_AGGREGATABLE(CFaxRoutingMethod)

BEGIN_COM_MAP(CFaxRoutingMethod)
    COM_INTERFACE_ENTRY(IFaxRoutingMethod)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    STDMETHOD(get_RoutingData)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ExtensionName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_FriendlyName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ImageName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_FunctionName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Guid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Enable)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Enable)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);

private:
    CFaxPort           *m_pFaxPort;
    DWORD               m_LastFaxError;
    DWORD               m_DeviceId;
    BOOL                m_Enabled;
    BSTR                m_DeviceName;
    BSTR                m_Guid;
    BSTR                m_FunctionName;
    BSTR                m_ImageName;
    BSTR                m_FriendlyName;
    BSTR                m_ExtensionName;
    LPBYTE              m_RoutingData;

};

#endif //__FAXROUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxroute.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxroute.cpp

Abstract:

    This file implements the CFaxRoutingMethod and
    CFaxRoutingMethods interfaces.

Author:

    Wesley Witt (wesw) 1-June-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "faxroute.h"



CFaxRoutingMethod::CFaxRoutingMethod()
{
    m_pFaxPort      = NULL;
    m_LastFaxError  = NO_ERROR;
    m_DeviceId      = 0;
    m_Enabled       = FALSE;
    m_DeviceName    = NULL;
    m_Guid          = NULL;
    m_FunctionName  = NULL;
    m_ImageName     = NULL;
    m_FriendlyName  = NULL;
}


CFaxRoutingMethod::~CFaxRoutingMethod()
{
    if (m_pFaxPort) {
        m_pFaxPort->Release();
    }
    if (m_DeviceName) {
        SysFreeString( m_DeviceName );
    }
    if (m_Guid) {
        SysFreeString( m_Guid );
    }
    if (m_FunctionName) {
        SysFreeString( m_FunctionName );
    }
    if (m_ImageName) {
        SysFreeString( m_ImageName );
    }
    if (m_FriendlyName) {
        SysFreeString( m_FriendlyName );
    }
    if (m_ExtensionName) {
        SysFreeString( m_ExtensionName );
    }
    if (m_RoutingData) {
        FaxFreeBuffer( m_RoutingData );
    }
}


BOOL
CFaxRoutingMethod::Initialize(
    CFaxPort *i_pFaxPort,
    DWORD  i_DeviceId,
    BOOL   i_Enabled,
    LPCWSTR i_DeviceName,
    LPCWSTR i_Guid,
    LPCWSTR i_FunctionName,
    LPCWSTR i_FriendlyName,
    LPCWSTR i_ImageName,
    LPCWSTR i_ExtensionName
    )
{
    HRESULT hr;

    m_pFaxPort          = i_pFaxPort;
    m_DeviceId          = i_DeviceId;
    m_Enabled           = i_Enabled;
    m_DeviceName        = SysAllocString(i_DeviceName);
    m_Guid              = SysAllocString(i_Guid);
    m_FunctionName      = SysAllocString(i_FunctionName);
    m_ImageName         = SysAllocString(i_ImageName);
    m_FriendlyName      = SysAllocString(i_FriendlyName);
    m_ExtensionName     = SysAllocString(i_ExtensionName);
    m_RoutingData       = NULL;

    if ( (!m_DeviceName && i_DeviceName) ||
         (!m_Guid && i_Guid) ||
         (!m_FunctionName && i_FunctionName) ||
         (!m_ImageName && i_ImageName) ||
         (!m_FriendlyName && i_FriendlyName) ||
         (!m_ExtensionName && i_ExtensionName)
       ) {
        SysFreeString(m_DeviceName);   
        SysFreeString(m_Guid);         
        SysFreeString(m_FunctionName); 
        SysFreeString(m_ImageName);    
        SysFreeString(m_FriendlyName); 
        SysFreeString(m_ExtensionName);
        return FALSE;
    }

    if (!m_pFaxPort) {
        return FALSE;
    }

    hr = m_pFaxPort->AddRef();
    if (FAILED(hr)) {
        m_pFaxPort = NULL;
        return FALSE;
    }

    DWORD Size = 0;

    if (!FaxGetRoutingInfoW( m_pFaxPort->GetPortHandle(), m_Guid, &m_RoutingData, &Size )) {
        m_RoutingData = NULL;
        m_LastFaxError = GetLastError();
        return FALSE;
    }

    if (Size == 0) {
        FaxFreeBuffer( m_RoutingData );
        m_RoutingData = NULL;
    }

    return TRUE;
}


STDMETHODIMP CFaxRoutingMethod::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = { &IID_IFaxRoutingMethod };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++) {
        if (InlineIsEqualGUID(*arr[i],riid)) {
            return S_OK;
        }
    }

    return S_FALSE;
}


STDMETHODIMP CFaxRoutingMethod::get_DeviceId(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxRoutingMethod::get_Enable(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_Enabled;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
    
}


STDMETHODIMP CFaxRoutingMethod::put_Enable(BOOL newVal)
{
    if (!FaxEnableRoutingMethodW( m_pFaxPort->GetPortHandle(), m_Guid, newVal)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    m_Enabled = newVal;
    return S_OK;
}


STDMETHODIMP CFaxRoutingMethod::get_DeviceName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_DeviceName);

    if (!Copy  && m_DeviceName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
        
}


STDMETHODIMP CFaxRoutingMethod::get_Guid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Guid);

    if (!Copy  && m_Guid) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
        
}


STDMETHODIMP CFaxRoutingMethod::get_FunctionName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_FunctionName);

    if (!Copy  && m_FunctionName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    

}


STDMETHODIMP CFaxRoutingMethod::get_ImageName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_ImageName);

    if (!Copy  && m_ImageName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;        
}


STDMETHODIMP CFaxRoutingMethod::get_FriendlyName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_FriendlyName);

    if (!Copy  && m_FriendlyName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;            
}


STDMETHODIMP CFaxRoutingMethod::get_ExtensionName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_ExtensionName);

    if (!Copy  && m_ExtensionName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;            
}


STDMETHODIMP CFaxRoutingMethod::get_RoutingData(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;

    Copy = NULL;
    __try {

        if (m_RoutingData == NULL) {        
            Copy = SysAllocString( L"" );            
        } else if (*((LPDWORD)m_RoutingData) == 0 || *((LPDWORD)m_RoutingData) == 1) {
            Copy = SysAllocString( (LPWSTR)(m_RoutingData + sizeof(DWORD)) );
            if (!Copy && (LPWSTR)(m_RoutingData + sizeof(DWORD))) {
                return E_OUTOFMEMORY;
            }
        } else {
            return E_UNEXPECTED;
        }

        if (!Copy) {
            return E_OUTOFMEMORY;
        }

        *pVal = Copy;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        if (Copy != NULL) {
            SysFreeString(Copy);
	}
    }


    return E_UNEXPECTED;
}


CFaxRoutingMethods::CFaxRoutingMethods()
{
    m_pFaxPort      = NULL;
    m_LastFaxError  = 0;
    m_MethodCount   = 0;
    m_VarVect       = NULL;
}


CFaxRoutingMethods::~CFaxRoutingMethods()
{
    if (m_pFaxPort) {
        m_pFaxPort->Release();
    }

    if (m_VarVect) {
        delete [] m_VarVect;
    }
}


BOOL CFaxRoutingMethods::Init(CFaxPort *pFaxPort)
{
    HRESULT hr;
    
    if (!pFaxPort) {
        return FALSE;
    }

    m_pFaxPort = pFaxPort;
    hr = m_pFaxPort->AddRef();
    if (FAILED(hr)) {
        m_pFaxPort = NULL;
        return FALSE;
    }

    PFAX_ROUTING_METHODW RoutingMethod = NULL;
    DWORD Size = 0;

    //
    // get the routing methods from the server
    //

    if (!FaxEnumRoutingMethodsW( m_pFaxPort->GetPortHandle(), &RoutingMethod, &m_MethodCount )) {
        m_LastFaxError = GetLastError();        
        return FALSE;
    }

    //
    // enumerate the methods
    //

    m_VarVect = new CComVariant[m_MethodCount];
    if (!m_VarVect) {
        FaxFreeBuffer( RoutingMethod );
        return FALSE;
    }

    for (DWORD i=0; i<m_MethodCount; i++) {

        //
        // create the object
        //

        CComObject<CFaxRoutingMethod> *pFaxRoutingMethod;
        HRESULT hr = CComObject<CFaxRoutingMethod>::CreateInstance( &pFaxRoutingMethod );
        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }

        //
        // set the values
        //

        if (!pFaxRoutingMethod->Initialize(
            m_pFaxPort,
            RoutingMethod[i].DeviceId,
            RoutingMethod[i].Enabled,
            RoutingMethod[i].DeviceName,
            RoutingMethod[i].Guid,
            RoutingMethod[i].FunctionName,
            RoutingMethod[i].FriendlyName,
            RoutingMethod[i].ExtensionImageName,
            RoutingMethod[i].ExtensionFriendlyName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxRoutingMethod->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //

        CComVariant &var = m_VarVect[i];
        __try {
            var.vt = VT_DISPATCH;
            var.pdispVal = lpDisp;
            hr = S_OK;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = E_UNEXPECTED;            
        }

        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }
    }

    FaxFreeBuffer( RoutingMethod );

    return TRUE;
}


STDMETHODIMP CFaxRoutingMethods::get_Item(long Index, VARIANT * retval)
{
    if (!retval) {
        return E_POINTER;
    }

    //
    // use 1-based index, VB like
    //

    if ((Index < 1) || (Index > (long) m_MethodCount)) {
        return E_INVALIDARG;
    }

    __try {
        VariantInit( retval );
    
        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        return VariantCopy( retval, &m_VarVect[Index-1] );
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }    

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxRoutingMethods::get_Count(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_MethodCount;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by faxcom.rc
//

#define IDR_FAXTIFF                     101
#define IDR_FAXSERVER                   102
#define IDR_FAXPORT                     103
#define IDR_FAXPORTS                    104
#define IDR_FAXROUTINGMETHOD            105
#define IDR_FAXROUTINGMETHODS           106
#define IDR_FAXSTATUS                   107
#define IDR_FAXDOC                      108
#define IDR_FAXJOBS                     109
#define IDR_FAXJOB                      111

#define IDS_PROJNAME                    100
#define IDS_UNAVAILABLE                 101
#define IDS_JOB_PENDING                 102
#define IDS_JOB_INPROGRESS              103
#define IDS_JOB_DELETING                104
#define IDS_JOB_FAILED                  105
#define IDS_JOB_PAUSED                  106

#define IDS_DEVICE_DIALING              107
#define IDS_DEVICE_SENDING              108
#define IDS_DEVICE_RECEIVING            109
#define IDS_DEVICE_COMPLETED            110
#define IDS_DEVICE_HANDLED              111
#define IDS_DEVICE_UNAVAILABLE          112
#define IDS_DEVICE_BUSY                 113
#define IDS_DEVICE_NOANSWER             114
#define IDS_DEVICE_BADADDRESS           115
#define IDS_DEVICE_NODIALTONE           116
#define IDS_DEVICE_DISCONNECTED         117
#define IDS_DEVICE_FATALERROR           118
#define IDS_DEVICE_NOTFAXCALL           119
#define IDS_DEVICE_CALLDELAYED          120
#define IDS_DEVICE_BLACKLISTED          121
#define IDS_DEVICE_INITIALIZING         122
#define IDS_DEVICE_OFFLINE              123
#define IDS_DEVICE_RINGING              124
#define IDS_DEVICE_AVAILABLE            125
#define IDS_DEVICE_ABORTING             126
#define IDS_DEVICE_ROUTING              127
#define IDS_DEVICE_ANSWERED             128
#define IDS_DEVICE_UNKNOWN              129
#define IDS_JOB_UNKNOWN                 130

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxsvr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxsvr.cpp

Abstract:

    This file implements the CFaxServer interface.

Author:

    Wesley Witt (wesw) 1-June-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "faxsvr.h"
#include "faxport.h"
#include "FaxDoc.h"
#include "FaxJob.h"




CFaxServer::CFaxServer()
{
    m_LastFaxError			= NO_ERROR;
    m_FaxHandle				= 0;
	m_Retries				= 0;
	m_RetryDelay			= 0;
	m_DirtyDays				= 0;
	m_UseDeviceTsid			= FALSE;
	m_ServerCp				= FALSE;
	m_PauseServerQueue		= FALSE;;
	m_StartCheapTime.Hour	= 0;
    m_StartCheapTime.Minute	= 0;
	m_StopCheapTime.Hour    = 0;
    m_StartCheapTime.Minute	= 0;
	m_ArchiveOutgoingFaxes  = FALSE;;
	m_ArchiveDirectory		= NULL;
	m_InboundProfile		= NULL;
}


CFaxServer::~CFaxServer()
{
    if (m_FaxHandle) {
        FaxClose( m_FaxHandle );
    }

	if (m_ArchiveDirectory)
		SysFreeString(m_ArchiveDirectory);	
	if (m_InboundProfile)
		SysFreeString(m_InboundProfile);


}


STDMETHODIMP CFaxServer::Connect(BSTR ServerName)
{
    if (!FaxConnectFaxServer( ServerName, &m_FaxHandle )) {
        m_LastFaxError = GetLastError();
        m_FaxHandle = NULL;
        return E_FAIL;
    }

    DWORD FaxServerVersion = 0;

    if (!FaxGetVersion( m_FaxHandle, &FaxServerVersion )) {
        m_LastFaxError = GetLastError();
        FaxClose( m_FaxHandle );
        m_FaxHandle = NULL;
        return E_FAIL;
    }

	if (!RetrieveConfiguration()) {
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	
    return S_OK;
}

STDMETHODIMP CFaxServer::Disconnect()
{
    if (m_FaxHandle == NULL) {
        return E_FAIL;
    }

    if (!FaxClose( m_FaxHandle )) {
        return E_FAIL;
    }

    m_FaxHandle = NULL;
	m_Retries = 0;
	m_RetryDelay = 0;
	m_DirtyDays = 0 ;
	m_Branding = FALSE;
	m_UseDeviceTsid = FALSE;
	m_ServerCp = FALSE;
	m_PauseServerQueue = FALSE;
	m_StartCheapTime.Hour = 0;
	m_StartCheapTime.Minute = 0;
	m_StopCheapTime.Hour = 0;
	m_StopCheapTime.Minute = 0;
	m_StartCheapTime.Hour = 0;
	m_ArchiveOutgoingFaxes = FALSE;
	if (m_ArchiveDirectory)
		SysFreeString(m_ArchiveDirectory);
	m_ArchiveDirectory = NULL;
	if (m_InboundProfile)
		SysFreeString(m_InboundProfile);
	m_InboundProfile = NULL;

    return S_OK;
}

STDMETHODIMP CFaxServer::GetPorts(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }

    CComObject<CFaxPorts>* p = new CComObject<CFaxPorts>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;        
    }

    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxServer::CreateDocument(BSTR FileName, VARIANT * retval)
{
    HRESULT hr;

    if (!FileName || !retval) {
        return E_POINTER;
    }

    CComObject<CFaxDoc>* p = new CComObject<CFaxDoc>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(FileName,this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    
    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::GetJobs(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return(E_POINTER);
    }
    
    CComObject<CFaxJobs>* p = new CComObject<CFaxJobs>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }
    
    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }
    
    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::get_Retries(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_Retries;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_Retries(long newVal)
{
    long oldval = m_Retries;

	m_Retries = newVal;
	
	if (!UpdateConfiguration() ) {
        m_Retries = oldval;
		return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_RetryDelay(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_RetryDelay;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_RetryDelay(long newVal)
{
    long oldval = m_RetryDelay;
	m_RetryDelay = newVal;
	
    if (!UpdateConfiguration() ) {
        m_RetryDelay = oldval;    
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;
}

STDMETHODIMP CFaxServer::get_DirtyDays(long * pVal)
{
    if (!pVal) {
    return E_POINTER;
    }

    __try {
        *pVal = m_DirtyDays;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    
    }

    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxServer::put_DirtyDays(long newVal)
{
	long oldval = m_DirtyDays;
    m_DirtyDays = newVal;
	
    if (!UpdateConfiguration() ) {
        m_DirtyDays = oldval;    
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;

}

STDMETHODIMP CFaxServer::get_Branding(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_Branding;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_Branding(BOOL newVal)
{
	BOOL oldval = m_Branding;
    m_Branding = newVal;
	
    if (!UpdateConfiguration() ) {
        m_Branding = oldval;
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;

}

STDMETHODIMP CFaxServer::get_UseDeviceTsid(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_UseDeviceTsid;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_UseDeviceTsid(BOOL newVal)
{
	BOOL oldval = m_UseDeviceTsid;
    m_UseDeviceTsid= newVal;
	
	if (!UpdateConfiguration() ) {
        m_UseDeviceTsid = oldval;
		return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;


}

STDMETHODIMP CFaxServer::get_ServerCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_ServerCp;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_ServerCoverpage(BOOL newVal)
{
	BOOL oldval = m_ServerCp;
    m_ServerCp = newVal;
	
	if (!UpdateConfiguration() ) {
		m_ServerCp = oldval;
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_PauseServerQueue(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_PauseServerQueue;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_PauseServerQueue(BOOL newVal)
{
	BOOL oldval = m_PauseServerQueue;
    m_PauseServerQueue = newVal;
	
	if (!UpdateConfiguration() ) {
		m_PauseServerQueue = oldval;
        return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_ArchiveOutboundFaxes(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_ArchiveOutgoingFaxes;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_ArchiveOutboundFaxes(BOOL newVal)
{
	BOOL oldval = m_ArchiveOutgoingFaxes;
    m_ArchiveOutgoingFaxes = newVal;
	
	if (!UpdateConfiguration() ) {
        m_ArchiveOutgoingFaxes = oldval;
		return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;


}

STDMETHODIMP CFaxServer::get_ArchiveDirectory(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_ArchiveDirectory);

    if (!Copy  && m_ArchiveDirectory) {
        return E_OUTOFMEMORY;
    }
    
    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_ArchiveDirectory(BSTR newVal)
{
	BSTR tmp = SysAllocString(newVal);
    BSTR old = m_ArchiveDirectory;
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
        
    m_ArchiveDirectory = tmp;    
	
	if (!UpdateConfiguration() ) {
        SysFreeString(tmp);
        m_ArchiveDirectory = old;
		return HRESULT_FROM_WIN32(m_LastFaxError);
    } else {
        SysFreeString(old);        
        return S_OK;
    }
}

STDMETHODIMP CFaxServer::get_ServerMapiProfile(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_InboundProfile);

    if (!Copy  && m_InboundProfile) {
        return E_OUTOFMEMORY;
    }
    
    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_ServerMapiProfile(BSTR newVal)
{
	BSTR tmp = SysAllocString(newVal);
    BSTR old = m_InboundProfile;
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    m_InboundProfile = tmp;

    if (!UpdateConfiguration() ) {
        SysFreeString(tmp);
        m_InboundProfile = old;
        return HRESULT_FROM_WIN32(m_LastFaxError);
    } else {
        SysFreeString(old);
        return S_OK;
    }
}

STDMETHODIMP CFaxServer::get_DiscountRateStartHour(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StartCheapTime.Hour;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_DiscountRateStartHour(short newVal)
{
	short old = m_StartCheapTime.Hour;
    m_StartCheapTime.Hour = newVal;

	if (!UpdateConfiguration() ) {
        m_StartCheapTime.Hour = old;
		return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateStartMinute(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StartCheapTime.Minute;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_DiscountRateStartMinute(short newVal)
{
	short old = m_StartCheapTime.Minute;
    m_StartCheapTime.Minute = newVal;

	if (!UpdateConfiguration() ) {
        m_StartCheapTime.Minute = old;
		return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateEndHour(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StopCheapTime.Hour;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_DiscountRateEndHour(short newVal)
{
	short old = m_StopCheapTime.Hour;
    m_StopCheapTime.Hour = newVal;

	if (!UpdateConfiguration() ) {
        m_StopCheapTime.Hour = old;
		return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateEndMinute(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StopCheapTime.Minute;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_DiscountRateEndMinute(short newVal)
{
	short old = m_StopCheapTime.Minute;
    m_StopCheapTime.Minute = newVal;

	if (!UpdateConfiguration() ) {
        m_StopCheapTime.Minute = old;
		return HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}


BOOL CFaxServer::RetrieveConfiguration()
{	    
    if (!m_FaxHandle) {
		return FALSE;
	}

	PFAX_CONFIGURATIONW FaxConfig;

	if (!FaxGetConfigurationW(m_FaxHandle,&FaxConfig) ) {
		m_LastFaxError = GetLastError();
		return FALSE;
	}

	m_Retries = FaxConfig->Retries;
	m_RetryDelay =FaxConfig->RetryDelay;
	m_DirtyDays = FaxConfig->DirtyDays;
	m_Branding = FaxConfig->Branding;
	m_UseDeviceTsid = FaxConfig->UseDeviceTsid;
	m_ServerCp = FaxConfig->ServerCp;
	m_PauseServerQueue = FaxConfig->PauseServerQueue;
	m_StartCheapTime.Hour = FaxConfig->StartCheapTime.Hour;
	m_StartCheapTime.Minute = FaxConfig->StartCheapTime.Minute;
	m_StopCheapTime.Hour = FaxConfig->StopCheapTime.Hour;
	m_StopCheapTime.Minute = FaxConfig->StopCheapTime.Minute;
	m_StartCheapTime.Hour = FaxConfig->StartCheapTime.Hour;
	m_ArchiveOutgoingFaxes = FaxConfig->ArchiveOutgoingFaxes;
	m_ArchiveDirectory = SysAllocString(FaxConfig->ArchiveDirectory);
    if ((!m_ArchiveDirectory && FaxConfig->ArchiveDirectory)) {
        m_LastFaxError = ERROR_OUTOFMEMORY;
    }
	m_InboundProfile = SysAllocString(FaxConfig->InboundProfile);
    if ((!m_InboundProfile && FaxConfig->InboundProfile)) {
        m_LastFaxError = ERROR_OUTOFMEMORY;
    }

    FaxFreeBuffer(FaxConfig);    

    return (m_LastFaxError == NO_ERROR) ? TRUE : FALSE;

}

BOOL CFaxServer::UpdateConfiguration()
{
	if (!m_FaxHandle) {
		return FALSE;
	}

	FAX_CONFIGURATIONW FaxConfig;

	ZeroMemory(&FaxConfig,sizeof(FAX_CONFIGURATIONW) );
    FaxConfig.SizeOfStruct = sizeof(FAX_CONFIGURATIONW);
	FaxConfig.Retries = m_Retries;
	FaxConfig.RetryDelay = m_RetryDelay ;
	FaxConfig.DirtyDays = m_DirtyDays;
	FaxConfig.Branding = m_Branding;
	FaxConfig.UseDeviceTsid = m_UseDeviceTsid;
	FaxConfig.ServerCp = m_ServerCp;
	FaxConfig.PauseServerQueue = m_PauseServerQueue;
	FaxConfig.StartCheapTime.Hour = m_StartCheapTime.Hour;
	FaxConfig.StartCheapTime.Minute = m_StartCheapTime.Minute;
	FaxConfig.StopCheapTime.Hour = m_StopCheapTime.Hour;
	FaxConfig.StopCheapTime.Minute = m_StopCheapTime.Minute;
	FaxConfig.StartCheapTime.Hour = m_StartCheapTime.Hour;
	FaxConfig.ArchiveOutgoingFaxes = m_ArchiveOutgoingFaxes;
	FaxConfig.ArchiveDirectory = m_ArchiveDirectory;
	FaxConfig.InboundProfile = m_InboundProfile;

	if (!FaxSetConfigurationW(m_FaxHandle,&FaxConfig) ) {
		m_LastFaxError = GetLastError();
		return FALSE;
	}

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxsvr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxsvr.h

Abstract:

    This module contains the fax server class definitions.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#ifndef __FAXSERVER_H_
#define __FAXSERVER_H_

#include "resource.h"       // main symbols
#include "winfax.h"
#include "winfaxp.h"

class ATL_NO_VTABLE CFaxServer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxServer, &CLSID_FaxServer>,
    public IDispatchImpl<IFaxServer, &IID_IFaxServer, &LIBID_FAXCOMLib>
{
public:
    CFaxServer();
    ~CFaxServer();
    HANDLE GetFaxHandle() { return m_FaxHandle; };

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSERVER)

BEGIN_COM_MAP(CFaxServer)
    COM_INTERFACE_ENTRY(IFaxServer)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
	STDMETHOD(get_DiscountRateEndMinute)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateEndMinute)(/*[in]*/ short newVal);
	STDMETHOD(get_DiscountRateEndHour)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateEndHour)(/*[in]*/ short newVal);
    STDMETHOD(get_DiscountRateStartMinute)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateStartMinute)(/*[in]*/ short newVal);
	STDMETHOD(get_DiscountRateStartHour)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateStartHour)(/*[in]*/ short newVal);
	STDMETHOD(get_ServerMapiProfile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ServerMapiProfile)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ArchiveDirectory)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ArchiveDirectory)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ArchiveOutboundFaxes)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ArchiveOutboundFaxes)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_PauseServerQueue)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_PauseServerQueue)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_ServerCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ServerCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_UseDeviceTsid)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_UseDeviceTsid)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_Branding)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Branding)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_DirtyDays)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DirtyDays)(/*[in]*/ long newVal);
	STDMETHOD(get_RetryDelay)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_RetryDelay)(/*[in]*/ long newVal);
	STDMETHOD(get_Retries)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Retries)(/*[in]*/ long newVal);
	STDMETHOD(GetJobs)(VARIANT *retval);
	STDMETHOD(CreateDocument)(BSTR FileName, VARIANT *retval);
    STDMETHOD(GetPorts)(VARIANT* retval);
    STDMETHOD(Disconnect)();
    STDMETHOD(Connect)(BSTR ServerName);

private:
	BOOL UpdateConfiguration();
	BOOL RetrieveConfiguration();
    DWORD   m_LastFaxError;
    HANDLE  m_FaxHandle;
    BOOL		m_Branding;
	DWORD		m_Retries;
	DWORD		m_RetryDelay;
	DWORD		m_DirtyDays;
	BOOL		m_UseDeviceTsid;
	BOOL		m_ServerCp;
	BOOL		m_PauseServerQueue;
	FAX_TIME	m_StartCheapTime;
	FAX_TIME	m_StopCheapTime;
	BOOL		m_ArchiveOutgoingFaxes;
	BSTR		m_ArchiveDirectory;
	BSTR		m_InboundProfile;

};


BSTR GetDeviceStatus(DWORD);
BSTR GetQueueStatus(DWORD);

#endif //__FAXSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxtiff.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxtiff.h

Abstract:

    This file contains the class definition for the faxtiff object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXTIFF_H_
#define __FAXTIFF_H_

#include "resource.h"       // main symbols
#include "tiff.h"


class ATL_NO_VTABLE CFaxTiff :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxTiff, &CLSID_FaxTiff>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxTiff, &IID_IFaxTiff, &LIBID_FAXCOMLib>
{
public:
    CFaxTiff();
    ~CFaxTiff();

DECLARE_REGISTRY_RESOURCEID(IDR_FAXTIFF)

BEGIN_COM_MAP(CFaxTiff)
    COM_INTERFACE_ENTRY(IFaxTiff)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxTiff
public:
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Routing)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RecipientNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Image)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Image)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ReceiveTime)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RawReceiveTime)(/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(get_TiffTagString)(/*[in]*/ WORD tagID, /*[out, retval]*/ BSTR* pVal);       

private:
    LPWSTR      GetStringTag(WORD TagId);
    DWORD       GetDWORDTag(WORD TagId);
    DWORDLONG   GetQWORDTag(WORD TagId);
    BSTR        GetString( DWORD ResId );
    LPWSTR      AnsiStringToUnicodeString(LPSTR AnsiString);
    LPSTR       UnicodeStringToAnsiString(LPWSTR UnicodeString);


private:
    WCHAR TiffFileName[MAX_PATH+1];
    WCHAR StrBuf[128];
    HANDLE hFile;
    HANDLE hMap;
    LPBYTE fPtr;
    PTIFF_HEADER TiffHeader;
    DWORD NumDirEntries;
    UNALIGNED TIFF_TAG *TiffTags;
};

#endif //__FAXTIFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\status.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    status.cpp

Abstract:

    This module implements the status interface/object.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#include "stdafx.h"
#include "faxcom.h"
#include "status.h"



CFaxStatus::CFaxStatus()
{
    m_pFaxPort          = NULL;
    m_Tsid              = NULL;
    m_Description       = NULL;
    m_RecipientName     = NULL;
    m_SenderName        = NULL;
    m_RoutingString     = NULL;
    m_Address           = NULL;
    m_DocName           = NULL;
    m_DeviceName        = NULL;
    m_Csid              = NULL;
    m_CallerId          = NULL;

    m_Receive           = FALSE;
    m_Send              = FALSE;

    m_PageCount         = 0;
    m_DocSize           = 0;
    m_DeviceId          = 0;
    m_CurrentPage       = 0;

    ZeroMemory( &m_StartTime, sizeof(m_StartTime) );
    ZeroMemory( &m_SubmittedTime, sizeof(m_SubmittedTime) );
    ZeroMemory( &m_ElapsedTime, sizeof(m_ElapsedTime) );
}


CFaxStatus::~CFaxStatus()
{
    if (m_pFaxPort) {
        m_pFaxPort->Release();
    }

    FreeMemory();
}


void CFaxStatus::FreeMemory()
{
    if (m_Tsid) {
        SysFreeString( m_Tsid );
    }
    if (m_Description) {
        SysFreeString( m_Description );
    }
    if (m_RecipientName) {
        SysFreeString( m_RecipientName );
    }
    if (m_SenderName) {
        SysFreeString( m_SenderName );
    }
    if (m_RoutingString) {
        SysFreeString( m_RoutingString );
    }    
    if (m_Address) {
        SysFreeString( m_Address );
    }
    if (m_DocName) {
        SysFreeString( m_DocName );
    }
    if (m_DeviceName) {
        SysFreeString( m_DeviceName );
    }
    if (m_Csid) {
        SysFreeString( m_Csid );
    }
    if (m_CallerId) {
        SysFreeString( m_CallerId );
    }

    m_Tsid              = NULL;
    m_Description       = NULL;
    m_RecipientName     = NULL;
    m_SenderName        = NULL;
    m_RoutingString     = NULL;    
    m_Address           = NULL;
    m_DocName           = NULL;
    m_DeviceName        = NULL;
    m_Csid              = NULL;
    m_CallerId          = NULL;

    m_Receive           = FALSE;
    m_Send              = FALSE;

    m_PageCount         = 0;
    m_DocSize           = 0;    
    m_DeviceId          = 0;
    m_CurrentPage       = 0;

    ZeroMemory( &m_StartTime, sizeof(m_StartTime) );
    ZeroMemory( &m_SubmittedTime, sizeof(m_SubmittedTime) );
    ZeroMemory( &m_ElapsedTime, sizeof(m_ElapsedTime) );
}


BOOL CFaxStatus::Init(CFaxPort *pFaxPort)
{
    HRESULT hr;
    
    m_pFaxPort = pFaxPort;
    
    hr = m_pFaxPort->AddRef();
    if (FAILED(hr)) {
        m_pFaxPort = NULL;
        return FALSE;
    }

    hr = Refresh();
    if (FAILED(hr)) {
        return FALSE;
    }
    return TRUE;
}


STDMETHODIMP CFaxStatus::Refresh()
{
    PFAX_DEVICE_STATUSW FaxStatus = NULL;
    DWORD Size = 0;
    DWORDLONG ElapsedTime;
    DWORDLONG CurrentFileTime;
    SYSTEMTIME CurrentTime;
    HRESULT hr = S_OK;


    if (!FaxGetDeviceStatusW( m_pFaxPort->GetPortHandle(), &FaxStatus )) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    FreeMemory();

    m_PageCount         = FaxStatus->TotalPages;
    m_DocSize           = FaxStatus->Size;
    m_DeviceId          = m_pFaxPort->GetDeviceId();
    m_CurrentPage       = FaxStatus->CurrentPage;

    m_Receive           = FaxStatus->JobType == JT_RECEIVE ? TRUE : FALSE;
    m_Send              = FaxStatus->JobType == JT_SEND ? TRUE : FALSE;

    if (FaxStatus->Tsid) {
        m_Tsid = SysAllocString( FaxStatus->Tsid );
        if (!m_Tsid) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->StatusString) {
        m_Description = SysAllocString( FaxStatus->StatusString );
        if (!m_Description) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->RecipientName) {
        m_RecipientName = SysAllocString( FaxStatus->RecipientName );
        if (!m_RecipientName) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->SenderName) {
        m_SenderName = SysAllocString( FaxStatus->SenderName );
        if (!m_SenderName) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->RoutingString) {
        m_RoutingString = SysAllocString( FaxStatus->RoutingString );
        if (!m_RoutingString) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->PhoneNumber) {
        m_Address = SysAllocString( FaxStatus->PhoneNumber );
        if (!m_Address) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->DocumentName) {
        m_DocName = SysAllocString( FaxStatus->DocumentName );
        if (!m_DocName) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->DeviceName) {
        m_DeviceName = SysAllocString( FaxStatus->DeviceName );
        if (!m_DeviceName) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->Csid) {
        m_Csid = SysAllocString( FaxStatus->Csid );
        if (!m_Csid) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FaxStatus->CallerId) {
        m_CallerId = SysAllocString( FaxStatus->CallerId );
        if (!m_CallerId) {
            hr = E_OUTOFMEMORY;
        }
    }

    m_Description = GetDeviceStatus(FaxStatus->Status);
    if (!m_Description) {
        hr = E_OUTOFMEMORY;
    }

    FileTimeToSystemTime( &FaxStatus->StartTime, &m_StartTime );
    FileTimeToSystemTime( &FaxStatus->SubmittedTime, &m_SubmittedTime );

    GetSystemTime( &CurrentTime );
    SystemTimeToFileTime( &CurrentTime, (FILETIME*)&ElapsedTime );
    SystemTimeToFileTime( &m_StartTime, (FILETIME*)&CurrentFileTime );

    ElapsedTime = ElapsedTime - CurrentFileTime;

    FileTimeToSystemTime( (FILETIME*)&ElapsedTime, &m_ElapsedTime );

    FaxFreeBuffer( FaxStatus );

    return hr;
}


STDMETHODIMP CFaxStatus::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = { &IID_IFaxStatus };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++) {
        if (InlineIsEqualGUID(*arr[i],riid)) {
            return S_OK;
        }
    }

    return S_FALSE;
}


STDMETHODIMP CFaxStatus::get_CallerId(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_CallerId);

    if (!Copy  && m_CallerId) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Csid);

    if (!Copy  && m_Csid) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_CurrentPage(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_CurrentPage;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DeviceId(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DeviceName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_DeviceName);

    if (!Copy  && m_DeviceName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DocumentName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_DocName);

    if (!Copy  && m_DocName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Send(BOOL * pVal)
{
    *pVal = m_Send;
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_Receive(BOOL * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_Receive;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Address(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Address);

    if (!Copy  && m_Address) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;}


STDMETHODIMP CFaxStatus::get_RoutingString(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_RoutingString);

    if (!Copy  && m_RoutingString) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_SenderName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_SenderName);

    if (!Copy  && m_SenderName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_RecipientName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_RecipientName);

    if (!Copy  && m_RecipientName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DocumentSize(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DocSize;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Description(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Description);

    if (!Copy  && m_Description) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_PageCount(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_PageCount;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Tsid);

    if (!Copy  && m_Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy ;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_StartTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_StartTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_SubmittedTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_SubmittedTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_ElapsedTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_ElapsedTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\faxtiff.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxtiff.cpp

Abstract:

    This file implements the FaxTiff object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "FaxTiff.h"


CFaxTiff::CFaxTiff()
{
    hFile = INVALID_HANDLE_VALUE;
    hMap = NULL;
    fPtr = NULL;
}


CFaxTiff::~CFaxTiff()
{
    if (hFile != INVALID_HANDLE_VALUE) {
        UnmapViewOfFile( fPtr );
        CloseHandle( hMap );
        CloseHandle( hFile );
    }
}


BSTR CFaxTiff::GetString( DWORD ResId )
{
    WCHAR TmpBuf[MAX_PATH];
    
    ::LoadString( _Module.GetModuleInstance(), ResId, TmpBuf, sizeof(TmpBuf)/sizeof(WCHAR) );

    return SysAllocString( TmpBuf ) ;

}


LPWSTR
CFaxTiff::AnsiStringToUnicodeString(
    LPSTR AnsiString
    )
{
    DWORD Count;
    LPWSTR UnicodeString;


    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    UnicodeString = (LPWSTR) LocalAlloc( LPTR, Count * sizeof(UNICODE_NULL) );
    if (!UnicodeString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        LocalFree( UnicodeString );
        return NULL;
    }

    return UnicodeString;
}

LPSTR
CFaxTiff::UnicodeStringToAnsiString(
    LPWSTR UnicodeString
    )
{
    DWORD Count;
    LPSTR AnsiString;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    AnsiString = (LPSTR) LocalAlloc( LPTR, Count );
    if (!AnsiString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        LocalFree( AnsiString );
        return NULL;
    }

    return AnsiString;
}



LPWSTR CFaxTiff::GetStringTag(WORD TagId)
{
    for (DWORD i=0; i<NumDirEntries; i++) {
        if (TiffTags[i].TagId == TagId) {
            if (TiffTags[i].DataType != TIFF_ASCII) {
                return NULL;
            }
            if (TiffTags[i].DataCount > 4) {
                return AnsiStringToUnicodeString( (LPSTR) (fPtr + TiffTags[i].DataOffset) );
            }
            return AnsiStringToUnicodeString( (LPSTR) &TiffTags[i].DataOffset );
        }
    }

    return NULL;
}


DWORD CFaxTiff::GetDWORDTag(WORD TagId)
{
    for (DWORD i=0; i<NumDirEntries; i++) {
        if (TiffTags[i].TagId == TagId) {
            if (TiffTags[i].DataType != TIFF_LONG) {
                return 0;
            }
            return TiffTags[i].DataOffset;
        }
    }
    return 0;
}


DWORDLONG CFaxTiff::GetQWORDTag(WORD TagId)
{
    for (DWORD i=0; i<NumDirEntries; i++) {
        if (TiffTags[i].TagId == TagId) {
            if (TiffTags[i].DataType != TIFF_SRATIONAL) {
                return 0;
            }
            return *(UNALIGNED DWORDLONG*) (fPtr + TiffTags[i].DataOffset);
        }
    }
    return 0;
}


STDMETHODIMP CFaxTiff::InterfaceSupportsErrorInfo(REFIID riid)
{
        static const IID* arr[] =
        {
                &IID_IFaxTiff,
        };
        for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
        {
                if (InlineIsEqualGUID(*arr[i],riid))
                        return S_OK;
        }
        return S_FALSE;
}

STDMETHODIMP CFaxTiff::get_ReceiveTime(BSTR * pVal)
{
    BSTR Copy = NULL;
    DWORD StrSize = 0;
    WCHAR DateStr[256];
    WCHAR TimeStr[128];
    FILETIME LocalTime;
    SYSTEMTIME SystemTime;
    DWORDLONG ReceiveTime;
    BOOL bFail = FALSE;

    if (!pVal) {
        return E_POINTER;
    }
    
    ReceiveTime = GetQWORDTag( TIFFTAG_FAX_TIME );
    if (ReceiveTime == 0) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
        goto copy;
    }

    

    FileTimeToLocalFileTime( (FILETIME*) &ReceiveTime, &LocalTime );
    FileTimeToSystemTime( &LocalTime, &SystemTime );    

    StrSize = GetDateFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        DateStr,
        sizeof(DateStr)
        );
    if (StrSize == 0) {
        Copy = GetString( IDS_UNAVAILABLE );
        goto copy;
    }

    StrSize = GetTimeFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        TimeStr,
        sizeof(TimeStr)
        );
    if (StrSize == 0) {
        Copy = GetString( IDS_UNAVAILABLE );
        goto copy;
    }

    wcscat( DateStr, L" @ " );
    wcscat( DateStr, TimeStr );

    Copy = SysAllocString( DateStr );
                                     
copy:

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Image(BSTR *FileName)
{
    if (!FileName) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString( TiffFileName );

    if (!Copy  && TiffFileName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *FileName = Copy;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::put_Image(BSTR FileName)
{
    if (!FileName) {
        return E_POINTER;
    }    
    
    HRESULT Rslt = E_FAIL;

    //
    // if a file was previously open, then close it
    //

    if (hFile != INVALID_HANDLE_VALUE) {
        UnmapViewOfFile( fPtr );
        CloseHandle( hMap );
        CloseHandle( hFile );
    }

    //
    // open the tiff file
    //

    hFile = CreateFile(
        FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    hMap = CreateFileMapping(
        hFile,
        NULL,
        PAGE_READONLY | SEC_COMMIT,
        0,
        0,
        NULL
        );
    if (!hMap) {
        goto exit;
    }

    fPtr = (LPBYTE) MapViewOfFile(
        hMap,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (!fPtr) {
        goto exit;
    }

    TiffHeader = (PTIFF_HEADER) fPtr;

    //
    // validate that the file is really a tiff file
    //

    if ((TiffHeader->Identifier != TIFF_LITTLEENDIAN) || (TiffHeader->Version != TIFF_VERSION)) {
        goto exit;
    }

    //
    // get the tag count
    //

    NumDirEntries = *(LPWORD)(fPtr + TiffHeader->IFDOffset);

    //
    // get a pointer to the tags
    //

    TiffTags = (UNALIGNED TIFF_TAG*) (fPtr + TiffHeader->IFDOffset + sizeof(WORD));

    //
    // save the file name
    //

    wcscpy( TiffFileName, FileName );

    //
    // set a good return value
    //

    Rslt = 0;

exit:
    if (Rslt) {
        if (hFile != INVALID_HANDLE_VALUE) {
            if (fPtr) {
                UnmapViewOfFile( fPtr );
            }
            if (hMap) {
                CloseHandle( hMap );
            }
            CloseHandle( hFile );
            hFile = INVALID_HANDLE_VALUE;
            hMap = NULL;
            fPtr = NULL;
        }
    }

    return Rslt;
}

STDMETHODIMP CFaxTiff::get_RecipientName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR RecipName = GetStringTag( TIFFTAG_RECIP_NAME );
    if (!RecipName) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = FALSE;
    } else {
        Copy = SysAllocString( RecipName );
        LocalFree( RecipName );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try { 
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        SysFreeString( Copy );

    }

    return E_UNEXPECTED;

}


STDMETHODIMP CFaxTiff::get_RecipientNumber(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR RecipNumber = GetStringTag( TIFFTAG_RECIP_NUMBER );
    if (!RecipNumber) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
    } else {
        Copy = SysAllocString( RecipNumber );
        LocalFree( RecipNumber );
    }
    
    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

     } __except (EXCEPTION_EXECUTE_HANDLER) {

         SysFreeString( Copy );

    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::get_SenderName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR SenderName = GetStringTag( TIFFTAG_SENDER_NAME );
    if (!SenderName) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
    } else {
        Copy = SysAllocString( SenderName );
        LocalFree( SenderName );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::get_Routing(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
   
    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Routing = GetStringTag( TIFFTAG_ROUTING );
    if (!Routing) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( Routing );
        LocalFree( Routing );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_CallerId(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR CallerId = GetStringTag( TIFFTAG_CALLERID );
    if (!CallerId) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( CallerId );
        LocalFree( CallerId );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Csid = GetStringTag( TIFFTAG_CSID );
    if (!Csid) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( Csid );
        LocalFree( Csid );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Tsid = GetStringTag( TIFFTAG_TSID );
    if (!Tsid) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( Tsid );
        LocalFree( Tsid );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_RawReceiveTime(VARIANT *pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    VARIANT local;
    DWORDLONG ReceiveTime = GetQWORDTag( TIFFTAG_FAX_TIME );
    
    ZeroMemory(&local, sizeof(local));

    local.vt = VT_CY;
    local.cyVal.Lo = (DWORD)(ReceiveTime & 0xFFFFFFFF);
    local.cyVal.Hi = (LONG) (ReceiveTime >> 32);    

    //
    // can't use VariantCopy because this is a caller allocated variant
    //
    __try {
        
        pVal->vt       = local.vt;
        pVal->cyVal.Lo = local.cyVal.Lo;
        pVal->cyVal.Hi = local.cyVal.Hi;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
    }
    
    return E_UNEXPECTED;

}   

STDMETHODIMP CFaxTiff::get_TiffTagString(
    WORD tagID,
    BSTR* pVal
    )
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Value = GetStringTag( tagID );
    if (!Value) {
        Value = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( Value );
        LocalFree( Copy );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\stdafx.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stdafx.cpp

Abstract:

    This file contains the static support code for the
    atl controls in this project.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\status.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    status.h

Abstract:

    This file implements the status interface/object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXSTATUS_H_
#define __FAXSTATUS_H_

#include "resource.h"
#include "faxport.h"
#include <winfax.h>

class ATL_NO_VTABLE CFaxStatus :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxStatus, &CLSID_FaxStatus>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxStatus, &IID_IFaxStatus, &LIBID_FAXCOMLib>
{
public:
    CFaxStatus();
    ~CFaxStatus();
    BOOL Init(CFaxPort *pFaxPort);
    void FreeMemory();

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSTATUS)
DECLARE_NOT_AGGREGATABLE(CFaxStatus)

BEGIN_COM_MAP(CFaxStatus)
    COM_INTERFACE_ENTRY(IFaxStatus)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    STDMETHOD(Refresh)();
    STDMETHOD(get_ElapsedTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_SubmittedTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_StartTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_PageCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DocumentSize)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RoutingString)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Address)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Receive)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_Send)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_DocumentName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentPage)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pVal);

private:
    CFaxPort       *m_pFaxPort;
    BOOL            m_Receive;
    BOOL            m_Send;
    BSTR            m_Tsid;
    BSTR            m_Description;
    BSTR            m_RecipientName;
    BSTR            m_SenderName;
    BSTR            m_RoutingString;
    BSTR            m_Address;
    BSTR            m_DocName;
    BSTR            m_DeviceName;
    BSTR            m_Csid;
    BSTR            m_CallerId;
    DWORD           m_PageCount;
    DWORD           m_DocSize;
    DWORD           m_DeviceId;
    DWORD           m_CurrentPage;
    SYSTEMTIME      m_StartTime;
    SYSTEMTIME      m_SubmittedTime;
    SYSTEMTIME      m_ElapsedTime;

};

#endif //__FAXSTATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\util.cpp ===
#include "resource.h"
#include "stdafx.h"
#include <winfax.h>

extern CComModule _Module;

BSTR GetQueueStatus(DWORD QueueStatus) 
{
    WCHAR  szQueueStatus[100];
    szQueueStatus[0] = (WCHAR)'\0';

    DWORD ResourceID;

    if (QueueStatus & JS_INPROGRESS)      {
        ResourceID = IDS_JOB_INPROGRESS;
    } else if (QueueStatus & JS_DELETING) {
        ResourceID = IDS_JOB_DELETING;
    } else if (QueueStatus & JS_FAILED)   {
        ResourceID = IDS_JOB_FAILED;
    } else if (QueueStatus & JS_PAUSED)   {
        ResourceID = IDS_JOB_PAUSED;
    } else if (QueueStatus == JS_PENDING) {
        ResourceID = IDS_JOB_PENDING;
    } else
        ResourceID = IDS_JOB_UNKNOWN;

    LoadString(_Module.GetModuleInstance(),ResourceID,szQueueStatus,100);

    return SysAllocString(szQueueStatus);
}


BSTR GetDeviceStatus(DWORD DeviceStatus)
{
    WCHAR  szDeviceStatus[100];
    szDeviceStatus[0] = (WCHAR)'\0';

    DWORD ResourceID;

    if (DeviceStatus == FPS_DIALING) {
        ResourceID = IDS_DEVICE_DIALING;
    } else if (DeviceStatus == FPS_SENDING) {
        ResourceID = IDS_DEVICE_SENDING;
    } else if (DeviceStatus == FPS_RECEIVING) {
        ResourceID = IDS_DEVICE_RECEIVING;
    } else if (DeviceStatus == FPS_COMPLETED) {
        ResourceID = IDS_DEVICE_COMPLETED;
    } else if (DeviceStatus == FPS_HANDLED) {
        ResourceID = IDS_DEVICE_HANDLED;
    } else if (DeviceStatus == FPS_UNAVAILABLE) {
        ResourceID = IDS_DEVICE_UNAVAILABLE;
    } else if (DeviceStatus == FPS_BUSY) {
        ResourceID = IDS_DEVICE_BUSY;
    } else if (DeviceStatus == FPS_NO_ANSWER) {
        ResourceID = IDS_DEVICE_NOANSWER;
    } else if (DeviceStatus == FPS_BAD_ADDRESS) {
        ResourceID = IDS_DEVICE_BADADDRESS; 
    } else if (DeviceStatus == FPS_NO_DIAL_TONE) {
        ResourceID = IDS_DEVICE_NODIALTONE;
    } else if (DeviceStatus == FPS_DISCONNECTED) {
        ResourceID = IDS_DEVICE_DISCONNECTED;
    } else if (DeviceStatus == FPS_FATAL_ERROR) {
        ResourceID = IDS_DEVICE_FATALERROR;
    } else if (DeviceStatus == FPS_NOT_FAX_CALL) {
        ResourceID = IDS_DEVICE_NOTFAXCALL;
    } else if (DeviceStatus == FPS_CALL_DELAYED) {
        ResourceID = IDS_DEVICE_CALLDELAYED;
    } else if (DeviceStatus == FPS_CALL_BLACKLISTED) {
        ResourceID = IDS_DEVICE_BLACKLISTED;
    } else if (DeviceStatus == FPS_INITIALIZING) {
        ResourceID = IDS_DEVICE_INITIALIZING;
    } else if (DeviceStatus == FPS_OFFLINE) {
        ResourceID = IDS_DEVICE_OFFLINE;
    } else if (DeviceStatus == FPS_RINGING) {
        ResourceID = IDS_DEVICE_RINGING;
    } else if (DeviceStatus == FPS_AVAILABLE) {
        ResourceID = IDS_DEVICE_AVAILABLE;
    } else if (DeviceStatus == FPS_ABORTING) {
        ResourceID = IDS_DEVICE_ABORTING;
    } else if (DeviceStatus == FPS_ROUTING) {
        ResourceID = IDS_DEVICE_ROUTING;
    } else if (DeviceStatus == FPS_ANSWERED) {
        ResourceID = IDS_DEVICE_ANSWERED;
    } else {
        ResourceID = IDS_DEVICE_UNKNOWN;
    }


    LoadString(_Module.GetModuleInstance(),ResourceID,szDeviceStatus,100);

    return SysAllocString(szDeviceStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED_)
#define AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <faxcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\adminhlp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    adminhelp.h

Abstract:

    This header contains resource id to help mappings

Environment:

    WIN32 User Mode

Author:

    Andrew Ritz (andrewr) 9-Jan-1998

--*/

#ifndef __FAXADMIN_HELP_H
#define __FAXADMIN_HELP_H

#include "faxhelp.h"

static ULONG_PTR RoutingPriorityHelpIDs[] =
{
    IDC_ROUTE_EXTS,             IDH_Fax_Service_Routing_PriorityList,
    IDC_ROUTEPRI_UP,            IDH_Fax_Service_Routing_Up,	 
    IDC_ROUTEPRI_DOWN,          IDH_Fax_Service_Routing_Down,	
    IDC_ROUTEPRI_TITLE,         IDH_INACTIVE,    
    0,                          0
} ;


static ULONG_PTR ServerGeneralHelpIDs[] =
{
    IDC_RETRY_COUNT,            IDH_Fax_Service_General_NumberOfRetries,
    IDC_RETRY_DELAY,            IDH_Fax_Service_General_MinutesBetweenRetries,                 
    IDC_KEEP_DAYS,              IDH_Fax_Service_General_DaysUnsentJobKept,     
    IDC_ARCHIVE_PATH,           IDH_Fax_Service_General_ArchiveOutgoingFaxes,	     
    IDC_DISCOUNT_START,         IDH_Fax_Service_General_DiscountPeriod,	              
    IDC_DISCOUNT_END,           IDH_Fax_Service_General_DiscountPeriod,	                
    IDC_ARCHIVE_BROWSE,         IDH_Fax_Service_General_ArchiveOutgoingFaxes_Browse,     
    IDC_PRINT_BANNER,           IDH_Fax_Service_General_PrintBannerOnTop,	     
    IDC_USE_TSID,               IDH_Fax_Service_General_UseSendingDeviceTSID,	     
    IDC_ARCHIVE,                IDH_Fax_Service_General_ArchiveOutgoingFaxes,	     
    IDC_FORCESERVERCP,          IDH_Fax_Service_General_ForceServerCoverPages,	               
    IDC_DISCOUNT_START_STATIC,  IDH_Fax_Service_General_DiscountPeriod,	     
    IDC_TIMESTART    ,          IDH_Fax_Service_General_DiscountPeriod,
    IDC_DISCOUNT_END_STATIC,    IDH_Fax_Service_General_DiscountPeriod,	     
    IDC_TIMEEND,                IDH_Fax_Service_General_DiscountPeriod,
    IDC_STATIC_MAPI_PROFILE,    IDH_Fax_Service_General_MapiProfile,
    IDC_SERVER_MAPI_PROFILE,    IDH_Fax_Service_General_MapiProfile,
    IDC_RETRY_GRP,              IDH_Fax_Service_General_RetryCharacteristics_GRP,
    IDC_STATIC_RETRY,           IDH_Fax_Service_General_NumberOfRetries,     
    IDC_STATIC_RETRY_MINUTES,   IDH_Fax_Service_General_MinutesBetweenRetries,     
    IDC_STATIC_KEEPDAYS,        IDH_Fax_Service_General_DaysUnsentJobKept,	             
    IDC_SEND_GRP,               IDH_Fax_Service_General_SendSettings_GRP,                        
    0,                          0
} ;


static ULONG_PTR DeviceGeneralHelpIDs[] =
{
    IDDI_DEVICE_PROP_EDIT_TSID,  IDH_Fax_Modem_General_SendTSID,	     
    IDDI_DEVICE_PROP_EDIT_CSID,  IDH_Fax_Modem_General_ReceiveTSID,	
    IDDI_DEVICE_PROP_SPIN_RINGS, IDH_Fax_Modem_General_RingsBeforeAnswer,
    IDDI_DEVICE_PROP_EDIT_RINGS, IDH_Fax_Modem_General_RingsBeforeAnswer,
    IDC_DEVICE_SEND_GRP,         (DWORD) -1,
    IDC_STATIC_TSID,             IDH_Fax_Modem_General_SendTSID,	
    IDC_STATIC_TSID1,            IDH_Fax_Modem_General_SendTSID,	
    IDC_DEVICE_RECEIVE_GRP,      (DWORD) -1,
    IDC_STATIC_CSID,             IDH_Fax_Modem_General_ReceiveTSID,
    IDC_STATIC_CSID1,            IDH_Fax_Modem_General_ReceiveTSID,
    IDC_STATIC_RINGS,            IDH_Fax_Modem_General_RingsBeforeAnswer,
    IDC_SEND,                    IDH_Fax_Modem_General_Send,
    IDC_RECEIVE,                 IDH_Fax_Modem_General_Receive,
    0,                          0
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\dcomputer.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dcomputer.h

Abstract:

    This header prototypes the computer selection dialog.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __DIALOG_COMPUTER_H_
#define __DIALOG_COMPUTER_H_

#include "resource.h"

class CInternalRoot;    // forward declaration

class CFaxSelectComputerPropSheet
{
public:

    CFaxSelectComputerPropSheet( HINSTANCE hInstance, LONG_PTR hMmcNotify, CInternalRoot * glob );

    ~CFaxSelectComputerPropSheet();

    HPROPSHEETPAGE GetHandle() { return _hPropSheet; }

private:

    static INT_PTR APIENTRY DlgProc( HWND hwndDlg,
                                     UINT message,
                                     WPARAM wParam,
                                     LPARAM lParam );

    //
    // NOTE: The following **must** be consecutive.
    //

    PROPSHEETPAGE   _PropSheet;    
    BOOL            _fFirstActive;

    LONG_PTR         _hMmcNotify;
    HPROPSHEETPAGE   _hPropSheet;
    CInternalRoot *  _globalRoot;
};
            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\dcomputer.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dcomputer.cpp

Abstract:

    This file contains implementation of 
    the computer selection dialog.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#include "stdafx.h"
#include "dcomputer.h"
#include "iroot.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CFaxSelectComputerPropSheet::CFaxSelectComputerPropSheet(
                                                        IN HINSTANCE hInstance,
                                                        IN LONG_PTR hMmcNotify, 
                                                        IN CInternalRoot * glob )

: _fFirstActive( TRUE ),
  _hMmcNotify( hMmcNotify ),
  _globalRoot( glob )
/*++

Routine Description:

    Constructor

Arguments:

    hInstance - the instance pointer
    hMmcNotify - the MMC notify handle
    glob - a pointer to the owning node

Return Value:

    None.    

--*/
{
    DebugPrint(( TEXT("CFaxSelectComputerPropSheet Created") ));
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_IS_PAGE0);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_IS_PAGE0_TITLE);
    _PropSheet.pfnDlgProc  = CFaxSelectComputerPropSheet::DlgProc;
    _PropSheet.lParam = (LONG_PTR)this;

    _hPropSheet = NULL;
    _hPropSheet = CreatePropertySheetPage( &_PropSheet );

    assert(_hPropSheet != NULL );

}

CFaxSelectComputerPropSheet::~CFaxSelectComputerPropSheet()
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.    

--*/
{
    DebugPrint(( TEXT("CFaxSelectComputerPropSheet Destroyed") ));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Dialog Proc
//
//

INT_PTR 
APIENTRY 
CFaxSelectComputerPropSheet::DlgProc( IN HWND hwndDlg,
                                      IN UINT message,
                                      IN WPARAM wParam,
                                      IN LPARAM lParam )
/*++

Routine Description:

    Dialog Procedure

Arguments:

    hwndDlg - the hwnd of the dialog
    message - the message
    wParam, lParam - the window message parameters

Return Value:

    BOOL

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxSelectComputerPropSheet::DlgProc") ));

    BOOL fRet = FALSE;

    switch( message ) {
        case WM_INITDIALOG:
            {
                DebugPrint(( TEXT("CFaxSelectComputerPropSheet::DlgProc -- WM_INITDIALOG\n") ));

                LPARAM lthis = ((CFaxSelectComputerPropSheet *)lParam)->_PropSheet.lParam;
                CFaxSelectComputerPropSheet * pthis = (CFaxSelectComputerPropSheet *)lthis;

                SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

                //
                // Default to local machine.
                //

                CheckRadioButton( hwndDlg,
                                  IDDI_LOCAL_COMPUTER,
                                  IDDI_REMOTE_COMPUTER,
                                  IDDI_LOCAL_COMPUTER );

                EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), FALSE );

                fRet = TRUE;
                break;
            }

        case WM_COMMAND:
            {
                DebugPrint(( TEXT("CFaxSelectComputerPropSheet::DlgProc -- WM_COMMAND\n") ));

                switch( LOWORD( wParam ) ) {
                    case IDDI_LOCAL_COMPUTER:
                        {
                            if( BN_CLICKED == HIWORD(wParam) ) {
                                EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), FALSE );
                                fRet = TRUE;
                            }
                            break;
                        }

                    case IDDI_REMOTE_COMPUTER:
                        {
                            if( BN_CLICKED == HIWORD(wParam) ) {
                                EnableWindow( GetDlgItem( hwndDlg, IDDI_COMPNAME ), TRUE );
                                fRet = TRUE;
                            }
                            break;
                        }
                } // switch
                break;
            }

        case WM_NOTIFY:
            {
                DebugPrint(( TEXT("CFaxSelectComputerPropSheet::DlgProc -- WM_NOTIFY\n") ));
                CFaxSelectComputerPropSheet * pthis =
                    (CFaxSelectComputerPropSheet *)GetWindowLongPtr( hwndDlg,
                                                                     DWLP_USER );

                switch( ((LPNMHDR) lParam)->code ) {
                    case PSN_KILLACTIVE:
                        {
                            // Allow loss of activation
                            SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, FALSE );

                            fRet = TRUE;
                            break;
                        }

                    case PSN_SETACTIVE:
                        {
                            if( pthis->_fFirstActive ) {
                                PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_FINISH );

                                pthis->_fFirstActive = FALSE;
                            } else {
                                // Go to next page
                                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, -1 );
                            }

                            fRet = TRUE;
                            break;
                        }

                    case PSN_WIZBACK:
                        {
                            // Allow previous page
                            SetWindowLongPtr( hwndDlg,
                                              DWLP_MSGRESULT,
                                              PSNRET_NOERROR );

                            fRet = TRUE;
                            break;
                        }

                    case PSN_WIZNEXT:
                        {
                            // Allow next page
                            SetWindowLongPtr( hwndDlg,
                                              DWLP_MSGRESULT,
                                              PSNRET_NOERROR );

                            fRet = TRUE;
                            break;
                        }

                    case PSN_WIZFINISH:
                        {
                            TCHAR wcCompName[MAX_COMPUTERNAME_LENGTH+1];

                            if( IsDlgButtonChecked( hwndDlg, IDDI_LOCAL_COMPUTER ) ) {
                                pthis->_globalRoot->SetMachine( NULL );
                            } else {
                                if( GetDlgItemText( hwndDlg, IDDI_COMPNAME, wcCompName, MAX_COMPUTERNAME_LENGTH ) ) {
                                    pthis->_globalRoot->SetMachine( (TCHAR *)&wcCompName );
                                }
                            }

                            MMCPropertyChangeNotify( pthis->_hMmcNotify, 0 );

                            fRet = TRUE;

                            break;
                        }

                } // switch

                break;
            }

        case WM_DESTROY:
            {
                DebugPrint(( TEXT("CFaxSelectComputerPropSheet::DlgProc -- WM_DESTROY\n") ));
                CFaxSelectComputerPropSheet * pthis =
                    (CFaxSelectComputerPropSheet *)GetWindowLongPtr( hwndDlg,
                                                                     DWLP_USER );

                MMCFreeNotifyHandle( pthis->_hMmcNotify );

                delete pthis;

                fRet = TRUE;
                break;
            }
    } // switch

    return fRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\ddevmain.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dcomputer.cpp

Abstract:

    This file contains implementation of 
    the computer selection dialog.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#include "stdafx.h"
#include "faxcompd.h"
#include "faxcomp.h"
#include "ddevmain.h"
#include "inode.h"
#include "idevice.h"
#include "adminhlp.h"
#include "faxreg.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CFaxDeviceSettingsPropSheet::CFaxDeviceSettingsPropSheet(
                                                        IN HINSTANCE hInstance,
                                                        IN LONG_PTR hMmcNotify, 
                                                        IN CInternalDevice * NodePtr,
                                                        IN CFaxComponent  * pComp 
                                                        )
: _hMmcNotify( hMmcNotify ),          
_dwDeviceId( 0 ),
_hFaxServer( 0 ),
_pOwnNode( NodePtr ),
_pCompData( NULL ),
_pComp( pComp )
/*++

Routine Description:

    Constructor

Arguments:

    hInstance - the instance pointer
    hMmcNotify - the MMC notify handle
    NodePtr - a pointer to the owning node    

Return Value:

    None.    

--*/
{
    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(icex);    
    icex.dwICC = ICC_DATE_CLASSES;
    InitCommonControlsEx(&icex);    

    DebugPrint(( TEXT("CFaxDeviceSettingsPropSheet Created") ));
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE | PSP_USECALLBACK;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_DEVICE_PROP_PAGE_1);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_DEVICE_PROP_PAGE_1_TITLE);
    _PropSheet.pfnDlgProc  = CFaxDeviceSettingsPropSheet::DlgProc;
    _PropSheet.lParam = (LONG_PTR)this;
    _PropSheet.pfnCallback = &PropSheetPageProc;

    _hPropSheet = NULL;
    _hPropSheet = CreatePropertySheetPage( &_PropSheet );

    assert(_hPropSheet != NULL );

    assert( NodePtr != NULL );
    assert( NodePtr->pDeviceInfo != NULL );

    _hFaxServer = NodePtr->hFaxServer;
    _dwDeviceId = NodePtr->pDeviceInfo->DeviceId;
    _pCompData = NodePtr->m_pCompData;

}

CFaxDeviceSettingsPropSheet::~CFaxDeviceSettingsPropSheet()
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.    

--*/
{
    DebugPrint(( TEXT("CFaxDeviceSettingsPropSheet Destroyed") ));

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Dialog Proc
//
//

INT_PTR
APIENTRY 
CFaxDeviceSettingsPropSheet::DlgProc(
                                    IN HWND hwndDlg,
                                    IN UINT message,
                                    IN WPARAM wParam,
                                    IN LPARAM lParam 
                                    )
/*++

Routine Description:

    Dialog Procedure

Arguments:

    hwndDlg - the hwnd of the dialog
    message - the message
    wParam, lParam - the window message parameters

Return Value:

    BOOL

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxDeviceSettingsPropSheet::DlgProc") ));

    BOOL        fRet = FALSE;
    HWND        hwnd = NULL;
    HWND        hwndSheet = NULL;

    switch( message ) {
        case WM_INITDIALOG:
            {

                DebugPrint(( TEXT("CFaxDeviceSettingsPropSheet::DlgProc -- WM_INITDIALOG\n") ));        

                assert( lParam != NULL );
                LONG_PTR lthis = ((CFaxDeviceSettingsPropSheet *)lParam)->_PropSheet.lParam;

                CFaxDeviceSettingsPropSheet * pthis = (CFaxDeviceSettingsPropSheet *)lthis;

                assert( pthis != NULL );                

                SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

                // setup the spinner control
                hwnd = GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_SPIN_RINGS );
                SendMessage( hwnd, UDM_SETRANGE32, MIN_RING_COUNT, MAX_RING_COUNT );
                SendMessage( hwnd, UDM_SETPOS, 0, (LPARAM) MAKELONG((short) pthis->_pOwnNode->pDeviceInfo->Rings, 0) );        
                SendMessage( GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_RINGS ), EM_SETLIMITTEXT, 2, 0 );

                // setup TSID control
                SetDlgItemText( hwndDlg, IDDI_DEVICE_PROP_EDIT_TSID, pthis->_pOwnNode->pDeviceInfo->Tsid );
                SendMessage( GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_TSID ), EM_SETLIMITTEXT, TSID_LIMIT, 0 );

                // setup send checkbox
                CheckDlgButton(hwndDlg,IDC_SEND,((pthis->_pOwnNode->pDeviceInfo->Flags & FPF_SEND) == FPF_SEND));

                // setup CSID control   
                SetDlgItemText( hwndDlg, IDDI_DEVICE_PROP_EDIT_CSID, pthis->_pOwnNode->pDeviceInfo->Csid );
                SendMessage( GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_CSID ), EM_SETLIMITTEXT, CSID_LIMIT , 0 );

                // setup receive checkbox
                CheckDlgButton(hwndDlg,IDC_RECEIVE,((pthis->_pOwnNode->pDeviceInfo->Flags & FPF_RECEIVE) == FPF_RECEIVE));
                EnableWindow( GetDlgItem( hwndDlg, IDC_STATIC_RINGS ), IsDlgButtonChecked( hwndDlg,IDC_RECEIVE ) );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_RINGS ), IsDlgButtonChecked( hwndDlg,IDC_RECEIVE ) );
                EnableWindow( GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_SPIN_RINGS ), IsDlgButtonChecked( hwndDlg,IDC_RECEIVE ) );

                pthis->_pComp->IncPropSheetCount();

                fRet = TRUE;
                break;
            }

        case WM_COMMAND:
            {
                DebugPrint(( TEXT("CFaxDeviceSettingsPropSheet::DlgProc -- WM_COMMAND\n") ));
                // activate apply button        

                WORD wID = LOWORD( wParam );

                switch( wID ) {
                    case IDDI_DEVICE_PROP_EDIT_CSID:
                    case IDDI_DEVICE_PROP_EDIT_TSID:
                    case IDDI_DEVICE_PROP_EDIT_RINGS:
                    
                        if( HIWORD(wParam) == EN_CHANGE ) {     // notification code 
                            hwndSheet = GetParent( hwndDlg );
                            PropSheet_Changed( hwndSheet, hwndDlg );                
                        }
                        break;                    

                    case IDC_RECEIVE:
                        EnableWindow( GetDlgItem( hwndDlg, IDC_STATIC_RINGS ), IsDlgButtonChecked( hwndDlg,IDC_RECEIVE ) );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_RINGS ), IsDlgButtonChecked( hwndDlg,IDC_RECEIVE ) );
                        EnableWindow( GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_SPIN_RINGS ), IsDlgButtonChecked( hwndDlg,IDC_RECEIVE ) );
                    case IDC_SEND:                    
                        if ( HIWORD(wParam) == BN_CLICKED ) {     // notification code
                            hwndSheet = GetParent( hwndDlg );
                            PropSheet_Changed( hwndSheet, hwndDlg );                
                        }
                    default:
                        break;
                } // switch

                fRet = TRUE;
                break;
            }

        case WM_HELP:
                WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle,
                        FAXCFG_HELP_FILENAME,
                        HELP_WM_HELP,
                        (ULONG_PTR) &DeviceGeneralHelpIDs);    
                fRet = TRUE;
                break;
    
        case WM_CONTEXTMENU:
                WinHelp((HWND) wParam,
                        FAXCFG_HELP_FILENAME,
                        HELP_CONTEXTMENU,
                        (ULONG_PTR) &DeviceGeneralHelpIDs);
                fRet = TRUE;    
                break;
        case WM_NOTIFY:
            {
//        DebugPrint(( TEXT("CFaxDeviceSettingsPropSheet::DlgProc -- WM_NOTIFY\n") ));
                CFaxDeviceSettingsPropSheet * pthis =
                    (CFaxDeviceSettingsPropSheet *)GetWindowLongPtr( hwndDlg,
                                                                     DWLP_USER );

                switch( ((LPNMHDR) lParam)->code ) {
                    case PSN_APPLY:
                        {
                            // apply changes here!!

                            if (SUCCEEDED(pthis->ValidateData( hwndDlg) )) {
                               pthis->UpdateData( hwndDlg );
                               MMCPropertyChangeNotify( pthis->_hMmcNotify, (LONG_PTR)pthis->_pOwnNode );
   
                               // deactivate apply button
   
                               hwndSheet = GetParent( hwndDlg );
                               PropSheet_UnChanged( hwndSheet, hwndDlg );
   
                               fRet = TRUE;
                            } else {
                               fRet = FALSE;
                            }


                            break;
                        }

                } // switch

                break;
            }

        case WM_DESTROY:
            {
                DebugPrint(( TEXT("CFaxDeviceSettingsPropSheet::DlgProc -- WM_DESTROY\n") ));
                CFaxDeviceSettingsPropSheet * pthis =
                    (CFaxDeviceSettingsPropSheet *)GetWindowLongPtr( hwndDlg,
                                                                     DWLP_USER );

                if( pthis != NULL ) {

                    pthis->_pComp->DecPropSheetCount();

                    MMCFreeNotifyHandle( pthis->_hMmcNotify );
                }

                fRet = TRUE;
                break;
            }
    } // switch

    return fRet;
}

// the settings are updated in the property sheet because this
// allows the property sheet to complete even if the snapin or
// owner node has already been destroyed.
HRESULT 
CFaxDeviceSettingsPropSheet::UpdateData(
                                       HWND hwndDlg 
                                       )
/*++

Routine Description:

    Update Data method

Arguments:

    hwndDlg - the hwnd of the dialog

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::UpdateData") ));

    assert( hwndDlg != NULL );

    HRESULT             hr = S_OK;
    HANDLE              portHandle = NULL;
    HWND                hwnd;
    PFAX_PORT_INFO      pDeviceInfo = NULL;
    LRESULT             lr;
    UINT                rc;
    TCHAR               m_Tsid[ TSID_LIMIT+1 ];
    TCHAR               m_Csid[ CSID_LIMIT+1 ];

    ZeroMemory( m_Tsid, sizeof(TCHAR) * (TSID_LIMIT+1) );
    ZeroMemory( m_Csid, sizeof(TCHAR) * (CSID_LIMIT+1) );    

    try {
        do {
            if( _pCompData->QueryRpcError() ) {
                hr = E_UNEXPECTED;
                break;
            }

            // open the port
            if( !FaxOpenPort( _hFaxServer, _dwDeviceId, PORT_OPEN_MODIFY, &portHandle ) ) {
                if (GetLastError() != ERROR_ACCESS_DENIED) {
                    _pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);            
                }
                ::GlobalStringTable->SystemErrorMsg( GetLastError() );
                hr = E_UNEXPECTED;
                break;
            }

            // get data
            if( !FaxGetPort( portHandle, &pDeviceInfo ) ) {
                if (GetLastError() != ERROR_ACCESS_DENIED) {
                    _pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                }                               
                ::GlobalStringTable->SystemErrorMsg( GetLastError() );
                hr = E_UNEXPECTED;
                break;
            }

            // grab the TSID and CSID from the dialog
            hwnd = GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_TSID );
            rc = GetDlgItemText( hwndDlg, IDDI_DEVICE_PROP_EDIT_TSID, m_Tsid, TSID_LIMIT+1 );
            if( rc == 0 ) {
                assert( FALSE );            
                hr = E_UNEXPECTED;
                break;
            }

            hwnd = GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_CSID );
            rc = GetDlgItemText( hwndDlg, IDDI_DEVICE_PROP_EDIT_CSID, m_Csid, CSID_LIMIT+1 );
            if( rc == 0 ) {
                assert( FALSE );            
                hr = E_UNEXPECTED;
                break;
            }
            assert( pDeviceInfo != NULL );

            pDeviceInfo->Tsid = m_Tsid;
            pDeviceInfo->Csid = m_Csid;

            // grab the position from the spinner control
            hwnd = GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_SPIN_RINGS );
            lr = SendMessage( hwnd, UDM_GETPOS, 0, 0 );
            if( HIWORD( lr ) != 0 ) {
                assert( FALSE );            
                hr = E_UNEXPECTED;
                break;
            }
            pDeviceInfo->Rings = LOWORD( lr );
            pDeviceInfo->Rings = max(pDeviceInfo->Rings,MIN_RING_COUNT);
            pDeviceInfo->Rings = min(pDeviceInfo->Rings,MAX_RING_COUNT);

            //grab the send and receive checkbox from the dialog
            pDeviceInfo->Flags = (IsDlgButtonChecked(hwndDlg,IDC_RECEIVE) == BST_CHECKED) ?
                                 (pDeviceInfo->Flags | FPF_RECEIVE) : 
                                 (pDeviceInfo->Flags & (~FPF_RECEIVE)) ;
            pDeviceInfo->Flags = (IsDlgButtonChecked(hwndDlg,IDC_SEND) == BST_CHECKED) ? 
                                 (pDeviceInfo->Flags | FPF_SEND) :
                                 (pDeviceInfo->Flags & (~FPF_SEND)) ;
            

            // set new settings
            if( !FaxSetPort( portHandle, pDeviceInfo ) ) {
                DWORD ec = GetLastError();
                if (ec != ERROR_ACCESS_DENIED && ec != ERROR_DEVICE_IN_USE) {
                    _pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                }
                
                if (ec == ERROR_DEVICE_IN_USE)
                    ::GlobalStringTable->PopUpMsg( hwndDlg, IDS_DEVICE_INUSE, TRUE, 0 );
                else 
                    ::GlobalStringTable->SystemErrorMsg( ec );
                
                hr = E_UNEXPECTED;
                break;
            }

            
            FaxClose( portHandle );
            FaxFreeBuffer( (PVOID) pDeviceInfo );
            pDeviceInfo = NULL;
            portHandle = NULL;

            // See if faxstat is running
            HWND hWndFaxStat = FindWindow(FAXSTAT_WINCLASS, NULL);
            if (hWndFaxStat) {
                if (SendMessage(hWndFaxStat, WM_FAXSTAT_MMC, (WPARAM) _dwDeviceId, 0)) {
                    ::GlobalStringTable->PopUpMsg( hwndDlg, IDS_DEVICE_MANUALANSWER, FALSE, 0 );
                }
            }

        } while( 0 );
    } catch( ... ) {
        _pCompData->NotifyRpcError( TRUE );
        assert(FALSE);            
        hr = E_UNEXPECTED;
    }

    if(portHandle != NULL ) {
        FaxClose( portHandle );
        FaxFreeBuffer( (PVOID) pDeviceInfo );
        pDeviceInfo = NULL;
    }

    return hr;
}

UINT 
CALLBACK 
CFaxDeviceSettingsPropSheet::PropSheetPageProc(
                                              HWND hwnd,      
                                              UINT uMsg,      
                                              LPPROPSHEETPAGE ppsp        
                                              )
/*++

Routine Description:

    Dialog Init and destroy routine

Arguments:

    hwndDlg - the hwnd of the dialog - will be NULL
    uMsg - the message PSPCB_CREATE or PSPCB_RELEASE 
    ppsp - pointer to a PROPERTYSHEETPAGE struct

Return Value:

    UINT - nonzero to allow, zero to fail

--*/
{
    CFaxDeviceSettingsPropSheet * pthis = NULL;
    UINT retval = 1;

    // release my property sheet
    if( uMsg == PSPCB_RELEASE ) {
        try {
            pthis = (CFaxDeviceSettingsPropSheet * )(ppsp->lParam);
            delete pthis;
        } catch( ... ) {
            assert( FALSE );
            retval = 0;

        }
    }
    return retval;
}


BOOL
IsAscii(
    LPCWSTR ptszChar
    ) 
{
    BOOL fReturnValue = TRUE;
    while ( (*ptszChar != (WCHAR) TEXT('\0')) &&
          ( fReturnValue != (BOOL) FALSE) ) {
        if ( (*ptszChar < (WCHAR) 0x0020) || (*ptszChar > (WCHAR) MAXCHAR) ) {
            fReturnValue = (BOOL) FALSE;
        }

        ptszChar = _wcsinc( ptszChar );
    }
   
    return fReturnValue;
}


HRESULT 
CFaxDeviceSettingsPropSheet::ValidateData(
                                       HWND hwndDlg 
                                       )
/*++

Routine Description:

    validate Data method

Arguments:

    hwndDlg - the hwnd of the dialog

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::ValidateData") ));

    assert( hwndDlg != NULL );

    HWND                hwnd;
    UINT                rc;
    TCHAR               Tsid[ TSID_LIMIT+1 ] = {0};
    TCHAR               Csid[ CSID_LIMIT+1 ] = {0};
    DWORD               Rings;
    LRESULT             lr;

    // grab the TSID and CSID from the dialog
    hwnd = GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_TSID );
    rc = GetDlgItemText( hwndDlg, IDDI_DEVICE_PROP_EDIT_TSID, Tsid, TSID_LIMIT+1 );
    
    hwnd = GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_EDIT_CSID );
    rc = GetDlgItemText( hwndDlg, IDDI_DEVICE_PROP_EDIT_CSID, Csid, CSID_LIMIT+1 );

    // get the ring count
    hwnd = GetDlgItem( hwndDlg, IDDI_DEVICE_PROP_SPIN_RINGS );
    lr = SendMessage( hwnd, UDM_GETPOS, 0, 0 );
    if( HIWORD( lr ) != 0 ) {
        ::GlobalStringTable->PopUpMsg( hwndDlg, IDS_ERR_INVALID_RING, TRUE, 0 );
        return( E_FAIL);
    }
    Rings = LOWORD( lr );
    
    //
    // make sure the CSID and TSID are both ascii strings
    //
    if (!*Csid || !*Tsid) {
        ::GlobalStringTable->PopUpMsg( hwndDlg, IDS_ERR_ID_REQD, TRUE, 0 );
        return E_FAIL;
    }


    if (!IsAscii(Csid) || !IsAscii(Tsid)) {
       ::GlobalStringTable->PopUpMsg( hwndDlg, IDS_ERR_ASCII_ONLY, TRUE, 0 );
       return E_FAIL;
    }

    if (Rings < MIN_RING_COUNT || Rings > MAX_RING_COUNT) {
        ::GlobalStringTable->PopUpMsg( hwndDlg, IDS_ERR_INVALID_RING, TRUE, 0 );
        return E_FAIL;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\activefax\winfax.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    winfax.cpp

Abstract:

    This file implements a pseudo winfax interface.
    The COM interfaces call winfax using the regular
    winfax.h header file and include the cpp file
    as part of the build.  This module provides winfax
    interfaces that talk to the fax server through
    http/ftp via isapi instead of the coventional rpc
    methods.  This allows the COM interfaces to work
    on the internet and across a proxy too.

    If you add any winfax interfaces to this file you
    must be sure to correctly update the faxisapi.h
    header file and add the corresponding function
    in the faxisapi dll.

Author:

    Wesley Witt (wesw) 1-June-1997

Environment:

    User Mode

--*/

#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <tchar.h>

#include "faxutil.h"
#include "winfax.h"
#include "faxisapi.h"


#define FixupStringIn(_s,_buf)  if ((_s)) { (_s) = (LPWSTR) ((DWORD)(_s) + (DWORD)(_buf)); }


HINTERNET hInternet;
HINTERNET hConnection;
HANDLE    hHeap;


VOID
StoreString(
    LPWSTR String,
    LPDWORD DestString,
    LPBYTE Buffer,
    LPDWORD Offset
    )
{
    if (String) {
        wcscpy( (LPWSTR) (Buffer+*Offset), String );
        *DestString = *Offset;
        *Offset += StringSize( String );
    } else {
        *DestString = 0;
    }
}


DWORD
PortInfoSize(
    PFAX_PORT_INFOW PortInfo
    )
{
    DWORD Size = sizeof(FAX_PORT_INFOW);

    Size += StringSize( PortInfo->DeviceName );
    Size += StringSize( PortInfo->Tsid );
    Size += StringSize( PortInfo->Csid );

    return Size;
}


VOID
Flush(
    HINTERNET hSession
    )
{
    BOOL Rslt;
    DWORD Size;
    LPBYTE Buffer[32];


    do {
        Size = sizeof(Buffer);
        Rslt = InternetReadFile( hSession, Buffer, Size, &Size );
    } while( Rslt && Size );
}


BOOL
GetResponse(
    HINTERNET hSession,
    LPBYTE Buffer,
    DWORD BufferSize
    )
{
    BOOL Rslt;
    DWORD Size;
    IFAX_RESPONSE_HEADER Response;


    Rslt = InternetReadFile(
        hSession,
        (LPVOID) &Response,
        sizeof(IFAX_RESPONSE_HEADER),
        &Size
        );
    if (!Rslt) {
        return FALSE;
    }

    if (Response.ErrorCode) {
        SetLastError( Response.ErrorCode );
        return FALSE;
    }

    if (Response.Size) {
        Rslt = InternetReadFile(
            hSession,
            Buffer,
            min( BufferSize, Response.Size - sizeof(IFAX_RESPONSE_HEADER)),
            &Size
            );
        if (!Rslt) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
GetResponseAlloc(
    HINTERNET hSession,
    LPBYTE *Buffer
    )
{
    BOOL Rslt;
    DWORD Size;
    IFAX_RESPONSE_HEADER Response;


    Rslt = InternetReadFile(
        hSession,
        (LPVOID) &Response,
        sizeof(IFAX_RESPONSE_HEADER),
        &Size
        );
    if (!Rslt) {
        return FALSE;
    }

    if (Response.ErrorCode) {
        SetLastError( Response.ErrorCode );
        return FALSE;
    }

    *Buffer = (LPBYTE) MemAlloc( Response.Size );
    if (*Buffer == NULL) {
        return FALSE;
    }

    Rslt = InternetReadFile(
        hSession,
        *Buffer,
        Response.Size - sizeof(IFAX_RESPONSE_HEADER),
        &Size
        );
    if (!Rslt) {
        MemFree( *Buffer );
        return FALSE;
    }

    return TRUE;
}


HINTERNET
OpenRequest(
    VOID
    )
{
    HINTERNET hSession = HttpOpenRequestA(
        hConnection,
        "GET",
        "/scripts/faxisapi.dll",
        "HTTP/1.0",
        "",
        NULL,
        INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE,
        0
        );
    if (!hSession) {
        return NULL;
    }

    return hSession;
}


BOOL
SendRequest(
    HINTERNET hSession,
    LPVOID Buffer,
    DWORD BufferSize
    )
{
    BOOL Rslt = HttpSendRequestA(
        hSession,
        NULL,
        0,
        Buffer,
        BufferSize
        );
    if (!Rslt) {
        return FALSE;
    }

    DWORD Code, Size;
    Size = sizeof(DWORD);
    if (!HttpQueryInfoA( hSession, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &Code, &Size, NULL )) {
        return FALSE;
    }

    if (Code != HTTP_STATUS_OK) {
        return FALSE;
    }

    return TRUE;
}


extern "C"
VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    )
{
    MemFree( Buffer );
}


extern "C"
BOOL
WINAPI
FaxClose(
    IN HANDLE FaxHandle
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_CLOSE;
    iFaxGeneral.FaxHandle = FaxHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, NULL, 0 );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxConnectFaxServerW(
    IN  LPWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )
{
    CHAR MachineNameA[64];


    if (hInternet) {
        InternetCloseHandle( hInternet );
    }

    if (hConnection) {
        InternetCloseHandle( hConnection );
    }

    if (!hHeap) {
        hHeap = HeapInitialize( NULL, NULL, NULL, 0 );
    }

    WideCharToMultiByte(
        CP_ACP,
        0,
        MachineName,
        -1,
        MachineNameA,
        sizeof(MachineNameA),
        NULL,
        NULL
        );

    hInternet = InternetOpenA(
        "FaxCom",
        INTERNET_OPEN_TYPE_PRECONFIG,
        NULL,
        NULL,
        0
        );
    if (!hInternet) {
        return FALSE;
    }

    hConnection = InternetConnectA(
        hInternet,
        MachineNameA,
        INTERNET_DEFAULT_HTTP_PORT,
        NULL,
        NULL,
        INTERNET_SERVICE_HTTP,
        0,
        0
        );
    if (!hConnection) {
        return FALSE;
    }

    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_CONNECT iFaxConnect;

    iFaxConnect.Command = ICMD_CONNECT;
    wcscpy( iFaxConnect.ServerName, MachineName );

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxConnect, sizeof(IFAX_CONNECT) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    DWORD Code, Size;
    HttpQueryInfo( hSession, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &Code, &Size, NULL );

    Rslt = GetResponse( hSession, (LPBYTE)FaxHandle, sizeof(HANDLE) );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *PortInfoBuffer,
    OUT LPDWORD PortsReturned
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_ENUM_PORTS;
    iFaxGeneral.FaxHandle = FaxHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)PortsReturned, sizeof(DWORD) );
    if (Rslt) {
        Rslt = GetResponseAlloc( hSession, PortInfoBuffer );
    }

    if (Rslt) {
        PFAX_PORT_INFOW PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

        for (DWORD i=0; i<*PortsReturned; i++) {
            FixupStringIn( PortInfo[i].DeviceName, PortInfo );
            FixupStringIn( PortInfo[i].Tsid, PortInfo );
            FixupStringIn( PortInfo[i].Csid, PortInfo );
        }
    }

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxOpenPort(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_OPEN_PORT iFaxOpenPort;

    iFaxOpenPort.Command    = ICMD_OPEN_PORT;
    iFaxOpenPort.FaxHandle  = FaxHandle;
    iFaxOpenPort.DeviceId   = DeviceId;
    iFaxOpenPort.Flags      = Flags;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxOpenPort, sizeof(IFAX_OPEN_PORT) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)FaxPortHandle, sizeof(HANDLE) );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT LPBYTE *PortInfoBuffer
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_GET_PORT;
    iFaxGeneral.FaxHandle = FaxPortHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponseAlloc( hSession, PortInfoBuffer );

    if (Rslt) {
        PFAX_PORT_INFOW PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;
        FixupStringIn( PortInfo->DeviceName, PortInfo );
        FixupStringIn( PortInfo->Tsid, PortInfo );
        FixupStringIn( PortInfo->Csid, PortInfo );
    }

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxSetPortW(
    IN  HANDLE FaxPortHandle,
    IN  LPBYTE PortInfoBuffer
    )
{
    PFAX_PORT_INFOW PortInfo = (PFAX_PORT_INFOW) PortInfoBuffer;

    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    DWORD Size = sizeof(IFAX_SET_PORT) + PortInfoSize( PortInfo );
    DWORD Offset = sizeof(IFAX_SET_PORT);

    PIFAX_SET_PORT iFaxSetPort = (PIFAX_SET_PORT) MemAlloc( Size );
    if (!iFaxSetPort) {
        return FALSE;
    }

    iFaxSetPort->Command                 = ICMD_SET_PORT;
    iFaxSetPort->FaxPortHandle           = FaxPortHandle;
    iFaxSetPort->PortInfo.SizeOfStruct   = PortInfo->SizeOfStruct;
    iFaxSetPort->PortInfo.DeviceId       = PortInfo->DeviceId;
    iFaxSetPort->PortInfo.State          = PortInfo->State;
    iFaxSetPort->PortInfo.Flags          = PortInfo->Flags;
    iFaxSetPort->PortInfo.Rings          = PortInfo->Rings;
    iFaxSetPort->PortInfo.Priority       = PortInfo->Priority;

    StoreString( PortInfo->DeviceName, (LPDWORD)iFaxSetPort->PortInfo.DeviceName, (LPBYTE)iFaxSetPort, &Offset );
    StoreString( PortInfo->Csid, (LPDWORD)iFaxSetPort->PortInfo.Csid, (LPBYTE)iFaxSetPort, &Offset );
    StoreString( PortInfo->Tsid, (LPDWORD)iFaxSetPort->PortInfo.Tsid, (LPBYTE)iFaxSetPort, &Offset );

    BOOL Rslt = SendRequest( hSession, (LPVOID) iFaxSetPort, Size );

    MemFree( iFaxSetPort );

    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, NULL, 0 );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxGetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GET_ROUTINGINFO iFaxGetRoutingInfo;

    iFaxGetRoutingInfo.Command = ICMD_GET_ROUTINGINFO;
    iFaxGetRoutingInfo.FaxPortHandle = FaxPortHandle;
    wcsncpy( iFaxGetRoutingInfo.RoutingGuid, RoutingGuid, MAX_GUID_STRING_LEN );

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGetRoutingInfo, sizeof(IFAX_GET_ROUTINGINFO) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)RoutingInfoBufferSize, sizeof(DWORD) );
    if (Rslt) {
        Rslt = GetResponseAlloc( hSession, RoutingInfoBuffer );
    }

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
    return TRUE;
}


extern "C"
BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  HANDLE FaxPortHandle,
    OUT LPBYTE *StatusBuffer
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_GET_DEVICE_STATUS;
    iFaxGeneral.FaxHandle = FaxPortHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponseAlloc( hSession, StatusBuffer );

    PFAX_DEVICE_STATUSW DeviceStatus = (PFAX_DEVICE_STATUSW) *StatusBuffer;

    FixupStringIn( DeviceStatus->CallerId, DeviceStatus );
    FixupStringIn( DeviceStatus->Csid, DeviceStatus );
    FixupStringIn( DeviceStatus->DeviceName, DeviceStatus );
    FixupStringIn( DeviceStatus->DocumentName, DeviceStatus );
    FixupStringIn( DeviceStatus->PhoneNumber, DeviceStatus );
    FixupStringIn( DeviceStatus->RoutingString, DeviceStatus );
    FixupStringIn( DeviceStatus->SenderName, DeviceStatus );
    FixupStringIn( DeviceStatus->RecipientName, DeviceStatus );
    FixupStringIn( DeviceStatus->StatusString, DeviceStatus );
    FixupStringIn( DeviceStatus->Tsid, DeviceStatus );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN  HANDLE FaxPortHandle,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_ENUM_ROUTING_METHODS;
    iFaxGeneral.FaxHandle = FaxPortHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)MethodsReturned, sizeof(DWORD) );
    if (Rslt) {
        Rslt = GetResponseAlloc( hSession, RoutingInfoBuffer );
    }

    if (Rslt) {
        PFAX_ROUTING_METHODW RoutingMethod = (PFAX_ROUTING_METHODW) *RoutingInfoBuffer;
        for (DWORD i=0; i<*MethodsReturned; i++) {
            FixupStringIn( RoutingMethod[i].DeviceName, RoutingMethod );
            FixupStringIn( RoutingMethod[i].Guid, RoutingMethod );
            FixupStringIn( RoutingMethod[i].FriendlyName, RoutingMethod );
            FixupStringIn( RoutingMethod[i].FunctionName, RoutingMethod );
            FixupStringIn( RoutingMethod[i].ExtensionImageName, RoutingMethod );
            FixupStringIn( RoutingMethod[i].ExtensionFriendlyName, RoutingMethod );
        }
    }

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN  HANDLE FaxPortHandle,
    IN  LPWSTR RoutingGuid,
    IN  BOOL Enabled
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_ENABLE_ROUTING_METHOD iFaxEnableRouting;

    iFaxEnableRouting.Command = ICMD_ENABLE_ROUTING_METHOD;
    iFaxEnableRouting.FaxPortHandle = FaxPortHandle;
    iFaxEnableRouting.Enabled = Enabled;

    wcsncpy( iFaxEnableRouting.RoutingGuid, RoutingGuid, MAX_GUID_STRING_LEN );

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxEnableRouting, sizeof(IFAX_ENABLE_ROUTING_METHOD) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, NULL, 0 );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxGetVersion(
    IN  HANDLE FaxHandle,
    OUT LPDWORD Version
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_GET_VERSION;
    iFaxGeneral.FaxHandle = FaxHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)Version, sizeof(DWORD) );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\ddevmain.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dcomputer.h

Abstract:

    This header prototypes the computer selection dialog.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __DIALOG_DEVICEMAIN_H_
#define __DIALOG_DEVICEMAIN_H_

#include "resource.h"

class CInternalDevice;    // forward declaration
class CFaxComponentData;
class CFaxComponent;

class CFaxDeviceSettingsPropSheet {
public:

    CFaxDeviceSettingsPropSheet( HINSTANCE hInstance, LONG_PTR hMmcNotify, CInternalDevice * NodePtr, CFaxComponent * pComp );

    ~CFaxDeviceSettingsPropSheet();

    HPROPSHEETPAGE GetHandle() { return _hPropSheet;}

private:

    static INT_PTR APIENTRY DlgProc( HWND hwndDlg,
                                     UINT message,
                                     WPARAM wParam,
                                     LPARAM lParam );

    HRESULT UpdateData( HWND hwndDlg );
    HRESULT ValidateData( HWND hwndDlg );

    static UINT CALLBACK PropSheetPageProc(
                                   HWND hwnd,      
                                   UINT uMsg,      
                                   LPPROPSHEETPAGE ppsp        
                                   );

    //
    // NOTE: The following **must** be consecutive.
    //

    PROPSHEETPAGE       _PropSheet;    

    LONG_PTR            _hMmcNotify;
    HPROPSHEETPAGE      _hPropSheet;
    CInternalDevice *   _pOwnNode;
    CFaxComponentData * _pCompData;
    CFaxComponent *     _pComp;

    DWORD               _dwDeviceId;
    HANDLE              _hFaxServer;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\dgenprop.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dcomputer.cpp

Abstract:

    This file contains implementation of
    the computer selection dialog.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#include "stdafx.h"
#include "dgenprop.h"

#include "faxcompd.h"   // IComponentData
#include "inode.h"      // internal node
#include "iroot.h"      // root node

#include "adminhlp.h"

#pragma hdrstop

#define MyHideWindow(_hwnd)   ::SetWindowLong((_hwnd),GWL_STYLE,::GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CFaxGeneralSettingsPropSheet::CFaxGeneralSettingsPropSheet(
                                                          IN HINSTANCE hInstance,
                                                          IN LONG_PTR hMmcNotify,
                                                          IN CInternalRoot * NodePtr
                                                          )
: _hMmcNotify( hMmcNotify ),
_pOwnNode( NodePtr )
/*++

Routine Description:

    Constructor

Arguments:

    hInstance - the instance pointer
    hMmcNotify - the MMC notify handle
    NodePtr - a pointer to the owning node

Return Value:

    None.

--*/
{
    DebugPrint(( TEXT("CFaxGeneralSettingsPropSheet Created") ));
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE | PSP_USECALLBACK ;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDP_GENERAL_PROPS);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDP_GENERAL_PROPS_TITLE);
    _PropSheet.pfnDlgProc  = CFaxGeneralSettingsPropSheet::DlgProc;
    _PropSheet.lParam = (LONG_PTR)this;
    _PropSheet.pfnCallback = &PropSheetPageProc;

    _hPropSheet = NULL;
    _hPropSheet = CreatePropertySheetPage( &_PropSheet );

    INITCOMMONCONTROLSEX icex;
                icex.dwSize = sizeof(icex);
                icex.dwICC = ICC_DATE_CLASSES;
                InitCommonControlsEx(&icex);

    assert( _hPropSheet != NULL );

    _hFaxServer = NodePtr->m_pCompData->m_FaxHandle;
    _pCompData = NodePtr->m_pCompData;
    assert( _hFaxServer );

    _MapiProfiles = NULL;
}

CFaxGeneralSettingsPropSheet::~CFaxGeneralSettingsPropSheet()
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.

--*/
{
    DebugPrint(( TEXT("CFaxGeneralSettingsPropSheet Destroyed") ));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Dialog Proc
//
//

INT_PTR
APIENTRY
CFaxGeneralSettingsPropSheet::DlgProc(
                                     IN HWND hwndDlg,
                                     IN UINT message,
                                     IN WPARAM wParam,
                                     IN LPARAM lParam
                                     )
/*++

Routine Description:

    Dialog Procedure

Arguments:

    hwndDlg - the hwnd of the dialog
    message - the message
    wParam, lParam - the window message parameters

Return Value:

    BOOL

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxGeneralSettingsPropSheet::DlgProc") ));

    BOOL                    fRet = FALSE;
    HWND                    hwnd = NULL;
    HWND                    hwndSheet = NULL;
    PFAX_CONFIGURATION      config= NULL;
    TCHAR                   buffer[ 20 ];

    switch( message ) {
        case WM_INITDIALOG:
            {

                DebugPrint(( TEXT("CFaxGeneralSettingsPropSheet::DlgProc -- WM_INITDIALOG\n") ));

                assert( lParam != NULL );
                LONG_PTR lthis = ((CFaxGeneralSettingsPropSheet *)lParam)->_PropSheet.lParam;

                CFaxGeneralSettingsPropSheet * pthis = (CFaxGeneralSettingsPropSheet *)lthis;

                assert( pthis != NULL );

                SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );

                // get the fax config data
                try {
                    if( pthis->_pCompData->QueryRpcError() ) {
                        fRet = FALSE;
                        break;
                    }

                    if( !FaxGetConfiguration( pthis->_hFaxServer, &config ) ) {
                        
                        if (GetLastError() != ERROR_ACCESS_DENIED) {
                            pthis->_pCompData->NotifyRpcError( TRUE );
                            assert(FALSE);            
                        } 

                        ::GlobalStringTable->SystemErrorMsg( GetLastError() );
                        
                        fRet = FALSE;
                        break;
                    }
                } catch( ... ) {
                    pthis->_pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                    ::GlobalStringTable->SystemErrorMsg( GetLastError() );
                    fRet = FALSE;
                    break;
                }

                // setup retry count
                ZeroMemory( (PVOID)buffer, sizeof( TCHAR ) * 20 );
                SetDlgItemText( hwndDlg, IDC_RETRY_COUNT, _itot( config->Retries, buffer, 10 ) );
                SendMessage( GetDlgItem(hwndDlg, IDC_RETRY_COUNT), EM_SETLIMITTEXT, 2 , 0 );

                // setup retry delay
                ZeroMemory( (PVOID)buffer, sizeof( TCHAR ) * 20 );
                SetDlgItemText( hwndDlg, IDC_RETRY_DELAY, _itot( config->RetryDelay, buffer, 10 ) );
                SendMessage( GetDlgItem(hwndDlg, IDC_RETRY_DELAY), EM_SETLIMITTEXT, 2 , 0 );

                // setup unsent keep time
                ZeroMemory( (PVOID)buffer, sizeof( TCHAR ) * 20 );
                SetDlgItemText( hwndDlg, IDC_KEEP_DAYS, _itot( config->DirtyDays, buffer, 10 ) );
                SendMessage( GetDlgItem(hwndDlg, IDC_KEEP_DAYS), EM_SETLIMITTEXT, 2 , 0 );

                // setup print banner
                hwnd = GetDlgItem( hwndDlg, IDC_PRINT_BANNER );
                if( config->Branding == TRUE ) {
                    SendMessage( hwnd, BM_SETCHECK, BST_CHECKED, 0 );
                } else {
                    SendMessage( hwnd, BM_SETCHECK, BST_UNCHECKED, 0 );
                }

                // setup use TSID
                hwnd = GetDlgItem( hwndDlg, IDC_USE_TSID );
                if( config->UseDeviceTsid == TRUE ) {
                    SendMessage( hwnd, BM_SETCHECK, BST_CHECKED, 0 );
                } else {
                    SendMessage( hwnd, BM_SETCHECK, BST_UNCHECKED, 0 );
                }

                // setup use server coverpages
                hwnd = GetDlgItem( hwndDlg, IDC_FORCESERVERCP );
                if( config->ServerCp == TRUE ) {
                    SendMessage( hwnd, BM_SETCHECK, BST_CHECKED, 0 );
                } else {
                    SendMessage( hwnd, BM_SETCHECK, BST_UNCHECKED, 0 );
                }

                // setup archive outgoing faxes
                hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE );
                if( config->ArchiveOutgoingFaxes == TRUE ) {
                    SendMessage( hwnd, BM_SETCHECK, BST_CHECKED, 0 );
                    hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE_PATH );
                    EnableWindow( hwnd, TRUE );
                    hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE_BROWSE );
                    EnableWindow( hwnd, TRUE );
                } else {
                    SendMessage( hwnd, BM_SETCHECK, BST_UNCHECKED, 0 );
                    hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE_PATH );
                    EnableWindow( hwnd, FALSE );
                    hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE_BROWSE );
                    EnableWindow( hwnd, FALSE );
                }

                // setup archive path
                SetDlgItemText( hwndDlg, IDC_ARCHIVE_PATH, config->ArchiveDirectory );
                SendMessage( GetDlgItem(hwndDlg, IDC_ARCHIVE_PATH), EM_SETLIMITTEXT, MAX_PATH-16 , 0 );

                //
                // setup server mapi profile box
                //
                if ( !FaxGetMapiProfiles( pthis->_hFaxServer, &pthis->_MapiProfiles ) ) {
                    pthis->_MapiProfiles = NULL;
                    hwnd = GetDlgItem( hwndDlg, IDC_SERVER_MAPI_PROFILE );
                    SendMessage( hwnd, CB_RESETCONTENT, 0 , 0 );
                    MyHideWindow(hwnd);
                    MyHideWindow(GetDlgItem(hwndDlg, IDC_STATIC_MAPI_PROFILE) );
                } else {
                    hwnd = GetDlgItem( hwndDlg, IDC_SERVER_MAPI_PROFILE );
                    EnableWindow( GetDlgItem( hwndDlg, IDC_STATIC_MAPI_PROFILE ), TRUE );
                    EnableWindow( hwnd, TRUE );
                    SendMessage( hwnd,CB_RESETCONTENT, 0 , 0 );
                    EnumMapiProfiles( hwnd, (LPTSTR) config->InboundProfile, pthis );
                }

                // initialize time controls
                InitTimeControl( GetDlgItem( hwndDlg, IDC_TIMESTART ),
                                 config->StartCheapTime
                               );

                InitTimeControl( GetDlgItem( hwndDlg, IDC_TIMEEND ),
                                 config->StopCheapTime
                               );

                FaxFreeBuffer( (PVOID) config );

                pthis->_pCompData->IncPropSheetCount();

                fRet = TRUE;
                break;
            }

        case WM_COMMAND:
            {
                DebugPrint(( TEXT("CFaxGeneralSettingsPropSheet::DlgProc -- WM_COMMAND\n") ));
                // activate apply button

                WORD wID = LOWORD( wParam );

                switch( HIWORD( wParam) ) {
                    case EN_CHANGE:
                        switch( wID ) {
                            case IDC_ARCHIVE_PATH:
                            case IDC_RETRY_COUNT:
                            case IDC_RETRY_DELAY:
                            case IDC_KEEP_DAYS:
                                hwndSheet = GetParent( hwndDlg );
                                PropSheet_Changed( hwndSheet, hwndDlg );
                                break;
                        }
                        break;
                    case CBN_SELCHANGE:
                        if (wID == IDC_SERVER_MAPI_PROFILE) {
                            hwndSheet = GetParent( hwndDlg );
                            PropSheet_Changed( hwndSheet, hwndDlg );
                        }
                        break;
                    case BN_CLICKED:
                        switch( wID ) {
                            case IDC_ARCHIVE_BROWSE:
                                if( BrowseForDirectory( hwndDlg ) == TRUE ) {
                                    hwndSheet = GetParent( hwndDlg );
                                    PropSheet_Changed( hwndSheet, hwndDlg );
                                }
                                break;
                            case IDC_ARCHIVE:
                                if( SendDlgItemMessage( hwndDlg, IDC_ARCHIVE, BM_GETCHECK, 0, 0 ) == BST_CHECKED ) {
                                    hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE_PATH );
                                    EnableWindow( hwnd, TRUE );
                                    hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE_BROWSE );
                                    EnableWindow( hwnd, TRUE );
                                } else {
                                    hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE_PATH );
                                    EnableWindow( hwnd, FALSE );
                                    hwnd = GetDlgItem( hwndDlg, IDC_ARCHIVE_BROWSE );
                                    EnableWindow( hwnd, FALSE );
                                }
                                //fall through
                            case IDC_PRINT_BANNER:
                            case IDC_USE_TSID:
                            case IDC_FORCESERVERCP:
                                hwndSheet = GetParent( hwndDlg );
                                PropSheet_Changed( hwndSheet, hwndDlg );
                                break;
                        }
                        break;
                } // switch

                fRet = TRUE;
                break;
            }
        case WM_HELP:
                WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle,
                        FAXCFG_HELP_FILENAME,
                        HELP_WM_HELP,
                        (ULONG_PTR) &ServerGeneralHelpIDs);
                fRet = TRUE;
                break;

        case WM_CONTEXTMENU:
                WinHelp((HWND) wParam,
                        FAXCFG_HELP_FILENAME,
                        HELP_CONTEXTMENU,
                        (ULONG_PTR) &ServerGeneralHelpIDs);
                fRet = TRUE;
                break;

        case WM_NOTIFY:
            {
//        DebugPrint(( TEXT("CFaxGeneralSettingsPropSheet::DlgProc -- WM_NOTIFY\n") ));

                CFaxGeneralSettingsPropSheet * pthis =
            (CFaxGeneralSettingsPropSheet *)GetWindowLongPtr( hwndDlg,
                                                              DWLP_USER );

                switch( ((LPNMHDR) lParam)->code ) {
                    case PSN_APPLY:
                        // apply changes here!!
                        if( SUCCEEDED( pthis->UpdateData( hwndDlg ) ) ) {
                            MMCPropertyChangeNotify( pthis->_hMmcNotify, (LONG_PTR)pthis->_pOwnNode );
                            // deactivate apply button
                            hwndSheet = GetParent( hwndDlg );
                            SetWindowLongPtr( hwndDlg,
                                              DWLP_MSGRESULT,
                                              PSNRET_NOERROR );
                            //PropSheet_UnChanged( hwndSheet, hwndDlg );
                        } else {
                            SetWindowLongPtr( hwndDlg,
                                              DWLP_MSGRESULT,
                                              PSNRET_INVALID_NOCHANGEPAGE );
                        }
                        fRet = TRUE;
                        break;
                    case DTN_DATETIMECHANGE:
                        // activate apply button
                        hwndSheet = GetParent( hwndDlg );
                        PropSheet_Changed( hwndSheet, hwndDlg );
                        fRet = 0;
                        break;
                } // switch

                break;
            }

        case WM_DESTROY:
            {
                DebugPrint(( TEXT("CFaxGeneralSettingsPropSheet::DlgProc -- WM_DESTROY\n") ));
                CFaxGeneralSettingsPropSheet * pthis =
                (CFaxGeneralSettingsPropSheet *)GetWindowLongPtr( hwndDlg,
                                                                  DWLP_USER );

                if( pthis != NULL ) {
                    pthis->_pCompData->DecPropSheetCount();
                    MMCFreeNotifyHandle( pthis->_hMmcNotify );
                } else {
                    assert( FALSE );
                }

                fRet = TRUE;
                break;
            }
    } // switch

    return fRet;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Internal Functions.
//
//

HRESULT
CFaxGeneralSettingsPropSheet::UpdateData(
                                        IN HWND hwndDlg
                                        )
/*++

Routine Description:

    This routine writes the data manipulated in the property page out to the
    fax service.

    The settings are updated in the property sheet because this
    allows the property sheet to complete even if the owner node
    has already been destroyed.

Arguments:

    hwndDlg - the dialog's window handle

Return Value:

    HRESULT indicating SUCCEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::UpdateData") ));

    assert( hwndDlg != NULL );

    HRESULT             hr = S_OK;
    HWND                hwndSheet;
    BOOL                rc;
    TCHAR               buffer[ MAX_PATH + 1 ];
    PFAX_CONFIGURATION  config = NULL;
    HWND                hwndControl;
    int                 index;
    TCHAR               MapiProfile[100];

    ZeroMemory( buffer, sizeof(TCHAR) * MAX_PATH + 1 );
    try {
        do {
            // get the fax config data

            if( _pCompData->QueryRpcError() ) {
                hr = E_UNEXPECTED;
                break;
            }

            if( !FaxGetConfiguration( _hFaxServer, &config ) ) {
                if (GetLastError() != ERROR_ACCESS_DENIED) {
                    _pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);            
                }
                ::GlobalStringTable->SystemErrorMsg( GetLastError() );

                hr = E_UNEXPECTED;
                break;
            }

            // setup retry count
            config->Retries = GetDlgItemInt( hwndDlg,
                                             IDC_RETRY_COUNT,  // control identifier
                                             &rc,
                                             FALSE );
            if( rc == FALSE ) {
                hr = E_UNEXPECTED;
                break;
            }

            // validate and limit the retry count
            config->Retries = max(config->Retries,0);
            config->Retries = min(config->Retries,99);


            // setup retry delay
            config->RetryDelay = GetDlgItemInt( hwndDlg,
                                                IDC_RETRY_DELAY,  // control identifier
                                                &rc,
                                                FALSE );
            if( rc == FALSE ) {
                hr = E_UNEXPECTED;
                break;
            }

            // validate and limit the retry delay
            config->RetryDelay = max(config->RetryDelay,0);
            config->RetryDelay = min(config->RetryDelay,99);

            // setup unsent keep time
            config->DirtyDays = GetDlgItemInt( hwndDlg,
                                               IDC_KEEP_DAYS,  // control identifier
                                               &rc,
                                               FALSE );
            if( rc == FALSE ) {
                hr = E_UNEXPECTED;
                break;
            }

            // validate and limit the dirty day
            config->DirtyDays = max(config->DirtyDays,0);
            config->DirtyDays = min(config->DirtyDays,99);


            // setup print banner
            if( IsDlgButtonChecked( hwndDlg, IDC_PRINT_BANNER ) == BST_CHECKED ) {
                config->Branding = TRUE;
            } else {
                config->Branding = FALSE;
            }

            // setup use TSID
            if( IsDlgButtonChecked( hwndDlg, IDC_USE_TSID ) == BST_CHECKED ) {
                config->UseDeviceTsid = TRUE;
            } else {
                config->UseDeviceTsid = FALSE;
            }

            // setup use server coverpages
            if( IsDlgButtonChecked( hwndDlg, IDC_FORCESERVERCP ) == BST_CHECKED ) {
                config->ServerCp = TRUE;
            } else {
                config->ServerCp = FALSE;
            }

            // setup archive outgoing faxes
            config->ArchiveOutgoingFaxes = (IsDlgButtonChecked( hwndDlg, IDC_ARCHIVE ) == BST_CHECKED );
                
            if (config->ArchiveOutgoingFaxes) {
                GetDlgItemText( hwndDlg, IDC_ARCHIVE_PATH, buffer, MAX_PATH );
                if (!(*buffer)) {
                    hwndSheet = GetParent( hwndDlg );
                        ::GlobalStringTable->PopUpMsg( hwndSheet, IDS_NO_ARCHIVE_PATH, TRUE , 0 );
                        hr = E_UNEXPECTED;
                        break;
                }
                
                if((PathIsDirectory( buffer ) == FALSE) ) {
                    //
                    // try to create the directory
                    //
                    MakeDirectory( buffer );
                    if (! PathIsDirectory( buffer ) ) {

                        hwndSheet = GetParent( hwndDlg );
                        ::GlobalStringTable->PopUpMsg( hwndSheet, IDS_BAD_ARCHIVE_PATH, TRUE , 0 );
                        hr = E_UNEXPECTED;
                        break;
                    }
                }
    
                config->ArchiveDirectory = buffer;            

            }


            // get the time control times.
            SYSTEMTIME      time;

            ZeroMemory( (PVOID) &time, sizeof( SYSTEMTIME ) );
            DateTime_GetSystemtime( GetDlgItem( hwndDlg, IDC_TIMESTART ), &time );
            config->StartCheapTime.Hour = time.wHour;
            config->StartCheapTime.Minute = time.wMinute;

            ZeroMemory( (PVOID) &time, sizeof( SYSTEMTIME ) );
            DateTime_GetSystemtime( GetDlgItem( hwndDlg, IDC_TIMEEND ), &time );
            config->StopCheapTime.Hour = time.wHour;
            config->StopCheapTime.Minute = time.wMinute;

            // get the mapi profile
            if (_MapiProfiles) {
                hwndControl = GetDlgItem( hwndDlg, IDC_SERVER_MAPI_PROFILE );
                index = (int)SendMessage( hwndControl, CB_GETCURSEL, 0 , 0 );
                if (index <= 0) {
                   config->InboundProfile = NULL;
                } else {
                  index = (int)SendMessage( hwndControl, CB_GETLBTEXT,index,(LPARAM) MapiProfile );
                  if (index != CB_ERR) {
                    config->InboundProfile = MapiProfile;
                  }
                }
            }

            if( !FaxSetConfiguration( _hFaxServer, config ) ) {
                if (GetLastError() != ERROR_ACCESS_DENIED) {
                    _pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                }
                                
                ::GlobalStringTable->SystemErrorMsg( GetLastError() );



                hr= E_UNEXPECTED;
                break;
            }
        } while( 0 );
    } catch( ... ) {
        _pCompData->NotifyRpcError( TRUE );
        assert(FALSE);
        ::GlobalStringTable->SystemErrorMsg( GetLastError() );
        hr = E_UNEXPECTED;
    }

    if(config != NULL ) {
        FaxFreeBuffer( (PVOID) config );
        config = NULL;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Utility Functions
//
//

BOOL  CFaxGeneralSettingsPropSheet::InitTimeControl(
                                                   IN HWND hwndTimeCtrl,
                                                   IN FAX_TIME faxTime
                                                   )
/*++

Routine Description:

    This function sets the time.

Arguments:

    hwndTime - the time control's  window handle
    faxTime - a fax time struct to init the control to


Return Value:



--*/
{
    SYSTEMTIME  time;

    TCHAR       Is24H[2], IsRTL[2], *pszTimeFormat = ::GlobalStringTable->GetString(IDS_TIME_FORMAT);

    if (GetLocaleInfo( LOCALE_USER_DEFAULT,LOCALE_ITIME, Is24H,sizeof(Is24H) ) && Is24H[0] == TEXT('1')) {
        pszTimeFormat = ::GlobalStringTable->GetString(IDS_24HTIME_FORMAT);
    }
    else if (GetLocaleInfo( LOCALE_USER_DEFAULT,LOCALE_ITIMEMARKPOSN, IsRTL,sizeof(IsRTL) ) && IsRTL[0] == TEXT('1')) {
        pszTimeFormat = ::GlobalStringTable->GetString(IDS_RTLTIME_FORMAT);
    }

    // initialize time
    GetLocalTime( &time );  // just to fill the struct in

    time.wHour = faxTime.Hour;
    time.wMinute = faxTime.Minute;
    time.wSecond = 0;
    time.wMilliseconds = 0;

    DateTime_SetFormat( hwndTimeCtrl,pszTimeFormat );
    DateTime_SetSystemtime( hwndTimeCtrl, GDT_VALID, &time );

    return TRUE;
}

BOOL
CFaxGeneralSettingsPropSheet::BrowseForDirectory(
                                                IN HWND hwndDlg
                                                )
/*++

Routine Description:

    Browse for a directory

Arguments:

    hwndDlg - Specifies the dialog window on which the Browse button is displayed

Return Value:

    TRUE if successful, FALSE if the user presses Cancel

--*/

{
    LPITEMIDLIST    pidl;
    WCHAR           buffer[MAX_PATH];
    VOID            SHFree(LPVOID);
    BOOL            result = FALSE;
    LPMALLOC        pMalloc;

    BROWSEINFO bi = {
        hwndDlg,
        NULL,
        buffer,
        ::GlobalStringTable->GetString( IDS_GET_ARCHIVE_DIRECTORY ),
        BIF_RETURNONLYFSDIRS,
        NULL,
        (LPARAM) buffer,
    };


    if(! GetDlgItemText( hwndDlg, IDC_ARCHIVE_PATH, buffer, MAX_PATH))
        buffer[0] = 0;

    if(pidl = SHBrowseForFolder(&bi)) {

        if(SHGetPathFromIDList(pidl, buffer)) {

            if(wcslen(buffer) > MAX_PATH-16)
                ::GlobalStringTable->PopUpMsg(0,IDS_DIR_TOO_LONG, TRUE, NULL );
            else {
                SetDlgItemText(hwndDlg, IDC_ARCHIVE_PATH, buffer);
                result = TRUE;
            }
        }

        SHGetMalloc(&pMalloc);

        pMalloc->Free(pidl);

        pMalloc->Release();
    }

    return result;
}


BOOL
CFaxGeneralSettingsPropSheet::EnumMapiProfiles(
    HWND hwnd,
    LPWSTR SelectedProfile,
    CFaxGeneralSettingsPropSheet * pthis
    )
/*++

Routine Description:

    Put the mapi profiles in the combo box, selects the specified profile

Arguments:

    hwnd - window handle to mapi profiles combo box

Return Value:

    NONE

--*/
{
    LPWSTR MapiProfiles;
    int index;

    MapiProfiles = (LPWSTR) pthis->_MapiProfiles;

    if (!MapiProfiles) {
        return FALSE;
    }

    //
    // insert a "none" selection as the first entry
    //
    ::SendMessage(
                  hwnd,
                  CB_ADDSTRING,
                  0,
                  (LPARAM) ::GlobalStringTable->GetString( IDS_NO_MAPI )
                 );

    while (MapiProfiles && *MapiProfiles) {
        ::SendMessage(
                     hwnd,
                     CB_ADDSTRING,
                     0,
                     (LPARAM) MapiProfiles
                     );
        MapiProfiles += wcslen(MapiProfiles) + 1;
    }

    if (SelectedProfile) {
        index = (int)SendMessage(hwnd,CB_FINDSTRINGEXACT,-1,(LPARAM) SelectedProfile);
    } else {
        index = 0;
    }

    if (index != CB_ERR) {
        SendMessage(hwnd, CB_SETCURSEL, index, 0);
    }

    return TRUE;
}

UINT
CALLBACK
CFaxGeneralSettingsPropSheet::PropSheetPageProc(
                                               HWND hwnd,
                                               UINT uMsg,
                                               LPPROPSHEETPAGE ppsp
                                               )
/*++

Routine Description:

    Dialog Init and destroy routine

Arguments:

    hwndDlg - the hwnd of the dialog - will be NULL
    uMsg - the message PSPCB_CREATE or PSPCB_RELEASE
    ppsp - pointer to a PROPERTYSHEETPAGE struct

Return Value:

    UINT - nonzero to allow, zero to fail

--*/
{
    CFaxGeneralSettingsPropSheet * pthis = NULL;
    UINT retval = 1;

    // release my property sheet
    if( uMsg == PSPCB_RELEASE ) {
        try {
            pthis = (CFaxGeneralSettingsPropSheet * )(ppsp->lParam);
            delete pthis;
        } catch( ... ) {
            assert( FALSE );
            retval = 0;
        }
    }
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\dgenprop.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dgenprop.h

Abstract:

    This header prototypes the general property sheet.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __DIALOG_GENPROP_H_
#define __DIALOG_GENPROP_H_

#include "resource.h"

class CInternalRoot;    // forward declaration
class CFaxComponentData;

class CFaxGeneralSettingsPropSheet {
public:

    CFaxGeneralSettingsPropSheet( HINSTANCE hInstance, LONG_PTR hMmcNotify, CInternalRoot * NodePtr );

    ~CFaxGeneralSettingsPropSheet();

    HPROPSHEETPAGE GetHandle() { return _hPropSheet;}

private:

    static INT_PTR APIENTRY DlgProc( HWND hwndDlg,
                                     UINT message,
                                     WPARAM wParam,
                                     LPARAM lParam );

    HRESULT UpdateData( HWND hwndDlg );

    static BOOL InitTimeControl( HWND hwndTime,
                          FAX_TIME faxTime
                        );

    static BOOL BrowseForDirectory( HWND hwndDlg );

    static UINT CALLBACK PropSheetPageProc(
                                          HWND hwnd,      
                                          UINT uMsg,      
                                          LPPROPSHEETPAGE ppsp        
                                          );

    static BOOL EnumMapiProfiles( HWND hwnd , LPWSTR SelectedProfile, CFaxGeneralSettingsPropSheet * pthis);

    //
    // NOTE: The following **must** be consecutive.
    //

    PROPSHEETPAGE       _PropSheet;    

    LONG_PTR            _hMmcNotify;
    HPROPSHEETPAGE      _hPropSheet;
    CInternalRoot *     _pOwnNode;
    CFaxComponentData * _pCompData;

    HANDLE              _hFaxServer;

    LPBYTE              _MapiProfiles;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\droutpri.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    droutepri.h

Abstract:

    This header prototypes the route extension pri dialog.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __DIALOG_ROUTE_PRI_H_
#define __DIALOG_ROUTE_PRI_H_

#include "resource.h"

class CInternalNode;        // forward declaration
class CInternalDevice;
class CFaxComponentData;
class CFaxComponent;

class CFaxRoutePriPropSheet {
public:

    CFaxRoutePriPropSheet( HINSTANCE hInstance, LONG_PTR hMmcNotify, CInternalNode * NodePtr, CFaxComponent * pComp );

    ~CFaxRoutePriPropSheet();

    HPROPSHEETPAGE GetHandle() { return _hPropSheet;}

private:

    static INT_PTR APIENTRY DlgProc( HWND hwndDlg,
                                     UINT message,
                                     WPARAM wParam,
                                     LPARAM lParam );

    HRESULT UpdateData( HWND hwndDlg );
    HRESULT PopulateListBox( HWND hwndDlg );
    HRESULT GetData();

    static UINT CALLBACK PropSheetPageProc(
                                          HWND hwnd,      
                                          UINT uMsg,      
                                          LPPROPSHEETPAGE ppsp        
                                          );

    //
    // NOTE: The following **must** be consecutive.
    //

    PROPSHEETPAGE               _PropSheet;    

    LONG_PTR                    _hMmcNotify;
    HPROPSHEETPAGE              _hPropSheet;
    CInternalNode *             _pOwnNode;
    CFaxComponentData *         _pCompData;
    CFaxComponent *             _pComp;

    PFAX_GLOBAL_ROUTING_INFO    _pRoutingMethod;                // buffer containing routing methods
    DWORD                       _iRoutingMethodCount;           // count of rounting methods
    PFAX_GLOBAL_ROUTING_INFO *  _pRoutingMethodIndex;           // index of routing methods
    DWORD                       _iRoutingMethodIndexCount;      // index size
    HANDLE                      _hFaxServer;    

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxadmin.cpp ===
// faxadmin.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f faxadminps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "faxadmin.h"

#include "faxadmin_i.c"
#include "FaxSnapin.h"  // Fax Snapin
#include "FaxSAbout.h"  // Fax SnapinAbout
#include "faxstrt.h"

#pragma hdrstop

CComModule     _Module;
CStringTable * GlobalStringTable;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_FaxSnapin, CFaxSnapin)
OBJECT_ENTRY(CLSID_FaxSnapinAbout, CFaxSnapinAbout)
END_OBJECT_MAP()

extern "C"
BOOL 
WINAPI 
DllMain(
        IN HINSTANCE hInstance, 
        IN DWORD dwReason, 
        IN LPVOID /*lpReserved*/)
/*++

Routine Description:

    DLL main.
    Standard ATL code.
    
Arguments:

    hInstance - instance handle
    dwReason - DLL attach/detach/etc
    lpReserved - reserved

Return Value:

    BOOL indicating failure.

--*/
{
    if(dwReason == DLL_PROCESS_ATTACH) {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        if( _Module.GetLockCount() == 0 ) {
            GlobalStringTable = new CStringTable(hInstance);
            if (!GlobalStringTable) {
                return FALSE;
            }
        }
    } else if(dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
        if( _Module.GetLockCount() == 0 ) {
            if(GlobalStringTable != NULL) {
                delete GlobalStringTable;
            }
        }
    }
    return TRUE;    // ok
}

STDAPI 
DllCanUnloadNow(
                void)
/*++

Routine Description:

    Called to determine if the DLL is ok to unload.
    Standard ATL code.
    
Arguments:

    None.

Return Value:

    HRESULT S_OK to unload, S_FALSE to keep.

--*/
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

STDAPI 
DllGetClassObject(
                  IN REFCLSID rclsid, 
                  IN REFIID riid, 
                  OUT LPVOID* ppv)
/*++

Routine Description:

    Gets the class factory.
    
    Standard ATL code.
    
Arguments:

    rclsid - the clsid of the class.
    riid - interface id.
    ppv - the buffer to return the class object in.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)
/*++

Routine Description:

    Registers the in-proc com server.
    
    Standard ATL code.
    
Arguments:

    None.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI 
DllUnregisterServer(void)
/*++

Routine Description:

    UnRegisters the in-proc com server.
    
    Standard ATL code.
    
Arguments:

    None.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcconbar.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxconmenu.h

Abstract:

    This header prototypes my implementation of IExtendControlbar.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAX_ICOMPONENT_CONTROLBAR_H_
#define __FAX_ICOMPONENT_CONTROLBAR_H_

#include "resource.h"

class CFaxComponent; // forward decl

class CFaxComponentExtendControlbar : public IExtendControlbar
{
public:

    // constructor

    CFaxComponentExtendControlbar()
    {
        m_pFaxComponent = NULL;
    }
    
    // IExtendControlbar
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
        /* [in] */ LPCONTROLBAR pControlbar);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);

protected:
        CFaxComponent *     m_pFaxComponent;
};
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcconbar.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcconbar.cpp

Abstract:

    This file contains my implementation of IExtendControlbar for IComponent.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// faxconbar.cpp : Implementation of CFaxExtendControlbar 

#include "stdafx.h"
#include "faxcconbar.h"
#include "faxadmin.h"
#include "faxsnapin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "iroot.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxComponentExtendContextMenu - IExtendContextMenu implementation for IComponent
//
//

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentExtendControlbar::SetControlbar(
                                            IN LPCONTROLBAR pControlbar)
/*++

Routine Description:

    Stores the LPCONTROLBAR sent to the snapin.
    
Arguments:

    pControlbar - the LPCONTROLBAR to be set.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxComponentExtendControlbar::SetControlbar") ));

    assert(m_pFaxComponent != NULL );
    if( m_pFaxComponent == NULL ) {
        return E_UNEXPECTED;
    }

    if( pControlbar == NULL ) {
        DebugPrint(( TEXT("         ********************* FREE Controlbar") ));
        if( m_pFaxComponent->m_pControlbar != NULL ) {
            m_pFaxComponent->m_pControlbar->Release();
            m_pFaxComponent->m_pControlbar = NULL;
        }
    } else {
        DebugPrint(( TEXT("         ********************* SET Controlbar") ));
        // should only be called once??        
        assert( m_pFaxComponent->m_pControlbar == NULL );

        m_pFaxComponent->m_pControlbar = pControlbar;
        m_pFaxComponent->m_pControlbar->AddRef();
    }   
    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentExtendControlbar::ControlbarNotify(
                                               IN MMC_NOTIFY_TYPE event,
                                               IN LPARAM arg,
                                               IN LPARAM param)
/*++

Routine Description:

    Dispatch the ControbarNotify call to the correct node by extracting the
    cookie from the DataObject.
    
Arguments:

    event - the event type.
    arg, param - the arguments of the event.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxComponentExtendControlbar::ControlbarNotify") ));

    CFaxDataObject *    myDataObject = NULL;
    LONG_PTR            cookie = NULL;
    HRESULT             hr;

    if( event == MMCN_BTN_CLICK ) {

        ATLTRACE(_T("CFaxComponentExtendControlbar::ControlbarNotify: MMCN_BTN_CLICK\n"));

        assert( arg != NULL );
        if( arg == NULL ) {
            return E_POINTER;
        }

        myDataObject = ::ExtractOwnDataObject( (LPDATAOBJECT)arg );
        assert( myDataObject != NULL );
        if( myDataObject == NULL ) {
            return E_UNEXPECTED;
        }

        cookie = myDataObject->GetCookie();
        if( cookie == NULL ) {
            // root
            hr = m_pFaxComponent->pOwner->globalRoot->ControlBarOnBtnClick( m_pFaxComponent, myDataObject, param );
        } else {
            // child
            try {            
                hr = ((CInternalNode *)cookie)->ControlBarOnBtnClick( m_pFaxComponent, myDataObject, param );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }


    } else if( event == MMCN_SELECT ) {

        ATLTRACE(_T("CFaxComponentExtendControlbar::ControlbarNotify: MMCN_SELECT\n"));

        assert( param != NULL );
        if( param == NULL ) {
            return E_POINTER;
        }

#ifdef DEBUG
        if( HIWORD( arg ) == TRUE ) {
            DebugPrint(( TEXT("         +++++++++++ ControlbarNotify Select") ));
        } else {
            DebugPrint(( TEXT("         ----------- ControlbarNotify DESelect") ));
        }
#endif

        myDataObject = ::ExtractOwnDataObject( (LPDATAOBJECT)param );
        assert( myDataObject != NULL );
        if( myDataObject == NULL ) {
            return E_UNEXPECTED;
        }

        cookie = myDataObject->GetCookie();
        if( cookie == NULL ) {
            // root
            hr = m_pFaxComponent->pOwner->globalRoot->ControlBarOnSelect( m_pFaxComponent, arg, myDataObject );
        } else {
            // child
            try {            
                hr = ((CInternalNode *)cookie)->ControlBarOnSelect( m_pFaxComponent, arg, myDataObject );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcconmn.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcconmn.cpp

Abstract:

    This file contains my implementation of IExtendContextMenu for IComponent.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// faxconmenu.cpp : Implementation of CFaxExtendContextMenu
#include "stdafx.h"
#include "faxcconmn.h"
#include "faxadmin.h"
#include "faxsnapin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "iroot.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxExtendContextMenu implementation
//
//


HRESULT 
STDMETHODCALLTYPE 
CFaxComponentExtendContextMenu::AddMenuItems(
                                            IN LPDATAOBJECT piDataObject,
                                            IN LPCONTEXTMENUCALLBACK piCallback,
                                            IN OUT long __RPC_FAR *pInsertionAllowed)
/*++

Routine Description:

    This routine dispatches AddMenuItems to the correct node by using the
    cookie stored in piDataObject.
    
Arguments:

    piDataObject - the data object associated with the target node
    piCallback - the CONTEXTMENUCALLBACK used to add items
    pInsertionAllowed - flags to allow insertion

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxComponentExtendContextMenu::AddMenuItems") ));

    CFaxDataObject *    myDataObject = NULL;
    LONG_PTR            cookie;
    HRESULT             hr;

    assert( piDataObject != NULL );
    if( piDataObject == NULL ) {
        return E_POINTER;
    }
    if( piCallback == NULL ) {
        return E_POINTER;
    }
    if( pInsertionAllowed == NULL ) {
        return E_POINTER;
    }

    myDataObject = ExtractOwnDataObject( piDataObject );

    if( myDataObject == NULL ) {
        return E_UNEXPECTED;
    }

    cookie = myDataObject->GetCookie();

    if(cookie == NULL) {
        // root node
        assert( m_pFaxComponent != NULL );
        hr = m_pFaxComponent->pOwner->globalRoot->ComponentContextMenuAddMenuItems( m_pFaxComponent, 
                                                                                    myDataObject, 
                                                                                    piCallback, 
                                                                                    pInsertionAllowed );
    } else {
        // child node
        try {        
            hr = ((CInternalNode *)cookie)->ComponentContextMenuAddMenuItems( m_pFaxComponent, 
                                                                          myDataObject, 
                                                                          piCallback, 
                                                                          pInsertionAllowed );
        } catch ( ... ) {
            DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
            assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentExtendContextMenu::Command(
                                       IN long lCommandID,
                                       IN LPDATAOBJECT piDataObject)
/*++

Routine Description:

    This routine dispatches context menu commands to the correct node by using the
    cookie stored in piDataObject.
    
Arguments:

    lCommandID - the command id
    piDataObject - the data object associated with the target node

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxComponentExtendContextMenu::Command") ));

    CFaxDataObject *    myDataObject = NULL;
    LONG_PTR            cookie;
    HRESULT             hr;

    assert( piDataObject != NULL );
    if( piDataObject == NULL ) {
        return E_POINTER;
    }

    myDataObject = ExtractOwnDataObject( piDataObject );
    if( myDataObject == NULL ) {
        return E_UNEXPECTED;
    }

    cookie = myDataObject->GetCookie();

    if(cookie == NULL) {
        // root node
        assert( m_pFaxComponent != NULL );
        hr = m_pFaxComponent->pOwner->globalRoot->ComponentContextMenuCommand( m_pFaxComponent, 
                                                                               lCommandID, 
                                                                               myDataObject );
    } else {
        // child node
        try {        
            hr = ((CInternalNode *)cookie)->ComponentContextMenuCommand( m_pFaxComponent, 
                                                                     lCommandID, 
                                                                     myDataObject );
        } catch ( ... ) {
            DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
            assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcconmn.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxconmenu.h

Abstract:

    This header prototypes my implementation of IExtendContextMenu.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAX_ICOMPONENT_CONTEXT_MENU_H_
#define __FAX_ICOMPONENT_CONTEXT_MENU_H_

#include "resource.h"

class CFaxComponent; // forward decl

class CFaxComponentExtendContextMenu : public IExtendContextMenu
{
public:

    // constructor

    CFaxComponentExtendContextMenu()
    {
        m_pFaxComponent = NULL;
    }

    // IExtendContextMenu
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
        /* [in] */ LPDATAOBJECT piDataObject,
        /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
        /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
        /* [in] */ long lCommandID,
        /* [in] */ LPDATAOBJECT piDataObject);

protected:
        CFaxComponent *     m_pFaxComponent;
};
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\droutpri.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    droutpri.cpp

Abstract:

    This file contains implementation of 
    the routing extension priority dialog.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#include "stdafx.h"
#include "droutpri.h"
#include "faxcompd.h"
#include "faxcomp.h"
#include "inode.h"
#include "idevice.h"
#include "adminhlp.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CFaxRoutePriPropSheet::CFaxRoutePriPropSheet(
                                            IN HINSTANCE hInstance,
                                            IN LONG_PTR hMmcNotify, 
                                            IN CInternalNode * NodePtr,
                                            IN CFaxComponent * pComp 
                                            )
: _hMmcNotify( hMmcNotify ),
_hFaxServer( 0 ),
_pOwnNode( NodePtr ),
_pRoutingMethod( NULL ),
_iRoutingMethodCount( 0 ),
_pRoutingMethodIndex( NULL ),
_pComp( pComp )
/*++

Routine Description:

    Constructor

Arguments:

    hInstance - the instance pointer
    hMmcNotify - the MMC notify handle
    NodePtr - a pointer to the owning node    

Return Value:

    None.    

--*/
{
    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(icex);    
    icex.dwICC = ICC_DATE_CLASSES;
    InitCommonControlsEx(&icex);    

    DebugPrint(( TEXT("CFaxRoutePriPropSheet Created") ));
    _PropSheet.dwSize    = sizeof( *this );
    _PropSheet.dwFlags   = PSP_USETITLE | PSP_USECALLBACK;
    _PropSheet.hInstance = hInstance;
    _PropSheet.pszTemplate = MAKEINTRESOURCE(IDD_ROUTE_PRI);
    _PropSheet.pszTitle    = MAKEINTRESOURCE(IDD_ROUTE_PRI_TITLE);
    _PropSheet.pfnDlgProc  = CFaxRoutePriPropSheet::DlgProc;
    _PropSheet.lParam = (LONG_PTR)this;
    _PropSheet.pfnCallback = &PropSheetPageProc;

    _hPropSheet = NULL;
    _hPropSheet = CreatePropertySheetPage( &_PropSheet );

    assert(_hPropSheet != NULL );

    assert( NodePtr != NULL );
    
    _pCompData = NodePtr->m_pCompData;
    _hFaxServer = _pCompData->m_FaxHandle;
    
}

CFaxRoutePriPropSheet::~CFaxRoutePriPropSheet()
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.    

--*/
{
    DebugPrint(( TEXT("CFaxRoutePriPropSheet Destroyed") ));
    if( _pRoutingMethodIndex != NULL ) {
        delete _pRoutingMethodIndex;
        _pRoutingMethodIndex = NULL;
        _iRoutingMethodIndexCount = 0;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Dialog Proc
//
//

INT_PTR 
APIENTRY 
CFaxRoutePriPropSheet::DlgProc(
                              IN HWND hwndDlg,
                              IN UINT message,
                              IN WPARAM wParam,
                              IN LPARAM lParam 
                              )
/*++

Routine Description:

    Dialog Procedure

Arguments:

    hwndDlg - the hwnd of the dialog
    message - the message
    wParam, lParam - the window message parameters

Return Value:

    BOOL

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxRoutePriPropSheet::DlgProc") ));

    BOOL        fRet = FALSE;
    HWND        hwnd = NULL;
    HWND        hwndSheet = NULL;    

    switch( message ) {
        case WM_INITDIALOG:
            {
                DebugPrint(( TEXT("CFaxRoutePriPropSheet::DlgProc -- WM_INITDIALOG\n") ));        

                assert( lParam != NULL );
                LONG_PTR lthis = ((CFaxRoutePriPropSheet *)lParam)->_PropSheet.lParam;

                CFaxRoutePriPropSheet * pthis = (CFaxRoutePriPropSheet *)lthis;

                assert( pthis != NULL );

                SetWindowLongPtr( hwndDlg, DWLP_USER, lthis );
                
                if( pthis->_pComp != NULL ) {                
                    pthis->_pComp->IncPropSheetCount();
                } else {
                    pthis->_pCompData->IncPropSheetCount();
                }

                fRet = TRUE;
                break;
            }

        case WM_COMMAND:
            {
//                DebugPrint(( TEXT("CFaxRoutePriPropSheet::DlgProc -- WM_COMMAND\n") ));
                // activate apply button        

                WORD                        wID = LOWORD( wParam );
                WORD                        wCMD = HIWORD( wParam );
                DWORD                       dwSelectedItem;

                CFaxRoutePriPropSheet *     pthis =
                    (CFaxRoutePriPropSheet *)GetWindowLongPtr( hwndDlg,
                                                               DWLP_USER );

                hwnd = GetDlgItem( hwndDlg, IDC_ROUTE_EXTS );        

                switch( wCMD ) {
                    case BN_CLICKED:
                        {
                            switch( wID ) {
                                case IDC_ROUTEPRI_UP:
                                    {
                                        DebugPrint(( TEXT("       ++++++++++++++ CFaxRoutePriPropSheet::DlgProc -- UP button pushed \n") ));
                                        //
                                        // handle click here!!
                                        //
                                        PFAX_GLOBAL_ROUTING_INFO     tempRM;

                                        dwSelectedItem = (DWORD)SendMessage( hwnd, LB_GETCURSEL, 0, 0 );
                                        SetFocus( hwnd );

                                        if( dwSelectedItem != LB_ERR ) {
                                            if( dwSelectedItem < pthis->_iRoutingMethodIndexCount &&
                                                dwSelectedItem > 0 ) {
                                                tempRM = pthis->_pRoutingMethodIndex[ dwSelectedItem - 1 ];
                                                pthis->_pRoutingMethodIndex[ dwSelectedItem - 1 ] = pthis->_pRoutingMethodIndex[ dwSelectedItem ];
                                                pthis->_pRoutingMethodIndex[ dwSelectedItem ] = tempRM;

                                                hwndSheet = GetParent( hwndDlg );
                                                pthis->PopulateListBox( hwndDlg );

                                                SetFocus( hwnd );
                                                SendMessage( hwnd, LB_SETCURSEL, dwSelectedItem - 1 , 0 );

                                                PropSheet_Changed( hwndSheet, hwndDlg );                
                                            }
                                        }

                                        break;
                                    }

                                case IDC_ROUTEPRI_DOWN:        
                                    {                    
                                        DebugPrint(( TEXT("       ++++++++++++++ CFaxRoutePriPropSheet::DlgProc -- DOWN button pushed \n") ));
                                        //
                                        // handle click here!
                                        //
                                        PFAX_GLOBAL_ROUTING_INFO     tempRM;

                                        dwSelectedItem = (DWORD)SendMessage( hwnd, LB_GETCURSEL, 0, 0 );

                                        if( dwSelectedItem != LB_ERR ) {
                                            if( dwSelectedItem < pthis->_iRoutingMethodIndexCount - 1 &&
                                                dwSelectedItem >= 0 ) {
                                                tempRM = pthis->_pRoutingMethodIndex[ dwSelectedItem + 1 ];
                                                pthis->_pRoutingMethodIndex[ dwSelectedItem + 1 ] = pthis->_pRoutingMethodIndex[ dwSelectedItem ];
                                                pthis->_pRoutingMethodIndex[ dwSelectedItem ] = tempRM;

                                                hwndSheet = GetParent( hwndDlg );
                                                pthis->PopulateListBox( hwndDlg );
                                                PropSheet_Changed( hwndSheet, hwndDlg );                

                                                SetFocus( hwnd );
                                                SendMessage( hwnd, LB_SETCURSEL, dwSelectedItem + 1 , 0 );

                                            }
                                        }
                                        break;
                                    }
                                default:
                                    break;
                            } // switch
                            break;
                        }
                }

                fRet = TRUE;
                break;
            }

        case WM_HELP:
                WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle,
                        FAXCFG_HELP_FILENAME,
                        HELP_WM_HELP,
                        (ULONG_PTR) &RoutingPriorityHelpIDs);    
                fRet = TRUE;
                break;

        case WM_CONTEXTMENU:
                WinHelp((HWND) wParam,
                        FAXCFG_HELP_FILENAME,
                        HELP_CONTEXTMENU,
                        (ULONG_PTR) &RoutingPriorityHelpIDs);
                fRet = TRUE;    
                break;

        case WM_NOTIFY:
            {
//        DebugPrint(( TEXT("CFaxRoutePriPropSheet::DlgProc -- WM_NOTIFY\n") ));
                CFaxRoutePriPropSheet * pthis =
                    (CFaxRoutePriPropSheet *)GetWindowLongPtr( hwndDlg,
                                                               DWLP_USER );

                switch( ((LPNMHDR) lParam)->code ) {
                    case PSN_APPLY:
                        // apply changes here!!
                        DebugPrint(( TEXT("       ++++++++++++++ CFaxRoutePriPropSheet::DlgProc -- APPLY button pushed \n") ));
                        if( FAILED( pthis->UpdateData( hwndDlg ) ) ) {
                            fRet = FALSE;
                            break;
                        }

                        // deactivate apply button

                        hwndSheet = GetParent( hwndDlg );
                        PropSheet_UnChanged( hwndSheet, hwndDlg );

                        fRet = TRUE;

                        break;

                    case PSN_SETACTIVE:
                        // refresh the page in case the user enabled some routing methods                
                        DebugPrint(( TEXT("       ++++++++++++++ CFaxRoutePriPropSheet::DlgProc -- PAGE ACTIVATED \n") ));
                        if( FAILED( pthis->GetData() ) ) {
                            fRet = FALSE;
                            break;
                        }
                        pthis->PopulateListBox( hwndDlg ); 

                        fRet = TRUE;
                        break;
                } // switch

                break;
            }

        case WM_DESTROY:
            {                
                DebugPrint(( TEXT("CFaxRoutePriPropSheet::DlgProc -- WM_DESTROY\n") ));
                CFaxRoutePriPropSheet * pthis =
                    (CFaxRoutePriPropSheet *)GetWindowLongPtr( hwndDlg,
                                                               DWLP_USER );

                if( pthis != NULL ) {
                    // MMCFreeNotifyHandle( pthis->_hMmcNotify );
                    // BUGBUG MMCFreeNotifyHandle is called from the general property page.               
                    // It can only be called ONCE!!!
                    if( pthis->_pComp != NULL ) {                    
                        pthis->_pComp->DecPropSheetCount();
                    } else {
                        pthis->_pCompData->DecPropSheetCount();
                    }
                }

                fRet = TRUE;
                break;
            }
    } // switch

    return fRet;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Internal Functions.
//
//

HRESULT 
CFaxRoutePriPropSheet::UpdateData(
                                 HWND hwndDlg 
                                 )
/*++

Routine Description:

    This routine writes the data manipulated in the property page out to the
    fax service.

    The settings are updated in the property sheet because this
    allows the property sheet to complete even if the owner node 
    has already been destroyed.

Arguments:

    hwndDlg - the dialog's window handle

Return Value:

    HRESULT indicating SUCCEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::UpdateData") ));

    HRESULT                     hr = S_OK;

    assert( hwndDlg != NULL );

    try {
        do {
            if( _pCompData->QueryRpcError() == TRUE ) {
                assert( FALSE );
                hr = E_UNEXPECTED;
                break;
            }

            for( DWORD i = 0; i < _iRoutingMethodIndexCount; i++ ) {                
                _pRoutingMethodIndex[ i ]->Priority = i + 1;
                if( !FaxSetGlobalRoutingInfo( _hFaxServer, 
                                              _pRoutingMethodIndex[ i ] )
                  ) {

                    if (GetLastError() != ERROR_ACCESS_DENIED) {
                        _pCompData->NotifyRpcError( TRUE );
                        assert(FALSE);
                    }
                    
                    ::GlobalStringTable->SystemErrorMsg( GetLastError() );

                    hr = E_UNEXPECTED;
                    break;
                }

            }
        } while( 0 );
    } catch( ... ) {
        _pCompData->NotifyRpcError( TRUE );
        assert(FALSE);
        ::GlobalStringTable->SystemErrorMsg( GetLastError() );
        hr = E_UNEXPECTED;       
    }

    return hr;
}

HRESULT 
CFaxRoutePriPropSheet::PopulateListBox(
                                      HWND hwndDlg 
                                      ) 
/*++

Routine Description:

    Populates the List Box containg the routing extensions.

Arguments:

    hwndDlg - the dialog's window handle

Return Value:

    HRESULT indicating SUCCEDED() or FAILED()

--*/
{
    HRESULT         hr = S_OK;
    HWND            hwnd;
    TCHAR           buffer[80];    

    ZeroMemory( (PVOID)buffer, sizeof( TCHAR ) * 80 );

    // populate the list box
    do {
        hwnd = GetDlgItem( hwndDlg, IDC_ROUTE_EXTS );

        // clear the list box
        SendMessage( hwnd, LB_RESETCONTENT, 0, 0 );

        // verify the index has been created
        if( _pRoutingMethodIndex == NULL ) {
            assert( FALSE );
            hr = E_UNEXPECTED;
            break;
        }

        // insert the string into the list box
        for( DWORD i = 0; i < _iRoutingMethodIndexCount; i ++ ) {
            if( _pRoutingMethodIndex[i] != NULL ) {
                SendMessage( hwnd, LB_ADDSTRING, 0, (LPARAM) (LPCTSTR) _pRoutingMethodIndex[i]->FriendlyName );
            }
        }
    } while( 0 );

    return hr;
}

HRESULT
CFaxRoutePriPropSheet::GetData() 
/*++

Routine Description:

    Gets data from the fax service.

Arguments:

    None.

Return Value:

    HRESULT indicating SUCCEDED() or FAILED()

--*/
{
    HRESULT     hr = S_OK;

    try {
        do {
            if( _pRoutingMethod != NULL ) {
                FaxFreeBuffer( (PVOID)_pRoutingMethod );
                _pRoutingMethod = NULL;
                _iRoutingMethodCount = 0;            
            }

            if( _pRoutingMethodIndex != NULL ) {
                delete _pRoutingMethodIndex;
                _pRoutingMethodIndex = NULL;
                _iRoutingMethodIndexCount = 0;
            }

            if( _pCompData->QueryRpcError() == TRUE ) {
                assert( FALSE );
                hr = E_UNEXPECTED;
                break;
            }

            // get the routing methods
            if( !FaxEnumGlobalRoutingInfo( _hFaxServer, &_pRoutingMethod, &_iRoutingMethodCount ) ) {
                if (GetLastError() != ERROR_ACCESS_DENIED) {
                    _pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                }
                ::GlobalStringTable->SystemErrorMsg( GetLastError() );
                hr = E_UNEXPECTED;
                break;
            }

            // build the index
            _iRoutingMethodIndexCount = _iRoutingMethodCount;
            _pRoutingMethodIndex = new PFAX_GLOBAL_ROUTING_INFO[ _iRoutingMethodCount ];
            if (!_pRoutingMethodIndex) {
                hr = E_OUTOFMEMORY;
                break;
            }
            ZeroMemory( (PVOID) _pRoutingMethodIndex,
                        sizeof( PFAX_GLOBAL_ROUTING_INFO ) * _iRoutingMethodCount );                
            // setup the index
            for( DWORD i = 0; i < _iRoutingMethodCount; i ++ ) {
                _pRoutingMethodIndex[i] = &(_pRoutingMethod[i]);
            }
        } while( 0 );

    } catch( ... ) {
        _pCompData->NotifyRpcError( TRUE );
        assert(FALSE);
        ::GlobalStringTable->SystemErrorMsg( GetLastError() );
        hr = E_UNEXPECTED;       
    }

    return hr;
}

UINT 
CALLBACK 
CFaxRoutePriPropSheet::PropSheetPageProc(
                                        HWND hwnd,      
                                        UINT uMsg,      
                                        LPPROPSHEETPAGE ppsp        
                                        )
/*++

Routine Description:

    Dialog Init and destroy routine

Arguments:

    hwndDlg - the hwnd of the dialog - will be NULL
    uMsg - the message PSPCB_CREATE or PSPCB_RELEASE 
    ppsp - pointer to a PROPERTYSHEETPAGE struct

Return Value:

    UINT - nonzero to allow, zero to fail

--*/
{
    CFaxRoutePriPropSheet * pthis = NULL;
    UINT retval = 1;

    // release my property sheet
    if( uMsg == PSPCB_RELEASE ) {
        try {
            pthis = (CFaxRoutePriPropSheet * )(ppsp->lParam);
            delete pthis;
        } catch( ... ) {
            assert( FALSE );
            retval = 0;
        }
    }
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcomp.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcomponent.h

Abstract:

    This file contains my implementation of IComponent.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// faxcomponent.cpp : Implementation of CFaxComponent
#include "stdafx.h"
#include "faxadmin.h"
#include "faxhelper.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"

#include "inode.h"
#include "iroot.h"
#include "ilogging.h"
#include "ilogcat.h"
#include "idevices.h"
#include "idevice.h"

#include "adminhlp.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and Destructor
//
//

CFaxComponent::CFaxComponent() 
/*++

Routine Description:

    Constructor
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    m_pUnknown = NULL;
    m_pConsole = NULL;
    m_pConsoleNameSpace = NULL;
    m_pConsoleVerb = NULL;
    m_pHeaderCtrl = NULL;
    m_pImageList = NULL;
    m_pResultData = NULL;
    m_pControlbar = NULL;

    m_dwPropSheetCount = 0;

    CFaxComponentExtendContextMenu::m_pFaxComponent = this;  
    CFaxComponentExtendPropertySheet::m_pFaxComponent = this;  
    CFaxComponentExtendControlbar::m_pFaxComponent = this;  

    // initialize CInternalDevices instance data
    pDeviceArray = NULL;
    numDevices = 0;

    // initialize CInternalLogging instance data
    pLogPArray = NULL;
    pCategories = NULL;
    numCategories = 0;

    DebugPrint(( TEXT("FaxComponent Created") ));
}

CFaxComponent::~CFaxComponent()
/*++

Routine Description:

    Destructor.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    DebugPrint(( TEXT("FaxComponent Destroyed") ));

    DWORD count; 

    // release CInternalDevices instance data
    if(pDeviceArray != NULL ) {
        for(  count = 0; count < numDevices; count ++ ) {
            if( pDeviceArray[count] != NULL ) {            
                delete pDeviceArray[count];
                pDeviceArray[count] = NULL;
            }
        }
        delete pDeviceArray;
        pDeviceArray = NULL;
    }

    // release CInternalLogging instance data
    if( pLogPArray != NULL ) {
        for( count = 0; count < numCategories; count++ ) {
            if( pLogPArray[count] != NULL ) {
                delete pLogPArray[count];
                pLogPArray[count] = NULL;
            }
        }
        delete pLogPArray;
        pLogPArray = NULL;
    }
    if( pCategories != NULL ) {
        FaxFreeBuffer( (PVOID) pCategories );
        pCategories = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxComponent implementation
//
//

HRESULT 
STDMETHODCALLTYPE 
CFaxComponent::Initialize(
                         IN LPCONSOLE lpUnknown)
/*++

Routine Description:

    This routine initializes IComponent by querying
    for needed interfaces.
    
Arguments:

    lpUnknown - the console's IUnknown/IConsole interface.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    assert( lpUnknown != NULL );

    HRESULT     hr;

    do {
        m_pUnknown = lpUnknown;
        // increment reference on the console
        m_pUnknown->AddRef();

        hr = m_pUnknown->QueryInterface( IID_IConsole, (void **)&m_pConsole );
        assert( SUCCEEDED( hr ));
        if( FAILED( hr ) ) {
            break;        
        }

        hr = m_pConsole->QueryResultImageList( &m_pImageList );
        assert( SUCCEEDED( hr ));        
        if( FAILED( hr ) ) {
            break;        
        }


        hr = m_pUnknown->QueryInterface( IID_IResultData, (void **)&m_pResultData );
        assert( SUCCEEDED( hr ));
        if( FAILED( hr ) ) {
            break;        
        }

        hr = m_pUnknown->QueryInterface( IID_IConsoleNameSpace, (void **)&m_pConsoleNameSpace );
        assert( SUCCEEDED( hr ));
        if( FAILED( hr ) ) {
            break;        
        }

        hr = m_pConsole->QueryConsoleVerb( &m_pConsoleVerb );
        assert( SUCCEEDED( hr ));
        if( FAILED( hr ) ) {
            break;        
        }

        hr = m_pUnknown->QueryInterface( IID_IHeaderCtrl, (void **)&m_pHeaderCtrl );
        assert( SUCCEEDED( hr ));
        if( FAILED( hr ) ) {
            break;        
        }

        // set the header object
        hr = m_pConsole->SetHeader( m_pHeaderCtrl );
        assert( SUCCEEDED( hr ));
        if( FAILED( hr ) ) {
            break;        
        }

    } while( 0 );

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponent::Notify(
                     IN LPDATAOBJECT lpDataObject,
                     IN MMC_NOTIFY_TYPE event,
                     IN LPARAM arg,
                     IN LPARAM param) 
/*++

Routine Description:

    This routine dispatches events sent to the IComponent
    interface using the cookie extracted from the DataObject.
    
    The cookie stored is a pointer to the class that implements behavior for
    that subfolder. So we delegate all the messages by taking the cookie
    casting it to a pointer to a folder, and invoking the notify method.
    
Arguments:

    lpDataobject - the data object
    event - the event type
    arg, param - event arguments

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    HRESULT             hr = S_OK;
    CFaxDataObject *    dataObject = NULL;
    LONG_PTR            cookie;

//    DebugPrint(( TEXT("Trace: CFaxComponent::Notify") ));

    if( event == MMCN_CONTEXTHELP ) {
        MMCPropertyHelp(FAXMMC_HTMLHELP_TOPIC);
    }
    else if( lpDataObject != NULL) {
        dataObject = ExtractOwnDataObject( lpDataObject );
        if( dataObject == NULL ) {
            return E_UNEXPECTED;
        }

        cookie = dataObject->GetCookie();

        if( cookie == NULL) {
            // my static node
            assert( pOwner );
            hr = pOwner->globalRoot->ResultNotify( this, dataObject, event, arg, param );
        } else {
            // cast the cookie to a pointer
            try {            
                hr = ((CInternalNode *)cookie)->ResultNotify( this, dataObject, event, arg, param );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    } else {
        // some events do not pass a lpDataObject into Notify.
        // we need to handle those events here, if you want
        // to handle them at all!!
        if( event == MMCN_PROPERTY_CHANGE ) {
            if( param != NULL ) {
                try {                
                    hr = ((CInternalNode *)param)->ResultNotify( this, NULL, event, arg, param );
                } catch ( ... ) {
                    DebugPrint(( TEXT("Invalid Cookie") ));
                    assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                    hr = E_UNEXPECTED;
                }
            }
        }
    }

    return hr;    
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponent::Destroy(
                      IN MMC_COOKIE cookie) 
/*++

Routine Description:

    This method releases all the aquired console interface in preperation
    for the IComponent being destroyed.
    
Arguments:

    None.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxComponent::Notify") ));

    // the prop sheet count should never be negative
    assert( QueryPropSheetCount() >= 0 );

    // check to see if any property sheets are up
    while( QueryPropSheetCount() > 0 ) {
        DebugPrint(( TEXT("Trace: QueryPropSheetCount() %d "), QueryPropSheetCount() ));
        // don't allow deletion        
        GlobalStringTable->PopUpMsg( NULL, IDS_PROP_SHEET_STILL_UP, TRUE, NULL );
    }

    // release the header object
    HRESULT hr = m_pConsole->SetHeader( NULL );
    assert( SUCCEEDED( hr ));

    if( m_pUnknown != NULL ) {
        m_pUnknown->Release();
        m_pUnknown = NULL;
    }

    if( m_pConsole != NULL ) {
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if( m_pConsoleNameSpace != NULL ) {
        m_pConsoleNameSpace->Release();
        m_pConsoleNameSpace = NULL;
    }

    if( m_pConsoleVerb != NULL ) {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if( m_pHeaderCtrl != NULL ) {
        m_pHeaderCtrl->Release();
        m_pHeaderCtrl = NULL;
    }

    if( m_pImageList != NULL ) {
        m_pImageList->Release();
        m_pImageList = NULL;
    }

    if( m_pResultData != NULL ) {
        m_pResultData->Release();
        m_pResultData = NULL;
    }

    if( m_pControlbar != NULL ) {
        m_pControlbar->Release();
        m_pControlbar = NULL;
    }

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponent::QueryDataObject(
                              IN MMC_COOKIE cookie,
                              IN DATA_OBJECT_TYPES type,
                              OUT LPDATAOBJECT __RPC_FAR *ppDataObject) 
/*++

Routine Description:

    This method dispatches DataObjects requests to the appropriate 
    nodes using the cookie.
    
Arguments:

    cookie - the cookie for the associated node
    type - the type of the cookie
    ppDataobject - a pointer to the new data object is stored here
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxComponent::QueryDataObject") ));

    HRESULT hr = S_OK;

    if( ppDataObject != NULL ) {
        if( cookie == NULL ) {
            assert( pOwner );
            hr = pOwner->globalRoot->ResultQueryDataObject( this, cookie, type, ppDataObject );
        } else {
            try {            
                hr = ((CInternalNode *)cookie)->ResultQueryDataObject( this, cookie, type, ppDataObject );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    } else {
        // bad pointer
        assert( FALSE );
        hr = E_POINTER;
    }

    return hr;

}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponent::GetResultViewType(
                                IN MMC_COOKIE cookie,
                                OUT LPOLESTR __RPC_FAR *ppViewType,
                                OUT long __RPC_FAR *pViewOptions) 
/*++

Routine Description:

    This method dispatches GetResultViewType requests to the appropriate 
    nodes using the cookie.
    
Arguments:

    cookie - the cookie for the associated node
    ppViewType - the viewtype
    ppViewOptions - view options
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    HRESULT hr = S_OK;

    assert ( ppViewType != NULL );
    if( ppViewType == NULL ) {
        return E_POINTER;
    }
    assert ( pViewOptions != NULL );
    if( pViewOptions == NULL ) {
        return E_POINTER;
    }

    if( cookie == NULL ) {
        assert( pOwner );
        hr = pOwner->globalRoot->ResultGetResultViewType( this, cookie, ppViewType, pViewOptions );
    } else {
        try {        
            hr = ((CInternalNode *)cookie)->ResultGetResultViewType( this, cookie, ppViewType, pViewOptions );
        } catch ( ... ) {
            DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
            assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponent::GetDisplayInfo(
                             IN OUT RESULTDATAITEM __RPC_FAR *pResultDataItem) 
/*++

Routine Description:

    This method dispatches DisplayInfo requests to the appropriate 
    nodes using the cookie in pResultDataItem.
    
Arguments:

    pResultDataItem - struct containing information about the scope item.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{

//    DebugPrint(( TEXT("Trace: CFaxComponent::GetDisplayInfo") ));

    LONG_PTR cookie;
    HRESULT hr = S_OK;

    assert( pResultDataItem != NULL );

    if( pResultDataItem == NULL ) {
        // oops bad pointer
        return E_POINTER;
    }

    cookie = pResultDataItem->lParam;    

    if( cookie == NULL ) {
        // our top node
        assert( pOwner );
        hr = pOwner->globalRoot->ResultGetDisplayInfo(this, pResultDataItem);
    } else {
        // another node
        try {      
            hr = ((CInternalNode *)cookie)->ResultGetDisplayInfo(this, pResultDataItem);
        } catch ( ... ) {
            DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
            //assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponent::CompareObjects(
                             IN LPDATAOBJECT lpDataObjectA,
                             IN LPDATAOBJECT lpDataObjectB) 
/*++

Routine Description:

    This method compares two data object to see if they correspond to 
    the same object by comparing the cookies.
    
Arguments:

    lpDataObjectA - object A
    lpDataObjectB - object B

Return Value:

    HRESULT indicating S_OK or S_FALSE. E_UNEXPECTED for an error.

--*/
{
    CFaxDataObject * aOBJ = ExtractOwnDataObject( lpDataObjectA );
    CFaxDataObject * bOBJ = ExtractOwnDataObject( lpDataObjectB );

    if( aOBJ == NULL || bOBJ == NULL ) {
        return E_UNEXPECTED;
    }

    if( aOBJ->GetCookie() == bOBJ->GetCookie() ) {
        return S_OK;
    } else {
        return S_FALSE;
    }    
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Internal Methods
//
//

void 
CFaxComponent::SetOwner(
                       CFaxComponentData * myOwner )
/*++

Routine Description:

    Sets the Component's owner - needed for internal stuff
    
Arguments:

    myOwner - the owner of the IComponent instance.

Return Value:

    None.

--*/
{
    assert( myOwner != NULL );
    pOwner = myOwner;
}

HRESULT 
CFaxComponent::InsertIconsIntoImageList()
/*++

Routine Description:

    oads the component's result pane icons into an image list
    
Arguments:

    None.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    HRESULT     hr = E_UNEXPECTED;

    assert( pOwner != NULL );
    assert( m_pImageList != NULL );

    if( m_pImageList != NULL ) {
        if( pOwner != NULL ) {
            hr = pOwner->InsertIconsIntoImageList( m_pImageList );
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcomp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcomponent.h

Abstract:

    This header prototypes my implementation of IComponent.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAXCOMPONENT_H_
#define __FAXCOMPONENT_H_

#include "resource.h"
#include "faxadmin.h"

#include "faxcconmn.h"  // IExtendContextMenu dispatcher for IComponent
#include "faxcprppg.h"  // IExtendPropertyPage dispatcher for IComponent
#include "faxcconbar.h" // IExtendControlbar dispatcher for IComponent

class CFaxComponentData; // forward declarator
class CInternalDevice;
class CInternalLogCat;

/////////////////////////////////////////////////////////////////////////////
// CFaxComponent
class CFaxComponent :   public CComObjectRoot,
                        public IComponent,
                        public CFaxComponentExtendContextMenu,
                        public CFaxComponentExtendPropertySheet,
                        public CFaxComponentExtendControlbar
{
public:

    // ATL Map

    DECLARE_NOT_AGGREGATABLE(CFaxComponent)

    BEGIN_COM_MAP(CFaxComponent)
        COM_INTERFACE_ENTRY(IComponent)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IExtendControlbar)
    END_COM_MAP()

    // constructor and destructor
    CFaxComponent();

    ~CFaxComponent();

    // IComponent
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
                                                                   /* [in] */ LPCONSOLE lpUnknown );

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(
                                                               /* [in] */ LPDATAOBJECT lpDataObject,
                                                               /* [in] */ MMC_NOTIFY_TYPE event,
                                                               /* [in] */ LPARAM arg,
                                                               /* [in] */ LPARAM param);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy(
                                                                /* [in] */ MMC_COOKIE cookie);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject(
                                                                        /* [in] */ MMC_COOKIE cookie,
                                                                        /* [in] */ DATA_OBJECT_TYPES type,
                                                                        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType(
                                                                          /* [in] */ MMC_COOKIE cookie,
                                                                          /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                                                          /* [out] */ long __RPC_FAR *pViewOptions);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(
                                                                       /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects(
                                                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                                                       /* [in] */ LPDATAOBJECT lpDataObjectB);

    // other methods
    void SetOwner( CFaxComponentData * myOwner );
    CFaxComponentData * GetOwner( void ) { return pOwner; }    
    HRESULT InsertIconsIntoImageList();

    LONG    QueryPropSheetCount() { return m_dwPropSheetCount; }
    void    IncPropSheetCount() {   InterlockedIncrement( &m_dwPropSheetCount );
                                    DebugPrint(( TEXT("IncPropSheet Count %d "), m_dwPropSheetCount )); }
    void    DecPropSheetCount() {   InterlockedDecrement( &m_dwPropSheetCount );
                                    DebugPrint(( TEXT("DecPropSheet Count %d "), m_dwPropSheetCount )); }

public:

    LPCONSOLE               m_pUnknown;                 // IUnknown -- should be LPUNKNOWN but docs are wrong?
    LPCONSOLE               m_pConsole;                 // IConsole
    LPCONSOLENAMESPACE      m_pConsoleNameSpace;        // IConsoleNameSpace
    LPCONSOLEVERB           m_pConsoleVerb;             // IConsoleVerb
    LPHEADERCTRL            m_pHeaderCtrl;              // IHeaderCtrl
    LPIMAGELIST             m_pImageList;               // IImageList
    LPRESULTDATA            m_pResultData;              // IResultData
    LPCONTROLBAR            m_pControlbar;              // IControlbar

    CFaxComponentData *     pOwner;                     // my owner

    // IComponent instance data for CInternalDevices
    CInternalDevice **      pDeviceArray;
    DWORD                   numDevices;

    // IComponent instance data for CInternalLogging
    PFAX_LOG_CATEGORY       pCategories;
    DWORD                   numCategories;
    CInternalLogCat **      pLogPArray;

private:
    LONG                    m_dwPropSheetCount;         // property sheet count

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxconbar.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxconbar.h

Abstract:

    This header prototypes my implementation of IExtendControlbar for IComponentData.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAX_ICOMPONENTDATA_CONTROLBAR_H_
#define __FAX_ICOMPONENTDATA_CONTROLBAR_H_

#include "resource.h"

class CFaxComponentData; // forward decl

class CFaxExtendControlbar : public IExtendControlbar
{
public:

    // constructor

    CFaxExtendControlbar()
    {
        m_pFaxSnapin = NULL;
    }

    // IExtendControlbar
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
        /* [in] */ LPCONTROLBAR pControlbar);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LONG_PTR arg,
        /* [in] */ LONG_PTR param);

protected:
        CFaxSnapin *     m_pFaxSnapin;
};
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcompd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcompd.h

Abstract:

    This header prototypes my implementation of IComponentData.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAXCOMPDATA_H_
#define __FAXCOMPDATA_H_

#include "resource.h"

class CInternalRoot; // forward declaration
                     
/////////////////////////////////////////////////////////////////////////////
// CFaxComponentData

class CFaxComponentData : public IComponentData
{
public:
    
    // constructor and destructor
    CFaxComponentData();
    ~CFaxComponentData();    

    // IComponentData
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
                                                                   /* [in] */ LPUNKNOWN pUnknown);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent(
                                                                            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(
                                                               /* [in] */ LPDATAOBJECT lpDataObject,
                                                               /* [in] */ MMC_NOTIFY_TYPE event,
                                                               /* [in] */ LPARAM arg,
                                                               /* [in] */ LPARAM param);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void );

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject(
                                                                        /* [in] */ MMC_COOKIE cookie,
                                                                        /* [in] */ DATA_OBJECT_TYPES type,
                                                                        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(
                                                                       /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects(
                                                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                                                       /* [in] */ LPDATAOBJECT lpDataObjectB);    

    // non inteface members    
    HRESULT InsertIconsIntoImageList( LPIMAGELIST pImageList );
    HRESULT InsertSingleIconIntoImageList( WORD resID, long assignedIndex, LPIMAGELIST pImageList );
    BOOL    QueryRpcError();
    void    NotifyRpcError( BOOL bRpcErrorHasHappened );
    LONG    QueryPropSheetCount() { return m_dwPropSheetCount; }
    void    IncPropSheetCount() {   InterlockedIncrement( &m_dwPropSheetCount );
                                    DebugPrint(( TEXT("IncPropSheet Count %d "), m_dwPropSheetCount )); }
    void    DecPropSheetCount() {   InterlockedDecrement( &m_dwPropSheetCount );
                                    DebugPrint(( TEXT("DecPropSheet Count %d "), m_dwPropSheetCount )); }

public:

    LPUNKNOWN                   m_pUnknown;                     // IUnknown
    LPCONSOLE                   m_pConsole;                     // IConsole
    LPCONSOLENAMESPACE          m_pConsoleNameSpace;            // IConsoleNameSpace
    LPIMAGELIST                 m_pImageList;                   // IImageList
    LPCONTROLBAR                m_pControlbar;                  // IControlbar

    HANDLE                      m_FaxHandle;                    // connection handle to the fax server.    
    CInternalRoot *             globalRoot;                     // pointer to the global root

private:
    CRITICAL_SECTION            GlobalCriticalSection;          
    BOOL                        m_bRpcErrorHasHappened;         // rpc error flag
    LONG                        m_dwPropSheetCount;             // property sheet count
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxconbar.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxconbar.cpp

Abstract:

    This file contains my implementation of IExtendControlbar for IComponentData.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// faxconbar.cpp : Implementation of CFaxExtendControlbar 

#include "stdafx.h"
#include "faxcconbar.h"
#include "faxadmin.h"
#include "faxsnapin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "iroot.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxExtendControlbar - IExtendControlbar implementation for IComponentData
//
//

HRESULT 
STDMETHODCALLTYPE 
CFaxExtendControlbar::SetControlbar(
                                       IN LPCONTROLBAR pControlbar)
/*++

Routine Description:

    Stores the LPCONTROLBAR sent to the snapin.
    
Arguments:

    pControlbar - the LPCONTROLBAR to be set.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxExtendControlbar::SetControlbar") ));

    assert( pControlbar != NULL );
    if( pControlbar == NULL ) {
        return E_POINTER;
    }

    assert(m_pFaxSnapin != NULL );
    if( m_pFaxSnapin == NULL ) {
        return E_UNEXPECTED;
    }

    m_pFaxSnapin->m_pControlbar = pControlbar;
    m_pFaxSnapin->m_pControlbar->AddRef();
    
    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxExtendControlbar::ControlbarNotify(
                                          IN MMC_NOTIFY_TYPE event,
                                          IN LPARAM arg,
                                          IN LPARAM param)
/*++

Routine Description:

    Dispatch the ControbarNotify call to the correct node by extracting the
    cookie from the DataObject.
    
Arguments:

    event - the event type.
    arg, param - the arguments of the event.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxExtendControlbar::ControlbarNotify") ));

    CFaxDataObject *    myDataObject = NULL;
    LONG_PTR            cookie = NULL;
    HRESULT             hr;

    if( event == MMCN_BTN_CLICK ) {

        ATLTRACE(_T("CFaxExtendControlbar::ControlbarNotify: MMCN_BTN_CLICK\n"));

        assert( arg != NULL );
        if( arg == NULL ) {
            return E_POINTER;
        }

        myDataObject = ::ExtractOwnDataObject( (LPDATAOBJECT)arg );
        assert( myDataObject != NULL );
        if( myDataObject == NULL ) {
            return E_UNEXPECTED;
        }

        cookie = myDataObject->GetCookie();
        if( cookie == NULL ) {        
            // root
            hr = m_pFaxSnapin->globalRoot->ControlBarOnBtnClick2( m_pFaxSnapin, myDataObject, param );
        } else {
            // child
            try {            
                hr = ((CInternalNode *)cookie)->ControlBarOnBtnClick2( m_pFaxSnapin, myDataObject, param );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }


    } else if( event == MMCN_SELECT ) {

        ATLTRACE(_T("CFaxExtendControlbar::ControlbarNotify: MMCN_SELECT\n"));

        assert( param != NULL );
        if( param == NULL ) {
            return E_POINTER;
        }        

        myDataObject = ::ExtractOwnDataObject( (LPDATAOBJECT)param );
        assert( myDataObject != NULL );
        if( myDataObject == NULL ) {
            return E_UNEXPECTED;
        }

        cookie = myDataObject->GetCookie();
        if( cookie == NULL ) {        
            // root
            hr = m_pFaxSnapin->globalRoot->ControlBarOnSelect2( m_pFaxSnapin, arg, myDataObject );
        } else {
            // child
            try {            
                hr = ((CInternalNode *)cookie)->ControlBarOnSelect2( m_pFaxSnapin, arg, myDataObject );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcompd.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxcompd.cpp

Abstract:

    This file contains my implementation of IComponentData.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// faxcompdata.cpp : Implementation of CFaxComponentData
#include "stdafx.h"
#include "faxadmin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "iroot.h"
#include "idevice.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CFaxComponentData::CFaxComponentData()
/*++

Routine Description:

    Constructor.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    m_pUnknown = NULL;                      // IUnknown
    m_pConsoleNameSpace = NULL;             // IConsoleNameSpace
    m_pConsole = NULL;                      // IConsole
    m_pImageList = NULL;                    // IImageList
    m_pControlbar = NULL;                   // IControlbar

    m_FaxHandle =  NULL;                    // Fax connection handle;
    m_bRpcErrorHasHappened = TRUE;          // Fax server is down until we connect.

    m_dwPropSheetCount = 0;

    DebugPrint(( TEXT( "FaxComponentData Created" ) ));

    globalRoot = new CInternalRoot( NULL, this );
    assert( globalRoot != NULL );

    // Initialize the critical section.
    InitializeCriticalSection( &GlobalCriticalSection ); 
    InitializeCriticalSection( &CInternalDevice::csDeviceLock );
}

CFaxComponentData::~CFaxComponentData()
/*++

Routine Description:

    Destructor.
    
Arguments:

    None.

Return Value:

    None.

--*/
{         
    assert( globalRoot != NULL );
    if( globalRoot != NULL ) {
        delete globalRoot;
    }
    DebugPrint(( TEXT( "FaxComponentData Destroyed" ) ));    
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxComponentData implementation
//
//

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentData::Initialize(
                             IN LPUNKNOWN pUnknown) 
/*++

Routine Description:

    This routine initializes IComponentData by querying
    for needed interfaces.
    
Arguments:

    pUnknown - the console's IUnknown interface.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    HRESULT hr;   

    DebugPrint(( TEXT("Trace: CFaxComponentData::Initialize") ));

    do {
        assert(globalRoot != NULL );
        if(globalRoot == NULL ) {
            hr = E_UNEXPECTED;
            break;
        }

        assert(pUnknown != NULL);
        if( pUnknown == NULL ) {
            hr = E_POINTER;
            break;
        }

        // MMC should only call ::Initialize once!
        assert(m_pUnknown == NULL);
        if( m_pUnknown != NULL ) {
            hr = E_UNEXPECTED;
            break;
        }

        m_pUnknown = pUnknown;
        m_pUnknown->AddRef();

        // retrieve and store away all the interface pointers I might want

        //
        // Get pointer to IConsole
        //
        hr = pUnknown->QueryInterface(IID_IConsole, (VOID**)(&m_pConsole));
        assert( SUCCEEDED(hr) );    
        if( FAILED( hr ) ) {
            break;
        }

        //
        // Get pointer to IConsoleNameSpace
        //
        hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (VOID**)(&m_pConsoleNameSpace));
        assert( SUCCEEDED(hr) );    
        if( FAILED( hr ) ) {
            break;
        }

        //
        // Get pointer to IImageList for scope pane
        //
        //hr = pUnknown->QueryInterface(IID_IImageList, (VOID**)(&m_pImageList));

        hr = m_pConsole->QueryScopeImageList( &m_pImageList );
        assert( SUCCEEDED(hr) );    
        if( FAILED( hr ) ) {
            break;
        }

        // setup my images in the imagelist
        hr = InsertIconsIntoImageList( m_pImageList );
        assert( SUCCEEDED(hr) );
        if( FAILED( hr ) ) {
            break;
        }

    } while( 0 );

    // damage control
    if( FAILED( hr ) ) {
        if( m_pUnknown != NULL ) {
            m_pUnknown->Release();
            m_pUnknown = NULL;
        }

        if( m_pConsole != NULL ) {
            m_pConsole->Release(); 
            m_pConsole = NULL;   
        }

        if( m_pConsoleNameSpace != NULL ) {
            m_pConsoleNameSpace->Release();
            m_pConsoleNameSpace = NULL;
        }

        if( m_pImageList != NULL ) {
            m_pImageList->Release();
            m_pImageList = NULL;
        }
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentData::CreateComponent(
                                  OUT LPCOMPONENT __RPC_FAR *ppComponent) 
/*++

Routine Description:

    This routine creates and returns an IComponent interface.
    
Arguments:

    ppComponent - the new IComponent is returned here.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    HRESULT             hr = S_OK;
    CFaxComponent *     temp = NULL;

    DebugPrint(( TEXT("Trace: CFaxComponentData::CreateComponent") ));

    //
    // MMC asks us for a pointer to the IComponent interface
    //                          

    if( ppComponent != NULL ) {
        temp = new CComObject<CFaxComponent>;
        if( temp == NULL ) {
            return E_OUTOFMEMORY;
        }
        temp->SetOwner( this );

        *ppComponent = temp;

        (*ppComponent)->AddRef();    
    } else {
        hr = E_POINTER;
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentData::Notify(
                         IN LPDATAOBJECT lpDataObject,
                         IN MMC_NOTIFY_TYPE event,
                         IN LPARAM arg,
                         IN LPARAM param) 
/*++

Routine Description:

    This routine dispatches events sent to the IComponentData 
    interface using the cookie extracted from the DataObject.
    
    The cookie stored is a pointer to the class that implements behavior for
    that subfolder. So we delegate all the messages by taking the cookie
    casting it to a pointer to a folder, and invoking the notify method.
    
Arguments:

    lpDataobject - the data object
    event - the event type
    arg, param - event arguments

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    HRESULT             hr = S_OK;
    CFaxDataObject *    dataObject = NULL;
    LONG_PTR            cookie;

//    DebugPrint(( TEXT("Trace: CFaxComponentData::Notify") ));

    if( lpDataObject != NULL) {
        dataObject = ExtractOwnDataObject( lpDataObject );
        if( dataObject == NULL ) {
            return E_UNEXPECTED;
        }

        cookie = dataObject->GetCookie();

        if( cookie == NULL) {
            // my static node
            hr = globalRoot->ScopeNotify( this, dataObject, event, arg, param );
        } else {
            // cast the cookie to a pointer
            try {
                hr = ((CInternalNode *)cookie)->ScopeNotify( this, dataObject, event, arg, param );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    } else {
        // some events do not pass a lpDataObject 
        // if we want to handle these event, we 
        // have to do it here
        if( event == MMCN_PROPERTY_CHANGE ) {
            if( param != NULL ) {
                try {                
                    hr = ((CInternalNode *)param)->ScopeNotify( this, NULL, event, arg, param );
                } catch ( ... ) {
                    DebugPrint(( TEXT("Invalid Cookie") ));
                    assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                    hr = E_UNEXPECTED;
                }
            }
        }
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentData::Destroy(
                          void )
/*++

Routine Description:

    This method releases all the aquired console interface in preperation
    for the snapin being destroyed.
    
Arguments:

    None.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxComponentData::Destroy") ));

    // the prop sheet count should never be negative
    assert( QueryPropSheetCount() >= 0 );

    // check to see if any property sheets are up
    while( QueryPropSheetCount() > 0 ) {
        DebugPrint(( TEXT("Trace: QueryPropSheetCount() %d "), QueryPropSheetCount() ));
        // don't allow deletion        
        GlobalStringTable->PopUpMsg( NULL, IDS_PROP_SHEET_STILL_UP, TRUE, NULL );
    }

    // Free interfaces
    if( m_pUnknown != NULL ) {
        m_pUnknown->Release();
        m_pUnknown = NULL;
    }

    if( m_pConsole != NULL ) {
        m_pConsole->Release(); 
        m_pConsole = NULL;   
    }

    if( m_pConsoleNameSpace != NULL ) {
        m_pConsoleNameSpace->Release();
        m_pConsoleNameSpace = NULL;
    }

    if( m_pImageList != NULL ) {
        m_pImageList->Release();
        m_pImageList = NULL;
    }

    if( m_pControlbar != NULL ) {
        m_pControlbar->Release();
        m_pControlbar = NULL;
    }

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentData::QueryDataObject(
                                  IN MMC_COOKIE cookie,
                                  IN DATA_OBJECT_TYPES type,
                                  OUT LPDATAOBJECT __RPC_FAR *ppDataObject) 
/*++

Routine Description:

    This method dispatches DataObjects requests to the appropriate 
    nodes using the cookie.
    
Arguments:

    cookie - the cookie for the associated node
    type - the type of the cookie
    ppDataobject - a pointer to the new data object is stored here
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxComponentData::QueryDataObject") ));

    HRESULT hr = S_OK;

    if( cookie == NULL ) {
        hr = globalRoot->ScopeQueryDataObject( this, cookie, type, ppDataObject );
    } else {
        try {        
            hr = ((CInternalNode *)cookie)->ScopeQueryDataObject( this, cookie, type, ppDataObject );
        } catch ( ... ) {
            DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
            assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentData::GetDisplayInfo(
                                 IN OUT SCOPEDATAITEM __RPC_FAR *pScopeDataItem)
/*++

Routine Description:

    This method dispatches DisplayInfo requests to the appropriate 
    nodes using the cookie in pScopeDataItem.
    
Arguments:

    pScopeDataItem - struct containing information about the scope item.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxComponentData::GetDisplayInfo") ));

    LONG_PTR    cookie;
    HRESULT     hr = S_OK;

    assert(pScopeDataItem != NULL);
    if( pScopeDataItem == NULL ) {
        return E_POINTER;
    }

    cookie = pScopeDataItem->lParam;

    if( cookie == NULL ) {
        // our top node        
        hr = globalRoot->ScopeGetDisplayInfo( this, pScopeDataItem);
    } else {
        // another node
        try {        
            hr = ((CInternalNode *)cookie)->ScopeGetDisplayInfo( this, pScopeDataItem);
        } catch ( ... ) {
            DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
            assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CompareObjects
//
// Compares two objects.

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentData::CompareObjects(
                                 IN LPDATAOBJECT lpDataObjectA,
                                 IN LPDATAOBJECT lpDataObjectB) 
/*++

Routine Description:

    This method compares two data object to see if they correspond to 
    the same object by comparing the cookies.
    
Arguments:

    lpDataObjectA - object A
    lpDataObjectB - object B

Return Value:

    HRESULT indicating S_OK or S_FALSE. E_UNEXPECTED for an error.

--*/
{
    DebugPrint(( TEXT("Trace: CFaxComponentData::CompareObjects") ));

    CFaxDataObject * aOBJ = ExtractOwnDataObject( lpDataObjectA );
    CFaxDataObject * bOBJ = ExtractOwnDataObject( lpDataObjectB );

    if( aOBJ == NULL || bOBJ == NULL ) {
        return E_UNEXPECTED;
    }

    if( aOBJ->GetCookie() == bOBJ->GetCookie() ) {
        return S_OK;
    } else {
        return S_FALSE;
    }    
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Internal Methods
//
//

HRESULT 
CFaxComponentData::InsertIconsIntoImageList(
                                           IN LPIMAGELIST pImageList )
/*++

Routine Description:

    Takes an image list and inserts the standard set of icons into it
    Add any new node images you want here and also don't forget to assign them
    new ids.
    
Arguments:

    pImageList - the image list into which icons are to be inserted.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{    
    HICON           hIcon = NULL;
    HRESULT         hr = S_OK;
    WORD            resID = IDI_NODEICON;

    do {

        // set generic node icon
        // the defined values are stored in resource.h
        hr = InsertSingleIconIntoImageList( IDI_NODEICON, IDI_NODEICON, pImageList );
        if( FAILED( hr ) ) {
            break;
        }

        // set more icons here
        //
        //

        for( resID = IDI_COVERPG; resID < LAST_ICON; resID++ ) {
            hr = InsertSingleIconIntoImageList( resID, resID, pImageList );
            if( FAILED( hr ) ) {
                break;
            }
        }
        if( FAILED( hr ) ) {
            break;
        }
    } while( 0 );

    return hr;
}

HRESULT 
CFaxComponentData::InsertSingleIconIntoImageList(
                                                IN WORD resID, 
                                                IN long assignedIndex, 
                                                IN LPIMAGELIST pImageList )
/*++

Routine Description:

    Takes an image list and inserts a single icon into it
    using the resource ID and index specified.
    
Arguments:

    resID - the resource ID
    assignedIndex - the index assigned to the icon    
    pImageList - the image list into which icons are to be inserted.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    HICON           hIcon = NULL;
    HRESULT         hr = S_OK;

    do {
        hIcon = LoadIcon( ::GlobalStringTable->GetInstance(), MAKEINTRESOURCE( resID ) );
        assert( hIcon != NULL );
        if( hIcon == NULL ) {
            hr = E_UNEXPECTED;
            break;
        }
        hr = pImageList->ImageListSetIcon( (LONG_PTR *)hIcon, assignedIndex );
        assert( SUCCEEDED( hr ) );
        if( FAILED( hr ) ) {
            break;
        }

    } while( 0 );

    return hr;
}

BOOL 
CFaxComponentData::QueryRpcError()
/*++

Routine Description:

    Queries the state of the RPC connection. 

    The critical section is probably needed because this function can be called from
    the property sheets which run in a different thread.
    
Arguments:

    None.

Return Value:

    BOOL indicating TRUE if the RPC connection has encountered an error.

--*/
{ 
    BOOL    temp;

    EnterCriticalSection(&GlobalCriticalSection); 

    temp = m_bRpcErrorHasHappened; 

    // other stuff might go in here someday

    LeaveCriticalSection(&GlobalCriticalSection);

    return temp;
}

void 
CFaxComponentData::NotifyRpcError(
                                 IN BOOL bRpcErrorHasHappened ) 
/*++

Routine Description:

    Informs all the members of the snapin that the RPC connection is dead and
    the server state is indeterminate
    
    The critical section is probably needed because this function can be called from
    the property sheets which run in a different thread.
    
Arguments:

    BOOL indicating TRUE if the RPC connection has encountered an error.

Return Value:

    None.

--*/
{
    EnterCriticalSection(&GlobalCriticalSection); 

    // handle server down events here
    // other stuff might go in here someday

    m_bRpcErrorHasHappened = bRpcErrorHasHappened;        

    LeaveCriticalSection(&GlobalCriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxconmenu.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxconmenu.h

Abstract:

    This header prototypes my implementation of IExtendContextMenu.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAX_CONTEXT_MENU_H_
#define __FAX_CONTEXT_MENU_H_

#include "resource.h"

class CFaxSnapin; // forward decl

class CFaxExtendContextMenu : public IExtendContextMenu
{
public:

    // constructor

    CFaxExtendContextMenu()
    {
        m_pFaxSnapin = NULL;
    }

    // IExtendContextMenu
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
        /* [in] */ LPDATAOBJECT piDataObject,
        /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
        /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
        /* [in] */ long lCommandID,
        /* [in] */ LPDATAOBJECT piDataObject);

protected:
        CFaxSnapin *     m_pFaxSnapin;
};
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxconmenu.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxconmenu.cpp

Abstract:

    This file contains my implementation of IExtendContextMenu.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// faxconmenu.cpp : Implementation of CFaxExtendContextMenu
#include "stdafx.h"
#include "faxconmenu.h"
#include "faxadmin.h"
#include "faxsnapin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "iroot.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxExtendContextMenu - IExtendContextMenu implementation for IComponentData
//
//

HRESULT 
STDMETHODCALLTYPE 
CFaxExtendContextMenu::AddMenuItems(
                                   IN LPDATAOBJECT piDataObject,
                                   IN LPCONTEXTMENUCALLBACK piCallback,
                                   IN OUT long __RPC_FAR *pInsertionAllowed)
/*++

Routine Description:

    Dispatch the AddMenuItems call to the correct node by extracting the
    cookie from the DataObject.
    
Arguments:

    piDataObject - the data object for the target node.
    piCallback - the CONTEXTMENUCALLBACK pointer
    pInsertionAllowed - flags to indicate whether insertion is allowed.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxExtendContextMenu::AddMenuItems") ));

    CFaxDataObject *    myDataObject = NULL;
    LONG_PTR            cookie;
    HRESULT             hr;

    assert( piDataObject != NULL );
    if( piDataObject == NULL ) {
        return E_POINTER;
    }
    if( piCallback == NULL ) {
        return E_POINTER;
    }
    if( pInsertionAllowed == NULL ) {
        return E_POINTER;
    }

    myDataObject = ExtractOwnDataObject( piDataObject );
    if( myDataObject == NULL ) {
        return E_UNEXPECTED;
    }

    cookie = myDataObject->GetCookie();

    if(cookie == NULL) {
        // root node
        hr = m_pFaxSnapin->globalRoot->ComponentDataContextMenuAddMenuItems( m_pFaxSnapin, 
                                                                             myDataObject, 
                                                                             piCallback, 
                                                                             pInsertionAllowed );
    } else {
        // child node
        try {        
        hr = ((CInternalNode *)cookie)->ComponentDataContextMenuAddMenuItems( m_pFaxSnapin, 
                                                                              myDataObject, 
                                                                              piCallback, 
                                                                              pInsertionAllowed );
        } catch (...) {
            DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
            assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

HRESULT
STDMETHODCALLTYPE 
CFaxExtendContextMenu::Command(
                              IN long lCommandID,
                              IN LPDATAOBJECT piDataObject)
/*++

Routine Description:

    Dispatch the context menu Command call to the correct node by extracting the
    cookie from the DataObject.
    
Arguments:

    lCommandID - the command id
    piDataObject - the DataObject for the target node.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxExtendContextMenu::Command") ));

    CFaxDataObject *    myDataObject = NULL;
    LONG_PTR            cookie;
    HRESULT             hr;

    assert( piDataObject != NULL );
    if( piDataObject == NULL ) {
        return E_POINTER;
    }

    myDataObject = ExtractOwnDataObject( piDataObject );
    if( myDataObject == NULL ) {
        return E_UNEXPECTED;
    }

    cookie = myDataObject->GetCookie();

    if(cookie == NULL) {
        // root node
        hr = m_pFaxSnapin->globalRoot->ComponentDataContextMenuCommand( m_pFaxSnapin, 
                                                                        lCommandID, 
                                                                        myDataObject );
    } else {
        // child node
        try {       
            hr = ((CInternalNode *)cookie)->ComponentDataContextMenuCommand( m_pFaxSnapin, 
                                                                         lCommandID, 
                                                                         myDataObject );
        } catch ( ... ) {
            DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
            assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcprppg.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxproppg.cpp

Abstract:

    This file contains my implementation of IExtendPropertyPage for the IComponent interface.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// faxcompdata.cpp : Implementation of CFaxComponentData
#include "stdafx.h"
#include "faxcprppg.h"      // IExtendPropertyPage for IComponent
#include "faxadmin.h"
#include "faxsnapin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "iroot.h"
#include "dcomputer.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxComponentExtendPropertyPage
//
//

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentExtendPropertySheet::CreatePropertyPages(
                                                     IN LPPROPERTYSHEETCALLBACK lpProvider,
                                                     IN LONG_PTR handle,
                                                     IN LPDATAOBJECT lpIDataObject)
/*++

Routine Description:

    This routine dispatches the CreateProperPages to the correct node by
    extracting the cookie from lpIdataobject.
    
Arguments:

    lpProvider - PROPERTSHEETCALLBACK pointer.
    handle - MMC routing handle
    lpIDataobject - the data object associated with the destination node

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT(" ************************ Trace: CFaxComponentExtendPropertySheet::CreatePropertyPages") ));

    CFaxDataObject *    myDataObject = NULL;    
    LONG_PTR            cookie;
    HRESULT             hr;

    assert( lpIDataObject != NULL );
    assert( lpProvider != NULL );
    if( lpIDataObject == NULL || lpProvider == NULL ) {
        return E_POINTER;
    }

    myDataObject = ExtractOwnDataObject( lpIDataObject );
    if( myDataObject == NULL ) {
        return E_UNEXPECTED;
    }

    cookie = myDataObject->GetCookie();

    if( myDataObject->GetContext() == CCT_RESULT ) {
        DebugPrint(( TEXT("Trace: CFaxComponentExtendPropertySheet::CreatePropertyPages - RESULT context") ));
        // regular property sheet request, dispatch it
        if( cookie == NULL ) {
            DebugPrint(( TEXT("Trace: CFaxComponentExtendPropertySheet::CreatePropertyPages - ROOT node") ));
            // root object
            assert( m_pFaxComponent != NULL );
            hr = m_pFaxComponent->pOwner->globalRoot->ComponentPropertySheetCreatePropertyPages( m_pFaxComponent, lpProvider, handle, myDataObject );
        } else {
            DebugPrint(( TEXT("Trace: CFaxComponentExtendPropertySheet::CreatePropertyPages - SUBNODE") ));
            // subfolder
            try {            
                hr = ((CInternalNode *)cookie)->ComponentPropertySheetCreatePropertyPages( m_pFaxComponent, lpProvider, handle, myDataObject );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    } else {
        // the MMC shouldn't call us with any other type of request!
        assert( FALSE );
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxComponentExtendPropertySheet::QueryPagesFor(
                                                IN LPDATAOBJECT lpDataObject)
/*++

Routine Description:

    This routine dispatches the QueryPagesFor to the correct node by
    extracting the cookie from lpIdataobject.
    
Arguments:

    lpDataobject - the data object associated with the destination node

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT(" ************************ Trace: CFaxComponentExtendPropertySheet::QueryPagesFor") ));

    CFaxDataObject *    myDataObject = NULL;
    LONG_PTR            cookie;
    HRESULT             hr;

    assert( lpDataObject != NULL );
    if( lpDataObject == NULL ) {
        return E_POINTER;
    }

    myDataObject = ExtractOwnDataObject( lpDataObject );
    if( myDataObject == NULL ) {
        return E_UNEXPECTED;
    }

    cookie = myDataObject->GetCookie();

    if( myDataObject->GetContext() == CCT_RESULT ) {
        // regular property sheet request, dispatch it
        if( cookie == NULL ) {
            // root object
            assert( m_pFaxComponent != NULL );
            hr = m_pFaxComponent->pOwner->globalRoot->ComponentPropertySheetQueryPagesFor( m_pFaxComponent, myDataObject );    
        } else {
            // subfolder
            try {            
                hr = ((CInternalNode *)cookie)->ComponentPropertySheetQueryPagesFor( m_pFaxComponent, myDataObject );
            } catch ( ... ) {            
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    } else {
        // the MMC shouldn't call us with any other type of request!
        assert( FALSE );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxhelper.h ===
// faxhelper.h : IComponent Interface helpers
// 
// these functions help with extracting dataobjects and clipboards
//
// stolen from the MMC SDK.
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
//

#ifndef __FAX_DATAOBJECT_HELPER_H_
#define __FAX_DATAOBJECT_HELPER_H_

#include "faxdataobj.h"

/////////////////////////////////////////////////////////////////////////////
// We need a few functions to help work with dataobjects and clipboard formats

HRESULT ExtractFromDataObject(LPDATAOBJECT lpDataObject,CLIPFORMAT cf,ULONG cb,HGLOBAL *phGlobal);
CFaxDataObject *ExtractOwnDataObject(LPDATAOBJECT lpDataObject);

#endif // __GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxdataobj.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxdataobj.h

Abstract:

    This header prototypes my implementation of IDataObject.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAXDATAOBJECT_H_
#define __FAXDATAOBJECT_H_

#include "resource.h"

class CInternalNode;     // Forward declarations
class CFaxComponentData; 

class CFaxDataObject : public CComObjectRoot,
                       public IDataObject
{

public:

    // ATL Map

    DECLARE_NOT_AGGREGATABLE(CFaxDataObject)

    BEGIN_COM_MAP(CFaxDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
    END_COM_MAP()

    // constructor and destructor
    CFaxDataObject();
    ~CFaxDataObject();

    //
    // IDataObject
    //

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDataHere(
                                                               /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
                                                               /* [out][in] */ STGMEDIUM __RPC_FAR *pmedium);

    // these are not implemented

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData(
                                                           /* [unique][in] */ FORMATETC __RPC_FAR *pformatetcIn,
                                                           /* [out] */ STGMEDIUM __RPC_FAR *pmedium) {
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE QueryGetData(
                                                  /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc) {
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
                                                           /* [unique][in] */ FORMATETC __RPC_FAR *pformatectIn,
                                                           /* [out] */ FORMATETC __RPC_FAR *pformatetcOut) {
        return E_NOTIMPL;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData(
                                                           /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
                                                           /* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
                                                           /* [in] */ BOOL fRelease) {
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc(
                                                   /* [in] */ DWORD dwDirection,
                                                   /* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenumFormatEtc) {
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE DAdvise(
                                             /* [in] */ FORMATETC __RPC_FAR *pformatetc,
                                             /* [in] */ DWORD advf,
                                             /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
                                             /* [out] */ DWORD __RPC_FAR *pdwConnection) {
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE DUnadvise(
                                               /* [in] */ DWORD dwConnection) {
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE EnumDAdvise(
                                                 /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise) {
        return E_NOTIMPL;
    }

    //
    // Non-interface member functions
    //
public:   
    ULONG_PTR GetCookie() { return m_ulCookie; } // cast the owner to a cookie.
    void SetCookie( ULONG_PTR cookie ) 
    {        
        m_ulCookie = cookie; 
    }

    CInternalNode * GetOwner() { return pOwner; }
    // this functino sets the owner of the dataobject 
    // as well as registers the node specific clipboard formats
    void SetOwner( CInternalNode* pO );

    DATA_OBJECT_TYPES GetContext( void ) { return m_Context; }
    void SetContext( DATA_OBJECT_TYPES context ) 
    {
        m_Context = context;
    }

private:
    HRESULT _WriteInternal(IStream *pstm);
    HRESULT _WriteDisplayName(IStream *pstm);
    HRESULT _WriteNodeType(IStream *pstm);
    HRESULT _WriteClsid(IStream *pstm);

    ULONG               m_cRefs;     // object refcount
    ULONG_PTR           m_ulCookie;  // what this obj refers to
    CInternalNode *     pOwner;      // used for getting info from the creator class
    DATA_OBJECT_TYPES   m_Context;   // context in which this was created

#ifdef DEBUG
    static long DataObjectCount;     // debug DataObjectCount
#endif

public:
    // At a minimum we have to implement these clipboard formats
    // to keep MMC happy. We will assert if we don't
    static UINT s_cfInternal;       // Our custom clipboard format
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxhelper.cpp ===
// faxhelper.cpp : IComponent Interface helpers
// 
// these functions help with extracting dataobjects and clipboards
//
// stolen from the MMC SDK.
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
//

#include "stdafx.h"
#include "faxhelper.h"

#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
// We need a few functions to help work with dataobjects and clipboard formats

CFaxDataObject * 
ExtractOwnDataObject(
                    IN LPDATAOBJECT lpDataObject )
/*++

Routine Description:

    This routine extracts a CFaxDataObject from a IDataObject.
    
Arguments:

    lpDataObject

Return Value:

    CFaxDataObject * on success, NULL on failure.

--*/
{
//    DebugPrint(( TEXT("Trace: ::ExtractOwnDataObjecct") ));

    HRESULT hr = S_OK;
    HGLOBAL hGlobal;
    CFaxDataObject *pdo = NULL;

    if( lpDataObject == NULL ) {
        return NULL;
    }

    hr = ExtractFromDataObject(lpDataObject,
                               (CLIPFORMAT)CFaxDataObject::s_cfInternal, 
                               sizeof(CFaxDataObject **),
                               &hGlobal);

    if(SUCCEEDED(hr)) {
        pdo = *(CFaxDataObject **)(hGlobal);
        assert(pdo);    
        assert(!GlobalFree(hGlobal));
    }

    return pdo;
}

HRESULT 
ExtractFromDataObject(
                     IN LPDATAOBJECT lpDataObject,
                     IN CLIPFORMAT cf,
                     IN ULONG cb,
                     OUT HGLOBAL *phGlobal )
/*++

Routine Description:

    Asks the IDataObject for the clipboard format specified in cf
    
Arguments:

    lpDataObject - the data object passed in
    cf - the requested clipboard format
    cb - the requested number of bytes to allocate for the object
    phGlobal - the global handle to the newly allocated info

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: ::ExtractFromDataObjecct") ));

    HRESULT hr = S_OK;
    STGMEDIUM stgmedium =  {  TYMED_HGLOBAL,  NULL};
    FORMATETC formatetc =  {  cf, NULL,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL};

    assert(lpDataObject != NULL);
    if( lpDataObject == NULL ) {
        return E_POINTER;
    }

    *phGlobal = NULL;

    do 
    {
        // Allocate memory for the stream

        stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, cb);

        if(!stgmedium.hGlobal) {
            hr = E_OUTOFMEMORY;
            ATLTRACE(_T("Out of memory\n"));
            break;
        }

        // Attempt to get data from the object

        try {
            hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
        } catch( ... ) {
            // an exception happened!
            hr = E_UNEXPECTED;
        }


        if(FAILED(hr)) {
            break;
        }

        *phGlobal = stgmedium.hGlobal;
        stgmedium.hGlobal = NULL;
    } while(0); 

    // if the call failed, and we allocated memory,
    // free the memory
    if(FAILED(hr) && stgmedium.hGlobal) {
        if(!GlobalFree(stgmedium.hGlobal)) {
            assert(FALSE);
        };
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxdataobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxdataobj.cpp

Abstract:

    This file contains my implementation of IDataObject.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// FaxDataObj.cpp : Implementation of CFaxDataObject
#include "stdafx.h"
#include "faxadmin.h"
#include "faxdataobj.h"
#include "faxstrt.h"

#include "inode.h"

#pragma hdrstop

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//
UINT CFaxDataObject::s_cfInternal = 0;
UINT CFaxDataObject::s_cfDisplayName = 0;
UINT CFaxDataObject::s_cfNodeType = 0;
UINT CFaxDataObject::s_cfSnapinClsid = 0;

#ifdef DEBUG
// DataObject Count
long CFaxDataObject::DataObjectCount = 0;
#endif

#define CF_SNAPIN_INTERNAL L"MMC_SNAPIN_INTERNAL"

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CFaxDataObject::CFaxDataObject()
/*++

Routine Description:

    Constructor.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxDataObject::CFaxDataObject") ));
    m_ulCookie = 0;
    m_Context = CCT_UNINITIALIZED;
    pOwner = NULL;

#ifdef DEBUG    
    InterlockedIncrement( &DataObjectCount );    
    // DebugPrint(( TEXT("FaxDataObject %d created."), DataObjectCount ));
#endif

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
    s_cfInternal = RegisterClipboardFormat(CF_SNAPIN_INTERNAL);
    s_cfDisplayName = RegisterClipboardFormat(CCF_DISPLAY_NAME);
    s_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);
    s_cfSnapinClsid = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
}

CFaxDataObject::~CFaxDataObject()
/*++

Routine Description:

    Destructor.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
//    DebugPrint(( TEXT("Trace: CFaxDataObject::~CFaxDataObject") ));
#ifdef DEBUG
    if( DataObjectCount <= 1 ) {
        // DebugPrint(( TEXT("                       ** All FaxDataObjects destroyed"), DataObjectCount ));
    }
    InterlockedDecrement( &DataObjectCount );
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxDataObject - IDataObject implementation
//
//

HRESULT 
STDMETHODCALLTYPE 
CFaxDataObject::GetDataHere(
                           /* [unique] */ IN FORMATETC __RPC_FAR *pFormatEtc,
                           IN OUT STGMEDIUM __RPC_FAR *pMedium)
/*++

Routine Description:

    Writes the requested data to the specified medium, also dispatches 
    the data request to the owning node's getdatahere for custom formats.
    
Arguments:

    pFormatEtc - the format
    pMedium - the medium

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    // DebugPrint(( TEXT("Trace: CFaxDataObject::GetDataHere") ));

    HRESULT hr = S_OK;
    const CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pstm = NULL;

    assert(pOwner != NULL );
    pMedium->pUnkForRelease = NULL; // by OLE spec

    do {
        hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &pstm);
        if( FAILED( hr ) ) {
            break;
        }

        if(cf == s_cfDisplayName) {
            //DebugPrint(( TEXT("Trace: CFaxDataObject Format DisplayName") ));
            hr = _WriteDisplayName(pstm);
        } else if(cf == s_cfInternal) {
            //DebugPrint(( TEXT("Trace: CFaxDataObject Format Internal") ));
            hr = _WriteInternal(pstm);
        } else if(cf == s_cfNodeType) {
            //DebugPrint(( TEXT("Trace: CFaxDataObject Format Node Type UUID") ));
            hr = _WriteNodeType(pstm);
        } else if(cf == s_cfSnapinClsid) {
            //DebugPrint(( TEXT("Trace: CFaxDataObject Format Snapin CLSID") ));
            hr = _WriteClsid(pstm);
        } else {
            // if we're attached to a node 
            if(pOwner != NULL ) {
                // this is a node specific dataobject - handle node specific data formats
                hr = pOwner->DataObjectGetDataHere( pFormatEtc, pstm );

                // not a known data type!
                if( FAILED(hr) ) {
                    assert( FALSE );                
                    break;
                }
            } else {
                // this is a snapin data object
                // we don't support this clipboard format
                assert( FALSE );                
                hr = DV_E_FORMATETC;
            }
        }
    } while(0);

    if(pstm) {
        pstm->Release();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Member Functions
//
//

void 
CFaxDataObject::SetOwner(
                        CInternalNode* pO )
/*++

Routine Description:

    Initialization function to set the owner of the dataobject and
    register additional clipboard formats
    
Arguments:

    pO - owner node

Return Value:

    None.

--*/
{ 
    assert( pO != NULL );
    pOwner = pO; 

    // register node specific data types now
    if( pOwner != NULL ) {
        pOwner->DataObjectRegisterFormats();
    }
}

HRESULT
CFaxDataObject::_WriteNodeType(
                              IStream *pstm)
/*++

Routine Description:

    Write this node's GUID type to the stream [pstm].    
    
Arguments:

    pstm - the target stream

Return Value:

    None.

--*/
{
    HRESULT hr;
    const GUID *pguid = NULL;

    assert( pOwner != NULL );
    if( pOwner == NULL ) {
        return E_UNEXPECTED;
    }

    pguid = pOwner->GetNodeGUID();

    hr = pstm->Write((PVOID) pguid, sizeof(GUID), NULL);
    return hr;
}

HRESULT
CFaxDataObject::_WriteDisplayName(
                                 IStream *pstm)
/*++

Routine Description:

    Write this node's display name to the stream [pstm].    
    
Arguments:

    pstm - the target stream

Return Value:

    None.

--*/
{
    HRESULT hr = S_OK;
    LPWSTR pwszName;

    assert( pOwner != NULL );
    if( pOwner == NULL ) {
        return E_UNEXPECTED;
    }

    pwszName = pOwner->GetNodeDisplayName();

    ULONG ulSizeofName = lstrlen(pwszName);
    ulSizeofName++; // count null
    ulSizeofName *= sizeof(WCHAR);

    hr = pstm->Write(pwszName, ulSizeofName, NULL);
    return hr;
}

HRESULT
CFaxDataObject::_WriteInternal(
                              IStream *pstm)
/*++

Routine Description:

    Write this object's data in the private clipboard format 
    to the stream [pstm].    
    
Arguments:

    pstm - the target stream

Return Value:

    None.

--*/
{
    HRESULT hr;

    CFaxDataObject *pThis = this;
    hr = pstm->Write(&pThis, sizeof (CFaxDataObject *), NULL);
    return hr;
}

HRESULT
CFaxDataObject::_WriteClsid(
                           IStream *pstm)
/*++

Routine Description:

    Write the snapin's CLSID
    to the stream [pstm].    
    
Arguments:

    pstm - the target stream

Return Value:

    None.

--*/
{
    HRESULT hr;

    hr = pstm->Write(&CLSID_FaxSnapin, sizeof CLSID_FaxSnapin, NULL);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxpersist.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxpersist.h

Abstract:

    This header prototypes my implementation of IPersistStream.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAX_PERSIST_STREAM_H_
#define __FAX_PERSIST_STREAM_H_

#include "resource.h"

class CFaxSnapin; // forward decl

class CFaxPersistStream : public IPersistStream 
{
public:
    // constructor

    CFaxPersistStream()
    {
        m_bDirtyFlag = TRUE;
        m_pFaxSnapin = NULL;
    }

    // IPersistStream

    virtual HRESULT STDMETHODCALLTYPE GetClassID( 
        /* [out] */ CLSID __RPC_FAR *pClassID);

    virtual HRESULT STDMETHODCALLTYPE IsDirty( void );
    
    virtual HRESULT STDMETHODCALLTYPE Load( 
        /* [unique][in] */ IStream __RPC_FAR *pStm );
    
    virtual HRESULT STDMETHODCALLTYPE Save( 
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ BOOL fClearDirty );
    
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize );

    void SetDirty( BOOL isDirty ) { m_bDirtyFlag = isDirty; }

protected:
    CFaxSnapin *        m_pFaxSnapin;
    BOOL                m_bDirtyFlag;

};
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxcprppg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxproppg.h

Abstract:

    This header prototypes my implementation of IExtendPropertySheet for the IComponent interface.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAX_ICOMPONENT_PROP_PAGE_H_
#define __FAX_ICOMPONENT_PROP_PAGE_H_

#include "resource.h"

class CFaxComponent; // forward declared

class CFaxComponentExtendPropertySheet : public IExtendPropertySheet {
public:
    CFaxComponentExtendPropertySheet()
    {
        m_pFaxComponent = NULL;
    }

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages(
                                                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                                            /* [in] */ LONG_PTR handle,
                                                                            /* [in] */ LPDATAOBJECT lpIDataObject);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor(
                                                                      /* [in] */ LPDATAOBJECT lpDataObject);
protected:
    CFaxComponent * m_pFaxComponent;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxproppg.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxproppg.cpp

Abstract:

    This file contains my implementation of IExtendPropertyPage.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// faxcompdata.cpp : Implementation of CFaxComponentData
#include "stdafx.h"
#include "faxproppg.h"
#include "faxadmin.h"
#include "faxsnapin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "iroot.h"
#include "dcomputer.h"

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// CFaxExtendPropertyPage
//
//

HRESULT 
STDMETHODCALLTYPE 
CFaxExtendPropertySheet::CreatePropertyPages(
                                            IN LPPROPERTYSHEETCALLBACK lpProvider,
                                            IN LONG_PTR handle,
                                            IN LPDATAOBJECT lpIDataObject)
/*++

Routine Description:

    This routine extracts the cookie from lpIDataObject and dispatches
    the call to the correct node object. It also handles the initialization 
    case (the select computer dialog).

Arguments:

    lpProvider - a pointer to the PROPERTSHEET callback
    handle - a MMC routing handle
    lpIDataObject - the data object for this object.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT(" ************************ Trace: CFaxExtendPropertySheet::CreatePropertyPages") ));

    CFaxDataObject *    myDataObject;
    CFaxSelectComputerPropSheet * pFoo;
    LONG_PTR            cookie;
    HRESULT             hr;

    assert( lpIDataObject != NULL );
    assert( lpProvider != NULL );
    if( lpIDataObject == NULL || lpProvider == NULL ) {
        assert( FALSE );
        return E_POINTER;
    }

    myDataObject = ExtractOwnDataObject( lpIDataObject );
    if( myDataObject == NULL ) {
        return E_UNEXPECTED;
    }

    cookie = myDataObject->GetCookie();

    if( myDataObject->GetContext() == CCT_SNAPIN_MANAGER ) {
        // initialization case, handle it here!!
        DebugPrint(( TEXT("Trace: CFaxExtendPropertySheet::CreatePropertyPages - NODEMGR context") ));
        pFoo = new CFaxSelectComputerPropSheet( ::GlobalStringTable->GetInstance(), handle, m_pFaxSnapin->globalRoot );
        if (!pFoo) {
            return E_OUTOFMEMORY;
        }
        hr = lpProvider->AddPage( pFoo->GetHandle() );        
    } else if( myDataObject->GetContext() == CCT_SCOPE ) {
        DebugPrint(( TEXT("Trace: CFaxExtendPropertySheet::CreatePropertyPages - SCOPE context") ));
        // regular property sheet request, dispatch it
        if( cookie == NULL ) {
            DebugPrint(( TEXT("Trace: CFaxExtendPropertySheet::CreatePropertyPages - ROOT node") ));
            // root object
            assert( m_pFaxSnapin != NULL );
            hr = m_pFaxSnapin->globalRoot->ComponentDataPropertySheetCreatePropertyPages( m_pFaxSnapin, lpProvider, handle, myDataObject );    
        } else {
            DebugPrint(( TEXT("Trace: CFaxExtendPropertySheet::CreatePropertyPages - SUBNODE") ));
            // subfolder
            try {               
                hr = ((CInternalNode *)cookie)->ComponentDataPropertySheetCreatePropertyPages( m_pFaxSnapin, lpProvider, handle, myDataObject );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    } else {
        // oops - mmc shouldn't be calling us with CCT_RESULT
        assert( FALSE );
    }

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxExtendPropertySheet::QueryPagesFor(
                                      IN LPDATAOBJECT lpDataObject)
/*++

Routine Description:

    This routine extracts the cookie from lpIDataObject and dispatches
    the call to the correct node object.

Arguments:

    lpIDataObject - the data object for this object.

Return Value:

    HRESULT indicating SUCCEEDED() S_OK, or S_FALSE
    or FAILED()

--*/
{
    DebugPrint(( TEXT(" ************************ Trace: CFaxExtendPropertySheet::QueryPagesFor") ));

    CFaxDataObject *    myDataObject;
    LONG_PTR            cookie;
    HRESULT             hr;

    assert( lpDataObject != NULL );
    if( lpDataObject == NULL ) {
        return E_POINTER;
    }

    myDataObject = ExtractOwnDataObject( lpDataObject );
    if( myDataObject == NULL ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }

    cookie = myDataObject->GetCookie();

    if( myDataObject->GetContext() == CCT_SNAPIN_MANAGER ) {
        // initialization case, handle it here!!
        hr = S_OK;
    } else if( myDataObject->GetContext() == CCT_SCOPE ) {
        // regular property sheet request, dispatch it
        if( cookie == NULL ) {
            // root object
            assert( m_pFaxSnapin );
            hr = m_pFaxSnapin->globalRoot->ComponentDataPropertySheetQueryPagesFor( m_pFaxSnapin, myDataObject );    
        } else {
            // subfolder
            try {            
                hr = ((CInternalNode *)cookie)->ComponentDataPropertySheetQueryPagesFor( m_pFaxSnapin, myDataObject );
            } catch ( ... ) {
                DebugPrint(( TEXT("Invalid Cookie: 0x%08x"), cookie ));
                assert( FALSE ); // got passed an INVALID COOKIE!?!?!?!?
                hr = E_UNEXPECTED;
            }
        }
    } else {
        // oops - mmc shouldn't be calling us with CCT_RESULT
        assert( FALSE );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxpersist.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxconmenu.cpp

Abstract:

    This file contains my implementation of IExtendContextMenu.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#include "stdafx.h"
#include "faxsnapin.h"
#include "faxpersist.h"
#include "faxadmin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "iroot.h"

#pragma hdrstop

HRESULT 
STDMETHODCALLTYPE 
CFaxPersistStream::GetClassID(
                             OUT CLSID __RPC_FAR *pClassID)
/*++

Routine Description:

    This routine returns the CLSID of the snapin.

Arguments:

    pClassID - returns the class id

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxPersistStream::GetClassID") ));
    assert( pClassID != NULL );
    if (!pClassID) {
        return E_FAIL;
    }
    
    *pClassID = CLSID_FaxSnapin;

    return S_OK;
}


HRESULT 
STDMETHODCALLTYPE 
CFaxPersistStream::IsDirty(
                          void )
/*++

Routine Description:

    Returns S_OK if the stream is dirty and needs to be written out.
    Returns S_FALSE otherwise.

Arguments:

    None.

Return Value:

    HRESULT indicating if the stream is dirty.

--*/
{
    DebugPrint(( TEXT("Trace: CFaxPersistStream::IsDirty") ));
    if( m_bDirtyFlag == FALSE ) {
        return S_FALSE;
    } else {
        return S_OK;        // save us
    }

}

HRESULT 
STDMETHODCALLTYPE 
CFaxPersistStream::Load(
                       /* [unique] */ IN IStream __RPC_FAR *pStm)
/*++

Routine Description:

    Loads the state of the snapin from the stream in pStm

Arguments:

    pStm - stream to read snapin state from

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxPersistStream::Load") ));

    assert( pStm != NULL );
    assert( m_pFaxSnapin != NULL );

    HRESULT hr;
    int     iResult;
    BOOL    isremote;
    ULONG   count;
    TCHAR   machineName[ MAX_COMPUTERNAME_LENGTH + 1 ];

    do {
        hr = pStm->Read( &isremote, sizeof( BOOL ), &count );
        if( !SUCCEEDED( hr ) ) {
            break;
        }
        if( isremote == TRUE ) {
            // remote
            hr = pStm->Read( &machineName, MAX_COMPUTERNAME_LENGTH * 2, &count );
            if( !SUCCEEDED( hr ) ) {
                break;
            }
            m_pFaxSnapin->globalRoot->SetMachine( (LPTSTR)&machineName );
        } else {
            // local
            m_pFaxSnapin->globalRoot->SetMachine( NULL );
        }              
    } while( 0 );

    if( hr != S_OK ) {
        m_pFaxSnapin->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_LOADSTATE_ERR ), 
                                             ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                             MB_OK, 
                                             &iResult);
    }
    m_bDirtyFlag = FALSE;

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxPersistStream::Save(
                       /* [unique] */ IN IStream __RPC_FAR *pStm,
                       IN BOOL fClearDirty)
/*++

Routine Description:

    This routine save the snapin state to the stream.
    
Arguments:

    pStm - the target stream
    fClearDirty - TRUE to clear the dirty flag.    

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxPersistStream::Save") ));

    assert( pStm != NULL );
    assert( m_pFaxSnapin != NULL );

    ULONG       count;
    int         iResult;
    HRESULT     hr;
    BOOL        r;

    do {
        if( m_pFaxSnapin->globalRoot->GetMachine() != NULL ) {
            // remote
            r = TRUE;
            hr = pStm->Write( &r, sizeof(BOOL), &count );
            if( !SUCCEEDED( hr ) ) {
                break;
            }
            hr = pStm->Write( const_cast<PVOID>(m_pFaxSnapin->globalRoot->GetMachine()), 
                              MAX_COMPUTERNAME_LENGTH * 2, &count );
            if( !SUCCEEDED( hr ) ) {
                break;
            }
        } else {
            // local
            r = FALSE;
            hr = pStm->Write( &r, sizeof(BOOL), &count );
            if( !SUCCEEDED( hr ) ) {
                break;
            }
        }
        if( fClearDirty == TRUE ) {
            m_bDirtyFlag = FALSE;
        }
    } while( 0 );

    if( !SUCCEEDED( hr ) ) {
        m_pFaxSnapin->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_SAVESTATE_ERR ), 
                                             ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                             MB_OK, 
                                             &iResult);        
    }
    return hr;

}

HRESULT 
STDMETHODCALLTYPE 
CFaxPersistStream::GetSizeMax(
                             OUT ULARGE_INTEGER __RPC_FAR *pcbSize)
/*++

Routine Description:

    This routine returns the maximum size that the snapin will require
    to persist its state.
    
Arguments:

    pcbSize - size of the stream.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxPersistStream::GetSizeMax") ));

    assert( pcbSize != NULL );
    if (!pcbSize) {
        return E_FAIL;
    }    

    // return a conservative estimate of the space required in bytes
    LISet32( *pcbSize, sizeof( BOOL ) + (MAX_COMPUTERNAME_LENGTH+1) * (sizeof(TCHAR)) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxproppg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxproppg.h

Abstract:

    This header prototypes my implementation of IExtendPropertySheet.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __FAX_PROP_PAGE_H_
#define __FAX_PROP_PAGE_H_

#include "resource.h"

class CFaxSnapin; // forward declared

class CFaxExtendPropertySheet : public IExtendPropertySheet {
public:
    CFaxExtendPropertySheet() 
    {
        m_pFaxSnapin = NULL;
    }

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages(
                                                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                                            /* [in] */ LONG_PTR handle,
                                                                            /* [in] */ LPDATAOBJECT lpIDataObject);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor(
                                                                      /* [in] */ LPDATAOBJECT lpDataObject);
protected:
    CFaxSnapin * m_pFaxSnapin;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxsabout.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxsabout.h

Abstract:

    This header is the ISnapinAbout implmentation.
    

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// FaxSnapin.h : Declaration of the CFaxSnapinAbout

#ifndef __FAXSNAPINABOUT_H_
#define __FAXSNAPINABOUT_H_

#include "resource.h"           // main symbols
#include "faxadmin.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxSnapinAbout
class ATL_NO_VTABLE CFaxSnapinAbout : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxSnapinAbout, &CLSID_FaxSnapinAbout>,
    public ISnapinAbout
{
public:
    CFaxSnapinAbout()
    {
        DebugPrint(( TEXT("FaxSnapinAbout Created") ));
    }
    ~CFaxSnapinAbout()
    {
        DebugPrint(( TEXT("FaxSnapinAbout Destroyed") ));
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_FAXSNAPIN)
    DECLARE_NOT_AGGREGATABLE(CFaxSnapinAbout)

    BEGIN_COM_MAP(CFaxSnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)  
    END_COM_MAP()

    // IFaxSnapinAbout

    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinDescription( 
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ LPOLESTR __RPC_FAR *lpName);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinVersion( 
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinImage( 
            /* [out] */ HICON __RPC_FAR *hAppIcon);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticFolderImage( 
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask);

};

#endif //__FAXSNAPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxsabout.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxsabout.cpp

Abstract:

    Implementation of ISnapinAbout

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// FaxSnapin.cpp : Implementation of CFaxSnapinAbout
#include "stdafx.h"
#include "faxadmin.h"
#include "FaxSAbout.h"
#include "faxstrt.h"          // string table

#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
// CFaxSnapinAbout

HRESULT 
STDMETHODCALLTYPE 
CFaxSnapinAbout::GetSnapinDescription(
                                     OUT LPOLESTR __RPC_FAR *lpDescription)
/*++

Routine Description:

    Returns a LPOLESTR to the textual description of the snapin.

Arguments:

    lpDescription - the pointer is returned here

Return Value:

    HRESULT indicating SUCCCEDED() or FAILED()

--*/
{
    LPTSTR  description = NULL;    

    if (!lpDescription) {
        return(E_POINTER);
    }

    description = ::GlobalStringTable->GetString( IDS_SNAPIN_DESCRIPTION );
    if( description == NULL ) {
        return E_UNEXPECTED;
    }

    *lpDescription = (LPOLESTR)CoTaskMemAlloc( StringSize( description ) * 2 );
    if( *lpDescription == NULL ) {
        return E_OUTOFMEMORY;
    }

    _tcscpy( *lpDescription, description );

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSnapinAbout::GetProvider(
                            OUT LPOLESTR __RPC_FAR *lpName)
/*++

Routine Description:

    Returnes the provider name of the snapin.

Arguments:

    lpName - returns an LPOLESTR pointing to the provider name, IE Microsoft.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    LPTSTR  name = NULL;  

    if (!lpName) {
        return(E_POINTER);
    }

    name = ::GlobalStringTable->GetString( IDS_SNAPIN_PROVIDER );
    if( name == NULL ) {
        return E_UNEXPECTED;
    }

    *lpName = (LPOLESTR)CoTaskMemAlloc( StringSize( name ) * 2 );
    if( *lpName == NULL ) {
        return E_OUTOFMEMORY;
    }

    _tcscpy( *lpName, name );

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSnapinAbout::GetSnapinVersion(
                                 OUT LPOLESTR __RPC_FAR *lpVersion)
/*++

Routine Description:

    Returned the version of the snapin.

Arguments:

    lpVersion - returns an LPOLESTR pointing to the version string.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    LPTSTR  version = NULL;    

    if (!lpVersion) {
        return(E_POINTER);
    }

    version = ::GlobalStringTable->GetString( IDS_SNAPIN_VERSION );
    if( version == NULL ) {
        return E_UNEXPECTED;
    }

    *lpVersion = (LPOLESTR)CoTaskMemAlloc( StringSize( version ) * 2 );
    if( *lpVersion == NULL ) {
        return E_OUTOFMEMORY;
    }

    _tcscpy( *lpVersion, version );

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSnapinAbout::GetSnapinImage(
                               OUT HICON __RPC_FAR *hAppIcon)
/*++

Routine Description:

    Returns an icon for the root folder of the snapin.

Arguments:

    lpName - returns an LPOLESTR pointing to the provider name, IE Microsoft.

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{    

    if (!hAppIcon) {
        return(E_POINTER);
    }

    *hAppIcon = LoadIcon( ::GlobalStringTable->GetInstance(), MAKEINTRESOURCE( IDI_FAXSVR ) );
    if( *hAppIcon == NULL ) {
        return E_UNEXPECTED;
    }

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSnapinAbout::GetStaticFolderImage(
                                     OUT HBITMAP __RPC_FAR *hSmallImage,
                                     OUT HBITMAP __RPC_FAR *hSmallImageOpen,
                                     OUT HBITMAP __RPC_FAR *hLargeImage,
                                     OUT COLORREF __RPC_FAR *cMask)
/*++

Routine Description:

    Returns bitmaps for the root folder of the snapin.

Arguments:

    hSnallImage - 16x16 image closed state
    hSmallImageOpen - 16x16 image open state
    hLargeInmage - 32x32 image
    cmask - colour mask
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    if (!cMask || !hSmallImage || !hLargeImage || !hSmallImageOpen) {
        return E_POINTER;
    }

    *cMask = 0x00ff00ff;

    *hSmallImage = LoadBitmap( ::GlobalStringTable->GetInstance(), MAKEINTRESOURCE( IDB_MAINSMALL ) );
    assert( *hSmallImage != NULL );
    if( *hSmallImage == NULL ) {
        return E_UNEXPECTED;
    }
    *hSmallImageOpen = LoadBitmap( ::GlobalStringTable->GetInstance(), MAKEINTRESOURCE( IDB_MAINSMALL ) );
    assert( *hSmallImageOpen != NULL );
    if( *hSmallImageOpen == NULL ) {
        return E_UNEXPECTED;
    }
    *hLargeImage = LoadBitmap( ::GlobalStringTable->GetInstance(), MAKEINTRESOURCE( IDB_MAINLARGE ) );
    assert( *hLargeImage != NULL );
    if( *hLargeImage == NULL ) {
        return E_UNEXPECTED;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxshelp.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxhelp.cpp

Abstract:

    This file contains my implementation of ISnapinHelp.

Environment:

    WIN32 User Mode

Author:

    Andrew Ritz (andrewr) 30-Sept-1997

--*/

#include "stdafx.h"
#include "faxsnapin.h"
#include "faxpersist.h"
#include "faxadmin.h"
#include "faxcomp.h"
#include "faxcompd.h"
#include "faxdataobj.h"
#include "faxhelper.h"
#include "faxstrt.h"
#include "adminhlp.h"
#include "faxshelp.h"
#include "iroot.h"

#pragma hdrstop

HRESULT 
STDMETHODCALLTYPE
CFaxSnapinHelp::GetHelpTopic(
    LPOLESTR* lpCompiledHelpFile
    )
/*++

Routine Description:

    This routine returns the CLSID of the snapin.

Arguments:

    pClassID - returns the class id

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    WCHAR Path[MAX_PATH];

    DebugPrint(( TEXT("Trace: CFaxSnapinHelp::GetHelpTopic") ));
    assert( lpCompiledHelpFile != NULL );

    ExpandEnvironmentStrings(FAXMMC_HTMLHELP_FILENAME,Path,sizeof(Path)/sizeof(WCHAR));

    *lpCompiledHelpFile = SysAllocString( Path );

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE
CFaxSnapinTopic::ShowTopic(
    LPOLESTR pszHelpTopic
    )
/*++

Routine Description:

    This routine returns the CLSID of the snapin.

Arguments:

    pClassID - returns the class id

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CFaxSnapinTopic::ShowTopic") ));

    pszHelpTopic = SysAllocString( FAXMMC_HTMLHELP_TOPIC );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxsecinfo.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxsecinfo.h

Abstract:

    This header is the ISecurityInformation implmentation used to instantiate a
    security page.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/


// FaxSnapin.cpp : Implementation of CFaxSnapinAbout
#include "stdafx.h"
#include "faxadmin.h"

#include "faxsecinfo.h"
#include "faxstrt.h"            // string table
#include "faxcompd.h"           // IComponentData

#include "inode.h"              // CInternalNode
#include "iroot.h"              // CInternalRoot

#include <faxreg.h> // contains FAXSTAT_WINCLASS definition

#pragma hdrstop

GENERIC_MAPPING FaxGenericMapping[] =
{
    {
        STANDARD_RIGHTS_READ,
        STANDARD_RIGHTS_WRITE,
        STANDARD_RIGHTS_EXECUTE,
        STANDARD_RIGHTS_REQUIRED    
    }
};

SI_ACCESS siFaxAccesses[] =
{
    // submit permission
    {   
        &GUID_NULL, 
        FAX_JOB_SUBMIT | STANDARD_RIGHTS_WRITE,
        MAKEINTRESOURCE(IDS_FAXSEC_JOB_SUB),
        SI_ACCESS_GENERAL
    },

    // query permission
    {   
        &GUID_NULL, 
        FAX_JOB_QUERY | STANDARD_RIGHTS_READ,
        MAKEINTRESOURCE(IDS_FAXSEC_JOB_QRY),    
        SI_ACCESS_GENERAL
    },

    {   
        &GUID_NULL, 
        FAX_CONFIG_QUERY | STANDARD_RIGHTS_READ,
        MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_QRY),    
        SI_ACCESS_GENERAL
    },

    {   
        &GUID_NULL, 
        FAX_PORT_QUERY | STANDARD_RIGHTS_READ,
        MAKEINTRESOURCE(IDS_FAXSEC_PORT_QRY),    
        SI_ACCESS_GENERAL
    },

    // manage permission    
    
    {   
        &GUID_NULL, 
        FAX_JOB_MANAGE | STANDARD_RIGHTS_ALL,
        MAKEINTRESOURCE(IDS_FAXSEC_JOB_MNG),
        SI_ACCESS_GENERAL
    },
    
    {   
        &GUID_NULL, 
        FAX_CONFIG_SET | STANDARD_RIGHTS_ALL,
        MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_SET),
        SI_ACCESS_GENERAL
    },    
        
    {   
        &GUID_NULL, 
        FAX_PORT_SET | STANDARD_RIGHTS_ALL,
        MAKEINTRESOURCE(IDS_FAXSEC_PORT_SET),    
        SI_ACCESS_GENERAL
    },

    // custom access (We don't expose this access, but it is the default access when adding new permissions)
    {   
        &GUID_NULL, 
        FAX_READ | FAX_WRITE,
        TEXT("foobar"),    
        SI_ACCESS_GENERAL
    }

};

#define iFaxDefSecurity 7

CFaxSecurityInformation::CFaxSecurityInformation()
: m_pDescriptor( NULL ),
m_pCompData( NULL ),
m_pOwner( NULL ),
m_dwDescID( 0 ),
m_pAbsoluteDescriptor( NULL ),
m_pDacl( NULL ),
m_pSacl( NULL ),
m_pDescOwner( NULL ),
m_pPrimaryGroup( NULL )
{
    DebugPrint(( TEXT("CFaxSecurityInfo Created") ));
}

CFaxSecurityInformation::~CFaxSecurityInformation()
{
    DebugPrint(( TEXT("CFaxSecurityInfo Destroyed") ));
    
    if( m_pDescriptor != NULL ) {
        ::LocalFree( m_pDescriptor );
        m_pDescriptor = NULL;
    }
    
}

/////////////////////////////////////////////////////////////////////////////
// CFaxSecurityInformation
// *** ISecurityInformation methods ***

HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetObjectInformation(
                                             IN OUT PSI_OBJECT_INFO pObjectInfo 
                                             )
{
    DebugPrint(( TEXT("Trace: CFaxSecurityInformation::GetObjectInformation") ));

    assert( pObjectInfo != NULL );

    if( pObjectInfo == NULL ) {
        return E_POINTER;
    }

    pObjectInfo->dwFlags = SI_NO_TREE_APPLY | SI_EDIT_ALL | SI_NO_ACL_PROTECT;
    pObjectInfo->hInstance = ::GlobalStringTable->GetInstance();
    pObjectInfo->pszServerName = m_pCompData->globalRoot->GetMachine();
    pObjectInfo->pszObjectName = ::GlobalStringTable->GetString( IDS_SECURITY_CAT_NODE_DESC );

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetSecurity(
                                    IN SECURITY_INFORMATION RequestedInformation,
                                    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                                    IN BOOL fDefault 
                                    )
{
    DebugPrint(( TEXT("Trace: CFaxSecurityInformation::GetSecurity") ));

    SetSecurityDescriptor( m_dwDescID );

    if( fDefault == TRUE ) {
        return E_NOTIMPL;
    } else {
        if( RequestedInformation & DACL_SECURITY_INFORMATION ||
            RequestedInformation & OWNER_SECURITY_INFORMATION ||
            RequestedInformation & GROUP_SECURITY_INFORMATION ||
            RequestedInformation & SACL_SECURITY_INFORMATION
          ) 
        {            
            if( IsValidSecurityDescriptor( m_pDescriptor ) ) {
                if( FAILED( MakeSelfRelativeCopy( m_pDescriptor, ppSecurityDescriptor ) ) ) {
                    assert( FALSE );
                    return E_UNEXPECTED;
                }
                // paranoia check
                if( !IsValidSecurityDescriptor( *ppSecurityDescriptor ) ) {
                    assert( FALSE );
                    return E_UNEXPECTED;
                }

                return S_OK;
            } else {
                assert( FALSE );
                return E_UNEXPECTED;
            }
        } else {
            return E_NOTIMPL;
        }
    }    
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::SetSecurity(
                                    IN SECURITY_INFORMATION SecurityInformation,
                                    IN PSECURITY_DESCRIPTOR pSecurityDescriptor 
                                    )
{
    DebugPrint(( TEXT("Trace: CFaxSecurityInformation::SetSecurity") ));

    FAX_SECURITY_DESCRIPTOR         temp;
    BOOL                            bResult;
    BOOL                            bPresent;
    BOOL                            bDefaulted;

    PACL                                pDacl = NULL;
    PACL                                pOldDacl = NULL;
    DWORD                               dwDaclSize = 0;
    PACL                                pSacl = NULL;
    DWORD                               dwSaclSize = 0;
    PSID                                pSidOwner = NULL;
    DWORD                               dwOwnerSize = 0;
    PSID                                pPrimaryGroup = NULL;
    DWORD                               dwPrimaryGroupSize = 0;

    SetSecurityDescriptor( m_dwDescID );

    // paranoia check
    if( !IsValidSecurityDescriptor( pSecurityDescriptor ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }
    if( !IsValidSecurityDescriptor( m_pAbsoluteDescriptor ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }
    if( !IsValidSecurityDescriptor( m_pDescriptor ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }

    if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
        // if the descriptor we got has a DACL
        if( !GetSecurityDescriptorDacl(
                                      pSecurityDescriptor,     // address of security descriptor  
                                      &bPresent,               // address of flag for presence of disc. ACL
                                      &pDacl,                  // address of pointer to ACL  
                                      &bDefaulted              // address of flag for default disc. ACL
                                      ) 
          ) {
            assert( FALSE );
            return E_UNEXPECTED;    
        } else {
            if( bPresent ) {
                // delete the old DACL
                if( m_pDacl != NULL ) {
                    ::LocalFree( (PVOID) m_pDacl );
                    m_pDacl = NULL;
                }

                m_pDacl = pDacl;

                // set the new DACL
                if( !SetSecurityDescriptorDacl(
                                              m_pAbsoluteDescriptor,
                                              bPresent,
                                              pDacl,
                                              FALSE
                                              )
                  ) {
                    assert( FALSE );
                    return E_UNEXPECTED;
                }
            }
        }
    }

    if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
        // if the descriptor we got has a SACL
        if( !GetSecurityDescriptorSacl(
                                      pSecurityDescriptor,     // address of security descriptor  
                                      &bPresent,               // address of flag for presence of disc. ACL
                                      &pDacl,                  // address of pointer to ACL  
                                      &bDefaulted              // address of flag for default disc. ACL
                                      ) 
          ) {
            assert( FALSE );
            return E_UNEXPECTED;    
        } else {
            if( bPresent ) {
                // delete the old SACL
                if( m_pSacl != NULL ) {
                    ::LocalFree( (PVOID) m_pSacl );
                    m_pSacl = NULL;
                }

                m_pSacl = pSacl;

                // set the new SACL
                if( !SetSecurityDescriptorSacl(
                                              m_pAbsoluteDescriptor,
                                              bPresent,
                                              pSacl,
                                              FALSE
                                              )
                  ) {
                    assert( FALSE );
                    return E_UNEXPECTED;
                }
            }
        }
    }

    if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
        // if the descriptor we got has a OWNER
        if( !GetSecurityDescriptorOwner(
                                       pSecurityDescriptor,     // address of security descriptor  
                                       &pSidOwner,                 // address of pointer to ACL  
                                       &bDefaulted              // address of flag for default disc. ACL
                                       ) 
          ) {
            assert( FALSE );
            return E_UNEXPECTED;    
        } else {
            if( pSidOwner != NULL ) {
                // delete the old OWNER
                if( m_pDescOwner != NULL ) {
                    ::LocalFree( (PVOID) m_pDescOwner );
                    m_pDescOwner = NULL;
                }

                m_pDescOwner = pSidOwner;

                // set the new owner
                if( !SetSecurityDescriptorOwner(
                                               m_pAbsoluteDescriptor,
                                               pSidOwner,
                                               FALSE
                                               )
                  ) {
                    assert( FALSE );
                    return E_UNEXPECTED;
                }
            }
        }
    }

    if( SecurityInformation & GROUP_SECURITY_INFORMATION ) {
        // if the descriptor we got has a GROUP
        if( !GetSecurityDescriptorGroup(
                                       pSecurityDescriptor,     // address of security descriptor  
                                       &pPrimaryGroup,          // address of pointer to ACL  
                                       &bDefaulted              // address of flag for default disc. ACL
                                       ) 
          ) {
            assert( FALSE );
            return E_UNEXPECTED;    
        } else {
            if( pPrimaryGroup != NULL ) {

                // delete the old group
                if( m_pPrimaryGroup != NULL ) {
                    ::LocalFree( (PVOID) m_pPrimaryGroup );
                    m_pPrimaryGroup = NULL;
                }
                m_pPrimaryGroup = pPrimaryGroup;

                // set the new group
                if( !SetSecurityDescriptorGroup(
                                               m_pAbsoluteDescriptor,
                                               pPrimaryGroup,
                                               FALSE
                                               )
                  ) {
                    assert( FALSE );
                    return E_UNEXPECTED;
                }
            }
        }
    }

    // release the old relative desciptor
    if( m_pDescriptor != NULL ) {
        ::LocalFree( (PVOID)m_pDescriptor );
        m_pDescriptor = NULL;
    }

    // paranoia check
    if( !IsValidSecurityDescriptor( m_pAbsoluteDescriptor ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }

    // copy the new absolute descriptor to a relative version
    if( FAILED( MakeSelfRelativeCopy( m_pAbsoluteDescriptor, &m_pDescriptor ) ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }

    // paranoia check
    if( !IsValidSecurityDescriptor( m_pDescriptor ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }
    if( !IsValidSecurityDescriptor( m_pAbsoluteDescriptor ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }

    // save the new relative descriptor to the fax server
    temp.Id = m_dwDescID;
    temp.FriendlyName = NULL;
    temp.SecurityDescriptor = (unsigned char *)m_pDescriptor;
    try {
        bResult = FaxSetSecurityDescriptor( m_pCompData->m_FaxHandle, &temp );
        if( bResult == FALSE ) {
            ::GlobalStringTable->SystemErrorMsg( GetLastError() );
            assert( FALSE );
        }
    } catch( ... ) {
        bResult = FALSE;
        m_pCompData->NotifyRpcError( TRUE );
        assert( FALSE );
        ::GlobalStringTable->SystemErrorMsg( GetLastError() );
    }
    
    // paranoia check
    if( !IsValidSecurityDescriptor( m_pDescriptor ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }
    
    if( !IsValidSecurityDescriptor( m_pAbsoluteDescriptor ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }

    // See if faxstat is running
    HWND hWndFaxStat = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxStat) {
        PostMessage(hWndFaxStat, WM_FAXSTAT_MMC, 0, 0);
    }

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetAccessRights(
                                        IN const GUID* pguidObjectType,
                                        IN DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                        OUT PSI_ACCESS *ppAccess,
                                        OUT ULONG *pcAccesses,
                                        OUT ULONG *piDefaultAccess 
                                        )
{
    DebugPrint(( TEXT("Trace: CFaxSecurityInformation::GetAccessRights") ));
    *ppAccess = siFaxAccesses;    
    *pcAccesses = 7;    
    *piDefaultAccess = iFaxDefSecurity;

    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::MapGeneric(
                                   IN const GUID *pguidObjectType,
                                   IN UCHAR *pAceFlags,
                                   IN OUT ACCESS_MASK *pMask
                                   )
{
    DebugPrint(( TEXT("Trace: CFaxSecurityInformation::MapGeneric") ));
    MapGenericMask( pMask, FaxGenericMapping );

    return S_OK;
}

// no need to impl these

HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetInheritTypes(
                                        OUT PSI_INHERIT_TYPE *ppInheritTypes,
                                        OUT ULONG *pcInheritTypes 
                                        )
{
    DebugPrint(( TEXT("Trace: CFaxSecurityInformation::GetInheritTypes") ));
    return E_NOTIMPL;
}

HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::PropertySheetPageCallback(
                                                  IN HWND hwnd, 
                                                  IN UINT uMsg, 
                                                  IN SI_PAGE_TYPE uPage 
                                                  )
{
    DebugPrint(( TEXT("Trace: CFaxSecurityInformation::PropertySheetPageCallback") ));

    if( uMsg == PSPCB_RELEASE  ) {    
        DestroyAbsoluteDescriptor();
    }

    return S_OK;
}

// Internal Methods

HRESULT 
CFaxSecurityInformation::SetOwner(
                                 CInternalNode * toSet ) 
{ 
    DebugPrint(( TEXT("         * Trace: CFaxSecurityInformation::SetOwner") ));

    assert( toSet != NULL );

    m_pOwner = toSet; 
    m_pCompData = m_pOwner->m_pCompData;

    return S_OK;
}

HRESULT 
CFaxSecurityInformation::SetSecurityDescriptor(
                                              DWORD FaxDescriptorId
                                              )
{
    DebugPrint(( TEXT("         * Trace: CFaxSecurityInformation::SetSecurityDescriptor") ));

    DWORD                           descLen = 0;    
    HRESULT                         hr = S_OK;
    PFAX_SECURITY_DESCRIPTOR        FaxDescriptor = NULL;
    BOOL                            bResult;

    try {
        bResult = FaxGetSecurityDescriptor( m_pOwner->m_pCompData->m_FaxHandle, FaxDescriptorId, &FaxDescriptor );
    } catch( ... ) {
        bResult = FALSE;
        assert( FALSE );
    }

    if( bResult ) {
        if( !IsValidSecurityDescriptor( FaxDescriptor->SecurityDescriptor ) ) {
            assert( FALSE );
            return E_UNEXPECTED;
        }

        m_dwDescID = FaxDescriptor->Id;

        hr = MakeSelfRelativeCopy( FaxDescriptor->SecurityDescriptor, &m_pDescriptor );
        if( FAILED( hr ) ) {
            assert( FALSE );
            return hr;
        }

        FaxFreeBuffer( FaxDescriptor );

        hr = MakeAbsoluteCopyFromRelative( m_pDescriptor, &m_pAbsoluteDescriptor );
        if( FAILED( hr ) ) {
            assert( FALSE );
            return hr;
        }
        
        // paranoia check
        if( !IsValidSecurityDescriptor( m_pDescriptor ) ) {
            assert( FALSE );
            return E_UNEXPECTED;
        }
        // paranoia check
        if( !IsValidSecurityDescriptor( m_pAbsoluteDescriptor ) ) {
            assert( FALSE );
            return E_UNEXPECTED;
        }

    } else {
        if (GetLastError() != ERROR_ACCESS_DENIED) {
            assert( FALSE );
            m_pOwner->m_pCompData->NotifyRpcError( TRUE );
        }
        ::GlobalStringTable->SystemErrorMsg( GetLastError() );
        hr = E_UNEXPECTED;                
    }
    return hr;
}


// stolen from \private\admin\snapin\filemgmt\permpage.cpp and modified
HRESULT CFaxSecurityInformation::MakeSelfRelativeCopy(
                                                     PSECURITY_DESCRIPTOR  psdOriginal,
                                                     PSECURITY_DESCRIPTOR* ppsdNew 
                                                     )
{
    DebugPrint(( TEXT("         * Trace: CFaxSecurityInformation::MakeSelfRelativeCopy") ));
    assert( NULL != psdOriginal );

    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL         sdc = 0;
    PSECURITY_DESCRIPTOR                psdSelfRelativeCopy = NULL;
    DWORD                               dwRevision = 0;
    DWORD                               cb = 0;

    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        assert( FALSE );
        return E_INVALIDARG;
    }

    if( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) {
        assert( FALSE );
        DWORD err = ::GetLastError();
        return HRESULT_FROM_WIN32( err );
    }

    if( sdc & SE_SELF_RELATIVE ) {
        // the original is in self-relative format, just byte-copy it

        // get size
        cb = ::GetSecurityDescriptorLength( psdOriginal );

        // alloc the memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(NULL == psdSelfRelativeCopy) {
            assert( FALSE );
            return E_OUTOFMEMORY;
        }

        // make the copy
        ::memcpy( psdSelfRelativeCopy, psdOriginal, cb );
    } else {
        // the original is in absolute format, convert-copy it

        // get new size - it will fail and set cb to the correct buffer size
        ::MakeSelfRelativeSD( psdOriginal, NULL, &cb );

        // alloc the new amount of memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(NULL == psdSelfRelativeCopy) {
            assert( FALSE );
            return E_OUTOFMEMORY; // just in case the exception is ignored
        }

        if( !::MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) ) {
            assert( FALSE );
            if( NULL == ::LocalFree( psdSelfRelativeCopy ) ) {
                DWORD err = ::GetLastError();
                return HRESULT_FROM_WIN32( err );
            }
            psdSelfRelativeCopy = NULL;
        }
    }

    *ppsdNew = psdSelfRelativeCopy;
    return S_OK;
}

HRESULT CFaxSecurityInformation::MakeAbsoluteCopyFromRelative(
                                                             PSECURITY_DESCRIPTOR  psdOriginal,
                                                             PSECURITY_DESCRIPTOR* ppsdNew 
                                                             )
{
    assert( NULL != psdOriginal );

    DebugPrint(( TEXT("         * Trace: CFaxSecurityInformation::MakeAbsoluteCopyFromRelative") ));

    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL         sdc = 0;
    PSECURITY_DESCRIPTOR                psdAbsoluteCopy = NULL;
    DWORD                               dwRevision = 0;
    DWORD                               cb = 0;

    BOOL                                bDefaulted;

    DWORD                               dwDaclSize = 0;
    BOOL                                bDaclPresent = FALSE;    
    DWORD                               dwSaclSize = 0;
    BOOL                                bSaclPresent = FALSE;
   
    DWORD                               dwOwnerSize = 0;    
    DWORD                               dwPrimaryGroupSize = 0;

    HRESULT                             hr = S_OK;

    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        assert( FALSE );
        return E_INVALIDARG;
    }

    if( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) {
        assert( FALSE );
        DWORD err = ::GetLastError();
        hr = HRESULT_FROM_WIN32( err );
        goto cleanup;
    }

    if( sdc & SE_SELF_RELATIVE ) {
        // the original is in self-relative format, build an absolute copy

        // get the dacl
        if( !GetSecurityDescriptorDacl(
                                      psdOriginal,      // address of security descriptor  
                                      &bDaclPresent,    // address of flag for presence of disc. ACL
                                      &m_pDacl,           // address of pointer to ACL  
                                      &bDefaulted       // address of flag for default disc. ACL
                                      ) 
          ) {
            assert( FALSE );
            hr = E_INVALIDARG;
            goto cleanup;

        }

        // get the sacl
        if( !GetSecurityDescriptorSacl(
                                      psdOriginal,      // address of security descriptor  
                                      &bSaclPresent,    // address of flag for presence of disc. ACL
                                      &m_pSacl,           // address of pointer to ACL  
                                      &bDefaulted       // address of flag for default disc. ACL
                                      )
          ) {
            assert( FALSE );
            hr = E_INVALIDARG;
            goto cleanup;

        }

        // get the owner
        if( !GetSecurityDescriptorOwner(
                                       psdOriginal,    // address of security descriptor
                                       &m_pDescOwner,        // address of pointer to owner security 
                                       // identifier (SID)
                                       &bDefaulted     // address of flag for default
                                       )
          ) {
            assert( FALSE );
            hr = E_INVALIDARG;
            goto cleanup;
        }

        // get the group
        if( !GetSecurityDescriptorGroup(
                                       psdOriginal,    // address of security descriptor
                                       &m_pPrimaryGroup, // address of pointer to owner security 
                                       // identifier (SID)
                                       &bDefaulted     // address of flag for default
                                       )
          ) {
            assert( FALSE );
            hr = E_INVALIDARG;
            goto cleanup;
        }

        // get required buffer size
        cb = 0;
        MakeAbsoluteSD(
                      psdOriginal,              // address of self-relative SD
                      psdAbsoluteCopy,          // address of absolute SD
                      &cb,                      // address of size of absolute SD
                      NULL,                     // address of discretionary ACL
                      &dwDaclSize,              // address of size of discretionary ACL
                      NULL,                     // address of system ACL
                      &dwSaclSize,              // address of size of system ACL
                      NULL,                     // address of owner SID
                      &dwOwnerSize,             // address of size of owner SID
                      NULL,                     // address of primary-group SID
                      &dwPrimaryGroupSize       // address of size of group SID
                      );

        // alloc the memory
        psdAbsoluteCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        m_pDacl = (PACL) ::LocalAlloc( LMEM_ZEROINIT, dwDaclSize );        
        m_pSacl = (PACL) ::LocalAlloc( LMEM_ZEROINIT, dwSaclSize );
        m_pDescOwner = (PSID) ::LocalAlloc( LMEM_ZEROINIT, dwOwnerSize );
        m_pPrimaryGroup = (PSID) ::LocalAlloc( LMEM_ZEROINIT, dwPrimaryGroupSize );

        if(NULL == psdAbsoluteCopy || 
           NULL == m_pDacl ||
           NULL == m_pSacl ||
           NULL == m_pDescOwner ||
           NULL == m_pPrimaryGroup
          ) {
            assert( FALSE );
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        // make the copy
        if( !MakeAbsoluteSD(
                           psdOriginal,            // address of self-relative SD
                           psdAbsoluteCopy,        // address of absolute SD
                           &cb,                    // address of size of absolute SD
                           m_pDacl,                  // address of discretionary ACL
                           &dwDaclSize,            // address of size of discretionary ACL
                           m_pSacl,                  // address of system ACL
                           &dwSaclSize,            // address of size of system ACL
                           m_pDescOwner,                 // address of owner SID
                           &dwOwnerSize,           // address of size of owner SID
                           m_pPrimaryGroup,          // address of primary-group SID
                           &dwPrimaryGroupSize     // address of size of group SID
                           ) 
          ) {
            assert( FALSE );
            hr = E_UNEXPECTED;
            goto cleanup;
        }
    } else {
        // the original is in absolute format, fail
        *ppsdNew = NULL;
        hr = E_INVALIDARG;
        goto cleanup;
    }

    *ppsdNew = psdAbsoluteCopy;

    // paranoia check
    if( !IsValidSecurityDescriptor( *ppsdNew ) ) {
        assert( FALSE );
        hr = E_UNEXPECTED;
        goto cleanup;
    }
    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        assert( FALSE );
        hr = E_UNEXPECTED;
        goto cleanup;
    }

    return hr;

    cleanup:
    if( m_pDacl != NULL && bDaclPresent == TRUE ) {
        ::LocalFree((PVOID) m_pDacl );
        m_pDacl = NULL;
    }
    if( m_pSacl != NULL && bSaclPresent == TRUE ) {
        ::LocalFree((PVOID) m_pSacl );
        m_pSacl = NULL;
    }
    if( m_pDescOwner != NULL ) {
        ::LocalFree((PVOID) m_pOwner );
        m_pDescOwner = NULL;
    }
    if( m_pPrimaryGroup != NULL ) {
        ::LocalFree((PVOID) m_pPrimaryGroup );
        m_pPrimaryGroup = NULL;
    }
    if( psdAbsoluteCopy != NULL ) {
        ::LocalFree((PVOID) psdAbsoluteCopy );
        psdAbsoluteCopy = NULL;
    }

    return hr;
}

// cleanup function only called by destructor.
HRESULT CFaxSecurityInformation::DestroyAbsoluteDescriptor()
{
    DebugPrint(( TEXT("         * Trace: CFaxSecurityInformation::DestroyAbsoluteDescriptor") ));

    SECURITY_DESCRIPTOR_CONTROL         sdc = 0;
   
    DWORD                               dwRevision = 0;
    DWORD                               cb = 0;

    HRESULT                             hr = S_OK;

    if( m_pAbsoluteDescriptor == NULL ) {
        assert( FALSE );
        return E_POINTER;
    }

    if( !IsValidSecurityDescriptor( m_pAbsoluteDescriptor ) ) {
// BUGBUG this assertion always fails for some reason unknown if
// you hit apply then ok on the property sheet. something is wrong.
//
// for some reason, this bug does not manifest on Alpha?!
//
        assert( FALSE );
        return E_INVALIDARG;
    }

    if( !::GetSecurityDescriptorControl( m_pAbsoluteDescriptor, &sdc, &dwRevision ) ) {
        assert( FALSE );
        DWORD err = ::GetLastError();
        hr = HRESULT_FROM_WIN32( err );
        goto cleanup;
    }

    if( !(sdc & SE_SELF_RELATIVE) ) {

        if( m_pDacl != NULL ) {
            ::LocalFree((PVOID) m_pDacl );
            m_pDacl = NULL;
        }
        if( m_pSacl != NULL ) {
            ::LocalFree((PVOID) m_pSacl );
            m_pSacl = NULL;
        }
        if( m_pDescOwner != NULL ) {
            ::LocalFree((PVOID) m_pDescOwner );
            m_pDescOwner = NULL;
        }
        if( m_pPrimaryGroup != NULL ) {
            ::LocalFree((PVOID) m_pPrimaryGroup );
            m_pPrimaryGroup = NULL;
        }
        if( m_pAbsoluteDescriptor != NULL ) {
            ::LocalFree((PVOID) m_pAbsoluteDescriptor );
            m_pAbsoluteDescriptor = NULL;
        }
    } else {
        // not in absolute!!
        assert( FALSE );
        return E_INVALIDARG;
    }

    return hr;

    cleanup:
    assert( FALSE );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxshelp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxhelp.h

Abstract:

    This header prototypes my implementation of ISnapinHelp.

Environment:

    WIN32 User Mode

Author:

    Andrew Ritz (andrewr) 30-Sept-1997

--*/

#ifndef __FAX_SNAP_HELP_H_
#define __FAX_SNAP_HELP_H_

#include "resource.h"

class CFaxSnapin; // forward decl

class CFaxSnapinHelp : public ISnapinHelp 
{
public:
    // constructor

    CFaxSnapinHelp()
    {    
        m_pFaxSnapin = NULL;
    }

    virtual HRESULT STDMETHODCALLTYPE GetHelpTopic( LPOLESTR* lpCompiledHelpFile);

protected:
    CFaxSnapin *        m_pFaxSnapin;

};
      
class CFaxSnapinTopic : public IDisplayHelp 
{
public:
    // constructor

    CFaxSnapinTopic()
    {    
        m_pFaxSnapin = NULL;
    }

    virtual HRESULT STDMETHODCALLTYPE ShowTopic( LPOLESTR pszHelpTopic);

protected:
    CFaxSnapin *        m_pFaxSnapin;

};
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxsnapin.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsnapin.cpp

Abstract:

    This file currently contains nothing, but assorted junk
    may be put here.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// FaxSnapin.cpp : Implementation of CFaxSnapin
#include "stdafx.h"
#include "faxadmin.h"
#include "FaxSnapin.h"
#include "faxstrt.h"          // string table

#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
// CFaxSnapin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxsecinfo.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxsecinfo.h

Abstract:

    This header is the ISecurityInformation implmentation used to instantiate a
    security page.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/


// FaxSnapin.h : Declaration of the CFaxSnapinAbout

#ifndef __FAX_SECURITY_INFO_H_
#define __FAX_SECURITY_INFO_H_

#include "resource.h"           // main symbols
#include "faxadmin.h"

#include <aclui.h>              // ACL UI editor

class CInternalNode; // forward decl
class CFaxComponentData;

class ATL_NO_VTABLE CFaxSecurityInformation : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxSecurityInformation, &CLSID_FaxSecurityInformation>,
    public ISecurityInformation {
public:
    CFaxSecurityInformation::CFaxSecurityInformation();
    CFaxSecurityInformation::~CFaxSecurityInformation();

    DECLARE_NOT_AGGREGATABLE(CFaxSecurityInformation)
    DECLARE_REGISTRY_RESOURCEID(IDR_FAXSNAPIN)

    BEGIN_COM_MAP(CFaxSecurityInformation)
    COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

    public:    
    // *** ISecurityInformation methods ***
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetObjectInformation(
                                                                             OUT PSI_OBJECT_INFO pObjectInfo );

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSecurity(
                                                                    IN SECURITY_INFORMATION RequestedInformation,
                                                                    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                                                                    IN BOOL fDefault );

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSecurity(
                                                                    IN SECURITY_INFORMATION SecurityInformation,
                                                                    IN PSECURITY_DESCRIPTOR pSecurityDescriptor );

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAccessRights(
                                                                        IN const GUID* pguidObjectType,
                                                                        IN DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                                                        OUT PSI_ACCESS *ppAccess,
                                                                        OUT ULONG *pcAccesses,
                                                                        OUT ULONG *piDefaultAccess );

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapGeneric(
                                                                   IN const GUID *pguidObjectType,
                                                                   IN UCHAR *pAceFlags,
                                                                   IN OUT ACCESS_MASK *pMask); /* ?? */

    // no need to impl these

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInheritTypes(
                                                                        OUT PSI_INHERIT_TYPE *ppInheritTypes,
                                                                        OUT ULONG *pcInheritTypes );

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PropertySheetPageCallback(
                                                                                  IN HWND hwnd, 
                                                                                  IN UINT uMsg, 
                                                                                  IN SI_PAGE_TYPE uPage ); /* ?? */

    // internal methods
    HRESULT SetOwner( CInternalNode * toSet);

    HRESULT SetSecurityDescriptor( DWORD FaxDescriptorId );

    HRESULT MakeSelfRelativeCopy(
                                PSECURITY_DESCRIPTOR  psdOriginal,
                                PSECURITY_DESCRIPTOR* ppsdNew 
                                );

    HRESULT MakeAbsoluteCopyFromRelative(
                                        PSECURITY_DESCRIPTOR  psdOriginal,
                                        PSECURITY_DESCRIPTOR* ppsdNew 
                                        );


    HRESULT DestroyAbsoluteDescriptor();


public:

    CInternalNode *         m_pOwner;                   // my owning node
    CFaxComponentData *     m_pCompData;                // owning IComponentData
    PSECURITY_DESCRIPTOR    m_pDescriptor;              // my security descriptor
    PSECURITY_DESCRIPTOR    m_pAbsoluteDescriptor;      // absolute format descriptor
    DWORD                   m_dwDescID;                 // descriptor ID    

    // used to track components of the absolute descriptor
    PACL                                m_pDacl;
    PACL                                m_pSacl;
    PSID                                m_pDescOwner;
    PSID                                m_pPrimaryGroup;

};

#endif //__FAX_SECURITY_INFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxsnapin.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsnapin.h

Abstract:

    This header is the root ATL class for the fax snapin, 
    and contains misc junk. This was originally generated by
    VC++. It inherits it's implementation of IComponentData from
    faxcompd.h.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

// FaxSnapin.h : Declaration of the CFaxSnapin

#ifndef __FAXSNAPIN_H_
#define __FAXSNAPIN_H_

#include "resource.h"           // main symbols
#include "faxadmin.h"

#include "faxcomp.h"            // IComponent
#include "faxcompd.h"           // IComponentData
#include "faxpersist.h"         // IPersistStream
#include "faxproppg.h"          // IExtendPropertyPage
#include "faxconmenu.h"         // IExtendContextMenu
#include "faxconbar.h"
#include "faxdataobj.h"         // IDataObject
#include "faxshelp.h"           // ISnapinHelp

/////////////////////////////////////////////////////////////////////////////
// CFaxSnapin
class ATL_NO_VTABLE CFaxSnapin : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxSnapin, &CLSID_FaxSnapin>,
    public IFaxSnapin,
    public CFaxComponentData,
    public CFaxPersistStream,
    public CFaxExtendPropertySheet,
    public CFaxExtendContextMenu,
    public CFaxExtendControlbar,
    public CFaxSnapinHelp,
    public CFaxSnapinTopic
{
public:
    CFaxSnapin()
    {
        DebugPrint(( TEXT("FaxSnapin Created") ));
        CFaxExtendContextMenu::m_pFaxSnapin = this;  
        CFaxExtendPropertySheet::m_pFaxSnapin = this;  
        CFaxPersistStream::m_pFaxSnapin = this;  
        CFaxExtendControlbar::m_pFaxSnapin = this;
        CFaxSnapinHelp::m_pFaxSnapin = this;
        CFaxSnapinTopic::m_pFaxSnapin = this;
    }
    ~CFaxSnapin()
    {
        DebugPrint(( TEXT("FaxSnapin Destroyed") ));
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_FAXSNAPIN)
    DECLARE_NOT_AGGREGATABLE(CFaxSnapin)

    BEGIN_COM_MAP(CFaxSnapin)
        COM_INTERFACE_ENTRY(IFaxSnapin)  
        COM_INTERFACE_ENTRY(IComponentData)  
        COM_INTERFACE_ENTRY(IPersistStream)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendControlbar)
        COM_INTERFACE_ENTRY(ISnapinHelp)
        COM_INTERFACE_ENTRY(IDisplayHelp)
    END_COM_MAP()

    // IFaxSnapin
    public:        
};

#endif //__FAXSNAPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxstrt.h ===
#ifndef __FAXSTRINGTABLE_H_ 
#define __FAXSTRINGTABLE_H_ 

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxstrt.h

Abstract:

    This file implements string table functions.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997
    Snagged and Modified from:                                  
      Wesley Witt (wesw) 17-Feb-1996

--*/

#include "resource.h"

// string table struct

typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    LPTSTR  String;
} STRING_TABLE;

typedef STRING_TABLE* PSTRING_TABLE;

// The CStringTable Class encapsulates the concept of string resources.
// The Constructor will automatically find and load all the defined string resources for the program.

class CStringTable 
{
    // this is the string table composed of resource ID string pairs stored in _STRING_TABLE structs   
    // don't forget to define the string resource IDs in resource.h.
    // the actual strings go in the .res file.

    static STRING_TABLE StringTable [];

public:
    // constructor
    CStringTable( HMODULE thisModule );

    // destructor - clean up nicely
    ~CStringTable();

    // ***************************************
    // Gets a const string pointer given a resource ID.
    const LPTSTR GetString( DWORD ResourceId );

    // **************************************
    // Does a quick popup given a resource ID
    int PopUpMsg( HWND hwnd, DWORD ResourceId, BOOL Error, DWORD Type );

    // **************************************
    // Does a quick popup given a resource ID, and some formatting flags
    int PopUpMsgFmt( HWND hwnd, DWORD ResourceId, BOOL Error, DWORD Type, ... );

    // **************************************
    // Does a quick popup with the system error code
    VOID CStringTable::SystemErrorMsg(DWORD ErrorCode);

    // **************************************
    // Returns the instance
    HMODULE   GetInstance();
    
private:
    HINSTANCE       gInstance;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\faxstrt.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxstrt.cpp

Abstract:

    This file implements string table functions.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997
    Snagged and Modified from:                                  
      Wesley Witt (wesw) 17-Feb-1996

--*/

#include "stdafx.h"
#include "resource.h"
#include "faxstrt.h"

#include "strings.h"

#pragma hdrstop

//===========================//===========================//===========================//===========================
//===========================//===========================//===========================//===========================

#define CountStringTable ( sizeof(StringTable) / sizeof(STRING_TABLE) )

extern CComModule _Module;

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CStringTable::CStringTable( 
                            HMODULE thisModule )
/*++

Routine Description:

    Constructor

Arguments:

    thisModule - instance handle

Return Value:

    None.    

--*/
{
    DWORD            i;
    TCHAR            Buffer[256];       

    assert( thisModule != NULL );

    gInstance = thisModule;

    for( i=0; i<CountStringTable; i++ ) {
        if( StringTable[i].ResourceId != 0xFFFF ) {
            if( LoadString( thisModule, StringTable[i].ResourceId, Buffer, sizeof(Buffer)/sizeof(TCHAR)) != NULL ) {
                // if we find the string, allocate an array for the string
                // StringSize is a macro found in faxutil.h
                StringTable[i].String = new TCHAR[ StringSize(Buffer) ];
    
                if( StringTable[i].String == NULL ) {
                    // if we can't alloc the memory, just put empty into the table.
                    StringTable[i].String = TEXT("");
                } else {
                    // otherwise copy it into the table
                    _tcscpy( StringTable[i].String, Buffer );
                }
            } else {
                // if we don't find the string, put empty into the table
                StringTable[i].String = TEXT("");
            }
        }
    }        
    DebugPrint(( TEXT( "CStringTable Created" ) ));
}

CStringTable::~CStringTable() 
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.    

--*/
{
    DWORD  i;

    for( i=0; i<CountStringTable; i++ ) {
        if( StringTable[i].String != NULL ) {
            delete StringTable[i].String;
        }
    }
    DebugPrint(( TEXT( "CStringTable Destroyed" ) ));
}

const LPTSTR 
CStringTable::GetString( 
                         IN DWORD ResourceId )
/*++

Routine Description:

    Gets a const string pointer given a resource ID.

Arguments:

    pParent - pointer to parent node, in this case unused
    pCompData - pointer to IComponentData implementation for snapin global data

Return Value:

    a const LPTSTR pointing to the string requested. Do not free this string.

--*/
{
    DWORD i;

    for(i=0; i<CountStringTable; i++) {
        if(StringTable[i].ResourceId == ResourceId) {
            return StringTable[i].String;
        }
    }

    // oh oh we didn't find the string!!
    assert( 0 );
    return NULL;
}

int 
CStringTable::PopUpMsg( 
                        IN HWND hwnd, 
                        IN DWORD ResourceId, 
                        IN BOOL Error, 
                        IN DWORD Type )
/*++

Routine Description:

    Does a quick popup given a resource ID

Arguments:

    hwnd - the parent of the message box
    resourceId - the id of the string resource you want in the dialog
    error - make this an error or warning
    type - flags to affect the appearance of the message box    

Return Value:

    look up MessageBox in the API.

--*/
{
    return MessageBox(
                     hwnd,
                     GetString( ResourceId ),
                     GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
                     MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
                     );
}

// **************************************

int 
CStringTable::PopUpMsgFmt( 
                           IN HWND hwnd, 
                           IN DWORD ResourceId, 
                           IN BOOL Error, 
                           IN DWORD Type, 
                           ... )
/*++

Routine Description:

    Does a quick popup given a resource ID, and some formatting flags

Arguments:

    hwnd - the parent of the message box
    resourceId - the id of the string resource you want in the dialog
    error - make this an error or warning
    type - flags to affect the appearance of the message box    
    ... - strings to sub into the resource string.

Return Value:

    look up MessageBox in the API.

--*/
{
    TCHAR         buf[1024];
    va_list       arg_ptr;

    va_start(arg_ptr, Type);
    _vsntprintf( buf, sizeof(buf), GetString( ResourceId ), arg_ptr );

    return MessageBox(
                     hwnd,
                     buf,
                     GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
                     MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
                     );
}

VOID
CStringTable::SystemErrorMsg(
                             DWORD ErrorCode)
/*++

Routine Description:

    Does a quick popup with the system error code

Arguments:

    ErrorCode - the error code returned from GetLastError.

Return Value:

    None.

--*/
{
    LPTSTR lpMsgBuf;
    
    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        ErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL
        );

    MessageBox( NULL, 
                lpMsgBuf, 
                GetString( IDS_ERR_TITLE ),
                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK );

    LocalFree( lpMsgBuf );
}

HMODULE   
CStringTable::GetInstance() 
/*++

Routine Description:

    Returns the instance.

Arguments:

    None.

Return Value:

    The instance handle.

--*/
{
        return gInstance;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\idevice.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ilogcat.h

Abstract:

    Internal implementation for a logging category item.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#ifndef __IDEVICE_H_
#define __IDEVICE_H_

#include "winfax.h"

#define CSID_LIMIT      20
#define TSID_LIMIT      20
#define MIN_RING_COUNT  1
#define MAX_RING_COUNT  99

class CFaxDeviceSettingsPropSheet; // forward decl
class CFaxRoutePriPropSheet; // forward decl

class CInternalDevice : public CInternalNode
{

public:
    CInternalDevice( CInternalNode * pParent, 
                                      CFaxComponentData * pCompData,
                                      HANDLE faxHandle,
                                      DWORD devID );
    ~CInternalDevice();
    
    // IComponent over-rides
    HRESULT STDMETHODCALLTYPE ResultGetDisplayInfo(
                              /* [in] */ CFaxComponent * pComp,  
                              /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);

    // IExtendContextMenu overrides for IComponent

    virtual HRESULT STDMETHODCALLTYPE ComponentContextMenuAddMenuItems(
                                                             /* [in] */ CFaxComponent * pCompData,
                                                             /* [in] */ CFaxDataObject * piDataObject,
                                                             /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                                             /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

    virtual HRESULT STDMETHODCALLTYPE ComponentContextMenuCommand(
                                                        /* [in] */ CFaxComponent * pCompData,
                                                        /* [in] */ long lCommandID,
                                                        /* [in] */ CFaxDataObject * piDataObject);

    // IExtendPropertySheet overrides for IComponent
    virtual HRESULT STDMETHODCALLTYPE ComponentPropertySheetCreatePropertyPages(
                                                                      /* [in] */ CFaxComponent * pComp,
                                                                      /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                                      /* [in] */ LONG_PTR handle,
                                                                      /* [in] */ CFaxDataObject * lpIDataObject);

    virtual HRESULT STDMETHODCALLTYPE ComponentPropertySheetQueryPagesFor(
                                                                /* [in] */ CFaxComponent * pComp,
                                                                /* [in] */ CFaxDataObject * lpDataObject);

    // IDataObject overrides
    virtual HRESULT DataObjectRegisterFormats();
    virtual HRESULT DataObjectGetDataHere( FORMATETC __RPC_FAR *pFormatEtc, IStream * pstm );

    // event handlers
    virtual HRESULT         ResultOnSelect(CFaxComponent* pComp, 
                                           CFaxDataObject * lpDataObject, 
                                           LPARAM arg, LPARAM param);

    virtual HRESULT         ResultOnPropertyChange(CFaxComponent* pComp, 
                                                CFaxDataObject * lpDataObject, 
                                                LPARAM arg, LPARAM param);

    virtual HRESULT         ControlBarOnBtnClick(CFaxComponent* pComp, 
                                                 CFaxDataObject * lpDataObject, 
                                                 LPARAM param );    
    
    virtual HRESULT         ControlBarOnSelect(CFaxComponent* pComp, 
                                               LPARAM arg, 
                                               CFaxDataObject * lpDataObject );

    // member functions

    virtual const GUID * GetNodeGUID();    
    virtual const LPTSTR GetNodeDisplayName();
    virtual const LONG_PTR GetCookie();
    virtual CInternalNode * GetThis() { return this; }
    virtual const int       GetNodeDisplayImage() { return IDI_FAXING; }
    
    void    SetItemID( HRESULTITEM hItem ) { hItemID = hItem; }    
    LPTSTR  GetStatusString( DWORD state );

    // these functions get and commit the state this device to the fax server
    HRESULT RetrieveNewInfo();
    HRESULT CommitNewInfo();

public:
    
    DWORD                       dwDeviceId;
    HANDLE                      hFaxServer;
    PFAX_PORT_INFO              pDeviceInfo;
    
    HRESULTITEM                 hItemID;

    // clipboard formats
    static UINT                 s_cfFaxDevice;
    static UINT                 s_cfFaxServerDown;

    CFaxDeviceSettingsPropSheet *pMyPropSheet;
    MMC_CONSOLE_VERB            defaultVerb;
    LPTOOLBAR                   myToolBar;

    static CRITICAL_SECTION     csDeviceLock;
};

typedef CInternalDevice* pCInternalDevice;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\idevice.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ilogcat.cpp

Abstract:

    Internal implementation for a logging category item.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#include "StdAfx.h"

#include "inode.h"          // base class
#include "iroot.h"          // root item
#include "idevice.h"        // device item

#include "idevices.h"       // devices folder
#include "faxcompd.h"       // CFaxComponentData
#include "faxcomp.h"        // CFaxComponent
#include "faxdataobj.h"     // dataobject
#include "faxstrt.h"        // string table

#include "ddevmain.h"       // device settings
#include "droutpri.h"       // route extension priority

#include "faxreg.h"

#pragma hdrstop

extern CStringTable * GlobalStringTable;

CRITICAL_SECTION     CInternalDevice::csDeviceLock = {0};

// defines for context menu command ids
#define SEND_CONTEXT_ITEM       11
#define RECV_CONTEXT_ITEM       12

// defines for toolbar button command ids
#define CMD_PRI_UP      123
#define CMD_PRI_DOWN    124

// Generated with uuidgen. Each node must have a GUID associated with it.
// This one is for the main root node.
const GUID GUID_DeviceNode = /* de58ae00-4c0f-11d1-9083-00a0c90ab504 */
{
    0xde58ae00,
    0x4c0f,
    0x11d1,
    {0x90, 0x83, 0x00, 0xa0, 0xc9, 0x0a, 0xb5, 0x04}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CInternalDevice::CInternalDevice(
                                IN CInternalNode * pParent, 
                                IN CFaxComponentData * pCompData,
                                IN HANDLE faxHandle,
                                IN DWORD devID ) 
: CInternalNode( pParent, pCompData ),
  dwDeviceId( devID ),
  hFaxServer( faxHandle ),
  pDeviceInfo( NULL ),
  myToolBar( NULL )
/*++

Routine Description:

    Constructor

Arguments:

    pParent - pointer to parent node, in this case unused
    pCompData - pointer to IComponentData implementation for snapin global data

Return Value:

    None.    

--*/
{       
    RetrieveNewInfo();    

    DebugPrint(( TEXT("CInternalDevice Created") ));
}

CInternalDevice::~CInternalDevice() 
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.    

--*/
{
    if( myToolBar != NULL ) {
        myToolBar->Release();
        myToolBar = NULL ;
    }
    DebugPrint(( TEXT("CInternalDevice Destroyed") ));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Custom Clipboard Format handlers.
//
//

// clipboard format
UINT         CInternalDevice::s_cfFaxDevice = 0;
UINT         CInternalDevice::s_cfFaxServerDown = 0;
#define CCF_FAX_DEVICE L"CF_FAX_DEVICE"
#define CCF_FAX_SERVER_DOWN L"CF_FAX_SERVER_DOWN"

// clipboard methods
HRESULT 
CInternalDevice::DataObjectRegisterFormats()
/*++

Routine Description:

    Registers the custom clipboard formats for the device node.

Arguments:

    None.

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    s_cfFaxDevice = RegisterClipboardFormat(CCF_FAX_DEVICE);
    s_cfFaxServerDown = RegisterClipboardFormat(CCF_FAX_SERVER_DOWN);
    return S_OK;
}

HRESULT 
CInternalDevice::DataObjectGetDataHere(
                                      IN FORMATETC __RPC_FAR *pFormatEtc, 
                                      IN IStream * pstm )
/*++

Routine Description:

    Handles GetDataHere for custom clipboard formats specific to this
    particular node.

    The default implementation asserts since there should be no unhandled 
    formats.
    
Arguments:

    pFormatEtc - the FORMATETC struction indicating where and what the
                 client is requesting
    pstm - the stream to write the data to.
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    const       CLIPFORMAT cf = pFormatEtc->cfFormat;
    HANDLE      faxHandle = ((CInternalDevices *)m_pParentINode)->faxHandle;
    HRESULT     hr = S_OK;
    LPTSTR      tstr;
    BOOL        temp;

    assert( faxHandle != NULL );
    assert( pDeviceInfo != NULL );

    if( cf == s_cfFaxDevice ) {
        // handle the device clipboard format
        pstm->Write( &(faxHandle), sizeof(HANDLE), NULL );
        pstm->Write( &(pDeviceInfo->DeviceId), sizeof(DWORD), NULL );
        tstr = m_pCompData->globalRoot->GetMachine();
        if( tstr != NULL ) {
            pstm->Write( tstr, (MAX_COMPUTERNAME_LENGTH+1) * sizeof( TCHAR ), NULL );
        } else {
            pstm->Write( &tstr, sizeof( NULL ), NULL );
        }
    } else if( cf == s_cfFaxServerDown ) {
        // handle the query server down format
        temp = m_pCompData->QueryRpcError();
        pstm->Write( &temp, sizeof( BOOL ), NULL );
    } else {
        hr = DV_E_FORMATETC;
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Mandatory CInternalNode implementations.
//
//

const GUID * 
CInternalDevice::GetNodeGUID()
/*++

Routine Description:

    Returns the node's associated GUID.

Arguments:

    None.

Return Value:

    A const pointer to a binary GUID.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalDevice::GetNodeGUID") ));
    return &GUID_DeviceNode;
}

const LPTSTR 
CInternalDevice::GetNodeDisplayName()
/*++

Routine Description:

    Returns a const TSTR pointer to the node's display name.

Arguments:

    None.

Return Value:

    A const pointer to a TSTR.

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalDevice::GetNodeDisplayName") ));
    return (LPTSTR)pDeviceInfo->DeviceName;
}

const LONG_PTR   
CInternalDevice::GetCookie()
/*++

Routine Description:

    Returns the cookie for this node.

Arguments:

    None.

Return Value:

    A const long containing the cookie for the pointer,
    in this case, (long)this.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalDevice::GetCookie") ));
    DebugPrint(( TEXT("Device Node Cookie: 0x%p"), this ));
    return (LONG_PTR)this; // device node's cookie is the this pointer.
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// 
// IComponent over-rides
//
//

HRESULT STDMETHODCALLTYPE CInternalDevice::ResultGetDisplayInfo(
                                                               IN CFaxComponent * pComp,  
                                                               IN OUT RESULTDATAITEM __RPC_FAR *pResultDataItem)
/*++

Routine Description:

    This routine dispatches result pane GetDisplayInfo requests to the appropriate handlers
    in the mandatory implementations of the node, as well as handling special case data requests.
            
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    pResultDataItem - a pointer to the RESULTDATAITEM struct which needs to be filled in.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalDevice::ResultGetDisplayInfo") ));

    TCHAR       buffer[ 20 ];
    HRESULT     hr = S_OK;

    ZeroMemory( (PVOID)buffer, 20 * sizeof( TCHAR ) );

    assert(pResultDataItem != NULL);    

    do {
        if( m_pCompData->QueryRpcError() == TRUE ) {
            // notify the parent of the failure
            ((CInternalDevices *)m_pParentINode)->NotifyFailure( pComp );
            hr = E_UNEXPECTED;
            break;    
        }

        if( pResultDataItem->mask & RDI_STR ) {
            if( pResultDataItem->nCol == 0 ) {
                hr = RetrieveNewInfo();
                if( FAILED( hr ) ) {
                    assert( FALSE );
                    break;
                }
                pResultDataItem->str = GetNodeDisplayName();
            }
            if( pResultDataItem->nCol == 1 ) {
                if( pDeviceInfo->Flags & FPF_SEND ) {
                    pResultDataItem->str = ::GlobalStringTable->GetString( IDS_YES );
                } else {
                    pResultDataItem->str = ::GlobalStringTable->GetString( IDS_NO );
                }            
            }
            if( pResultDataItem->nCol == 2 ) {
                if( pDeviceInfo->Flags & FPF_RECEIVE ) {
                    pResultDataItem->str = ::GlobalStringTable->GetString( IDS_YES );
                } else {
                    pResultDataItem->str = ::GlobalStringTable->GetString( IDS_NO );
                }            
            }
            if( pResultDataItem->nCol == 3 ) {
                pResultDataItem->str = (LPTSTR)pDeviceInfo->Tsid;
            }
            if( pResultDataItem->nCol == 4 ) {
                pResultDataItem->str = (LPTSTR)pDeviceInfo->Csid;
            }
            if( pResultDataItem->nCol == 5 ) {
                pResultDataItem->str = GetStatusString( pDeviceInfo->State );
            }
            if( pResultDataItem->nCol == 6 ) {
                pResultDataItem->str = _itot( pDeviceInfo->Priority, buffer, 10 );
            }
            if( pResultDataItem->mask & RDI_IMAGE ) {
                pResultDataItem->nImage = GetNodeDisplayImage();
            }
        }
    } while( 0 );
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IExtendContextMenu event handlers
//
//

HRESULT 
STDMETHODCALLTYPE 
CInternalDevice::ComponentContextMenuAddMenuItems(
                                                 IN CFaxComponent * pComp,
                                                 IN CFaxDataObject * piDataObject,
                                                 IN LPCONTEXTMENUCALLBACK piCallback,
                                                 IN OUT long __RPC_FAR *pInsertionAllowed)
/*++

Routine Description:

    Adds items to the context menu.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    piDataObject - pointer to the dataobject associated with this node
    piCallback - a pointer to the IContextMenuCallback used to insert pages
    pInsertionAllowed - a set of flag indicating whether insertion is allowed.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::ComponentContextMenuAddMenuItems") ));

    CONTEXTMENUITEM menuItem;    
    HRESULT         hr = S_OK;

    if( !( *pInsertionAllowed | CCM_INSERTIONALLOWED_TOP ) ) {
        assert( FALSE );
        return S_OK;
    }

    // build the submenu items

    ZeroMemory( ( void* )&menuItem, sizeof( menuItem ) );

    menuItem.strName = ::GlobalStringTable->GetString( IDS_DEVICE_SEND_EN );
    menuItem.strStatusBarText = ::GlobalStringTable->GetString( IDS_DEVICE_SEND_EN_DESC );
    menuItem.lCommandID = SEND_CONTEXT_ITEM;
    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
    if( pDeviceInfo->Flags & FPF_SEND ) {
        menuItem.fFlags = MF_ENABLED | MF_CHECKED;
    } else {
        menuItem.fFlags = MF_ENABLED;
    }
    menuItem.fSpecialFlags = 0;

    hr = piCallback->AddItem( &menuItem );
    if( FAILED(hr) ) {
        assert(FALSE);
        return hr;
    }


    ZeroMemory( ( void* )&menuItem, sizeof( menuItem ) );

    menuItem.strName = ::GlobalStringTable->GetString( IDS_DEVICE_RECV_EN );
    menuItem.strStatusBarText = ::GlobalStringTable->GetString( IDS_DEVICE_RECV_EN_DESC );
    menuItem.lCommandID = RECV_CONTEXT_ITEM;
    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
    if( pDeviceInfo->Flags & FPF_RECEIVE ) {
        menuItem.fFlags = MF_ENABLED | MF_CHECKED;
    } else {
        menuItem.fFlags = MF_ENABLED;
    }
    menuItem.fSpecialFlags = 0;

    hr = piCallback->AddItem( &menuItem );
    if( FAILED(hr) ) {
        assert(FALSE);
        return hr;
    }

    return hr;
}


HRESULT 
STDMETHODCALLTYPE 
CInternalDevice::ComponentContextMenuCommand(
                                            IN CFaxComponent * pComp,
                                            IN long lCommandID,
                                            IN CFaxDataObject * piDataObject)
/*++

Routine Description:

    Context menu event handler.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lCommandID - the command ID
    piDataObject - pointer to the dataobject associated with this node
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::ComponentContextMenuCommand") ));

    HRESULT                 hr = S_OK;

    assert( hFaxServer != NULL );

    do {

        // retrieve data
        hr = RetrieveNewInfo();
        if( FAILED( hr ) ) {
            assert( FALSE );
            break;
        }

        switch( lCommandID ) {
            case SEND_CONTEXT_ITEM:
                if( pDeviceInfo->Flags & FPF_SEND ) {
                    pDeviceInfo->Flags = pDeviceInfo->Flags & (~FPF_SEND);
                } else {
                    pDeviceInfo->Flags = pDeviceInfo->Flags | FPF_SEND;
                }
                break;

            case RECV_CONTEXT_ITEM:
                if( pDeviceInfo->Flags & FPF_RECEIVE ) {
                    pDeviceInfo->Flags = pDeviceInfo->Flags & (~FPF_RECEIVE);
                } else {
                    pDeviceInfo->Flags = pDeviceInfo->Flags | FPF_RECEIVE;
                }
                break;

            default:
                assert(FALSE);
                break;

        }

        // commit new settings
        hr = CommitNewInfo();
        if( FAILED( hr ) ) {
            break;
        }

        // fixup the service startup state
        ((CInternalDevices*)m_pParentINode)->CorrectServiceState();

    } while( 0 );

    // notify update
    pComp->m_pResultData->UpdateItem( hItemID );

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IExtendPropertySheet event handlers
//
//

HRESULT 
STDMETHODCALLTYPE 
CInternalDevice::ComponentPropertySheetCreatePropertyPages(
                                                          IN CFaxComponent * pComp,
                                                          IN LPPROPERTYSHEETCALLBACK lpProvider,
                                                          IN LONG_PTR handle,
                                                          IN CFaxDataObject * lpIDataObject)
/*++

Routine Description:

    This routine adds device pages to the property sheet.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lpProvider - a pointer to the IPropertySheetCallback used to insert pages
    handle - a handle to route messages with
    lpIDataobject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::ComponentPropertySheetCreatePropertyPages") ));
    assert( lpIDataObject != NULL );
    assert( lpProvider != NULL );

    HRESULT                             hr;

    if( lpIDataObject == NULL || lpProvider == NULL ) {
        assert(FALSE);
        return E_POINTER;
    }

    pMyPropSheet = new CFaxDeviceSettingsPropSheet( ::GlobalStringTable->GetInstance(), handle, this, pComp );
    if (!pMyPropSheet) {
        return(E_OUTOFMEMORY);
    }
    hr = lpProvider->AddPage( pMyPropSheet->GetHandle() );

    return hr;
}

HRESULT 
STDMETHODCALLTYPE 
CInternalDevice::ComponentPropertySheetQueryPagesFor(
                                                    IN CFaxComponent * pComp,
                                                    IN CFaxDataObject * lpDataObject)
/*++

Routine Description:

    The implementation of this routine returns S_OK to indicate there are
    property pages to be added to the property sheet.

Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lpDataobject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::ComponentPropertySheetQueryPagesFor") ));
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// 
// Internal Event Handlers
//
//

HRESULT 
CInternalDevice::ResultOnSelect(
                               IN CFaxComponent* pComp, 
                               IN CFaxDataObject * lpDataObject, 
                               IN LPARAM arg, 
                               IN LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_SELECT message for the device node.

Arguments:

    pComp - a pointer to the instance of IComponentData which this root node is associated with.
    lpDataObject - a pointer to the data object containing context information for this node.    
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    BOOL bScope = LOWORD( arg );
    BOOL bSelect = HIWORD( arg );

    if( bSelect == TRUE ) {
        DebugPrint(( TEXT("++++++++++++++++++++++++++++ Device SELECT") ));
        pComp->m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );     
        pComp->m_pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );
    } else {
        DebugPrint(( TEXT("---------------------------- Device DESELECT") ));
        // if the toolbar has not already been released
        if( pComp->m_pControlbar != NULL ) {        
            pComp->m_pControlbar->Detach( myToolBar );
        }
    }

    return S_OK;  
}

HRESULT 
CInternalDevice::ResultOnPropertyChange(
                                       IN CFaxComponent* pComp, 
                                       IN CFaxDataObject * lpDataObject, 
                                       IN LPARAM arg, 
                                       IN LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_PROPERTY_CHANGE message for the device node.

Arguments:

    pComp - a pointer to the instance of IComponentData which this root node is associated with.
    lpDataObject - a pointer to the data object containing context information for this node.
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{   
    HRESULT         hr = S_OK;

    do {
        hr = pComp->m_pResultData->UpdateItem( hItemID );
        if( FAILED( hr ) ) {
            break;        
        }
    } while( 0 );
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IExtendControlbar - default implementations
//
//

HRESULT  
CInternalDevice::ControlBarOnBtnClick(
                                     IN CFaxComponent* pComp, 
                                     IN CFaxDataObject * lpDataObject, 
                                     IN LPARAM param )
/*++

Routine Description:

    Handles a click on a toolbar button.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lpDataObject - pointer to the dataobject associated with this node
    param - the parameter for the message
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::ControlBarOnBtnClick") ));
    HRESULT                 hr = S_OK;

    assert( hFaxServer != NULL );

    do {
        hr = RetrieveNewInfo();
        if( FAILED( hr ) ) {
            break;
        }
        switch( param ) {
            case CMD_PRI_UP:
                DebugPrint(( TEXT("     ******************** Increase priority") ));
                if( pDeviceInfo->Priority > 1 ) {
                    pDeviceInfo->Priority--;
                    hr = CommitNewInfo();
                    if( FAILED( hr ) ) {
                        pDeviceInfo->Priority++;
                        break;
                    }
                }
                break;
            case CMD_PRI_DOWN:
                DebugPrint(( TEXT("     ******************** Decrease priority") ));
                if( pDeviceInfo->Priority < 1000 ) {
                    pDeviceInfo->Priority++;
                    hr = CommitNewInfo();
                    if( FAILED( hr ) ) {
                        pDeviceInfo->Priority--;
                        break;
                    }
                }
                break;
        }

        // BUGBUG for some reason, I need to do this twice for the sort to be correctly
        // done!!!! If I only do it one, the MMC sorts in reverse order for some reason?
        //
        // Ultimate kludge! Yuck.
        //
        pComp->m_pResultData->UpdateItem( hItemID );        
        pComp->m_pResultData->Sort( 6, 0, NULL );        
        pComp->m_pResultData->UpdateItem( hItemID );        
        pComp->m_pResultData->Sort( 6, 0, NULL );        

    } while( 0 );

    return hr;
}

HRESULT 
CInternalDevice::ControlBarOnSelect(
                                   IN CFaxComponent* pComp, 
                                   IN LPARAM arg, 
                                   IN CFaxDataObject * lpDataObject )
/*++

Routine Description:

    Adds and removes the toolbar when the node is clicked.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    arg - the parameter for the message
    lpDataObject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("CInternalDevice::ControlBarOnSelect") ));

    BOOL            bScope = (BOOL) LOWORD( arg );
    BOOL            bSelect = (BOOL) HIWORD( arg );    
    LPUNKNOWN       lpUnk;
    HRESULT         hr = S_OK;

    if( pComp == NULL ) {
        assert( FALSE );
        return E_POINTER;
    }

    MMCBUTTON       buttons[] = 
    {
        { 
            0, 
            CMD_PRI_UP, 
            TBSTATE_ENABLED,
            TBSTYLE_BUTTON, 
            ::GlobalStringTable->GetString( IDS_BTN_RAISE_PRI ),
            ::GlobalStringTable->GetString( IDS_BTN_RAISE_PRI_TOOLTIP )
        },

        {
            1, 
            CMD_PRI_DOWN, 
            TBSTATE_ENABLED,
            TBSTYLE_BUTTON, 
            ::GlobalStringTable->GetString( IDS_BTN_LOWER_PRI ),
            ::GlobalStringTable->GetString( IDS_BTN_LOWER_PRI_TOOLTIP )
        }
    };

    if( bSelect == TRUE ) {
        DebugPrint(( TEXT("++++++++++++++++++++++++++++ Device Controlbar SELECT") ));
        // if the controlbar hasn't already been created, create it
        if( myToolBar == NULL ) {
            hr = pComp->m_pControlbar->Create( TOOLBAR, pComp, &lpUnk );
            if( FAILED( hr ) ) {
                assert( FALSE );
                return E_UNEXPECTED;
            }

            hr = lpUnk->QueryInterface( IID_IToolbar, (void **)&myToolBar );
            if( FAILED( hr ) ) {
                assert( FALSE );
                return E_UNEXPECTED;
            }

            lpUnk->Release();

            HBITMAP hbUp = LoadBitmap( ::GlobalStringTable->GetInstance(), 
                                       MAKEINTRESOURCE( IDB_UP ) );
            assert( hbUp != NULL );

            HBITMAP hbDown = LoadBitmap( ::GlobalStringTable->GetInstance(), 
                                         MAKEINTRESOURCE( IDB_DOWN ) );
            assert( hbDown != NULL );

            hr = myToolBar->AddBitmap( 1, hbUp, 16, 16, 0x00ff00ff );
            if( FAILED( hr ) ) {
                assert( FALSE );
                return hr;
            }

            hr = myToolBar->AddBitmap( 1, hbDown, 16, 16, 0x00ff00ff );
            if( FAILED( hr ) ) {
                assert( FALSE );
                return hr;
            }

            hr = myToolBar->AddButtons( 2, buttons );
            if( FAILED( hr ) ) {
                assert( FALSE );
                return hr;
            }
        }
        hr = pComp->m_pControlbar->Attach( TOOLBAR, myToolBar );
    } else {
        DebugPrint(( TEXT("--------------------------- Device Controlbar DESELECT") ));
        // detach the toolbar
        hr = pComp->m_pControlbar->Detach( myToolBar );
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Internal Functions
// 
//

HRESULT 
CInternalDevice::RetrieveNewInfo()
/*++

Routine Description:

    Retrieves new device info.

Arguments:

    None.

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    HANDLE                  portHandle = NULL;    
    HRESULT                 hr = S_OK;

    EnterCriticalSection( &csDeviceLock );

    assert( hFaxServer != NULL );

    try {
        do {
            if( m_pCompData->QueryRpcError() ) {
                hr = E_UNEXPECTED;
                break;
            }

            // open the port
            if( !FaxOpenPort( hFaxServer, dwDeviceId, PORT_OPEN_QUERY, &portHandle ) ) {
                if (GetLastError() != ERROR_ACCESS_DENIED) {
                    m_pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                }
                ::GlobalStringTable->SystemErrorMsg( GetLastError() );
                hr = E_UNEXPECTED;
                break;
            }

            // free the existing buffer
            if( pDeviceInfo != NULL ) {
                FaxFreeBuffer( (PVOID) pDeviceInfo );
                pDeviceInfo = NULL;
            }

            // get data
            if( !FaxGetPort( portHandle, &pDeviceInfo ) ) {
                if (GetLastError() != ERROR_ACCESS_DENIED) {
                    m_pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                }
                ::GlobalStringTable->SystemErrorMsg( GetLastError() );
                hr = E_UNEXPECTED;
                break;
            }
        } while( 0 );
    } catch( ... ) {
        m_pCompData->NotifyRpcError( TRUE );
        assert(FALSE);
        ::GlobalStringTable->SystemErrorMsg( GetLastError() );
        hr = E_UNEXPECTED;
    }

    // close port
    if( portHandle != NULL ) {
        FaxClose( portHandle );        
    }

    LeaveCriticalSection( &csDeviceLock );

    return hr;
}

HRESULT 
CInternalDevice::CommitNewInfo()
/*++

Routine Description:

    Writes out the current device state to the fax service.

Arguments:

    None.

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    HANDLE                  portHandle = NULL;    
    HRESULT                 hr = S_OK;
    DWORD                   ec = ERROR_SUCCESS;

    EnterCriticalSection( &csDeviceLock );

    assert( hFaxServer != NULL );
    try {
        do {
            if( m_pCompData->QueryRpcError() ) {
                hr = E_UNEXPECTED;
                break;
            }

            // open the port
            if( !FaxOpenPort( hFaxServer, dwDeviceId, PORT_OPEN_MODIFY, &portHandle ) ) {
                if (GetLastError() != ERROR_ACCESS_DENIED) {
                    m_pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                }
                ::GlobalStringTable->SystemErrorMsg( GetLastError() );
                hr = E_UNEXPECTED;
                break;
            }

            // set data
            if( !FaxSetPort( portHandle, pDeviceInfo ) ) {
                ec = GetLastError();
                if (ec != ERROR_ACCESS_DENIED && ec != ERROR_DEVICE_IN_USE) {
                    m_pCompData->NotifyRpcError( TRUE );
                    assert(FALSE);
                }
                if (ec == ERROR_DEVICE_IN_USE)
                    ::GlobalStringTable->PopUpMsg( NULL , IDS_DEVICE_INUSE, TRUE, 0 );
                else 
                    ::GlobalStringTable->SystemErrorMsg( ec );
                
                hr = E_UNEXPECTED;
                break;
            }

            FaxClose( portHandle );
            portHandle = NULL;

            // See if faxstat is running
            HWND hWndFaxStat = FindWindow(FAXSTAT_WINCLASS, NULL);
            if (hWndFaxStat) {
                if (SendMessage(hWndFaxStat, WM_FAXSTAT_MMC, (WPARAM) dwDeviceId, 0)) {
                    ::GlobalStringTable->PopUpMsg( NULL, IDS_DEVICE_MANUALANSWER, FALSE, 0 );
                }
            }

        } while( 0 );
    } catch( ... ) {
        m_pCompData->NotifyRpcError( TRUE );
        assert(FALSE);
        ::GlobalStringTable->SystemErrorMsg( GetLastError() );
        hr = E_UNEXPECTED;       
    }

    // close port
    if( portHandle != NULL ) {
        FaxClose( portHandle );        
    }

    LeaveCriticalSection( &csDeviceLock );

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Utility Functions
// 
//

LPTSTR      
CInternalDevice::GetStatusString(
                                DWORD state )
/*++

Routine Description:

    Returns the correct status description given a device state.

Arguments:

    state - the state of the device

Return Value:

    A LPTSTR to a buffer containing the description of the state. Do not free this string.

--*/
{
    int i;
    int j = 1;

    // this will break if the defines ever change!!
    for( i = 1; i <= 25; i++ ) {
        if( j & state ) {
            break;
        }
        j = j << 1; // shift left
    }
    if( i <= 24 && i > 0 ) {
        return ::GlobalStringTable->GetString(  IDS_DEVICE_STATUS + i );   
    } else {
        assert( FALSE );
        return ::GlobalStringTable->GetString(  IDS_DEVICE_STATUS_UNKNOWN );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\ilogcat.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ilogcat.cpp

Abstract:

    Internal implementation for a logging category item.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#include "StdAfx.h"

#include "inode.h"          // base class
#include "ilogcat.h"        // log category item

#include "ilogging.h"       // logging folder
#include "faxcomp.h"        // CFaxComponent
#include "faxdataobj.h"     // dataobject
#include "faxstrt.h"        // string table

#pragma hdrstop

#define PRI_CONTEXT_MENU 10;

extern CStringTable * GlobalStringTable;

// Generated with uuidgen. Each node must have a GUID associated with it.
// This one is for the main root node.
const GUID GUID_LogCatNode = /* 208dd5bc-44e2-11d1-9076-00a0c90ab504 */
{
    0x208dd5bc,
    0x44e2,
    0x11d1,
    {0x90, 0x76, 0x00, 0xa0, 0xc9, 0x0a, 0xb5, 0x04}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor.
//
//


CInternalLogCat::CInternalLogCat( CInternalNode * pParent, CFaxComponentData * pCompData ) :
    CInternalNode( pParent, pCompData )
/*++

Routine Description:

    Constructor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    pCategory = NULL;
}

CInternalLogCat::~CInternalLogCat()
/*++

Routine Description:

    Destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Mandatory CInternalNode implementations.
//
//

const GUID * 
CInternalLogCat::GetNodeGUID()
/*++

Routine Description:

    Returns the node's associated GUID.

Arguments:

    None.

Return Value:

    A const pointer to a binary GUID.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalLogCat::GetNodeGUID") ));
    return &GUID_LogCatNode;
}

const LPTSTR 
CInternalLogCat::GetNodeDisplayName()
/*++

Routine Description:

    Returns a const TSTR pointer to the node's display name.

Arguments:

    None.

Return Value:

    A const pointer to a TSTR.

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalLogCat::GetNodeDisplayName") ));
    return (LPTSTR)pCategory->Name;
}

const LONG_PTR   
CInternalLogCat::GetCookie()
/*++

Routine Description:

    Returns the cookie for this node.

Arguments:

    None.

Return Value:

    A const long containing the cookie for the pointer,
    in this case, a NULL, since the root node has no cookie.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalLogCat::GetCookie") ));
    DebugPrint(( TEXT("Log Category Node Cookie: 0x%p"), this ));
    return (LONG_PTR)this; // status node's cookie is the node id.
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// 
// IComponent over-rides
//
//

HRESULT 
STDMETHODCALLTYPE 
CInternalLogCat::ResultGetDisplayInfo(
                                     IN CFaxComponent * pComp,  
                                     IN OUT RESULTDATAITEM __RPC_FAR *pResultDataItem)
/*++

Routine Description:

    This routine dispatches result pane GetDisplayInfo requests to the appropriate handlers
    in the mandatory implementations of the node, as well as handling special case data requests.
            
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    pResultDataItem - a pointer to the RESULTDATAITEM struct which needs to be filled in.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalLogCat::ResultGetDisplayInfo") ));

    assert(pResultDataItem != NULL);    

    if( pResultDataItem->mask & RDI_STR ) {
        if( pResultDataItem->nCol == 0 ) {
            pResultDataItem->str = GetNodeDisplayName();
        }
        if( pResultDataItem->nCol == 1) {
            pResultDataItem->str = ::GlobalStringTable->GetString( IDS_LOG_LEVEL_NONE + pCategory->Level );
        }
    }
    if( pResultDataItem->mask & RDI_IMAGE ) {
        pResultDataItem->nImage = GetNodeDisplayImage();
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IExtendContextMenu event handlers - default implementations
//
//

HRESULT 
STDMETHODCALLTYPE 
CInternalLogCat::ComponentContextMenuAddMenuItems(
                                                 IN CFaxComponent * pComp,
                                                 IN CFaxDataObject * piDataObject,
                                                 IN LPCONTEXTMENUCALLBACK piCallback,
                                                 IN OUT long __RPC_FAR *pInsertionAllowed)
/*++

Routine Description:

    Adds items to the context menu.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    piDataObject - pointer to the dataobject associated with this node
    piCallback - a pointer to the IContextMenuCallback used to insert pages
    pInsertionAllowed - a set of flag indicating whether insertion is allowed.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    CONTEXTMENUITEM menuItem;
    WORD            menuID;
    HRESULT         hr = S_OK;

    if( !( *pInsertionAllowed | CCM_INSERTIONALLOWED_TOP ) ) {
        assert( FALSE );
        return S_OK;
    }

    // build the submenu

    ZeroMemory( (void*)&menuItem, sizeof( menuItem ));

    menuItem.strName = ::GlobalStringTable->GetString( IDS_LOG_LEVEL );
    menuItem.strStatusBarText = ::GlobalStringTable->GetString( IDS_LOG_LEVEL_DESC );
    menuItem.lCommandID = PRI_CONTEXT_MENU;
    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
    menuItem.fFlags = MF_POPUP | MF_ENABLED;
    menuItem.fSpecialFlags = CCM_SPECIAL_SUBMENU;

    hr = piCallback->AddItem( &menuItem );
    if( FAILED(hr) ) {
        return hr;
    }

    // build the submenu

    for( menuID = 0; menuID < 4; menuID++ ) {

        ZeroMemory( ( void* )&menuItem, sizeof( menuItem ) );

        menuItem.strName = ::GlobalStringTable->GetString( IDS_LOG_LEVEL_NONE + menuID );
        menuItem.strStatusBarText = ::GlobalStringTable->GetString( IDS_LOG_LEVEL_NONE_DESC + menuID );
        menuItem.lCommandID = menuID;
        menuItem.lInsertionPointID = PRI_CONTEXT_MENU;
        if( menuID == pCategory->Level ) {
            menuItem.fFlags = MF_ENABLED | MF_CHECKED;
        } else {
            menuItem.fFlags = MF_ENABLED;
        }
        menuItem.fSpecialFlags = 0;

        hr = piCallback->AddItem( &menuItem );
        if( FAILED(hr) ) {
            return hr;
        }
    }    
    return hr;
}



HRESULT 
STDMETHODCALLTYPE 
CInternalLogCat::ComponentContextMenuCommand(
                                            IN CFaxComponent * pComp,
                                            IN long lCommandID,
                                            IN CFaxDataObject * piDataObject)
/*++

Routine Description:

    Handles context menu commands.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lCommandID - the command ID
    piDataObject - pointer to the dataobject associated with this node
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    HRESULT hr;

    if( lCommandID >= 0 || lCommandID < 4 ) {
        pCategory->Level = lCommandID;
        assert( m_pParentINode );
        hr = ((CInternalLogging *)m_pParentINode)->CommitChanges( pComp );
        if( SUCCEEDED( hr ) ) {
            pComp->m_pResultData->UpdateItem( hItemID );
        }
    }

    // if we return a failure here, the MMC will assert on us!!
    // so we return only S_OK.

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Internal Event Handlers
//
//

HRESULT 
CInternalLogCat::ResultOnSelect( 
                               IN CFaxComponent* pComp, 
                               IN CFaxDataObject * lpDataObject, 
                               IN LPARAM arg, LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_SELECT message for the log category node.

Arguments:

    pCompData - a pointer to the instance of IComponentData which this root node is associated with.
    pdo - a pointer to the data object associated with this node
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalRoot::OnSelect") ));
    pComp->m_pConsoleVerb->SetDefaultVerb( MMC_VERB_NONE );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\ilogcat.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ilogcat.h

Abstract:

    Internal implementation for a logging category item.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#ifndef __ILOGCAT_H_
#define __ILOGCAT_H_

#include "winfax.h"

class CInternalLogCat : public CInternalNode
{
public:
    // constructor and destructor
    CInternalLogCat( CInternalNode * pParent, CFaxComponentData * pCompData );
    ~CInternalLogCat();

    // IComponent over-rides
    HRESULT STDMETHODCALLTYPE ResultGetDisplayInfo(
                              /* [in] */ CFaxComponent * pComp,  
                              /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);

    // IExtendContextMenu overrides for IComponent
    virtual HRESULT STDMETHODCALLTYPE ComponentContextMenuAddMenuItems(
                                                             /* [in] */ CFaxComponent * pCompData,
                                                             /* [in] */ CFaxDataObject * piDataObject,
                                                             /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                                             /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

    virtual HRESULT STDMETHODCALLTYPE ComponentContextMenuCommand(
                                                        /* [in] */ CFaxComponent * pCompData,
                                                        /* [in] */ long lCommandID,
                                                        /* [in] */ CFaxDataObject * piDataObject);

    // internal event handler
    HRESULT ResultOnSelect( 
                               IN CFaxComponent* pComp, 
                               IN CFaxDataObject * lpDataObject, 
                               IN LPARAM arg, LPARAM param );

    // member functions

    virtual const GUID * GetNodeGUID();    
    virtual const LPTSTR GetNodeDisplayName();
    virtual const LONG_PTR GetCookie();
    virtual CInternalNode * GetThis() { return this; }
    virtual const int       GetNodeDisplayImage() { return IDI_LOGGING; }

    void SetLogCategory( PFAX_LOG_CATEGORY pC ) { pCategory = pC; }   
    void SetItemID( HRESULTITEM hItem ) { hItemID = hItem; }    

private:
    PFAX_LOG_CATEGORY           pCategory;
    HRESULTITEM                 hItemID;
};

typedef CInternalLogCat* pCInternalLogCat;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\idevices.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    idevices.cpp

Abstract:

    Internal implementation for the devices subfolder.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#include "StdAfx.h"

#include "inode.h"          // base class
#include "iroot.h"          // iroot
#include "idevices.h"       // devices folder
#include "idevice.h"        // a device

#include "faxsnapin.h"      // snapin
#include "faxdataobj.h"     // dataobject
#include "faxstrt.h"        // string table

#pragma hdrstop

extern CStringTable * GlobalStringTable;

// Generated with uuidgen. Each node must have a GUID associated with it.
// This one is for the devices subfolder.
const GUID GUID_DevicesNode = /* 03a815d8-3e9e-11d1-9075-00a0c90ab504 */
{
    0x03a815d8,
    0x3e9e,
    0x11d1,
    {0x90, 0x75, 0x00, 0xa0, 0xc9, 0x0a, 0xb5, 0x04}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CInternalDevices::CInternalDevices(
                                  CInternalNode * pParent, 
                                  CFaxComponentData * pCompData ) 
: CInternalNode( pParent, pCompData ),  
  pDevicesInfo( NULL )
/*++

Routine Description:

    Constructor

Arguments:

    pParent - pointer to parent node, in this case unused
    pCompData - pointer to IComponentData implementation for snapin global data

Return Value:

    None.    

--*/
{
    DebugPrint(( TEXT("CInternalDeviceS Created") ));

    faxHandle = m_pCompData->m_FaxHandle;
    assert( faxHandle != NULL );    
}

CInternalDevices::~CInternalDevices( )
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.    

--*/
{
    DebugPrint(( TEXT("CInternalDeviceS Destroyed") ));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Mandatory CInternalNode implementations.
//
//

const GUID * 
CInternalDevices::GetNodeGUID()
/*++

Routine Description:

    Returns the node's associated GUID.

Arguments:

    None.

Return Value:

    A const pointer to a binary GUID.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalDevices::GetNodeGUID") ));
    return &GUID_DevicesNode;
}

const LPTSTR 
CInternalDevices::GetNodeDisplayName()
/*++

Routine Description:

    Returns a const TSTR pointer to the node's display name.

Arguments:

    None.

Return Value:

    A const pointer to a TSTR.

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalDevices::GetNodeDisplayName") ));
    return ::GlobalStringTable->GetString( IDS_DEVICESNODENAME );
}

const LPTSTR 
CInternalDevices::GetNodeDescription()
/*++

Routine Description:

    Returns a const TSTR pointer to the node's display description.

Arguments:

    None.

Return Value:

    A const pointer to a TSTR.

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalDevices::GetNodeDisplayName") ));
    return ::GlobalStringTable->GetString( IDS_DEVICES_FOLDER_DESC_ROOT );
}

const LONG_PTR   
CInternalDevices::GetCookie()
/*++

Routine Description:

    Returns the cookie for this node.

Arguments:

    None.

Return Value:

    A const long containing the cookie for the pointer,
    in this case, (long)this.

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalDevices::GetCookie") ));
    DebugPrint(( TEXT("Devices Node Cookie: 0x%p"), this ));
    return (LONG_PTR)this; // status node's cookie is the node id.
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// 
// Internal Event Handlers
//
//

HRESULT 
CInternalDevices::ResultOnShow(
                              IN CFaxComponent* pComp, 
                              IN CFaxDataObject * lpDataObject, 
                              IN LPARAM arg, 
                              IN LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_SHOW message for the devices node.

Arguments:

    pComp - a pointer to the instance of IComponentData which this root node is associated with.
    lpDataObject - a pointer to the data object containing context information for this node.    
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevices::ResultOnShow") ));

    HRESULT                 hr = S_OK;    
    unsigned int            count;
    int                     iResult;    

    LPHEADERCTRL            pIHeaderCtrl;    

    if( m_pCompData->QueryRpcError() ) {
        return E_UNEXPECTED;
    }

    if( arg == TRUE ) { // need to display result pane
        do {
            // get resultdata pointer
            pIResultData = pComp->m_pResultData;
            assert( pIResultData );            
            if( pIResultData == NULL ) {
                hr = E_UNEXPECTED;
                break;
            }

            // insert the icons into the image list
            hr = pComp->InsertIconsIntoImageList();
            assert( SUCCEEDED( hr ) );
            if( FAILED( hr ) ) {
                break;
            }

            // set headers
            pIHeaderCtrl = pComp->m_pHeaderCtrl;

            hr = pIHeaderCtrl->InsertColumn( 0,  
                                             ::GlobalStringTable->GetString( IDS_DEVICE_NAME ), 
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );
            if( FAILED( hr ) ) {
                break;
            }

            hr = pIHeaderCtrl->InsertColumn( 1, 
                                             ::GlobalStringTable->GetString( IDS_DEVICE_SEND_EN ),
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );                                             
            if( FAILED( hr ) ) {
                break;
            }

            hr = pIHeaderCtrl->InsertColumn( 2, 
                                             ::GlobalStringTable->GetString( IDS_DEVICE_RECV_EN ),
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );                                             
            if( FAILED( hr ) ) {
                break;
            }

            hr = pIHeaderCtrl->InsertColumn( 3, 
                                             ::GlobalStringTable->GetString( IDS_DEVICE_TSID ),
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );                                             
            if( FAILED( hr ) ) {
                break;
            }

            hr = pIHeaderCtrl->InsertColumn( 4,                                              
                                             ::GlobalStringTable->GetString( IDS_DEVICE_CSID ),
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );                                             
            if( FAILED( hr ) ) {
                break;
            }

            hr = pIHeaderCtrl->InsertColumn( 5, 
                                             ::GlobalStringTable->GetString( IDS_DEVICE_STATUS ),
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );                                             
            if( FAILED( hr ) ) {
                break;
            }

            hr = pIHeaderCtrl->InsertColumn( 6, 
                                             ::GlobalStringTable->GetString( IDS_DEVICE_PRI ),
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );                                             
            if( FAILED( hr ) ) {
                break;
            }
                
            // this is the first time initializing the devices node
            if( pComp->pDeviceArray == NULL ) {    
                // get fax info
                try {
                    if( !FaxEnumPorts( faxHandle, &pDevicesInfo, &pComp->numDevices ) ) {

                        if (GetLastError() == ERROR_ACCESS_DENIED) {
                            ::GlobalStringTable->SystemErrorMsg(ERROR_ACCESS_DENIED);
                        } else {
                            m_pCompData->NotifyRpcError( TRUE );
                            hr = m_pCompData->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_FAX_RETR_DEV_FAIL ), 
                                                                     ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                                                     MB_OK, 
                                                                     &iResult);                
                        }

                        
                        hr = E_UNEXPECTED;

                        break;            
                    }
                } catch( ... ) {
                    m_pCompData->NotifyRpcError( TRUE );
                    hr = m_pCompData->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_FAX_RETR_DEV_FAIL ), 
                                                             ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                                             MB_OK, 
                                                             &iResult);                
                    hr = E_UNEXPECTED;
                    break;            
                }
                assert( pComp->pDeviceArray == NULL );
    
                pComp->pDeviceArray = new pCInternalDevice[pComp->numDevices];
                if (!pComp->pDeviceArray) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
    
                ZeroMemory( (void *)pComp->pDeviceArray, pComp->numDevices * sizeof( pCInternalDevice ) );

                for( count = 0; count < pComp->numDevices; count ++ ) {                
                    pComp->pDeviceArray[count] = new CInternalDevice( this, m_pCompData, faxHandle, pDevicesInfo[count].DeviceId );
                    if (!pComp->pDeviceArray[count]) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                }
            }

            // on each display, insert each device into the devices pane
            for( count = 0; count < pComp->numDevices; count++ ) {
                hr = InsertItem( &pComp->pDeviceArray[count], &(pDevicesInfo[count]) );
                if( FAILED( hr ) ) {
                    break;
                }
            }
        } while( 0 );
        if( pDevicesInfo != NULL ) {
            FaxFreeBuffer( (PVOID) pDevicesInfo );
            pDevicesInfo = NULL;
        }

        if (FAILED(hr)) {
            if (pComp->pDeviceArray) {
                for (count = 0; count < pComp->numDevices; count++ ) {
                    if (pComp->pDeviceArray[count]) {
                        delete(pComp->pDeviceArray[count]);
                    }
                }

                delete(pComp->pDeviceArray);
                pComp->pDeviceArray = NULL;
            }
        }
    }    
    return hr;
}


HRESULT 
CInternalDevices::ResultOnDelete(
                                IN CFaxComponent* pComp,
                                IN CFaxDataObject * lpDataObject, 
                                IN LPARAM arg, 
                                IN LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_DELETE message for the devices node.

Arguments:

    pComp - a pointer to the instance of IComponentData which this root node is associated with.
    lpDataObject - a pointer to the data object containing context information for this node.
    pdo - a pointer to the data object associated with this node
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{

    // unneeded because the per result view data will be deleted by destroying the
    // CInternalComponent holding the information
#if 0
    DebugPrint(( TEXT("Trace: CInternalDevices::ResultOnDelete") ));

    unsigned int count;

    for( count = 0; count < pComp->numDevices; count++ ) {
        if( pComp->pDeviceArray[count] != NULL ) {
            delete pComp->pDeviceArray[count];
            pComp->pDeviceArray[count] = NULL;
        }
    }
    delete pComp->pDeviceArray;
    pComp->pDeviceArray = NULL;
#endif 

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Internal Functions
// 
//

HRESULT 
CInternalDevices::CorrectServiceState()
/*++

Routine Description:

    Scans the devices to see if any are enabled for receive, and if so,
    resets the service's startup state to automatic from manual. If no
    devices are enabled for receive, then the service is set from
    automatic to manual.

Arguments:

    None.

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DWORD               i;    
    PFAX_PORT_INFO      pPortInfos = NULL;
    DWORD               portCount;
    int                 iResult;
    BOOL                setAuto = FALSE;
    HRESULT             hr = S_OK;

    DebugPrint(( TEXT("Trace: CInternalDevices::CorrectServiceState") ));

    do {
        // get fax info
        try {
            if( m_pCompData->QueryRpcError() ) {
                hr = E_UNEXPECTED;
                break;            
            }

            if( !FaxEnumPorts( faxHandle, &pPortInfos, &portCount ) ) {
                if (GetLastError() == ERROR_ACCESS_DENIED) {
                    ::GlobalStringTable->SystemErrorMsg(ERROR_ACCESS_DENIED);
                } else {
                    m_pCompData->NotifyRpcError( TRUE );
                    hr = m_pCompData->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_FAX_RETR_DEV_FAIL ), 
                                                             ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                                             MB_OK, 
                                                             &iResult);                
                }
                hr = E_UNEXPECTED;
                break;            
            }
        } catch( ... ) {
            m_pCompData->NotifyRpcError( TRUE );
            hr = m_pCompData->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_FAX_RETR_DEV_FAIL ), 
                                                     ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                                     MB_OK, 
                                                     &iResult);                
            hr = E_UNEXPECTED;
            break;            
        }
        for( i = 0; i < portCount; i++) {
            if( pPortInfos[i].Flags & FPF_RECEIVE ) {
                setAuto = TRUE;
                break;
            }
        }

        SetServiceState( setAuto );

    } while( 0 );

    if( pPortInfos != NULL ) {
        FaxFreeBuffer( (PVOID) pPortInfos );
        pPortInfos = NULL;
    }

    return hr;
}

HRESULT 
CInternalDevices::SetServiceState(
                                 IN BOOL fAutomatic )
/*++

Routine Description:

    Opens the Service Manager on the snapin's target machine, and sets
    the fax service state according to the fAutomatic parameter.

Arguments:

    fAutomatic - if TRUE, sets the service to start automatically.
                 if FALSE, sets the service to start manually.

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    SC_LOCK                             sclLock;     
    LPQUERY_SERVICE_LOCK_STATUS         lpqslsBuf; 
    TCHAR                               buffer[256];
    LPTSTR                              str;
    int                                 iResult;
    HRESULT                             hr = S_OK;
    SC_HANDLE                           schSCManager;
    SC_HANDLE                           schService;

    DebugPrint(( TEXT("Trace: CInternalDevices::SetServiceState") ));

    DWORD dwBytesNeeded, dwStartType;  

    ZeroMemory( (PVOID)buffer, sizeof( TCHAR ) * 256 );

    schSCManager = OpenSCManager( ((CInternalRoot*)m_pParentINode)->GetMachine(), 
                                  NULL, 
                                  SC_MANAGER_CONNECT | SC_MANAGER_LOCK 
                                  | SC_MANAGER_QUERY_LOCK_STATUS | SC_MANAGER_ENUMERATE_SERVICE );

    if( schSCManager == NULL ) {
        ::GlobalStringTable->PopUpMsg( NULL, IDS_ERR_CONNECT_SCM, TRUE, 0 );
        assert( FALSE );
        return E_UNEXPECTED;
    }


    // Need to acquire database lock before reconfiguring.  
    sclLock = LockServiceDatabase(schSCManager);  
    // If the database cannot be locked, report the details.  
    if(sclLock == NULL) {
        // Exit if the database is not locked by another process.  
        if(GetLastError() != ERROR_SERVICE_DATABASE_LOCKED) {
            ::GlobalStringTable->PopUpMsg( NULL, IDS_ERR_LOCK_SERVICE_DB, TRUE, 0 );
            assert( FALSE );
            return E_UNEXPECTED;
        }

        // Allocate a buffer to get details about the lock.  
        lpqslsBuf = (LPQUERY_SERVICE_LOCK_STATUS) LocalAlloc( LPTR, 
                                                              sizeof(QUERY_SERVICE_LOCK_STATUS)+256); 

        if(lpqslsBuf == NULL) {
            ::GlobalStringTable->PopUpMsg( NULL, IDS_OUT_OF_MEMORY, TRUE, 0 );
            assert( FALSE );
            return E_OUTOFMEMORY;
        }

        do {
            // Get and print the lock status information.  
            if(!QueryServiceLockStatus( schSCManager, 
                                        lpqslsBuf,
                                        sizeof(QUERY_SERVICE_LOCK_STATUS)+256, 
                                        &dwBytesNeeded) ) {
                ::GlobalStringTable->PopUpMsg( NULL, IDS_ERR_QUERY_LOCK, TRUE, 0 );
                assert( FALSE );
                break;
            }
            if(lpqslsBuf->fIsLocked) {
                str = ::GlobalStringTable->GetString( IDS_QUERY_LOCK );
                _stprintf( buffer, str, lpqslsBuf->lpLockOwner, lpqslsBuf->dwLockDuration );
                m_pCompData->m_pConsole->MessageBox( buffer, 
                                                     ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                                     MB_OK, 
                                                     &iResult);
            } else {
                ::GlobalStringTable->PopUpMsg( NULL, IDS_ERR_LOCK_SERVICE_DB, TRUE, 0 );
            }

        } while( 0 );

        LocalFree(lpqslsBuf);
        return E_UNEXPECTED;
    }

    do {

        // The database is locked, so it is safe to make changes.  
        // Open a handle to the service.      
        schService = OpenService( schSCManager,             // SCManager database 
                                  TEXT("Fax"),       // name of service 
                                  SERVICE_CHANGE_CONFIG );  // need CHANGE access 
        if(schService == NULL) {
            ::GlobalStringTable->PopUpMsg( NULL, IDS_ERR_OPEN_SERVICE, TRUE, 0 );
            assert( FALSE );
            hr = E_UNEXPECTED;
            break;
        }

        dwStartType = (fAutomatic) ? SERVICE_AUTO_START : 
                      SERVICE_DEMAND_START;  

        if(! ChangeServiceConfig( schService,        // handle of service 
                                  SERVICE_NO_CHANGE, // service type: no change 
                                  dwStartType,       // change service start type 
                                  SERVICE_NO_CHANGE, // error control: no change 
                                  NULL,              // binary path: no change 
                                  NULL,              // load order group: no change 
                                  NULL,              // tag ID: no change 
                                  NULL,              // dependencies: no change 
                                  NULL,              // account name: no change 
                                  NULL,              // password: no change     
                                  NULL) ) {            // display string
            ::GlobalStringTable->PopUpMsg( NULL, IDS_ERR_CHANGE_SERVICE, TRUE, 0 );
            assert( FALSE );
            hr = E_UNEXPECTED;
        }

        // Close the handle to the service.      
        CloseServiceHandle(schService);

    } while( 0 );

    // Release the database lock.      
    UnlockServiceDatabase(sclLock);

    return hr;
}

void 
CInternalDevices::NotifyFailure(
                               CFaxComponent * pComp )
/*++

Routine Description:

    If there was a failure in a RPC call anywhere in the child nodes, the result
    pane should be cleared. This function clears the result pane.

Arguments:

    pComp - a pointer to the instance of IComponentData which this root node is associated with.

Return Value:

    None.

--*/
{
    assert( pComp != NULL );
    assert( pComp->pDeviceArray != NULL );

    pComp->m_pResultData->DeleteAllRsltItems();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Utility Functions
// 
//

HRESULT 
CInternalDevices::InsertItem(
                            IN CInternalDevice ** pDevice, 
                            IN PFAX_PORT_INFO pDeviceInfo )
/*++

Routine Description:

    Wrapper that inserts an item into the result view pane given some information.

Arguments:

    pDevice - the instance of CInternalDevice to insert
    pDeviceInfo - the information associated with that log category.

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    RESULTDATAITEM      rdi;
    HRESULT             hr = S_OK;

    ZeroMemory( &rdi, sizeof( RESULTDATAITEM ) );
    rdi.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    rdi.nCol = 0;
    rdi.bScopeItem = FALSE;   
    rdi.lParam = (*pDevice)->GetCookie();
    rdi.nImage = (*pDevice)->GetNodeDisplayImage();
    rdi.str = MMC_CALLBACK;

    hr = pIResultData->InsertItem( &rdi );    
    assert( SUCCEEDED( hr ) );

    (*pDevice)->SetItemID( rdi.itemID );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\idevices.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    idevices.h

Abstract:

    Internal implementation for the devices subfolder.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#ifndef __IDEVICES_H_
#define __IDEVICES_H_

class CInternalDevice;      // forward declaration

class CInternalDevices : public CInternalNode
{
public:
    CInternalDevices( CInternalNode * pParent, CFaxComponentData * pCompData );
    ~CInternalDevices();

    // member functions

    virtual const GUID * GetNodeGUID();    
    virtual const LPTSTR GetNodeDisplayName();
    virtual const LPTSTR GetNodeDescription();
    virtual const LONG_PTR GetCookie();
    virtual CInternalNode * GetThis() { return this; }

    virtual const int       GetNodeDisplayImage() { return IDI_FAXING; }
    virtual const int       GetNodeDisplayOpenImage() { return IDI_FAXING; }
    
    virtual HRESULT         ResultOnShow(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnDelete(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);

    HRESULT CorrectServiceState();

    // removes all the devices in preperation for a re-enum
    void NotifyFailure( CFaxComponent * pComp );

    HANDLE                      faxHandle;    
private:
    HRESULT InsertItem(   CInternalDevice ** pDevice, 
                          PFAX_PORT_INFO pPortInfo );
    
    HRESULT SetServiceState( BOOL fAutomatic );

    CInternalDevice **          pDeviceArray;

    PFAX_PORT_INFO              pDevicesInfo;
    LPRESULTDATA                pIResultData;    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\ilogging.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ilogging.cpp

Abstract:

    Internal implementation for the logging subfolder.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#include "StdAfx.h"

#include "inode.h"          // base class
#include "iroot.h"          // iroot

#include "ilogging.h"       // logging folder
#include "ilogcat.h"        // log category item

#include "faxsnapin.h"      // snapin
#include "faxdataobj.h"     // dataobject
#include "faxstrt.h"        // string table

#pragma hdrstop

extern CStringTable * GlobalStringTable;

// Generated with uuidgen. Each node must have a GUID associated with it.
// This one is for the logging subfolder.
const GUID GUID_LoggingNode = /* 03d8fbd8-3e9e-11d1-9075-00a0c90ab504 */
{
    0x03d8fbd8,
    0x3e9e,
    0x11d1,
    {0x90, 0x75, 0x00, 0xa0, 0xc9, 0x0a, 0xb5, 0x04}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CInternalLogging::CInternalLogging(
                                  CInternalNode * pParent, 
                                  CFaxComponentData * pCompData  ) 
: CInternalNode( pParent, pCompData )
/*++

Routine Description:

    Constructor

Arguments:

    pParent - pointer to parent node, in this case unused
    pCompData - pointer to IComponentData implementation for snapin global data

Return Value:

    None.    

--*/
{
    faxHandle = m_pCompData->m_FaxHandle;
    assert( faxHandle != NULL );
}

CInternalLogging::~CInternalLogging() 
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.    

--*/
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Mandatory CInternalNode implementations.
//
//

const GUID * 
CInternalLogging::GetNodeGUID()
/*++

Routine Description:

    Returns the node's associated GUID.

Arguments:

    None.

Return Value:

    A const pointer to a binary GUID.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalLogging::GetNodeGUID") ));
    return &GUID_LoggingNode;
}

const LPTSTR
CInternalLogging::GetNodeDisplayName()
/*++

Routine Description:

    Returns a const TSTR pointer to the node's display name.

Arguments:

    None.

Return Value:

    A const pointer to a TSTR.

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalLogging::GetNodeDisplayName") ));
    return ::GlobalStringTable->GetString( IDS_LOGGINGNODENAME );
}

const LPTSTR 
CInternalLogging::GetNodeDescription()
/*++

Routine Description:

    Returns a const TSTR pointer to the node's display description.

Arguments:

    None.

Return Value:

    A const pointer to a TSTR.

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalLogging::GetNodeDisplayName") ));
    return ::GlobalStringTable->GetString( IDS_LOGGING_FOLDER_DESC_ROOT );
}

const LONG_PTR  
CInternalLogging::GetCookie()
/*++

Routine Description:

    Returns the cookie for this node.

Arguments:

    None.

Return Value:

    A const long containing the cookie for the pointer,
    in this case, (long)this.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalLogging::GetCookie") ));
    DebugPrint(( TEXT("Logging Node Cookie: 0x%p"), this ));
    return (LONG_PTR)this; // status node's cookie is the node id.
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// 
// Internal Event Handlers
//
//

HRESULT 
CInternalLogging::ResultOnShow(
                              IN CFaxComponent* pComp, 
                              IN CFaxDataObject * lpDataObject, 
                              IN LPARAM arg, 
                              IN LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_SHOW message for the logging node.

Arguments:

    pComp - a pointer to the instance of IComponentData which this root node is associated with.
    lpDataObject - a pointer to the data object containing context information for this node.
    pdo - a pointer to the data object associated with this node
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalLogging::ResultOnShow") ));

    HRESULT                 hr = S_OK;    
    unsigned int            count;
    int                     iResult;        
    BOOL                    bResult = FALSE;

    LPHEADERCTRL            pIHeaderCtrl;    

    if( m_pCompData->QueryRpcError() ) {
        return E_UNEXPECTED;
    }

    if( arg == TRUE ) { // need to display result pane

        do {
            // get resultdata pointer
            pIResultData = pComp->m_pResultData;
            assert( pIResultData );            
            if( pIResultData == NULL ) {
                hr = E_UNEXPECTED;
                break;
            }

            // insert the icons into the image list
            hr = pComp->InsertIconsIntoImageList();
            assert( SUCCEEDED( hr ) );
            if( FAILED( hr ) ) {
                break;
            }

            // set headers
            pIHeaderCtrl = pComp->m_pHeaderCtrl;

            hr = pIHeaderCtrl->InsertColumn( 0,  
                                             ::GlobalStringTable->GetString( IDS_LOG_CATEGORY ), 
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );
            if( FAILED( hr ) ) {
                break;
            }


            hr = pIHeaderCtrl->InsertColumn( 1, 
                                             ::GlobalStringTable->GetString( IDS_LOG_LEVEL ),
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );                                             
            if( FAILED( hr ) ) {
                break;
            }

            // get fax info
            try {
                bResult = FaxGetLoggingCategories( faxHandle, &pComp->pCategories, &pComp->numCategories );
            } catch( ... ) {
            }

            if( !bResult ) {
                if (GetLastError() == ERROR_ACCESS_DENIED) {
                    ::GlobalStringTable->SystemErrorMsg(ERROR_ACCESS_DENIED);
                } else {
                    m_pCompData->NotifyRpcError( TRUE );
                    hr = m_pCompData->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_FAX_RETR_CAT_FAIL ), 
                                                             ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                                             MB_OK, 
                                                             &iResult);                
                }
                hr = E_UNEXPECTED;
                break;            
            }

            pComp->pLogPArray = new pCInternalLogCat[pComp->numCategories];
            assert(pComp->pLogPArray != NULL);
            if (!pComp->pLogPArray) {
                hr = E_OUTOFMEMORY;
                break;
            }

            ZeroMemory( (void*)pComp->pLogPArray, sizeof( pCInternalLogCat ) * pComp->numCategories);

            for( count = 0; count < pComp->numCategories; count++ ) {
                hr = InsertItem( &pComp->pLogPArray[count], &(pComp->pCategories[count]) );
                if( !SUCCEEDED( hr ) ) {
                    break;
                }
            }
        } while( 0 );
    } else {
        // we're leaving the result pane
        // so we need to delete my result pane
        FaxFreeBuffer( (PVOID)pComp->pCategories );
        pComp->pCategories = NULL;
        for( count = 0; count < pComp->numCategories; count++ ) {
            if( pComp->pLogPArray ) {
                if (pComp->pLogPArray[count] != NULL ) {
                    delete pComp->pLogPArray[count];
                    pComp->pLogPArray[count] = NULL;
                }
            }
        }
    }

    return hr;
}


HRESULT 
CInternalLogging::ResultOnDelete(
                                IN CFaxComponent* pComp,
                                IN CFaxDataObject * lpDataObject, 
                                IN LPARAM arg, LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_DELETE message for the logging node.

Arguments:

    pComp - a pointer to the instance of IComponentData which this root node is associated with.
    lpDataObject - a pointer to the data object containing context information for this node.
    pdo - a pointer to the data object associated with this node
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    unsigned int count;

    for( count = 0; count < pComp->numCategories; count++ ) {
        if( pComp->pLogPArray[count] != NULL ) {
            delete pComp->pLogPArray[count];
            pComp->pLogPArray[count] = NULL;
        }
    }
    delete pComp->pLogPArray;
    pComp->pLogPArray = NULL;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Internal Functions
// 
//

HRESULT 
CInternalLogging::CommitChanges(
                               CFaxComponent * pComp )
/*++

Routine Description:

    This function writes changes made in the subnodes out to the 
    target fax service.

Arguments:

    pComp - a pointer to the instance of IComponent associated with the event.    

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    BOOL    result = FALSE;

    if( m_pCompData->QueryRpcError() ) {
        return E_UNEXPECTED;
    }

    try {
        result = FaxSetLoggingCategories( faxHandle, pComp->pCategories, pComp->numCategories );
    } catch( ... ) {
        m_pCompData->NotifyRpcError( TRUE );
    }

    if( result == FALSE || m_pCompData->QueryRpcError() == TRUE ) {
        if (GetLastError() != ERROR_ACCESS_DENIED) {
            m_pCompData->NotifyRpcError( TRUE );
            assert(FALSE);
        }        

        ::GlobalStringTable->SystemErrorMsg( GetLastError() );

        // clean up the result pane
        assert( pComp != NULL );
        pComp->m_pResultData->DeleteAllRsltItems();

        if(pComp->pLogPArray != NULL ) {
            for( DWORD count = 0; count < pComp->numCategories; count++ ) {
                if( pComp->pLogPArray[count] != NULL ) {
                    delete pComp->pLogPArray[count];
                    pComp->pLogPArray[count] = NULL;
                }
            }
            delete pComp->pLogPArray;
            pComp->pLogPArray = NULL;
        }

        assert( FALSE );
        return E_UNEXPECTED;
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Utility Functions
// 
//

HRESULT 
CInternalLogging::InsertItem(
                            IN CInternalLogCat ** pLogCat, 
                            IN PFAX_LOG_CATEGORY Category )
/*++

Routine Description:

    Wrapper that inserts an item into the result view pane given some information.

Arguments:

    pLogCat - the instance of CInternalLogCat to insert
    Category - the information associated with that log category.

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    RESULTDATAITEM      rdi;
    HRESULT             hr = S_OK;

    if (!pLogCat) {
        return(E_POINTER);
    }

    *pLogCat = new CInternalLogCat( this, m_pCompData );    
    assert(*pLogCat != NULL);
    if (!*pLogCat) {
        return(E_OUTOFMEMORY);
    }

    (*pLogCat)->SetLogCategory( Category );

    ZeroMemory( &rdi, sizeof( RESULTDATAITEM ) );
    rdi.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    rdi.nCol = 0;
    rdi.bScopeItem = FALSE;   
    rdi.lParam = (*pLogCat)->GetCookie();
    rdi.nImage = (*pLogCat)->GetNodeDisplayImage();
    rdi.str = MMC_CALLBACK;

    hr = pIResultData->InsertItem( &rdi );    
    assert( SUCCEEDED( hr ) );

    (*pLogCat)->SetItemID( rdi.itemID );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\ilogging.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ilogging.h

Abstract:

    Internal implementation for the logging subfolder.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#ifndef __ILOGGING_H_
#define __ILOGGING_H_

class CInternalLogCat;      // forward decl

class CInternalLogging : public CInternalNode
{
public:

    // constructor / destructor
    CInternalLogging(  CInternalNode * pParent, CFaxComponentData * pCompData  );
    ~CInternalLogging();

    // member functions

    virtual const GUID * GetNodeGUID();    
    virtual const LPTSTR GetNodeDisplayName();
    virtual const LPTSTR GetNodeDescription();
    virtual const LONG_PTR GetCookie();
    virtual CInternalNode * GetThis() { return this; }
    virtual const int       GetNodeDisplayImage() { return IDI_LOGGING; }
    virtual const int       GetNodeDisplayOpenImage() { return IDI_LOGGING; }

    // internal event handlers
    virtual HRESULT         ResultOnShow(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnDelete(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    HRESULT CommitChanges( CFaxComponent * pComp );

private:
    HRESULT InsertItem(   CInternalLogCat ** pLogCat, 
                          PFAX_LOG_CATEGORY Category );
           
    LPRESULTDATA                pIResultData;
    HANDLE                      faxHandle;    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\inode.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inode.h

Abstract:

    This header contains the abstract base node class for
    the snapin.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

#ifndef __INODE_H_
#define __INODE_H_

#include "resource.h"

class CFaxDataObject;       // forward declaration
class CFaxComponentData;
class CFaxComponent;

// the CInternalNode class provides a framework in which the various
// types of subcontainers in the snapin will implement various methods.
//
// all the subcontainers in the scope and result panes inherit from this class
//
// the global Notify method in CFaxComponent and CFaxComponentData and others
// will delegate to the implementations specified by the children of this class.
// using the cookie as an identifier. (currently a cast to pointer, but can be changed 
// to a lookup table when/if a long < pointer type (64-bit world).
//
// this class will supply a default implementation of some of the methods via virtual functions

class CInternalNode
{
public:
    // constructor
    CInternalNode( CInternalNode * pParent, CFaxComponentData * pCompData )
    {
        m_pParentINode = pParent;
        m_pCompData = pCompData;
    }
    ~CInternalNode() 
    {
    }

    // *********************************************8
    // These methods call those defined below.
    //
    // This moves common code together in the inode class
    // and makes the descendents simpler, since they only
    // implement the methods they need to override the
    // default implementations for.

    // IComponentData

    virtual HRESULT STDMETHODCALLTYPE ScopeNotify(
                                                 /* [in] */ CFaxComponentData * pCompData,
                                                 /* [in] */ CFaxDataObject * lpDataObject,
                                                 /* [in] */ MMC_NOTIFY_TYPE event,
                                                 /* [in] */ LPARAM arg,
                                                 /* [in] */ LPARAM param);

    virtual HRESULT STDMETHODCALLTYPE ScopeGetDisplayInfo(
                                                         /* [in] */ CFaxComponentData * pCompData,
                                                         /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);


    virtual HRESULT STDMETHODCALLTYPE ScopeQueryDataObject(
                                                          /* [in] */ CFaxComponentData * pCompData,
                                                          /* [in] */ MMC_COOKIE cookie,
                                                          /* [in] */ DATA_OBJECT_TYPES type,
                                                          /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

    // IComponent

    virtual HRESULT STDMETHODCALLTYPE ResultNotify(
                                                  /* [in] */ CFaxComponent * pComp,  
                                                  /* [in] */ CFaxDataObject * lpDataObject,
                                                  /* [in] */ MMC_NOTIFY_TYPE event,
                                                  /* [in] */ LPARAM arg,
                                                  /* [in] */ LPARAM param);

    virtual HRESULT STDMETHODCALLTYPE ResultGetDisplayInfo(
                                                          /* [in] */ CFaxComponent * pComp,  
                                                          /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);

    virtual HRESULT STDMETHODCALLTYPE ResultGetResultViewType(
                                                             /* [in] */ CFaxComponent * pComp,  
                                                             /* [in] */ MMC_COOKIE cookie,
                                                             /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                                             /* [out] */ long __RPC_FAR *pViewOptions);

    virtual HRESULT STDMETHODCALLTYPE ResultQueryDataObject(
                                                           /* [in] */ CFaxComponent * pComp,  
                                                           /* [in] */ MMC_COOKIE cookie,
                                                           /* [in] */ DATA_OBJECT_TYPES type,
                                                           /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

    // ***********************************************************
    // ExtendPropertySheet event handlers - default implementations
    // we need seperate versions for IComponentData and IComponent
    // in your code if you want differing behavior 
    // in the scope and results panes.
    //
    // You can simply delegate one implementation to the other
    // if you want the same behavior in both panes

    // IExtendPropertySheet for IComponentData
    virtual HRESULT STDMETHODCALLTYPE ComponentDataPropertySheetCreatePropertyPages(
                                                                      /* [in] */ CFaxComponentData * pCompData,
                                                                      /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                                      /* [in] */ LONG_PTR handle,
                                                                      /* [in] */ CFaxDataObject * lpIDataObject);

    virtual HRESULT STDMETHODCALLTYPE ComponentDataPropertySheetQueryPagesFor(
                                                                /* [in] */ CFaxComponentData * pCompData,
                                                                /* [in] */ CFaxDataObject * lpDataObject);

    // IExtendPropertySheet for IComponent
    virtual HRESULT STDMETHODCALLTYPE ComponentPropertySheetCreatePropertyPages(
                                                                      /* [in] */ CFaxComponent * pComp,
                                                                      /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                                      /* [in] */ LONG_PTR handle,
                                                                      /* [in] */ CFaxDataObject * lpIDataObject);

    virtual HRESULT STDMETHODCALLTYPE ComponentPropertySheetQueryPagesFor(
                                                                /* [in] */ CFaxComponent * pComp,
                                                                /* [in] */ CFaxDataObject * lpDataObject);

    // ***********************************************************
    // ExtendContextMenu event handlers - default implementations
    // we need seperate versions for IComponentData and IComponent
    // in your code if you want differing behavior 
    // in the scope and results panes.
    //
    // You can simply delegate one implementation to the other
    // if you want the same behavior in both panes

    // IExtendContextMenu for IComponentData
    virtual HRESULT STDMETHODCALLTYPE ComponentDataContextMenuAddMenuItems(
                                                             /* [in] */ CFaxComponentData * pCompData,
                                                             /* [in] */ CFaxDataObject * piDataObject,
                                                             /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                                             /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

    virtual HRESULT STDMETHODCALLTYPE ComponentDataContextMenuCommand(
                                                        /* [in] */ CFaxComponentData * pCompData,
                                                        /* [in] */ long lCommandID,
                                                        /* [in] */ CFaxDataObject * piDataObject);

    // IExtendContextMenu for IComponent
    virtual HRESULT STDMETHODCALLTYPE ComponentContextMenuAddMenuItems(
                                                             /* [in] */ CFaxComponent * pComp,
                                                             /* [in] */ CFaxDataObject * piDataObject,
                                                             /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                                             /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

    virtual HRESULT STDMETHODCALLTYPE ComponentContextMenuCommand(
                                                        /* [in] */ CFaxComponent * pComp,
                                                        /* [in] */ long lCommandID,
                                                        /* [in] */ CFaxDataObject * piDataObject);

    // ***********************************************************
    // IDataObject event handlers - default implementations
    // do nothing
    virtual HRESULT DataObjectRegisterFormats();
    virtual HRESULT DataObjectGetDataHere( FORMATETC __RPC_FAR *pFormatEtc, IStream * pstm );

    // *******************************************
    // member functions
    //
    // these are implemented by the descendents of CInternalNode and define
    // the behavior of the node.

    // returns the GUID of this node type - MUST BE IMPLEMENTED

    virtual const GUID *    GetNodeGUID() = 0;    

    // returns the display name - MUST BE IMPLEMENTED

    virtual const LPTSTR    GetNodeDisplayName() = 0;
    virtual const LPTSTR    GetNodeDescription();
    
    // returns the cookie of the node - MUST BE IMPLEMENTED
    
    virtual const LONG_PTR  GetCookie() = 0;

    // gets the right this pointer - MUST BE IMPLEMENTED
    virtual CInternalNode * GetThis() = 0;

    // returns the image indices - not required yet, but will be in the future

    virtual const int       GetNodeDisplayImage() { return IDI_NODEICON; }
    virtual const int       GetNodeDisplayOpenImage() { return IDI_NODEICON; }

    // sets the parent pointer

    virtual void                SetParentNode( CInternalNode * toSet) { m_pParentINode = toSet; }
    
    // gets the parent pointer

    virtual CInternalNode *     GetParentNode() { return m_pParentINode; }

    // *****************************************************
    // scope pane event handlers
    // override these as necessary to handle console events

    virtual HRESULT         ScopeOnExpand(CFaxComponentData * pCompData, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ScopeOnDelete(CFaxComponentData * pCompData, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ScopeOnRename(CFaxComponentData * pCompData, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ScopeOnPropertyChange(CFaxComponentData * pCompData, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);

    // *****************************************************
    // result pane event handlers
    // override these as necessary to handle console events

    virtual HRESULT         ResultOnActivate(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnAddImages(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnButtonClick(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnClick(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnDoubleClick(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnDelete(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnExpand(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnMinimized(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnPropertyChange(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnQueryPaste(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnRemoveChildren(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnRename(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);    
    virtual HRESULT         ResultOnSelect(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnShow(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);
    virtual HRESULT         ResultOnViewChange(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM arg, LPARAM param);

    // *****************************************************
    // Controlbar event handlers
    // override these as necessary to handle control bar events

    // for IComponent (Result pane nodes)
    virtual HRESULT         ControlBarOnBtnClick(CFaxComponent* pComp, CFaxDataObject * lpDataObject, LPARAM param );    
    virtual HRESULT         ControlBarOnSelect(CFaxComponent* pComp,  LPARAM arg, CFaxDataObject * lpDataObject );
    // for IComponentData (Scope pane nodes)
    virtual HRESULT         ControlBarOnBtnClick2(CFaxComponentData* pCompData, CFaxDataObject * lpDataObject, LPARAM param );    
    virtual HRESULT         ControlBarOnSelect2(CFaxComponentData* pCompData,  LPARAM arg, CFaxDataObject * lpDataObject );

public:
    
    CInternalNode *         m_pParentINode;     // my parent    
    CFaxComponentData *     m_pCompData;        // owning IComponentData

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\inode.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inode.h

Abstract:

    This file contains partial implementation of 
    the node abstract base class.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/

/*++

To create a new node type, create a new class that inheits from CInternalNode.
Implement all the methods in the Mandatory CInternalNode category listed in the
header file for this class. They are marked as pure virtual, to insure your class
will not compile unless these methods are implemented.

To add other functionality to the node, override the default implementation 
included below.

TODO: add a default implemention of InsertItem so that the new node knows how to
      insert itself into a result or scope pane view, instead of the parent
      node having an InsertItem method.

--*/

#include "stdafx.h"
#include "inode.h"          
#include "faxsnapin.h"      // snapin base
#include "faxdataobj.h"     // dataobject
#include "faxhelper.h"      // ole helper functions
#include "faxstrt.h"        // string table

#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Default mandatory CInternalNode implementations.
//
//

const LPTSTR    
CInternalNode::GetNodeDescription()
/*++

Routine Description:

    Returns a const TSTR pointer to the node's display description. You must not
    free this string, it is internally used.

Arguments:

    None.

Return Value:

    A const pointer to a TSTR.

--*/
{
    return ::GlobalStringTable->GetString( IDS_GENERIC_NODE );
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IComponentData default implementation.
//
//

HRESULT STDMETHODCALLTYPE 
CInternalNode::ScopeNotify(
                          IN CFaxComponentData * pCompData,
                          IN CFaxDataObject * pDO,
                          IN MMC_NOTIFY_TYPE event,
                          IN LPARAM arg,
                          IN LPARAM param)     
/*++

Routine Description:

    This routine dispatches scope pane events to their respective handlers.
    Do not override this procedure, instead override the individual event handlers
    declared below.
    
Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    pDO - a pointer to the IDataObject associated with this node
    event - the MMC event
    arg, param - the event parameters

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ScopeNotify") ));

    HRESULT     hr;

    if( pDO != NULL ) {
        switch(event) {
            case MMCN_EXPAND:
                ATLTRACE(_T("       ****ScopeNotify event: MMCN_EXPAND\n"));
                hr = ScopeOnExpand(pCompData, pDO, arg, param);        
                break;

            case MMCN_DELETE:
                ATLTRACE(_T("       ****ScopeNotify event: MMCN_DELETE\n"));
                hr = ScopeOnDelete(pCompData, pDO, arg, param);        
                break;

            case MMCN_RENAME:
                ATLTRACE(_T("       ****ScopeNotify event: MMCN_RENAME\n"));
                hr = ScopeOnRename(pCompData, pDO, arg, param);        
                break;

                // if we need more events later on for the scope pane, they MUST 
                // be added HERE, as well as default handlers added below

            default:
                ATLTRACE(_T("       ****ScopeNotify event: unimplemented event %x\n"), event);        
                hr = S_FALSE;
                break;
        }
    } else {
        if( event == MMCN_PROPERTY_CHANGE ) {
            ATLTRACE(_T("       ****ScopeNotify event: MMCN_PROPERTY_CHANGE\n"));
            hr = ScopeOnPropertyChange(pCompData, pDO, arg, param);                    
        } else {
            assert( FALSE );
            hr = E_UNEXPECTED;
        }
    }
    return hr;        
}

HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ScopeGetDisplayInfo(
                                  IN CFaxComponentData * pCompData,
                                  IN OUT SCOPEDATAITEM __RPC_FAR *pScopeDataItem)
/*++

Routine Description:

    This routine dispatches scope pane GetDisplayInfo requests to the appropriate handlers
    in the mandatory implementations of the node.
    
    Override this method if you want more specific behavior to a GetDisplayInfo call, otherwise
    just call the mandatory methods.
        
Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    pScopeDataItem - a pointer to the SCOPEDATAITEM struct which needs to be filled in.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalNode::ScopeGetDisplayInfo") ));    

    // override this method if you need more selective display info in
    // the scope pane.

    assert(pScopeDataItem != NULL);

    if( pScopeDataItem->mask & SDI_STR ) {
        pScopeDataItem->displayname = GetNodeDisplayName();
    }
    if( pScopeDataItem->mask & SDI_IMAGE ) {
        pScopeDataItem->nImage = GetNodeDisplayImage();
    }
    if( pScopeDataItem->mask & SDI_OPENIMAGE ) {
        pScopeDataItem->nOpenImage = GetNodeDisplayOpenImage();
    }

    return S_OK;    
}

HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ScopeQueryDataObject(
                                   IN CFaxComponentData * pCompData,
                                   IN MMC_COOKIE cookie,
                                   IN DATA_OBJECT_TYPES type,
                                   OUT LPDATAOBJECT __RPC_FAR *ppDataObject) 
/*++

Routine Description:

    This routine creates and returns a IDataObject containing context information for the current node.

Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    cookie - the cookie of the target node
    type - indicates the the node type IE scope, result, etc.
    ppDataobject - store the pointer to the new data object here.
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalNode::ScopeQueryDataObject") ));

    HRESULT hr = S_OK;

    INT iResult;
    CFaxDataObject *pdoNew = NULL;

    do {

        pdoNew = new CComObject< CFaxDataObject >;

        if(!pdoNew) {
            hr = E_OUTOFMEMORY;
            assert( m_pCompData->m_pConsole != NULL );
            if ( m_pCompData->m_pConsole != NULL ) {
                m_pCompData->m_pConsole->MessageBox(::GlobalStringTable->GetString(IDS_OUT_OF_MEMORY) ,
                                                    ::GlobalStringTable->GetString(IDS_ERR_TITLE), 
                                                    MB_OK, &iResult);
            }
            break;
        }

        pdoNew->SetCookie( GetCookie() );
        pdoNew->SetOwner( GetThis() );
        pdoNew->SetContext( type );

        *ppDataObject = pdoNew;

        // addref it **** is this needed???!?
        (*ppDataObject)->AddRef();

    } while(0);

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IComponent default implementation.
//
//

HRESULT
STDMETHODCALLTYPE
CInternalNode::ResultNotify(
                           IN CFaxComponent * pComp,  
                           IN CFaxDataObject * pDO,
                           IN MMC_NOTIFY_TYPE event,
                           IN LPARAM arg,
                           IN LPARAM param) 
/*++

Routine Description:

    This routine dispatches result pane events to their respective handlers.
    Do not override this procedure, instead override the individual event handlers
    declared below.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    pDO - a pointer to the IDataObject associated with this node
    event - the MMC event
    arg, param - the event parameters

Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ResultNotify") ));
    HRESULT             hr;

    if( pDO != NULL ) {
        switch(event) {
            case MMCN_ACTIVATE:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_ACTIVATE\n"));
                hr = ResultOnActivate(pComp, pDO, arg, param);        
                break;

            case MMCN_ADD_IMAGES:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_ADD_IMAGES\n"));
                hr = ResultOnAddImages(pComp, pDO, arg, param);        
                break;

            case MMCN_BTN_CLICK:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_BTN_CLICK\n"));
                hr = ResultOnButtonClick(pComp, pDO, arg, param);        
                break;

            case MMCN_CLICK:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_CLICK\n"));
                hr = ResultOnClick(pComp, pDO, arg, param);        
                break;

            case MMCN_DBLCLICK:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_DBLCLICK\n"));
                hr = ResultOnDoubleClick(pComp, pDO, arg, param);        
                break;

            case MMCN_DELETE:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_DELETE\n"));
                hr = ResultOnDelete(pComp, pDO, arg, param);        
                break;

            case MMCN_EXPAND:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_EXPAND\n"));
                hr = ResultOnExpand(pComp, pDO, arg, param);        
                break;

            case MMCN_MINIMIZED:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_MINIMIZED\n"));
                hr = ResultOnMinimized(pComp, pDO, arg, param);
                break;

            case MMCN_QUERY_PASTE:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_MINIMIZED\n"));
                hr = ResultOnQueryPaste(pComp, pDO, arg, param);
                break;

            case MMCN_REMOVE_CHILDREN:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_REMOVE_CHILDREN\n"));
                hr = ResultOnRemoveChildren(pComp, pDO, arg, param);        
                break;

            case MMCN_RENAME:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_RENAME\n"));
                hr = ResultOnRename(pComp, pDO, arg, param);        
                break;

            case MMCN_SELECT:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_SELECT"));
#ifdef DEBUG
                if( HIWORD( arg ) == TRUE ) {
                    ATLTRACE(_T(" select\n"));
                } else {
                    ATLTRACE(_T(" unselect\n"));
                }
#endif
                hr = ResultOnSelect(pComp, pDO, arg, param);        
                break;

            case MMCN_SHOW:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_SHOW\n"));
                hr = ResultOnShow(pComp, pDO, arg, param);        
                break;

            case MMCN_VIEW_CHANGE:
                ATLTRACE(_T("       ****ResultNotify event: MMCN_VIEW_CHANGE\n"));
                hr = ResultOnViewChange(pComp, pDO, arg, param);        
                break;

                // if we need more events later on for the result pane, they MUST 
                // be added HERE, as well as default handlers added below

            default:
                ATLTRACE(_T("       ****ResultNotify event: unimplemented event %x\n"), event);        
                hr = S_FALSE;
                break;
        }
    } else {
        // some events do not return a data object
        if( event == MMCN_PROPERTY_CHANGE ) {
            ATLTRACE(_T("       ****ResultNotify event: MMCN_PROPERTY_CHANGE\n"));
            hr = ResultOnPropertyChange(pComp, pDO, arg, param);                    
        } else {
            hr = E_UNEXPECTED;
        }
    }

    return hr;        
}

HRESULT
STDMETHODCALLTYPE
CInternalNode::ResultGetDisplayInfo(
                                   IN CFaxComponent * pComp,  
                                   IN OUT RESULTDATAITEM __RPC_FAR *pResultDataItem)
/*++

Routine Description:

    This routine dispatches result pane GetDisplayInfo requests to the appropriate handlers
    in the mandatory implementations of the node.
    
    Override this method if you want more specific behavior to a GetDisplayInfo call, otherwise
    just call the mandatory methods.
        
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    pResultDataItem - a pointer to the RESULTDATAITEM struct which needs to be filled in.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

NOTE:
    
    // **********************************************************************
    // **********************************************************************
    // default implementation only works for ** scope folders ** 
    // scope folders show up in the BOTH PANES
    // YOU MUST OVERRIDE THIS METHOD IF YOU WANT TO DISPLAY INFO FOR 
    // RESULT PANE METHODS AND REMOVE THE CHECK FOR bScopeIteim == TRUE.
    // **********************************************************************
    // **********************************************************************
    
--*/
{
//    DebugPrint(( TEXT("Trace: CInternalNode::ResultGetDisplayInfo") ));

    assert(pResultDataItem != NULL);    

    if( pResultDataItem->bScopeItem == TRUE ) {
        if( pResultDataItem->mask & RDI_STR ) {
            if( pResultDataItem->nCol == 0 ) {
                pResultDataItem->str = GetNodeDisplayName();
            }
            if( pResultDataItem->nCol == 1 ) {
                pResultDataItem->str = GetNodeDescription();
            }
        }
        if( pResultDataItem->mask & RDI_IMAGE ) {
            pResultDataItem->nImage = GetNodeDisplayImage();
        }
    } else {
        DebugPrint(( TEXT("******** Trace: CInternalNode::ResultGetDisplayInfo") ));
        DebugPrint(( TEXT("         DID YOU FORGET TO OVERRIDE ME!!!!") ));
    }

    return S_OK;
}

HRESULT
STDMETHODCALLTYPE 
CInternalNode::ResultGetResultViewType(
                                      IN CFaxComponent * pComp,  
                                      IN MMC_COOKIE cookie,
                                      OUT LPOLESTR __RPC_FAR *ppViewType,
                                      OUT long __RPC_FAR *pViewOptions) 
/*++

Routine Description:

    This routine dispatches result pane events to their respective handlers.
    Do not override this procedure, instead override the individual event handlers
    declared below.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    cookie - the cookie of the target node
    ppViewType - returns the requested view type
    pViewOptions - returns the requested view options

Return Value:

    None.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalNode::ResultGetResultViewType") ));
    *pViewOptions = MMC_VIEW_OPTIONS_NONE; // request default view.
    return S_FALSE;
}

HRESULT
STDMETHODCALLTYPE
CInternalNode::ResultQueryDataObject(
                                    IN CFaxComponent * pComp,  
                                    IN MMC_COOKIE cookie,
                                    IN DATA_OBJECT_TYPES type,
                                    OUT LPDATAOBJECT __RPC_FAR *ppDataObject) 
/*++

Routine Description:

    This routine creates and returns a IDataObject containing context information for the current node.

Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    cookie - the cookie of the target node
    type - indicates the the node type IE scope, result, etc.
    ppDataobject - store the pointer to the new data object here.
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalNode::ResultQueryDataObject") ));

    // delegate to the implementation in ScopeQueryDataObject
    return ScopeQueryDataObject( pComp->GetOwner(), cookie, type, ppDataObject );
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IExtendPropertySheet event handlers - default implementations
//
//

// ExtendPropertySheet event handlers - default implementations
// we need seperate versions for IComponentData and IComponent
// in your code if you want differing behavior 
// in the scope and results panes.
//
// You can simply delegate one implementation to the other
// if you want the same behavior in both panes

// ***********************************************************
// IExtendPropertySheet for IComponentData
HRESULT
STDMETHODCALLTYPE 
CInternalNode::ComponentDataPropertySheetCreatePropertyPages(
                                                            IN CFaxComponentData * pCompData,
                                                            IN LPPROPERTYSHEETCALLBACK lpProvider,
                                                            IN LONG_PTR handle,
                                                            IN CFaxDataObject * lpIDataObject)
/*++

Routine Description:

    The default implementation of this routine returns S_FALSE and does not add
    any pages to the property sheet.
    
Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    lpProvider - a pointer to the IPropertySheetCallback used to insert pages
    handle - a handle to route messages with
    lpIDataobject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ComponentDataPropertySheetCreatePropertyPages") ));
    return S_FALSE; // no pages added
}

HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ComponentDataPropertySheetQueryPagesFor(
                                                      IN CFaxComponentData * pCompData,
                                                      IN CFaxDataObject * lpDataObject)
/*++

Routine Description:

    The default implementation of this routine returns S_FALSE to indicate there are no
    property pages to be added to the property sheet.

Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    lpDataobject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ComponentDataPropertySheetQueryPagesFor") ));
    return S_FALSE; // no pages for this object
}

// ***********************************************************
// IExtendPropertySheet for IComponent
HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ComponentPropertySheetCreatePropertyPages(
                                                        IN CFaxComponent * pComp,
                                                        IN LPPROPERTYSHEETCALLBACK lpProvider,
                                                        IN LONG_PTR handle,
                                                        IN CFaxDataObject * lpIDataObject)
/*++

Routine Description:

    The default implementation of this routine returns S_FALSE and does not add
    any pages to the property sheet.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lpProvider - a pointer to the IPropertySheetCallback used to insert pages
    handle - a handle to route messages with
    lpIDataobject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ComponentPropertySheetCreatePropertyPages") ));
    return S_FALSE; // no pages added
}

HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ComponentPropertySheetQueryPagesFor(
                                                  IN CFaxComponent * pComp,
                                                  IN CFaxDataObject * lpDataObject)
/*++

Routine Description:

    The default implementation of this routine returns S_FALSE to indicate there are no
    property pages to be added to the property sheet.

Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lpDataobject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ComponentPropertySheetQueryPagesFor") ));
    return S_FALSE; // no pages for this object
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IExtendContextMenu event handlers - default implementations
//
//

// ExtendContextMenu event handlers - default implementations
// we need seperate versions for IComponentData and IComponent
// in your code if you want differing behavior 
// in the scope and results panes.
//
// You can simply delegate one implementation to the other
// if you want the same behavior in both panes

// ***********************************************************
// IExtendContextMenu for IComponentData
HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ComponentDataContextMenuAddMenuItems(
                                                   IN CFaxComponentData * pCompData,
                                                   IN CFaxDataObject * piDataObject,
                                                   IN LPCONTEXTMENUCALLBACK piCallback,
                                                   IN OUT long __RPC_FAR *pInsertionAllowed )
/*++

Routine Description:

    The default implementation of this routine not add
    any items to the context menu.
    
Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    piDataObject - pointer to the dataobject associated with this node
    piCallback - a pointer to the IContextMenuCallback used to insert pages
    pInsertionAllowed - a set of flag indicating whether insertion is allowed.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ComponentDataContextMenuAddMenuItems") ));
    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ComponentDataContextMenuCommand(
                                              IN CFaxComponentData * pCompData,
                                              IN long lCommandID,
                                              IN CFaxDataObject * piDataObject)
/*++

Routine Description:

    The default implementation of the context menu handler does not do anything.
    
Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    lCommandID - the command ID
    piDataObject - pointer to the dataobject associated with this node
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ComponentDataContextMenuCommand") ));
    return S_OK;
}

// ***********************************************************
// IExtendContextMenu for IComponent
HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ComponentContextMenuAddMenuItems(
                                               IN CFaxComponent * pComp,
                                               IN CFaxDataObject * piDataObject,
                                               IN LPCONTEXTMENUCALLBACK piCallback,
                                               IN OUT long __RPC_FAR *pInsertionAllowed)
/*++

Routine Description:

    The default implementation of this routine not add
    any items to the context menu.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    piDataObject - pointer to the dataobject associated with this node
    piCallback - a pointer to the IContextMenuCallback used to insert pages
    pInsertionAllowed - a set of flag indicating whether insertion is allowed.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ComponentContextMenuAddMenuItems") ));
    return S_OK;
}

HRESULT 
STDMETHODCALLTYPE 
CInternalNode::ComponentContextMenuCommand(
                                          IN CFaxComponent * pComp,
                                          IN long lCommandID,
                                          IN CFaxDataObject * piDataObject)
/*++

Routine Description:

    The default implementation of the context menu handler does not do anything.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lCommandID - the command ID
    piDataObject - pointer to the dataobject associated with this node
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalNode::ComponentContextMenuCommand") ));
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IExtendControlbar - default implementations
//
//

// if we need more events later on for the controlbar, a
// default handler MUST be added here.

//
// these are for IComponent (result pane nodes)
//
HRESULT         
CInternalNode::ControlBarOnBtnClick(
                                   IN CFaxComponent* pComp, 
                                   IN CFaxDataObject * lpDataObject, 
                                   IN LPARAM param )
/*++

Routine Description:

    Handles a click on a toolbar button.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    lpDataObject - pointer to the dataobject associated with this node
    param - the parameter for the message
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    // handle a command event here
    return S_OK;
}

HRESULT         
CInternalNode::ControlBarOnSelect(
                                 IN CFaxComponent* pComp, 
                                 IN LPARAM arg, 
                                 IN CFaxDataObject * lpDataObject )
/*++

Routine Description:

    Add the toolbar here.
    
Arguments:

    pComp - a pointer to the IComponent associated with this node.
    arg - the parameter for the message
    lpDataObject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    // add and remove any custom control bars here depending on arg
    // if adding the first time, don't forget to CREATE the toolbars first
    // after the first time, just use attach and detach dependin on what you get for arg
    // you need the pComp->m_pControlbar interface pointer to set these things up.
    return S_OK;
}

//
// these are for IComponentData (scope pane nodes)
// MAY NOT WORK! (I don't use them.)
//
HRESULT         
CInternalNode::ControlBarOnBtnClick2(
                                    IN CFaxComponentData* pCompData, 
                                    IN CFaxDataObject * lpDataObject, 
                                    IN LPARAM param )
/*++

Routine Description:

    Handles a click on a toolbar button.
    
Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    lpDataObject - pointer to the dataobject associated with this node
    param - the parameter for the message
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    // handle a command event here
    return S_OK;
}
HRESULT         
CInternalNode::ControlBarOnSelect2(
                                  IN CFaxComponentData* pCompData,  
                                  IN LPARAM arg, 
                                  IN CFaxDataObject * lpDataObject )
/*++

Routine Description:

    Add the toolbar here.
    
Arguments:

    pCompData - a pointer to the IComponentData associated with this node.
    arg - the parameter for the message
    lpDataObject - pointer to the dataobject associated with this node
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    // add and remove any custom control bars here depending on arg
    // if adding the first time, don't forget to CREATE the toolbars first
    // after the first time, just use attach and detach dependin on what you get for arg
    // you need the pCompData->m_pControlbar interface pointer to set these things up.
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IDataObject special custom clipboard format handlers - default implementations
//
//

HRESULT 
CInternalNode::DataObjectRegisterFormats() 
/*++

Routine Description:

    Register custom clipboard formats that are specific to this
    node.

    The default implementation does nothing.
    
Arguments:

    None.
    
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    return S_OK;
}

HRESULT 
CInternalNode::DataObjectGetDataHere( 
                                      IN FORMATETC __RPC_FAR *pFormatEtc, 
                                      IN IStream * pstm )
/*++

Routine Description:

    Handles GetDataHere for custom clipboard formats specific to this
    particular node.

    The default implementation asserts since there should be no unhandled 
    formats.
    
Arguments:

    pFormatEtc - the FORMATETC struction indicating where and what the
                 client is requesting
    pstm - the stream to write the data to.
        
Return Value:

    HRESULT indicating SUCCEEDED() or FAILED()

--*/
{
    assert(FALSE);
    return DV_E_FORMATETC;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Scope Pane event handlers - default implementations
//
//

// Override these methods in your descendent classes in to handle scope pane events.
// if we need more events later on for the scope pane, a
// default handler MUST be added here.

HRESULT         
CInternalNode::ScopeOnExpand(
                            IN CFaxComponentData * pCompData, 
                            IN CFaxDataObject * lpDataObject, 
                            IN LPARAM arg, 
                            IN LPARAM param)
{   
    return S_FALSE;
}

HRESULT         
CInternalNode::ScopeOnDelete(
                            IN CFaxComponentData * pCompData, 
                            IN CFaxDataObject * lpDataObject, 
                            IN LPARAM arg, 
                            IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ScopeOnRename(
                            IN CFaxComponentData * pCompData, 
                            IN CFaxDataObject * lpDataObject, 
                            IN LPARAM arg, 
                            IN LPARAM param)
{
    return S_FALSE;
}


HRESULT         
CInternalNode::ScopeOnPropertyChange(
                                    IN CFaxComponentData * pCompData, 
                                    IN CFaxDataObject * lpDataObject, 
                                    IN LPARAM arg, 
                                    IN LPARAM param)
{
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Result Pane event handlers - default implementations
//
//

// Override these methods in your descendent classes in to handle result pane events.
// if we need more events later on for the result pane, a
// default handler MUST be added here.

HRESULT         
CInternalNode::ResultOnActivate(
                               IN CFaxComponent* pComp, 
                               IN CFaxDataObject * lpDataObject, 
                               IN LPARAM arg, 
                               IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnAddImages(
                                IN CFaxComponent* pComp, 
                                IN CFaxDataObject * lpDataObject, 
                                IN LPARAM arg, 
                                IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnButtonClick(
                                  IN CFaxComponent* pComp, 
                                  IN CFaxDataObject * lpDataObject, 
                                  IN LPARAM arg, 
                                  IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnClick(
                            IN CFaxComponent* pComp, 
                            IN CFaxDataObject * lpDataObject, 
                            IN LPARAM arg, 
                            IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnDoubleClick(
                                  IN CFaxComponent* pComp, 
                                  IN CFaxDataObject * lpDataObject, 
                                  IN LPARAM arg, 
                                  IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnDelete(
                             IN CFaxComponent* pComp, 
                             IN CFaxDataObject * lpDataObject, 
                             IN LPARAM arg, 
                             IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnExpand(
                             IN CFaxComponent* pComp, 
                             IN CFaxDataObject * lpDataObject, 
                             IN LPARAM arg, 
                             IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnMinimized(
                                IN CFaxComponent* pComp, 
                                IN CFaxDataObject * lpDataObject, 
                                IN LPARAM arg, 
                                IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnPropertyChange(
                                     IN CFaxComponent* pComp, 
                                     IN CFaxDataObject * lpDataObject, 
                                     IN LPARAM arg, 
                                     IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnQueryPaste(
                                 IN CFaxComponent* pComp, 
                                 IN CFaxDataObject * lpDataObject, 
                                 IN LPARAM arg, 
                                 IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnRemoveChildren(
                                     IN CFaxComponent* pComp, 
                                     IN CFaxDataObject * lpDataObject, 
                                     IN LPARAM arg, 
                                     IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnRename(
                             IN CFaxComponent* pComp, 
                             IN CFaxDataObject * lpDataObject, 
                             IN LPARAM arg, 
                             IN LPARAM param)
{
    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnSelect(
                             IN CFaxComponent* pComp, 
                             IN CFaxDataObject * lpDataObject, 
                             IN LPARAM arg, 
                             IN LPARAM param)
{
    // set the default verb to OPEN
    pComp->m_pConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN );

    return S_FALSE;
}

HRESULT         
CInternalNode::ResultOnShow(
                           IN CFaxComponent* pComp, 
                           IN CFaxDataObject * lpDataObject, 
                           IN LPARAM arg, 
                           IN LPARAM param)
{
    // note this method needs to insert the images EVERY TIME IT IS CALLED.
    // if you override this method YOU MUST REMEMBER TO DO THIS OR YOUR ICONS WILL NOT SHOW UP.
    HRESULT         hr = S_OK;

    // setup my images in the imagelist
    if( arg == TRUE ) {
        // showing result pane
        hr = pComp->InsertIconsIntoImageList();
    }

    return hr;
}

HRESULT         
CInternalNode::ResultOnViewChange(
                                 IN CFaxComponent* pComp, 
                                 IN CFaxDataObject * lpDataObject, 
                                 IN LPARAM arg, 
                                 IN LPARAM param)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\iroot.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    iroot.cpp

Abstract:

    Internal implementation for the root subfolder.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#include "StdAfx.h"

#include "inode.h"          // base class
#include "iroot.h"          // root folder

#include "idevices.h"       // devices folder
#include "ilogging.h"       // logging folder

#include "faxsnapin.h"      // snapin 
#include "faxdataobj.h"     // dataobject
#include "faxhelper.h"      // ole helper functions
#include "faxstrt.h"        // string table
#include "faxsecinfo.h"     // fax security info

#include "dgenprop.h"       // general property sheet
#include "droutpri.h"       // routing priority property sheet
#include <aclui.h>          // acl editor property sheet

#pragma hdrstop

// context menu command
#define RECONNECT_SERVER        101

extern CStringTable * GlobalStringTable;

// Generated with uuidgen. Each node must have a GUID associated with it.
// This one is for the main root node.
const GUID GUID_RootNode = /* 8f39b047-3071-11d1-9067-00a0c90ab504 */
{
    0x8f39b047,
    0x3071,
    0x11d1,
    {0x90, 0x67, 0x00, 0xa0, 0xc9, 0x0a, 0xb5, 0x04}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Constructor and destructor
//
//

CInternalRoot::CInternalRoot(
                            IN CInternalNode * pParent, 
                            IN CFaxComponentData * pCompData ) 
: CInternalNode( this, pCompData )
/*++

Routine Description:

    Constructor

Arguments:

    pParent - pointer to parent node, in this case unused
    pCompData - pointer to IComponentData implementation for snapin global data

Return Value:

    None.    

--*/
{
    iDevices    = NULL;
    iLogging    = NULL;   

    targetFaxServName = NULL;           
    m_pCompData->m_FaxHandle = NULL;
    localNodeName = NULL;
    pMyPropSheet = NULL;
    pMyPropSheet2 = NULL;
    m_myPropPage = NULL;
}

CInternalRoot::~CInternalRoot()
/*++

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.    

--*/
{
    if(iDevices != NULL ) {
        delete iDevices;
    }
    if(iLogging != NULL ) {
        delete iLogging;
    }
    if(m_pCompData->m_FaxHandle != NULL ) {
        FaxClose( m_pCompData->m_FaxHandle ); // close the connection
        m_pCompData->m_FaxHandle = NULL;     
    }
    if(targetFaxServName != NULL ) {
        delete targetFaxServName;
    }

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Mandatory CInternalNode implementations.
//
//

const GUID * CInternalRoot::GetNodeGUID()
/*++

Routine Description:

    Returns the node's associated GUID.

Arguments:

    None.

Return Value:

    A const pointer to a binary GUID.    

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalRoot::GetNodeGUID") ));
    return &GUID_RootNode;
}

const LPTSTR 
CInternalRoot::GetNodeDisplayName()
/*++

Routine Description:

    Returns a const TSTR pointer to the node's display name.

Arguments:

    None.

Return Value:

    A const pointer to a TSTR.

--*/
{
//    DebugPrint(( TEXT("Trace: CInternalRoot::GetNodeDisplayName") ));
    if( localNodeName == NULL ) {
        if( targetFaxServName != NULL ) {
            // remote machine
            localNodeName = new TCHAR[  StringSize(  (::GlobalStringTable->GetString(IDS_ROOTNODENAME)) )
                                        + StringSize( targetFaxServName ) 
                                        + 1 ];

            assert( localNodeName != NULL );
            if (!localNodeName) {
                return NULL;
            }

            _tcscpy( localNodeName, ::GlobalStringTable->GetString(IDS_ROOTNODENAME) );
            _tcscat( localNodeName, targetFaxServName );
        } else {
            // local machine
            localNodeName = new TCHAR[  StringSize(  (::GlobalStringTable->GetString(IDS_ROOTNODENAME)) )
                                        + StringSize( ::GlobalStringTable->GetString(IDS_LOCALMACHINE) )
                                        + 1 ];

            assert( localNodeName != NULL );
            if (!localNodeName) {
                return NULL;
            }

            _tcscpy( localNodeName, ::GlobalStringTable->GetString(IDS_ROOTNODENAME) );
            _tcscat( localNodeName, ::GlobalStringTable->GetString(IDS_LOCALMACHINE) );
        }

    }

    return localNodeName;
}

const LONG_PTR
CInternalRoot::GetCookie()
/*++

Routine Description:

    Returns the cookie for this node.

Arguments:

    None.

Return Value:

    A const long containing the cookie for the pointer,
    in this case, a NULL, since the root node has no cookie.    

--*/
{
    DebugPrint(( TEXT("Root Node Cookie: NULL") ));
    return NULL; // root node has no cookie.
}

void         
CInternalRoot::SetMachine(
                         IN LPTSTR theName )
/*++

Routine Description:

    Sets the machine name for the root node. This is used by all other nodes
    to determine the target machine name.

Arguments:

    A LPTSTR pointing to the machine name. It will be string copied to an internal store.

Return Value:

    None.    

--*/
{
    if(theName != NULL ) {
        targetFaxServName = new TCHAR[ MAX_COMPUTERNAME_LENGTH + 1 ];
        if (!targetFaxServName) {
            return;
        }
        ZeroMemory( (PVOID) targetFaxServName, (MAX_COMPUTERNAME_LENGTH + 1) * sizeof( TCHAR ) );
        _tcsncpy( targetFaxServName, theName, MAX_COMPUTERNAME_LENGTH );
        targetFaxServName[MAX_COMPUTERNAME_LENGTH] = 0;
    } else {
        targetFaxServName = NULL;
    }
}

const LPTSTR
CInternalRoot::GetMachine()
/*++

Routine Description:

    Returns the machine name for the root node. This is used by all other
    nodes to determine the target machine name.

Arguments:

    None.

Return Value:

    A const LPTSTR pointing to the machine name. Do not free this string, it is an internal
    buffer.

--*/
{
    return targetFaxServName;
}    

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// 
// Internal Event Handlers
//
//

HRESULT
CInternalRoot::ScopeOnExpand(
                            IN CFaxComponentData * pCompData,
                            IN CFaxDataObject * pdo, 
                            IN LPARAM arg, 
                            IN LPARAM param )
/*++

Routine Description:

    Event handler for the MMCN_EXPAND message for the root node.

Arguments:

    pCompData - a pointer to the instance of IComponentData which this root node is associated with.
    pdo - a pointer to the data object associated with this node
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalRoot::ScopeOnExpand") ));

    INT             iResult;
    HRESULT         hr = S_OK;        
    LPCONSOLE       console = pCompData->m_pConsole;
    HANDLE          targetFaxServHandle = NULL;
    DWORD           descCount = 0;

    assert(console != NULL);    // make sure we QI'ed for the interface

    if(arg == TRUE) { // folder needs to be expanded
        DebugPrint(( TEXT("Trace: CInternalRoot::ScopeOnExpand - Expand folder") ));

        if(!pdo) {
            hr = console->MessageBox(::GlobalStringTable->GetString( IDS_CORRUPT_DATAOBJECT ), 
                                     ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                     MB_OK, 
                                     &iResult);
            hr = E_INVALIDARG;
            return hr;
        }

        // Make sure that what we are placing ourselves under is the root node!
        if(pdo->GetCookie() != NULL)
            return S_FALSE;

        assert(pdo->GetContext() == CCT_SCOPE);

        //
        // Open the fax server connection.
        //

        try {
            if( FaxConnectFaxServer( targetFaxServName, &targetFaxServHandle ) == FALSE ) {
                m_pCompData->NotifyRpcError( TRUE );
                hr = console->MessageBox(::GlobalStringTable->GetString( IDS_FAX_CONNECT_SERVER_FAIL ), 
                                         ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                         MB_OK, 
                                         &iResult);
                DebugPrint(( TEXT("Trace: CInternalRoot::ScopeOnExpand - open connection fail") ));        
                hr = E_UNEXPECTED;
            } else {
                // sucessful connect!
                m_pCompData->NotifyRpcError( FALSE );
            }            
        } catch( ... ) {
            m_pCompData->NotifyRpcError( TRUE );
            console->MessageBox(::GlobalStringTable->GetString( IDS_FAX_CONNECT_SERVER_FAIL ), 
                                     ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                     MB_OK, 
                                     &iResult);
            hr = E_UNEXPECTED;
            DebugPrint(( TEXT("Trace: CInternalRoot::ScopeOnExpand - open connection fail") ));        
        }

        //
        // short circuit if we failed to connect to faxsvc
        //
        if (FAILED(hr)) {
            return(hr);
        }

        m_pCompData->m_FaxHandle = targetFaxServHandle;

        //
        // Place our folder into the scope pane
        //

        // create a new internal representation of the devices folder.
        iDevices = new CInternalDevices( this, m_pCompData );        
        
        assert( iDevices != NULL );
        if (!iDevices) {
            return(E_OUTOFMEMORY);
        }
        
        // insert devices folder
        hr = InsertItem( iDevices, param );

        // create a new internal representation of the logging folder.
        iLogging = new CInternalLogging( this, m_pCompData );        
        
        assert( iLogging != NULL );
        if (!iLogging) {
            return(E_OUTOFMEMORY);
        }

        // insert logging folder
        hr = InsertItem( iLogging, param );
    } else if(arg == FALSE ) {
        DebugPrint(( TEXT("Trace: CInternalRoot::ScopeOnExpand - Contract folder") ));
    }

    return hr;    
}

HRESULT 
CInternalRoot::ResultOnShow(
                           IN CFaxComponent* pComp, 
                           IN CFaxDataObject * lpDataObject, 
                           IN LPARAM arg, 
                           IN LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_SHOW message for the root node.

Arguments:

    pCompData - a pointer to the instance of IComponentData which this root node is associated with.
    lpDataObject - a pointer to the data object containing context information for this node.
    pdo - a pointer to the data object associated with this node
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    LPHEADERCTRL    pIHeaderCtrl = pComp->m_pHeaderCtrl;    
    HRESULT         hr = S_OK;

    DebugPrint(( TEXT("Trace: CInternalRoot::ResultOnShow") ));

    assert( pIHeaderCtrl != NULL );

    if( arg == TRUE ) {
        do {
            // insert the icons into the image list
            hr = pComp->InsertIconsIntoImageList();
            assert( SUCCEEDED( hr ) );
            if( FAILED( hr ) ) {
                break;
            }

            hr = pIHeaderCtrl->InsertColumn( 0,  
                                             ::GlobalStringTable->GetString( IDS_ROOT_NAME ), 
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );
            if( FAILED( hr ) ) {
                break;
            }

            hr = pIHeaderCtrl->InsertColumn( 1, 
                                             ::GlobalStringTable->GetString( IDS_ROOT_DESC ),
                                             LVCFMT_LEFT, 
                                             MMCLV_AUTO );                                             
            if( FAILED( hr ) ) {
                break;
            }
        } while( 0 );
    }
    return hr;
}

HRESULT 
CInternalRoot::ResultOnSelect(
                             IN CFaxComponent* pComp, 
                             IN CFaxDataObject * lpDataObject, 
                             IN LPARAM arg, 
                             IN LPARAM param)
/*++

Routine Description:

    Event handler for the MMCN_SELECT message for the root node.

Arguments:

    pCompData - a pointer to the instance of IComponentData which this root node is associated with.
    pdo - a pointer to the data object associated with this node
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalRoot::ResultOnSelect") ));
    if( m_pCompData->QueryRpcError() == FALSE ) {
        pComp->m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );    
        pComp->m_pConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN );
    } else {
        pComp->m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, FALSE );        
        pComp->m_pConsoleVerb->SetDefaultVerb( MMC_VERB_NONE );
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// IExtendPropertySheet implementation
//
//

HRESULT 
STDMETHODCALLTYPE 
CInternalRoot::ComponentDataPropertySheetCreatePropertyPages(
                                                            IN CFaxComponentData * pCompData,
                                                            IN LPPROPERTYSHEETCALLBACK lpProvider,
                                                            IN LONG_PTR handle,
                                                            IN CFaxDataObject * lpIDataObject)
/*++

Routine Description:

    Event handler for the MMCN_EXPAND message for the root node.

Arguments:

    pCompData - a pointer to the instance of IComponentData which this root node is associated with.
    pdo - a pointer to the data object associated with this node
    arg, param - the arguements of the message

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::ComponentPropertySheetCreatePropertyPages") ));
    assert( lpIDataObject != NULL );
    assert( lpProvider != NULL );

    HRESULT                             hr;
    BOOL                                bResult = FALSE;
    PFAX_SECURITY_DESCRIPTOR            pSecurityDescriptor = NULL;
    CFaxSecurityInformation *           psi = NULL;
    DWORD                               descCount = 0;

    PFAX_GLOBAL_ROUTING_INFO            pRoutingMethod;    
    DWORD                               iRoutingMethodCount;
    DWORD                               i;
    WCHAR                               DllName[MAX_PATH];
    BOOL                                bUnknownMethod = FALSE;

    if( m_pCompData->QueryRpcError() == TRUE ) {
        assert( FALSE );
        return E_UNEXPECTED;   
    }

    if( lpIDataObject == NULL || lpProvider == NULL ) {
        assert(FALSE);
        return E_POINTER;
    }

    pMyPropSheet = new CFaxGeneralSettingsPropSheet( ::GlobalStringTable->GetInstance(), handle, this );
    if (!pMyPropSheet) {
        hr = E_OUTOFMEMORY;
        goto e0;
    }
    
    hr = lpProvider->AddPage( pMyPropSheet->GetHandle() );
    if (FAILED(hr)) {
        goto e1;        
    }

    try {
        //
        // do routing priority page
        //

        //
        // Check if we have non "default" extensions
        //
       

       if( !FaxEnumGlobalRoutingInfo( m_pCompData->m_FaxHandle, 
                                      &pRoutingMethod, 
                                      &iRoutingMethodCount ) ) {
           if (GetLastError() != ERROR_ACCESS_DENIED) {
               m_pCompData->NotifyRpcError( TRUE );
               assert(FALSE);
           }
           ::GlobalStringTable->SystemErrorMsg( GetLastError() );
           hr = E_UNEXPECTED;           
           goto e1;
       } else {

         // go through the routing methods ensuring that
         // we know of all of them
         DWORD retval;
         retval = ExpandEnvironmentStrings(MSFAX_EXTENSION,DllName,MAX_PATH);
         if (retval == 0 || retval > MAX_PATH) {
             hr = E_OUTOFMEMORY;
             goto e1;
         }

         for( i=0; i<iRoutingMethodCount; i++ ) {
            if(wcscmp( pRoutingMethod[i].ExtensionImageName, DllName ) != 0) {
               bUnknownMethod = TRUE;
               break;
            }
         }

         FaxFreeBuffer( (PVOID)pRoutingMethod );
         
         // if we bumped into a method we don't know
         // then we put up the routing property sheet
         if( bUnknownMethod == TRUE ) {       
            pMyPropSheet2 = new CFaxRoutePriPropSheet( ::GlobalStringTable->GetInstance(), handle, this, NULL );
            if (!pMyPropSheet2) {
                hr = E_OUTOFMEMORY;
                goto e1;
            }
            hr = lpProvider->AddPage( pMyPropSheet2->GetHandle() );
            if (FAILED(hr)) {
                goto e2;
            }
         }
         
       }       
    
       if( FaxGetSecurityDescriptorCount( m_pCompData->m_FaxHandle, &descCount ) ) {        
       // if there is only one descriptor we might as well just stick it in
       // the root node
            if( descCount == 1 ) {                
                psi = new CComObject<CFaxSecurityInformation>;
                if (!psi) {
                    hr = E_OUTOFMEMORY;
                    goto e2;
                }

                psi->SetOwner( this );
                if( SUCCEEDED( psi->SetSecurityDescriptor( 0 ) ) ) {
                    m_myPropPage = CreateSecurityPage( psi );
                    hr = lpProvider->AddPage( m_myPropPage );
                } else {
                    goto e3;                    
                }
    
                FaxFreeBuffer( (PVOID)pSecurityDescriptor );            
            }
        }
    } catch ( ... ) {
        assert( FALSE );
        DebugPrint(( TEXT("Trace: CInternalRoot::ComponentDataPropertySheetCreatePropertyPages - RPC connection fail") ));        
        m_pCompData->NotifyRpcError( TRUE );
        hr = E_UNEXPECTED;
    }

    return hr;

e3:
    if (psi) delete(psi);
e2: 
    if (pMyPropSheet2) delete(pMyPropSheet2);
e1:
    if (pMyPropSheet) delete(pMyPropSheet);
e0:
    return(hr);
}

HRESULT 
STDMETHODCALLTYPE 
CInternalRoot::ComponentDataPropertySheetQueryPagesFor(
                                                      IN CFaxComponentData * pCompData,
                                                      IN CFaxDataObject * lpDataObject)
/*++

Routine Description:

    Returns S_OK to indicated there are property pages for this node.

Arguments:

    pCompData - a pointer to the instance of IComponentData which this root node is associated with.
    lpDataObject - a pointer to the data object associated with this node    

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalDevice::ComponentPropertySheetQueryPagesFor") ));
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// IExtendContextMenu implementation
//
//

HRESULT
STDMETHODCALLTYPE 
CInternalRoot::ComponentDataContextMenuAddMenuItems(
                                                   IN CFaxComponentData * pCompData,
                                                   IN CFaxDataObject * piDataObject,
                                                   IN LPCONTEXTMENUCALLBACK piCallback,
                                                   IN OUT long __RPC_FAR *pInsertionAllowed)
/*++

Routine Description:

    Adds the context menu items to the root node.

Arguments:

    pCompData - a pointer to the instance of IComponentData which this root node is associated with.
    piDataObject - a pointer to the data object associated with this node
    piCallback - a pointer the the IContextMenuCallback supplied by the MMC
    pInsertionAllowed - a set of flags to indicate whether context menu insertion is allows

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{       
    DebugPrint(( TEXT("Trace: CInternalDevice::ComponentContextMenuAddMenuItems") ));

    CONTEXTMENUITEM menuItem;    
    HRESULT         hr = S_OK;

    if( !( *pInsertionAllowed | CCM_INSERTIONALLOWED_TOP ) ) {
        assert( FALSE );
        return E_UNEXPECTED;
    }

    if( m_pCompData->QueryRpcError() == TRUE ) {

        // build the submenu items

        ZeroMemory( ( void* )&menuItem, sizeof( menuItem ) );

        menuItem.strName = ::GlobalStringTable->GetString( IDS_RECONNECT );
        menuItem.strStatusBarText = ::GlobalStringTable->GetString( IDS_RECONNECT_DESC );
        menuItem.lCommandID = RECONNECT_SERVER;
        menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        menuItem.fFlags = MF_ENABLED;
        menuItem.fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;

        hr = piCallback->AddItem( &menuItem );
        if( FAILED(hr) ) {
            assert(FALSE);
            return hr;
        }

    }

    return hr;
}


HRESULT 
STDMETHODCALLTYPE 
CInternalRoot::ComponentDataContextMenuCommand(
                                              IN CFaxComponentData * pCompData,
                                              IN long lCommandID,
                                              IN CFaxDataObject * piDataObject)
/*++

Routine Description:

    Handles the context menu events.

Arguments:

    pCompData - a pointer to the instance of IComponentData which this root node is associated with.
    lCommandID - the command ID.
    piDataObject - a pointer to the data object associated with this node

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    DebugPrint(( TEXT("Trace: CInternalRoot::ComponentDataContextMenuCommand") ));

    HRESULT                 hr = S_OK;
    HANDLE                  targetFaxServHandle = NULL;
    int                     iResult;        

    do {
        switch( lCommandID ) {
            case RECONNECT_SERVER:
                //
                // Re-open the fax server connection.
                //

                try {

                    if( FaxConnectFaxServer( targetFaxServName, &targetFaxServHandle ) == FALSE ) {
                        m_pCompData->NotifyRpcError( TRUE );
                        hr = m_pCompData->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_FAX_CONNECT_SERVER_FAIL ), 
                                                                 ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                                                 MB_OK, 
                                                                 &iResult);
                        DebugPrint(( TEXT("Trace: CInternalRoot::ComponentDataContextMenuCommand - RE-OPEN connection fail") ));
                    } else {
                        // sucessful connect!
                        m_pCompData->NotifyRpcError( FALSE );                        
                    }

                } catch( ... ) {
                    m_pCompData->NotifyRpcError( TRUE );
                    m_pCompData->m_pConsole->MessageBox(::GlobalStringTable->GetString( IDS_FAX_CONNECT_SERVER_FAIL ), 
                                                             ::GlobalStringTable->GetString( IDS_ERR_TITLE ), 
                                                             MB_OK, 
                                                             &iResult);
                    DebugPrint(( TEXT("Trace: CInternalRoot::ComponentDataContextMenuCommand - RE-OPEN connection fail") ));
                    hr = E_UNEXPECTED;
                    break;
                }
                m_pCompData->m_FaxHandle = targetFaxServHandle;
                break;

            default:
                assert(FALSE);
                hr = E_UNEXPECTED;
                break;

        }

    } while( 0 );

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Utility Function
// 
//

HRESULT 
CInternalRoot::InsertItem(
                         IN CInternalNode * iCookie, 
                         IN LPARAM param )
/*++

Routine Description:

    Wrapper that inserts an item into a scope view pane given a cookie.

Arguments:

    iCookie - the cookie of the node that needs to be inserted into the view
    param - the HRESULTITEM of the parent to the node being inserted

Return Value:

    HRESULT which indicates SUCCEEDED() or FAILED()

--*/
{
    SCOPEDATAITEM sdi;
    LPCONSOLENAMESPACE consoleNameSpace = m_pCompData->m_pConsoleNameSpace;
    assert(consoleNameSpace != NULL); // make sure we QI'ed for the interface

    ZeroMemory(&sdi, sizeof sdi);
    sdi.mask        = SDI_STR       | // displayname is valid
                      SDI_PARAM     | // lParam is valid
                      SDI_IMAGE     | // nImage is valid
                      SDI_OPENIMAGE | // nOpenImage is valid
                      SDI_CHILDREN  | // cChildren is valid
                      SDI_PARENT;
    sdi.relativeID  = (HSCOPEITEM) param;
    sdi.nImage      = iCookie->GetNodeDisplayImage();
    sdi.nOpenImage  = iCookie->GetNodeDisplayOpenImage();
    sdi.displayname = MMC_CALLBACK;
    sdi.cChildren = 0;
    sdi.lParam = (LPARAM) iCookie; // The cookie

    return consoleNameSpace->InsertItem(&sdi);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\iroot.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    iroot.h

Abstract:

    Internal implementation for the root subfolder.

Environment:

    WIN32 User Mode

Author:

    Darwin Ouyang (t-darouy) 30-Sept-1997

--*/ 

#ifndef __IROOT_H_
#define __IROOT_H_

#include "inode.h"

class CInternalDevices;         // forward declarator
class CInternalLogging;         // forward declarator
class CInternalSecurity;        // forward declarator

class CFaxGeneralSettingsPropSheet; // forward decl
class CFaxRoutePriPropSheet;


#define MSFAX_EXTENSION         L"%systemroot%\\system32\\faxroute.dll"

class CInternalRoot : public CInternalNode
{
public:
    CInternalRoot( CInternalNode * pParent, CFaxComponentData * pCompData );
    ~CInternalRoot();

    // member functions

    virtual const GUID * GetNodeGUID();    
    virtual const LPTSTR GetNodeDisplayName();
    virtual const LONG_PTR GetCookie();
    virtual const LPTSTR GetMachine();
    virtual void         SetMachine( LPTSTR theName );
    virtual CInternalNode * GetThis() { return this; }

    // =========================================
    // Internal Event Handlers =================

    virtual HRESULT ScopeOnExpand( 
                                   /* [in] */ CFaxComponentData * pCompData,
                                   /* [in] */ CFaxDataObject * pDataObject, 
                                   /* [in] */ LPARAM arg, 
                                   /* [in] */ LPARAM param );
    virtual HRESULT ResultOnShow(
                                         CFaxComponent* pComp, 
                                         CFaxDataObject * lpDataObject, 
                                         LPARAM arg, 
                                         LPARAM param);

    virtual HRESULT ResultOnSelect(
                                   CFaxComponent* pComp, 
                                                CFaxDataObject * lpDataObject, 
                                                LPARAM arg, 
                                                LPARAM param);

    // =========================================
    // IExtendPropertySheet for IComponentData
    virtual HRESULT STDMETHODCALLTYPE ComponentDataPropertySheetCreatePropertyPages(
                                                                      /* [in] */ CFaxComponentData * pCompData,
                                                                      /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                                      /* [in] */ LONG_PTR handle,
                                                                      /* [in] */ CFaxDataObject * lpIDataObject);

    virtual HRESULT STDMETHODCALLTYPE ComponentDataPropertySheetQueryPagesFor(
                                                                /* [in] */ CFaxComponentData * pCompData,
                                                                /* [in] */ CFaxDataObject * lpDataObject);

    // =========================================
    // IExtendContextMenu for IComponentData
    virtual HRESULT STDMETHODCALLTYPE ComponentDataContextMenuAddMenuItems(
                                                             /* [in] */ CFaxComponentData * pCompData,
                                                             /* [in] */ CFaxDataObject * piDataObject,
                                                             /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                                             /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

    virtual HRESULT STDMETHODCALLTYPE ComponentDataContextMenuCommand(
                                                        /* [in] */ CFaxComponentData * pCompData,
                                                        /* [in] */ long lCommandID,
                                                        /* [in] */ CFaxDataObject * piDataObject);

    // =========================================
    // Helper Functions ========================

    HRESULT InsertItem( CInternalNode * iCookie, LPARAM param );

private:
    // =========================================
    // Internal Node Pointers ==================
    CInternalDevices *          iDevices;
    CInternalLogging *          iLogging;    

    CFaxGeneralSettingsPropSheet    *pMyPropSheet;
    CFaxRoutePriPropSheet           *pMyPropSheet2;
    HPROPSHEETPAGE                  m_myPropPage;

    // =========================================
    // Fax Machine Name and Connection Handle ==
    LPTSTR                      targetFaxServName;
    LPTSTR                      localNodeName;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\resource.h ===
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by faxadmin.rc
//

#define IDC_STATIC                      -1

//
// Project global strings
//
#define IDS_PROJNAME                    100
#define IDS_ROOTNODENAME                101
#define IDR_FAXSNAPIN                   101
#define IDS_COVERPAGESNODENAME          102
#define IDS_DEVICESNODENAME             103
#define IDS_LOGGINGNODENAME             104
#define IDS_PRINTERSNODENAME            105
#define IDS_PRIORITYNODENAME            106
#define IDS_STATUSNODENAME              107
#define IDS_LOCALMACHINE                108

//
// logging node strings
//
#define IDS_LOG_CATEGORY                109
#define IDS_LOG_LEVEL                   110
// The following 4 defines MUST BE CONTIGUOUS NUMBERS
// or CInternalLogging::ResultOnShow will FAIL!!
#define IDS_LOG_LEVEL_NONE              111
#define IDS_LOG_LEVEL_MIN               112
#define IDS_LOG_LEVEL_MED               113
#define IDS_LOG_LEVEL_MAX               114
// The following 4 defines MUST BE CONTIGUOUS NUMBERS
// or CInternalLogging::ResultOnShow will FAIL!!
#define IDS_LOG_LEVEL_NONE_DESC         115
#define IDS_LOG_LEVEL_MIN_DESC          116
#define IDS_LOG_LEVEL_MED_DESC          117
#define IDS_LOG_LEVEL_MAX_DESC          118
#define IDS_LOG_LEVEL_DESC              119

//
// coverpage node strings
//
#define IDS_CVRPG_NAME                  130
#define IDS_CVRPG_DESC                  131
#define IDS_FAX_COVERPAGE_LOC           132

// 
// device node strings
//
#define IDS_DEVICE_NAME                 140
#define IDS_DEVICE_TSID                 141
#define IDS_DEVICE_CSID                 142
// these must be contiguous and in order or this will not work!!
#define IDS_DEVICE_SEND_EN              143
#define IDS_DEVICE_RECV_EN              144
// these must be contiguous and in order or this will not work!!
#define IDS_DEVICE_STATUS                   145
#define IDS_DEVICE_STATUS_DIALING           146
#define IDS_DEVICE_STATUS_SENDING           147
#define IDS_DEVICE_STATUS_RECEIVING         148
#define IDS_DEVICE_STATUS_COMPLETED         149
#define IDS_DEVICE_STATUS_HANDLED           150
#define IDS_DEVICE_STATUS_UNAVAILABLE       151
#define IDS_DEVICE_STATUS_BUSY              152
#define IDS_DEVICE_STATUS_NO_ANSWER         153
#define IDS_DEVICE_STATUS_BAD_ADDRESS       154
#define IDS_DEVICE_STATUS_NO_DIAL_TONE      155
#define IDS_DEVICE_STATUS_DISCONNECTED      156
#define IDS_DEVICE_STATUS_FATAL_ERROR       157
#define IDS_DEVICE_STATUS_NOT_FAX_CALL      158
#define IDS_DEVICE_STATUS_CALL_DELAYED      159
#define IDS_DEVICE_STATUS_CALL_BLACKLIST    160
#define IDS_DEVICE_STATUS_INITIALIZING      161
#define IDS_DEVICE_STATUS_OFFLINE           162
#define IDS_DEVICE_STATUS_RINGING           163
//#define IDS_UNUSED                          164 // should cause asserts
//#define IDS_UNUSED                          165 // should cause asserts
#define IDS_DEVICE_STATUS_AVAILABLE         166
#define IDS_DEVICE_STATUS_ABORTING          167
#define IDS_DEVICE_STATUS_ROUTING           168
#define IDS_DEVICE_STATUS_ANSWERED          169

#define IDS_DEVICE_STATUS_UNKNOWN           170

#define IDS_DEVICE_CMENU_ENABLE             171
#define IDS_DEVICE_CMENU_ENABLE_DESC        172
#define IDS_DEVICE_SEND_EN_DESC             173
#define IDS_DEVICE_RECV_EN_DESC             174

#define IDS_DEVICE_PRI                      175
#define IDS_ERR_ASCII_ONLY                  176
#define IDS_ERR_ID_REQD                     177
#define IDS_DEVICE_INUSE                    178
#define IDS_DEVICE_MANUALANSWER             179
#define IDS_ERR_INVALID_RING                180

//
// Root node defines
//
#define IDS_ROOT_NAME                   250
#define IDS_ROOT_DESC                   251
#define IDS_LOGGING_FOLDER_DESC_ROOT    252
#define IDS_DEVICES_FOLDER_DESC_ROOT    253
#define IDS_PRIORITY_FOLDER_DESC_ROOT   254
#define IDS_SECURITY_FOLDER_DESC_ROOT   255
#define IDS_GENERIC_NODE                270
#define IDS_RECONNECT                   271
#define IDS_RECONNECT_DESC              272

//
// Security node defines
//
#define IDS_SECURITY_NODENAME           300
#define IDS_SECURITY_CAT_NODE_DESC      301
#define IDS_SECURITY_HEADER1            302
#define IDS_SECURITY_HEADER2            303

#define IDS_ALLOW                       304

#define IDS_FAXSEC_JOB_QRY              305
#define IDS_FAXSEC_JOB_SUB              306
#define IDS_FAXSEC_CONFIG_QRY           307
#define IDS_FAXSEC_CONFIG_SET           308
#define IDS_FAXSEC_PORT_QRY             309
#define IDS_FAXSEC_PORT_SET             310
#define IDS_FAXSEC_JOB_MNG              311

//
// Error messages
//
#define IDS_ERR_TITLE                   501
#define IDS_WRN_TITLE                   502
#define IDS_OUT_OF_MEMORY               503
#define IDS_CORRUPT_DATAOBJECT          504
#define IDS_FAX_CONNECT_SERVER_FAIL     505
#define IDS_LOADSTATE_ERR               506
#define IDS_SAVESTATE_ERR               507
#define IDS_FAX_RETR_CAT_FAIL           508
#define IDS_FAX_RETR_DEV_FAIL           509
#define IDS_BAD_ARCHIVE_PATH            510
#define IDS_ERR_LOCK_SERVICE_DB         511
#define IDS_ERR_QUERY_LOCK              512
#define IDS_ERR_OPEN_SERVICE            513
#define IDS_ERR_CHANGE_SERVICE          514
#define IDS_QUERY_LOCK                  515
#define IDS_ERR_CONNECT_SCM             516
#define IDS_PROP_SHEET_STILL_UP         517
#define IDS_NO_ARCHIVE_PATH             518
#define IDS_NO_MAPI                     519

#define IDS_YES                         575
#define IDS_NO                          576

//
// ISnapinAbout                    
//
#define IDS_SNAPIN_DESCRIPTION          600
#define IDS_SNAPIN_PROVIDER             601
#define IDS_SNAPIN_VERSION              602

//
// Select computer wizard page
//
#define IDP_IS_PAGE0                    1001
#define IDP_IS_PAGE0_TITLE              1002

// controls
#define IDDI_COMPNAME                   1028
#define IDDI_LOCAL_COMPUTER             1029
#define IDDI_REMOTE_COMPUTER            1030

#define IDDI_STATIC                     -1

//
// Defines for Devices property page
//
#define IDP_DEVICE_PROP_PAGE_1          1101
#define IDP_DEVICE_PROP_PAGE_1_TITLE    1102

// controls
#define IDDI_DEVICE_PROP_EDIT_TSID      1105
#define IDDI_DEVICE_PROP_EDIT_CSID      1106
#define IDDI_DEVICE_PROP_SPIN1          1107
#define IDDI_DEVICE_PROP_EDIT3          1108
#define IDDI_DEVICE_PROP_SPIN2          1109
#define IDDI_DEVICE_PROP_EDIT4          1110
#define IDDI_DEVICE_PROP_EDIT5          1111
#define IDDI_DEVICE_PROP_SPIN_RINGS     1112
#define IDDI_DEVICE_PROP_EDIT_RINGS     1113
#define IDDI_DEVICE_PROP_BUTTON1        1114
#define IDC_DEVICE_SEND_GRP             1115
#define IDC_STATIC_TSID                 1116
#define IDC_DEVICE_RECEIVE_GRP          1117
#define IDC_STATIC_CSID                 1118
#define IDC_STATIC_RINGS                1119
#define IDC_SEND                        1120
#define IDC_RECEIVE                     1121
#define IDC_STATIC_TSID1                1122
#define IDC_STATIC_CSID1                1123

//
// Defines for general property page
//

#define IDP_GENERAL_PROPS               1200
#define IDP_GENERAL_PROPS_TITLE         1201

#define IDC_RETRY_COUNT                 1202
#define IDC_RETRY_DELAY                 1203
#define IDC_KEEP_DAYS                   1204
#define IDC_ARCHIVE_PATH                1205
#define IDC_DISCOUNT_START              1206
#define IDC_DISCOUNT_END                1207
#define IDC_ARCHIVE_BROWSE              1208
#define IDC_PRINT_BANNER                1209
#define IDC_USE_TSID                    1210
#define IDC_ARCHIVE                     1211
#define IDC_FORCESERVERCP               1212
#define IDC_DISCOUNT_START_STATIC       1213
#define IDC_DISCOUNT_END_STATIC         1214
#define IDC_RETRY_GRP                   1215
#define IDC_STATIC_RETRY                1216
#define IDC_STATIC_RETRY_MINUTES        1217
#define IDC_STATIC_KEEPDAYS             1218
#define IDC_SEND_GRP                    1219
#define IDS_GET_ARCHIVE_DIRECTORY       1220
#define IDS_DIR_TOO_LONG                1221
#define IDC_TIMESTART                   1222
#define IDC_TIMEEND                     1223
#define IDS_TIME_FORMAT                 1224
#define IDC_STATIC_MAPI_PROFILE         1225
#define IDC_SERVER_MAPI_PROFILE         1226
#define IDS_24HTIME_FORMAT              1227
#define IDS_RTLTIME_FORMAT              1228

//
// Toolbar buttons
//

#define IDS_BTN_RAISE_PRI               1300
#define IDS_BTN_RAISE_PRI_TOOLTIP       1301
#define IDS_BTN_LOWER_PRI               1302
#define IDS_BTN_LOWER_PRI_TOOLTIP       1303

//
// Defines for route ext priority page
//

#define IDD_ROUTE_PRI                   1400
#define IDD_ROUTE_PRI_TITLE             1401
#define IDC_ROUTEPRI_UP                 1402
#define IDC_ROUTEPRI_DOWN               1403
#define IDC_ROUTE_EXTS                  1404
#define IDC_ROUTEPRI_TITLE              1405

#define IDS_ROUTE_MTD_LISTBOX_FORMAT    1406
#define IDS_ROUTE_MTD_LISTBOX_ENABLED   1407
#define IDS_ROUTE_MTD_LISTBOX_DISABLED  1408


//
// Icons
//
// must be sequential!!!
#define IDI_NODEICON                    5001
#define IDI_COVERPG                     5003
#define IDI_DIALING                     5004
#define IDI_FAXOPTIONS                  5005
#define IDI_FAXING                      5006
#define IDI_FAXSVR                      5007
#define IDI_FAXUSER                     5008
#define IDI_LOGGING                     5009
#define IDI_PRIORITY                    5010
#define IDI_RECEIVE                     5011
#define IDI_SEND                        5012
#define IDI_STATUS                      5013
#define IDI_USERINFO                    5014
#define IDI_UP                          5015
#define IDI_DOWN                        5016
#define IDI_SECURITY                    5017
// define for loop.
#define LAST_ICON                       5018

//
// Bitmaps for root static node
//
#define IDB_MAINLARGE                   1500
#define IDB_MAINSMALL                   1501
#define IDB_UP                          1502
#define IDB_DOWN                        1503

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1600
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         2000
#define _APS_NEXT_SYMED_VALUE           3000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\strings.h ===
//===========================//===========================//===========================//===========================
// This is the global table of string used in the snapin.
//
//===========================//===========================//===========================//===========================

#define BEGIN_STRING_TABLE( x )         STRING_TABLE x = {
#define STR(name)                       { name, NULL },
#define END_STRING_TABLE                { 0xFFFF, NULL} };

BEGIN_STRING_TABLE( CStringTable::StringTable[] )
    STR( IDS_PROJNAME )
    STR( IDS_ROOTNODENAME )

    STR( IDS_COVERPAGESNODENAME )
    STR( IDS_DEVICESNODENAME )
    STR( IDS_LOGGINGNODENAME )
    STR( IDS_PRINTERSNODENAME )
    STR( IDS_PRIORITYNODENAME )
    STR( IDS_STATUSNODENAME )
    STR( IDS_LOCALMACHINE )
    STR( IDS_LOG_CATEGORY )
    STR( IDS_LOG_LEVEL )
    STR( IDS_LOG_LEVEL_DESC )
    STR( IDS_LOG_LEVEL_NONE )
    STR( IDS_LOG_LEVEL_NONE_DESC )
    STR( IDS_LOG_LEVEL_MIN )
    STR( IDS_LOG_LEVEL_MIN_DESC )
    STR( IDS_LOG_LEVEL_MED )
    STR( IDS_LOG_LEVEL_MED_DESC )
    STR( IDS_LOG_LEVEL_MAX )
    STR( IDS_LOG_LEVEL_MAX_DESC )

    STR( IDS_CVRPG_NAME )
    STR( IDS_CVRPG_DESC )
    STR( IDS_FAX_COVERPAGE_LOC )

    STR( IDS_DEVICE_NAME    )
    STR( IDS_DEVICE_TSID    )
    STR( IDS_DEVICE_CSID    )
    STR( IDS_DEVICE_SEND_EN )
    STR( IDS_DEVICE_RECV_EN )

    STR( IDS_DEVICE_STATUS ) 
    STR( IDS_DEVICE_STATUS_DIALING        )
    STR( IDS_DEVICE_STATUS_SENDING        )
    STR( IDS_DEVICE_STATUS_RECEIVING      )
    STR( IDS_DEVICE_STATUS_COMPLETED      )
    STR( IDS_DEVICE_STATUS_HANDLED        )
    STR( IDS_DEVICE_STATUS_UNAVAILABLE    )
    STR( IDS_DEVICE_STATUS_BUSY           )
    STR( IDS_DEVICE_STATUS_NO_ANSWER      )
    STR( IDS_DEVICE_STATUS_BAD_ADDRESS    )
    STR( IDS_DEVICE_STATUS_NO_DIAL_TONE   )
    STR( IDS_DEVICE_STATUS_DISCONNECTED   )
    STR( IDS_DEVICE_STATUS_FATAL_ERROR    )
    STR( IDS_DEVICE_STATUS_NOT_FAX_CALL   )
    STR( IDS_DEVICE_STATUS_CALL_DELAYED   )
    STR( IDS_DEVICE_STATUS_CALL_BLACKLIST )
    STR( IDS_DEVICE_STATUS_INITIALIZING   )
    STR( IDS_DEVICE_STATUS_OFFLINE        )
    STR( IDS_DEVICE_STATUS_RINGING        )
    STR( IDS_DEVICE_STATUS_AVAILABLE      )
    STR( IDS_DEVICE_STATUS_ABORTING       )
    STR( IDS_DEVICE_STATUS_ROUTING        )
    STR( IDS_DEVICE_STATUS_ANSWERED       )
    STR( IDS_DEVICE_STATUS_UNKNOWN        )
    STR( IDS_DEVICE_CMENU_ENABLE          )
    STR( IDS_DEVICE_CMENU_ENABLE_DESC     )
    STR( IDS_DEVICE_SEND_EN_DESC )
    STR( IDS_DEVICE_RECV_EN_DESC )

    STR( IDS_ROOT_NAME                 )
    STR( IDS_ROOT_DESC                 )
    STR( IDS_LOGGING_FOLDER_DESC_ROOT  )
    STR( IDS_DEVICES_FOLDER_DESC_ROOT  )
    STR( IDS_PRIORITY_FOLDER_DESC_ROOT )
    STR( IDS_SECURITY_FOLDER_DESC_ROOT )
    STR( IDS_GENERIC_NODE )
    STR( IDS_RECONNECT )
    STR( IDS_RECONNECT_DESC )

    STR( IDS_SECURITY_NODENAME )
    STR( IDS_SECURITY_CAT_NODE_DESC    )
    STR( IDS_SECURITY_HEADER1          )
    STR( IDS_SECURITY_HEADER2          )   
    STR( IDS_ALLOW )

    STR( IDS_ERR_TITLE )
    STR( IDS_WRN_TITLE )
    STR( IDS_OUT_OF_MEMORY )
    STR( IDS_CORRUPT_DATAOBJECT )
    STR( IDS_FAX_CONNECT_SERVER_FAIL )
    STR( IDS_LOADSTATE_ERR )
    STR( IDS_SAVESTATE_ERR )
    STR( IDS_FAX_RETR_CAT_FAIL )
    STR( IDS_FAX_RETR_DEV_FAIL )
    STR( IDS_NO_ARCHIVE_PATH )
    STR( IDS_BAD_ARCHIVE_PATH )
    STR( IDS_TIME_FORMAT )
    STR( IDS_24HTIME_FORMAT )
    STR( IDS_RTLTIME_FORMAT )
    STR( IDS_ERR_LOCK_SERVICE_DB )
    STR( IDS_ERR_QUERY_LOCK )
    STR( IDS_ERR_OPEN_SERVICE )
    STR( IDS_ERR_CHANGE_SERVICE )
    STR( IDS_QUERY_LOCK )
    STR( IDS_ERR_CONNECT_SCM )
    STR( IDS_PROP_SHEET_STILL_UP )

    STR( IDS_YES )
    STR( IDS_NO )

    STR( IDS_SNAPIN_DESCRIPTION )
    STR( IDS_SNAPIN_PROVIDER )
    STR( IDS_SNAPIN_VERSION )

    STR( IDP_IS_PAGE0_TITLE )
    STR( IDP_DEVICE_PROP_PAGE_1_TITLE )
    STR( IDP_GENERAL_PROPS_TITLE )
    STR( IDS_ERR_ASCII_ONLY )
    STR( IDS_ERR_ID_REQD )
    STR( IDS_DEVICE_INUSE )
    STR( IDS_DEVICE_MANUALANSWER )
    STR( IDS_NO_MAPI )
    STR( IDS_ERR_INVALID_RING )

    STR( IDS_GET_ARCHIVE_DIRECTORY )
    STR( IDS_DIR_TOO_LONG )

    STR( IDS_BTN_RAISE_PRI         )
    STR( IDS_BTN_RAISE_PRI_TOOLTIP )
    STR( IDS_BTN_LOWER_PRI         )
    STR( IDS_BTN_LOWER_PRI_TOOLTIP )
    
    STR( IDS_DEVICE_PRI )

    STR( IDS_ROUTE_MTD_LISTBOX_FORMAT   )
    STR( IDS_ROUTE_MTD_LISTBOX_ENABLED  )
    STR( IDS_ROUTE_MTD_LISTBOX_DISABLED )

    STR( IDS_FAXSEC_JOB_QRY           )
    STR( IDS_FAXSEC_JOB_SUB           )
    STR( IDS_FAXSEC_CONFIG_QRY        )
    STR( IDS_FAXSEC_CONFIG_SET        )
    STR( IDS_FAXSEC_PORT_QRY          )
    STR( IDS_FAXSEC_PORT_SET          )

END_STRING_TABLE

#undef BEGIN_STRING_TABLE
#undef STR
#undef END_STRING_TABLE

//===========================//===========================//===========================//===========================
//===========================//===========================//===========================//===========================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__572BA80C_2FA7_11D1_9067_00A0C90AB504__INCLUDED_)
#define AFX_STDAFX_H__572BA80C_2FA7_11D1_9067_00A0C90AB504__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

#include <mmc.h>
#include <objidl.h>
#include <shlobj.h>
#include <shlwapi.h>

#ifdef DEBUG
#define _ATL_DEBUG_REFCOUNT
#define _ATL_DEBUG_QI
#endif
                    
#include <assert.h>

#ifndef DEBUG
#undef assert
#define assert( x ) 
#endif

#include <winfax.h>                         // fax includes
#include <winfaxp.h>                        // private fax includes
#include <..\..\inc\faxutil.h>

#include <atl21\atlbase.h>
#include "faxstrt.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

extern CStringTable * GlobalStringTable;

#include <atl21\atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__572BA80C_2FA7_11D1_9067_00A0C90AB504__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cfg\faxcfg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcpl.h

Abstract:

    Header file for fax configuration DLL

Environment:

        Windows NT fax configuration DLL

Revision History:

        02/27/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _FAXCPL_H_
#define _FAXCPL_H_

#include <windows.h>
#include <windowsx.h>
#include <winfax.h>

#include "faxcfg.h"
#include "faxutil.h"
#include "faxreg.h"
#include "faxcfgrs.h"
#include "faxhelp.h"

#define FAX_DRIVER_NAME         TEXT("Windows NT Fax Driver")

#define CLIENT_OPTIONS_PAGE     0
#define CLIENT_COVERPG_PAGE     1
#define STATUS_OPTIONS_PAGE     2
#define ADVNCD_OPTIONS_PAGE     3

#define PATH_SEPARATOR '\\'

#define NUL 0
//
// Cover page filename extension and link filename extension
//

#define CP_FILENAME_EXT     TEXT(".cov")
#define LNK_FILENAME_EXT    TEXT(".lnk")
#define MAX_FILENAME_EXT    4

//
// Data structure for representing a list of cover pages:
//  the first nServerDirs paths refer to the server cover page directory
//  remaining paths contain user cover page directories
//

#define MAX_COVERPAGE_DIRS  8

typedef struct {

    BOOL    serverCP;
    INT     nDirs;
    LPTSTR  pDirPath[MAX_COVERPAGE_DIRS];

} CPDATA, *PCPDATA;

//
// Flag bits attached to each cover page in a listbox
//

#define CPFLAG_DIRINDEX 0x00FF
#define CPFLAG_LINK     0x0100


#define CPACTION_BROWSE 0
#define CPACTION_OPEN   1
#define CPACTION_NEW    2
#define CPACTION_REMOVE 3

#define EQUAL_STRING    0
#define FILENAME_EXT    '.'
#define MAX_STRING_LEN      MAX_PATH
#define MAX_MESSAGE_LEN     512

//#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))

#define MemAllocZ(size)     ((PVOID) MemAlloc((size)))

//#define MemFree(ptr)        { if (ptr) LocalFree((HLOCAL) (ptr)); }

#define AllocStringZ(cch)   MemAllocZ(sizeof(TCHAR) * (cch))
#define AllocStringZ(cch)   MemAllocZ(sizeof(TCHAR) * (cch))
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))
#define IsNulChar(c)        ((c) == NUL)


#define IsEmptyString(p)    ((p)[0] == NUL)

//
// globals
//
extern HINSTANCE ghInstance;

static ULONG_PTR userInfoHelpIDs[] =
{
    IDC_SENDER_NAME,            IDH_USERINFO_FULL_NAME,
    IDC_SENDER_FAX_NUMBER,      IDH_USERINFO_FAX_NUMBER,
    IDC_SENDER_MAILBOX,         IDH_USERINFO_EMAIL_ADDRESS,
    IDC_SENDER_COMPANY,         IDH_USERINFO_COMPANY,
    IDC_SENDER_ADDRESS,         IDH_USERINFO_ADDRESS,
    IDC_SENDER_TITLE,           IDH_USERINFO_TITLE,
    IDC_SENDER_DEPT,            IDH_USERINFO_DEPARTMENT,
    IDC_SENDER_OFFICE_LOC,      IDH_USERINFO_OFFICE_LOCATION,
    IDC_SENDER_OFFICE_TL,       IDH_USERINFO_WORK_PHONE,
    IDC_SENDER_HOME_TL,         IDH_USERINFO_HOME_PHONE,
    IDC_SENDER_BILLING_CODE,    IDH_USERINFO_BILLING_CODE,
    IDCSTATIC_FULLNAME,         IDH_USERINFO_FULL_NAME,
    IDCSTATIC_FAX_NUMBER_GROUP, IDH_USERINFO_RETURN_FAX_GRP,
    IDCSTATIC_COUNTRY,          IDH_USERINFO_RETURN_FAX_GRP,
    IDCSTATIC_FAX_NUMBER,       IDH_USERINFO_FAX_NUMBER,
    IDCSTATIC_MAILBOX,          IDH_USERINFO_EMAIL_ADDRESS,
    IDCSTATIC_TITLE,            IDH_USERINFO_TITLE,
    IDCSTATIC_COMPANY,          IDH_USERINFO_COMPANY,
    IDCSTATIC_OFFICE,           IDH_USERINFO_OFFICE_LOCATION,
    IDCSTATIC_DEPT,             IDH_USERINFO_DEPARTMENT,
    IDCSTATIC_HOME_PHONE,       IDH_USERINFO_HOME_PHONE,
    IDCSTATIC_WORK_PHONE,       IDH_USERINFO_WORK_PHONE,
    IDCSTATIC_ADDRESS,          IDH_USERINFO_ADDRESS,
    IDCSTATIC_FAX_NUMBER_GROUP, IDH_USERINFO_RETURN_FAX_GRP,
    IDCSTATIC_USERINFO_ICON,    IDH_INACTIVE,
    IDCSTATIC_USERINFO,         IDH_INACTIVE,
    IDCSTATIC_BILLING_CODE,     IDH_USERINFO_BILLING_CODE,    
    0,                          0
};

static ULONG_PTR statusMonitorHelpIDs[] = {
    IDC_STATUS_TASKBAR,         IDH_STATUS_DISPLAY_ON_TASKBAR,
    IDC_STATUS_ONTOP,           IDH_STATUS_ALWAYS_ON_TOP,
    IDC_STATUS_VISUAL,          IDH_STATUS_VISUAL_NOTIFICATION,
    IDC_STATUS_SOUND,           IDH_STATUS_SOUND_NOTIFICATION,
    IDC_STATUS_MANUAL,          IDH_STATUS_ENABLE_MANUAL_ANSWER,
    IDCSTATIC_STATUS_OPTIONS,   IDH_INACTIVE,
    IDCSTATIC_STATUS_ICON,      IDH_INACTIVE,
    IDC_DISPLAY_GRP,            IDH_INACTIVE,
    IDC_ARRIVE_GRP,             IDH_INACTIVE,
    0,                          0
};

static ULONG_PTR clientCoverpgHelpIDs[] = {
    IDC_COVERPG_LIST,           IDH_COVERPAGE_PERSONAL_LIST,
    IDC_COVERPG_ADD,            IDH_COVERPAGE_ADD,
    IDC_COVERPG_NEW,            IDH_COVERPAGE_NEW,
    IDC_COVERPG_OPEN,           IDH_COVERPAGE_OPEN,
    IDC_COVERPG_REMOVE,         IDH_COVERPAGE_REMOVE,
    IDCSTATIC_COVERPAGE_ICON,   IDH_INACTIVE,
    IDCSTATIC_COVER_PAGE,       IDH_INACTIVE,
    IDCSTATIC_COVERPG_DESCR,    IDH_INACTIVE,
    0,                          0
};

static ULONG_PTR advancedHelpIDs[] = {
    IDCSTATIC_ADVANCED_ICON,    IDH_INACTIVE,
    IDCSTATIC_ADVANCED_OPTIONS, IDH_INACTIVE,
    IDCSTATIC_MMC_DESC,         IDH_INACTIVE,
    IDC_LAUNCH_MMC,             IDH_LAUNCH_FAX_SERVICE_MANAGEMENT,
    IDCSTATIC_LAUNCH_MMC,       IDH_INACTIVE,
    IDC_LAUNCH_MMC_HELP,        IDH_HELP_BUTTON,
    IDCSTATIC_LAUNCH_MMC_HELP,  IDH_INACTIVE,
    IDC_ADD_PRINTER,            IDH_ADD_FAX_PRINTER,
    IDCSTATIC_ADD_PRINTER,      IDH_INACTIVE,
    0,                          0
};


static PULONG_PTR arrayHelpIDs[4] = 
{
    userInfoHelpIDs,
    clientCoverpgHelpIDs,
    statusMonitorHelpIDs,
    advancedHelpIDs
};

//
// prototypes
//
BOOL LoadWinfax();
VOID UnloadWinfax();

VOID
SetChangedFlag(
    HWND    hDlg,
    BOOL    changed
    );


BOOL
HandleHelpPopup(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    int     index
    );


//
// Generate a list of available user cover pages
//

VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hDlg
    );

//
// Perform various action to manage the list of cover pages
//

VOID
ManageCoverPageList(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    INT     action
    );


//
// Enable/disable buttons for manage cover page files
//

VOID
UpdateCoverPageControls(
    HWND    hDlg
    );

//
// Allocate memory to hold cover page information
//

PCPDATA
AllocCoverPageInfo();

//
// Free up memory used for cover page information
//

VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    );


INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pBuffer
    );

//
// Display an error message dialog
//

INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     formatStrId,
    INT     titleStrId,
    ...
    );

LPTSTR
MakeQuotedParameterString(
    LPTSTR  pInputStr
    );

//
// Find the cover page editor executable filename
//

LPTSTR
GetCoverPageEditor(
    VOID
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cfg\cpl.c ===
#include <windows.h>
#include <windowsx.h>
#include <winspool.h>

#include "faxutil.h"
#include "faxreg.h"
#include "faxcfgrs.h"
#include "faxhelp.h"
#include "faxcfg.h"
#include "devmode.h"

VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}


PVOID
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cbNeeded;

    if (!GetPrinter(hPrinter, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cbNeeded)) &&
        GetPrinter(hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded))
    {
        return pPrinterInfo;
    }

    DebugPrint((TEXT("GetPrinter failed: %d\n"), GetLastError()));
    MemFree(pPrinterInfo);
    return NULL;
}

INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     titleStrId,
    INT     formatStrId,
    ...
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    type - Specifies the type of message box to be displayed
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    Same as the return value from MessageBox

--*/

{
    LPTSTR  pTitle, pFormat, pMessage;
    INT     result;
    va_list ap;

    pTitle = pFormat = pMessage = NULL;

    if ((pTitle = AllocStringZ(MAX_TITLE_LEN)) &&
        (pFormat = AllocStringZ(MAX_STRING_LEN)) &&
        (pMessage = AllocStringZ(MAX_MESSAGE_LEN)))
    {
        //
        // Load dialog box title string resource
        //

        if (titleStrId == 0)
            titleStrId = IDS_ERROR_CFGDLGTITLE;

        LoadString(ghInstance, titleStrId, pTitle, MAX_TITLE_LEN);

        //
        // Load message format string resource
        //

        LoadString(ghInstance, formatStrId, pFormat, MAX_STRING_LEN);

        //
        // Compose the message string
        //

        va_start(ap, formatStrId);
        wvsprintf(pMessage, pFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //

        if (type == 0)
            type = MB_OK | MB_ICONERROR;

        result = MessageBox(hwndParent, pMessage, pTitle, type);

    } else {

        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cfg\faxcfgrs.h ===
#define IDC_SENDER_NAME             101
#define IDC_SENDER_FAX_NUMBER       102
#define IDC_SENDER_MAILBOX          103
#define IDC_SENDER_COMPANY          104
#define IDC_SENDER_ADDRESS          105
#define IDC_SENDER_TITLE            106
#define IDC_SENDER_DEPT             107
#define IDC_SENDER_OFFICE_LOC       108
#define IDC_SENDER_OFFICE_TL        109
#define IDC_SENDER_HOME_TL          110
#define IDC_SENDER_BILLING_CODE     111

#define IDCSTATIC_FULLNAME          201
#define IDCSTATIC_FAX_NUMBER_GROUP  202
#define IDCSTATIC_COUNTRY           203
#define IDCSTATIC_FAX_NUMBER        204
#define IDCSTATIC_MAILBOX           205
#define IDCSTATIC_TITLE             206
#define IDCSTATIC_COMPANY           207
#define IDCSTATIC_OFFICE            208
#define IDCSTATIC_DEPT              209
#define IDCSTATIC_HOME_PHONE        210
#define IDCSTATIC_WORK_PHONE        211
#define IDCSTATIC_ADDRESS           212
#define IDCSTATIC_USERINFO_ICON     213
#define IDCSTATIC_USERINFO          214
#define IDCSTATIC_BILLING_CODE      215
#define IDCSTATIC_STATUS_ICON       216
#define IDCSTATIC_STATUS_OPTIONS    217
#define IDCSTATIC_COVERPAGE_ICON    218
#define IDCSTATIC_COVER_PAGE        219
#define IDC_COVERPG_LIST            250
#define IDC_COVERPG_OPEN            251
#define IDC_COVERPG_NEW             252
#define IDC_COVERPG_ADD             253
#define IDC_COVERPG_REMOVE          254
#define IDC_ARRIVE_GRP              255
#define IDC_DISPLAY_GRP             256
#define IDCSTATIC_COVERPG_DESCR     257
#define IDCSTATIC_ADVANCED_ICON     258
#define IDCSTATIC_ADVANCED_OPTIONS  259
#define IDC_LAUNCH_MMC              260
#define IDCSTATIC_MMC_DESC          261
#define IDCSTATIC_LAUNCH_MMC        262
#define IDC_LAUNCH_MMC_HELP         263
#define IDCSTATIC_LAUNCH_MMC_HELP   264
#define IDC_ADD_PRINTER             265
#define IDCSTATIC_ADD_PRINTER       266

#define IDI_USERINFO                301
#define IDI_STATUS                  302
#define IDI_COVERPG                 303
#define IDI_ADVANCED                304

#define IDD_USER_INFO               401
#define IDD_STATUS_OPTIONS          402
#define IDD_CLIENT_COVERPG          403
#define IDD_ADVANCED_OPTIONS        404

#define IDS_RESOLVE_LINK_FAILED     500
#define IDS_CONFIRM_DELETE          501
#define IDS_DELETE_PROMPT           502
#define IDS_DELETE_FAILED           503
#define IDS_CREATE_LINK_FAILED      504
#define IDS_COPY_FILE_FAILED        505
#define IDS_FILENAME_TOOLONG        506
#define IDS_CP_DUPLICATE            507
#define IDS_NO_COVERPG_DIR          508
#define IDS_BAD_CP_EXTENSION        509
#define IDS_BROWSE_COVERPAGE        510
#define IDS_CP_FILETYPE             511
#define IDS_CANNOT_OPEN_CPEDITOR    512
#define IDS_CANNOT_FIND_CPEDITOR    513
#define IDS_ERROR_CFGDLGTITLE       514
#define IDS_MMC_CMDLINE             515
#define IDS_MMC_HELP_CMDLINE        516
#define IDS_SHELL32_CMDLINE         517
#define IDS_DEFAULT_PRINTER_NAME    518
#define IDS_ADD_PRINTER_CAPTION     519
#define IDS_ADD_PRINTER_SUCCESS     520
#define IDS_ADD_PRINTER_FAILED      521


#define IDC_STATUS_TASKBAR          900
#define IDC_STATUS_ONTOP            901
#define IDC_STATUS_VISUAL           902
#define IDC_STATUS_SOUND            903
#define IDC_STATUS_ANSWER           904
#define IDC_STATUS_MANUAL           905
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cfg\clientcp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clientcp.c

Abstract:

    Functions for handling events in the "Client Cover Page" tab of
    the fax client configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/


#include <windows.h>
#include <windowsx.h>
#include <winfax.h>
#include <shlobj.h>
#include <shellapi.h>
#include <tchar.h>
#include <commdlg.h>


#include "faxutil.h"
#include "faxreg.h"
#include "faxcfgrs.h"
#include "faxhelp.h"
#include "faxcfg.h"

PCPDATA pCPInfo;

BOOL
ClientCoverPageProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling the "Client Cover Page" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    INT     cmdId;

    switch (message) {

    case WM_INITDIALOG:

        pCPInfo = AllocCoverPageInfo();

        InitCoverPageList(pCPInfo, hDlg);
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_COVERPG_ADD:
        case IDC_COVERPG_NEW:
        case IDC_COVERPG_OPEN:
        case IDC_COVERPG_REMOVE:

            //
            // User clicked one of the buttons for managing cover page files
            //

            cmdId = (cmdId == IDC_COVERPG_REMOVE) ? CPACTION_REMOVE :
                    (cmdId == IDC_COVERPG_OPEN) ? CPACTION_OPEN :
                    (cmdId == IDC_COVERPG_NEW) ? CPACTION_NEW : CPACTION_BROWSE;

            ManageCoverPageList(hDlg,
                                pCPInfo,
                                GetDlgItem(hDlg, IDC_COVERPG_LIST),
                                cmdId);
            break;

        case IDC_COVERPG_LIST:

            switch (GET_WM_COMMAND_CMD(wParam, lParam)) {

            case LBN_SELCHANGE:

                UpdateCoverPageControls(hDlg);
                break;

            case LBN_DBLCLK:

                //
                // Double-clicking in the cover page list is equivalent
                // to pressing the "Open" button
                //

                ManageCoverPageList(hDlg,
                                    pCPInfo,
                                    GetDlgItem(hDlg, cmdId),
                                    CPACTION_OPEN);
                break;
            }
            break;

        default:

            return FALSE;
        }
        return TRUE;

    case WM_NOTIFY:

        switch (((NMHDR *) lParam)->code) {

        case PSN_SETACTIVE:

            break;

        case PSN_APPLY:

            return PSNRET_NOERROR;
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, CLIENT_COVERPG_PAGE);
    }

    return FALSE;
}

//
// Find the filename portion given a filename:
//  return a pointer to the '.' character if successful
//  NULL if there is no extension
//

#define FindFilenameExtension(pFilename) _tcsrchr(pFilename, TEXT(FILENAME_EXT))

VOID
HandleOpenCoverPage(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelected,
    INT     action
    )

/*++

Routine Description:

    Edit the currently selected cover page file or
    create a new cover page file

Arguments:

    hDlg - Handle to the dialog window on which the list of cover pages is displayed
    pCPInfo - Points to cover page information
    hwndList - Handle to cover page listbox window
    pSelected - Currently selected cover page filename
    action - Open an existing cover page file or create a new one

Return Value:

    NONE

--*/

{
    MSG			msg; // used for peeking messages
    DWORD		WaitObj;
    TCHAR       filename[MAX_PATH];
    LPTSTR      pExecutableName, pDirPath, pFilename;

    SHELLEXECUTEINFO shellExeInfo = {

        sizeof(SHELLEXECUTEINFO),
        SEE_MASK_NOCLOSEPROCESS,
        hDlg,
        NULL,
        NULL,
        NULL,
        NULL,
        SW_SHOWNORMAL,
    };

    //
    // Determine the default directory to run the cover page editor in:
    //

    if (action == CPACTION_NEW) {

        //
        // When creating a new cover page, the default directory is either
        // the server cover page directory or the user cover page directory
        // depending on whether the user is doing server adminstration.
        //

        pDirPath = pCPInfo->pDirPath[0];
        pFilename = NULL;
        SetEnvironmentVariable(TEXT("ClientCoverpage"),TEXT("1"));

    } else {

        INT flags;

        //
        // If the currently selected file is a link, resolve it first
        //

        lstrcpy(filename, pSelected);

        if (!IsEmptyString(pSelected) &&
            (flags = GetSelectedCoverPage(pCPInfo, hwndList, NULL)) > 0 &&
            (flags & CPFLAG_LINK) &&
            !ResolveShortcut(pSelected, filename))
        {
            DisplayMessageDialog(hDlg, 0, 0, IDS_RESOLVE_LINK_FAILED, pSelected);
            return;
        }

        //
        // Separate the filename into directory and filename components
        //

        if (pFilename = _tcsrchr(filename, TEXT(PATH_SEPARATOR))) {

            *pFilename++ = NUL;
            pDirPath = filename;

        } else {

            pFilename = filename;
            pDirPath = NULL;
        }
    }

    //
    // Find the "Cover Page Editor" executable
    //

    if ((pExecutableName = GetCoverPageEditor()) == NULL) {

        DisplayMessageDialog(hDlg, 0, 0, IDS_CANNOT_FIND_CPEDITOR);
        return;
    }

    //
    // Start cover page editor and wait for it to exit before proceeding
    //

    shellExeInfo.lpFile = pExecutableName;
    shellExeInfo.lpDirectory = pDirPath;
    shellExeInfo.lpParameters = MakeQuotedParameterString(pFilename);

    DebugPrint((TEXT("Cover page editor: %ws\n"), pExecutableName));
    DebugPrint((TEXT("Initial working directory: %ws\n"), pDirPath));
    DebugPrint((TEXT("Cover page filename: %ws\n"), shellExeInfo.lpParameters));

	// Disable the parent window.
	EnableWindow( GetParent(hDlg), FALSE );
    if (! ShellExecuteEx(&shellExeInfo)) {

        DisplayMessageDialog(hDlg, 0, 0, IDS_CANNOT_OPEN_CPEDITOR, pExecutableName);
        MemFree((PVOID)shellExeInfo.lpParameters);
        MemFree((PVOID)pExecutableName);
        return;
    }

    //
    // Refresh the list of cover page files when we're done
    //

    MemFree((PVOID)shellExeInfo.lpParameters);
    MemFree((PVOID)pExecutableName);

    while (TRUE) {
		// Wait for multiple objects in case of other messages coming.
        WaitObj = MsgWaitForMultipleObjects( 1, &shellExeInfo.hProcess, FALSE, INFINITE, QS_ALLINPUT );
        if (WaitObj == WAIT_OBJECT_0)
            break;
        
        // PeekMessage instead of GetMessage so we drain the message queue
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE )) {
			TranslateMessage( &msg );
			DispatchMessage( &msg );
        }
	}

	EnableWindow( GetParent(hDlg), TRUE );

    InitCoverPageList(pCPInfo, hDlg);

    SetEnvironmentVariable(TEXT("ClientCoverpage"),NULL);
}



VOID
HandleBrowseCoverPage(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelected
    )

/*++

Routine Description:

    Remove the currently selected cover page file

Arguments:

    hDlg - Handle to the dialog window on which the list of cover pages is displayed
    pCPInfo - Points to cover page information
    hwndList - Handle to cover page listbox window
    pSelected - Currently selected cover page filename

Return Value:

    NONE

--*/

{
    TCHAR   filename[MAX_PATH];
    TCHAR   title[MAX_TITLE_LEN];
    TCHAR   filter[MAX_TITLE_LEN];
    LPTSTR  pExtension, pFilename;
    LPTSTR  pCPDir;
    INT     n;

    OPENFILENAME ofn = {

        sizeof(OPENFILENAME),
        hDlg,
        ghInstance,
        filter,
        NULL,
        0,
        1,
        filename,
        MAX_PATH,
        NULL,
        0,
        NULL,
        title,
        OFN_FILEMUSTEXIST | OFN_NODEREFERENCELINKS | OFN_HIDEREADONLY,
        0,
        0,
        NULL,
        0,
        NULL,
        NULL,
    };

    //
    // Figure out what the initial directory should be
    //

    if (! IsEmptyString(pSelected)) {

        INT flags;

        //
        // Find out if the currently selected cover page file is a
        // user cover page and whether it's a link
        //

        if ((flags = GetSelectedCoverPage(pCPInfo, hwndList, NULL)) > 0 &&
            (flags & CPFLAG_LINK) &&
            ResolveShortcut(pSelected, filename))
        {
            //
            // Set the initial directory to the link destination
            //

            _tcscpy(pSelected, filename);

            if (pFilename = _tcsrchr(pSelected, TEXT(PATH_SEPARATOR))) {

                *pFilename = NUL;
                ofn.lpstrInitialDir = pSelected;
            }
        }
    }

    //
    // Compose the file-type filter string
    //

    LoadString(ghInstance, IDS_CP_FILETYPE, title, MAX_TITLE_LEN);
    wsprintf(filter, TEXT("%s%c*%s%c"), title, NUL, CP_FILENAME_EXT, NUL);

    LoadString(ghInstance, IDS_BROWSE_COVERPAGE, title, MAX_TITLE_LEN);
    filename[0] = NUL;

    //
    // Present the "Open File" dialog
    //

    if (! GetOpenFileName(&ofn))
        return;

    //
    // Make sure the selected filename has the correct extension
    //

    if ((pExtension = FindFilenameExtension(filename)) == NULL ||
         _tcsicmp(pExtension, CP_FILENAME_EXT) != EQUAL_STRING)
    {
        DisplayMessageDialog(hDlg, 0, 0, IDS_BAD_CP_EXTENSION, CP_FILENAME_EXT);
        return;
    }

    //
    // Check if the selected file is already inside one of the
    // cover page directories
    //

    for (n=0; n < pCPInfo->nDirs; n++) {
        TCHAR Path[MAX_PATH];

        if (_tcslen(pCPInfo->pDirPath[n]) + _tcslen(&filename[ofn.nFileOffset]) >= MAX_PATH) {
            DisplayMessageDialog(hDlg, 0, 0, IDS_FILENAME_TOOLONG);
            return;
        }
        
        _tcscpy(Path, pCPInfo->pDirPath[n]);
        _tcscat(Path, &filename[ofn.nFileOffset]);

        if (GetFileAttributes(Path) != 0xffffffff) {
            DisplayMessageDialog(hDlg, 0, 0, IDS_CP_DUPLICATE, filename);
            return;
        }
    }    

    //
    // Add the selected cover page file to the first cover page directory
    // Create the cover page directory if necessary
    //

    pCPDir = pCPInfo->pDirPath[0];

    if (!pCPDir || IsEmptyString(pCPDir)) {

        DisplayMessageDialog(hDlg, 0, 0, IDS_NO_COVERPG_DIR);
        return;
    }

    CreateDirectory(pCPDir, NULL);

    pFilename = &filename[ofn.nFileOffset];
    _tcscpy(pSelected, pCPDir);
    n = _tcslen(pSelected);

    if (n + _tcslen(pFilename) >= MAX_PATH - MAX_FILENAME_EXT || pFilename >= pExtension) {

        DisplayMessageDialog(hDlg, 0, 0, IDS_FILENAME_TOOLONG);
        return;
    }

    _tcsncpy(pSelected + n, pFilename, (INT)(pExtension - pFilename));
    n += (INT)(pExtension - pFilename);

    if (pCPInfo->serverCP) {

        //
        // Copy the physical file for server cover pages
        //

        _tcscpy(pSelected + n, CP_FILENAME_EXT);

        if (! CopyFile(filename, pSelected, TRUE)) {
            DisplayMessageDialog(hDlg, 0, 0, IDS_COPY_FILE_FAILED, filename, pSelected);
            return;
        }


    } else {

        //
        // Create the shortcut file for user cover page
        //

        _tcscpy(pSelected + n, LNK_FILENAME_EXT);

        if (GetFileAttributes(pSelected) != 0xffffffff) {
            DisplayMessageDialog(hDlg, 0, 0, IDS_CP_DUPLICATE, filename);
            return;
        }

        if (! CreateShortcut(pSelected, filename)) {

            DisplayMessageDialog(hDlg, 0, 0, IDS_CREATE_LINK_FAILED, pSelected, filename);
            return;
        }
    }

    //
    // Refresh the cover page list - we're being lazy here in that
    // we reset the entire list content
    //

    InitCoverPageList(pCPInfo, hDlg);
}


VOID
HandleRemoveCoverPage(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pFilename
    )

/*++

Routine Description:

    Remove the currently selected cover page file

Arguments:

    hDlg - Handle to the dialog window on which the list of cover pages is displayed
    pCPInfo - Points to cover page information
    hwndList - Handle to cover page listbox window
    pFilename - Currently selected cover page filename

Return Value:

    NONE

--*/

{
    //
    // Display the confirmation dialog before proceeding
    //

    if (DisplayMessageDialog(hDlg,
                             MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2,
                             IDS_CONFIRM_DELETE,
                             IDS_DELETE_PROMPT,
                             pFilename) == IDYES)
    {
        if (DeleteFile(pFilename)) {

            //
            // Update the list box if the file is successfully removed
            //

            INT selIndex, count;

            if ((selIndex = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0)) != LB_ERR) {

                SendMessage(hwndList, LB_DELETESTRING, selIndex, 0);

                if ((count = (INT)SendMessage(hwndList, LB_GETCOUNT, 0, 0)) > 0) {

                    count --;
                    SendMessage(hwndList, LB_SETCURSEL, min(selIndex, count), 0);
                }
            }

            UpdateCoverPageControls(hDlg);

        } else
            DisplayMessageDialog(hDlg, 0, 0, IDS_DELETE_FAILED, pFilename);
    }
}



VOID
ManageCoverPageList(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    INT     action
    )

/*++

Routine Description:

    Perform various action to manage the list of cover pages

Arguments:

    hDlg - Handle to the dialog window on which the list of cover pages is displayed
    pCPInfo - Points to cover page information
    hwndList - Handle to cover page listbox window
    action - What action to perform on the cover page list

Return Value:

    NONE

--*/

{
    TCHAR   filename[MAX_PATH];

    //
    // Get the name of currently selected cover page file
    //

    if (pCPInfo == NULL || hwndList == NULL)
        return;

    GetSelectedCoverPage(pCPInfo, hwndList, filename);

    //
    // Call appropriate function depends on the action parameter
    //

    switch (action) {

    case CPACTION_OPEN:

        if (IsEmptyString(filename))
            break;

    case CPACTION_NEW:

        HandleOpenCoverPage(hDlg, pCPInfo, hwndList, filename, action);
        break;

    case CPACTION_BROWSE:

        HandleBrowseCoverPage(hDlg, pCPInfo, hwndList, filename);
        break;

    case CPACTION_REMOVE:

        if (! IsEmptyString(filename))
            HandleRemoveCoverPage(hDlg, pCPInfo, hwndList, filename);
        break;
    }
}



VOID
UpdateCoverPageControls(
    HWND    hDlg
    )

/*++

Routine Description:

    Enable/disable buttons for manage cover page files

Arguments:

    hDlg - Handle to the property page containing the cover page controls

Return Value:

    NONE

--*/

{
    HWND    hwndOpen, hwndRemove;

    //
    // If all buttons are disabled, leave them alone here
    //

    if (! IsWindowEnabled(GetDlgItem(hDlg, IDC_COVERPG_NEW)))
        return;

    hwndOpen = GetDlgItem(hDlg, IDC_COVERPG_OPEN);
    hwndRemove = GetDlgItem(hDlg, IDC_COVERPG_REMOVE);

    if (SendDlgItemMessage(hDlg, IDC_COVERPG_LIST, LB_GETCURSEL, 0, 0) != LB_ERR) {

        EnableWindow(hwndOpen, TRUE);
        EnableWindow(hwndRemove, TRUE);

    } else {

        if (GetFocus() == hwndOpen || GetFocus() == hwndRemove)
            SetFocus(GetDlgItem(hDlg, IDC_COVERPG_NEW));

        EnableWindow(hwndOpen, FALSE);
        EnableWindow(hwndRemove, FALSE);
    }
}



VOID
AddCoverPagesToList(
    PCPDATA     pCPInfo,
    HWND        hwndList,
    INT         dirIndex
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a list

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to a list window
    dirIndex - Cover page directory index

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           filename[MAX_PATH];
    HANDLE          hFindFile;
    LPTSTR          pDirPath, pFilename, pExtension;
    INT             listIndex, dirLen, fileLen, flags;

    //
    // Copy the directory path to a local buffer
    //

    flags = dirIndex;
    pDirPath = pCPInfo->pDirPath[dirIndex];

    if (IsEmptyString(pDirPath))
        return;

    if ((dirLen = _tcslen(pDirPath)) >= MAX_PATH - MAX_FILENAME_EXT - 1) {

        DebugPrint(( TEXT("Directory name too long: %ws\n"), pDirPath));
        return;
    }

    _tcscpy(filename, pDirPath);

    //
    // Go through the following loop twice:
    //  Once to add the files with .ncp extension
    //  Again to add the files with .lnk extension
    //
    // Don't chase links for server based cover pages
    //

    do {

        //
        // Generate a specification for the files we're interested in
        //

        pFilename = &filename[dirLen];
        *pFilename = TEXT('*');
        _tcscpy(pFilename+1, (flags & CPFLAG_LINK) ? LNK_FILENAME_EXT : CP_FILENAME_EXT);

        //
        // Call FindFirstFile/FindNextFile to enumerate the files
        // matching our specification
        //

        hFindFile = FindFirstFile(filename, &findData);

        if (hFindFile != INVALID_HANDLE_VALUE) {

            do {

                //
                // Exclude directories and hidden files
                //

                if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY))
                    continue;

                //
                // Make sure we have enough room to store the full pathname
                //

                if ((fileLen = _tcslen(findData.cFileName)) <= MAX_FILENAME_EXT)
                    continue;

                if (fileLen + dirLen >= MAX_PATH) {

                    DebugPrint(( TEXT("Filename too long: %ws%ws\n"), pDirPath, findData.cFileName));
                    continue;
                }

                //
                // If we're chasing links, make sure the link refers to
                // a cover page file.
                //

                if (flags & CPFLAG_LINK) {

                    _tcscpy(pFilename, findData.cFileName);

                    if (! IsCoverPageShortcut(filename))
                        continue;
                }

                //
                // Don't display the filename extension
                //

                if (pExtension = FindFilenameExtension(findData.cFileName))
                    *pExtension = NUL;

                //
                // Add the cover page name to the list window
                //

                listIndex = (INT)SendMessage(hwndList,
                                             LB_ADDSTRING,
                                             0,
                                             (LPARAM) findData.cFileName);

                if (listIndex != LB_ERR)
                    SendMessage(hwndList, LB_SETITEMDATA, listIndex, flags);

            } while (FindNextFile(hFindFile, &findData));

            FindClose(hFindFile);
        }

        flags ^= CPFLAG_LINK;

    } while ((flags & CPFLAG_LINK) && ! pCPInfo->serverCP);
}



VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hDlg
    )

/*++

Routine Description:

    Generate a list of available cover pages

Arguments:

    pCPInfo - Points to cover page information
    hDlg - Handle to the dialog window containing cover page list

Return Value:

    NONE

--*/

{
    HWND    hwndList;
    INT     index, lastSel;

    if ((hwndList = GetDlgItem(hDlg, IDC_COVERPG_LIST)) && pCPInfo) {

        //
        // Disable redraw on the list and reset its content
        //

        if ((lastSel = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR)
            lastSel = 0;

        SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
        SendMessage(hwndList, LB_RESETCONTENT, 0, 0);

        //
        // Add cover pages to the list
        //

        for (index=0; index < pCPInfo->nDirs; index++)
            AddCoverPagesToList(pCPInfo, hwndList, index);

        //
        // Highlight the first cover page in the list
        //

        if ((index = (INT)SendMessage(hwndList, LB_GETCOUNT, 0, 0)) > 0 && lastSel >= index)
            lastSel = index - 1;

        SendMessage(hwndList, LB_SETCURSEL, lastSel, 0);

        //
        // Enable redraw on the list window
        //

        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

    } else if (hwndList) {

        SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
    }

    UpdateCoverPageControls(hDlg);
}



INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pBuffer
    )

/*++

Routine Description:

    Retrieve the currently selected cover page filename

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to the list window
    pBuffer - Points to a buffer for storing the selected cover page filename
        The size of the buffer is assumed to be MAX_PATH characters.
        if pBuffer is NULL, we assume the called is interested in the item flags

Return Value:

    Flags associated with the currently selected item
    Negative if there is an error

--*/

{
    LPTSTR      pDirPath;
    INT         selIndex, itemFlags;

    //
    // Default to empty string in case of an error
    //

    if (pBuffer)
        pBuffer[0] = NUL;

    if (pCPInfo == NULL || hwndList == NULL)
        return LB_ERR;

    //
    // Get currently selected item index
    //

    if ((selIndex = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR)
        return selIndex;

    //
    // Get the flags associated with the currently selected item
    //

    itemFlags = (INT)SendMessage(hwndList, LB_GETITEMDATA, selIndex, 0);

    if (itemFlags == LB_ERR || !pBuffer)
        return itemFlags;

    Assert((itemFlags & CPFLAG_DIRINDEX) < pCPInfo->nDirs);
    pDirPath = pCPInfo->pDirPath[itemFlags & CPFLAG_DIRINDEX];

    //
    // Assemble the full pathname for the cover page file
    //  directory prefix
    //  display name
    //  filename extension
    //

    while (*pBuffer++ = *pDirPath++)
        NULL;

    pBuffer--;

    SendMessage(hwndList, LB_GETTEXT, selIndex, (LPARAM) pBuffer);
    _tcscat(pBuffer, (itemFlags & CPFLAG_LINK) ? LNK_FILENAME_EXT : CP_FILENAME_EXT);

    return itemFlags;
}

VOID
AppendPathSeparator(
    LPTSTR  pDirPath
    )

/*++

Routine Description:

    Append a path separator (if necessary) at the end of a directory name

Arguments:

    pDirPath - Points to a directory name

Return Value:

    NONE

--*/

{
    INT length;


    //
    // Calculate the length of directory string
    //

    length = _tcslen(pDirPath);

    if (length >= MAX_PATH-1 || length < 1)
        return;

    //
    // If the last character is not a path separator,
    // append a path separator at the end
    //

    if (pDirPath[length-1] != TEXT(PATH_SEPARATOR)) {

        pDirPath[length] = TEXT(PATH_SEPARATOR);
        pDirPath[length+1] = NUL;
    }
}



PCPDATA
AllocCoverPageInfo(
    )

/*++

Routine Description:

    Allocate memory to hold cover page information

Arguments:

    hPrinter - Handle to a printer object if serverCP is TRUE

Return Value:

    Pointer to a CPDATA structure, NULL if there is an error

NOTE:

    Put this inside a critical section is the caller is concerned about
    being thread safe.

--*/

{
    PCPDATA pCPInfo;
    INT     nDirs;
    LPTSTR  pDirPath, pUserCPDir, pSavedPtr;


    if (pCPInfo = MemAlloc(sizeof(CPDATA))) {
    	ZeroMemory(pCPInfo,sizeof(CPDATA));
        if ( (pUserCPDir = MemAlloc(MAX_PATH)) && (pSavedPtr = pUserCPDir) && (GetClientCpDir(pUserCPDir,MAX_PATH)) ) {

            //
            // Find the directory in which the user cover pages are stored
            //

            while (*pUserCPDir && pCPInfo->nDirs < MAX_COVERPAGE_DIRS) {

                LPTSTR  pNextDir = pUserCPDir;

                //
                // Find the next semicolon character
                //

                while (*pNextDir && *pNextDir != TEXT(';'))
                    pNextDir++;

                if (*pNextDir != NUL)
                    *pNextDir++ = NUL;

                //
                // Make sure the directory name is not too long
                //

                if (_tcslen(pUserCPDir) < MAX_PATH) {

                    if (! (pDirPath = AllocStringZ(MAX_PATH)))
                        break;

                    pCPInfo->pDirPath[pCPInfo->nDirs++] = pDirPath;
                    _tcscpy(pDirPath, pUserCPDir);
                }

                pUserCPDir = pNextDir;
            }

            MemFree(pSavedPtr);
        }

        //
        // Append path separators at the end if necessary
        //

        for (nDirs=0; nDirs < pCPInfo->nDirs; nDirs++) {

            AppendPathSeparator(pCPInfo->pDirPath[nDirs]);
            DebugPrint(( TEXT("Cover page directory: %ws\n"), pCPInfo->pDirPath[nDirs]));
        }
    }

    return pCPInfo;
}



VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Free up memory used for cover page information

Arguments:

    pCPInfo - Points to cover page information to be freed

Return Value:

    NONE

--*/

{
    if (pCPInfo) {

        INT index;

        for (index=0; index < pCPInfo->nDirs; index++)
            MemFree(pCPInfo->pDirPath[index]);

        MemFree(pCPInfo);
    }
}



LPTSTR
MakeQuotedParameterString(
    LPTSTR  pInputStr
    )

/*++

Routine Description:

    Make a copy of the input string and make sure it's in the same form
    as expected by SHELLEXECUTEINFO.lpParameters.

Arguments:

    pInputStr - Specifies the input string

Return Value:

    Pointer to the processed parameter string

--*/

#define QUOTE   TEXT('"')

{
    LPTSTR  pStr, pDestStr;
    INT     length;

    //
    // Special case: if the input string is NULL, simply return NULL
    //

    if (pInputStr == NULL)
        return NULL;

    //
    // Figure out how long the resulting string is.
    // Initial value is 3 = two extra quotes plus NUL terminator.
    //

    for (pStr=pInputStr, length=3; *pStr; pStr++)
        length += (*pStr == QUOTE) ? 3 : 1;

    //
    // Copy the input string and replace quote characters
    //

    if (pStr = pDestStr = MemAlloc(length * sizeof(TCHAR))) {

        *pStr++ = QUOTE;

        while (*pInputStr) {

            if ((*pStr++ = *pInputStr++) == QUOTE) {

                *pStr++ = QUOTE;
                *pStr++ = QUOTE;
            }
        }

        *pStr++ = QUOTE;
        *pStr = NUL;
    }

    return pDestStr;
}


LPTSTR GetCoverPageEditor() 
{
    LPTSTR Location;

    HKEY hKey = OpenRegistryKey(HKEY_CURRENT_USER,REGKEY_FAX_SETUP,TRUE,0);

    if (hKey == NULL) {
        return NULL;
    }

    Location = GetRegistryStringExpand(hKey,REGVAL_CP_EDITOR,DEFAULT_COVERPAGE_EDITOR);

    RegCloseKey(hKey);

    return Location;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cfg\statopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    statopts.c

Abstract:

    Functions to handle status monitor options dialog

Environment:

        Fax configuration applet

Revision History:

        12/3/96 -georgeje-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <windowsx.h>
#include <winfax.h>
#include <shellapi.h>
#include <tchar.h>
#include <winspool.h>

#include "faxcfg.h"
#include "faxutil.h"
#include "faxreg.h"
#include "faxcfgrs.h"
#include "faxhelp.h"

HMODULE                         hModWinfax = NULL;
PFAXCONNECTFAXSERVER            pFaxConnectFaxServer;
PFAXCLOSE                       pFaxClose;
PFAXACCESSCHECK                 pFaxAccessCheck;


VOID
DoInitStatusOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Initializes the Status Options property sheet page with information from the registry

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    NONE

--*/


#define InitStatusOptionsCheckBox(id, pValueName, DefaultValue) \
    CheckDlgButton( hDlg, id, GetRegistryDword( hRegKey, pValueName ));

{
    HKEY    hRegKey;
    HANDLE  hFax;

    //
    // Open the user info registry key for reading
    //

    
    if (! (hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE,KEY_READ)))
        return;

    //
    // Fill in the edit text fields
    //

    InitStatusOptionsCheckBox(IDC_STATUS_TASKBAR, REGVAL_TASKBAR, BST_CHECKED);
    InitStatusOptionsCheckBox(IDC_STATUS_ONTOP, REGVAL_ALWAYS_ON_TOP, BST_CHECKED);
    InitStatusOptionsCheckBox(IDC_STATUS_VISUAL, REGVAL_VISUAL_NOTIFICATION, BST_CHECKED);
    InitStatusOptionsCheckBox(IDC_STATUS_SOUND, REGVAL_SOUND_NOTIFICATION, BST_UNCHECKED);
    InitStatusOptionsCheckBox(IDC_STATUS_MANUAL, REGVAL_ENABLE_MANUAL_ANSWER, BST_UNCHECKED);

    //
    // Close the registry key before returning to the caller
    //

    RegCloseKey(hRegKey);

    //
    // check if the user has permission to change manual answer, gray it out if he doesn't
    // 
    if (!LoadWinfax()) {
        return;
    }

    if (!pFaxConnectFaxServer(NULL, &hFax)) {
        return;
    }

    EnableWindow(GetDlgItem(hDlg, IDC_STATUS_MANUAL), pFaxAccessCheck(hFax, FAX_PORT_QUERY | FAX_PORT_SET));
    
    pFaxClose(hFax);

    UnloadWinfax();    
}


VOID
DoSaveStatusOptions(
    HWND    hDlg
    )   

/*++

Routine Description:

    Save the information on the Status Options property sheet page to registry

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    NONE

--*/

#define SaveStatusOptionsCheckBox(id, pValueName) \
            SetRegistryDword(hRegKey, pValueName, IsDlgButtonChecked(hDlg, id));

{
    HKEY    hRegKey;
    BOOL    fSaveConfig = FALSE;

    HWND    hWndFaxStat = NULL;

    //
    // Open the user registry key for writing and create it if necessary
    //

    if (! (hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO,TRUE, KEY_ALL_ACCESS)))
    {
        return;
    }

    SaveStatusOptionsCheckBox(IDC_STATUS_TASKBAR, REGVAL_TASKBAR);
    SaveStatusOptionsCheckBox(IDC_STATUS_ONTOP, REGVAL_ALWAYS_ON_TOP);
    SaveStatusOptionsCheckBox(IDC_STATUS_VISUAL, REGVAL_VISUAL_NOTIFICATION);
    SaveStatusOptionsCheckBox(IDC_STATUS_SOUND, REGVAL_SOUND_NOTIFICATION);
    SaveStatusOptionsCheckBox(IDC_STATUS_MANUAL, REGVAL_ENABLE_MANUAL_ANSWER);

    //
    // Close the registry key before returning to the caller
    //

    RegCloseKey(hRegKey);

    // See if faxstat is running
    hWndFaxStat = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxStat) {
        PostMessage(hWndFaxStat, WM_FAXSTAT_CONTROLPANEL, IsDlgButtonChecked(hDlg, IDC_STATUS_MANUAL), 0);
    }

}


BOOL
StatusOptionsProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling the "Status Options" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    LPNMHDR lpNMHdr = (LPNMHDR) lParam;

    switch (message) {

    case WM_INITDIALOG:

        DoInitStatusOptions( hDlg );
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_STATUS_TASKBAR:
        case IDC_STATUS_ONTOP:
        case IDC_STATUS_VISUAL:
        case IDC_STATUS_SOUND:
        case IDC_STATUS_MANUAL:

            if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                break;

        default:
            return FALSE;
        }

        SetChangedFlag(hDlg, TRUE);
        return TRUE;

    case WM_NOTIFY:

        switch (lpNMHdr->code) {

        case PSN_SETACTIVE:

            break;

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            DoSaveStatusOptions(hDlg);
            SetChangedFlag(hDlg, FALSE);
            return PSNRET_NOERROR;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam,STATUS_OPTIONS_PAGE);

    }

    return FALSE;
}

BOOL
AdvancedOptionsProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling the "Status Options" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    LPNMHDR lpNMHdr = (LPNMHDR) lParam;
    TCHAR Text[MAX_PATH], CommandLine[MAX_PATH], Caption[MAX_PATH];
    WORD  IconIndex;
    HICON hIconMMC, hIconMMCHelp, hIconAddPrinter;
    WCHAR FaxPrinterName[MAX_PATH];

    HANDLE  hPrinter, hChangeNotification;
    DWORD   dwWaitResult;

    switch (message) {

    case WM_INITDIALOG:
        // Load and set the mmc icon
        IconIndex = 0;
        LoadString(ghInstance, IDS_MMC_CMDLINE, Text, MAX_PATH);
        ExpandEnvironmentStrings(Text, CommandLine, MAX_PATH);
        hIconMMC = ExtractAssociatedIcon(ghInstance, CommandLine, &IconIndex);
        SendDlgItemMessage(hDlg, IDC_LAUNCH_MMC, BM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) hIconMMC);

        // Load and set the mmc help icon
        IconIndex = 0;
        LoadString(ghInstance, IDS_MMC_HELP_CMDLINE, Text, MAX_PATH);
        ExpandEnvironmentStrings(Text, CommandLine, MAX_PATH);
        hIconMMCHelp = ExtractAssociatedIcon(ghInstance, CommandLine, &IconIndex);
        SendDlgItemMessage(hDlg, IDC_LAUNCH_MMC_HELP, BM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) hIconMMCHelp);

        // Load and set the add printer icon
        IconIndex = 59;
        LoadString(ghInstance, IDS_SHELL32_CMDLINE, Text, MAX_PATH);
        ExpandEnvironmentStrings(Text, CommandLine, MAX_PATH);
        hIconAddPrinter = ExtractAssociatedIcon(ghInstance, CommandLine, &IconIndex);
        SendDlgItemMessage(hDlg, IDC_ADD_PRINTER, BM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) hIconAddPrinter);

        return TRUE;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDC_LAUNCH_MMC:
            LoadString(ghInstance, IDS_MMC_CMDLINE, Text, MAX_PATH);
            ExpandEnvironmentStrings(Text, CommandLine, MAX_PATH);
            ShellExecute(
                hDlg,
                NULL,
                CommandLine,
                TEXT("/s"),
                TEXT("."),
                SW_SHOWNORMAL
                );
            return TRUE;

        case IDC_LAUNCH_MMC_HELP:
            LoadString(ghInstance, IDS_MMC_HELP_CMDLINE, Text, MAX_PATH);
            ExpandEnvironmentStrings(Text, CommandLine, MAX_PATH);
            ShellExecute(
                hDlg,
                NULL,
                CommandLine,
                NULL,
                TEXT("."),
                SW_SHOWNORMAL
                );
            return TRUE;

        case IDC_ADD_PRINTER:
            // Initialize the handles
            hPrinter = NULL;
            hChangeNotification = INVALID_HANDLE_VALUE;

            // Initialize the wait result
            dwWaitResult = WAIT_TIMEOUT;

            // Open the local print server
            if (OpenPrinter(NULL, &hPrinter, NULL) == TRUE)
            {
                hChangeNotification = FindFirstPrinterChangeNotification(hPrinter, PRINTER_CHANGE_ADD_PRINTER, 0, NULL);
            }

            // Add the fax printer
            MyLoadString(ghInstance, IDS_DEFAULT_PRINTER_NAME, FaxPrinterName, MAX_PATH, GetSystemDefaultUILanguage());
            swprintf(Text, TEXT("printui.dll,PrintUIEntry %s /q /if /b \"%s\" /f \"%%SystemRoot%%\\inf\\ntprint.inf\" /r \"MSFAX:\" /m \"%s\" /l \"%%SystemRoot%%\\system32\""), IsProductSuite() ? L"/Z" : L"/z", FaxPrinterName, FAX_DRIVER_NAME);
            ExpandEnvironmentStrings(Text, CommandLine, MAX_PATH);

            ExpandEnvironmentStrings(TEXT("%systemroot%\\system32\\rundll32.exe"), Text, MAX_PATH);

            ShellExecute(
                hDlg,
                NULL,
                Text,
                CommandLine,
                TEXT("."),
                SW_SHOWNORMAL
                );

            if (hChangeNotification != INVALID_HANDLE_VALUE)
            {
                // Wait for the change notification
                dwWaitResult = WaitForSingleObject(hChangeNotification, 60000);

                // Close the change notification
                FindClosePrinterChangeNotification(hChangeNotification);
            }

            if (hPrinter != NULL)
            {
                // Close the local printer server
                ClosePrinter(hPrinter);
            }

            // Load the caption
            LoadString(ghInstance, IDS_ADD_PRINTER_CAPTION, Caption, MAX_PATH);

            // Load the text
            if (dwWaitResult == WAIT_OBJECT_0)
            {
                LoadString(ghInstance, IDS_ADD_PRINTER_SUCCESS, Text, MAX_PATH);
            }
            else
            {
                LoadString(ghInstance, IDS_ADD_PRINTER_FAILED, Text, MAX_PATH);
            }

            // Display the message
            MessageBox(hDlg, Text, Caption, dwWaitResult == WAIT_OBJECT_0 ? MB_ICONINFORMATION : MB_ICONWARNING);

            return TRUE;
        };

#if 0
    case WM_NOTIFY:

        switch (lpNMHdr->code) {

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            DoSaveStatusOptions(hDlg);
            SetChangedFlag(hDlg, FALSE);
            return PSNRET_NOERROR;
        }
        break;
#endif

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam,ADVNCD_OPTIONS_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cpl\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Declaration of resource ID constants

Environment:

        Windows NT fax configuration applet

Revision History:

        02/22/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//
// String resource IDs
//

#define IDS_FAX                         101
#define IDS_CONFIG_FAX                  102
#define IDS_FAX_TITLE                   103

//
// Icon resource IDs
//

#define IDI_FAX                         201

#endif  // !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cfg\userinfo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    userinfo.c

Abstract:

    Functions for handling events in the "User Info" tab of
    the fax client configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <windowsx.h>
#include <winspool.h>

#include "faxutil.h"
#include "faxreg.h"
#include "faxcfgrs.h"
#include "faxhelp.h"
#include "faxcfg.h"
#include "devmode.h"

#define FAX_DRIVER_NAME TEXT("Windows NT Fax Driver")

BOOL insideSetDlgItemText;
DWORD changeFlag;

VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )
;
#if 0

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}
#endif

VOID
DoInitUserInfo(
    HWND    hDlg
    )

/*++

Routine Description:

    Initializes the User Info property sheet page with information from the registry

Arguments:

    hDlg - Handle to the User Info property sheet page

Return Value:

    NONE

--*/

#define InitUserInfoTextField(id, pValueName){ \
        LPWSTR regStr = GetRegistryString(hRegKey, pValueName, L"");\
        SetDlgItemText(hDlg, id, regStr);\
        MemFree(regStr);}

{
    HKEY    hRegKey;

    //
    // Maximum length for various text fields in the dialog
    //

    static INT textLimits[] = {

        IDC_SENDER_NAME,            128,
        IDC_SENDER_FAX_NUMBER,      64,
        IDC_SENDER_MAILBOX,         MAX_EMAIL_ADDRESS,
        IDC_SENDER_COMPANY,         128,
        IDC_SENDER_ADDRESS,         256,
        IDC_SENDER_TITLE,           64,
        IDC_SENDER_DEPT,            64,
        IDC_SENDER_OFFICE_LOC,      64,
        IDC_SENDER_OFFICE_TL,       64,
        IDC_SENDER_HOME_TL,         64,
        IDC_SENDER_BILLING_CODE,    16,
        0,
    };

    LimitTextFields(hDlg, textLimits);

    //
    // Open the user info registry key for reading
    //

    if (! (hRegKey = OpenRegistryKey(HKEY_CURRENT_USER,REGKEY_FAX_USERINFO,TRUE,KEY_ALL_ACCESS)))
        return;

    //
    // Initialize the list of countries
    //

    insideSetDlgItemText = TRUE;

    //
    // Fill in the edit text fields
    //

    InitUserInfoTextField(IDC_SENDER_NAME, REGVAL_FULLNAME);
    InitUserInfoTextField(IDC_SENDER_FAX_NUMBER, REGVAL_FAX_NUMBER);
    InitUserInfoTextField(IDC_SENDER_MAILBOX, REGVAL_MAILBOX);
    InitUserInfoTextField(IDC_SENDER_COMPANY, REGVAL_COMPANY);
    InitUserInfoTextField(IDC_SENDER_TITLE, REGVAL_TITLE);
    InitUserInfoTextField(IDC_SENDER_ADDRESS, REGVAL_ADDRESS);
    InitUserInfoTextField(IDC_SENDER_DEPT, REGVAL_DEPT);
    InitUserInfoTextField(IDC_SENDER_OFFICE_LOC, REGVAL_OFFICE);
    InitUserInfoTextField(IDC_SENDER_HOME_TL, REGVAL_HOME_PHONE);
    InitUserInfoTextField(IDC_SENDER_OFFICE_TL, REGVAL_OFFICE_PHONE);
    InitUserInfoTextField(IDC_SENDER_BILLING_CODE, REGVAL_BILLING_CODE);

    insideSetDlgItemText = FALSE;

    //
    // Close the registry key before returning to the caller
    //

    RegCloseKey(hRegKey);
}

PVOID
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   level
    )
;
#if 0

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cbNeeded;

    if (!GetPrinter(hPrinter, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cbNeeded)) &&
        GetPrinter(hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded))
    {
        return pPrinterInfo;
    }

    DebugPrint((TEXT("GetPrinter failed: %d\n"), GetLastError()));
    MemFree(pPrinterInfo);
    return NULL;
}
#endif

BOOL
SetPrinterDevMode(
    LPTSTR ServerName,
    LPTSTR PrinterName,
    LPTSTR billingCode,
    LPTSTR emailAddress
    )
{
    HANDLE hPrinter = NULL;
    TCHAR PrinterBuffer[100];
    PPRINTER_INFO_9 pPrinterInfo9 = NULL;
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    PDRVDEVMODE dm = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {NULL, NULL, PRINTER_ALL_ACCESS};
    BOOL bSuccess = FALSE;

    if (ServerName) {
        wsprintf(PrinterBuffer,TEXT("\\\\%s\\%s"),ServerName,PrinterName);
    } else {
        wsprintf(PrinterBuffer,TEXT("%s"),PrinterName);
    }

    if (!OpenPrinter(PrinterBuffer,&hPrinter,&PrinterDefaults)) {
        DebugPrint(( TEXT("OpenPrinter failed, ec = %d\n"), GetLastError() ));
        goto exit;
    }


    //
    // Get the current user devmode
    //
    pPrinterInfo9 = MyGetPrinter(hPrinter,9);
    if (!pPrinterInfo9) {
        goto exit;
    }

    if (!pPrinterInfo9->pDevMode) {
        //
        // User devmode does not exist, so create devmode based on the printer devmode
        //
        pPrinterInfo2 = MyGetPrinter(hPrinter,2);
        if (!pPrinterInfo2 || !pPrinterInfo2->pDevMode) {
            goto exit;
        }

        dm = (PDRVDEVMODE) MemAlloc(sizeof(DRVDEVMODE));
        if (!dm) {
            goto exit;
        }

        //
        // Copy the printer devmode to the public devmode section of the user devmode
        //
        CopyMemory(&dm->dmPublic, pPrinterInfo2->pDevMode, sizeof(DEVMODE));
        dm->dmPublic.dmDriverExtra = sizeof(DMPRIVATE);

        //
        // Set the private devmode section of the user devmode
        //
        dm->dmPrivate.signature = DRIVER_SIGNATURE;
        dm->dmPrivate.flags = 0;
        dm->dmPrivate.sendCoverPage = TRUE;
        dm->dmPrivate.whenToSend = SENDFAX_ASAP;

        //
        // Set the billing code and email address
        //
        lstrcpy(dm->dmPrivate.billingCode,billingCode);
        lstrcpy(dm->dmPrivate.emailAddress,emailAddress);

        //
        // Patch up the pointer to the user devmode
        //
        pPrinterInfo9->pDevMode = (PDEVMODE) dm;
    }
    else {
        //
        // User devmode does exist, so be sure not to overwrite existing settings
        //
        dm = (PDRVDEVMODE) pPrinterInfo9->pDevMode;
        if (billingCode[0] && !dm->dmPrivate.billingCode[0]) {
            lstrcpy(dm->dmPrivate.billingCode,billingCode);
        }
        if (emailAddress[0] && !dm->dmPrivate.emailAddress[0]) {
            lstrcpy(dm->dmPrivate.emailAddress,emailAddress);
        }
    }

    //
    // Set the user devmode
    //
    if (!SetPrinter(hPrinter,9,(LPBYTE)pPrinterInfo9,0)) {
        DebugPrint(( TEXT("SetPrinter failed, ec = %d\n"), GetLastError() ));
        goto exit;
    }

    bSuccess = TRUE;

exit:
    if (hPrinter) {
        ClosePrinter(hPrinter);
    }

    if (pPrinterInfo2) {
        MemFree( pPrinterInfo2 );

        if (dm) {
            MemFree(dm);
        }
    }

    if (pPrinterInfo9) {
        MemFree( pPrinterInfo9 );
    }

    return bSuccess;


}


VOID
DoSaveUserInfo(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the User Info property sheet page to registry

Arguments:

    hDlg - Handle to the User Info property sheet page

Return Value:

    NONE

--*/

#define SaveUserInfoTextField(id, pValueName) { \
            if (! GetDlgItemText(hDlg, id, buffer, MAX_PATH)) \
                buffer[0] = 0; \
            SetRegistryString(hRegKey, pValueName, buffer); \
        }

#define  IsPrinterFaxPrinter(__PrinterInfo) \
        ((lstrcmp(__PrinterInfo.pDriverName,FAX_DRIVER_NAME) == 0) ? TRUE : FALSE )

{
    WCHAR   buffer[MAX_PATH];
    HKEY    hRegKey;
    WCHAR   BillingCode[MAX_BILLING_CODE+1];
    WCHAR   EmailAddress[MAX_EMAIL_ADDRESS+1];
    PPRINTER_INFO_2 pPrinterInfo;
    DWORD   dwPrinters,i;

    //
    // Open the user registry key for writing and create it if necessary
    //

    if (! changeFlag ||
        ! (hRegKey = OpenRegistryKey(HKEY_CURRENT_USER,REGKEY_FAX_USERINFO,TRUE,KEY_ALL_ACCESS)))
    {
        return;
    }

    SaveUserInfoTextField(IDC_SENDER_NAME, REGVAL_FULLNAME);
    SaveUserInfoTextField(IDC_SENDER_FAX_NUMBER, REGVAL_FAX_NUMBER);
    SaveUserInfoTextField(IDC_SENDER_MAILBOX, REGVAL_MAILBOX);
    SaveUserInfoTextField(IDC_SENDER_COMPANY, REGVAL_COMPANY);
    SaveUserInfoTextField(IDC_SENDER_TITLE, REGVAL_TITLE);
    SaveUserInfoTextField(IDC_SENDER_ADDRESS, REGVAL_ADDRESS);
    SaveUserInfoTextField(IDC_SENDER_DEPT, REGVAL_DEPT);
    SaveUserInfoTextField(IDC_SENDER_OFFICE_LOC, REGVAL_OFFICE);
    SaveUserInfoTextField(IDC_SENDER_HOME_TL, REGVAL_HOME_PHONE);
    SaveUserInfoTextField(IDC_SENDER_OFFICE_TL, REGVAL_OFFICE_PHONE);
    SaveUserInfoTextField(IDC_SENDER_BILLING_CODE, REGVAL_BILLING_CODE);

    //
    // Close the registry key before returning to the caller
    //

    RegCloseKey(hRegKey);

    //
    // write this information into the devmode for each fax printer
    //
    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                    2,
                                                    &dwPrinters,
                                                    PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS
                                                    );
    if (!pPrinterInfo) {
        return;
    }

    for (i = 0; i<dwPrinters;i++) {
        if (IsPrinterFaxPrinter(pPrinterInfo[i])) {
            //
            // note that we could use the devmode from printer_info_2 structure but we use GetPrinter/SetPrinter
            // instead
            //
            GetDlgItemText( hDlg, IDC_SENDER_BILLING_CODE, BillingCode, sizeof(BillingCode)/sizeof(WCHAR) );
            GetDlgItemText( hDlg, IDC_SENDER_MAILBOX, EmailAddress, sizeof(EmailAddress)/sizeof(WCHAR) );
            SetPrinterDevMode(pPrinterInfo[i].pServerName,
                              pPrinterInfo[i].pPrinterName,
                              BillingCode,
                              EmailAddress) ;
        }
    }
}


BOOL
UserInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling the "User Info" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (message) {

        case WM_INITDIALOG:
            //
            // Initialize the text fields with information from the registry
            //

            DoInitUserInfo(hDlg);
            return TRUE;

        case WM_COMMAND:

            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDC_SENDER_NAME:
                case IDC_SENDER_FAX_NUMBER:
                case IDC_SENDER_MAILBOX:
                case IDC_SENDER_COMPANY:
                case IDC_SENDER_ADDRESS:
                case IDC_SENDER_TITLE:
                case IDC_SENDER_DEPT:
                case IDC_SENDER_OFFICE_LOC:
                case IDC_SENDER_OFFICE_TL:
                case IDC_SENDER_HOME_TL:
                case IDC_SENDER_BILLING_CODE:

                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE && !insideSetDlgItemText)
                        break;

                default:
                    return FALSE;
            }

            SetChangedFlag( hDlg, TRUE );
            return TRUE;

        case WM_NOTIFY:

            switch (((NMHDR *) lParam)->code) {
                case PSN_SETACTIVE:
                    break;

                case PSN_APPLY:

                    //
                    // User pressed OK or Apply - validate inputs and save changes
                    //

                    DoSaveUserInfo(hDlg);
                    SetChangedFlag( hDlg, FALSE );
                    return PSNRET_NOERROR;
            }
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            return HandleHelpPopup(hDlg, message, wParam, lParam, CLIENT_OPTIONS_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cfg\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    utility functions

Environment:

        Fax configuration applet

Revision History:

        12/3/96 -georgeje-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <windowsx.h>
#include <winfax.h>

#include "faxcfg.h"
#include "faxutil.h"
#include "faxreg.h"
#include "faxcfgrs.h"
#include "faxhelp.h"


extern PFAXCONNECTFAXSERVER            pFaxConnectFaxServer;
extern PFAXCLOSE                       pFaxClose;
extern PFAXACCESSCHECK                 pFaxAccessCheck;
extern HMODULE                         hModWinfax;
extern DWORD                           changeFlag;

VOID
SetChangedFlag(
    HWND    hDlg,
    BOOL    changed
    )

/*++

Routine Description:

    Enable or disable the Apply button in the property sheet
    depending on if any of the dialog contents was changed

Arguments:

    hDlg - Handle to the property page window
    pageIndex - Specifies the index of current property page
    changed - Specifies whether the Apply button should be enabled

Return Value:

    NONE

--*/

{
    HWND    hwndPropSheet;

    //
    // Enable or disable the Apply button as appropriate
    //

    hwndPropSheet = GetParent(hDlg);

    if (changed) {
        PropSheet_Changed(hwndPropSheet, hDlg);
        changeFlag = TRUE;
    } else {
        changeFlag = FALSE;
        PropSheet_UnChanged(hwndPropSheet, hDlg);
    }
}


BOOL
HandleHelpPopup(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    int     index
    )

/*++

Routine Description:

    Handle context-sensitive help in property sheet pages

Arguments:

    hDlg, message, wParam, lParam - Parameters passed to the dialog procedure
    pageIndex - Specifies the index of the current property sheet page

Return Value:

    TRUE if the message is handle, FALSE otherwise

--*/

{
    if (message == WM_HELP) {

        WinHelp(((LPHELPINFO) lParam)->hItemHandle,
                FAXCFG_HELP_FILENAME,
                HELP_WM_HELP,
                (ULONG_PTR) arrayHelpIDs[index] );

    } else {

        WinHelp((HWND) wParam,
                FAXCFG_HELP_FILENAME,
                HELP_CONTEXTMENU,
                (ULONG_PTR) arrayHelpIDs[index] );
    }

    return TRUE;
}

VOID
UnloadWinfax(
)
{
    if (hModWinfax) {
        FreeLibrary(hModWinfax);
    }

    hModWinfax                = NULL;

    pFaxConnectFaxServer      = NULL;
    pFaxClose                 = NULL;
    pFaxAccessCheck           = NULL;
}

BOOL
LoadWinfax(
)
{
    //
    // try to load the winfax dll
    //

    hModWinfax = LoadLibrary(L"winfax.dll");
    if (hModWinfax == NULL) {
        return FALSE;
    }

    //
    // get the addresses of the functions that we need
    //

    pFaxConnectFaxServer      = (PFAXCONNECTFAXSERVER)      GetProcAddress(hModWinfax, "FaxConnectFaxServerW");
    pFaxClose                 = (PFAXCLOSE)                 GetProcAddress(hModWinfax, "FaxClose");
    pFaxAccessCheck           = (PFAXACCESSCHECK)           GetProcAddress(hModWinfax, "FaxAccessCheck");

    if ((pFaxConnectFaxServer == NULL) || (pFaxClose == NULL) || (pFaxAccessCheck == NULL)) {
        UnloadWinfax();
        return FALSE;
    }

    return TRUE;
}

#if 0
INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     titleStrId,
    INT     formatStrId,
    ...
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    type - Specifies the type of message box to be displayed
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    Same as the return value from MessageBox

--*/

{
    LPTSTR  pTitle, pFormat, pMessage;
    INT     result;
    va_list ap;

    pTitle = pFormat = pMessage = NULL;

    if ((pTitle = AllocStringZ(MAX_TITLE_LEN)) &&
        (pFormat = AllocStringZ(MAX_STRING_LEN)) &&
        (pMessage = AllocStringZ(MAX_MESSAGE_LEN)))
    {
        //
        // Load dialog box title string resource
        //

        if (titleStrId == 0)
            titleStrId = IDS_ERROR_CFGDLGTITLE;

        LoadString(ghInstance, titleStrId, pTitle, MAX_TITLE_LEN);

        //
        // Load message format string resource
        //

        LoadString(ghInstance, formatStrId, pFormat, MAX_STRING_LEN);

        //
        // Compose the message string
        //

        va_start(ap, formatStrId);
        wvsprintf(pMessage, pFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //

        if (type == 0)
            type = MB_OK | MB_ICONERROR;

        result = MessageBox(hwndParent, pMessage, pTitle, type);

    } else {

        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);
    return result;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxclient\cpl\faxcpl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcpl.c

Abstract:

    Implementation of the control panel applet entry point

Environment:

        Windows NT fax configuration applet

Revision History:

        02/27/96 -davidx-
                Created it.

        05/22/96 -davidx-
                Share the same DLL with remote admin program.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <commctrl.h>
#include <cpl.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxcfg.h"
#include "resource.h"
#include "faxcfgrs.h"



//
// Definition of global variables
//

HINSTANCE ghInstance;

UINT_PTR UserInfoDlgProc(HWND, UINT, WPARAM, LPARAM);
UINT_PTR StatusOptionsProc(HWND, UINT, WPARAM, LPARAM);
UINT_PTR ClientCoverPageProc(HWND, UINT, WPARAM, LPARAM);
UINT_PTR AdvancedOptionsProc(HWND, UINT, WPARAM, LPARAM);

BOOL
IsPriviledgedAccount(
    VOID
    );

BOOL
IsUserAdmin(
    VOID
    );


BOOL
DllEntryPoint(
    HINSTANCE   hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason) {
        case DLL_PROCESS_ATTACH:
            ghInstance = hModule;
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}

int
FaxConfigGetPages(
    HINSTANCE hInstance,
    HPROPSHEETPAGE *hPsp,
    DWORD Count
    )
{

    PROPSHEETPAGE psp[4];
    BOOL ShowAdvanced;

    ZeroMemory( &psp, sizeof(psp) );
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].hInstance = hInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_USER_INFO);
    psp[0].pfnDlgProc = UserInfoDlgProc;

    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].hInstance = hInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_CLIENT_COVERPG);
    psp[1].pfnDlgProc = ClientCoverPageProc;

	psp[2].dwSize = sizeof(PROPSHEETPAGE);
    psp[2].hInstance = hInstance;
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_STATUS_OPTIONS);
    psp[2].pfnDlgProc = StatusOptionsProc;

    hPsp[0] = CreatePropertySheetPage( &psp[0] );
	hPsp[1] = CreatePropertySheetPage( &psp[1] );
    hPsp[2] = CreatePropertySheetPage( &psp[2] );

    ShowAdvanced = IsPriviledgedAccount();
    if (ShowAdvanced) {
        psp[3].dwSize = sizeof(PROPSHEETPAGE);
        psp[3].hInstance = hInstance;
        psp[3].pszTemplate = MAKEINTRESOURCE(IDD_ADVANCED_OPTIONS);
        psp[3].pfnDlgProc = AdvancedOptionsProc;

        hPsp[3] = CreatePropertySheetPage( &psp[3] );
    }

    return ShowAdvanced ? 4 : 3;
}


INT
DoFaxConfiguration(
    HWND hwndCPl,
    LPTSTR pCmdLine
    )

/*++

Routine Description:

    Display fax configuration dialogs: client, server, or workstation

Arguments:

    hwndCPl - Handle to the Control Panel window

Return Value:

    0 if successful, -1 if there is an error

--*/

#define MAX_PAGES       16
#define MAX_TITLE_LEN   64

{
    HPROPSHEETPAGE  hPropSheetPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    TCHAR           dlgTitle[MAX_TITLE_LEN];
    INT             nPages,nStartPage;

    //
    // Get an array of property sheet page handles
    //

    nPages = FaxConfigGetPages( ghInstance, hPropSheetPages, MAX_PAGES );

    //
    // Fill out PROPSHEETHEADER structure
    //

    LoadString(ghInstance, IDS_FAX_TITLE, dlgTitle, MAX_TITLE_LEN);

    nStartPage = nStartPage = pCmdLine ? _ttol(pCmdLine) : 0;

    ZeroMemory( &psh, sizeof(psh) );
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEICONID;
    psh.hwndParent = hwndCPl;
    psh.hInstance = ghInstance;
    psh.pszIcon = MAKEINTRESOURCE(IDI_FAX);
    psh.pszCaption = dlgTitle;
    psh.nPages = nPages;
    psh.nStartPage = nStartPage;
    psh.phpage = hPropSheetPages;

    //
    // Display the property sheet
    //

    return (PropertySheet(&psh) == -1) ? -1 : 0;
}



LONG
CPlApplet(
    HWND    hwndCPl,
    UINT    uMsg,
    LPARAM  lParam1,
    LPARAM  lParam2
    )

/*++

Routine Description:

    Control panel applet entry point

Arguments:

    hwndCPl - Identifies the Control Panel window
    uMsg - Specifies the message being sent to the Control Panel applet
    lParam1 - Specifies additional message-specific information
    lParam2 - Specifies additional message-specific information

Return Value:

    Depends on the message

--*/

{
    static BOOL Failed = FALSE;


    switch (uMsg) {

    case CPL_INIT:
        return 1;

    case CPL_GETCOUNT:
        return 1;

    case CPL_INQUIRE:
        ((CPLINFO*)lParam2)->lData  = 0;
        ((CPLINFO*)lParam2)->idIcon = IDI_FAX;
        ((CPLINFO*)lParam2)->idName = IDS_FAX;
        ((CPLINFO*)lParam2)->idInfo = IDS_CONFIG_FAX;
        return 0;

    case CPL_DBLCLK:

        //
        // Treat this as CPL_STARTWPARMS with no parameter
        //
        if (Failed) {
            return 1;
        }
        return DoFaxConfiguration(hwndCPl,NULL);

    case CPL_STARTWPARMS:

        //
        // Display fax configuration dialog: client, server, or workstation
        //

        if (!DoFaxConfiguration(hwndCPl,(LPTSTR) lParam2)) {
            Failed = TRUE;
            return 1;
        }
        return 0;

    case CPL_EXIT:
        break;
    }

    return 0;
}

BOOL
IsPriviledgedAccount(
    VOID
    )
/*++

Routine Description:

    Determines if the currently logged on account is priviledged.  If it is priviledged, then
    we show the advanced tab in the control panel.  I'm still not sure what the priviledge
    check will be.

Arguments:

    NONE.

Return Value:

    TRUE if account is priviledged

--*/
{
    return IsUserAdmin();
}

//
// stolen from setupapi\security.c, so that we don't have to link to setupapi...
//
BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    b = AllocateAndInitializeSid(
            &NtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &AdministratorsGroup
            );

    if(b) {
        if (!CheckTokenMembership( NULL, AdministratorsGroup, &b)) {
            b = FALSE;
        }

        FreeSid(AdministratorsGroup);

    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\fspext\fsp.cpp ===
#include "stdafx.h"
#include "fspext.h"
#include "FSP.h"

/////////////////////////////////////////////////////////////////////////////
// CFSPComponentData
static const GUID CFSPGUID_NODETYPE = 
{    0xde58ae00,    0x4c0f,    0x11d1,    {0x90, 0x83, 0x00, 0xa0, 0xc9, 0x0a, 0xb5, 0x04}};
const GUID*  CFSPData::m_NODETYPE = &CFSPGUID_NODETYPE;
const TCHAR* CFSPData::m_SZNODETYPE = _T("de58ae00-4c0f-11d1-9083-00a0c90ab504");
const TCHAR* CFSPData::m_SZDISPLAY_NAME = _T("CFSP");
const CLSID* CFSPData::m_SNAPIN_CLASSID = &CLSID_FSP;


LRESULT CFSPPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //::SendMessage(GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
    SetChangedFlag (FALSE);
    switch (m_LoggingLevel) {
    case LOGGING_NONE:
        CheckDlgButton( IDC_LOG_NONE, TRUE);

        ::EnableWindow( GetDlgItem( IDC_LOGLOCATION ), FALSE );
        ::EnableWindow( GetDlgItem( IDC_LOCATION_LABEL ), FALSE );
        ::EnableWindow( GetDlgItem( IDC_LOGBROWSE ), FALSE );
        
        break;
    case LOGGING_ERRORS:
        CheckDlgButton( IDC_LOG_ERRORS, TRUE);      

        ::EnableWindow( GetDlgItem( IDC_LOGLOCATION ), TRUE );
        ::EnableWindow( GetDlgItem( IDC_LOCATION_LABEL ), TRUE );
        ::EnableWindow( GetDlgItem( IDC_LOGBROWSE ), TRUE );
        
        break;
    case LOGGING_ALL:                    
        CheckDlgButton( IDC_LOG_ALL , TRUE);

        ::EnableWindow( GetDlgItem( IDC_LOGLOCATION ), TRUE );
        ::EnableWindow( GetDlgItem( IDC_LOCATION_LABEL ), TRUE );
        ::EnableWindow( GetDlgItem( IDC_LOGBROWSE ), TRUE );

        break;
    default:        
        CheckDlgButton( IDC_LOG_NONE , TRUE);            

        ::EnableWindow( GetDlgItem( IDC_LOGLOCATION ), FALSE );
        ::EnableWindow( GetDlgItem( IDC_LOCATION_LABEL ), FALSE );
        ::EnableWindow( GetDlgItem( IDC_LOGBROWSE ), FALSE );        
    }

    SendDlgItemMessage( IDC_LOGLOCATION, EM_SETLIMITTEXT, MAX_PATH - 2, 0 );

    if (m_LoggingDirectory) {
        SetDlgItemText( IDC_LOGLOCATION, m_LoggingDirectory );
    }

    return 1;
}

VOID CFSPPage::SetChangedFlag( BOOL Flag ) {
    PropSheet_Changed( GetParent(), m_hWnd );
    m_bChanged = TRUE;
}


LRESULT CFSPPage::DisableLogging(INT code, INT id, HWND hwnd, BOOL& bHandled) 
{
    ::EnableWindow( GetDlgItem( IDC_LOGLOCATION ), FALSE );
    ::EnableWindow( GetDlgItem( IDC_LOCATION_LABEL ), FALSE );
    ::EnableWindow( GetDlgItem( IDC_LOGBROWSE ), FALSE );

    SetChangedFlag(TRUE);
    return 1;
}

LRESULT CFSPPage::EnableLogging(INT code, INT id, HWND hwnd, BOOL& bHandled)
{
    ::EnableWindow( GetDlgItem( IDC_LOGLOCATION ), TRUE );
    ::EnableWindow( GetDlgItem( IDC_LOCATION_LABEL ), TRUE );
    ::EnableWindow( GetDlgItem( IDC_LOGBROWSE ), TRUE );

    SetChangedFlag(TRUE);
    return 1;
}

LRESULT CFSPPage::OnBrowseDir(INT code, INT id, HWND hwnd, BOOL& bHandled) {
    BrowseForDirectory();
    return 1;
    }

BOOL CFSPPage::OnApply()
{
    //
    // if there aren't any changes, don't commit anything
    //
    if (!m_bChanged) {
        return TRUE;
    }

    if (IsDlgButtonChecked(IDC_LOG_NONE)== BST_CHECKED) {
        m_LoggingLevel = LOGGING_NONE;
    } else if (IsDlgButtonChecked(IDC_LOG_ERRORS)== BST_CHECKED) {
        m_LoggingLevel = LOGGING_ERRORS;
    } else if (IsDlgButtonChecked(IDC_LOG_ALL)== BST_CHECKED) {
        m_LoggingLevel = LOGGING_ALL;
    } else 
        m_LoggingLevel = LOGGING_NONE;

    if (m_LoggingLevel != LOGGING_NONE) {
        if (m_LoggingDirectory) {
            MemFree(m_LoggingDirectory);
        }
        m_LoggingDirectory = (LPTSTR) MemAlloc ( MAX_PATH );
        if (!GetDlgItemText( IDC_LOGLOCATION,m_LoggingDirectory, MAX_PATH - 1 ) ) {
            MessageBox(TEXT("You must enter a logging location"),
                       TEXT("Logging Error"),
                            MB_OK | MB_ICONEXCLAMATION);
            MemFree(m_LoggingDirectory);
            m_LoggingDirectory = NULL;
            ::SetFocus(GetDlgItem(IDC_LOGLOCATION));
            return FALSE;
        } else {
            if (!ValidateLogLocation()) {
                MessageBox(TEXT("You must enter a logging location"),
                           TEXT("Logging Error"),
                            MB_OK | MB_ICONEXCLAMATION);
                MemFree(m_LoggingDirectory);
                m_LoggingDirectory = NULL;
                ::SetFocus(GetDlgItem(IDC_LOGLOCATION));
                return FALSE;
            }
        }
    } else 
        if (m_LoggingDirectory) {
            MemFree(m_LoggingDirectory);
            m_LoggingDirectory = TEXT("");
        }
    
    if (!m_LogKey) {
        Assert(FALSE);
    }
    
    SetRegistryDword(m_LogKey,LOGLEVEL,m_LoggingLevel);
    SetRegistryString(m_LogKey,LOGLOCATION,m_LoggingDirectory);

    MessageBox(TEXT("You must restart the fax service for your logging changes to take effect"),
               TEXT("Logging Change"),
                    MB_OK);

    SetChangedFlag(FALSE);

    return TRUE;

}


BOOL
CFSPPage::BrowseForDirectory(
    )

/*++

Routine Description:

    Browse for a directory

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    textFieldId - Specifies the text field adjacent to the Browse button
    titleStrId - Specifies the title to be displayed in the browse window

Return Value:

    TRUE if successful, FALSE if the user presses Cancel

--*/

{
    LPITEMIDLIST    pidl;
    WCHAR           buffer[MAX_PATH];
    WCHAR           title[MAX_TITLE_LEN];
    VOID            SHFree(LPVOID);
    BOOL            result = FALSE;
    LPMALLOC        pMalloc;

    BROWSEINFO bi = {

        m_hWnd,
        NULL,
        buffer,
        title,
        BIF_RETURNONLYFSDIRS,
        NULL,
        (LPARAM) buffer,
    };

    if (! LoadString(_Module.m_hInst, IDS_BROWSE_TITLE, title, MAX_TITLE_LEN))
        title[0] = 0;

    if (! GetDlgItemText( IDC_LOGLOCATION, buffer, MAX_PATH))
        buffer[0] = 0;

    if (pidl = SHBrowseForFolder(&bi)) {

        if (SHGetPathFromIDList(pidl, buffer)) {

            if (wcslen(buffer) > MAX_PATH-2) {
                Assert(FALSE);
            } else {
                SetDlgItemText(IDC_LOGLOCATION, buffer);
                result = TRUE;
            }
        }

        SHGetMalloc(&pMalloc);

        pMalloc->Free(pidl);

        pMalloc->Release();
    }

    return result;
}

BOOL CFSPPage::ValidateLogLocation()
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR file[MAX_PATH];

    wsprintf(file,TEXT("%s\\faxt30.log"),m_LoggingDirectory);

    hFile = CreateFile(file,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        return FALSE;
    }
    
    CloseHandle(hFile);
    DeleteFile(m_LoggingDirectory);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\fspext\atlsnap.h ===
#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#ifndef UNICODE
#error "Only Unicode builds supported"
#endif

#include <mmc.h>
#include <commctrl.h>
#pragma comment(lib, "mmc.lib")


// Wrappers for propertypage and HBITMAP
#ifndef CPropertyPageImpl
#pragma comment(lib, "comctl32.lib")

template <class T>
class ATL_NO_VTABLE CPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		if(uMsg == PSPCB_CREATE)
		{
			_ASSERTE(hWnd == NULL);
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		_ASSERTE(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	BEGIN_MSG_MAP(CPropertyPageImpl< T >)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};
#endif

#ifndef CBitmap
class CBitmap
{
public:
	HBITMAP m_hBitmap;

	CBitmap(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
	{ }
	~CBitmap()
	{
		if(m_hBitmap != NULL)
			DeleteObject();
	}

	CBitmap& operator=(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
		return *this;
	}

	void Attach(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
	}
	HBITMAP Detach()
	{
		HBITMAP hBitmap = m_hBitmap;
		m_hBitmap = NULL;
		return hBitmap;
	}

	operator HBITMAP() const { return m_hBitmap; }

	HBITMAP LoadBitmap(LPCTSTR lpszResourceName)
	{
		_ASSERTE(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), lpszResourceName);
		return m_hBitmap;
	}
	HBITMAP LoadBitmap(UINT nIDResource)
	{
		_ASSERTE(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
		return m_hBitmap;
	}
	HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
	{
		_ASSERTE(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
		return m_hBitmap;
	}
	HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		_ASSERTE(m_hBitmap == NULL);
		m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
		return m_hBitmap;
	}
	HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
	{
		_ASSERTE(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
		return m_hBitmap;
	}
	HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
	{
		_ASSERTE(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
		return m_hBitmap;
	}
	HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
	{
		_ASSERTE(m_hBitmap == NULL);
		m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
	HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
	{
		_ASSERTE(m_hBitmap == NULL);
		m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}

	BOOL DeleteObject()
	{
		_ASSERTE(m_hBitmap != NULL);
		BOOL bRet = ::DeleteObject(m_hBitmap);
		if(bRet)
			m_hBitmap = NULL;
		return bRet;
	}

// Attributes
	int GetBitmap(BITMAP* pBitMap)
	{
		_ASSERTE(m_hBitmap != NULL);
		return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
	}
// Operations
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
	{
		_ASSERTE(m_hBitmap != NULL);
		return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{
		_ASSERTE(m_hBitmap != NULL);
		return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
	{
		_ASSERTE(m_hBitmap != NULL);
		return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
	}
	BOOL GetBitmapDimension(LPSIZE lpSize) const
	{
		_ASSERTE(m_hBitmap != NULL);
		return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
	}
};

#endif

class ATL_NO_VTABLE ISnapInDataInterface 
{
public:
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        long arg,
        long param,
        BOOL bComponentData,
        IConsole  *pConsole,
        IHeaderCtrl  *pHeader,
        IToolbar  *pToolbar) = 0;
    
    STDMETHOD(GetDispInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppVIewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed) = 0;
    
    STDMETHOD(Command)(long lCommandID) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        long handle,
		IUnknown* pUnk) = 0;
    
    STDMETHOD(QueryPagesFor)() = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
        MMC_NOTIFY_TYPE event,
        long arg,
        long param) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf, 
		LPSTREAM pStream) = 0;

	static ISnapInDataInterface* GetDataClass(IDataObject* pDataObj)
	{
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETCOOKIE, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(ISnapInDataInterface*));
		
		if (FAILED(pDataObj->GetDataHere(&formatetc, &stgmedium)))
			return NULL;
		
		ISnapInDataInterface* pTemp = *(ISnapInDataInterface**)stgmedium.hGlobal;
		
		GlobalFree(stgmedium.hGlobal);
		
		return pTemp;
	}
	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(CCF_NODETYPE);;
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(CCF_SZNODETYPE);  
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(CCF_DISPLAY_NAME); 
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
		m_CCF_SNAPIN_GETCOOKIE	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETCOOKIE"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETCOOKIE;
};

template <class T>
class CSnapinObjectRootEx : public CComObjectRootEx< T >
{
public:
	ISnapInDataInterface* GetDataClass(IDataObject* pDataObject)
	{
		return ISnapInDataInterface::GetDataClass(pDataObject);
	}
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	ISnapInDataInterface* GetDataClass(IDataObject* pDataObject) \
	{ \
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { ISnapInDataInterface::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
\
		if (FAILED(pDataObject->GetDataHere(&formatetc, &stgmedium))) \
			return NULL; \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); 
		


#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			m_##dataClass.InitDataClass(pDataObject); \
			return &m_##dataClass; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return ISnapInDataInterface::GetDataClass(pDataObject); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			LPSTREAM pStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &pStream);
			if (SUCCEEDED(hr))
			{
				hr = m_pData->FillData(pformatetc->cfFormat, pStream);
				pStream->Release();
			}
		}

		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	ISnapInDataInterface* m_pData;
};


template <class T, class C>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
	CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> m_spConsoleNameSpace;
	CComQIPtr<IConsole, &IID_IConsole> m_spConsole;
	
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE(_T("IComponentDataImpl::Initialize\n"));

		if (pUnknown == NULL)
		{
			ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n"));
			return E_UNEXPECTED;
		}

		m_spConsoleNameSpace = pUnknown;
		if (m_spConsoleNameSpace == NULL)
		{
			ATLTRACE(_T("QI for IConsoleNameSpace failed\n"));
			return E_UNEXPECTED;
		}

		m_spConsole = pUnknown;
		if (m_spConsole == NULL)
		{
			ATLTRACE(_T("QI for IConsole failed\n"));
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE(_T("IComponentDataImpl::CreateComponent\n"));
		if (ppComponent == NULL)
		{
			ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
			return E_UNEXPECTED;
		}

		*ppComponent = NULL;
		
		CComObject< C >* pComponent;
		HRESULT hr = CComObject< C >::CreateInstance(&pComponent);
		if (FAILED(hr))
		{
			ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			return hr;
		}
		
		return pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
	}

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        long arg,
        long param)
	{
		ATLTRACE(_T("IComponentDataImpl::Notify\n"));
		if (lpDataObject == NULL)
		{
			ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n"));
			return E_UNEXPECTED;
		}

		ISnapInDataInterface* pData = ISnapInDataInterface::GetDataClass(lpDataObject);
		if (pData == NULL)
		{
			return E_UNEXPECTED;
		}
		return pData->Notify(event, arg, param, TRUE, m_spConsole, NULL, NULL);
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE(_T("IComponentDataImpl::Destroy\n"));

		m_spConsole.Release();
		m_spConsoleNameSpace.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(long cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n"));
		_ASSERTE(m_pNode != NULL);

		if (ppDataObject == NULL)
		{
			ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;

		if (cookie == NULL)
			return m_pNode->GetDataObject(ppDataObject);

		ISnapInDataInterface* pData = (ISnapInDataInterface*) cookie;
		return pData->GetDataObject(ppDataObject);
	}
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n"));

		if (pScopeDataItem == NULL)
		{
			ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
			return E_UNEXPECTED;
		}

		ISnapInDataInterface* pData= (ISnapInDataInterface*) pScopeDataItem->lParam;
		if (pData == NULL)
			pData = m_pNode;

		if (pData == NULL)
		{
			return E_UNEXPECTED;
		}
		return pData->GetDispInfo(pScopeDataItem);
	}
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
		return S_FALSE;
    }

	protected:
		ISnapInDataInterface* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
//Review all of these may not be required
	CComPtr<IConsole> m_spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> m_spHeaderCtrl;
	CComPtr<IImageList> m_spImageList;
	CComPtr<IConsoleVerb> m_spConsoleVerb;

    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE(_T("IComponentImpl::Initialize\n"));

		if (lpConsole == NULL)
		{
			ATLTRACE(_T("lpConsole is NULL\n"));
			return E_UNEXPECTED;
		}

		m_spConsole = lpConsole;

		m_spHeaderCtrl = lpConsole;
		if (m_spHeaderCtrl == NULL)
		{
			ATLTRACE(_T("QI for IHeaderCtrl failed\n"));
			return E_UNEXPECTED;
		}

		HRESULT hr = m_spConsole->SetHeader(m_spHeaderCtrl);
		if (FAILED(hr))
		{
			ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			return hr;
		}
			
		hr = lpConsole->QueryResultImageList(&m_spImageList);
		if (FAILED(hr))
		{
			ATLTRACE(_T("IConsole::QueryResultImageList failed (HRESULT = %x)\n"), hr);
			return hr;
		}

		lpConsole->QueryConsoleVerb(&m_spConsoleVerb) ;
		if (FAILED(hr))
		{
			ATLTRACE(_T("IConsole::QueryConsoleVerb failed (HRESULT = %x)\n"), hr);
			return hr;
		}

		return S_OK;
	}
    
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        long arg,
        long param)
	{
		ATLTRACE(_T("IComponentImpl::Notify\n"));
		if (lpDataObject == NULL)
		{
			ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n"));
			return E_UNEXPECTED;
		}

		ISnapInDataInterface* pData = ISnapInDataInterface::GetDataClass(lpDataObject);
		if (pData == NULL)
		{
			ATLTRACE(_T("Invalid Data Object\n"));
			return E_UNEXPECTED;
		}
		return pData->Notify(event, arg, param, FALSE, m_spConsole, m_spHeaderCtrl, NULL);
	}
    
    STDMETHOD(Destroy)(long cookie)
	{
		ATLTRACE(_T("IComponentImpl::Destroy\n"));

		m_spConsoleVerb = NULL;
		m_spImageList = NULL;
		m_spHeaderCtrl.Release();	
		m_spConsole.Release();

		return S_OK;
	}
    
    STDMETHOD(QueryDataObject)(long cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentImpl::QueryDataObject\n"));

		if (ppDataObject == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_UNEXPECTED;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;

		ISnapInDataInterface* pData = (ISnapInDataInterface*) cookie;
		return pData->GetDataObject(ppDataObject);
	}
    
    STDMETHOD(GetResultViewType)(long cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
	{
		ATLTRACE(_T("IComponentImpl::GetResultViewType\n"));

		if (cookie == NULL)
		{
			*ppViewType = NULL;
			*pViewOptions = MMC_VIEW_OPTIONS_NONE;
			return S_OK;
		}
		
		ISnapInDataInterface* pData = (ISnapInDataInterface*)cookie;
		return pData->GetResultViewType(ppViewType, pViewOptions);
	}
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n"));
		if (pResultDataItem == NULL)
		{
			ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_UNEXPECTED;
		}

		ISnapInDataInterface* pData = (ISnapInDataInterface*) pResultDataItem->lParam;

		if (pData == NULL)
		{
			ATLTRACE(_T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pData->GetDisplayInfo(pResultDataItem);
	}
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}
};

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(long lUserParam,
        long cookieA,
        long cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
	{
		ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n"));
		if (pDataObject == NULL)
		{
			ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
			return E_UNEXPECTED;
		}

		T* pT = static_cast<T*>(this);
		ISnapInDataInterface* pData = pT->GetDataClass(pDataObject);

		if (pData == NULL)
		{
			ATLTRACE(_T("Invalid Data Object\n"));
			return E_UNEXPECTED;
		}
		return pData->AddMenuItems(piCallback, pInsertionAllowed);
	}
    
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendContextMenuImpl::Command\n"));
		if (pDataObject == NULL)
		{
			ATLTRACE(_T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
			return E_UNEXPECTED;
		}
		
		T* pT = static_cast<T*>(this);
		ISnapInDataInterface* pData = pT->GetDataClass(pDataObject);
		
		if (pData == NULL)
		{
			ATLTRACE(_T("Invalid Data Object\n"));
			return E_UNEXPECTED;
		}
		return pData->Command(lCommandID);
	}
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        long handle,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n"));
		if (pDataObject == NULL)
		{
			ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
			return E_UNEXPECTED;
		}

		T* pT = static_cast<T*>(this);
		ISnapInDataInterface* pData = pT->GetDataClass(pDataObject);

		if (pData == NULL)
		{
			ATLTRACE(_T("Invalid Data Object\n"));
			return E_UNEXPECTED;
		}
		return pData->CreatePropertyPages(lpProvider, handle, this);
	}
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n"));
		if (pDataObject == NULL)
		{
			ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
			return E_UNEXPECTED;
		}

		T* pT = static_cast<T*>(this);
		ISnapInDataInterface* pData = pT->GetDataClass(pDataObject);

		if (pData == NULL)
		{
			ATLTRACE(_T("Invalid Data Object\n"));
			return E_UNEXPECTED;
		}
		return pData->QueryPagesFor();
	}
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
	CComPtr <IControlbar> m_spControlbar;
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n"));
		if (pControlbar == NULL)
		{
			ATLTRACE(_T("IExtendControlbar::SetControlbar called with pControlbar==NULL\n"));
			return E_UNEXPECTED;
		}
		m_spControlbar = pControlbar;
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        long arg,
        long param)
	{
		ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n"));

		ISnapInDataInterface* pData = NULL;
		T* pT = static_cast<T*>(this);
		if (event == MMCN_BTN_CLICK)
		{
			pData = pT->GetDataClass((IDataObject*) arg);
		}
		else if (event == MMCN_SELECT)
		{
			BOOL bScope = (BOOL) LOWORD(arg);
			if (bScope)
			{
				LPDATAOBJECT* ppDataobject = (LPDATAOBJECT*) param;
				if (ppDataobject[0])
				{
					pData = pT->GetDataClass(ppDataobject[0]);
					if (pData != NULL)
						pData->ControlbarNotify(m_spControlbar, this, event, arg, param);
				}
					
				if (ppDataobject[1])
				{
					pData = pT->GetDataClass(ppDataobject[1]);
				}
			}
			else
				pData = pT->GetDataClass((IDataObject*) param);
		}
		if (pData == NULL)
		{
			ATLTRACE(_T("Invalid Data Object\n"));
			return E_UNEXPECTED;
		}
		HRESULT hr = pData->ControlbarNotify(m_spControlbar, this, event, arg, param);
		ATLTRACE(_T("Exiting : IExtendControlbarImpl::ControlbarNotify\n"));
		return hr;
	}
};

#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}


#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	typedef  CSnapInDataInterface< theClass, bIsExtension > baseClass; \
	HRESULT ProcessCommand(UINT nID, IDataObject* pDataObject) \
	{ \
		BOOL _bIsExtension = bIsExtension;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
			return func();

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 >= nID && nID <= id2) \
			return func(nID);

#define END_SNAPINCOMMAND_MAP() \
			return baseClass::ProcessCommand(nID, pDataObject); \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)

struct CSnapInToolbarInfo
{
public:
	TCHAR** m_pStrToolTip;
	TCHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
	IToolbar* m_pToolbar;

	~CSnapInToolbarInfo()
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
		if (m_pToolbar)
			m_pToolbar->Release();
		m_pToolbar = NULL;
	}
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0, NULL},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0, NULL} \
		}; \
		return m_toolbarInfo; \
	}	

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInDataInterface : public ISnapInDataInterface
{
public:
	OLECHAR* m_pszDisplayName;

	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
	CSnapInDataInterface()
	{
		m_pszDisplayName = NULL;

		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));

		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_PARENT;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = 0;
		m_scopeDataItem.nOpenImage = 1;

		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));

		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = 2;

	}

	virtual ~CSnapInDataInterface()
	{
		delete [] m_pszDisplayName;
		m_pszDisplayName = NULL;
	}    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        long arg,
        long param,
		BOOL bComponentData,
		IConsole* pConsole,
		IHeaderCtrl* pHeader,
		IToolbar* pToolbar)
	{
		ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::Notify"));
	}
    
    STDMETHOD(GetDispInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::GetDispInfo"));
	}
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppVIewType,
        long *pViewOptions)
	{
		ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::GetResultViewType"));
	}
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(_T("ISnapInDataInterfaceImpl::GetDisplayInfo"));
		T* pT = static_cast<T*> (this);

		if (pResultDataItem->bScopeItem)
		{
			if (pResultDataItem->mask & RDI_STR)
			{
				pResultDataItem->str = pT->GetResultPaneInfo(pResultDataItem->nCol);
			}
			if (pResultDataItem->mask & RDI_IMAGE)
			{
				pResultDataItem->nImage = m_scopeDataItem.nImage;
			}

			return S_OK;
		}
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = pT->GetResultPaneInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_resultDataItem.nImage;
		}
		return S_OK;
	}
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
	{
		ATLTRACE(_T("ISnapInDataInterfaceImpl::AddMenuItems"));
		T* pT = static_cast<T*> (this);
		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;
//		return SnapInMenuHelper<T> (pT, menuID, piCallback, pInsertionAllowed);

		HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
// Review
// Determine what to do here.
						menuItemInfo.fMask = MIIM_TYPE ;
						menuItemInfo.fType = MFT_STRING;
						TCHAR buf[128];
						menuItemInfo.dwTypeData = buf;
						menuItemInfo.cch = 128;
						if (!GetMenuItemInfo(hMenu, i, TRUE, &menuItemInfo))
							continue;
//						insertionID = _ttol(buf);
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR buf[128];
				menuItemInfo.dwTypeData = buf;

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					TCHAR strStatusBar[257];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;

					pT->UpdateMenuState(menuItemInfo.wID, buf, &menuItemInfo.fState);
					LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, strStatusBar, 257);

					CONTEXTMENUITEM contextMenuItem;
					memset(&contextMenuItem, 0, sizeof(contextMenuItem));
					contextMenuItem.strName = buf;
					contextMenuItem.strStatusBarText = strStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					
					HRESULT hr = piCallback->AddItem(&contextMenuItem);
					_ASSERTE(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}
		if (!bIsExtension)
			*pInsertionAllowed = CCM_INSERTIONALLOWED_TOP | CCM_INSERTIONALLOWED_NEW |
				CCM_INSERTIONALLOWED_TASK | CCM_INSERTIONALLOWED_VIEW;

		return S_OK;
	}
    
    STDMETHOD(Command)(long lCommandID)
	{
		ATLTRACE(_T("ISnapInDataInterfaceImpl::Command\n"));
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, NULL);
	}
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        long handle, IUnknown* pUnk)
	{
		ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::CreatePropertyPages"));
	}
    
    STDMETHOD(QueryPagesFor)(void)
	{
		ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, IExtendControlbar* pExtendControlBar)
	{
		ATLTRACE(_T("ISnapInDataInterfaceImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			if (pInfo->m_pToolbar)
				continue;

			HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			_ASSERTE(pData->wVersion == 1);
			_ASSERTE(pData->wWidth == 16);
			_ASSERTE(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];
			MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
			
			pInfo->m_pStrToolTip = new TCHAR* [pData->wItemCount];
			if (pInfo->m_pStrToolTip == NULL)
				continue;

			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
				pInfo->m_pStrToolTip[i] = NULL;
				memset(&pButtons[i], 0, sizeof(MMCBUTTON));
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR strStatusBar[512];
					LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, strStatusBar, 512);
					
					pInfo->m_pStrToolTip[i] = new TCHAR[lstrlen(strStatusBar) + 1];
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					lstrcpy(pInfo->m_pStrToolTip[i], strStatusBar);
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = _T("");
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = _T("");
					pButtons[i].lpButtonText = _T("");
					pButtons[i].fsType = TBSTYLE_SEP;
				}
			}

	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pInfo->m_pToolbar));
			if (FAILED(hr))
				continue;

			hr = pInfo->m_pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
			if (FAILED(hr))
			{
				pInfo->m_pToolbar->Release();
				pInfo->m_pToolbar = NULL;
				continue;
			}

			hr = pInfo->m_pToolbar->AddButtons(pData->wItemCount, pButtons);
			if (FAILED(hr))
			{
				pInfo->m_pToolbar->Release();
				pInfo->m_pToolbar = NULL;
			}

			delete [] pButtons;
		}
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		MMC_NOTIFY_TYPE event,
        long arg, long param)
	{
		ATLTRACE(_T("ISnapInDataInterfaceImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar);

		if(event == MMCN_SELECT)
		{
			BOOL bScope = (BOOL) LOWORD(arg);
			BOOL bSelect = (BOOL) HIWORD (arg);

			if (!bScope)
			{
				CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
				if (pInfo == NULL)
					return S_OK;

				if (!bSelect)
					return S_OK;

				for(; pInfo->m_idToolbar; pInfo++)
				{
					for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
					{
						if (pInfo->m_pnButtonID[i])
						{
							for (int j = ENABLED; j <= BUTTONPRESSED; j++)
							{
								pInfo->m_pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
									(MMC_BUTTON_STATE)j,
									pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], (MMC_BUTTON_STATE)j));
							}									
						}
					}
				}
			}
			else
			{
				LPDATAOBJECT* pData = (LPDATAOBJECT*) param;
				if (pData[0] == NULL)
					return S_OK;
				if (pData[0] == pData[1])
					return S_OK;
				ISnapInDataInterface* pCookie = ISnapInDataInterface::GetDataClass(pData[0]);
				if (pCookie == (ISnapInDataInterface*)this)
				{
					CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
					if (pInfo == NULL)
						return S_OK;

					for(; pInfo->m_idToolbar; pInfo++)
					{
						pControlbar->Detach(pInfo->m_pToolbar);
					}
					return S_OK;
				}

				CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
				if (pInfo == NULL)
					return S_OK;

				for(; pInfo->m_idToolbar; pInfo++)
				{
					pControlbar->Attach(TOOLBAR, pInfo->m_pToolbar);
					for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
					{
						if (pInfo->m_pnButtonID[i])
						{
							for (int j = ENABLED; j <= BUTTONPRESSED; j++)
							{
								pInfo->m_pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
									(MMC_BUTTON_STATE)j,
									pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], (MMC_BUTTON_STATE)j));
							}									
						}
					}
				}
				return S_OK;
			}
		}
		return pT->ProcessCommand((UINT) param, NULL);
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj)
	{
		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		pData->m_pData = this;

		hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));

		return hr;
	}

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT id, BYTE *fsState, BYTE *fsType)
	{
		*fsState = TBSTATE_ENABLED;
		*fsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT id, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID, IDataObject* pDataObject)
	{
		ATLTRACE(_T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (lstrlen((LPCTSTR)pT->GetSZNodeType()) + 1 )* sizeof(TCHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (lstrlen((LPCTSTR)pT->GetDisplayName()) + 1) * sizeof(TCHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(CLSID), &uWritten);
			return hr;
		}
		if (cf == m_CCF_SNAPIN_GETCOOKIE)
		{
			hr = pStream->Write(&pT, sizeof(T*), &uWritten);
			return hr;
		}


		return hr;
	}
	OLECHAR* GetResultPaneInfo(int nCol)
	{
		if (nCol == 0 && m_pszDisplayName)
			return m_pszDisplayName;

		return L"Override GetResultPaneInfo in your derived class";
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}

	static const UINT GetMenuID() 
	{
		return 0;
	}
};


_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_DISPLAY_NAME = 0;
_d