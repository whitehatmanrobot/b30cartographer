                                         sizeof(DWORD),
                                                IFS_CACHE_CINITFAILS_HELP
                                                );
    if( rgCounters[CACHE_CINITFAILS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }


    rgCounters[IFS_SAMPLEOBJ] = IfsPerfObject.CreateCounter(
                                                IFS_SAMPLEOBJ_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_SAMPLEOBJ_HELP
                                                );
    if( rgCounters[IFS_SAMPLEOBJ] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHITEMS] = IfsPerfObject.CreateCounter(
                                                IFS_HASHITEMS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHITEMS_HELP
                                                );
    if( rgCounters[IFS_HASHITEMS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHINSERT] = IfsPerfObject.CreateCounter(
                                                IFS_HASHINSERT_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHINSERT_HELP
                                                );
    if( rgCounters[IFS_HASHINSERT] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHSPLITINSERTS] = IfsPerfObject.CreateCounter(
                                                IFS_HASHSPLITINSERTS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHSPLITINSERTS_HELP
                                                );
    if( rgCounters[IFS_HASHSPLITINSERTS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHDELETES] = IfsPerfObject.CreateCounter(
                                                IFS_HASHDELETES_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHDELETES_HELP
                                                );
    if( rgCounters[IFS_HASHDELETES] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHSEARCHES] = IfsPerfObject.CreateCounter(
                                                IFS_HASHSEARCHES_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHSEARCHES_HELP
                                                );
    if( rgCounters[IFS_HASHSEARCHES] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHSEARCHHITS] = IfsPerfObject.CreateCounter(
                                                IFS_HASHSEARCHHITS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHSEARCHHITS_HELP
                                                );
    if( rgCounters[IFS_HASHSEARCHHITS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHSPLITS] = IfsPerfObject.CreateCounter(
                                                IFS_HASHSPLITS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHSPLITS_HELP
                                                );
    if( rgCounters[IFS_HASHSPLITS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHREALLOCS] = IfsPerfObject.CreateCounter(
                                                IFS_HASHREALLOCS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHREALLOCS_HELP
                                                );
    if( rgCounters[IFS_HASHREALLOCS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHDEEPBUCKET] = IfsPerfObject.CreateCounter(
                                                IFS_HASHDEEPBUCKET_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHDEEPBUCKET_HELP
                                                );
    if( rgCounters[IFS_HASHDEEPBUCKET] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHAVERAGEBUCKET] = IfsPerfObject.CreateCounter(
                                                IFS_HASHAVERAGEBUCKET_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHAVERAGEBUCKET_HELP
                                                );
    if( rgCounters[IFS_HASHAVERAGEBUCKET] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHEMPTYBUCKET] = IfsPerfObject.CreateCounter(
                                                IFS_HASHEMPTYBUCKET_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHEMPTYBUCKET_HELP
                                                );
    if( rgCounters[IFS_HASHEMPTYBUCKET] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHALLOCBUCKETS] = IfsPerfObject.CreateCounter(
                                                IFS_HASHALLOCBUCKETS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHALLOCBUCKETS_HELP
                                                );
    if( rgCounters[IFS_HASHALLOCBUCKETS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHACTIVEBUCKETS] = IfsPerfObject.CreateCounter(
                                                IFS_HASHACTIVEBUCKETS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHACTIVEBUCKETS_HELP
                                                );
    if( rgCounters[IFS_HASHACTIVEBUCKETS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHAVERAGESEARCH] = IfsPerfObject.CreateCounter(
                                                IFS_HASHAVERAGESEARCH_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHAVERAGESEARCH_HELP
                                                );
    if( rgCounters[IFS_HASHAVERAGESEARCH] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHDEEPSEARCH] = IfsPerfObject.CreateCounter(
                                                IFS_HASHDEEPSEARCH_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHDEEPSEARCH_HELP
                                                );
    if( rgCounters[IFS_HASHDEEPSEARCH] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHSEARCHCOST] = IfsPerfObject.CreateCounter(
                                                IFS_HASHSEARCHCOST_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHSEARCHCOST_HELP
                                                );
    if( rgCounters[IFS_HASHSEARCHCOST] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[IFS_HASHSEARCHCOSTMISS] = IfsPerfObject.CreateCounter(
                                                IFS_HASHSEARCHCOSTMISS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_HASHSEARCHCOSTMISS_HELP
                                                );
    if( rgCounters[IFS_HASHSEARCHCOSTMISS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    if( !CacheSuccessCreates.Create( IfsPerfObject, rgCounters[FORC_SUCCESS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheFailCreates.Create( IfsPerfObject, rgCounters[FORC_FAIL], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }


    if( !CacheItems.Create( IfsPerfObject, rgCounters[CACHE_ITEMS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheCLRU.Create( IfsPerfObject, rgCounters[CACHE_CLRU], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheExpired.Create( IfsPerfObject, rgCounters[CACHE_EXPIRED], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheInserts.Create( IfsPerfObject, rgCounters[CACHE_INSERTS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheReadHits.Create( IfsPerfObject, rgCounters[CACHE_READHITS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheSSearch.Create( IfsPerfObject, rgCounters[CACHE_SSEARCH], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheFSearch.Create( IfsPerfObject, rgCounters[CACHE_FSEARCH], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheResearch.Create( IfsPerfObject, rgCounters[CACHE_RESEARCH], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheWriteHits.Create( IfsPerfObject, rgCounters[CACHE_WRITEHITS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CachePCreates.Create( IfsPerfObject, rgCounters[CACHE_PCREATES], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheECreates.Create( IfsPerfObject, rgCounters[CACHE_ECREATES], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheCEFails.Create( IfsPerfObject, rgCounters[CACHE_CEFAILS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheCAllocFails.Create( IfsPerfObject, rgCounters[CACHE_CALLOCFAILS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !CacheCInitFails.Create( IfsPerfObject, rgCounters[CACHE_CINITFAILS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !IFSSampleObject.Create( IfsPerfObject, rgCounters[IFS_SAMPLEOBJ], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashItems.Create( IfsPerfObject, rgCounters[IFS_HASHITEMS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashInserts.Create( IfsPerfObject, rgCounters[IFS_HASHINSERT], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashSplitInserts.Create( IfsPerfObject, rgCounters[IFS_HASHSPLITINSERTS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashDeletes.Create( IfsPerfObject, rgCounters[IFS_HASHDELETES], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashSearches.Create( IfsPerfObject, rgCounters[IFS_HASHSEARCHES], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashSearchHits.Create( IfsPerfObject, rgCounters[IFS_HASHSEARCHHITS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashSplits.Create( IfsPerfObject, rgCounters[IFS_HASHSPLITS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashReallocs.Create( IfsPerfObject, rgCounters[IFS_HASHREALLOCS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashDeepBucket.Create( IfsPerfObject, rgCounters[IFS_HASHDEEPBUCKET], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashAverageBucket.Create( IfsPerfObject, rgCounters[IFS_HASHAVERAGEBUCKET], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashEmptyBucket.Create( IfsPerfObject, rgCounters[IFS_HASHEMPTYBUCKET], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashAllocBuckets.Create( IfsPerfObject, rgCounters[IFS_HASHALLOCBUCKETS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashActiveBuckets.Create( IfsPerfObject, rgCounters[IFS_HASHACTIVEBUCKETS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashAverageSearch.Create( IfsPerfObject, rgCounters[IFS_HASHAVERAGESEARCH], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashDeepSearch.Create( IfsPerfObject, rgCounters[IFS_HASHDEEPSEARCH], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashSearchCost.Create( IfsPerfObject, rgCounters[IFS_HASHSEARCHCOST], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

    if( !HashSearchCostMiss.Create( IfsPerfObject, rgCounters[IFS_HASHSEARCHCOSTMISS], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }

#if 0
    if( !IFSCacheState.Create( IfsPerfObject, rgCounters[IFS_CACHESTATE], iid ) ) {
        printf("Failed to create counter object Line: %d GLE: %d\n", __LINE__, GetLastError());
        exit(0);
    }
#endif

	CacheLibraryInit() ;

	StartTest() ;

	CacheLibraryTerm() ;

	TermAsyncTrace() ;

    _VERIFY( DestroyGlobalHeap() );

	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\cache2\src\cache2.cpp ===
/*++

	Cache2.cpp

	this file implements the main library support for the cache.

--*/


#include	<windows.h>
#include	"dbgtrace.h"
#include	"cache2.h"


BOOL				CScheduleThread::s_fInitialized ;
CRITICAL_SECTION	CScheduleThread::s_critScheduleList ;
HANDLE				CScheduleThread::s_hShutdown ;
HANDLE				CScheduleThread::s_hThread ;
CScheduleThread		CScheduleThread::s_Head( TRUE ) ;
DWORD				CScheduleThread::dwNotificationSeconds = 5 ;

//
//	Is the Caching library initialized ?
//
static	BOOL	fInitialized ;

CRITICAL_SECTION	g_CacheShutdown ;


BOOL    __stdcall
CacheLibraryInit()	{

	InitializeCriticalSection( &g_CacheShutdown ) ;

	if( !fInitialized ) {
		fInitialized = TRUE ;
		return	CScheduleThread::Init() ;
	}
	return	TRUE ;
}

BOOL    __stdcall
CacheLibraryTerm() {

	_ASSERT( fInitialized ) ;

	CScheduleThread::Term() ;

	DeleteCriticalSection( &g_CacheShutdown ) ;
	fInitialized = FALSE ;
	return	TRUE ;

}
			




DWORD	WINAPI	
CScheduleThread::ScheduleThread(	
						LPVOID	lpv
						) {
/*++

Routine Description :

	This function implements the thread which loops through
	all the Cache item's which are registered.  We invoke each
	one's Schedule method which gives it a change to bump TTL's etc...

Arguments :

	lpv - unused

Return Value :

	Always 0.

--*/



	while( 1 ) {

		DWORD	dwWait = WaitForSingleObject( s_hShutdown, dwNotificationSeconds * 100 ) ;

		if( dwWait == WAIT_TIMEOUT ) {

			EnterCriticalSection( &s_critScheduleList ) ;

			for( CScheduleThread* p = s_Head.m_pNext; p!=&s_Head; p = p->m_pNext ) {
				p->Schedule() ;
			}

			LeaveCriticalSection( &s_critScheduleList ) ;

		}	else	{

			break ;

		}
	}
	return	0 ;
}

BOOL
CScheduleThread::Init() {
/*++

Routine Description :

	Initialize the scheduler thread.
	Creates necessary threads, shutdown events, etc...

Arguments :

	None

Return Value :

	TRUE if successfull

--*/

	s_fInitialized = FALSE ;
	InitializeCriticalSection( &s_critScheduleList ) ;

	s_hShutdown = CreateEvent(	0,
								FALSE,
								FALSE,
								0 ) ;
	if( s_hShutdown != 0 ) {
	
		DWORD	dwJunk ;
		s_hThread = CreateThread(	0,
									0,
									ScheduleThread,
									0,
									0,
									&dwJunk ) ;
		if( s_hThread != 0 ) {
			s_fInitialized = TRUE ;
			return	TRUE ;
		}
	}
	return	FALSE ;
}

void
CScheduleThread::Term()	{
/*++

Routine Description :

	Terminates the scheduler thread - destroys all objects.

Arguments :

	None.

Return Value :

	None.

--*/

	if( s_fInitialized ) {
		if( s_hShutdown ) {
			SetEvent( s_hShutdown ) ;
		}
		if( s_hThread ) {
			WaitForSingleObject( s_hThread, INFINITE ) ;
			CloseHandle( s_hThread ) ;
		}
		if( s_hShutdown )
			CloseHandle( s_hShutdown ) ;

		s_hShutdown = 0 ;
		s_hThread = 0 ;

		s_fInitialized = FALSE ;
	}
}


CScheduleThread::CScheduleThread(	BOOL fSpecial ) {
/*++

Routine Description :

	Special constructor which makes the empty doubly linked list !

Arguments :

	None.

Return Value :

	TRUE if successfull.

--*/


	m_pPrev = this ;
	m_pNext = this ;

}

	

CScheduleThread::CScheduleThread() :
	m_pPrev( 0 ),
	m_pNext( 0 )	{
/*++

Routine Description :

	Creates an object placed on the Sheduler's queue
	for regular execution.	

Arguments :

	None.

Return Value :

	None.

--*/

	_ASSERT( s_fInitialized ) ;
//	_ASSERT( s_Head.m_pPrev != 0 ) ;
//	_ASSERT( s_Head.m_pNext != 0 ) ;
//	_ASSERT( s_Head.m_pPrev->m_pNext == &s_Head ) ;
//	_ASSERT( s_Head.m_pNext->m_pPrev == &s_Head ) ;

}

void
CScheduleThread::AddToSchedule()	{
/*++

Routine Description :

	Creates an object placed on the Sheduler's queue
	for regular execution.	

Arguments :

	None.

Return Value :

	None.

--*/

	_ASSERT( s_fInitialized ) ;

	EnterCriticalSection( &s_critScheduleList ) ;

	_ASSERT( s_Head.m_pPrev != 0 ) ;
	_ASSERT( s_Head.m_pNext != 0 ) ;
	_ASSERT( s_Head.m_pPrev->m_pNext == &s_Head ) ;
	_ASSERT( s_Head.m_pNext->m_pPrev == &s_Head ) ;

	CScheduleThread*	pNext = &s_Head ;
	CScheduleThread*	pPrev = s_Head.m_pPrev ;
	m_pPrev = pPrev ;
	m_pNext = pNext ;
	pPrev->m_pNext = this ;
	pNext->m_pPrev = this ;
	LeaveCriticalSection( &s_critScheduleList ) ;


}

CScheduleThread::~CScheduleThread() {
/*++

Routine Description :

	Destroys a CScheduleThread object - removes it from
	the queue of objects called by the schedule thread.

Arguments :

	None.

Return Value :

	None.

--*/


	if( !s_fInitialized ) {
		return ;
	}

	_ASSERT( m_pPrev == 0 ) ;
	_ASSERT( m_pNext == 0 ) ;

	if( this == &s_Head ) {
		DeleteCriticalSection( &s_critScheduleList ) ;
	}
}

void
CScheduleThread::RemoveFromSchedule() {
/*++

Routine Description :

	Destroys a CScheduleThread object - removes it from
	the queue of objects called by the schedule thread.

Arguments :

	None.

Return Value :

	None.

--*/


	EnterCriticalSection( &s_critScheduleList ) ;

	CScheduleThread*	pNext = m_pNext ;
	CScheduleThread*	pPrev = m_pPrev ;

	_ASSERT( pNext != 0 ) ;
	_ASSERT( pPrev != 0 ) ;

	pNext->m_pPrev = pPrev ;
	pPrev->m_pNext = pNext ;

	m_pPrev = 0 ;
	m_pNext = 0 ;

	LeaveCriticalSection( &s_critScheduleList ) ;
}


CAllocatorCache::CAllocatorCache(	
					DWORD	cbSize,
					DWORD	cMaxElements
					) :
	m_cbSize( cbSize ),
	m_cElements( 0 ),
	m_cMaxElements( cMaxElements ),
	m_pHead( 0 )	{
/*++

Routine Description :

	Construct the CAllocatorCache - we're ready to go as soon
	as this finishes !

Args :
	cbSize - Largest size of any element requested !
	cMaxElements - Maximum number of elements we'll hold in our free list !

Returns :
	Nothing

--*/
}

CAllocatorCache::~CAllocatorCache()	{
/*++

Routine Description :

	Destroy the CAllocatorCache - release all the memory back
	to the system heap !

Args :
	None.

Returns :
	Nothing

--*/

	FreeSpace* p = m_pHead ;
	FreeSpace* pNext = 0 ;
	do	{
		if( p ) {
			pNext = p->m_pNext ;
			::delete	(BYTE*)	p ;				
		}
		p = pNext ;
	}	while( p ) ;
}

void*
CAllocatorCache::Allocate(	size_t	cb )	{
/*++

Routine Description :

	This function allocates memory from our allocation cache.

Arguments :

	cb - the size of the allocation requested !

Return Value :

	Pointer to the allocated memory !

--*/

	_ASSERT( cb <= m_cbSize ) ;

	LPVOID	lpvReturn = m_pHead ;

	if( lpvReturn ) {

#ifdef	DEBUG
		//
		//	Check that the memory contains what we filled it with
		//	when it was released !
		//
		BYTE	*pb = (BYTE*)lpvReturn ;
		BYTE	*pbMax = pb+m_cbSize ;
		pb += sizeof( FreeSpace ) ;
		for(	;
				pb < pbMax;
				pb++ )	{
			_ASSERT( *pb == 0xCC ) ;
		}
#endif
		
		m_pHead = m_pHead->m_pNext ;
		m_cElements -- ;

	}	else	{

		lpvReturn = (LPVOID) ::new BYTE[m_cbSize] ;

	}
	return	lpvReturn ;
}

void
CAllocatorCache::Free(	void*	pv )	{
/*++

Routine Description :

	This function allocates memory from our allocation cache.

Arguments :

	cb - the size of the allocation requested !

Return Value :

	Pointer to the allocated memory !

--*/

#ifdef	DEBUG
	FillMemory( pv, m_cbSize, 0xCC ) ;
#endif

	if( m_cElements < m_cMaxElements ) {
		FreeSpace*	pFreeSpace = (FreeSpace*)pv ;
		pFreeSpace->m_pNext = m_pHead ;
		m_pHead = pFreeSpace ;
		m_cElements++ ;
	}	else	{
		::delete	(BYTE*)	pv ;
	}
}

#ifdef	DEBUG
//
//	Number of CacheState objects allocated !
//
long	CacheState::g_cCacheState = 0 ;
#endif


CacheState::CacheState(	class	CLRUList*	p,
						long	cClientRefs
						) :
		m_dwSignature( CACHESTATE_SIGNATURE ),
		m_pOwner( p ),
		m_cRefs( 1 ),
		m_lLRULock( 0 )	{

	//
	//	Must add a positive number of client references only !
	//
	_ASSERT( cClientRefs >= 0 ) ;

	TraceFunctEnter( "CacheState::CacheState" ) ;
	DebugTrace( (DWORD_PTR)this, "p %x cClientRefs %x", p, cClientRefs ) ;

	GetSystemTimeAsFileTime( &m_LastAccess ) ;	

	if( cClientRefs ) {
		CheckOut( 0, cClientRefs ) ;
	}
#ifdef	DEBUG
	InterlockedIncrement( &g_cCacheState ) ;
#endif
}

CacheState::~CacheState()	{

	TraceFunctEnter( "CacheState::~CacheState" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

#ifdef	DEBUG
	InterlockedDecrement( &g_cCacheState ) ;
#endif
}
	

void
CacheState::LRUReference(	class	CLRUList*	pLRU ) {

	TraceFunctEnter( "CacheState::LRUReference" ) ;
	DebugTrace( (DWORD_PTR)this, "pLRU %x m_lLRULock %x", pLRU, m_lLRULock ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

	if( pLRU ) {
		//
		//	Only put into the CLRUList once !
		//
		if( InterlockedIncrement( (long*)&m_lLRULock ) == 1 ) {
			//
			//	Add a reference while we are in transit in the work queue !
			//
			long l = AddRef() ;
			DebugTrace( DWORD_PTR(this), "Added a Reference to %x l %x", this, l ) ;
			pLRU->AddWorkQueue( this ) ;
		}
	}
}

//
//	Reference counting support - Add a reference
//
long
CacheState::AddRef()	{
/*++

Routine Description :

	Add a reference to this piece of Cache State.
	Note - we distinguish different types of references -
	This is a reference from a Cache onto the item

Arguments :

	None.

Return Value :

	Number of References

--*/

	TraceFunctEnter( "CacheState::AddRef" ) ;

	return	InterlockedIncrement( (long*)&m_cRefs ) ;
}


//
//	Keeping track of clients - remove a client ref !
//
long	
CacheState::CheckInNoLocks(	
			class	CAllocatorCache* pAlloc
			)	{
/*++

Routine Description :

	A client is returning an item to the cache.
	This function will remove a client reference,
	and perform appropriate processing !

Arguments :

	pAlloc - the cache used to allocate and free
		ourselves

Return Value :

	Number of References
	if 0 then we've been destroyed !

--*/

	TraceFunctEnter( "CacheState::CheckIn" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	_ASSERT( IsMasterReference() ) ;

	long result = InterlockedExchangeAdd( (long*)&m_cRefs, -CLIENT_REF ) - CLIENT_REF ;

	DebugTrace( (DWORD_PTR)this, "pAlloc %x result %x", pAlloc, result ) ;

	_ASSERT( (result & CLIENT_BITS) >= 0 ) ;

	if( result == 0 ) {
		//
		//	If this function is called then somebody has a lock on the state object, 
		//	that somebody must have an independent reference other than what's getting 
		//	checked in - so this should never happen !
		//
		_ASSERT( 1==0 ) ;
		if( !pAlloc )	{
			delete	this ;
		}	else	{
			Destroy(0) ;
			pAlloc->Free( this ) ;	
		}
	}	else	{
		//
		//	was this the last client reference ?
		//
		if( (result & CLIENT_BITS) == 0 )	{
			//
			//	Yes - go and put this in the modify queue !
			//
			LRUReference( m_pOwner ) ;
		}
	}
	return	result ;
}



//
//	Keeping track of clients - remove a client ref !
//
long	
CacheState::CheckIn(	
			class	CAllocatorCache* pAlloc
			)	{
/*++

Routine Description :

	A client is returning an item to the cache.
	This function will remove a client reference,
	and perform appropriate processing !

Arguments :

	pAlloc - the cache used to allocate and free
		ourselves

Return Value :

	Number of References
	if 0 then we've been destroyed !

--*/

	TraceFunctEnter( "CacheState::CheckIn" ) ;

	m_lock.ShareLock() ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	_ASSERT( IsMasterReference() ) ;

	long result = InterlockedExchangeAdd( (long*)&m_cRefs, -CLIENT_REF+1 ) - CLIENT_REF+1 ;

	DebugTrace( (DWORD_PTR)this, "pAlloc %x result %x", pAlloc, result ) ;

	_ASSERT( (result & CLIENT_BITS) >= 0 ) ;

	if( result == 0 ) {
		m_lock.ShareUnlock() ;
		if( !pAlloc )	{
			delete	this ;
		}	else	{
			Destroy(0) ;
			pAlloc->Free( this ) ;	
		}
	}	else	{
		//
		//	was this the last client reference ?
		//
		if( (result & CLIENT_BITS) == 0 )	{
			//
			//	Yes - go and put this in the modify queue !
			//
			LRUReference( m_pOwner ) ;
		}
		m_lock.ShareUnlock() ;
	}
	return	Release(pAlloc,0) ;
}

//
//	Keeping track of clients - Add a client ref !
//
long
CacheState::CheckOut(	
				class	CLRUList*	p,
				long	cClientRefs
				)	{
/*++

Routine Description :

	Add a reference to this piece of Cache State.
	Note - we distinguish different types of references -
	This is a reference from a CLIENT onto the item

Arguments :

	p -The LRU List managing this guys expiration
	cClientRefs - the number of refences to add

Return Value :

	Number of References

--*/

	//
	//	Must add a positive number of references !
	//
	_ASSERT( cClientRefs > 0 ) ;

	TraceFunctEnter( "CacheState::CheckOut" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	//_ASSERT( IsMasterReference() ) ;
	
	long	result = InterlockedExchangeAdd( (long*)&m_cRefs, CLIENT_REF*cClientRefs ) ;

	DebugTrace( (DWORD_PTR)this, "p %x result %x", p, result + (CLIENT_REF*cClientRefs) ) ;

	if( p ) {
		//
		//	Was this the first time this thing was checked out ?
		//
		if( (result & CLIENT_BITS) == 0 ) {
			//
			//	Yes - go and put this in the modify queue !
			//
			LRUReference( m_pOwner ) ;
		}
	}
	return	result + CLIENT_REF ;
}

//
//	Remove a reference - when we return 0 we're destroyed !
//
long
CacheState::Release(	class	CAllocatorCache	*pAlloc,
						void*	pv
						)	{
/*++

Routine Description :

	A cache is removing an item from the cache.
	This function will remove a client reference,
	and perform appropriate processing !

Arguments :

	pAlloc - the cache used to allocate and free
		ourselves

Return Value :

	Number of References
	if 0 then we've been destroyed !

--*/

	TraceFunctEnter( "CacheState::Release" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	long result = InterlockedDecrement( (long*)&m_cRefs ) ;


	DebugTrace( (DWORD_PTR)this, "pAlloc %x pv %x result %x", pAlloc, pv, result ) ;

	_ASSERT( !(result & 0x8000) ) ;
	if( result == 0 ) {
		if( !pAlloc )	{
			delete	this ;
		}	else	{
			Destroy(pv) ;
			pAlloc->Free( this ) ;	
		}
	}
	return	result ;
}

//
//	Provided to deal with failures during initialization of items
//	being insert into the cache - this function ensures that the
//	cache item ends up on the list for destruction !
//
void
CacheState::FailedCheckOut(	
				class	CLRUList*	p,
				long	cClientRefs,
				CAllocatorCache*	pAllocator,
				void*	pv
				)	{
/*++

Routine Description :

	Called after a failure has occurred when putting an item into
	the cache.  The item is referenced by the hash table but will end
	up not being referenced by clients.
	We removed a client reference if necessary, and we also put
	onto the LRU action list so that this thing eventually gets
	destroyed by expiration.

Arguments :

	p - the LRU list we should be on
	cClientRefs - Number of client references put on us !
	pAllocator - if NOT NULL then we can remove the final reference
		and destroy this thing !

Return Value :

	None.

--*/

	TraceFunctEnter( "CacheState::FailedCheckOut" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	_ASSERT( p != 0 ) ;
	_ASSERT( p==m_pOwner ) ;

	DebugTrace( (DWORD_PTR)this, "Args - p %x cClientRefs %x, pAllocator %x pv %x",
		p, cClientRefs, pAllocator, pv ) ;
	
	if( cClientRefs ) {
		long lSubtract = cClientRefs * CLIENT_REF ;
		long result = InterlockedExchangeAdd( (long*)&m_cRefs, -lSubtract ) - lSubtract;

		DebugTrace( (DWORD_PTR)this, "result %x", result ) ;

		_ASSERT( (result & CLIENT_BITS) == 0 ) ;
		_ASSERT( result != 0 ) ;
	}
	//
	//	Must not be checked out !
	//
	_ASSERT( !IsCheckedOut() ) ;
	//
	//	Should end up with only one reference - the hash table
	//	when failures occur !
	//
	_ASSERT( m_cRefs == 1 || m_cRefs == 2 ) ;

	if( pAllocator ) {
		long l = Release( pAllocator, pv ) ;
		DebugTrace( (DWORD_PTR)this, "l %x", l ) ;
		_ASSERT( l==0 ) ;
	}	else	{
		LRUReference( m_pOwner ) ;
	}
}


long
CacheState::ExternalCheckIn( ) {
/*++

Routine Description :

	This function exposes the check-in logic as
	used by people who aren't holding any cache locks

Arguments :

	NOne.

Return Value :

	Number of references.
	0 means we were destroyed shouldn't happen though !


--*/

	TraceFunctEnter( "CacheState::ExternalCheckIn" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	long	l = CheckIn( 0 ) ;	

	DebugTrace( (DWORD_PTR)this, "CheckIn results %x", l ) ;
	return	l ;
}


long
CacheState::ExternalCheckInNoLocks( ) {
/*++

Routine Description :

	This function exposes the check-in logic as
	used by people who aren't holding any cache locks

Arguments :

	NOne.

Return Value :

	Number of references.
	0 means we were destroyed shouldn't happen though !


--*/

	TraceFunctEnter( "CacheState::ExternalCheckInNoLocks" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	long	l = CheckInNoLocks( 0 ) ;	

	DebugTrace( (DWORD_PTR)this, "CheckIn results %x", l ) ;
	return	l ;
}


//
//	The following support functions are used to support manipulating
//	these objects in the various kinds of doubly linked lists we may reside in
//
//
BOOL
CacheState::FLockCandidate(	BOOL	fExpireChecks,
							FILETIME&	filetime,
							BOOL&	fToYoung
							) {
/*++

Routine Description :

	Figure out if this cache element could be deleted, and if so lock
	him up and return with the lock held !

Arguments :

	The expiration time !

Return Value :

	TRUE if the lock is held and this guy should be expired !

--*/

	TraceQuietEnter( "CacheState::FlockCandidate" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	fToYoung = FALSE ;

	m_lock.ExclusiveLock() ;

	BOOL	fReturn = TRUE ;
	if( fExpireChecks ) {
		fToYoung = !OlderThan( filetime ) ;
		fReturn &=
			m_lLRULock == 0 &&
			IsMasterReference() &&
			!IsCheckedOut() &&
			!fToYoung ;
	}

	if( fReturn )	{

		DebugTrace( (DWORD_PTR)this, "Item is a good candidate - get references!" ) ;

		REFSITER	refsiter( &m_ReferencesList ) ;
		while( !refsiter.AtEnd() ) {
			if( !refsiter.Current()->m_lock.TryExclusiveLock() )	{
				break ;
			}
			refsiter.Next() ;
		}
		//
		//	Try again later !
		//
		if( refsiter.AtEnd() ) {	
			if( !IsCheckedOut() ) {
			
				DebugTrace( (DWORD_PTR)this, "Item is TOTALLY Locked including all children!" ) ;

				return	TRUE ;
			}
		}

		//
		//	Undo our locks !
		//	
		refsiter.Prev() ;
		while(!refsiter.AtEnd() ) {
			refsiter.Current()->m_lock.ExclusiveUnlock() ;	
			refsiter.Prev() ;
		}
	}
	m_lock.ExclusiveUnlock() ;
	return	FALSE ;
}



BOOL
CacheState::FLockExpungeCandidate(	CacheState*&	pMaster	) {
/*++

Routine Description :

	This function is used when we are locking down a cache item that 
	is being considered for Expunge.  We cannot expunge items that do not
	master the cache item - so we have to be carefull in our locking.

Arguments :
	
	None.

Return Value :

	TRUE if this item is the Master Cache Entry, FALSE otherwise !

	NOTE: If this returns FALSE no locks are held !!!!!


--*/

	TraceFunctEnter( "CacheState::FlockExpungeCandidate" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

	CacheState*	pExtraRef = 0 ;
	m_lock.ExclusiveLock() ;

	pMaster = GetMasterReference() ;
	if( pMaster == this ) {
	REFSITER	refsiter( &pMaster->m_ReferencesList ) ;
		while( !refsiter.AtEnd() ) {
			refsiter.Current()->m_lock.ExclusiveLock() ;
			refsiter.Next() ;
		}	
	}	else	{
		//
		//	We are not the master cache element - so there 
		//	must be another Cache Item somewhere that is, 
		//	and we must be in his list - let's try to find him !
		//
		_ASSERT( !m_ReferencesList.IsEmpty() ) ;
		//
		//	Acquire the Master's lock !
		//
		CacheState*	pMaster2 = pMaster ;
		//
		//	Did we add an extra reference to the master !
		//
		if( !pMaster->m_lock.TryExclusiveLock() )	{
			//
			//	Because the easy way of locking the Master failed, 
			//	we need to AddRef() and Release() him because once 
			//	we drop our lock, we have no idea of his lifetime !
			//
			pExtraRef = pMaster ;
			long l = pMaster->AddRef() ;
			DebugTrace( DWORD_PTR(pMaster), "Added Ref to %x result %x this %x", pMaster, l, this ) ;
			m_lock.ExclusiveUnlock() ;
			pMaster->m_lock.ExclusiveLock() ;
			m_lock.ExclusiveLock() ;
			pMaster2 = GetMasterReference() ;
			_ASSERT(	pMaster2 == pMaster || 
						pMaster2 == this 
						) ;

			//
			//	If the master has changed in this window, then 
			//	we must now be an isolated element !
			//
			if( pMaster2 != pMaster ) {
				_ASSERT( m_ReferencesList.IsEmpty() ) ;
				_ASSERT( pMaster2 == this ) ;
				pMaster->ExclusiveUnlock() ;
			}
			pMaster = pMaster2 ;
		}
	}
	//
	//	Check to see whether there is an extra reference that 
	//	now needs to be removed !
	//
	if( pExtraRef ) {
		long l = pExtraRef->Release(0,0) ;
		DebugTrace( DWORD_PTR(pExtraRef), "Removed temporary reference result %x pExtraRef %x this %x pMaster %x", 
			l, pExtraRef, this, pMaster ) ;
	}
	return	TRUE ;
}

void
CacheState::ReleaseLocks(	CacheState*	pMaster )	{
/*++

Routine Description : 

	Given a guy in the cache who has had all of his locks acquired exclusively
	we drop all of these locks !

Arguments : 

	None.

Return Value : 

	None.

--*/

	TraceFunctEnter("CacheState::ReleaseLocks" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	_ASSERT( GetMasterReference() == pMaster ) ;

	if( pMaster == this ) {
		REFSITER	refsiter( &m_ReferencesList ) ;
		while( !refsiter.AtEnd() ) {
			CacheState*	p = refsiter.Current() ;
			p->m_lock.ExclusiveUnlock() ;
			refsiter.Next() ;
		} ;
	}	else	{
		pMaster->m_lock.ExclusiveUnlock() ;
	}
	m_lock.ExclusiveUnlock() ;
}



//
//
//
void
CacheState::FinishCandidate(	CacheState*	pMaster	)	{
/*++

Routine Description :

	Given a guy in the cache who is prime for destruction - finish him off !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter("CacheState::FinishCandidate" ) ;

	_ASSERT( pMaster == GetMasterReference() ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

	//_ASSERT( !IsCheckedOut() ) ;
	//_ASSERT( m_lLRULock == 0 ) ;

	RemoveFromLRU() ;

	if( pMaster == this ) {
		REFSITER	refsiter( &m_ReferencesList ) ;
		while( !refsiter.AtEnd() ) {
			CacheState*	p = refsiter.RemoveItem() ;
			DebugTrace( (DWORD_PTR)this, "Remove item %x", p ) ;
			p->RemoveCacheReference( TRUE ) ;
			p->m_lock.ExclusiveUnlock() ;
			long l = Release(0, 0) ;
			DebugTrace( DWORD_PTR(this), "ref %x this %x removed %x", l, this, p ) ;
			_ASSERT( l > 0 ) ;
		} ;
	}	else	{
		//
		//	just remove ourselves from the list !
		//
		m_ReferencesList.RemoveEntry() ;
		RemoveCacheReference( FALSE ) ;
		pMaster->m_lock.ExclusiveUnlock() ;
		long	l = pMaster->Release( 0, 0 ) ;
		DebugTrace( DWORD_PTR(pMaster), "Removed ref from master %x result %x this %x", 
			pMaster, l, this ) ;
	}
		
	//
	//	Once we've finished this guy off, it's on it's way to its doom and should not go back into LRU lists !
	//
	m_pOwner = 0 ;
	m_lock.ExclusiveUnlock() ;
}


void
CacheState::RemoveFromLRU()	{
	m_LRUList.RemoveEntry() ;
}




//
//
//
void
CacheState::IsolateCandidate()	{
/*++

Routine Description :

	Given a guy in the cache who is prime for destruction - finish him off !

	This piece of CacheState may be either a duplicate 'Name' for the same 
	cacheitem, or the master name for the item.
	If we are a duplicate name then we need to isolate ourselves from the 
	master name !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter("CacheState::IsolateCandidate" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

	_ASSERT( !IsCheckedOut() ) ;
	//_ASSERT( m_lLRULock == 0 ) ;

	m_lock.ExclusiveLock() ;
	CacheState*	pMaster = GetMasterReference() ;

	_ASSERT( pMaster != 0 ) ;

	if( pMaster == 0 ) {

		_ASSERT( m_ReferencesList.IsEmpty() ) ;
		_ASSERT( m_LRUList.IsEmpty() ) ;

	}	else	{

		if( pMaster == this ) {
			//
			//	this list should be empty !
			//
			//_ASSERT( m_ReferencesList.IsEmpty() ) ;
			//
			//	Just in case, dump everything out !
			//
			REFSITER	refsiter( &m_ReferencesList ) ;
			while( !refsiter.AtEnd() ) {
				CacheState*	p = refsiter.RemoveItem() ;
				p->m_lock.ExclusiveLock() ;
				p->RemoveCacheReference( FALSE ) ;
				p->m_lock.ExclusiveUnlock() ;
				long l = pMaster->Release(0, 0) ;
				DebugTrace( (DWORD_PTR)this, "result %x Remove item %x", l, p ) ;
				_ASSERT( l > 0 ) ;
			} ;
		}	else	{
			//
			//	We are not the master cache element - so there 
			//	must be another Cache Item somewhere that is, 
			//	and we must be in his list - let's try to find him !
			//
			_ASSERT( !m_ReferencesList.IsEmpty() ) ;

			//
			//	Acquire the Master's lock !
			//
			CacheState*	pMaster2 = pMaster ;
			//
			//	Did we add an extra reference to the master !
			//
			CacheState*	pExtraRef = 0 ;
			if( !pMaster->m_lock.TryExclusiveLock() )	{
				//
				//	Because the easy way of locking the Master failed, 
				//	we need to AddRef() and Release() him because once 
				//	we drop our lock, we have no idea of his lifetime !
				//
				pExtraRef = pMaster ;
				long l = pMaster->AddRef() ;
				DebugTrace( DWORD_PTR(pMaster), "Added a ref to %x result %x this %x", pMaster, l, this ) ;
				m_lock.ExclusiveUnlock() ;
				pMaster->m_lock.ExclusiveLock() ;
				m_lock.ExclusiveLock() ;
				pMaster2 = GetMasterReference() ;
				_ASSERT(	pMaster2 == pMaster || 
							pMaster2 == this 
							) ;
			}
			//
			//	Now remove this element from the cache !
			//
			if( pMaster2 == pMaster ) {	
				m_ReferencesList.RemoveEntry() ;
				RemoveCacheReference( FALSE ) ;
				pMaster->m_lock.ExclusiveUnlock() ;
				long	l = pMaster2->Release( 0, 0 ) ;
				DebugTrace( DWORD_PTR(pMaster2), "REmoved ref from master %x result %x this %x", pMaster2, l, this ) ;
			}	else	{
				pMaster->ExclusiveUnlock() ;
				_ASSERT( pMaster2 != 0 ) ;
			}
			//
			//	Check to see whether there is an extra reference that 
			//	now needs to be removed !
			//
			if( pExtraRef ) {
				long l = pExtraRef->Release(0,0) ;
				DebugTrace( DWORD_PTR(pExtraRef), "Removed temp ref from pExtraRef %x result %x this %x, pMaster %x", 
					pExtraRef, l, this, pMaster ) ;
			}
		}
		m_LRUList.RemoveEntry() ;
	}
	m_lock.ExclusiveUnlock() ;
}


#ifdef	DEBUG
BOOL
CacheState::IsOlder(	FILETIME	filetimeIn,
						FILETIME&	filetimeOut
						) {
/*++

Routine Description  :

	Check that our entry is older than the incoming time -
	NOTE, we will grab the ShareLock on the entry so that nobody
	else touches the time !

Arguments :

	filetimeIn - The time that this should be older than
	filetimeOut - Gets our time if possible

Return Value :

	TRUE if we are older than the specified time !

--*/

	BOOL	fReturn = TRUE ;
	filetimeOut = filetimeIn ;

	m_lock.ShareLock() ;

//	if( m_pData ) {
		fReturn = OlderThan( filetimeIn ) ;
		filetimeOut = m_LastAccess ;
//	}

	m_lock.ShareUnlock() ;

	return	fReturn ;
}
#endif




typedef	TDListIterator<	LRULIST	>	LRUITER ;

CLRUList::CLRUList() :
	m_lqModify( FALSE ),
	m_cMaxElements( 0 ),
	m_dwAverageInserts( 0 ),
	m_cCheckedOut( 0 ), 
	m_cItems ( 0 )	{
/*++

Routine Description :

	Do very basic initialization of the LRU List.
	Much more needs to be done through our Init() function.
	
Arguments :

	None.

Return Value :

	None.

--*/
	//TraceFunctEnter( "CLRUList::CLRUList" ) ;

	m_qwExpire.QuadPart = 0 ;
}

void
CLRUList::Init(	DWORD	dwMaxInstances,
				DWORD	dwLifetimeSeconds
				)	{
/*++

Routine Description :

	Set up our member variables !
	
Arguments :

	None.

Return Value :

	None.

--*/


	m_cMaxElements = dwMaxInstances ;
	m_qwExpire.QuadPart = DWORDLONG(dwLifetimeSeconds) * DWORDLONG( 10000000 ) ;


}

		

void
CLRUList::AddWorkQueue( 	CacheState*	pbase ) {

	TraceFunctEnter( "CLRUList::AddWorkQueue" ) ;
	DebugTrace( (DWORD_PTR)this, "pbase %x", pbase ) ;

	_ASSERT( pbase->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;

	m_lqModify.Append( pbase ) ;

}

void
CLRUList::DrainWorkQueue()	{

	CacheState*	pbase = 0 ;
	while( (pbase = m_lqModify.Remove()) != 0 ) {
	
		_ASSERT( !pbase->InCache() ) ;
		_ASSERT( !pbase->IsInLRUList() ) ;
		_ASSERT(pbase->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;

		long l = pbase->Release( 0, 0 ) ;
		_ASSERT( l==0 ) ;
	}
}

//
//	This function examines each item in the Work Queue and does
//	appropriate processing !
//
void
CLRUList::ProcessWorkQueue(	CAllocatorCache*	pAllocatorCache, 
							LPVOID				lpv 
							)	{

	TraceQuietEnter( "CLRUList::ProcessWorkQueue" ) ;

	FILETIME	filetimeNow ;
	GetSystemTimeAsFileTime( &filetimeNow ) ;

	CacheState*	pbase = 0 ;
	while( (pbase = m_lqModify.Remove()) != 0 ) {
		//
		//	examine the LRU item - and take appropriate action !
		//
		pbase->m_lock.ShareLock() ;

		//
		//	NOW - check to see if the item has been removed from the hash table - 
		//	in which case we just release our reference and move on !
		//

		if( !pbase->InCache() )		{
			pbase->m_lock.ShareUnlock() ;
			long l = pbase->Release( pAllocatorCache, lpv ) ;
		}	else	{

			long l = pbase->Release( pAllocatorCache, lpv ) ;
			//
			//	If the item is still in the hash table this should not have released the last reference !!!
			//
			_ASSERT( l != 0 ) ;

			_ASSERT(pbase->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;


			BOOL	fOut = pbase->IsCheckedOut() ;
			BOOL	fLRU = pbase->IsInLRUList() ;

			DebugTrace( (DWORD_PTR)this, "pbase %x fOut %x fLRU %x", pbase, fOut, fLRU ) ;

			//
			//	There are 4 cases -
			//
			//                 in LRU   out LRU
			//	checked in        A        X
			//	checked out       X        B
			//
			//	A - remove item from LRU List
			//	B - put item in LRU list
			//	X - No work required !
			//
			if( fOut == fLRU ) {

				if( fLRU ) {
					//
					//	Remove Item from LRU list !
					//
					m_LRUList.Remove( pbase ) ;

				}	else	{
					//
					//	put item in LRU list !
					//
				
					pbase->m_LastAccess = filetimeNow ;

					m_LRUList.PushBack( pbase ) ;
					
				}
			}
			pbase->m_lLRULock = 0 ;
			pbase->m_lock.ShareUnlock() ;
			_ASSERT(pbase->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
		}
	}


#ifdef	DEBUG	
		//
		//	Backwards iterator !
		//
		FILETIME	filetimeCur = filetimeNow ;
		LRUITER	iter( m_LRUList, FALSE ) ;	
		while( !iter.AtEnd() )	{
			FILETIME	filetimeNew ;
			_ASSERT( iter.Current()->IsOlder( filetimeCur, filetimeNew ) ) ;
			filetimeCur = filetimeNew ;
			iter.Prev() ;
		}
#endif

}

//
//
//
void
CLRUList::Expire(	
		CacheTable*	pTable,
		CAllocatorCache*	pCache,
		DWORD&	countExpired,
		void*	pv
		) {
/*++

Routine Description :

	This function expires items in the LRU List.
	We pick a bunch of guys to kick out of the cache.

Arguments :

	pTable - The object we use to manipulate locking
		and to remove items !
	countExpunged - Out parameter gets the number
		of items we've removed from the cache !

Return Value : 	

	None.

--*/

	TraceQuietEnter( "CLRUList::Expire" ) ;

	//DebugTrace( (DWORD_PTR)this, "Args - pTable %x pcache %x pv %x",
	//	pTable, pCache, pv ) ;

	countExpired = 0 ;

	//
	//	First get the list of candidates !
	//

	BOOL	fExpireChecks = TRUE ;

	LRULIST	list ;

	FILETIME	filetimeNow ;
	GetSystemTimeAsFileTime( &filetimeNow ) ;

	ULARGE_INTEGER	ulNow ;
	ulNow.LowPart = filetimeNow.dwLowDateTime ;
	ulNow.HighPart = filetimeNow.dwHighDateTime ;

	ulNow.QuadPart -= m_qwExpire.QuadPart ;

	filetimeNow.dwLowDateTime = ulNow.LowPart ;
	filetimeNow.dwHighDateTime = ulNow.HighPart ;

	CACHELOCK&	lock = pTable->GetLock() ;

	//
	//	First find the candidates !
	//
	lock.ExclusiveLock() ;

	//
	//	This will remove items from any list !
	//
	ProcessWorkQueue( pCache, pv ) ;

	{
		LRUITER	iter = m_LRUList ;	
		BOOL	fTerm = FALSE ;
		while( !iter.AtEnd() && !fTerm )	{
			CacheState*	pState = iter.Current() ;
			//DebugTrace( (DWORD_PTR)this, "Examining pState %x", pState ) ;
			_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
			BOOL	fLocked =  pState->FLockCandidate( fExpireChecks, filetimeNow, fTerm ) ;
			
			if( fExpireChecks ) {
				if( fTerm && m_cItems > (long)m_cMaxElements ) {
					fExpireChecks = FALSE ;
					fTerm = FALSE ;
				}
			}	else	{
				if( m_cItems <= (long)m_cMaxElements ) 
					fTerm = TRUE ;
			}

			if( fLocked )	{
				if( !pTable->RemoveEntry( pState ) )	{
					pState->m_lock.ExclusiveUnlock() ;
				}	else	{
					CacheState*	pTemp = iter.RemoveItem() ;
					_ASSERT( pTemp == pState ) ;
					_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
					list.PushFront( pTemp ) ;
					continue ;
				}
			}	
			iter.Next() ;
		}
	}

	lock.ExclusiveToPartial() ;

	LRUITER	iter = list ;
	while( !iter.AtEnd() ) {
		CacheState*	pState = iter.RemoveItem() ;
	
		//DebugTrace( (DWORD_PTR)this, "Destroying pState %x", pState ) ;

		_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
		//
		//	This entry has been removed from the cache -
		//	time to clean it up !
		//
		pState->FinishCandidate(pState) ;
		//
		//	This should remove the final reference !
		//
		long l = pState->Release( pCache, pv ) ;	
		_ASSERT( l==0 ) ;
	}
	lock.PartialUnlock() ;
}


BOOL
CLRUList::Empty(	
		CacheTable*	pTable,
		CAllocatorCache*	pCache,
		void*	pv
		) {
/*++

Routine Description :

	This function empties everything out of the cache !

Arguments :

	pTable - The object we use to manipulate locking
		and to remove items !

Return Value : 	

	None.

--*/

	TraceFunctEnter( "CLRUList::Empty" ) ;

	DebugTrace( (DWORD_PTR)this, "Args - pTable %x pcache %x pv %x",
		pTable, pCache, pv ) ;

	BOOL	fReturn = TRUE ;
	FILETIME	filetimeNow ;

	ZeroMemory( &filetimeNow, sizeof( filetimeNow ) ) ;

	//
	//	First get the list of candidates !
	//

	//
	//	This will remove items from any list !
	//
	ProcessWorkQueue( 0, 0 ) ;

	LRULIST	list ;

	{
		LRUITER	iter = m_LRUList ;	
		BOOL	fTerm = FALSE ;
		while( !iter.AtEnd() )	{
			CacheState*	pState = iter.Current() ;
			DebugTrace( (DWORD_PTR)this, "Examining pState %x", pState ) ;
			_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
			BOOL fLock = pState->FLockCandidate( FALSE, filetimeNow, fTerm ) ;

			_ASSERT( fLock ) ;

			if( fLock ) {
				if( !pTable->RemoveEntry( pState ) )	{
					fReturn = FALSE ;
					pState->m_lock.ExclusiveUnlock() ;
				}	else	{
					CacheState*	pTemp = iter.RemoveItem() ;
					_ASSERT( pTemp == pState ) ;
					_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
					list.PushFront( pTemp ) ;
					continue ;
				}
			}	
			iter.Next() ;
		}
	}

	LRUITER	iter = list ;
	while( !iter.AtEnd() ) {
		CacheState*	pState = iter.RemoveItem() ;
	
		DebugTrace( (DWORD_PTR)this, "Destroying pState %x", pState ) ;

		_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
		//
		//	This entry has been removed from the cache -
		//	time to clean it up !
		//
		pState->FinishCandidate(pState) ;
		//
		//	This should remove the final reference !
		//
		long l = pState->Release( pCache, pv ) ;	
		_ASSERT( l==0 ) ;
	}
	return	TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\cmmprops\cmmsprop.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmsprop.cpp

Abstract:

	This module contains the implementation of the special property class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	04/19/98	created

--*/

#include "windows.h"
#include <stdlib.h>
#include "dbgtrace.h"

#include "cmmsprop.h"

// =================================================================
// Implementation of CSpecialPropertyTable
//
int __cdecl CompareProperties(const void *pElem1, const void *pElem2)
{
	return(
		(((LPSPECIAL_PROPERTY_ITEM)pElem1)->idProp ==
		 ((LPSPECIAL_PROPERTY_ITEM)pElem2)->idProp) ?
		 0 :
			((((LPSPECIAL_PROPERTY_ITEM)pElem1)->idProp >
			((LPSPECIAL_PROPERTY_ITEM)pElem2)->idProp) ?
				1 : -1)
		);
}

CSpecialPropertyTable::CSpecialPropertyTable(
			LPPTABLE	pPropertyTable
			)
{
	_ASSERT(pPropertyTable);
	_ASSERT(pPropertyTable->pProperties);

	m_pProperties	= pPropertyTable->pProperties;
	m_dwProperties	= pPropertyTable->dwProperties;
	m_fIsSorted		= pPropertyTable->fIsSorted;
}

CSpecialPropertyTable::~CSpecialPropertyTable()
{
}

HRESULT CSpecialPropertyTable::GetProperty(
				PROP_ID		idProp,
				LPVOID		pContext,
				LPVOID		pParam,
				DWORD		ptBaseType,
				DWORD		cbLength,
				DWORD		*pcbLength,
				LPBYTE		pbBuffer,
				BOOL		fCheckAccess
				)
{
	HRESULT					hrRes	= S_OK;
	LPSPECIAL_PROPERTY_ITEM	pItem;

	TraceFunctEnterEx((LPARAM)this, "CSpecialPropertyTable::GetProperty");

	if (!pcbLength || !pbBuffer)
		return(E_POINTER);

	// Find the property
	pItem = SearchForProperty(idProp);

	// Found?
	if (pItem)
	{
		// Access check if applicable
		if (fCheckAccess && !(pItem->fAccess & PA_READ))
			hrRes = E_ACCESSDENIED;
		else
		{
			// Check the type
			if ((ptBaseType != PT_NONE) &&
				(ptBaseType != pItem->ptBaseType))
				hrRes = TYPE_E_TYPEMISMATCH;
			else
			{
				// Call the special get accessor
				hrRes = pItem->pfnGetAccessor(
							idProp,
							pContext,
							pParam,
							cbLength,
							pcbLength,
							pbBuffer);
			}
		}
	}
	else
		hrRes = S_FALSE;

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CSpecialPropertyTable::PutProperty(
				PROP_ID		idProp,
				LPVOID		pContext,
				LPVOID		pParam,
				DWORD		ptBaseType,
				DWORD		cbLength,
				LPBYTE		pbBuffer,
				BOOL		fCheckAccess
				)
{
	HRESULT					hrRes	= S_OK;
	LPSPECIAL_PROPERTY_ITEM	pItem;

	TraceFunctEnterEx((LPARAM)this, "CSpecialPropertyTable::PutProperty");

	if (!pbBuffer)
		return(E_POINTER);

	// Find the property
	pItem = SearchForProperty(idProp);

	// Found?
	if (pItem)
	{
		// Access check if applicable
		if (fCheckAccess && !(pItem->fAccess & PA_WRITE))
			hrRes = E_ACCESSDENIED;
		else
		{
			// Check the type
			if ((ptBaseType != PT_NONE) &&
				(ptBaseType != pItem->ptBaseType))
				hrRes = TYPE_E_TYPEMISMATCH;
			else
			{
				// Call the special put accessor
				hrRes = pItem->pfnPutAccessor(
							idProp,
							pContext,
							pParam,
							cbLength,
							pbBuffer);
			}
		}
	}
	else
		hrRes = S_FALSE;

	TraceFunctLeave();
	return(hrRes);
}

LPSPECIAL_PROPERTY_ITEM CSpecialPropertyTable::SearchForProperty(
			PROP_ID	idProp
			)
{
	LPSPECIAL_PROPERTY_ITEM	pItem = NULL;

	TraceFunctEnter("CSpecialPropertyTable::SearchForProperty");

	// If the table is sorted, we do a bsearch, otherwise we do
	// a inear search
	if (m_fIsSorted)
	{
		SPECIAL_PROPERTY_ITEM	KeyItem;

		DebugTrace(NULL, "Property table is sorted");

		// Fill in the property name to look for
		KeyItem.idProp = idProp;

		// Bsearch
		pItem = (LPSPECIAL_PROPERTY_ITEM)bsearch(
						&KeyItem,
						m_pProperties,
						m_dwProperties,
						sizeof(SPECIAL_PROPERTY_ITEM),
						CompareProperties);
	}
	else
	{
		DWORD			i;
		LPSPECIAL_PROPERTY_ITEM pCurrentItem;

		DebugTrace(NULL, "Property table is not sorted");

		// Linear search
		pItem = NULL;
		for (i = 0, pCurrentItem = m_pProperties; 
				i < m_dwProperties; 
				i++, pCurrentItem++)
			if (pCurrentItem->idProp == idProp)
			{
				pItem = pCurrentItem;
				break;
			}
	}

	TraceFunctLeave();
	return(pItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\cmmprops\cmmprops.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmmprops.cpp

Abstract:

    This module contains the implementation of the property search class

Author:

    Keith Lau   (keithlau@microsoft.com)

Revision History:

    keithlau    03/05/98    created

--*/

#include <windows.h>
#include <malloc.h>
#include <stdlib.h>
#include <search.h>

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmprops.h"
#include "cmmtypes.h"
#include "stddef.h"


long g_cCPropertyTableCreations = 0;
long g_cCPropertyTableSearchs = 0;

// =================================================================
// Implementation of CPropertyTableItem
//
CPropertyTableItem::CPropertyTableItem(
            CBlockManager               *pBlockManager,
            LPPROPERTY_TABLE_INSTANCE   pInstanceInfo
            )
{
    _ASSERT(pInstanceInfo);
    _ASSERT(pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::CPropertyTableItem");

    m_pInstanceInfo = pInstanceInfo;
    m_pBlockManager = pBlockManager;
    m_fLoaded = FALSE;

    m_dwCurrentFragment = 0;
    m_faOffsetToFragment = 0;
    m_dwCurrentItem = 0;
    m_dwCurrentItemInFragment = 0;
    m_faOffsetToCurrentItem = INVALID_FLAT_ADDRESS;

    TraceFunctLeaveEx((LPARAM)this);
}

CPropertyTableItem::~CPropertyTableItem()
{
    _ASSERT(m_pInstanceInfo);
    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::~CPropertyTableItem");

    m_pInstanceInfo = NULL;
    m_pBlockManager = NULL;
    m_fLoaded = FALSE;
    m_dwCurrentFragment = 0;
    m_faOffsetToFragment = 0;
    m_dwCurrentItem = 0;
    m_dwCurrentItemInFragment = 0;
    m_faOffsetToCurrentItem = INVALID_FLAT_ADDRESS;

    TraceFunctLeaveEx((LPARAM)this);
}


HRESULT CPropertyTableItem::AddItem(
            LPPROPERTY_ITEM pItem,
            DWORD           *pdwIndex,
            FLAT_ADDRESS    *pfaOffsetToItem
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwPropertyId;
    DWORD   dwFragmentNumber;
    DWORD   dwItemsInFragment;
    DWORD   dwItemInFragment;
    DWORD   dwSize;
    FLAT_ADDRESS    faOffset;

    _ASSERT(pdwIndex);
    _ASSERT(m_pInstanceInfo);
    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::AddItem");

    for (;;)
    {
        // OK, first we determine if we need to create a new fragment
        // before we move on ...
        dwPropertyId = m_pInstanceInfo->dwProperties;

        // Find out about our fragment type
        dwItemsInFragment = 1 << m_pInstanceInfo->dwItemBits;
        dwItemInFragment = dwPropertyId & (dwItemsInFragment - 1);
        dwFragmentNumber = dwPropertyId >> m_pInstanceInfo->dwItemBits;
        dwSize = m_pInstanceInfo->dwItemSize;

        // See if we already have the desired fragment
        hrRes = ReadFragmentFromFragmentNumber(dwFragmentNumber);
        if (!SUCCEEDED(hrRes))
        {
            // It's some other error, return failure ...
            if (hrRes != STG_E_PATHNOTFOUND)
            {
                ErrorTrace((LPARAM)this,
                            "Unable to ReadFragmentFromFragmentNumber");
                TraceFunctLeaveEx((LPARAM)this);
                return(hrRes);
            }

            if (dwFragmentNumber && (m_dwCurrentFragment < dwFragmentNumber))
            {
                // This is really embarassing, we are on a new fragment
                // but the fragment(s) before that are still not created
                // yet, we got to retry at this point ...
                continue;
            }

            // OK, so the fragment is not created yet, see if we need to
            // create it. THe first entry in a new fragment is responsible
            // for creating the fragment
            if (!dwItemInFragment)
            {
                // Build a new fragment structure ...
                DWORD                   dwOffset;
                FLAT_ADDRESS            faOffsetSlot;
                FLAT_ADDRESS            *pfaOffset;
                PROPERTY_TABLE_FRAGMENT ifFragment;
                ifFragment.dwSignature = PROPERTY_FRAGMENT_SIGNATURE_VALID;
                ifFragment.faNextFragment = INVALID_FLAT_ADDRESS;

                // The next ten or so lines of code is very tricky.
                // If we are at the first fragment (i.e. no fragments
                // have been created yet), then we would actually have to
                // fill in the offset of the allocated block into the
                // m_pInstanceInfo->faFirstFragment variable. Note that
                // pfaOffset is passed into AtomicAllocWriteAndIncrement
                // and the value is assigned INSIDE the locked region,
                // which makes this assignment thread-safe.
                //
                // For the other case, we need to fill in the parent's
                // faNextFragment member to link to the newly allocated
                // block. Now, since ReadFragmentFromFragmentNumber must
                // have failed beforehand at the node right before us.
                // m_faOffsetToFragment actually points to our parent's
                // fragment. So we pass in the offset of our parent's
                // faNextFragment value so the atomic operation can
                // fill it in for us.
                if (!dwFragmentNumber)
                {
                    // Hook up the first fragment
                    // _ASSERT(m_pInstanceInfo->faFirstFragment ==
                    //                  INVALID_FLAT_ADDRESS);
                    pfaOffset = &(m_pInstanceInfo->faFirstFragment);
                    faOffsetSlot = INVALID_FLAT_ADDRESS;
                }
                else
                {
                    // Hook up subsequent fragments to its parent
                    //_ASSERT(m_Fragment.faNextFragment == INVALID_FLAT_ADDRESS);
                    //_ASSERT(m_dwCurrentFragment == dwFragmentNumber);
                    pfaOffset = &faOffset;
                    faOffsetSlot = m_faOffsetToFragment +
                            offsetof(PROPERTY_TABLE_FRAGMENT, faNextFragment);
                }

                // Attempt to create the fragment, add the item to
                // the beginning of the new fragment, and increment the
                // property count in one atomic shot
                dwOffset = (dwItemInFragment * dwSize) +
                            sizeof(PROPERTY_TABLE_FRAGMENT);
                hrRes = m_pBlockManager->AtomicAllocWriteAndIncrement(
                            m_pInstanceInfo->dwFragmentSize,
                            pfaOffset,
                            faOffsetSlot,
                            INVALID_FLAT_ADDRESS,
                            (LPBYTE)&ifFragment,
                            sizeof(PROPERTY_TABLE_FRAGMENT),
                            (LPBYTE)pItem,
                            dwOffset,
                            dwSize,
                            &(m_pInstanceInfo->dwProperties),
                            dwPropertyId,
                            1,
                            &m_bcContext
                            );
                if (pfaOffsetToItem) *pfaOffsetToItem = *pfaOffset + dwOffset;
                if (!SUCCEEDED(hrRes))
                {
                    // We can fail for 2 reasons: Error or Retry; we bail
                    // out if it's an error.
                    if (hrRes != HRESULT_FROM_WIN32(ERROR_RETRY))
                    {
                        // Bail out!
                        ErrorTrace((LPARAM)this,
                            "Failed to AtomicAllocWriteAndIncrement (%08x)",
                            hrRes);
                        break;
                    }
                }
                else
                {
                    // Success
                    DebugTrace((LPARAM)this,
                            "Succeeded to AtomicAllocWriteAndIncrement!");

                    // We might want to update some internal members
                    // First, hook up the previous fragment to this new
                    // fragment.
                    _ASSERT(*pfaOffset != INVALID_FLAT_ADDRESS);
                    CopyMemory(&m_Fragment,
                                &ifFragment,
                                sizeof(PROPERTY_TABLE_FRAGMENT));
                    m_dwCurrentFragment = dwFragmentNumber;
                    m_faOffsetToFragment = *pfaOffset;
                    m_dwCurrentItem = dwPropertyId;
                    m_dwCurrentItemInFragment = dwItemInFragment;
                    m_fLoaded = TRUE;
                    break;
                }

                // Oooops, someone beat us in using this property ID,
                // we must retry immediately. Note since the state already
                // changed we would not be required to wait.
                continue;
            }

            // This is the most expensive case, basically, there is nothing
            // we can do but give up the time slice, I think besides changing
            // algorithm, this is the bast since I'd rather context switch
            // right away than switch after exhausting the time quanta
            Sleep(0);
            continue;
        }

        // This is the simplest case where we don't have to create a new
        // fragment so all we do is attempt an atomic write and increment
        // Still, there will be a window where some other thread might
        // beat us in using this property ID. In that case, we will retry
        // immediately.
        faOffset = m_faOffsetToFragment + sizeof(PROPERTY_TABLE_FRAGMENT) +
                        (dwItemInFragment * dwSize);
        hrRes = m_pBlockManager->AtomicWriteAndIncrement(
                        (LPBYTE)pItem,
                        faOffset,
                        dwSize,
                        &(m_pInstanceInfo->dwProperties),
                        dwPropertyId,
                        1,
                        &m_bcContext
                        );
        if (pfaOffsetToItem) *pfaOffsetToItem = faOffset;
        if (!SUCCEEDED(hrRes))
        {
            // We can fail for 2 reasons: Error or Retry; we bail
            // out if it's an error.
            if (hrRes != HRESULT_FROM_WIN32(ERROR_RETRY))
            {
                // Bail out!
                ErrorTrace((LPARAM)this,
                    "Failed to AtomicWriteAndIncrement (%08x)",
                    hrRes);
                break;
            }
        }
        else
        {
            // Success
            DebugTrace((LPARAM)this,
                    "Succeeded to AtomicWriteAndIncrement!");
            break;
        }

        // Retry scenario ...

    } // for (;;)

    // Fill in info ...
    if (SUCCEEDED(hrRes))
    {
        *pdwIndex = dwPropertyId;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT CPropertyTableItem::UpdateItem(
            DWORD           dwIndex,
            LPPROPERTY_ITEM pItem,
            FLAT_ADDRESS    *pfaOffsetToItem
            )
{
    HRESULT hrRes = S_OK;

    _ASSERT(m_pInstanceInfo);
    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::UpdateItem");

    // Atomically set the item
    m_fLoaded = FALSE;
    m_dwCurrentItem = dwIndex;
    hrRes = GetOrSetNextExistingItem(pItem, PIO_ATOMIC_WRITE_ITEM, pfaOffsetToItem);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT CPropertyTableItem::GetItemAtIndex(
            DWORD           dwIndex,
            LPPROPERTY_ITEM pItem,
            LPFLAT_ADDRESS  pfaOffset
            )
{
    HRESULT hrRes;

    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::GetItemAtIndex");

    // Just pre-set to what we want, and call GetOrSetNextExistingItem ...
    m_fLoaded = FALSE;
    m_dwCurrentItem = dwIndex;
    hrRes = GetOrSetNextExistingItem(pItem, PIO_READ_ITEM, pfaOffset);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT CPropertyTableItem::GetNextItem(
            LPPROPERTY_ITEM pItem
            )
{
    HRESULT hrRes;

    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::GetNextItem");

    // Just call GetOrSetNextExistingItem ...
    hrRes = GetOrSetNextExistingItem(pItem, PIO_READ_ITEM);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


HRESULT CPropertyTableItem::GetOrSetNextExistingItem(
            // This looks at m_dwCurrentItem for index
            LPPROPERTY_ITEM pItem,
            DWORD           dwOperation,
            LPFLAT_ADDRESS  pfaOffset
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwCurrentItem;

    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::GetOrSetNextExistingItem");

    // See if we are still in range
    dwCurrentItem = m_dwCurrentItem;
    if (m_fLoaded)
        dwCurrentItem++;

    // If we are at the end, respond so.
    if (dwCurrentItem == m_pInstanceInfo->dwProperties)
    {
        m_fLoaded = FALSE;
        return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    // We are blatantly out-of-range!
    if (dwCurrentItem > m_pInstanceInfo->dwProperties)
    {
        m_fLoaded = FALSE;
        return(STG_E_INVALIDPARAMETER);
    }

    m_dwCurrentItem = dwCurrentItem;

    // See if we are still in the current fragment
    if (!m_fLoaded ||
        (++m_dwCurrentItemInFragment >= (DWORD)(1 << m_pInstanceInfo->dwItemBits)))
    {
        FLAT_ADDRESS    faOffsetOfFragment;

        // We need to load a fragment
        if (!m_fLoaded)
        {
            DWORD   dwWhichFragment =
                        m_dwCurrentItem >> m_pInstanceInfo->dwItemBits;

            // Get the offset to the current fragment
            hrRes = ReadFragmentFromFragmentNumber(dwWhichFragment);
            if (!SUCCEEDED(hrRes))
                return(hrRes);
            _ASSERT(SUCCEEDED(hrRes));

            // Calculate the current item w.r.t the fragment
            m_dwCurrentItemInFragment = m_dwCurrentItem &
                        ((1 << m_pInstanceInfo->dwItemBits) - 1);
        }
        else
        {
            // Walk to next node
            faOffsetOfFragment = m_Fragment.faNextFragment;
            hrRes = ReadFragment(faOffsetOfFragment);
            if (!SUCCEEDED(hrRes))
            {
                ErrorTrace((LPARAM)this,
                            "Unable to load fragmentat offset %u",
                            (DWORD)faOffsetOfFragment);
                TraceFunctLeaveEx((LPARAM)this);
                return(hrRes);
            }

            // Okay, reset the current item
            m_dwCurrentFragment++;
            m_dwCurrentItemInFragment = 0;
        }
    }

    // Make sure what we have makes sense
    _ASSERT(m_dwCurrentItemInFragment < (DWORD)(1 << m_pInstanceInfo->dwItemBits));

    FLAT_ADDRESS    faOperateOffset =
                    m_faOffsetToFragment + sizeof(PROPERTY_TABLE_FRAGMENT) +
                    (m_dwCurrentItemInFragment * m_pInstanceInfo->dwItemSize);

    switch (dwOperation)
    {
    case PIO_READ_ITEM:

        // OK, Issue a read to get the item entry.
        DebugTrace((LPARAM)this, "Reading item");
        hrRes = ReadItem(faOperateOffset, pItem);
        if (SUCCEEDED(hrRes))
            m_faOffsetToCurrentItem = faOperateOffset;
        break;

    case PIO_WRITE_ITEM:
    case PIO_ATOMIC_WRITE_ITEM:

        // OK, Issue a write to set the item entry.
        DebugTrace((LPARAM)this, "Writing item%s",
                (dwOperation == PIO_ATOMIC_WRITE_ITEM)?" atomically":"");
        hrRes = WriteItem(faOperateOffset, pItem,
                    (dwOperation == PIO_ATOMIC_WRITE_ITEM));
        if (SUCCEEDED(hrRes))
            m_faOffsetToCurrentItem = faOperateOffset;
        break;

    default:
        _ASSERT(FALSE);
        ErrorTrace((LPARAM)this,
                "Invalid operation %u", dwOperation);
        hrRes = STG_E_INVALIDFUNCTION;
    }

    if (SUCCEEDED(hrRes) && pfaOffset)
        *pfaOffset = faOperateOffset;

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

inline HRESULT CPropertyTableItem::ReadFragmentFromFragmentNumber(
            DWORD           dwFragmentNumber
            )
{
    HRESULT hrRes;
    FLAT_ADDRESS    faOffsetOfFragment;

    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this,
                "CPropertyTableItem::ReadFragmentFromFragmentNumber");

    // Note this is strictly internal so we don't do much checking

    // Initially point to sentinel
    m_fLoaded = FALSE;
    m_dwCurrentFragment = 0;
    faOffsetOfFragment = m_pInstanceInfo->faFirstFragment;
    do
    {
        // Now if we are only one away from the desired node, but the
        // fragment does not exist, we will return a special code to
        // indicate that
        if (faOffsetOfFragment == INVALID_FLAT_ADDRESS)
        {
            DebugTrace((LPARAM)this,
                        "Unable to load fragment at offset %u (INVALID_FLAT_ADDRESS)",
                        (DWORD)faOffsetOfFragment);
            hrRes = STG_E_PATHNOTFOUND;
            break;
        }

        hrRes = ReadFragment(faOffsetOfFragment);
        if (!SUCCEEDED(hrRes))
        {
            ErrorTrace((LPARAM)this,
                        "Unable to load fragment %u at offset %u",
                        dwFragmentNumber, (DWORD)faOffsetOfFragment);
            break;
        }

        // Walk to next node
        m_dwCurrentFragment++;
        faOffsetOfFragment = m_Fragment.faNextFragment;

    } while (dwFragmentNumber--);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

inline HRESULT CPropertyTableItem::ReadFragment(
            FLAT_ADDRESS    faOffset
            )
{
    HRESULT hrRes;
    DWORD   dwSize;

    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::ReadFragment");

    // Is the fragment correct?
    if (faOffset == INVALID_FLAT_ADDRESS)
        return(STG_E_INVALIDPARAMETER);

    // Load up the minimal fragment header
    hrRes = m_pBlockManager->ReadMemory(
                    (LPBYTE)&m_Fragment,
                    faOffset,
                    sizeof(PROPERTY_TABLE_FRAGMENT),
                    &dwSize,
                    &m_bcContext);
    if (SUCCEEDED(hrRes))
    {
        m_fLoaded = TRUE;
        m_faOffsetToFragment = faOffset;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

inline HRESULT CPropertyTableItem::ReadItem(
            FLAT_ADDRESS    faOffset,
            LPPROPERTY_ITEM pItem
            )
{
    HRESULT hrRes;
    DWORD   dwSize;

    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::ReadItem");

    hrRes = m_pBlockManager->ReadMemory(
                (LPBYTE)pItem,
                faOffset,
                m_pInstanceInfo->dwItemSize,
                &dwSize,
                &m_bcContext);

    DebugTrace((LPARAM)this,
                "Loaded item from offset %u, HRESULT = %08x",
                (DWORD)faOffset, hrRes);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

inline HRESULT CPropertyTableItem::WriteItem(
            FLAT_ADDRESS    faOffset,
            LPPROPERTY_ITEM pItem,
            BOOL            fAtomic
            )
{
    HRESULT hrRes;
    DWORD   dwSize;

    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::WriteItem");

    if (fAtomic)
    {
        hrRes = m_pBlockManager->AtomicWriteAndIncrement(
                    (LPBYTE)pItem,
                    faOffset,
                    m_pInstanceInfo->dwItemSize,
                    NULL,   // No increment value, just a write
                    0,
                    0,
                    &m_bcContext);
    }
    else
    {
        hrRes = m_pBlockManager->WriteMemory(
                    (LPBYTE)pItem,
                    faOffset,
                    m_pInstanceInfo->dwItemSize,
                    &dwSize,
                    &m_bcContext);
    }

    DebugTrace((LPARAM)this,
                "Written item to offset %u, HRESULT = %08x",
                (DWORD)faOffset, hrRes);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

// =================================================================
// Implementation of CPropertyTable
//

CPropertyTable::CPropertyTable(
            PROPERTY_TABLE_TYPES        pttTableType,
            DWORD                       dwValidSignature,
            CBlockManager               *pBlockManager,
            LPPROPERTY_TABLE_INSTANCE   pInstanceInfo,
            LPPROPERTY_COMPARE_FUNCTION pfnCompare,
            const LPINTERNAL_PROPERTY_ITEM  pInternalProperties,
            DWORD                       dwInternalProperties
            )
{
    _ASSERT(pBlockManager);
    _ASSERT(pInstanceInfo);
    _ASSERT(pfnCompare);


    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::CPropertyTable");

    // Invalidate before initialization
    m_dwSignature = CPROPERTY_TABLE_SIGNATURE_INVALID;

    if (pttTableType == PTT_PROPERTY_TABLE)
    {
        // Enforce very strict checking of consistency
        if (!pInternalProperties)
        {
            _ASSERT(!dwInternalProperties);
        }
        else
        {
            _ASSERT(dwInternalProperties);
        }
    }
    else
    {
        // These parameters must not be set if the table is other
        // than a property table
        _ASSERT(!pInternalProperties);
        _ASSERT(!dwInternalProperties);
    }

    // Initialize internals
    m_dwTableType           = pttTableType;
    m_pBlockManager         = pBlockManager;
    m_pfnCompare            = pfnCompare;
    m_pInstanceInfo         = pInstanceInfo;
    m_pInternalProperties   = pInternalProperties;
    m_dwInternalProperties  = dwInternalProperties;
    m_dwValidInstanceSignature = dwValidSignature;

    // Validate the instance info structure
    /*
    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pInstanceInfo->dwFragmentSize ==
            ((m_pInstanceInfo->dwItemSize << m_pInstanceInfo->dwItemBits) +
            sizeof(PROPERTY_TABLE_FRAGMENT)));
    */

    // figure out what sort of mailmsg property table we are creating.
    // if its the global property table then setup member variables to
    // do property caching.
    //
    // There is no reason to cache recipient property offsets at this
    // time since the recipient property table is instantiated, used
    // once, then thrown away.  we'd spend more time making the cache
    // then the linear search in SearchForProperty costs
    if (m_dwValidInstanceSignature == GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID) {
        m_iCachedPropsBase = IMMPID_MP_BEFORE__+1;
        m_cCachedProps = IMMPID_MP_AFTER__ - m_iCachedPropsBase;
    } else {
        m_iCachedPropsBase = 0xffffffff;
        m_cCachedProps = 0;
    }

    // this is allocated and filled in lazily in InitializePropCache()
    m_rgCachedProps = NULL;

    // Validate the property table object
    m_dwSignature = CPROPERTY_TABLE_SIGNATURE_VALID;

    TraceFunctLeaveEx((LPARAM)this);
}

CPropertyTable::~CPropertyTable()
{
    _ASSERT(IsValid());

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::~CPropertyTable");

    // Invalidate!
    m_dwSignature = CPROPERTY_TABLE_SIGNATURE_INVALID;

    // free memory
    if (m_rgCachedProps) {
        _ASSERT(m_cCachedProps != 0);
        CMemoryAccess::FreeBlock(m_rgCachedProps);
        m_rgCachedProps = NULL;
        m_iCachedPropsBase = 0xffffffff;
        m_cCachedProps = 0;
    }

    // Wipe out all info so we make sure we AV if we access this
    // afterwards
    // Initialize internals
    m_dwTableType           = PTT_INVALID_TYPE;
    m_pBlockManager         = NULL;
    m_pfnCompare            = NULL;
    m_pInstanceInfo         = NULL;
    m_pInternalProperties   = NULL;
    m_dwInternalProperties  = 0;

    TraceFunctLeaveEx((LPARAM)this);
}

BOOL CPropertyTable::IsValid()
{
    return((m_dwSignature == CPROPERTY_TABLE_SIGNATURE_VALID));
}

BOOL CPropertyTable::IsInstanceInfoValid()
{
    BOOL    fRet = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::IsInstanceInfoValid");

    if (m_pInstanceInfo &&
        m_pInstanceInfo->dwSignature == m_dwValidInstanceSignature)
    {
        fRet = TRUE;
    }
    else
    {
        ErrorTrace((LPARAM)this, "Invalid signature");
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fRet);
}

HRESULT CPropertyTable::GetCount(
            DWORD       *pdwCount
            )
{
    _ASSERT(IsInstanceInfoValid());
    _ASSERT(pdwCount);

    if (!IsInstanceInfoValid())
        return(STG_E_INVALIDHEADER);

    *pdwCount = m_pInstanceInfo->dwProperties;
    return(S_OK);
}


HRESULT CPropertyTable::GetPropertyItem(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem
            )
{
    HRESULT hrRes           = S_OK;
    DWORD   dwCurrentItem   = 0;

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pfnCompare);
    _ASSERT(pvPropKey);
    _ASSERT(pItem);

    TraceFunctEnter("CPropertyTable::GetPropertyItem");

    hrRes = SearchForProperty(pvPropKey, pItem, NULL, NULL);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CPropertyTable::GetPropertyItemAndValue(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem,
            DWORD           dwLength,
            DWORD           *pdwLengthRead,
            LPBYTE          pbValue
            )
{
    HRESULT         hrRes;
    FLAT_ADDRESS    faItemOffset;

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pBlockManager);
    _ASSERT(pvPropKey);
    _ASSERT(pdwLengthRead);
    _ASSERT(pItem);
    _ASSERT(pbValue);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::GetPropertyItemAndValue");

    // First, find the property
    hrRes = SearchForProperty(pvPropKey, pItem, NULL, &faItemOffset);
    if (SUCCEEDED(hrRes))
    {
        // OK, the item is found. Since the offset and length fields could
        // have changed between SearchForProperty and now, we need a protected
        // call to make sure we read the most up to date info as well as no
        // other thread can change it while we are reading.
        hrRes = m_pBlockManager->AtomicDereferenceAndRead(
                            pbValue,
                            &dwLength,
                            (LPBYTE)pItem,
                            faItemOffset,
                            m_pInstanceInfo->dwItemSize,
                            offsetof(PROPERTY_ITEM, faOffset),
                            offsetof(PROPERTY_ITEM, dwSize),
                            NULL);

        *pdwLengthRead = dwLength;

        DebugTrace((LPARAM)this,
                    "AtomicDereferenceAndRead: offset %u, size %u, HRESULT = %08x",
                    (DWORD)pItem->faOffset, pItem->dwSize, hrRes);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CPropertyTable::GetPropertyItemAndValueUsingIndex(
            DWORD           dwIndex,
            LPPROPERTY_ITEM pItem,
            DWORD           dwLength,
            DWORD           *pdwLengthRead,
            LPBYTE          pbValue
            )
{
    HRESULT         hrRes;
    FLAT_ADDRESS    faItemOffset;

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pBlockManager);
    _ASSERT(pdwLengthRead);
    _ASSERT(pItem);
    _ASSERT(pbValue);

    // We've read nothing so far
    *pdwLengthRead = 0;

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::GetPropertyItemAndValueUsingIndex");

    CPropertyTableItem      ptiItem(m_pBlockManager, m_pInstanceInfo);

    // First, load the specified property
    hrRes = ptiItem.GetItemAtIndex(dwIndex, pItem, &faItemOffset);
    if (SUCCEEDED(hrRes))
    {
        // OK, the item is found. Since the offset and length fields could
        // have changed between SearchForProperty and now, we need a protected
        // call to make sure we read the most up to date info as well as no
        // other thread can change it while we are reading.
        hrRes = m_pBlockManager->AtomicDereferenceAndRead(
                            pbValue,
                            &dwLength,
                            (LPBYTE)pItem,
                            faItemOffset,
                            m_pInstanceInfo->dwItemSize,
                            offsetof(PROPERTY_ITEM, faOffset),
                            offsetof(PROPERTY_ITEM, dwSize),
                            NULL);

		// Set the length read if we succeeded
		if (SUCCEEDED(hrRes))
			*pdwLengthRead = pItem->dwSize;

        DebugTrace((LPARAM)this,
                    "AtomicDereferenceAndRead: offset %u, size %u, HRESULT = %08x",
                    (DWORD)pItem->faOffset, pItem->dwSize, hrRes);
    }

    TraceFunctLeave();
    return(hrRes);
}


HRESULT CPropertyTable::PutProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem,
            DWORD           dwSize,
            LPBYTE          pbValue
            )
{
    HRESULT         hrRes;
    FLAT_ADDRESS    faItemOffset;
    DWORD           dwIndex;
    BOOL            fGrow           = FALSE;
    BOOL            fCreate         = FALSE;
    LPPROPERTY_ITEM pItemCopy       = NULL;

    CBlockContext   bcContext;

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pBlockManager);
    _ASSERT(pvPropKey);
    _ASSERT(pItem);
    // pbValue can be NULL

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::PutProperty");

    if (!pbValue && dwSize) return(E_POINTER);

    // OK, since the search will destroy the extra property info,
    // we must save it somewhere. Boy, this is ugly.
    // This cannot fail. If we run out of resources we will simply
    // get a stack overflow, which is the same as calling a function
    // and there's not enough space to create its stack.
    pItemCopy = (LPPROPERTY_ITEM)_alloca(m_pInstanceInfo->dwItemSize);
    MoveMemory((LPVOID)pItemCopy, (LPVOID)pItem, m_pInstanceInfo->dwItemSize);

    // First, see if the property exists
    hrRes = SearchForProperty(pvPropKey, pItem, &dwIndex, &faItemOffset);
    if (SUCCEEDED(hrRes))
    {
        // If we don't need to specify the value, we can skip this junk
        if (pbValue)
        {
            if (pItem->dwMaxSize >= dwSize)
            {
                // Best scenario: these's enough space for the new value
                DebugTrace((LPARAM)this,
                            "Replacing property %u at offset %u, %u bytes",
                            dwIndex, (DWORD)pItem->faOffset, dwSize);

                // Update pItem
                pItem->dwSize = dwSize;
            }
            else
            {
                // We must grow the property, then
                DebugTrace((LPARAM)this,
                            "Growing property %u at offset %u, from %u to %u bytes",
                            dwIndex, (DWORD)pItem->faOffset, pItem->dwSize, dwSize);
                fGrow = TRUE;
            }
        }
    }
    else
    {
        // See if the property is not found ...
        if (hrRes != STG_E_UNKNOWN)
        {
            // Nope, this is a genuine error!
            ErrorTrace((LPARAM)this,
                        "Error searching property: HRESULT = %08x", hrRes);
            TraceFunctLeave();
            return(hrRes);
        }

        // Create a new property
        DebugTrace((LPARAM)this,
                    "Creating new property, %u bytes", dwSize);
        fCreate = TRUE;
    }

    // See if we need any new space ...
    if (pbValue)
    {
        if (fCreate || fGrow)
        {
            FLAT_ADDRESS    faOffset;
            DWORD           dwAllocSize;

            // Allocate some new memory
            DebugTrace((LPARAM)this, "Allocating %u bytes", dwSize);

            hrRes = m_pBlockManager->AllocateMemory(
                            dwSize,
                            &faOffset,
                            &dwAllocSize,
                            &bcContext);
            if (!SUCCEEDED(hrRes))
            {
                DebugTrace((LPARAM)this, "Allocating failed: HRESULT = %08x", hrRes);
                TraceFunctLeave();
                return(hrRes);
            }

            // Update pItem
            pItem->faOffset = faOffset;
            pItem->dwSize = dwSize;
            pItem->dwMaxSize = dwAllocSize;
        }

        // Atomically write the value
        hrRes = m_pBlockManager->AtomicWriteAndIncrement(
                    pbValue,
                    pItem->faOffset,
                    pItem->dwSize,
                    NULL,
                    0,
                    0,
                    &bcContext);
    }

    if (SUCCEEDED(hrRes))
    {
        CPropertyTableItem  ptiItem(
                                m_pBlockManager,
                                m_pInstanceInfo);
        FLAT_ADDRESS faOffsetToItem;

        if (fCreate)
        {
            // Atomically create the record
            MoveMemory((LPVOID)pItemCopy, (LPVOID)pItem, sizeof(PROPERTY_ITEM));
            hrRes = ptiItem.AddItem(pItemCopy, &dwIndex, &faOffsetToItem);
            DebugTrace((LPARAM)this,
                    "AddItem: HRESULT = %08x, new index = %u", hrRes, dwIndex);
        }
        else
        {
            // Atomically update the item record
            hrRes = ptiItem.UpdateItem(dwIndex, pItem, &faOffsetToItem);
            DebugTrace((LPARAM)this,
                    "UpdateItem: HRESULT = %08x, index = %u", hrRes, dwIndex);
        }

        if (m_rgCachedProps && SUCCEEDED(hrRes)) {
            _ASSERT(faOffsetToItem != INVALID_FLAT_ADDRESS);
            UpdatePropCache(pItem, faOffsetToItem, dwIndex);
        }
    }

    if (SUCCEEDED(hrRes) && fCreate)
        hrRes = S_FALSE;

    TraceFunctLeave();
    return(hrRes);
}

int __cdecl CompareInternalProperties(const void *pElem1, const void *pElem2)
{
    if (((LPINTERNAL_PROPERTY_ITEM)pElem1)->idProp ==
        ((LPINTERNAL_PROPERTY_ITEM)pElem2)->idProp)
        return(0);
    else
    {
        if (((LPINTERNAL_PROPERTY_ITEM)pElem1)->idProp >
            ((LPINTERNAL_PROPERTY_ITEM)pElem2)->idProp)
            return(1);
    }
    return(-1);
}

//
// This function allocates and fills in m_rgCachedProps
//
void CPropertyTable::InitializePropCache() {
    // it should only be called when there are properties to cache
    _ASSERT(m_cCachedProps);

    // its okay if this allocation failed.  in that case we won't have
    // the m_rgCachedProps array and will do linear lookups
    if (FAILED(CMemoryAccess::AllocBlock((void **) &m_rgCachedProps,
                                         sizeof(PROPCACHEITEM) * m_cCachedProps)))
    {
        m_rgCachedProps = NULL;
    } else {
        InterlockedIncrement(&g_cCPropertyTableCreations);

        // invalidate all items in the cache
        for (DWORD i = 0; i < m_cCachedProps; i++) {
            m_rgCachedProps[i].fa = INVALID_FLAT_ADDRESS;
        }

        // update the cache from what is already in the table
        FLAT_ADDRESS fa;
        DWORD dwCurrentItem = 0;
        PROPERTY_ITEM *pItem = (PROPERTY_ITEM *) alloca(m_pInstanceInfo->dwItemSize);
        CPropertyTableItem ptiItem(m_pBlockManager, m_pInstanceInfo);
        HRESULT hrRes = ptiItem.GetItemAtIndex(dwCurrentItem, pItem, &fa);
        while (SUCCEEDED(hrRes))
        {
            // put every item that we come across into the cache
            UpdatePropCache(pItem, fa, dwCurrentItem);

            // Get the next one. We can do this because the item object
            // is single-threaded
            hrRes = ptiItem.GetNextItem(pItem);
            if (SUCCEEDED(hrRes)) ptiItem.GetOffsetToCurrentItem(&fa);
            dwCurrentItem++;
        }
        _ASSERT(hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }
}

//
// set an item in the property cache.  to invalidate an item pass in
// INVALID_FLAT_ADDRESS for fa.
//
void CPropertyTable::UpdatePropCache(LPPROPERTY_ITEM pItem,
                                     FLAT_ADDRESS fa,
                                     DWORD dwIndex)
{
    TraceFunctEnter("CPropertyTable::UpdatePropCache");

    int iCachedProp;
    if (m_dwValidInstanceSignature == GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID) {
        GLOBAL_PROPERTY_ITEM *pGlobalItem = (GLOBAL_PROPERTY_ITEM *) pItem;
        iCachedProp = MapCachedProp(pGlobalItem->idProp);
    } else {
        iCachedProp = -1;
    }
    if (iCachedProp != -1) {
        DebugTrace((LPARAM) this,
            "iCachedProp = 0x%x  fa = 0x%x  dwIndex = 0x%x m_rgCachedProps = 0x%x",
            iCachedProp, fa, dwIndex, m_rgCachedProps);
        m_rgCachedProps[iCachedProp].fa = fa;
        m_rgCachedProps[iCachedProp].dwIndex = dwIndex;
    }

    TraceFunctLeave();
}

HRESULT CPropertyTable::SearchForProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem,
            DWORD           *pdwIndexToItem,
            FLAT_ADDRESS    *pfaOffsetToItem
            )
{
    HRESULT hrRes           = S_OK;
    DWORD   dwCurrentItem   = 0;
    PROP_ID idProp;

    InterlockedIncrement(&g_cCPropertyTableSearchs);

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pBlockManager);
    _ASSERT(m_pfnCompare);
    _ASSERT(pvPropKey);
    _ASSERT(pItem);

    TraceFunctEnter("CPropertyTable::SearchForProperty");

    // Create an instance of the item object
    CPropertyTableItem  ptiItem(
                            m_pBlockManager,
                            m_pInstanceInfo);

    idProp = *(PROP_ID *) pvPropKey;

    // First, search the well-known properties
    if (m_dwInternalProperties &&
        m_dwTableType == PTT_PROPERTY_TABLE)
    {
        LPINTERNAL_PROPERTY_ITEM    pInternalItem = NULL;
        INTERNAL_PROPERTY_ITEM      KeyItem;

        // Bsearch
        KeyItem.idProp = idProp;
        pInternalItem = (LPINTERNAL_PROPERTY_ITEM)bsearch(
                                &KeyItem,
                                m_pInternalProperties,
                                m_dwInternalProperties,
                                sizeof(INTERNAL_PROPERTY_ITEM),
                                CompareInternalProperties);

        if (pInternalItem)
        {
            hrRes = ptiItem.GetItemAtIndex(pInternalItem->dwIndex, pItem);
            ptiItem.GetOffsetToCurrentItem(pfaOffsetToItem);
            if (pdwIndexToItem)
                *pdwIndexToItem = pInternalItem->dwIndex;
            return(hrRes);
        }

        // This is not a well-known property
        dwCurrentItem = m_dwInternalProperties;
    }

    DebugTrace((LPARAM)this, "Scanning Property table");

    //
    // see if its in the property cache
    //

    // get an index into the cache array
    int iCachedProp = MapCachedProp(idProp);

    // we lazily initialize the property cache the first time that we need it
    if (iCachedProp != -1 && !m_rgCachedProps) InitializePropCache();

    // if the cache is initialize and this should be in the case then
    // search for it
    if (iCachedProp != -1 && m_rgCachedProps) {
        // see if this cache item is valid, and verify that it points to
        // the item that the user wanted
        if ((pItem != NULL) &&
            (m_rgCachedProps[iCachedProp].fa != INVALID_FLAT_ADDRESS) &&
            SUCCEEDED(ptiItem.ReadItem(m_rgCachedProps[iCachedProp].fa, pItem)) &&
            SUCCEEDED(m_pfnCompare(pvPropKey, pItem)))
        {
            // we've got a winner!
            *pfaOffsetToItem = m_rgCachedProps[iCachedProp].fa;
            if (pdwIndexToItem)
                *pdwIndexToItem = m_rgCachedProps[iCachedProp].dwIndex;
            return S_OK;
        }
    } else if (iCachedProp != -1) {
        // this case can be hit if we couldn't allocate memory for the
        // property cache.  we just need to set iCachedProp back to -1
        // so that we do a linear search
        iCachedProp = -1;
    }
    hrRes = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    //
    // Linear Search
    //

#ifdef DEBUG
    //
    // In debug builds we do the linear search if we couldn't find it
    // in the cache.  we then make sure that the linear search failed
    // as well.
    //
    if (1) {
#else
    //
    // in retail builds we only do this when the data wasn't in the cache
    //
    if (iCachedProp == -1) {
#endif
        // Linear search
        FLAT_ADDRESS fa;

        // we don't want to walk with pItem because if we don't find the
        // item then we will trash whatever the user had placed in pItem
        PROPERTY_ITEM *pThisItem =
            (PROPERTY_ITEM *) _alloca(m_pInstanceInfo->dwItemSize);

        hrRes = ptiItem.GetItemAtIndex(dwCurrentItem, pThisItem, &fa);
        while (SUCCEEDED(hrRes))
        {
            // Call the user-supplied compare function
            hrRes = m_pfnCompare(pvPropKey, pThisItem);
            if (SUCCEEDED(hrRes))
                break;

            // Get the next one. We can do this because the item object
            // is single-threaded
            hrRes = ptiItem.GetNextItem(pThisItem);
            dwCurrentItem++;
        }
#ifdef DEBUG
        // if the item was found here, but not found in the cache,
        // then there is an inconsistency that needs to be debugged.
        if (iCachedProp != -1 && SUCCEEDED(hrRes)) {
            DebugTrace(0, "iCachedProp = %i", iCachedProp);
            _ASSERT(FALSE);
            // we dont' want debug builds to behave differently then
            // retail builds, so force it to fail
            hrRes = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        }
#endif

        // if we found the item then copy it from pThisItem to pItem
        if (SUCCEEDED(hrRes)) {
            memcpy(pItem, pThisItem, m_pInstanceInfo->dwItemSize);
        }
    }

    // OKay, if we have no more items, then we cannot find the item,
    // otherwise, we let the error code percolate up
    if (!SUCCEEDED(hrRes) &&
        hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
    {
        // Property not found
        hrRes = STG_E_UNKNOWN;
    }
    else
    {
        // Fill in the offset
        ptiItem.GetOffsetToCurrentItem(pfaOffsetToItem);
        if (pdwIndexToItem)
            *pdwIndexToItem = dwCurrentItem;
    }

    TraceFunctLeave();
    return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\cstream\utest\cstrmtst.cpp ===
#define INITGUID
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <ole2.h>
#include <stdio.h>
#include <cstream.h>

#define BUF_SIZE			1024
#define MAX_ITERATIONS		10

char _rgData[] = { \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" \
	"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" };

void Test_CStreamFile(void);

void __cdecl main(int argc, char *argv[])
{
    // Locals
    HRESULT     hr;

    // Init OLE
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        printf("Error - Unable to initialize OLE.\n");
        exit(1);
    }

	Test_CStreamFile();

    // Un-init OLE
    CoUninitialize();

    // Done
    return;
}


void Test_CStreamFile()
{
	HRESULT hr = NOERROR;
	HANDLE		hFile = INVALID_HANDLE_VALUE;
    CStreamFile	*pStream = NULL;
	STATSTG		stat = {0};
	LARGE_INTEGER	dlibMove = {0};
	ULARGE_INTEGER	ulibNew = {0};
	char	rgReadBuffer[BUF_SIZE];
	ULONG cb = 0;
	ULONG cbTotal = 0;

	while(TRUE)
	{
		// Open the file
		printf("Creating test file, \"write.tst\"...");
		hFile = CreateFile("write.tst",GENERIC_WRITE | GENERIC_READ,0,NULL,
			CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
		if( hFile == INVALID_HANDLE_VALUE )
		{
			printf("Error - Unable to create test file \"write.tst\"\n");
			break;
		}
		printf("successful.\n");

		// Wrap with stream
		printf("Wrapping file with CStreamFile...");
		pStream = new CStreamFile(hFile, TRUE);
		if( pStream == NULL )
		{
			printf("Error - Unable to create stream on file.\n");
			break;
		}
		printf("successful.\n");

		// write data
		printf("Writing %dk to stream...", BUF_SIZE*MAX_ITERATIONS/1024);
		for( int i = 0; i < MAX_ITERATIONS; i++ )
		{
			hr = pStream->Write(_rgData,BUF_SIZE,&cb);
			if( FAILED(hr) )
			{
				printf("pStream->Write failed, hr = 0x%08x\n",hr);
				break;
			}
			if( cb != BUF_SIZE )
			{
				printf("pStream->Write error, bytes written not correct!\n");
				break;
			}
		}
		printf("successful.\n");

		// get size and make sure its correct
		printf("Get the Streams stat struct...");
		hr = pStream->Stat(&stat,STATFLAG_NONAME);
		if( FAILED(hr) )
		{
			printf("pStream->Stat failed, hr = 0x%08x\n",hr);
			break;
		}
		printf("successful.\n");

		// is correct size reported
		printf("Checking reported size of file...");
		if( stat.cbSize.HighPart == 0 && stat.cbSize.LowPart == BUF_SIZE*MAX_ITERATIONS )
			printf("correct size reported.\n");
		else
			printf("INcorrect size reported!\n");

		// test seek STREAM_SEEK_SET
		printf("Resetting seek pointer to beginning...");
		dlibMove.QuadPart = 0;
		hr = pStream->Seek(dlibMove,STREAM_SEEK_SET,&ulibNew);
		if( FAILED(hr) )
		{
			printf("pStream->Seek failed, hr = 0x%08x\n",hr);
			break;
		}
		printf("successful.\n");

		// now read to end of file
		printf("Reading from stream...");
		cb = 0;
		while( SUCCEEDED(hr = pStream->Read(rgReadBuffer,sizeof(rgReadBuffer),&cb)) )
		{
			if( cb == 0 )
				break;
			cbTotal += cb;
		}
		if( FAILED(hr) )
		{
			printf("pStream->Read failed, hr = 0x%08x\n",hr);
			break;
		}
		if( cbTotal == BUF_SIZE*MAX_ITERATIONS )
			printf("successfully read %dk.\n",BUF_SIZE*MAX_ITERATIONS/1024);
		else
			printf("failed to read %dk!\n",BUF_SIZE*MAX_ITERATIONS/1024);

		// test seek STREAM_SEEK_CUR
		printf("Setting seek pointer back from current...");
		dlibMove.QuadPart = -BUF_SIZE*MAX_ITERATIONS/2;
		hr = pStream->Seek(dlibMove,STREAM_SEEK_CUR,&ulibNew);
		if( FAILED(hr) )
		{
			printf("pStream->Seek failed, hr = 0x%08x\n",hr);
			break;
		}
		printf("successful.\n");

		// now read to end of file
		printf("Reading from stream...");
		cb = 0;
		cbTotal = 0;
		while( SUCCEEDED(hr = pStream->Read(rgReadBuffer,sizeof(rgReadBuffer),&cb)) )
		{
			if( cb == 0 )
				break;
			cbTotal += cb;
		}
		if( FAILED(hr) )
		{
			printf("pStream->Read failed, hr = 0x%08x\n",hr);
			break;
		}
		if( cbTotal == BUF_SIZE*MAX_ITERATIONS/2 )
			printf("successfully read %dk.\n",BUF_SIZE*MAX_ITERATIONS/2);
		else
			printf("failed to read %dk!\n",BUF_SIZE*MAX_ITERATIONS/2);


		// test seek STREAM_SEEK_END
		printf("Setting seek pointer back from end...");
		dlibMove.QuadPart = -BUF_SIZE*MAX_ITERATIONS/4;
		hr = pStream->Seek(dlibMove,STREAM_SEEK_END,&ulibNew);
		if( FAILED(hr) )
		{
			printf("pStream->Seek failed, hr = 0x%08x\n",hr);
			break;
		}
		printf("successful.\n");

		// now read to end of file
		printf("Reading from stream...");
		cb = 0;
		cbTotal = 0;
		while( SUCCEEDED(hr = pStream->Read(rgReadBuffer,sizeof(rgReadBuffer),&cb)) )
		{
			if( cb == 0 )
				break;
			cbTotal += cb;
		}
		if( FAILED(hr) )
		{
			printf("pStream->Read failed, hr = 0x%08x\n",hr);
			break;
		}
		if( cbTotal == BUF_SIZE*MAX_ITERATIONS/4 )
			printf("successfully read %dk.\n",BUF_SIZE*MAX_ITERATIONS/4);
		else
			printf("failed to read %dk!\n",BUF_SIZE*MAX_ITERATIONS/4);
		
		printf("\nDone with CSteamFile tests.\n\n");
		
		break;
	}

    // Cleanup
    if(pStream)
        pStream->Release();

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\cstream\cstream.cpp ===
#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <cstream.h>
#include <dbgtrace.h>

#define Tracefn(fn)	

CImpIStream::CImpIStream(void)
{
	SYSTEMTIME st;

	Tracefn("CImpIStream::CImpIStream");
    m_cRef = 1;

	m_cbSeek = 0;
	m_statstg.cbSize.LowPart = 0;
	memset(&m_statstg,0,sizeof(STATSTG));

	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.ctime);
}


CImpIStream::~CImpIStream(void)
{
	Tracefn("CImpIStream::~CImpIStream");
}

STDMETHODIMP CImpIStream::QueryInterface(
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject)
{
	Tracefn("CImpIStream::QueryInterface");

	*ppvObject=NULL;

    if (IsEqualIID(riid, IID_IUnknown)
    	|| IsEqualIID(riid,IID_IStream))
        *ppvObject=(LPVOID)this;

	if( *ppvObject != NULL )
	{
        ((LPUNKNOWN)*ppvObject)->AddRef();
		return NOERROR;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CImpIStream::AddRef(void)
{
	Tracefn("CImpIStream::AddRef");
    InterlockedIncrement(&m_cRef);
	return m_cRef;
}

STDMETHODIMP_(ULONG) CImpIStream::Release(void)
{
    ULONG cRefT;
	Tracefn("CImpIStream::Release");
    cRefT = InterlockedDecrement(&m_cRef);
    if( 0 == cRefT )
        delete this;
    return cRefT;
}

STDMETHODIMP CImpIStream::Read(
    void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
	Tracefn("CImpIStream::Read");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::Write(
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
	Tracefn("CImpIStream::Write");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	Tracefn("CImpIStream::Seek")
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::SetSize(
    ULARGE_INTEGER libNewSize)
{
	Tracefn("CImpIStream::SetSize");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::CopyTo(
    IStream __RPC_FAR *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER __RPC_FAR *pcbRead,
    ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
	Tracefn("CImpIStream::CopyTo");
	return E_NOTIMPL;
}


STDMETHODIMP CImpIStream::Commit(
    DWORD grfCommitFlags)
{
	Tracefn("CImpIStream::Commit");
	return S_OK;
}

STDMETHODIMP CImpIStream::Revert( void)
{
	Tracefn("CImpIStream::Revert");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
	Tracefn("CImpIStream::LockRegion");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
	Tracefn("CImpIStream::UnlockRegion");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::Stat(
    STATSTG __RPC_FAR *pstatstg,
    DWORD grfStatFlag)
{
	STATSTG * pstat = NULL;
	Tracefn("CImpIStream::Stat");

	if( !pstatstg )
		return STG_E_INVALIDPOINTER;

	memcpy(pstatstg,&m_statstg,sizeof(STATSTG));

	return NOERROR;
}

STDMETHODIMP CImpIStream::Clone(
    IStream __RPC_FAR *__RPC_FAR *ppstm)
{
	Tracefn("CImpIStream::Clone");
	return E_NOTIMPL;
}


/* -------------------------------------------------------------------------
CStreamMem
------------------------------------------------------------------------- */
CStreamMem::CStreamMem(void)
{
	Tracefn("CStreamMem::CStreamMem");
	m_pvData = NULL;
	m_fExternalData = FALSE;
}

CStreamMem::CStreamMem(PVOID pvData,ULONG cbSize)
{
	Tracefn("CStreamMem::CStreamMem");
	m_pvData = pvData;
	m_cbSeek = 0;
	m_statstg.cbSize.LowPart = cbSize;
	m_fExternalData = TRUE;
}

CStreamMem::~CStreamMem(void)
{
	Tracefn("CStreamMem::~CStreamMem");
	if( m_pvData && !m_fExternalData )
		free(m_pvData);				
}

STDMETHODIMP CStreamMem::GetPointerFromStream(PVOID *ppv,DWORD *pdwSize)
{
	HRESULT hr = NOERROR;

	if( NULL == ppv || NULL == pdwSize )
		return STG_E_INVALIDPOINTER;

	if( NULL != m_pvData )
	{
		*ppv = m_pvData;
		*pdwSize = m_statstg.cbSize.LowPart;			
	}
	else
	{
		*ppv = NULL;
		*pdwSize = 0;
	}
	return hr;
}


// IStream
STDMETHODIMP CStreamMem::Read(
	void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
	SYSTEMTIME st;
	ULONG cbRead = 0;
	Tracefn("CStreamMem::Read");

	if( pcbRead != NULL )
		*pcbRead = 0;

	_ASSERT(m_cbSeek <= m_statstg.cbSize.LowPart);

	// anything to do?
	if( cb == 0 || m_statstg.cbSize.LowPart == 0 || m_cbSeek == m_statstg.cbSize.LowPart )
		return NOERROR;

	// determine amount to copy
	cbRead = min(cb,m_statstg.cbSize.LowPart - m_cbSeek);

	if( cbRead > 0 )
	{
		// copy it
		CopyMemory(pv,(PBYTE)m_pvData + m_cbSeek,cbRead);

		// adjust seek pointer
		m_cbSeek += cbRead;
	}

	// update access time
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.atime);

	if( pcbRead != NULL )
		*pcbRead = cbRead;

	_ASSERT(m_cbSeek <= m_statstg.cbSize.LowPart);

	return NOERROR;
}

STDMETHODIMP CStreamMem::Write(
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
	ULONG cbNewSize = 0;
	PVOID pvMem = NULL;
	SYSTEMTIME st;
	Tracefn("CStreamMem::Write");

	if( pcbWritten != NULL)
		*pcbWritten = 0;

	// external data is readonly
	if( m_fExternalData )
		return STG_E_MEDIUMFULL;

	// anything to do?
	if( cb == 0 )
		return NOERROR;

	// determine new size
	cbNewSize = max(m_cbSeek + cb, m_statstg.cbSize.LowPart);

	if( m_pvData == NULL )
	{
		// no memory alloc yet
		if( NULL == (m_pvData = malloc(cbNewSize)) )
			return STG_E_MEDIUMFULL;
		m_statstg.cbSize.LowPart = cbNewSize;
	}
	else if( cbNewSize > m_statstg.cbSize.LowPart )
	{
		// grow existing memory
		if( NULL == (pvMem = realloc(m_pvData,cbNewSize)) )
			return STG_E_MEDIUMFULL;
		m_pvData = pvMem;
		m_statstg.cbSize.LowPart = cbNewSize;
	}

	// copy mem
	CopyMemory((PBYTE)m_pvData + m_cbSeek,pv,cb);

	// adjust seek pointer
	m_cbSeek += cb;

	// set the number of bytes actually written
	m_statstg.cbSize.LowPart = max(m_statstg.cbSize.LowPart,m_cbSeek);

	// return bytes written
	if( pcbWritten != NULL)
		*pcbWritten = cb;

	// update modify time
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.mtime);

	return NOERROR;
}


STDMETHODIMP CStreamMem::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	Tracefn("CStreamMem::Seek");
	// can we handle the seek?
	if( dlibMove.HighPart != 0 )
		return STG_E_WRITEFAULT;

	// handle the seek request
	switch( dwOrigin)
	{
		case STREAM_SEEK_SET:
			if( dlibMove.LowPart > m_statstg.cbSize.LowPart )
				return STG_E_WRITEFAULT;
			m_cbSeek = dlibMove.LowPart;
			break;
		case STREAM_SEEK_CUR:
			if( dlibMove.LowPart + m_cbSeek > m_statstg.cbSize.LowPart )
				return STG_E_WRITEFAULT;
			m_cbSeek += (int)dlibMove.LowPart;
			break;
		case STREAM_SEEK_END:
			if ((int)dlibMove.LowPart > 0 ||
				(ULONG)(-(int)dlibMove.LowPart) > m_statstg.cbSize.LowPart)
			{
				return STG_E_WRITEFAULT;
			}
			m_cbSeek = m_statstg.cbSize.LowPart + (int)dlibMove.LowPart;
			break;
	}

	// return new seek position
	if( plibNewPosition )
	{
		plibNewPosition->HighPart = 0;
		plibNewPosition->LowPart = m_cbSeek;
	}
	
	return NOERROR;
}

STDMETHODIMP CStreamMem::SetSize(
    ULARGE_INTEGER libNewSize)
{
	PVOID pvMem = NULL;
	Tracefn("CStreamMem::SetSize");

	// external data is readonly
	if( m_fExternalData )
		return STG_E_MEDIUMFULL;

	// can we handle the new size?
	if( libNewSize.HighPart != 0 )
		return STG_E_MEDIUMFULL;

	// alloc mem
	if( !m_pvData )
		pvMem = malloc(libNewSize.LowPart);
	else
		pvMem = realloc(m_pvData,libNewSize.LowPart);
	if( !pvMem )
		return STG_E_MEDIUMFULL;

	// save mem info
	m_pvData = pvMem;
	m_statstg.cbSize.LowPart = libNewSize.LowPart;

	// adjust the number of bytes actually written
	m_statstg.cbSize.LowPart = min(m_statstg.cbSize.LowPart,m_statstg.cbSize.LowPart);

	return NOERROR;
}

STDMETHODIMP CStreamMem::CopyTo(
    IStream __RPC_FAR *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER __RPC_FAR *pcbRead,
    ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
	Tracefn("CStreamMem::CopyTo");
	HRESULT hr = NOERROR;
	ULONG cbBytes = 0;
	ULONG cbWritten = 0;

	if( pstm == NULL )
		return STG_E_INVALIDPOINTER;

	cbBytes = min(m_statstg.cbSize.LowPart - m_cbSeek,cb.LowPart);

	if( pcbRead )
		pcbRead->QuadPart = cbBytes;

	if( cbBytes == 0 )
		return NOERROR;

	hr = pstm->Write((PBYTE)m_pvData + m_cbSeek,cbBytes,&cbWritten);
	if( pcbWritten )
		pcbWritten->QuadPart = cbWritten;
	return hr;
}


/* -------------------------------------------------------------------------
CStreamFile
------------------------------------------------------------------------- */
CStreamFile::CStreamFile(HANDLE hFile,BOOL fCloseHandle, BOOL fReadOnly)
{
	Tracefn("CStreamFile::CStreamFile");
	_ASSERT(hFile != INVALID_HANDLE_VALUE);

	if( hFile == INVALID_HANDLE_VALUE )
		return;
	m_fCloseHandle = fCloseHandle;
	m_fReadOnly = fReadOnly;
	m_hFile = hFile;
	m_statstg.cbSize.LowPart = GetFileSize(m_hFile,NULL);
}

CStreamFile::~CStreamFile(void)
{
	Tracefn("CStreamFile::~CStreamFile");
	if( m_fCloseHandle && m_hFile != INVALID_HANDLE_VALUE )
		CloseHandle(m_hFile);
	m_hFile = INVALID_HANDLE_VALUE;
}

// IStream
STDMETHODIMP CStreamFile::Read(
	void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
	SYSTEMTIME st;
	Tracefn("CStreamFile::Read");

	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	if( !pcbRead )
		return STG_E_INVALIDPOINTER;

	*pcbRead = 0;

	// anything to do?
	if( cb == 0 || m_statstg.cbSize.LowPart == 0 || m_cbSeek == m_statstg.cbSize.LowPart )
		return NOERROR;

	if( !ReadFile(m_hFile,pv,cb,pcbRead,NULL) )
		return HRESULT_FROM_WIN32(GetLastError());

	// adjust seek pointer
	m_cbSeek += *pcbRead;

	// update access time
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.atime);

	return NOERROR;
}

STDMETHODIMP CStreamFile::Write(
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
	ULONG cbNewSize = 0;
	ULONG cbWritten = 0;
	PVOID pvMem = NULL;
	SYSTEMTIME st;

	Tracefn("CStreamFile::Write");

	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	if (m_fReadOnly)
		return STG_E_MEDIUMFULL;

	if( pcbWritten != NULL )
		*pcbWritten = 0;

	// anything to do?
	if( cb == 0 )
		return NOERROR;

	if( !WriteFile(m_hFile,pv,cb,&cbWritten,NULL) )
		return HRESULT_FROM_WIN32(GetLastError());

	m_cbSeek += cbWritten;
	if( m_cbSeek > m_statstg.cbSize.LowPart )
	{
		m_statstg.cbSize.LowPart = m_cbSeek;
		if( !SetEndOfFile(m_hFile) )
			return HRESULT_FROM_WIN32(GetLastError());
	}
	
	if( pcbWritten != NULL )
		*pcbWritten = cbWritten;

	// update modify time
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.mtime);

	return NOERROR;
}


STDMETHODIMP CStreamFile::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	Tracefn("CStreamFile::Seek");

	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	// handle the seek request
	switch( dwOrigin)
	{
		case STREAM_SEEK_SET:
			m_cbSeek = dlibMove.LowPart;
			break;
		case STREAM_SEEK_CUR:
			m_cbSeek += (int)dlibMove.LowPart;
			break;
		case STREAM_SEEK_END:
			m_cbSeek = m_statstg.cbSize.LowPart + (int)dlibMove.LowPart;
			break;
	}

	// do seek
	if( -1L == SetFilePointer(m_hFile,m_cbSeek,NULL,FILE_BEGIN) )
		return HRESULT_FROM_WIN32(GetLastError());

	// return new seek position
	if( plibNewPosition )
	{
		plibNewPosition->HighPart = 0;
		plibNewPosition->LowPart = m_cbSeek;
	}

	return NOERROR;
}

STDMETHODIMP CStreamFile::SetSize(
    ULARGE_INTEGER libNewSize)
{
	Tracefn("CStreamFile::SetSize");
	HRESULT hr = NOERROR;

	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	// can we handle the new size?
	if( libNewSize.HighPart != 0 )
		return STG_E_MEDIUMFULL;

	// seek to new end of file
	if( -1L == SetFilePointer(m_hFile,libNewSize.LowPart,NULL,FILE_BEGIN) )
		return HRESULT_FROM_WIN32(GetLastError());

	// set end of file
	if( !SetEndOfFile(m_hFile) )
	{
		// get the error
		hr = HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
		// save new size.
		m_statstg.cbSize.LowPart = libNewSize.LowPart;
	}

	// restore seek pointer
	if( -1L == SetFilePointer(m_hFile,m_cbSeek,NULL,FILE_BEGIN) )
		hr = HRESULT_FROM_WIN32(GetLastError());

	return hr;
}

STDMETHODIMP CStreamFile::Commit(
    DWORD grfCommitFlags)
{
	Tracefn("CStreamFile::Commit");
	HRESULT hr = S_OK;
	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	if(!FlushFileBuffers(m_hFile))
		hr = HRESULT_FROM_WIN32(GetLastError());
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\dbgdumpx\dbgdumpx.c ===
/*++

Copyright (c) 1990, 1998 Microsoft Corporation

Module Name:

    dbgdumpx.c
    *WAS* kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created
    19-April-1998 Mikeswa Modify for Exchange Platinum
    22-Sept-1998 Mikeswa moved to IIS
    22-July-1999 Mikeswa and back to platinum
    24-March-2000 Mikeswa and back to IIS

--*/

#include <windows.h>
#include <imagehlp.h>
#include <transdbg.h>
#include <dbgdumpx.h>
#include <stdlib.h>

char  *s_rgszMonth[ 12 ] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};

char *s_rgszWeekDays[7] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *NewLine  = "\n";
#define FIELD_NAME_LENGTH 30
char FieldIndent[5 + 2*FIELD_NAME_LENGTH] = "                                  ";

#define GET_STRUCT_VALUE(Type, pvStruct, Offset) \
    (*(Type *)(((char *)pvStruct) + Offset))

#define FIELD_BUFFER_SIZE 100

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
);

int
kdextStrlen(
    LPSTR lpsz
);

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
);


PWINDBG_OUTPUT_ROUTINE               g_lpOutputRoutine;
PWINDBG_GET_EXPRESSION               g_lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL                   g_lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE  g_lpReadMemoryRoutine;
HANDLE                               g_hCurrentProcess;

#define    NL      1
#define    NONL    0

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetDataEx( DWORD_PTR dwAddress, PVOID ptr, ULONG size, PULONG pBytesRead)
{
    BOOL b;
    SIZE_T BytesRead;

    if (pBytesRead)
        *pBytesRead = 0;

    b = KdExtReadMemory((LPVOID) dwAddress, ptr, size, &BytesRead );

    if (!pBytesRead && (BytesRead != size)) {
        return FALSE;
    }

    if (!b) {
        /* If we have an out param... try reading less */
        if (!pBytesRead || !size)
            return FALSE;

        /* maybe our buffer size is too big... try to read 1 byte */
        b = KdExtReadMemory((LPVOID) dwAddress, ptr, 1, &BytesRead );
        if (!b)
           return FALSE;

        /* Try to find the best size... this is useful for strings */
        while (!b && (--size > 0)) {
            b = KdExtReadMemory((LPVOID) dwAddress, ptr, size, &BytesRead );
        }
    }

    if (pBytesRead)
        *pBytesRead = (ULONG)BytesRead;

    return TRUE;
}

BOOLEAN
GetData( DWORD_PTR dwAddress, PVOID ptr, ULONG size)
{
   return GetDataEx(dwAddress, ptr, size, NULL);
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&7 ], "0123456789abcdef"[ c&7 ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    BOOLEAN        b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = GetData((DWORD_PTR) puStr->Buffer, UnicodeString.Buffer, (ULONG) UnicodeString.Length);

    if (b)    {
        PRINTF("%wZ%s", &UnicodeString, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = KdExtReadMemory(
                (LPVOID) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a GUID
 */

BOOL
PrintGuid(
    GUID *pguid)
{
    ULONG i;

    PRINTF( "%08x-%04x-%04x", pguid->Data1, pguid->Data2, pguid->Data3 );
    for (i = 0; i < 8; i++) {
        PRINTF("%02x",pguid->Data4[i]);
    }
    return( TRUE );
}

/*
 * Displays a LARGE_INTEGER
 */

BOOL
PrintLargeInt(
    LARGE_INTEGER *bigint)
{
    PRINTF( "%08x:%08x", bigint->HighPart, bigint->LowPart);
    return( TRUE );
}

/*
 * Displays a DWORD size class signature
 */
BOOL
PrintClassSignature(
    CHAR * pch)
{
    PRINTF("0x%08X (%c%c%c%c)", *((DWORD *)pch), *(pch), *(pch+1), *(pch+2), *(pch+3));
    return( TRUE );
}

/*
 * Displays a standard LIST_ENTRY structure
 */
BOOL
PrintListEntry(DWORD_PTR dwAddress, CHAR * pch)
{
    PLIST_ENTRY pli = (PLIST_ENTRY) pch;
    LIST_ENTRY  liCurrent;
    PLIST_ENTRY pliCurrent = pli->Flink;
    DWORD       cEntries= 0;
    BOOL        fListOK = TRUE;

    //figure out how many entries there are
    while (pliCurrent != (PLIST_ENTRY) dwAddress)
    {
        cEntries++;
        if ((cEntries > 1000) ||
            !GetData((DWORD_PTR) pliCurrent, &liCurrent, sizeof(LIST_ENTRY)))
        {
            fListOK = FALSE;
            break;
        }
        pliCurrent = liCurrent.Flink;
    }

    PRINTF("0x%p ", dwAddress);
    if (fListOK)
        PRINTF("(%d entries)", cEntries);
    else
        PRINTF("(Unable to determine how many entries)");

    PRINTF(NewLine);
    PRINTF("%s    FLINK: 0x%p%s", FieldIndent, pli->Flink, NewLine);
    PRINTF("%s    BLINK: 0x%p", FieldIndent, pli->Blink);
    return( TRUE );
}


/*
 * Displays a human readable FILETIME
 */
BOOL PrintFileTime(FILETIME *pft, BOOL fLocalize)
{
    SYSTEMTIME	st;
    FILETIME ftDisplay = *pft;
    BOOL     fInit = TRUE;

    ZeroMemory(&st, sizeof(SYSTEMTIME));

    //Translate to local timezone if requested
    if (fLocalize)
        FileTimeToLocalFileTime(pft, &ftDisplay);

    //Only convert if non-zero
    if (!pft->dwLowDateTime && !pft->dwHighDateTime)
    {
        fInit = FALSE;
    }
    else if (!FileTimeToSystemTime(&ftDisplay, &st))
    {
        PRINTF("Unable to convert %08X %08X to a SYSTEMTIME - error %d",
            ftDisplay.dwLowDateTime,ftDisplay.dwHighDateTime, GetLastError());
        return FALSE;
    }

    if (fInit)
    {
        PRINTF("%s, %d %s %04d %02d:%02d:%02d %s",
            s_rgszWeekDays[st.wDayOfWeek],
            st.wDay, s_rgszMonth[ st.wMonth - 1 ],
            st.wYear, st.wHour, st.wMinute, st.wSecond,
            fLocalize ? "(localized)" : "");
    }
    else
    {
        PRINTF("FILETIME is zero");
    }
    return TRUE;
}

/*
 * Displays a the values of a bitmask
 */
BOOL
PrintBitMaskValues(
    DWORD BitMaskValue,
    FIELD_DESCRIPTOR *pFieldDescriptor)
{
    BOOL fFirstFlag;
    BIT_MASK_DESCRIPTOR *pBitMaskDescr;

    pBitMaskDescr = pFieldDescriptor->AuxillaryInfo.pBitMaskDescriptor;
    fFirstFlag = TRUE;
    if (pBitMaskDescr != NULL)
    {
        while (pBitMaskDescr->BitmaskName != NULL)
        {
            if (((BitMaskValue & pBitMaskDescr->BitmaskValue) ==
                  pBitMaskDescr->BitmaskValue) && //need to check all bits of bit mask
                //If descriptor value is 0.. it will always match any bit mask
                //it should only when the actual BitMaskValue is 0 as well
                (pBitMaskDescr->BitmaskValue || !BitMaskValue))
            {
                if (fFirstFlag)
                {
                    fFirstFlag = FALSE;
                    PRINTF("%s  ( %-s", FieldIndent, pBitMaskDescr->BitmaskName);
                }
                else
                {
                    PRINTF( " |\n" );
                    PRINTF("%s    %-s", FieldIndent, pBitMaskDescr->BitmaskName);
                }
            }
            pBitMaskDescr++;
        }
        PRINTF(" )");
        return TRUE;
    }
    return FALSE;
}

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

VOID
PrintStructFields( DWORD_PTR dwAddress, BYTE *ptr, FIELD_DESCRIPTOR *pFieldDescriptors, DWORD cIndentLevel)
{
    DWORD i,j;
    BYTE pbBuffer[FIELD_BUFFER_SIZE];
    DWORD BitMaskValue = 0;
    DWORD cbGetData = 0;
    CHAR  szTmpName[FIELD_NAME_LENGTH];

    //Make sure FieldIndent is correct
    for (j = 0; j < cIndentLevel%(FIELD_NAME_LENGTH/2); j++)
        lstrcat(FieldIndent, "  ");

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        for (j = 0; j < cIndentLevel%(FIELD_NAME_LENGTH/2); j++)
            PRINTF("  "); //print 2 spaces for every indent level


        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            memcpy(szTmpName, pFieldDescriptors->Name, FIELD_NAME_LENGTH-3);
            szTmpName[FIELD_NAME_LENGTH-3] = '\0';
            PRINTF( "%s... ", szTmpName);
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16d%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLine );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLine);
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOL *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLine);
            break;
        case FieldTypePointer:
            PRINTF( "@0x%p%s",
                *(DWORD_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeLong:
            PRINTF( "%-16d%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeULong:
        case FieldTypeDword:
            PRINTF( "%-16u%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeGuid:
            PrintGuid( (GUID *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypePStr:  //pointer to a string
            if (GetDataEx(GET_STRUCT_VALUE(DWORD_PTR, ptr,
                pFieldDescriptors->Offset), pbBuffer, FIELD_BUFFER_SIZE, &cbGetData))
            {
                //make sure the string is terminated
                pbBuffer[FIELD_BUFFER_SIZE - 1] = '\0';
                PRINTF( "%s", (LPSTR) pbBuffer );
            }
            else if (!GET_STRUCT_VALUE(DWORD_PTR, ptr, pFieldDescriptors->Offset))
            {
                PRINTF( "<Null String>");
            }
            else
            {
                PRINTF("ERROR: Unable to read string a 0x%p",
                    GET_STRUCT_VALUE(DWORD_PTR, ptr, pFieldDescriptors->Offset));
            }
            PRINTF( NewLine );
            break;
        case FieldTypePWStr:
            if (GetDataEx(GET_STRUCT_VALUE(DWORD_PTR, ptr, pFieldDescriptors->Offset),
                pbBuffer, FIELD_BUFFER_SIZE, &cbGetData))
            {
                //make sure the string is terminated
                pbBuffer[FIELD_BUFFER_SIZE - 1] = '\0';
                pbBuffer[FIELD_BUFFER_SIZE - 2] = '\0';
                PRINTF( "%ws", (LPWSTR) pbBuffer );
            }
            else
            {
                PRINTF("ERROR: Unable to read string a 0x%p",
                    GET_STRUCT_VALUE(DWORD_PTR, ptr, pFieldDescriptors->Offset));
            }
            PRINTF( NewLine );
            break;
        case FieldTypeStrBuffer:  //member is a character array
            PRINTF( "%.100s%s", (CHAR *)(((char *)ptr) + pFieldDescriptors->Offset), NewLine);
            break;
        case FieldTypeWStrBuffer:
            PRINTF( "%.100ws%s", (WCHAR *)(((char *)ptr) + pFieldDescriptors->Offset), NewLine);
            break;
        case FieldTypeUnicodeString:
            PrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
            PRINTF( NewLine );
            break;
        case FieldTypeAnsiString:
            PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
            PRINTF( NewLine );
            break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG_PTR Displacement;
                PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                g_lpGetSymbolRoutine( sym, SymbolName, &Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLine );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numerical value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                       pEnumValueDescr++;
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"Unknown!");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
               PRINTF( NewLine );
            }
            break;

        case FieldTypeByteBitMask:
            BitMaskValue = GET_STRUCT_VALUE(BYTE, ptr, pFieldDescriptors->Offset);
            PRINTF("0x%02X ", (BYTE) BitMaskValue);
            PRINTF( NewLine );
            if (PrintBitMaskValues(BitMaskValue, pFieldDescriptors))
                PRINTF( NewLine );
            break;
        case FieldTypeWordBitMask:
            BitMaskValue = GET_STRUCT_VALUE(WORD, ptr, pFieldDescriptors->Offset);
            PRINTF("0x%04X ", (WORD) BitMaskValue);
            PRINTF( NewLine );
            if (PrintBitMaskValues(BitMaskValue, pFieldDescriptors))
                PRINTF( NewLine );
            break;
        case FieldTypeDWordBitMask:
            BitMaskValue = GET_STRUCT_VALUE(DWORD, ptr, pFieldDescriptors->Offset);
            PRINTF("0x%08X ", (DWORD) BitMaskValue);
            PRINTF( NewLine );
            if (PrintBitMaskValues(BitMaskValue, pFieldDescriptors))
                PRINTF( NewLine );
            break;
        case FieldTypeStruct:
            PRINTF( "@0x%p%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeLargeInteger:
            PrintLargeInt( (LARGE_INTEGER *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypeClassSignature:
            PrintClassSignature(((char *)ptr) + pFieldDescriptors->Offset);
            PRINTF( NewLine );
            break;
        case FieldTypeListEntry:
            PrintListEntry(dwAddress + pFieldDescriptors->Offset,
                           ((char *)ptr) + pFieldDescriptors->Offset);
            PRINTF( NewLine );
            break;
        case FieldTypeLocalizedFiletime:
            PrintFileTime((FILETIME *) (((char *)ptr) + pFieldDescriptors->Offset), TRUE);
            PRINTF( NewLine );
            break;
        case FieldTypeFiletime:
            PrintFileTime((FILETIME *) (((char *)ptr) + pFieldDescriptors->Offset), FALSE);
            PRINTF( NewLine );
            break;
        case FieldTypeEmbeddedStruct:
            PRINTF( "Dumping %s@0x%p%s",
                ((STRUCT_DESCRIPTOR *) (pFieldDescriptors->AuxillaryInfo.pStructDescriptor))->StructName,
                dwAddress+ pFieldDescriptors->Offset, NewLine );
            PrintStructFields(dwAddress+pFieldDescriptors->Offset,
                              ((char *)ptr) + pFieldDescriptors->Offset,
                              ((STRUCT_DESCRIPTOR *) (pFieldDescriptors->AuxillaryInfo.pStructDescriptor))->FieldDescriptors,
                              cIndentLevel+1);
            break;
       default:
            PRINTF( "Unrecognized field type %d for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }

    //Make sure FieldIndent is correct when we leave
    FieldIndent[lstrlen(FieldIndent)-(cIndentLevel%(FIELD_NAME_LENGTH/2))] = '\0';

}

LPSTR LibCommands[] = {
    "help -- This command ",
    "dump <Struct Type Name>@<address expr> ",
    0
};

PT_DEBUG_EXTENSION(_help)
{
    int i;

    SETCALLBACKS();

    PRINTF("\n");

    for( i=0; ExtensionNames[i]; i++ )
        PRINTF( "%s\n", ExtensionNames[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );

    for( i=0; Extensions[i]; i++) {
        PRINTF( "   %s\n", Extensions[i] );
    }

    return;
}

#define NAME_DELIMITER '@'
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    int               ArgumentLength = kdextStrlen(lpArgument);
    BOOLEAN           fAmbiguous = FALSE;


    while ((pStructs->StructName != 0)) {
        int StructLength;
        StructLength = kdextStrlen(pStructs->StructName);
        if (StructLength >= ArgumentLength) {
            int Result = kdextStrnicmp(
                            lpArgument,
                            pStructs->StructName,
                            ArgumentLength);

            if (Result == 0) {
                if (StructLength == ArgumentLength) {
                    // Exact match. They must mean this struct!
                    fAmbiguous = FALSE;
                    NameIndex = i;
                    break;
                } else if (NameIndex != INVALID_INDEX) {
                    // We have encountered duplicate matches. Print out the
                    // matching strings and let the user disambiguate.
                   fAmbiguous = TRUE;
                   break;
                } else {
                   NameIndex = i;
                }
            }
        }
        pStructs++;i++;
    }

    if (fAmbiguous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (kdextStrnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(kdextStrlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

PT_DEBUG_EXTENSION(_dump)
{
    DWORD_PTR dwAddress;
    BYTE *pDataBuffer = NULL;

    SETCALLBACKS();

    if( szArg && *szArg ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (LPSTR) szArg;
        LPSTR lpArgs;
        ULONG Index;

        for (lpArgs = (LPSTR) szArg;
                *lpArgs != NAME_DELIMITER && *lpArgs != 0; lpArgs++) {
             ;
        }

        if (*lpArgs == NAME_DELIMITER) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {

                pDataBuffer = (BYTE *) LocalAlloc(0, Structs[Index].StructSize);
                if (!pDataBuffer)
                    return;

                //Eat up any extra @'s
                do {lpArgs++;} while ('@' == *lpArgs);

                dwAddress = (g_lpGetExpressionRoutine)( lpArgs );
                if (pDataBuffer &&
                    GetData(dwAddress,pDataBuffer,Structs[Index].StructSize)) {

                    PRINTF(
                        "++++++++++++++++ %s@0x%p ++++++++++++++++\n",
                        Structs[Index].StructName,
                        dwAddress);
                    PrintStructFields(
                        dwAddress,
                        pDataBuffer,
                        Structs[Index].FieldDescriptors, 0);
                    PRINTF(
                        "++++++++++++++++ size is %.10d bytes +++++++++++++++\n",
                        Structs[Index].StructSize);
                    PRINTF(
                        "---------------- %s@0x%p ----------------\n",
                        Structs[Index].StructName,
                        dwAddress);
                } else {
                    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                }
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    if (pDataBuffer)
        LocalFree(pDataBuffer);

    return;
}


PT_DEBUG_EXTENSION(_dumpoffsets)
{
    if( szArg && *szArg ) {

        LPSTR lpName = (LPSTR) szArg;
        LPSTR lpArgs = NULL;
        CHAR  chSave = '\0';
        FIELD_DESCRIPTOR *pFieldDescriptors = NULL;
        ULONG Index;

        for (lpArgs = (LPSTR) szArg;
                !isspace(*lpArgs) && *lpArgs != 0; lpArgs++) {
             ;
        }

        if (TRUE) {
            chSave = *lpArgs;
            *lpArgs = '\0';

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = chSave;

            if (INVALID_INDEX != Index) {

                PRINTF(
                    "++++++++++++++++ %s ++++++++++++++++\n",
                    Structs[Index].StructName);
                for (pFieldDescriptors = Structs[Index].FieldDescriptors;
                     pFieldDescriptors && pFieldDescriptors->Name;
                     pFieldDescriptors++)
                {
                    PRINTF("\t0x%08X\t%s\n",
                    pFieldDescriptors->Offset, pFieldDescriptors->Name);
                }
                PRINTF(
                    "++++++++++++++++ size is %.10d bytes +++++++++++++++\n",
                    Structs[Index].StructSize);
                PRINTF(
                    "---------------- %s ----------------\n",
                    Structs[Index].StructName);
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    return;
}
/*
 * KD Extensions should not link with the C-Runtime library routines. So,
 * we implement a few of the needed ones here.
 */

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
)
{
    int n, cbArg, val = 0;
    BOOL fNegative = FALSE;

    cbArg = kdextStrlen( lpArg );

    if (cbArg > 0) {
        for (n = 0; lpArg[n] == ' '; n++) {
            ;
        }
        if (lpArg[n] == '-') {
            n++;
            fNegative = TRUE;
        }
        for (; lpArg[n] >= '0' && lpArg[n] <= '9'; n++) {
            val *= 10;
            val += (int) (lpArg[n] - '0');
        }
        if (lpArg[n] == 0) {
            *pRet = (fNegative ? -val : val);
            return( TRUE );
        } else {
            return( FALSE );
        }
    } else {
        return( FALSE );
    }

}

int
kdextStrlen(
    LPSTR lpsz
)
{
    int c;

    if (lpsz == NULL) {
        c = 0;
    } else {
        for (c = 0; lpsz[c] != 0; c++) {
            ;
        }
    }

    return( c );
}


#define UPCASE_CHAR(c)  \
    ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
)
{
    int nDif, i;

    for (i = nDif = 0; nDif == 0 && i < cLen; i++) {
        nDif = UPCASE_CHAR(lpsz1[i]) - UPCASE_CHAR(lpsz2[i]);
    }

    return( nDif );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\codepageconvert\codepageconvert.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: CodePageConvert.cpp
//
// Contents: Implementation of functions
// HrCodePageConvert
// HrCodePageConvert
// HrCodePageConvertFree
// HrCodePageConvertInternal
//
// History:
// aszafer  2000/03/15  created
//
//-------------------------------------------------------------

#include "CodePageConvert.h"
#include "dbgtrace.h"

//+------------------------------------------------------------
//
// Function: HrCodePageConvert
//
// Synopsis: Converts a zero terminated string to a different code page
//
// NOTES: 
//   caller needs to provide buffer where target string is returned
//
// Arguments:
//    uiSourceCodePage          Source Code Page
//    pszSourceString           Source String
//    uiTargetCodePage          Target Code Page
//    pszTargetString           p to prealloc buffer where target string is returned
//    cbTargetStringBuffer      cbytes of preallocated buffer for target string 
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY if dynamic allocation of an internal buffer fails
//  HRESULT_FROM_WIN32(GetLastError()) if Wide<->Multibyte calls fail
//  HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) if
//                      uiSourceCodePage = uiTargetCodePage and 
//                      cbTargetStringBuffer is too small
//         
// History:
// aszafer  2000/03/29  created
//
//-------------------------------------------------------------
HRESULT HrCodePageConvert (
    IN UINT uiSourceCodePage,           // Source code page
    IN LPSTR pszSourceString,           // Source String 
    IN UINT uiTargetCodePage,           // Target code page
    OUT LPSTR pszTargetString,          // p to buffer where target string is returned
    IN int cbTargetStringBuffer)       // cbytes in buffer for target string
{

    HRESULT hr = S_OK;

    TraceFunctEnter("HrCodePageConvert");

    _ASSERT(pszSourceString);
    _ASSERT(pszTargetString);
    _ASSERT(cbTargetStringBuffer);
    
    //
    // Take care of trivial cases first
    //
    if (uiTargetCodePage == uiSourceCodePage){
    
        if (pszTargetString == pszSourceString)
            goto CLEANUP ;

        if (lstrlen(pszSourceString) < cbTargetStringBuffer){

            lstrcpy(pszTargetString,pszSourceString);
 
        }else{

            DebugTrace(0,
             "Insufficient cbTargetStringBuffer = %08lx",cbTargetStringBuffer);
            hr = HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) ;

        }

        goto CLEANUP ;
    }


    //
    // If case is not trivial, call into HrCodePageConvertInternal
    //
    hr = HrCodePageConvertInternal (
            uiSourceCodePage,               // source code page
            pszSourceString,                // source string
            uiTargetCodePage,               // target code page
            pszTargetString,                // target string or NULL
            cbTargetStringBuffer,          // cb in target string or 0 
            NULL );                           // NULL or p to where target string is returned


    if (FAILED(hr))
        DebugTrace(0,"HrCodePageConvertInternal failed hr =  %08lx", hr);
   

CLEANUP:

   DebugTrace(0,"returning %08lx", hr);
   TraceFunctLeave();

    return hr;
}


//+------------------------------------------------------------
//
// Function: HrCodePageConvert
//
// Synopsis: Converts a zero terminated string to a different code page
//
// NOTES: 
//   1. if the fucntion succeeds, the caller needs to call 
//      HrCodePageConvertFree (*ppszTargetString) when done,
//      to free memory allocated inside this function
//   2. if the function fails, it will internally free all allocated memory
//
// Arguments:
//    uiSourceCodePage          Source Code Page
//    pszSourceString           Source String
//    uiTargetCodePage          Target Code Page
//    ppszTargetString          p to where to return target string
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY if dynamic allocation of an internal buffer fails
//  HRESULT_FROM_WIN32(GetLastError()) if Wide<->Multibyte calls fail
//         
// History:
// aszafer  2000/03/29  created
//
//-------------------------------------------------------------
HRESULT HrCodePageConvert (
    IN UINT uiSourceCodePage,           // Source code page
    IN LPSTR pszSourceString,           // Source string
    IN UINT uiTargetCodePage,           // Target code page
    OUT LPSTR * ppszTargetString)       // p to where target string is returned
{

    HRESULT hr = S_OK;
    LPSTR pszTargetString = NULL;
    
    TraceFunctEnter("HrCodePageConvert");

    _ASSERT(pszSourceString);
    _ASSERT(ppszTargetString);
    
    //
    // Take care of trivial cases first
    //
    if (uiTargetCodePage == uiSourceCodePage){
    
        pszTargetString = new CHAR[lstrlen(pszSourceString) + 1];
        if (pszTargetString == NULL) {

            hr = E_OUTOFMEMORY ;
            DebugTrace(0,"alloc for pszTargetString failed hr =  %08lx", hr);
            goto CLEANUP ;
        
        }      

        lstrcpy(pszTargetString,pszSourceString);
        *ppszTargetString = pszTargetString;
        goto CLEANUP ;
    }


    //
    // If case is not trivial, call into HrCodePageConvertInternal
    //
    hr = HrCodePageConvertInternal (
            uiSourceCodePage,               // source code page
            pszSourceString,                // source string
            uiTargetCodePage,               // target code page
            NULL,                             // target string or NULL
            0,                                // cb in target string or 0 
            ppszTargetString );             // NULL or p to where target string is returned


    if (FAILED(hr))
        DebugTrace(0,"HrCodePageConvertInternal failed hr =  %08lx", hr);
  
    
CLEANUP:
 
    DebugTrace(0,"returning %08lx", hr);
    TraceFunctLeave();

    return hr;
}

//+------------------------------------------------------------
//
// Function: HrCodePageConvertInternal
//
// Synopsis: Converts a zero terminated string to a different code page
//
// NOTES: 
//   pointers to Source and Target strings may be the same 
//
// Arguments:
//    uiSourceCodePage          Source Code Page
//    pszSourceString           Source String
//    uiTargetCodePage          Target Code Page
//
//    either: 
//    pszTargetString           p to buffer prealloc by caller where target string
//                              is returned
//    cbTargetStringBuffer      cbytes in prealloc buffer for target string
//    ppszTargetString          NULL,
//
//    or:
//    pszTargetString           NULL
//    cbTargetStringBuffer      0
//    ppszTargetString          p to where target string is to be returned
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY if dynamic allocation of an internal buffer fails
//  HRESULT_FROM_WIN32(GetLastError()) if Wide<->Multibyte calls fail
//         
// History:
// aszafer  2000/03/29  created
//
//-------------------------------------------------------------
HRESULT HrCodePageConvertInternal (
    IN UINT uiSourceCodePage,               // source code page
    IN LPSTR pszSourceString,               // source string
    IN UINT uiTargetCodePage,               // target code page
    OUT LPSTR pszTargetString,              // target string or NULL
    IN int cbTargetStringBuffer,           // cb in target string or 0 
    OUT LPSTR* ppszTargetString )           // NULL or p to where target string is returned
{

    HRESULT hr = S_OK;
    WCHAR wsz[TEMPBUFFER_WCHARS] ;
    int cwch = sizeof(wsz)/sizeof(WCHAR) ;
    WCHAR* pwsz = wsz ;
    CHAR* psz ;
    int iSourceStringLengh ; 
    int cch ;
    BOOL fAlloc1 = FALSE ;
    BOOL fAlloc2 = FALSE ;

    TraceFunctEnter("HrCodePageConvertInternal");

    _ASSERT(((pszTargetString != NULL) && (cbTargetStringBuffer != 0)) ||
            (ppszTargetString != NULL) );

    psz = pszTargetString;
    cch = cbTargetStringBuffer;
    
    //
    // If stack allocated temp buffer may not be sufficient
    // for unicode string, allocate from heap 
    //
    iSourceStringLengh = lstrlen(pszSourceString) + 1 ; //includes terminator
    if (iSourceStringLengh > TEMPBUFFER_WCHARS){
        //
        // Here we assume that each character in the source code page
        // can be represented by a single unicode character
        //
        cwch = iSourceStringLengh ;
        pwsz = new WCHAR[iSourceStringLengh];
        
        if (pwsz == NULL) {

            hr = E_OUTOFMEMORY ;
            DebugTrace(0,"alloc for pwsz failed hr =  %08lx", hr);
            goto CLEANUP ;    
        }    

        fAlloc1 = TRUE ;
    }
    
    //
    // Convert to unicode
    //
    cwch = MultiByteToWideChar(
                uiSourceCodePage,               // code page 
                0,                                // dwFlags
                pszSourceString,                // string to map
                -1 ,                              // number of bytes in string
                pwsz,                             // wide-character buffer
                cwch );                           // size of buffer

    if(cwch == 0) {
    
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace(0,"MultiByteToWideChar2 failed hr =  %08lx", hr);
        _ASSERT(FAILED(hr));
        goto CLEANUP ;
    }

    //
    // If cbTargetStringBuffer == 0, allocate space for target string
    //
    if (cbTargetStringBuffer == 0){

        cch = WideCharToMultiByte(
                uiTargetCodePage,             // codepage 
                0,                              // dwFlags
                pwsz,                           // wide-character string
                cwch,                           // number of wchars in string
                NULL,                           // buffer for new string
                0,                              // size of buffer
                NULL,                           // default for unmappable chars
                NULL);                          // set when default char used

        if(cch == 0) {
        
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugTrace(0,"WideCharToMultiByte1 failed hr =  %08lx", hr);
            _ASSERT(FAILED(hr));
            goto CLEANUP ;
        } 


        psz = new CHAR[cch];
        if (psz == NULL) {
        
            hr = E_OUTOFMEMORY ;
            DebugTrace(0,"alloc for psz failed hr =  %08lx", hr);
            goto CLEANUP ;
        
        }
        fAlloc2 = TRUE ;
    }

    //
    // Convert to target code page
    //
    cch = WideCharToMultiByte(
                uiTargetCodePage,                     // codepage 
                0,                                      // dwFlags
                pwsz,                                   // wide-character string
                cwch,                                   // number of wchars in string
                psz,                                    // buffer for new string
                cch,                                    // size of buffer
                NULL,                                   // default for unmappable chars
                NULL);                                  // set when default char used

    if(cch == 0) {
    
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace(0,"WideCharToMultiByte2 failed hr =  %08lx", hr);
        _ASSERT(FAILED(hr));
        goto CLEANUP ;
    }

    //
    // If target string had to be allocated, output pointer to it
    //
    if (cbTargetStringBuffer == 0)
        *ppszTargetString = psz ;

        
CLEANUP:

    if (fAlloc1)
        delete[] pwsz ;

    if (FAILED(hr)){

        if (fAlloc2)
            delete[] psz ;
     }
        
    DebugTrace(0,"returning %08lx", hr);
    TraceFunctLeave();

    return hr;
}

//+------------------------------------------------------------
//
// Function: HrCodePageConvertFree
//
// Synopsis: Use to free memory if HrCodePageConvert or HrCodePageConvertInternal
//           allocate buffer for target string
//
// Arguments:
//    pszTargetString           p to buffer to be freed
//
// History:
// aszafer  2000/03/29  created
//
//-------------------------------------------------------------
VOID HrCodePageConvertFree(LPSTR pszTargetString)
{
    _ASSERT(pszTargetString);

    delete pszTargetString;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\crchash\crchash.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crchash.cpp

Abstract:
	CRC Hash function
*/

//
//
// Hashing function adopted from the INN code (see copyright below)
//

/*
    Copyright 1988 Jon Zeeff (zeeff@b-tech.ann-arbor.mi.us)
    You can use this code in any manner, as long as you leave my name on it
    and don't hold me responsible for any problems with it.

 * This is a simplified version of the pathalias hashing function.
 * Thanks to Steve Belovin and Peter Honeyman
 *
 * hash a string into a long int.  31 bit crc (from andrew appel).
 * the crc table is computed at run time by crcinit() -- we could
 * precompute, but it takes 1 clock tick on a 750.
 *
 * This fast table calculation works only if POLY is a prime polynomial
 * in the field of integers modulo 2.  Since the coefficients of a
 * 32-bit polynomial won't fit in a 32-bit word, the high-order bit is
 * implicit.  IT MUST ALSO BE THE CASE that the coefficients of orders
 * 31 down to 25 are zero.  Happily, we have candidates, from
 * E. J.  Watson, "Primitive Polynomials (Mod 2)", Math. Comp. 16 (1962):
 *  x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + x^0
 *  x^31 + x^3 + x^0
 *
 * We reverse the bits to get:
 *  111101010000000000000000000000001 but drop the last 1
 *         f   5   0   0   0   0   0   0
 *  010010000000000000000000000000001 ditto, for 31-bit crc
 *     4   8   0   0   0   0   0   0
 */

#include <windows.h>
#include "crchash.h"

static long CrcTable[128];
static BOOL bInitialized = FALSE;

/*
 - crcinit - initialize tables for hash function
 */
void crcinit()
{
    INT i, j;
    DWORD sum;

	if(bInitialized) return;

    for (i = 0; i < 128; ++i) {
        sum = 0;
        for (j = 7 - 1; j >= 0; --j) {
            if (i & (1 << j)) {
                sum ^= POLY >> j;
            }
        }
        CrcTable[i] = sum;
    }

	bInitialized = TRUE;
} // crcinit

/*
 - hash - Honeyman's nice hashing function
 */
DWORD CRCHash(const BYTE*	Key, DWORD Length)
{
    DWORD sum = 0;

    while ( Length-- ) {

        sum = (sum >> 7) ^ CrcTable[(sum ^ (*Key++)) & 0x7f];
    }
    return(sum);

}

/*
 - hash - Honeyman's nice hashing function
 */
DWORD CRCHashNoCase(const BYTE*	Key, DWORD Length)
{
    DWORD sum = 0;

    while ( Length-- ) {
        BYTE thisKey = (BYTE) tolower((char) (*Key++));
        sum = (sum >> 7) ^ CrcTable[(sum ^ thisKey) & 0x7f];
    }
    return(sum);

}



/*
 - hash - Honeyman's nice hashing function
 */
DWORD CRCHashWithPrecompute(	DWORD	sum,	const BYTE*	Key, DWORD Length)
{
    while ( Length-- ) {

        sum = (sum >> 7) ^ CrcTable[(sum ^ (*Key++)) & 0x7f];
    }
    return(sum);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\dbgdumpx\extdemdl\extdemdl.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File:  extdemdl.cpp
//
//  Description: Demo to show how to write a simple CDB extension
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <dbgdumpx.h>
#include <extdemex.h>
#include "extdemdl.h"  //define global field descriptors

DEFINE_EXPORTED_FUNCTIONS

//Displayed at top of help command
LPSTR ExtensionNames[] = {
    "Demo CDB debugger extensions",
    0
};

//Displayed at bottom of help command... after exported functions are explained
LPSTR Extensions[] = {
    0
};

//Initialization routine (not needed for simple dumping)
PEXTLIB_INIT_ROUTINE  g_pExtensionInitRoutine = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\dbgdumpx\extdemex\extdemex.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: extdemex.cpp
//
//  Description: Demo CDB extension exe file
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "extdemex.h"
#include <stdio.h>
#include <string.h>

// {FF8945D5-DBC1-11d1-ADF0-00C04FC32984}
static const GUID MyGuid = 
{ 0xff8945d5, 0xdbc1, 0x11d1, { 0xad, 0xf0, 0x0, 0xc0, 0x4f, 0xc3, 0x29, 0x84 } };

CMyClass *g_pMyClass = NULL;

int __cdecl main(int argc, char *argv[])
{
    g_pMyClass = new CMyClass;

    printf("Press ENTER to stop\n");
    getchar();

    delete g_pMyClass;
    return 0;
}

void DemoFunction(void)
{
    //nothing
};

#define CLASS_SIG 'd00f'
#define MY_STRING "This is a MY_STRUCT struct"
#define DEMO_STRING "This is my demo ASCII string"
#define W_DEMO_STRING L"This is my demo UNICODE string"

CMyClass::CMyClass()
{
    ZeroMemory(this, sizeof(CMyClass));
    m_dwPrivateSignature = CLASS_SIG;
    m_dwFlags = CLASS_OK | DWORD_BIT;
    m_guid = MyGuid;
    m_fBool = TRUE;
    m_pFunction = DemoFunction;
    m_szMySz = DEMO_STRING;
    m_wszMyWsz = W_DEMO_STRING;
    strcpy(m_szBuffer, DEMO_STRING);
    wcscpy(m_wszBuffer, W_DEMO_STRING);
    m_MyUnicodeString.Length = lstrlenW(W_DEMO_STRING)*sizeof(WCHAR);
    m_MyUnicodeString.Buffer = m_wszBuffer;
    m_MyAnsiString.Length = lstrlen(DEMO_STRING)*sizeof(CHAR);
    m_MyAnsiString.Buffer = m_szBuffer;
    m_eMyEnum = ENUM_VAL2;
    m_bFlags = CLASS_OK | MISC_BIT1;
    m_wFlags = CLASS_OK | MISC_BIT1 | MISC_BIT2 | WORD_BIT;

    m_MyStruct.m_cbName = strlen(MY_STRING)*sizeof(CHAR);
    m_MyStruct.m_szName = MY_STRING;
}

CMyClass::~CMyClass()
{
    m_dwFlags = CLASS_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\dbgdumpx\extdemdl\extdemdl.h ===
//-----------------------------------------------------------------------------
//
//
//  File: extdemdl.h
//
//  Description:  Demo field description header file
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <_dbgdump.h>

//Define all bitmasks and enums first
BEGIN_BIT_MASK_DESCRIPTOR(MyClassFlags)
    BIT_MASK_VALUE2(CLASS_OK, "CLASS_OK")
    BIT_MASK_VALUE2(CLASS_INVALID, "CLASS_INVALID")
    BIT_MASK_VALUE2(MISC_BIT1, "MISC_BIT1")
    BIT_MASK_VALUE2(MISC_BIT2, "MISC_BIT2")
    BIT_MASK_VALUE(WORD_BIT)
    BIT_MASK_VALUE(DWORD_BIT)
END_BIT_MASK_DESCRIPTOR

BEGIN_ENUM_DESCRIPTOR(MY_ENUM)
    ENUM_VALUE(CMyClass::ENUM_VAL1)
    ENUM_VALUE(CMyClass::ENUM_VAL2)
END_ENUM_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MyClassFields)
    FIELD3_PRIV(FieldTypeClassSignature, CMyClass, m_dwPrivateSignature)
    FIELD4_PRIV(FieldTypeDWordBitMask, CMyClass, m_dwFlags, GET_BIT_MASK_DESCRIPTOR(MyClassFlags))
    FIELD3_PRIV(FieldTypeStruct, CMyClass, m_MyStruct)
    FIELD3(FieldTypeByte, CMyClass, m_bMyByte)
    FIELD3(FieldTypeChar, CMyClass, m_chMyChar)
    FIELD3(FieldTypeBoolean, CMyClass, m_fBoolean)
    FIELD3(FieldTypeBool, CMyClass, m_fBool)
    FIELD3(FieldTypeULong, CMyClass, m_ulMyUlong)
    FIELD3(FieldTypeLong, CMyClass, m_lMyLong)
    FIELD3(FieldTypeUShort, CMyClass, m_usMyUshort)
    FIELD3(FieldTypeShort, CMyClass, m_sMyShort)
    FIELD3(FieldTypeGuid, CMyClass, m_guid)
    FIELD3(FieldTypePointer, CMyClass, m_pvMyPtr)
    FIELD3(FieldTypePStr, CMyClass, m_szMySz)
    FIELD3(FieldTypePWStr, CMyClass, m_wszMyWsz)
    FIELD3(FieldTypeStrBuffer, CMyClass, m_szBuffer)
    FIELD3(FieldTypeWStrBuffer, CMyClass, m_wszBuffer)
    FIELD3(FieldTypeUnicodeString, CMyClass, m_MyUnicodeString)
    FIELD3(FieldTypeAnsiString, CMyClass, m_MyAnsiString)
    FIELD4(FieldTypeEnum, CMyClass, m_eMyEnum, GET_ENUM_DESCRIPTOR(MY_ENUM))
    FIELD4(FieldTypeByteBitMask, CMyClass, m_bFlags, GET_BIT_MASK_DESCRIPTOR(MyClassFlags))
    FIELD4(FieldTypeWordBitMask, CMyClass, m_wFlags, GET_BIT_MASK_DESCRIPTOR(MyClassFlags))
    FIELD3(FieldTypeLargeInteger, CMyClass, m_liMyLargeInteger)
    FIELD3(FieldTypeDword, CMyClass, m_dwMyDWORD)
    FIELD3(FieldTypeSymbol, CMyClass, m_pFunction)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MyStructFields)
    FIELD3(FieldTypeDword, MY_STRUCT, m_cbName)
    FIELD3(FieldTypePStr, MY_STRUCT, m_szName)
END_FIELD_DESCRIPTOR

//Global STRUCT_DESCRIPTOR must come after included field descriptor files
BEGIN_STRUCT_DESCRIPTOR 
    STRUCT(CMyClass,MyClassFields)
    STRUCT(MY_STRUCT,MyStructFields)
END_STRUCT_DESCRIPTOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\domhash\domhash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992, 1998.
//
//  File:       domhash.c
//
//  Contents:   Implementation of public API for domain name lookup table
//
//  History:    SethuR -- Implemented
//              MikeSwa -- Modified for Domain Name lookup 2/98
//
//  Notes:
//  2/98        The major difference between the DFS version and the domain
//              name lookup is the size of the table, the ability for
//              wildcard lookups (*.foo.com), and the reverse order of the
//              lookup (com hashes first in foo.com).  To make the code more
//              readable given its new purpose, the files, structures, and
//              functions have been given non DFS-centric names.  A quick
//              mapping of the major files is (for those familiar with the
//              DFS code):
//                  domhash.h    (prefix.h)    -   Public include file
//                  _domhash.h   (prefixp.h)   -   Private include file
//                  domhash.cpp  (prefix.c)    -   Implementation of API
//                  _domhash.cpp (prefixp.c)   -   Private helper functions.
//
//--------------------------------------------------------------------------

#include "_domhash.h"
#include <stdio.h>

#define _ASSERT_DOMAIN_STRING(pstr) _ASSERT((_tcslen(pstr->Buffer)*sizeof(TCHAR)) == pstr->Length)

//---[ DOMAIN_NAME_TABLE ]-----------------------------------------------------
//
//
//  Description:
//      Class constructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
DOMAIN_NAME_TABLE::DOMAIN_NAME_TABLE()
{
    ULONG i;
    m_dwSignature       = DOMAIN_NAME_TABLE_SIG;
    m_cLookupAttempts   = 0;
    m_cLookupSuccesses  = 0;
    m_cLookupCollisions = 0;
    m_cHashCollisions   = 0;
    m_cStringCollisions = 0;
    m_cBucketsUsed      = 0;
    INITIALIZE_DOMAIN_NAME_TABLE_ENTRY(&RootEntry);

    // Initialize the various buckets.
    for (i = 0;i < NO_OF_HASH_BUCKETS;i++)
    {
        INITIALIZE_BUCKET(Buckets[i]);
    }

    NamePageList.pFirstPage = NULL;
}

//---[ ~DOMAIN_NAME_TABLE ]----------------------------------------------------
//
//
//  Description:
//      Class destructor - Dumps some stats to stderr
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
DOMAIN_NAME_TABLE::~DOMAIN_NAME_TABLE()
{
    PNAME_PAGE  pCurrentPage = NamePageList.pFirstPage;
    PNAME_PAGE  pNextPage = NULL;

#ifdef DEBUG
    //$$TODO find a more appropriate way to dump this (don't use *printf)
    ULONG   cTotalCollisions    = m_cHashCollisions + m_cStringCollisions;
    ULONG   ulPercentHash        = cTotalCollisions ? (m_cHashCollisions*100/cTotalCollisions) : 0;
    ULONG   ulPercentDesign      = cTotalCollisions ? (m_cStringCollisions*100/cTotalCollisions) : 0;
    ULONG   ulPercentCollisions  = m_cLookupAttempts ? (m_cLookupCollisions*100/m_cLookupAttempts) : 0;
    ULONG   ulAveCollisions      = m_cLookupCollisions ? (cTotalCollisions/m_cLookupCollisions) : 0;

    fprintf(stderr, "\nHash statistics\n");
    fprintf(stderr, "==============================================\n");
    fprintf(stderr, "Total lookup attempts                   %d\n", m_cLookupAttempts);
    fprintf(stderr, "Total lookup successes                  %d\n", m_cLookupSuccesses);
    fprintf(stderr, "Total lookups with hash collisions      %d\n", m_cLookupCollisions);
    fprintf(stderr, "%% of lookups with hash collisions       %d%%\n", ulPercentCollisions);
    fprintf(stderr, "Total hash Collisions                   %d\n", cTotalCollisions);
    fprintf(stderr, "Average length of lookups collisions    %d\n", ulAveCollisions);
    fprintf(stderr, "Hash collisions due to hash function    %d\n", m_cHashCollisions);
    fprintf(stderr, "Hash collisions due to string parent    %d\n", m_cStringCollisions);
    fprintf(stderr, "%% of collsions because of hash function %d%%\n", ulPercentHash);
    fprintf(stderr, "%% of collsions because of basic design  %d%%\n", ulPercentDesign);
    fprintf(stderr, "Total number of buckets used            %d\n", m_cBucketsUsed);
    fprintf(stderr, "%% buckets used                          %d%%\n", m_cBucketsUsed*100/NO_OF_HASH_BUCKETS);

    DumpTableContents();
#endif //DEBUG

    //Free Name pages
    while (pCurrentPage)
    {
        pNextPage = pCurrentPage->pNextPage;
        FREE_NAME_PAGE(pCurrentPage);
        pCurrentPage = pNextPage;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrInit
//
//  Synopsis:   Member function for initializing the domain name table
//
//  Returns:    HRESULT - S_OK on success
//
//  History:    04-18-94  SethuR Created (as DfsInitializePrefixTable)
//              03-03-98  MikeSwa modified for Domain Table
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrInit()
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrInit");
    HRESULT hr = S_OK;

    // Initialize the name page list.
    NamePageList.pFirstPage = ALLOCATE_NAME_PAGE();
    if (NamePageList.pFirstPage != NULL)
    {
        INITIALIZE_NAME_PAGE(NamePageList.pFirstPage);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceFunctLeave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrPrivInsertDomainName
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pPath]  -- the path to be looked up.
//
//              [pvNewData] -- BLOB associated with the path
//
//              [dwDomainNameTableFlags] -- flags that describe insert options
//                  DMT_INSERT_AS_WILDCARD -
//                      Set if the domain is NOT a wildcard
//                      domain, but it should be treated as one (more efficient
//                      than reallocated a string to prepend "*.").
//                  DMT_REPLACE_EXISTRING -
//                      Replace existing data if it exists.  Old data is saved
//                      in ppvOldData.
//
//              [ppvOldData] -- Old Data (if any) that was previously associated
//                      with this domain name.  If NULL, previous data will
//                      not be returned
//  Returns:    HRESULT - S_OK on success
//
//  History:    04-18-94  SethuR Created (as DfsInsertInPrefixTable)
//              03-02-98  MikeSwa Modified for Domain Table
//              05-11-98  MikeSwa... modified to support replace and treat
//                          as wildcard options.
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrPrivInsertDomainName(
                                IN  PDOMAIN_STRING  pstrDomainName,
                                IN  DWORD dwDomainNameTableFlags,
                                IN  PVOID pvNewData,
                                OUT PVOID *ppvOldData)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrPrivInsertDomainName");
    HRESULT                 hr = S_OK;
    TCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PTCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    DOMAIN_STRING           Path,Name;
    ULONG                   BucketNo;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pParentEntry = NULL;
    BOOL                    fNameFound = FALSE;
    BOOL                    fWildcard = FALSE;
    BOOL                    fReplaced = FALSE;

    _ASSERT_DOMAIN_STRING(pstrDomainName);

    // There is one special case, i.e., in which the domain name is '*'.
    // Since this is the WILDCARD_CHAR which is treated in a special
    // way, we do the processing upfront.

    if (pstrDomainName->Length == 0 || pvNewData == NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (ppvOldData)
        *ppvOldData = NULL;


    Path.Length = pstrDomainName->Length;
    Path.MaximumLength = pstrDomainName->MaximumLength;
    Path.Buffer = pstrDomainName->Buffer;
    pParentEntry = &RootEntry;

    //Check if wildcard "*."
    if (DMT_INSERT_AS_WILDCARD & dwDomainNameTableFlags)
    {
        fWildcard = TRUE;
        _ASSERT(!fAdjustPathIfWildcard(pstrDomainName, &Path));
    }
    else if (fAdjustPathIfWildcard(pstrDomainName, &Path))
    {
        fWildcard = TRUE;
    }
    else if (fIsWildcardRoot(pstrDomainName))
    {
        if (RootEntry.pWildCardData != NULL)
        {
            hr = DOMHASH_E_DOMAIN_EXISTS;
        }
        else
        {
            RootEntry.pWildCardData = pvNewData;
        }
        goto Exit;
    }


    if (Path.Length > MAX_PATH_SEGMENT_SIZE) {
        NameBuffer = (PTCHAR) pvMalloc(Path.Length + sizeof(TCHAR));
        if (NameBuffer == NULL) {
            hr = E_OUTOFMEMORY;
            DebugTrace((LPARAM) hr, "ERROR: Unable to allocate %d non-paged bytes", (Path.Length + sizeof(TCHAR)) );
            goto Exit;
        } else {
            cbNameBuffer = Path.Length + sizeof(TCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        // Process the name segment
        BucketNo = ulSplitCaseInsensitivePath(&Path,&Name);

        if (Name.Length > 0)
        {
            // Lookup the table to see if the name segment already exists.
            LookupBucket(&(Buckets[BucketNo]),&Name,pParentEntry,&pEntry,&fNameFound);

            DebugTrace((LPARAM) pEntry, "Returned pEntry");

            if (pEntry == NULL)
            {
                // Initialize the new entry and initialize the name segment.
                pEntry = ALLOCATE_DOMAIN_NAME_TABLE_ENTRY(this);

                if (!pEntry)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                INITIALIZE_DOMAIN_NAME_TABLE_ENTRY(pEntry);

                // Allocate the name space entry if there is no entry in the
                // name page.
                if (!fNameFound)
                {
                    PTSTR pBuffer;

                    // Allocate the entry in the name page.
                    pBuffer = ALLOCATE_NAME_PAGE_ENTRY(NamePageList,(Name.Length/sizeof(TCHAR)));

                    if (pBuffer != NULL)
                    {
                        RtlCopyMemory(pBuffer,Name.Buffer,Name.Length);
                        pEntry->PathSegment = Name;
                        pEntry->PathSegment.Buffer = pBuffer;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        //We shan't leak memory
                        FREE_DOMAIN_NAME_TABLE_ENTRY(pEntry);
                        pEntry = NULL;
                        break;
                    }
                }
                else
                    pEntry->PathSegment = Name;

                // thread the entry to point to the parent.
                pEntry->pParentEntry = pParentEntry;

                // Insert the entry in the bucket.
                if (0 == Buckets[BucketNo].NoOfEntries)
                    InterlockedIncrement((PLONG) &m_cBucketsUsed);

                INSERT_IN_BUCKET(Buckets[BucketNo],pEntry);

                // Insert the entry in the parent's children list.
                INSERT_IN_CHILD_LIST(pEntry, pParentEntry);
            }
            else
            {
                // Increment the no. of children associated with  this entry
                pEntry->NoOfChildren++;
            }

            pParentEntry = pEntry;
        }
        else
        {
            hr = E_INVALIDARG;
            DebugTrace((LPARAM) hr, "ERROR: Unable to insert domain name");
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        // The entry was successfully inserted in the prefix table. Update
        // the data (BLOB) associated with it.
        // We do it outside the loop to prevent redundant comparisons within
        // the loop.

        if (fWildcard)
        {
            if (pEntry->pWildCardData)  //make sure we aren't writing over anything
            {
                if (ppvOldData)
                    *ppvOldData = pEntry->pWildCardData;

                if (DMT_REPLACE_EXISTRING & dwDomainNameTableFlags)
                {
                    fReplaced = TRUE;
                    pEntry->pWildCardData = pvNewData;
                }
                else
                {
                    hr = DOMHASH_E_DOMAIN_EXISTS;
                }
            }
            else
            {
                pEntry->pWildCardData = pvNewData;
            }
        }
        else
        {
            if (pEntry->pData) //make sure we aren't writing over anything
            {
                if (ppvOldData)
                    *ppvOldData = pEntry->pData;

                if (DMT_REPLACE_EXISTRING & dwDomainNameTableFlags)
                {
                    fReplaced = TRUE;
                    pEntry->pData = pvNewData;
                }
                else
                {
                    hr = DOMHASH_E_DOMAIN_EXISTS;
                }
            }
            else
            {
                pEntry->pData = pvNewData;
            }
        }
    }

    // If a new entry was not successfully inserted we need to walk up the chain
    // of parent entries to undo the increment to the reference count and
    // remove the entries from their parent links.
    if (FAILED(hr) || //hr could be set in above if statement
        fReplaced) //remove extra child counts
    {
        while (pParentEntry != NULL)
        {
            PDOMAIN_NAME_TABLE_ENTRY pMaybeTempEntry;

            pMaybeTempEntry = pParentEntry;
            pParentEntry = pParentEntry->pParentEntry;

            if (pParentEntry && --pMaybeTempEntry->NoOfChildren == 0) {
                //
                // If pParentEntry == NULL, pMaybeTempEntry is
                // RootEntry. Do not try to remove it.
                //

                _ASSERT(FAILED(hr) && "We shouldn't get here during replace");
                REMOVE_FROM_CHILD_LIST(pMaybeTempEntry);
                REMOVE_FROM_BUCKET(pMaybeTempEntry);
                FREE_DOMAIN_NAME_TABLE_ENTRY(pMaybeTempEntry);
            }
        }
    }

  Exit:

    TraceFunctLeave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrFindDomainName
//
//  Synopsis:   Method API for looking up a name segment in a prefix table
//
//  Arguments:  IN  pPath  -- the path to be looked up.
//
//              OUT ppData -- placeholder for the BLOB for the prefix.
//
//              IN  fExtactMatch -- FALSE if wildcard matches are allowed
//
//  Returns:    HRESULT - S_OK on success
//
//  History:    04-18-94  SethuR Created (as DfsLookupPrefixTable)
//              03-02-98  MikeSwa Modified for Domain Table
//              06-03-98  MikeSwa Modified to use new HrLookupDomainName
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT DOMAIN_NAME_TABLE::HrFindDomainName(
                               PDOMAIN_STRING      pPath,
                               PVOID               *ppData,
                               BOOL                fExactMatch)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrFindDomainName");
    HRESULT                  hr     = S_OK;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    BOOL                     fExactMatchFound = FALSE;
    _ASSERT_DOMAIN_STRING(pPath);

    if (pPath->Length == 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = HrLookupDomainName(pPath, &fExactMatchFound, &pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (SUCCEEDED(hr))
        {
            _ASSERT(pEntry);
            if (fExactMatchFound && pEntry->pData)
            {
                //exact match found & non-wildcard data is there... use it!
                *ppData = pEntry->pData;
            }
            else if (fExactMatch) //exact match requested, but none found
            {
                hr = DOMHASH_E_NO_SUCH_DOMAIN;
            }
            else //exact match not requested
            {
                //Find the first ancestor with wildcard data
                while (pEntry->pParentEntry && !pEntry->pWildCardData)
                {
                    _ASSERT(pEntry != &RootEntry);
                    pEntry = pEntry->pParentEntry;
                }
                *ppData = pEntry->pWildCardData;
                if (!*ppData) //no wildcard match found
                {
                    _ASSERT(pEntry == &RootEntry); //We should search back to root
                    hr = DOMHASH_E_NO_SUCH_DOMAIN;
                }
            }
        }
        else if (!fExactMatch && (DOMHASH_E_NO_SUCH_DOMAIN == hr))
        {
            //if we don't require an exact match.... check the wildcard root
            if (RootEntry.pWildCardData)
            {
                hr = S_OK;
                *ppData = RootEntry.pWildCardData;
            }
        }

    }
    TraceFunctLeave();
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrRemoveDomainName
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pPath]  -- the path to be removed from table.
//              [ppvData] - Data that WAS stored in entry
//
//  Returns:    HRESULT
//                  S_OK on success
//                  DOMHASH_E_NO_SUCH_DOMAIN if not found
//
//  History:    04-18-94  SethuR Created (as DfsRemoveFromPrefixTable)
//              03-03-98  MikeSwa - Updated for Domain Table
//              06-03-98  MikeSwa - Modified to use new HrLookupDomainName
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT DOMAIN_NAME_TABLE::HrRemoveDomainName(PDOMAIN_STRING  pPath, PVOID *ppvData)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrRemoveDomainName");
    HRESULT         hr  = S_OK;
    DOMAIN_STRING   Path;
    BOOL            fWildcard = FALSE;
    BOOL            fExactMatchFound = FALSE;
    _ASSERT_DOMAIN_STRING(pPath);

    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pTempEntry = NULL;

    if (!ppvData)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (pPath->Length == 0)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = pPath->Buffer;

    if (fAdjustPathIfWildcard(pPath, &Path))
    {
        fWildcard = TRUE;
    }
    else if (fIsWildcardRoot(pPath))
    {
        *ppvData = RootEntry.pWildCardData;
        if (!*ppvData)
        {
            hr = DOMHASH_E_NO_SUCH_DOMAIN;
        }
        RootEntry.pWildCardData = NULL;
        goto Exit;
    }


    hr = HrLookupDomainName(&Path, &fExactMatchFound, &pEntry);

    if (SUCCEEDED(hr))
    {

        if (!fExactMatchFound)
        {
            //only a partial match was found
            hr = DOMHASH_E_NO_SUCH_DOMAIN;
            goto Exit;
        }

        // Destroy the association between the data associated with
        // this prefix.
        if (!fWildcard)
        {
            *ppvData = pEntry->pData;
            pEntry->pData = NULL;
        }
        else
        {
            *ppvData = pEntry->pWildCardData;
            pEntry->pWildCardData = NULL;
        }

        if (!*ppvData) //no data of of requested type in entry
        {
            //Make sure this isn't a completely NULL data leaf node (ie no way to delete it)
            _ASSERT(pEntry->pFirstChildEntry || pEntry->pData || pEntry->pWildCardData);
            hr = DOMHASH_E_NO_SUCH_DOMAIN;
            goto Exit;
        }

        // found an exact match for the given path name in the table.
        // traverse the list of parent pointers and delete them if
        // required.

        RemoveTableEntry(pEntry);
    }


  Exit:
    TraceFunctLeave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrLookupDomainName
//
//  Synopsis:   Private function for looking up an *entry* in the table.  It
//              makes no guarantees that there is user data available for the
//              returned entry.  This is the caller's responsibility.  It will
//              match the longest partial path... check fExactMatch to see
//              if an exact match was found
//
//  Arguments:  IN  pPath  -- the path to be looked up.
//
//              OUT pfExactMatch -- Exact Match was found
//
//              OUT ppEntry -- The matching entry for the path.
//
//
//  Returns:    HRESULT
//                  S_OK on success
//                  DOMHASH_E_NO_SUCH_DOMAIN if not found
//                  E_OUTOFMEMORY
//
//  History:    04-18-94  SethuR Created (as _LookupPrefixTable)
//              03-03-98  MikeSwa Modified for Domain Table
//              06-03-98  MikeSwa ExactMatch changed to OUT parameter
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT DOMAIN_NAME_TABLE::HrLookupDomainName(
                            DOMAIN_STRING            *pPath,
                            BOOL                     *pfExactMatch,
                            PDOMAIN_NAME_TABLE_ENTRY  *ppEntry)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrLookupDomainName");
    HRESULT                 hr = S_OK;
    DOMAIN_STRING           Path = *pPath;
    TCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PTCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    DOMAIN_STRING           Name;
    ULONG                   BucketNo;
    BOOL                    fPrefixFound = FALSE;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pParentEntry = &RootEntry;
    BOOL                    fNameFound = FALSE;

    _ASSERT(Path.Buffer[0] != PATH_DELIMITER);

    *pfExactMatch = FALSE;

    if (Path.Length > MAX_PATH_SEGMENT_SIZE) {
        NameBuffer = (PTCHAR) pvMalloc(Path.Length + sizeof(TCHAR));
        if (NameBuffer == NULL) {
            hr = E_OUTOFMEMORY;
            DebugTrace((LPARAM) hr, "ERROR: Unable to allocate %d non-paged bytes", (Path.Length + sizeof(TCHAR)) );
            goto Exit;
        } else {
            cbNameBuffer = Path.Length + sizeof(TCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        BucketNo = ulSplitCaseInsensitivePath(&Path,&Name);

        if (Name.Length > 0)
        {
            // Process the name segment
            // Lookup the bucket to see if the entry exists.
            LookupBucket(&(Buckets[BucketNo]),&Name,pParentEntry,&pEntry,&fNameFound);

            DebugTrace((LPARAM) pEntry, "Returned pEntry");

            if (pEntry != NULL)
            {
                *pfExactMatch = TRUE;
                _ASSERT(fNameFound && "Lookup bucket is broken");
                // Cache the data available for this prefix if any.
                 *ppEntry = pEntry;
            }
            else
            {
                *pfExactMatch = FALSE;
                break;
            }

            // set the stage for processing the next name segment.
            pParentEntry = pEntry;
        }
    }

    //Not even a partial match was found
    if (!*ppEntry)
    {
        _ASSERT(FALSE == *pfExactMatch);
        hr = DOMHASH_E_NO_SUCH_DOMAIN;
        DebugTrace((LPARAM) hr, "INFO: Path %s not found", pPath->Buffer);
    }


  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ DOMAIN_NAME_TABLE::HrIterateOverSubDomains ]----------------------------
//
//
//  Description:
//
//  Parameters:
//      IN strDomain    - Domain string to search for subdomains of
//                        (should not start with "*.")
//      IN pfn          - Mapping function (described below)
//      IN pvContext    - Context ptr pass to mapping function
//
//  Notes:
//      VOID DomainTableInteratorFunction(
//          IN PVOID pvContext, //context passed to HrIterateOverSubDomains
//          IN PVOID pvData, //data entry to look at
//          IN BOOL fWildcardData, //true if data is a wildcard entry
//          OUT BOOL *pfContinue, //TRUE if iterator should continue to the next entry
//          OUT BOOL *pfRemoveEntry); //TRUE if entry should be deleted
//
//  Returns:
//      S_OK on success
//      DOMHASH_E_NO_SUCH_DOMAIN if there is no matching domain or subdomains
//  History:
//      6/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrIterateOverSubDomains(
        IN DOMAIN_STRING *pstrDomain,
        IN DOMAIN_ITR_FN pfn,
        IN PVOID pvContext)
{
    HRESULT hr = S_OK;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pRootEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pNextEntry = NULL;
    BOOL    fExactMatchFound = FALSE;
    BOOL    fContinue        = TRUE;
    BOOL    fDelete          = FALSE;
    DWORD   cDomainsFound    = 0;
    BOOL    fWildcard        = FALSE;

    _ASSERT(pfn && "Invalid Param - pfn");
    _ASSERT((!pstrDomain || (WILDCARD_CHAR != pstrDomain->Buffer[0])) && "Invalid param - string starts with '*'");

    if (pstrDomain)
    {
        hr = HrLookupDomainName(pstrDomain, &fExactMatchFound, &pEntry);

        if (FAILED(hr))
            goto Exit;

        if (!fExactMatchFound) //there must be an entry at root of subtree
        {
            hr = DOMHASH_E_NO_SUCH_DOMAIN;
            goto Exit;
        }

        _ASSERT(pEntry);
    }
    else
    {
        //if !pstrDomain.., iterate over entire hash table
        pEntry = &RootEntry;
    }

    pRootEntry = pEntry;

    //Traverse all the child entries of pRootEntry (preorder)
    while (pEntry)
    {
        //get next entry before it is deleted
        pNextEntry = pNextTableEntry(pEntry, pRootEntry);

        //This check must be done before call to RemoveTableEntry
        //If there is no wildcard data, then entry might be deleted
        //after call to RemoveTableEntry (if it has no children)
        fWildcard = (NULL != pEntry->pWildCardData);

        if (pEntry->pData)
        {
            cDomainsFound++;
            pfn(pvContext, pEntry->pData, FALSE, &fContinue, &fDelete);
            if (fDelete)
            {
                pEntry->pData = NULL;
                RemoveTableEntry(pEntry);
            }
            if (!fContinue)
                break;
        }

        if (fWildcard)
        {
            cDomainsFound++;
            pfn(pvContext, pEntry->pWildCardData, TRUE, &fContinue, &fDelete);
            if (fDelete)
            {
                pEntry->pWildCardData = NULL;
                RemoveTableEntry(pEntry);
            }
            if (!fContinue)
                break;
        }
        pEntry = pNextEntry;
    }

    if (!cDomainsFound)
        hr = DOMHASH_E_NO_SUCH_DOMAIN;

  Exit:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::pvNextDomainName
//
//  Synopsis:   Enumerates the entries in the table in ordered fashion.
//              Note that state is maintained between calls to
//              pvNextDomainName - the caller must ensure that the table
//              is not modified between calls to pNextTableEntry by acquiring
//              an external read lock
//
//  Arguments:  IN OUT PVOID *ppvContext - context used to hold place
//
//  Returns:    Valid pointer to data associated with the next Prefix Table
//              entry, or NULL if at the end of the enumeration.
//
//-----------------------------------------------------------------------------
PVOID DOMAIN_NAME_TABLE::pvNextDomainName(IN OUT PVOID *ppvContext)
{
    PDOMAIN_NAME_TABLE_ENTRY pEntry, pNextEntry;
    PVOID   pvData = NULL;
    bool fDataUsed = false;

    _ASSERT(ppvContext);

    if ((PVOID) this == *ppvContext)
    {
        *ppvContext = NULL;
        goto Exit;
    }

    //Find entry to get data for
    if (!*ppvContext)
    {
        //We're starting over
        pNextEntry = &RootEntry;

        //Find first entry with valid data
        while (pNextEntry != NULL &&
               pNextEntry->pData == NULL &&
               pNextEntry->pWildCardData == NULL)
        {
            pNextEntry = pNextTableEntry(pNextEntry);
        }
    }
    else
    {
        //Use context provided as starting point
        if (ENTRY_SIG == **((DWORD**) ppvContext))
        {
            pNextEntry = (PDOMAIN_NAME_TABLE_ENTRY) *ppvContext;
        }
        else
        {
            _ASSERT(WILDCARD_SIG == **((DWORD **) ppvContext));
            pNextEntry = CONTAINING_RECORD(*ppvContext, DOMAIN_NAME_TABLE_ENTRY, dwWildCardSig);
            _ASSERT(ENTRY_SIG == pNextEntry->dwEntrySig);
            fDataUsed = true;
        }

        //If this is a next entry... either pData or pWildCard should be non-NULL
        _ASSERT(pNextEntry->pData || pNextEntry->pWildCardData);
    }

    pEntry = pNextEntry;

    //Save data to return in pvData
    if (pEntry != NULL)
    {
        if (pEntry->pData && !fDataUsed)
        {
            pvData = pEntry->pData;
        }
        else
        {
            _ASSERT(pEntry->pWildCardData);
            pvData = pEntry->pWildCardData;
        }
    }

    //Determine what context to return
    if (pNextEntry != NULL)
    {
        if (!fDataUsed && pNextEntry->pWildCardData && pEntry->pData)
        {
            //use wildcard data next time through
            *ppvContext = (PVOID) &(pNextEntry->dwWildCardSig);
        }
        else
        {
            do //find next entry that does not point to NULL info
            {
                pNextEntry = pNextTableEntry( pNextEntry );
            } while ( pNextEntry != NULL &&
                      pNextEntry->pData == NULL &&
                      pNextEntry->pWildCardData == NULL);
            *ppvContext = (PVOID) pNextEntry;
            _ASSERT(*ppvContext != (PVOID) this);  //so our sentinal value works
            if (NULL == *ppvContext)
            {
                *ppvContext = (PVOID) this;
            }
        }
    }

  Exit:

    return pvData;
}

//+----------------------------------------------------------------------------
//
//  Function:   pNextTableEntry
//
//  Synopsis:   Given a pointer to a Prefix Table Entry, this function will
//              return a pointer to the "next" prefix table entry.
//
//              The "next" entry is chosen as follows:
//                  If the start entry has a valid child, the child is
//                      is returned.
//                  else if the start entry has a valid sibling, the sibling
//                      is returned
//                  else the first valid sibling of the closest ancestor is
//                      returned.
//
//  Arguments:  [pEntry] -- The entry to start from.
//              [pRootEntry] -- Root node of subtree being enumerated
//                              (NULL or address of root entry will do all)
//
//  Returns:    Pointer to the next DOMAIN_NAME_TABLE_ENTRY that has a valid
//              pData, or NULL if there are no more entries.
//
//  Note:       You must have a read lock over a sequence of calls into this
//              function (you cannot release it between calls).
//  History;
//      06/09/98 - Mikeswa modified to accept RootEntry
//
//-----------------------------------------------------------------------------
PDOMAIN_NAME_TABLE_ENTRY
DOMAIN_NAME_TABLE::pNextTableEntry(IN PDOMAIN_NAME_TABLE_ENTRY pEntry,
                                   IN PDOMAIN_NAME_TABLE_ENTRY pRootEntry)
{
    PDOMAIN_NAME_TABLE_ENTRY pNextEntry = NULL;
    _ASSERT(pEntry);

    if (pEntry->pFirstChildEntry != NULL)
    {
        pNextEntry = pEntry->pFirstChildEntry;
    }
    else if ((pEntry->pSiblingEntry != NULL) && //if there is a sibling entry
            (pEntry != pRootEntry))             //this is not the root entry

    {
        //Should have same parent
        _ASSERT(pEntry->pParentEntry == pEntry->pSiblingEntry->pParentEntry);
        pNextEntry = pEntry->pSiblingEntry;
    }
    else
    {
        for (pNextEntry = pEntry->pParentEntry;
            pNextEntry != NULL &&
            pNextEntry->pSiblingEntry == NULL &&
            pNextEntry != pRootEntry;
            pNextEntry = pNextEntry->pParentEntry)
        {
            //NOTHING;
        }

        if (pNextEntry == pRootEntry)
        {
            pNextEntry = NULL;
        }
        else if (pNextEntry != NULL)
        {
            pNextEntry = pNextEntry->pSiblingEntry;
        }

    }
    return pNextEntry;
}
//---[ DOMAIN_NAME_TABLE::DumpTableContents ]----------------------------------
//
//
//  Description:
//      Print out contents of table.  Intended primarily for leak detection
//      during table destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void DOMAIN_NAME_TABLE::DumpTableContents()
{
    PDOMAIN_NAME_TABLE_ENTRY    pEntry = NULL;
    DOMAIN_STRING               Path;
    CHAR                        Buffer[MAX_PATH_SEGMENT_SIZE+1];
    DWORD                       cLeaks = 0;

    Path.Length = 0;
    Path.MaximumLength = MAX_PATH_SEGMENT_SIZE;
    Path.Buffer = Buffer;

    //Check for leaked entries
    pEntry = pNextTableEntry(&RootEntry);
    if (pEntry)
    {
        fprintf(stderr, "\nFOUND LEAKED ENTRIES!!\n\n");
        fprintf(stderr, "Entry ID    # Children  pData       pWildCard    Path\n");
        fprintf(stderr, "===========================================================================\n");
        while(pEntry)
        {
            _ASSERT(pEntry);
            GET_DOMAIN_NAME_TABLE_ENTRY_PATH(pEntry, &Path);
            fprintf(stderr, "0x%p  %10.10d  0x%p  0x%p   %s\n", pEntry,
                pEntry->NoOfChildren, pEntry->pData, pEntry->pWildCardData, Path.Buffer);
            cLeaks++;
            pEntry = pNextTableEntry(pEntry);
        }
        fprintf(stderr, "===========================================================================\n");
        fprintf(stderr, "Total Leaks: %d\n", cLeaks);
    }
}

//---[ DOMAIN_NAME_TABLE::RemoveTableEntry ]------------------------------------
//
//
//  Description:
//      Removes an entry from the table
//  Parameters:
//      IN  pentry  - Entry to remove
//  Returns:
//      -
//  History:
//      6/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void DOMAIN_NAME_TABLE::RemoveTableEntry(IN PDOMAIN_NAME_TABLE_ENTRY pEntry)
{
    PDOMAIN_NAME_TABLE_ENTRY pTempEntry = NULL;
    while (pEntry != NULL)
    {
        pTempEntry = pEntry;
        pEntry = pEntry->pParentEntry;
        if (pEntry && (--pTempEntry->NoOfChildren) == 0)
        {
            _ASSERT(!pTempEntry->pData && !pTempEntry->pWildCardData);
            //
            // pEntry == NULL means pTempEntry is pTable->RootEntry.
            // Do not try to remove it. (we also do not maintain a child count
            // on it).
            //
            REMOVE_FROM_CHILD_LIST(pTempEntry);
            REMOVE_FROM_BUCKET(pTempEntry);
            FREE_DOMAIN_NAME_TABLE_ENTRY(pTempEntry);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\domhash\_domhash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992, 1998.
//
//  File:       _domhash.cpp
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//              MikeSwa -- Modified for Domain Name lookup 2/98
//
//  Notes:
//  2/98        The major difference between the DFS version and the domain 
//              name lookup is the size of the table, the ability for 
//              wildcard lookups (*.foo.com), and the reverse order of the 
//              lookup (com hashes first in foo.com).  To make the code more
//              readable given its new purpose, the files, structures, and
//              functions have been given non DFS-centric names.  A quick 
//              mapping of the major files is (for those familiar with the 
//              DFS code):
//                  domhash.h  (prefix.h)    -   Public include file
//                  _domhash.h (prefixp.h)   -   Private inlcude file 
//                  domhash.c  (prefix.c)    -   Implementation of API
//                  _domhash.c (prefixp.c)   -   Private helper functions.
//
//--------------------------------------------------------------------------

#include "_domhash.h"

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (        \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//+---------------------------------------------------------------------------
//
//  Function:   _AllocateNamePageEntry
//
//  Synopsis:   private fn. for allocating a name page entry
//
//  Arguments:  [pNamePageList] -- name page list to allocate from
//
//              [cLength]  -- length of the buffer in TCHAR's
//
//  Returns:    NULL if unsuccessfull otherwise valid pointer
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PTSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pNamePageList,
                             ULONG           cLength)
{
   TraceFunctEnterEx((LPARAM) NULL, "_AllocateNamePageEntry");
   PNAME_PAGE pTempPage = pNamePageList->pFirstPage;
   PTSTR pBuffer = NULL;

   while (pTempPage != NULL)
   {
       if (pTempPage->cFreeSpace > (LONG)cLength)
          break;
       else
          pTempPage = pTempPage->pNextPage;
   }

   if (pTempPage == NULL)
   {
       pTempPage = ALLOCATE_NAME_PAGE();

       if (pTempPage != NULL)
       {
           INITIALIZE_NAME_PAGE(pTempPage);
           pTempPage->pNextPage = pNamePageList->pFirstPage;
           pNamePageList->pFirstPage = pTempPage;
           pTempPage->cFreeSpace = FREESPACE_IN_NAME_PAGE;
       }
   }

   if ((pTempPage != NULL) && (pTempPage->cFreeSpace >= (LONG)cLength))
   {
       pTempPage->cFreeSpace -= cLength;
       pBuffer = &pTempPage->Names[pTempPage->cFreeSpace];
   }

   TraceFunctLeave();
   return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\dbgdumpx\extdemex\extdemex.h ===
//-----------------------------------------------------------------------------
//
//
//	File: extdemex.h
//
//	Description:  Header file for CDB extension demo .exe file
//
//	Author: mikeswa
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <dbgdumpx.h>

typedef struct _MY_STRUCT
{
    DWORD       m_cbName;
    LPSTR       m_szName;
} MY_STRUCT;

typedef void(*PFUNCTION)(void);
class CMyClass
{
  private:
    DWORD       m_dwPrivateSignature;
    DWORD       m_dwFlags;
    MY_STRUCT   m_MyStruct;
  public:
      typedef enum _MY_ENUM {ENUM_VAL1, ENUM_VAL2} MY_ENUM;
    BYTE        m_bMyByte;
    CHAR        m_chMyChar;
    BOOLEAN     m_fBoolean;
    BOOL        m_fBool;
    ULONG       m_ulMyUlong;
    LONG        m_lMyLong;
    USHORT      m_usMyUshort;
    SHORT       m_sMyShort;
    GUID        m_guid;
    PVOID       m_pvMyPtr;
    LPSTR       m_szMySz;
    LPWSTR      m_wszMyWsz;
    UNICODE_STRING m_MyUnicodeString;
    ANSI_STRING m_MyAnsiString;
    CHAR        m_szBuffer[100];
    WCHAR       m_wszBuffer[200];
    PFUNCTION   m_pFunction;
    MY_ENUM     m_eMyEnum;
    BYTE        m_bFlags;
    WORD        m_wFlags;
    LARGE_INTEGER m_liMyLargeInteger;
    DWORD       m_dwMyDWORD;
    CMyClass();
    ~CMyClass();
};

//Flags
#define CLASS_OK        0x1
#define CLASS_INVALID   0x2
#define MISC_BIT1       0x4
#define MISC_BIT2       0x8
#define WORD_BIT        0x8000
#define DWORD_BIT       0x00800000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\domhash\_domhash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992, 1998.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented as DFS PERFIX table
//              Mikeswa 2/98 - updated for use as SMTP Domain Name Hash
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DOMAIN_NAME_TABLE_ENTRY,DOMAIN_NAME_TABLE_BUCKET and the
//              DOMAIN_NAME_TABLE.
//
//              The DOMAIN_NAME_TABLE is a hash table of DOMAIN_NAME_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DOMAIN_NAME_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//  2/98        The major difference between the DFS version and the domain
//              name lookup is the size of the table, the ability for
//              wildcard lookups (*.foo.com), and the reverse order of the
//              lookup (com hashes first in foo.com).  To make the code more
//              readable given its new purpose, the files, structures, and
//              functions have been given non DFS-centric names.  A quick
//              mapping of the major files is (for those familiar with the
//              DFS code):
//                  domhash.h    (prefix.h)    -   Public include file
//                  _domhash.h   (prefixp.h)   -   Private inlcude file
//                  domhash.cpp  (prefix.c)    -   Implementation of API
//                  _domhash.cpp (prefixp.c)   -   Private helper functions.
//
//--------------------------------------------------------------------------

#ifndef ___DOMHASH_H__
#define ___DOMHASH_H__

#include <domhash.h>
#include <transmem.h>

//
// MAX_PATH_SEGMENT_SIZE is simply used as a good size buffer to do prefix
// lookups and insertions. This should save us from having to allocate for
// most cases.
//

#define MAX_PATH_SEGMENT_SIZE  256
#define PATH_DELIMITER _TEXT('.')
#define WILDCARD_CHAR  _TEXT('*')
#define COMPARE_MEMORY(s,d,l)   memcmp(s,d,l)

#ifndef UNICODE
//Optimized ASCII version to handle 99% case
#define DOMHASH_TO_UPPER(mychar) \
    ((mychar) < 'a')   ? (mychar) \
                       : (((mychar) <= 'z') \
                       ? ((mychar) - 'a' + 'A') : mychar)
#else
#define DOMHASH_TO_UPPER(mychar) _towupper(mychar)
#endif //UNICODE

//---[ fAdjustPathIfWildcard ]-------------------------------------------------
//
//
//  Description:
//      Checks if a path is a wildcard path (starts with "*.") and moves the
//      begining of the domain to point past the first 2 characters if so.
//  Parameters:
//      IN  pDomainSource    Domain to check
//      OUT pDomainDest      Domain to modify
//  Returns:
//      TRUE if pPath is a wildcarded domain, FALSE otherwise
//
//-----------------------------------------------------------------------------
inline BOOL fAdjustPathIfWildcard(IN  DOMAIN_STRING *pDomainSource,
                                  OUT DOMAIN_STRING *pDomainDest)
{
    //Check if wildcard "*."
    if (pDomainSource->Length > 2 &&
        pDomainSource->Buffer[0] == WILDCARD_CHAR &&
        pDomainSource->Buffer[1] == PATH_DELIMITER)
    {
        //Adjust path to point past starting "*."
        pDomainDest->Length -= 2*sizeof(TCHAR);
        pDomainDest->MaximumLength -= 2*sizeof(TCHAR);
        pDomainDest->Buffer += 2;
        return TRUE;
    }
    return FALSE;
}

//---[ fIsWildcardRoot ]-------------------------------------------------------
//
//
//  Description:
//      Checks is given domain is the wildcard root domains (single character
//      that is WILDCARD_CHAR.
//  Parameters:
//      IN pPath    Domain to check
//  Returns:
//      TRUE if root wildcard, FALSE otherwise
//
//-----------------------------------------------------------------------------
inline BOOL fIsWildcardRoot(IN DOMAIN_STRING *pPath)
{
    //Check if 1 char long, and that char is WILDCARD_CHAR
    return(pPath->Length == sizeof(TCHAR) &&
           pPath->Buffer[0] == WILDCARD_CHAR);
}

//---[ ALLOCATE_DOMAIN_STRING ]------------------------------------------------
//
//
//  Description:
//      Allocates a new DOMAIN_STRING structure and initializes with copy of
//      given string.
//  Parameters:
//      szDomainName    string to initialize structure with
//  Returns:
//      PDOMAIN_STRING  on success
//      NULL on failure
//
//-----------------------------------------------------------------------------
inline PDOMAIN_STRING ALLOCATE_DOMAIN_STRING(PTSTR szDomainName)
{
    PDOMAIN_STRING  pDomainString = NULL;
    USHORT  usStringLength = 0;
    PSTR    pBuffer = NULL;

    _ASSERT(szDomainName);

    if (!szDomainName)
        goto Exit;

    usStringLength = (USHORT)_tcslen(szDomainName);

    pBuffer = (PSTR) pvMalloc(sizeof(TCHAR) * (usStringLength+1));
    if (!pBuffer)
        goto Exit;

    memcpy(pBuffer, szDomainName, (sizeof(TCHAR) * (usStringLength+1)));

    pDomainString = (PDOMAIN_STRING) pvMalloc(sizeof(DOMAIN_STRING));
    if (!pDomainString)
        goto Exit;

    pDomainString->Length = usStringLength*sizeof(TCHAR);
    pDomainString->MaximumLength = pDomainString->Length;
    pDomainString->Buffer = pBuffer;

    pBuffer = NULL;

  Exit:
    if (pBuffer)
        FreePv(pBuffer);

    return pDomainString;

}
//---[ ulSplitCaseInsensitivePath ]--------------------------------------------
//
//
//  Description:
//      Spits path around delimited characters and returns a hash (bucket number)
//      for the current string between delimiters.
//  Parameters:
//      pPath       Path to split (modified to maintain place in path)
//      pName       the leftmost component of the path(PDOMAIN_STRING )
//
//  SideEffects: structures pointed to by pName and pPath are modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created (as SPLIT_CASE_INSENSITIVE_PATH macro)
//              03-03-98  MikeSwa Made into C++ inline function - reversed order
//                        of search.
//  Returns:
//      Hash Bucket Number corresponding to the path name
//
//  NOTE:
//      pName grows backswords from pPath... if pPath is "machine.foo.com",
//      then pName will point to "MOC", "OOF", and "ENIHCAM" on successive calls.
//      This is because the hierarchy of the domain name is from right to left.
//
//-----------------------------------------------------------------------------
inline ULONG ulSplitCaseInsensitivePath(IN  OUT PDOMAIN_STRING  pPath,
                                        OUT     PDOMAIN_STRING  pName)
{
    TraceFunctEnterEx((LPARAM) NULL, "ulSplitCaseInsensitivePath");
    TCHAR *pPathBuffer   = (pPath)->Buffer;
    TCHAR *pNameBuffer   = (pName)->Buffer;
    TCHAR *pPathBufferStart = pPathBuffer-1;
    ULONG  BucketNo = 0;

    //Start from end of string
    pPathBuffer += ((pPath)->Length / sizeof(TCHAR) -1 );

    while ((pPathBufferStart != pPathBuffer) &&
           ((*pNameBuffer = *pPathBuffer--) != PATH_DELIMITER))
    {
        *pNameBuffer = DOMHASH_TO_UPPER(*pNameBuffer);
        BucketNo *= 131;  //First prime after ASCII character codes
        BucketNo += *pNameBuffer;
        pNameBuffer++;
    }

    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;
    *pNameBuffer = _TEXT('\0');
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer);

    //Set Path Length to not include before the portion we have already scanned
    (pPath)->Length = (USHORT)((CHAR *)pPathBuffer - (CHAR *)pPathBufferStart);

    TraceFunctLeave();
    return(BucketNo);
}

//+---------------------------------------------------------------------------
//
//  Function:   LookupBucket
//
//  Synopsis:   lookups the bucket for an entry.
//
//  Arguments:  IN  [Bucket] -- the bucket to be used (DOMAIN_NAME_TABLE_BUCKET)
//
//              IN  [Name]   -- the name to be looked up (DOMAIN_STRING )
//
//              IN  [pParentEntry] -- the parent entry of the entry we are
//                                searching for.
//
//              OUT [pEntry] -- placeholder for the desired entry.
//
//              OUT [fNameFound] -- indicates if the name was found.
//
//  SideEffects: Name,fNameFound and pEntry are modified
//
//  History:    04-18-94  SethuR Created (as macro)
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//  Notes:
//
//              We only store one copy of a string irrespective of the no. of
//              places it appears in, e.g. foo.bar and foo1.bar will result
//              in only one copy of bar being stored. This implies that the
//              lookup routine will have to return sufficient info. to prevent
//              the allocation of memory space for a string. If on exit
//              fNameFound is set to TRUE then this indicates that a similar
//              string was located in the table and the Name.Buffer field is
//              modified to point to the first instance of the string in
//              the table.
//
//----------------------------------------------------------------------------
inline void DOMAIN_NAME_TABLE::LookupBucket(
                         IN  PDOMAIN_NAME_TABLE_BUCKET pBucket,
                         IN  PDOMAIN_STRING  pName,
                         IN  PDOMAIN_NAME_TABLE_ENTRY pParentEntry,
                         OUT PDOMAIN_NAME_TABLE_ENTRY *ppEntry,
                         OUT BOOL *pfNameFound)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::LookupBucket");
    PDOMAIN_NAME_TABLE_ENTRY pCurEntry = pBucket->SentinelEntry.pNextEntry;
    ULONG   cHashCollisions = 0;
    ULONG   cStringCollisions = 0;
    BOOL    fHashCollision = TRUE;


    *pfNameFound = FALSE;
    *ppEntry = NULL;

    InterlockedIncrement((PLONG) &m_cLookupAttempts);

    //NOTE: This is a linear search of all the hash collisions for and multiple
    //instances of a domains name section.
    while (pCurEntry != &(pBucket->SentinelEntry))
    {
        fHashCollision = TRUE;
        if (pCurEntry->PathSegment.Length == pName->Length)
        {
            //Only do mem compare if length is the same

            //only do compare if we haven't found a string match
            if ((!*pfNameFound) &&
                    (!COMPARE_MEMORY(pCurEntry->PathSegment.Buffer,
                             pName->Buffer,
                             pName->Length)))
            {
                 *pfNameFound = TRUE;
                 pName->Buffer = pCurEntry->PathSegment.Buffer;
            }

            //If *pfNameFound is set, then a match has already been found
            //and pName->Buffer points to our internal copy.  We only need
            //to do a pointer compare
            if (*pfNameFound &&
               (pCurEntry->PathSegment.Buffer == pName->Buffer))
            {
                if (pCurEntry->pParentEntry == pParentEntry)
                {
                    *ppEntry = pCurEntry;
                    break;
                }
                fHashCollision = FALSE;
                cStringCollisions++; //correct string wrong parent
            }
        }

        if (fHashCollision)
            cHashCollisions++;  //multiple strings in this bucket

        pCurEntry = pCurEntry->pNextEntry;
    }

    if (*ppEntry)
    {
        //Lookup succeeded
        InterlockedIncrement((PLONG) &m_cLookupSuccesses);
    }


    if (cHashCollisions || cStringCollisions)
    {
        InterlockedIncrement((PLONG) &m_cLookupCollisions);
        if (cHashCollisions)
        {
            InterlockedExchangeAdd((PLONG) &m_cHashCollisions, cHashCollisions);
        }
        if (cStringCollisions)
        {
            InterlockedExchangeAdd((PLONG) &m_cStringCollisions, cStringCollisions);
        }
    }
    TraceFunctLeave();
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_BUCKET
//
//  Synopsis:   Initializes a hash bucket.
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DOMAIN_NAME_TABLE_BUCKET)
//
//  SideEffects: the bucket is intialized ( the collision list and count are
//               initialized
//
//  History:    04-18-94  SethuR Created
//              03-05-98  MikeSwa - made into inline function (instead of macro)
//
//----------------------------------------------------------------------------

void inline INITIALIZE_BUCKET(DOMAIN_NAME_TABLE_BUCKET &Bucket)                                           \
{
   (Bucket).SentinelEntry.pNextEntry = &(Bucket).SentinelEntry;
   (Bucket).SentinelEntry.pPrevEntry = &(Bucket).SentinelEntry;
   (Bucket).NoOfEntries = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_BUCKET
//
//  Synopsis:   inserts the entry in the bucket
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DOMAIN_NAME_TABLE_BUCKET)
//
//              [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to include the entry
//
//  History:    04-18-94  SethuR Created
//              03-05-98  MikeSwa - updated to count total buckets used and
//                          made into inline function (instead of macro)
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

void inline INSERT_IN_BUCKET(DOMAIN_NAME_TABLE_BUCKET &Bucket,
                         PDOMAIN_NAME_TABLE_ENTRY pEntry)                                     \
{
    (Bucket).NoOfEntries++;
    (pEntry)->pPrevEntry = (Bucket).SentinelEntry.pPrevEntry;
    (pEntry)->pNextEntry = &((Bucket).SentinelEntry);
    ((Bucket).SentinelEntry.pPrevEntry)->pNextEntry = (pEntry);
    (Bucket).SentinelEntry.pPrevEntry = (pEntry);
}

//+---------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_BUCKET
//
//  Synopsis:   removes the entry from the bucket
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to exclude the entry
//
//  History:    04-18-94  SethuR Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//----------------------------------------------------------------------------

void inline REMOVE_FROM_BUCKET(PDOMAIN_NAME_TABLE_ENTRY pEntry)
{
    PDOMAIN_NAME_TABLE_ENTRY pPrevEntry = (pEntry)->pPrevEntry;
    PDOMAIN_NAME_TABLE_ENTRY pNextEntry = (pEntry)->pNextEntry;

    pPrevEntry->pNextEntry = pNextEntry;
    pNextEntry->pPrevEntry = pPrevEntry;
}

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_CHILD_LIST
//
//  Synopsis:   Inserts this entry in the parent's list of children
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//              [pParentEntry] -- the entry into whose list of children
//                      pEntry has to be inserted.
//
//  SideEffects: Parent's list of children is modified.
//
//  History:    01-09-96  MilanS Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//----------------------------------------------------------------------------

void inline INSERT_IN_CHILD_LIST(PDOMAIN_NAME_TABLE_ENTRY pEntry,
                                 PDOMAIN_NAME_TABLE_ENTRY pParentEntry)
{
    PDOMAIN_NAME_TABLE_ENTRY pLastChild;

    if (pParentEntry->pFirstChildEntry == NULL) {
        pParentEntry->pFirstChildEntry = pEntry;
    } else {
        for (pLastChild = pParentEntry->pFirstChildEntry;
                pLastChild->pSiblingEntry != NULL;
                    pLastChild = pLastChild->pSiblingEntry) {
             //NOTHING;
        }
        pLastChild->pSiblingEntry = pEntry;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_CHILD_LIST
//
//  Synopsis:   Removes an entry from its parent's list of children
//
//  Arguments:  [pEntry] -- the Entry to remove from children list.
//
//  SideEffects: The children list of pParentEntry is modified.
//
//  History:    01-09-96  MilanS Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//  Notes:      This routine will ASSERT if pEntry is not in the parent's
//              list of children.
//
//-----------------------------------------------------------------------------

void inline REMOVE_FROM_CHILD_LIST(PDOMAIN_NAME_TABLE_ENTRY pEntry)                                       \
{
    PDOMAIN_NAME_TABLE_ENTRY pParentEntry = pEntry->pParentEntry;
    PDOMAIN_NAME_TABLE_ENTRY pPrevSibling;

    if (pParentEntry->pFirstChildEntry == pEntry) {
        pParentEntry->pFirstChildEntry = pEntry->pSiblingEntry;
    } else {
        for (pPrevSibling = pParentEntry->pFirstChildEntry;
                pPrevSibling->pSiblingEntry != pEntry;
                    pPrevSibling = pPrevSibling->pSiblingEntry) {
             _ASSERT(pPrevSibling->pSiblingEntry != NULL);
        }
        pPrevSibling->pSiblingEntry = pEntry->pSiblingEntry;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_NAME_PAGE
//
//  Synopsis:   initializes the name page
//
//  Arguments:  [pNamePage] -- the NAME_PAGE to be initialized
//
//  SideEffects: the name page is initialized
//
//  History:    04-18-94  SethuR Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//----------------------------------------------------------------------------

void inline INITIALIZE_NAME_PAGE(PNAME_PAGE pNamePage)
{
    pNamePage->pNextPage = NULL;
    pNamePage->cFreeSpace = FREESPACE_IN_NAME_PAGE - 1;
    pNamePage->Names[FREESPACE_IN_NAME_PAGE - 1] = _TEXT('\0');
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_DOMAIN_NAME_TABLE_ENTRY
//
//  Synopsis:   initializes the prefix table entry
//
//  Arguments:  [pEntry] -- the entry to be initialized
//
//  SideEffects: the prefix table entry is modified
//
//  History:    04-18-94  SethuR Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//----------------------------------------------------------------------------

void inline INITIALIZE_DOMAIN_NAME_TABLE_ENTRY(PDOMAIN_NAME_TABLE_ENTRY pEntry)
{
    ZeroMemory( pEntry, sizeof( DOMAIN_NAME_TABLE_ENTRY ) );
    pEntry->NoOfChildren = 1;
    pEntry->dwEntrySig = ENTRY_SIG;
    pEntry->dwWildCardSig = WILDCARD_SIG;
}

//---[ GET_DOMAIN_NAME_TABLE_ENTRY_PATH ]--------------------------------------
//
//
//  Description:
//      Walks up the list of parent entries and re-generates the full path
//      From the partial path information stored at each entry.
//
//      This is not very quick, and is intended for debugging purposes only
//  Parameters:
//      IN  pEntry   Entry to get info for
//      OUT pPath    Already allocated string to hold Path info
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void inline GET_DOMAIN_NAME_TABLE_ENTRY_PATH(PDOMAIN_NAME_TABLE_ENTRY pEntry,
                                             PDOMAIN_STRING pPath)
{
    PTSTR   pPathBuffer = NULL;
    PTSTR   pPathBufferStop = NULL;
    PTSTR   pEntryBuffer = NULL;
    PTSTR   pEntryBufferStop = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pParentEntry = NULL;

    _ASSERT(pEntry);
    _ASSERT(pPath);
    _ASSERT(pPath->Buffer);

    pPathBuffer = pPath->Buffer;
    pPathBufferStop = pPathBuffer + ((pPath)->MaximumLength / sizeof(TCHAR) -1 );

    while (pEntry && pEntry->pParentEntry && pPathBuffer < pPathBufferStop)
    {
        //dump current entries portion of the string
        if (pPathBuffer != pPath->Buffer) //already made first pass -- Add delimter
        {
            *pPathBuffer++ = PATH_DELIMITER;
        }

        pEntryBuffer = pEntry->PathSegment.Buffer;
        pEntryBufferStop = pEntryBuffer;
        pEntryBuffer += (pEntry->PathSegment.Length / sizeof(TCHAR) -1 );

        while (pPathBuffer < pPathBufferStop && pEntryBuffer >= pEntryBufferStop)
        {
            *pPathBuffer++ = *pEntryBuffer--;
        }
        pEntry = pEntry->pParentEntry;
    }

    _ASSERT(pEntry);
    *pPathBuffer = '\0';
}

//+---------------------------------------------------------------------------
//
//  Function:   ALLOCATION ROUTINES
//
//  Synopsis:   Allocation routines for Domain Name Table
//
//  History:    04-18-94  SethuR Created
//              02-98     MikeSwa Modified for use in Domain Name Table
//
//----------------------------------------------------------------------------

#define PREFIX_TABLE_ENTRY_SEGMENT_SIZE PAGE_SIZE


extern
PTSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pPageList,ULONG cLength);

PTSTR inline ALLOCATE_NAME_PAGE_ENTRY(NAME_PAGE_LIST &PageList, ULONG cLength)                           \
{
    return
    (
     ((PageList).pFirstPage->cFreeSpace -= (cLength)) >= 0
     ?
       &(PageList).pFirstPage->Names[(PageList).pFirstPage->cFreeSpace]
     :
       (
        (PageList).pFirstPage->cFreeSpace += (cLength)
        ,
        _AllocateNamePageEntry(&(PageList),(cLength))
       )
    );
}


PNAME_PAGE inline ALLOCATE_NAME_PAGE(void)
{
    return (PNAME_PAGE)pvMalloc(sizeof(NAME_PAGE));
}

void inline FREE_NAME_PAGE(PNAME_PAGE pPage)
{
    FreePv(pPage);
}

PDOMAIN_NAME_TABLE_ENTRY inline ALLOCATE_DOMAIN_NAME_TABLE_ENTRY(PDOMAIN_NAME_TABLE pTable)
{
    return (PDOMAIN_NAME_TABLE_ENTRY)pvMalloc(sizeof(DOMAIN_NAME_TABLE_ENTRY));
}

void inline FREE_DOMAIN_NAME_TABLE_ENTRY(PDOMAIN_NAME_TABLE_ENTRY pEntry)
{
    _ASSERT(pEntry);
    FreePv(pEntry);
}

void inline  FREE_DOMAIN_STRING(PDOMAIN_STRING pDomainString)
{
    if (pDomainString)
    {
        if (pDomainString->Buffer)
            FreePv(pDomainString->Buffer);
        FreePv(pDomainString);
    }
}

#endif // ___DOMHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\evntwrap\src\evntwrap.cpp ===
/*
 * An event log wrapper to simplify event logging for DLLs and to add
 * a few extra features.
 */

#include <windows.h>
#include <stdio.h>
#include "dbgtrace.h"
#include "stierr.h"
#include "crchash.h"
#include "evntwrap.h"
#include "rwex.h"

static CExShareLock g_lockHash;

#define STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX \
    "System\\CurrentControlSet\\Services\\EventLog\\System\\"
#define STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX \
    "System\\CurrentControlSet\\Services\\EventLog\\Application\\"

#define MAX_STAX_EVENT_SOURCE_PATH_PREFIX \
    ((sizeof(STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX) > \
      sizeof(STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX)) ? \
      sizeof(STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX) : \
      sizeof(STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX)) 


//
// Register your event source in the registry.
//
// Parameters:
//   szEventSource - the name of the eventsource
//   szMessageFile - the full path to the DLL which contains the
//                   eventlog strings
//
HRESULT CEventLogWrapper::AddEventSourceToRegistry(char *szEventSource,
                                                   char *szEventMessageFile,
                                                   BOOL fApplication) 
{
    HRESULT hr = S_OK;
    DWORD ec;
    HKEY hkEventSource = NULL;
    char szRegPath[1024] = STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX;
    DWORD dwDisposition;
    DWORD dwTypesSupported = 0x7;

    if (fApplication) {
        strcpy(szRegPath, 
            STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX);
    }

    strncat(szRegPath, szEventSource, 
        sizeof(szRegPath) - MAX_STAX_EVENT_SOURCE_PATH_PREFIX);

    //
    // open the path in the registry
    //
    ec = RegCreateKey(HKEY_LOCAL_MACHINE, 
                      szRegPath, 
                      &hkEventSource);
    if (ec != ERROR_SUCCESS) goto bail;

    // 
    // set the necessary keys
    //
    ec = RegSetValueEx(hkEventSource,
                       "EventMessageFile",
                       0,
                       REG_SZ,
                       (const BYTE *) szEventMessageFile,
                       strlen(szEventMessageFile));
    if (ec != ERROR_SUCCESS) goto bail;

    ec = RegSetValueEx(hkEventSource,
                       "TypesSupported",
                       0,
                       REG_DWORD,
                       (const BYTE *) &dwTypesSupported,
                       sizeof(DWORD));
    if (ec != ERROR_SUCCESS) goto bail;

bail:
    if (ec != ERROR_SUCCESS && hr == S_OK) hr = HRESULT_FROM_WIN32(ec);

    if (hkEventSource) {
        RegCloseKey(hkEventSource);
        hkEventSource = NULL;
    }

    return hr;
}

//
// Unregister your event source in the registry.
//
// Parameters:
//   szEventSource - the name of the eventsource
//
HRESULT CEventLogWrapper::RemoveEventSourceFromRegistry(char *szEventSource,
                                                        BOOL fApplication) 
{
    HRESULT hr = S_OK;
    DWORD ec;
    char szRegPath[1024] = STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX;

    if (fApplication) {
        strcpy(szRegPath, 
               STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX);
    }

    strncat(szRegPath, szEventSource,
        sizeof(szRegPath) - MAX_STAX_EVENT_SOURCE_PATH_PREFIX);

    // delete the key and its values
    ec = RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath);
    if (ec != ERROR_SUCCESS) hr = HRESULT_FROM_WIN32(ec);

    return hr;
}

DWORD ComputeHash(CEventLogHashKey  *pHashKey) {
    DWORD iHash;
    iHash = CRCHash((BYTE*)pHashKey->m_szKey, strlen(pHashKey->m_szKey) + 1);
    iHash *= pHashKey->m_idMessage;
    return iHash;
}

//
// Initialize the event logging library.
//
// Parameters:
//   szEventSource - the name of the eventsource
//
HRESULT CEventLogWrapper::Initialize(char *szEventSource) {
    HRESULT hr = S_OK;
    BOOL f;

    crcinit();

    f = m_hash.Init(&CEventLogHashItem::m_pNext,
                    100,
                    100,
                    ComputeHash,
                    2,
                    &CEventLogHashItem::GetKey,
                    &CEventLogHashItem::MatchKey);

    if (f) {
        m_hEventLog = RegisterEventSource(NULL, szEventSource);
        if (m_hEventLog == NULL) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    return hr;
}

//
// Write an event to the event log
//
// Parameters:
//   idMessage - the eventlog ID
//   cSubstrings - count of strings in rgszSubstrings
//   rgszSubstrings - substrings for the eventlog text
//   wType - eventlog error type.  Should be EVENTLOG_WARNING_TYPE,
//     EVENTLOG_INFORMATIONAL_TYPE or EVENTLOG_ERROR_TYPE.
//   errCode - Win32 error code to log (or 0)
//   iDebugLevel - debug level of the event.  1 = highest priority,
//     2^16 = lowest priority.  normally anything above 2^15 isn't
//     logged.
//   szKey - a key which is used along with idMessage to uniquely
//     identify this eventlog.  It is used to control the options.
//   dwOptions - options for logging this event.
// Optional Parameters:
//   iMessageString - call FormatMessage on errCode and save
//     the string into rgszSubstrings[iMessageString].
//   HMODULE hModule - module with extra error codes for
//     FormatMessage.
//
// Returns:
//   S_OK - event logged
//   S_FALSE - event not logged
//   E_* - error occured
//
HRESULT CEventLogWrapper::LogEvent(DWORD idMessage,
                                   WORD cSubstrings,
                                   LPCSTR *rgszSubstrings,
                                   WORD wEventType,
                                   DWORD errCode,
                                   WORD iDebugLevel,
                                   LPCSTR szKey,
                                   DWORD dwOptions,
                                   DWORD iMessageString,
                                   HMODULE hModule)
{
    HRESULT hr = S_OK;
    void *pRawData = NULL;
    DWORD cbRawData = 0;
    char szError[MAX_PATH] = "";
    char szEmptyKey[MAX_PATH] = "";

    if (m_hEventLog == NULL) {
        return E_UNEXPECTED;
    }

    //
    // Also include errCode in raw data form
    // where people can view it from EventViewer
    // 
    if (errCode != 0) {
        cbRawData = sizeof(errCode);
        pRawData = &errCode;
    }

    if (NULL == szKey) {
        szKey = szEmptyKey;
    }

    CEventLogHashItem *pHashItem = NULL;
    DWORD dwLogMode = dwOptions & LOGEVENT_FLAG_MODEMASK;

    //
    // call FormatMessage and get an error string if that is what one
    // of the substrings should be
    //
    if (iMessageString != 0xffffffff) {
        // if its a win32 HRESULT then un-hresult it
        if ((errCode & 0x0fff0000) == (FACILITY_WIN32 << 16)) {
            errCode = errCode & 0xffff;
        }

        // rgszSubstrings should already have a slot saved for the message
        _ASSERT(iMessageString < cSubstrings);
        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS |
                       ((hModule) ? FORMAT_MESSAGE_FROM_HMODULE : 0),
                       hModule,
                       errCode,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       szError,
                       sizeof(szError),
                       NULL);
		DWORD err = GetLastError();
        rgszSubstrings[iMessageString] = szError;
    }


    //
    // if this event is setup for onetime or perodic logging then check
    // with the hash table to see if this event has been logged before
    // and when it was last logged
    // if Key is NULL, it implies that it doesn't care about option
    //
    if ( (dwLogMode != LOGEVENT_FLAG_ALWAYS) && (szKey) ) {
        CEventLogHashKey hashkey;
        hashkey.m_szKey = (char *) szKey;
        hashkey.m_idMessage = idMessage;

        // search for this item
        g_lockHash.ShareLock();
        pHashItem = m_hash.SearchKey(&hashkey);

        if (pHashItem != NULL) {
            // if it was found then check to see if we should allow logging
            if ((dwLogMode == LOGEVENT_FLAG_ONETIME) ||
                (dwLogMode == LOGEVENT_FLAG_PERIODIC && 
                 !(pHashItem->PeriodicLogOkay())))
            {
                // this event has been logged before, so do nothing
                g_lockHash.ShareUnlock();
                return S_FALSE;
            }
        }
        g_lockHash.ShareUnlock();
    }

    //
    // log the event
    //
    if (!ReportEvent(m_hEventLog,
                     wEventType,
                     0,
                     idMessage,
                     NULL,
                     cSubstrings,
                     cbRawData,
                     rgszSubstrings,
                     pRawData))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // for any logging mode besides ALWAYS we need to update the hash
    // table.  we don't insert events which are always logged into the
    // hash table. Again, it the key is NULL, we do nothing about it
    //
    if ( SUCCEEDED(hr) && (dwLogMode != LOGEVENT_FLAG_ALWAYS) && (szKey) ) {
        g_lockHash.ExclusiveLock();
        if (pHashItem) {
            pHashItem->UpdateLogTime();
        } else {
            pHashItem = new CEventLogHashItem();
            if (pHashItem) {
                hr = pHashItem->InitializeKey(szKey, idMessage);
                if (SUCCEEDED(hr)) {
                    if (!m_hash.InsertData(*pHashItem)) {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (FAILED(hr)) {
                    delete pHashItem;
                    pHashItem = NULL;
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
        g_lockHash.ExclusiveUnlock();
    }

    return hr;
}

//
// Reset any history about events using this message and key,
// so that the next LogEvent with one-time or periodic logging
// will cause the event to be logged.
//
// Parameters:
//   idMessage - the eventlog ID
//   szKey - a key which is used along with idMessage to uniquely
//     identify this eventlog.
//
HRESULT CEventLogWrapper::ResetEvent(DWORD idMessage, LPCSTR szKey) {
    HRESULT hr = S_OK;
    CEventLogHashKey hashkey;

    if (m_hEventLog == NULL) {
        return E_UNEXPECTED;
    }

    hashkey.m_szKey = (char *) szKey;
    hashkey.m_idMessage = idMessage;

    g_lockHash.ExclusiveLock();
    if (!m_hash.Delete(&hashkey)) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    g_lockHash.ExclusiveUnlock();

    return hr;
}

CEventLogWrapper::~CEventLogWrapper() {
    if (m_hEventLog) {
        DeregisterEventSource(m_hEventLog);
        m_hEventLog = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\evntwrap\utest\ewtest.cpp ===
#include <windows.h>
#include <evntwrap.h>
#include <stdio.h>

DWORD WINAPI ResetEventThread(LPVOID pvEventLogWrapper) {
    CEventLogWrapper *pEventLogWrapper = (CEventLogWrapper *) pvEventLogWrapper;
    DWORD i;
    HRESULT hr;
    for (i = 0; i < 100000; i++) {
        hr = pEventLogWrapper->ResetEvent(400, "test");
    }

    return 0;
}

DWORD WINAPI LogEventThread(LPVOID pvEventLogWrapper) {
    CEventLogWrapper *pEventLogWrapper = (CEventLogWrapper *) pvEventLogWrapper;
    DWORD i;
    HRESULT hr;
    for (i = 0; i < 100000; i++) {
        char sz1[] = "hello";
        char sz2[] = "goodbye";
        char *rgsz[2] = { sz1, sz2 };

        hr = pEventLogWrapper->LogEvent(400,
                                        2,
                                        (const char **) rgsz,
                                        EVENTLOG_WARNING_TYPE,
                                        10,
                                        LOGEVENT_DEBUGLEVEL_HIGH,
                                        "test",
                                        LOGEVENT_FLAG_ONETIME);
    }

    return 0;
}

int __cdecl main(int argc, char **argv) {
    CEventLogWrapper eventwrapper;
    HRESULT hr;

    hr = CEventLogWrapper::AddEventSourceToRegistry("alextest", "c:\\winnt\\system32\\inetsrv\\smtpsvc.dll");
    if (FAILED(hr)) {
        printf("AddEventSource(\"alextest\") returned 0x%x\n", hr);
        return hr;
    }

    hr = eventwrapper.Initialize("alextest");
    if (FAILED(hr)) {
        printf("Initialize(\"smtpsvc\") returned 0x%x\n", hr);
        return hr;
    }

    for (int i = 0; i < 5; i++) {
        char sz1[] = "hello";
        char sz2[] = "goodbye";
        char *rgsz[2] = { sz1, sz2 };
        hr = eventwrapper.LogEvent(400,
                                   2,
                                   (const char **) rgsz,
                                   EVENTLOG_WARNING_TYPE,
                                   10,
                                   LOGEVENT_DEBUGLEVEL_HIGH,
                                   "test",
                                   LOGEVENT_FLAG_PERIODIC);
        printf("LogEvent(400) returned 0x%x\n", hr);

        if (i == 1) {
            eventwrapper.ResetEvent(400, "test");
        }

        if (i == 3) {
            //Sleep(2000);
        }
    }

    printf("doing multithreaded test\n");
    DWORD dwid;
    HANDLE rghThreads[20];
    for (i = 0; i < 10; i++) {
        rghThreads[i] = CreateThread(NULL, 0, LogEventThread, &eventwrapper, 0, &dwid);
    }
    for (i = 0; i < 10; i++) {
        rghThreads[i+10] = CreateThread(NULL, 0, ResetEventThread, &eventwrapper, 0, &dwid);
    }

    WaitForMultipleObjects(20, rghThreads, TRUE, INFINITE);

    hr = CEventLogWrapper::RemoveEventSourceFromRegistry("alextest");
    if (FAILED(hr)) {
        printf("RemoveEventSource(\"alextest\") returned 0x%x\n", hr);
        return hr;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\export\makefile.inc ===
copyfiles:
!if "$(_NTTREE)" != ""
	xcopy /verifd ..\$(O)\*.* $(_NTTREE)\staxpt\export\lib
!endif

!if "$(_NTTREE_NO_SPLIT)" != ""
	xcopy /verifd ..\$(O)\*.* $(_NTTREE_NO_SPLIT)\staxpt\export\lib
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\sdcache.h ===
/*++

	SDCACHE.H

	This file defines the interface to the Security 


--*/

#ifndef	_SDCACHE_H_
#define	_SDCACHE_H_

typedef
BOOL
(WINAPI	*CACHE_ACCESS_CHECK)(	IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
								IN	HANDLE					hClientToken,
								IN	DWORD					dwDesiredAccess, 
								IN	PGENERIC_MAPPING		GenericMapping, 
								IN	PRIVILEGE_SET*			PrivilegeSet, 
								IN	LPDWORD					PrivilegeSetLength,
								IN	LPDWORD					GrantedAccess, 
								IN	LPBOOL					AccessStatus
								) ;





//
//	Define the key for the hash tables we will be using !
//
class	CSDKey	{
private : 
	//
	//	pointer to the GENERIC_MAPPING portion of the key
	//
	PGENERIC_MAPPING		m_pMapping ;
	//
	//	pointer to the security descriptor portion of the key.
	//
	PSECURITY_DESCRIPTOR	m_pSecDesc ;
	//
	//	No use of default constructor allowed !
	//
	CSDKey() ;
	//
	//	CSDObject is allowed access to our inner members !
	//
	friend	class	CSDObject ;

public : 

	//
	//	the length of the security descriptor !
	//	this is publicly available, but should be read only !
	//
	int						m_cbSecDesc ;

	//
	//	Can only construct a key if these are provided 
	//
	inline
	CSDKey(	PGENERIC_MAPPING	pg, 
			PSECURITY_DESCRIPTOR	pSecDesc
			) : 
		m_pMapping( pg ), 
		m_pSecDesc( pSecDesc ), 
		m_cbSecDesc( GetSecurityDescriptorLength( pSecDesc ) )	{
		_ASSERT(IsValid()) ;
	}

	//
	//	Check that we're correctly initialized !
	//
	BOOL
	IsValid() ;

	//
	//	compare two keys for equality !
	//
	static
	int	
	MatchKey(	CSDKey left, CSDKey	right ) ;

	//
	//	compute the hash function of this key !
	//
	static	
	DWORD
	HashKey(	CSDKey	Key ) ;
} ;


class	CSDObjectContainer	; 

//
//	This is a variable length object that is placed within the buckets
//	of a hash table.  Each object contains a Security Descriptor, and 
//	the GENERIC_MAPPING relevant to evaluating that Security Descriptor.
//
class	CSDObject	{
private : 

	enum	CONSTANTS	{
		SIGNATURE = 'ODSC', 
		DEAD_SIGNATURE	= 'ODSX'
	} ;

	//
	//	help us recognize this thing in the debugger.
	//
	DWORD			m_dwSignature ;

	//
	//	The refcount for this item.
	//
	volatile	long	m_cRefCount ;

	//
	//	The item we use to chain this into a hash bucket.
	//
	DLIST_ENTRY		m_list ;

	//
	//	Store our Hash Value so that we have easy access to it !
	//
	DWORD			m_dwHash ;

	//
	//	Back pointer to the CSDContainer holding our locks !
	//
	CSDObjectContainer*	m_pContainer ;

	//
	//	The GENERIC_MAPPING structure the client provided and associated
	//	with the use of this security descriptor.
	//
	GENERIC_MAPPING	m_mapping ;

	//
	//	This is a variable length field containing the 
	//	Security descriptor we're holding.
	//
	DWORD			m_rgdwSD[1] ;

	//
	//	Return the security descriptor we're holding within ourselves.
	//
	inline	
	PSECURITY_DESCRIPTOR
	SecurityDescriptor()	{
		return	(PSECURITY_DESCRIPTOR)&(m_rgdwSD[0]) ;
	}

	//
	//	Return the length of the internally held security descriptor.
	//
	inline	
	DWORD
	SecurityDescriptorLength()	{
		return	GetSecurityDescriptorLength(SecurityDescriptor()) ;
	}

	//
	//	Not available to external clients !
	//
	CSDObject() ; 

public : 

    typedef		DLIST_ENTRY*	(*PFNDLIST)( class	CSDObject*  ) ; 

	//
	//	Construct a security descriptor object for the cache !
	//
	inline
	CSDObject(	DWORD			dwHash,
				CSDKey&			key, 
				CSDObjectContainer*	p
				) : 
		m_dwSignature( SIGNATURE ), 
		m_cRefCount( 2 ), 
		m_dwHash( dwHash ), 
		m_pContainer( p ),
		m_mapping( *key.m_pMapping )	{
		CopyMemory( m_rgdwSD, key.m_pSecDesc, GetSecurityDescriptorLength(key.m_pSecDesc) ) ;
	}

	//
	//	Our trivial destructor just makes it easy to recognize
	//	released objects in the debugger .
	//
	~CSDObject( )	{
		m_dwSignature = DEAD_SIGNATURE ;
	}

	//
	//	Need a special operator new to get our variable size part correct !
	//
	void*
	operator	new(	size_t	size, CSDKey&	key ) ;

	//
	//	Handle the release correctly !
	//	
	void
	operator	delete( void* ) ;


	//
	//	We don't allow just anybody to Add References to us !
	//
	inline
	long
	AddRef()	{
		return	InterlockedIncrement((long*)&m_cRefCount) ;
	}

	//
	//	Anybody is allowed to remove a reference from us !
	//
	long
	Release() ;


	//
	//	Check that we are a valid object !
	//
	BOOL
	IsValid() ;

	//
	//	Determine whether the client has access or not !
	//
	BOOL
	AccessCheck(	HANDLE	hToken, 
					ACCESS_MASK	accessMask,
					CACHE_ACCESS_CHECK	pfnAccessCheck
					) ;	

	//---------------------------
	//	
	//	Hash table support functions - 
	//	the following set of functions support the use of these objects
	//	in the standard hash tables defined in fdlhash.h
	//

	//
	//	Get the offset to the doubly linked list within the object.
	//
	inline	static
	DLIST_ENTRY*
	HashDLIST(	CSDObject*	p ) {
		return	&p->m_list ;
	}

	//
	//	Get the hash value out of the object !
	//
	inline	static	DWORD
	ReHash(	CSDObject*	p )		{
		_ASSERT(	p->IsValid() ) ;
		return	p->m_dwHash ;
	}

	//
	//	return our key to the caller !
	//
	inline	CSDKey
	GetKey()	{
		_ASSERT( IsValid() ) ;
		return	CSDKey( &m_mapping, SecurityDescriptor() ) ;
	}
} ;


//
//	This defines a hash table containing security descriptors !
//
typedef	TFDLHash<	class	CSDObject, 
					class	CSDKey, 
					&CSDObject::HashDLIST >	SDTABLE ;

//
//	This object provides the locking and hash table for a specified set
//	of security descriptors !
//
class	CSDObjectContainer	{
private : 

	enum	CONSTANTS	{
		SIGNATURE = 'CDSC', 
		DEAD_SIGNATURE	= 'CDSX', 
		INITIAL_BUCKETS = 32, 
		INCREMENT_BUCKETS = 16, 
		LOAD = 8
	} ;

	//
	//	The signature of the Security Descriptor Container !
	//
	DWORD	m_dwSignature ;

	//
	//	The lock that protects this hash table !
	//
	CShareLockNH	m_lock ;

	//
	//	A hash table instance !
	//
	SDTABLE			m_table ;

	//
	//	our friends include CSDObject which needs to unlike 
	//	out of our hash table upon destruction.
	//
	friend	class	CSDObject ;

public : 

	//
	//	construct one of these guys !
	//
	CSDObjectContainer() : 
		m_dwSignature( SIGNATURE )	{
	}

	//
	//	Our trivial destructor just makes it easy to recognize
	//	released objects in the debugger .
	//
	~CSDObjectContainer()	{
		m_dwSignature = DEAD_SIGNATURE ;
		
	}

	//
	//	Initialize this particular table
	//
	inline
	BOOL
	Init()	{
		return
			m_table.Init(	INITIAL_BUCKETS, 
							INCREMENT_BUCKETS, 
							LOAD, 
							CSDKey::HashKey, 
							CSDObject::GetKey, 
							CSDKey::MatchKey, 
							CSDObject::ReHash
							) ;
	}

	//
	//	Now - find or create a given security descriptor 
	//	item !
	//
	CSDObject*
	FindOrCreate(	DWORD	dwHash, 
					CSDKey&	key 
					) ;

} ;

typedef	CRefPtr2<CSDObject>			PTRCSDOBJ ;
typedef	CHasRef<CSDObject,FALSE>	HCSDOBJ ;

//
//	This class provides our external interface for caching security descriptors.
//
class	CSDMultiContainer	{
private : 

	enum	CONSTANTS	{
		SIGNATURE = 'ODSC', 
		DEAD_SIGNATURE	= 'ODSX',
		CONTAINERS=37			// pick a nice prime number !
	} ;

	//
	//	our signature !
	//
	DWORD		m_dwSignature ;
	//
	//	a bunch of child containers !
	//
	CSDObjectContainer	m_rgContainer[CONTAINERS] ;
public : 

	inline
	CSDMultiContainer() : 
		m_dwSignature( SIGNATURE )	{
	}

	inline
	HCSDOBJ
	FindOrCreate(	PGENERIC_MAPPING		pMapping, 
					PSECURITY_DESCRIPTOR	pSecDesc
					)	{

		CSDKey	key( pMapping, pSecDesc ) ;
		DWORD	dwHash = CSDKey::HashKey( key ) ;
		DWORD	i = dwHash % CONTAINERS ;

		return	m_rgContainer[i].FindOrCreate(	dwHash, key ) ;
	}

	BOOL
	Init() ;

} ;

#endif	_SDCACHE_H_	// end of the security descriptor cache !
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\testdll.h ===
/*++

	TestDll.h

	This file defines the interface to our test DLL !

--*/

#ifndef	_TESTDLL_H_
#define	_TESTDLL_H_

#ifdef	__cplusplus
extern	"C"	{
#endif

#ifdef	_TESTDLL_IMP_
#define	TESTDLL_EXPORT	__declspec( dllexport ) 
#else
#define	TESTDLL_EXPORT	__declspec( dllimport ) 
#endif	// _TESTDLL_IMP_

//
//	Start running the test !
//
TESTDLL_EXPORT
BOOL
StartTest(	DWORD	cPerSecondFiles,	// Number of files to to create per second
			DWORD	cPerSecondFind,		// Number of files to search the cache for per second 
			DWORD	cParallelFinds,		// Number of finds to do in parallel !
			char*	szDir				// Directory to do test in !
			) ;

//
//	Block the calling thread untill all work is done !
//
TESTDLL_EXPORT
void
StopTest() ;

#ifdef	__cplusplus
}
#endif


#endif	// _TESTDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\dotstuff.h ===
/*++

	dotstuff.h

	This header files defines some of the Dot Stuffing helper objects that 
	we have built for the File Handle Cache.

--*/

#include	"refptr2.h"


class	IDotManipBase : public	CRefCount2	{
protected : 
	//
	//	Return the number of bytes in the buffer that should pass
	//	through the IO operation !
	//
	virtual
	BOOL
	InternalProcessBuffer(	
				BYTE*	lpb,			// The users original buffer
				DWORD	cbIn,			// Number of bytes to look at in orignal buffer
				DWORD	cbAvailable,	// Number of bytes available in the original buffer
				DWORD	&cbRemains,		// Number of bytes we left in the original Buffer - can be zero
				BYTE*	&lpbOut,		// An output buffer that holds a portion of the string !
				DWORD	&cbOut,			// The amount of stuff in our output buffer
				int		&cBias			// Whether we should offset associated IO's to overwrite
										// previous results !
				) = 0 ;


	//
	//	This is the number of times the string as appeared in the message - 
	//	NOTE : This can be initialized to -1 if we are examining the message
	//	to determine that it needs to be dot stuffed.  This is because
	//	the terminating CRLF.CRLF will set occurrences to 0, indicating that
	//	there is no issue.
	//
	long	m_cOccurrences ;

	//
	//	Private constructor allows us to initialize m_cOccurrences !
	//
	IDotManipBase( long	l )	: 
		m_cOccurrences( l )	{
	}

public : 
/*++

	This class defines a pure virtual API used by our Dot Manipulation 
	classes to define how they interact with other code.

--*/

	//
	//	Destruction is always virtual !
	//
	virtual	~IDotManipBase()	{}

	//
	//	Publicly exposed API !
	//
	inline	BOOL
	ProcessBuffer(	BYTE*	lpb,
					DWORD	cbIn,
					DWORD	cbAvailable,
					DWORD	&cbRemains,
					BYTE*	&lpbOut,
					DWORD	&cbOut,
					int		&cBias,
					BOOL	fFinalBuffer = FALSE, 
					BOOL	fTerminatorPresent = FALSE
					)	{
		//
		//	Validate the callers arguments as much as possible !
		//
		_ASSERT( lpb != 0 ) ;
		_ASSERT( cbIn != 0 ) ;
		_ASSERT( cbAvailable >= cbIn ) ;

		//
		//	Ensure that these are correctly setup !
		//
		cbRemains = 0 ;
		lpbOut = 0 ;
		cbOut = 0 ;
		cBias = 0 ;

		BOOL	fReturn = 
			InternalProcessBuffer( 
							lpb, 
							cbIn, 
							cbAvailable,
							cbRemains,
							lpbOut,
							cbOut, 
							cBias
							) ;

		//
		//	Do some checking on the results of the call !
		//
		_ASSERT( cBias <= 0 ) ;
		_ASSERT( (lpbOut == 0 && cbOut == 0) || (lpbOut != 0 && cbOut != 0) ) ;
		_ASSERT( cbRemains <= cbAvailable ) ;
		
		return	fReturn ;
	}

	//
	//	Return the number of times we saw a pattern matching the 
	//	sequence specified when we were constructed !
	//
	long
	NumberOfOccurrences()	{
		return	m_cOccurrences ;
	}
} ;

extern	BYTE	szDot[] ;
extern	BYTE	szDotStuffed[] ;
extern	BYTE	szShrink[] ;
extern	BYTE	szGrow[] ;

class	CDotScanner	:	public	IDotManipBase		{
/*++

	This class detects messages which have Dot Stuffing issues.
	We can operate in one of two modes - determine if the message flowing by
	is dot stuffed, or determine if the message flowing by would need
	to be dot stuffed.

--*/
private : 

	enum	{
		SIGNATURE = 'futs',		// should appear as 'stuf' in the debugger !
		DEAD_SIGNATURE = 'futx'
	} ; 

	//
	//	Our signature !
	//
	DWORD	m_dwSignature ;
	
	//
	//	This is the string we are interested in detecting : 
	//
	BYTE	*m_pchMatch ;
	
	//
	//	This is our current match state !
	//
	BYTE	*m_pchState ;

	//
	//	Don't allow copies and stuff so make these private !
	//
	CDotScanner( CDotScanner& ) ;
	CDotScanner&	operator=( CDotScanner& ) ;

public : 

	CDotScanner(	BOOL	fWillGetTerminator = TRUE ) : 
		IDotManipBase(  (fWillGetTerminator ? -1 : 0) ),
		m_dwSignature( SIGNATURE ),
		m_pchMatch( szDotStuffed ),
		m_pchState( szDotStuffed )	{
		m_cRefs = 0 ;	// Hack - our base class CRefCount2 doesn't do what we want !
	}

	~CDotScanner(	)	{
		m_dwSignature = DEAD_SIGNATURE ;
	}

	//
	//	See if the user specified pattern occurs in the buffer !
	//
	BOOL
	InternalProcessBuffer(
				BYTE*	lpb,			// The users original buffer
				DWORD	cbIn,			// Number of bytes to look at in orignal buffer
				DWORD	cbAvailable,	// Number of bytes available in the original buffer
				DWORD	&cbRemains,		// Number of bytes we left in the original Buffer - can be zero
				BYTE*	&lpbOut,		// An output buffer that holds a portion of the string !
				DWORD	&cbOut,			// The amount of stuff in our output buffer
				int		&cBias			// Whether we should offset associated IO's to overwrite
										// previous results !
				) ;
} ;

class	CDotModifier	:	public	IDotManipBase	{
/*++

	This class is used to detect messages that need to be dot-stuffed
	or de-dot stuffed.  We can either remove or insert dot-stuffing as 
	required on the fly, depending on how we are constructed !

--*/
private : 
	enum	{
		SIGNATURE = 'mtod',		// should appear as 'stuf' in the debugger !
		DEAD_SIGNATURE = 'mtox'
	} ; 

	//
	//	Our signature !
	//
	DWORD	m_dwSignature ;
	
	//
	//	This is the string we are interested in detecting : 
	//
	BYTE	*m_pchMatch ;

	//
	//	This is our current match state !
	//
	BYTE	*m_pchState ;

	//
	//	This is the string we want to have replace the string we're detecting
	//
	BYTE	*m_pchReplace ;

	//
	//	Number of characters in the matching and replacement string.
	//
	int		m_cchMatch ;
	int		m_cDiff ;


	//
	//	This is the total offset we've accumulated in the stream !
	//
	long	m_cOffsetBytes ;

	//
	//	Don't allow copies and stuff so make these private !
	//
	CDotModifier( CDotModifier& ) ;
	CDotModifier&	operator=( CDotModifier& ) ;

public : 

	//
	//	Initialize our state - cannot fail !
	//
	CDotModifier(	
			BYTE*	szMatch = szDotStuffed, 
			BYTE*	szReplace = szShrink
			) :
		IDotManipBase( 0 ),
		m_dwSignature( SIGNATURE ), 
		m_pchMatch( szMatch ),
		m_pchState( szMatch ),
		m_pchReplace( szReplace ),
		m_cchMatch( strlen( (const char*)szMatch) ), 
		m_cDiff( strlen( (const char*)szReplace) - strlen( (const char*)szMatch ) ),
		m_cOffsetBytes( 0 )	{
		m_cRefs = 0 ;	// HACK - our base class CRefCount2 doesn't do what we want !
	}

	//
	//	Just mark our Signature DWORD - handy for debugging !
	//
	~CDotModifier()	{
		m_dwSignature = DEAD_SIGNATURE ;
	}

	//
	//	Modify dot sequences as they go by !
	//
	BOOL
	InternalProcessBuffer(
				BYTE*	lpb,			// The users original buffer
				DWORD	cbIn,			// Number of bytes to look at in orignal buffer
				DWORD	cbAvailable,	// Number of bytes available in the original buffer
				DWORD	&cbRemains,		// Number of bytes we left in the original Buffer - can be zero
				BYTE*	&lpbOut,		// An output buffer that holds a portion of the string !
				DWORD	&cbOut,			// The amount of stuff in our output buffer
				int		&cBias			// Whether we should offset associated IO's to overwrite
										// previous results !
				) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\dll\namecach.cpp ===
/*++

	NAMECACH.CPP

	This file implements the Name Cache functionality that is 
	part of the file handle cache.


--*/

#pragma	warning( disable : 4786 )
#include	"fcachimp.h"

BOOL
CCacheKey::IsValid()	{
/*++

Routine Description : 

	Determine whether the CCacheKey has been correctly constructed !

Arguments : 

	None.

Return Value : 

	TRUE if correctly constructed, FALSE otherwise 

--*/

	_ASSERT(	m_lpstrName != 0 ) ;
	_ASSERT(	*m_lpstrName != '\0' ) ;
	_ASSERT(	m_pfnCompare != 0 ) ;

	return	m_lpstrName != 0 &&
			*m_lpstrName != '\0' && 
			m_pfnCompare != 0 ;
}

int
CCacheKey::MatchKey(	CCacheKey*	pKeyLeft, 
						CCacheKey*	pKeyRight
						)	{
/*++

Routine description : 

	Compare 2 CacheKey's, and return -1 if pKeyLeft < pKeyRight, 
	0 if pKeyLeft==pKeyRight and 1 if pKeyLeft > pKeyRight.

Arguments : 

	pKeyLeft, pKeyRight the two keys to order

Return Value : 

	integer with memcmp() semantics.

--*/

	_ASSERT( pKeyLeft != 0 && pKeyRight != 0 ) ;
	_ASSERT( pKeyLeft->IsValid() ) ;
	_ASSERT( pKeyRight->IsValid() ) ;

	LONG_PTR	i = lstrcmp(	pKeyLeft->m_lpstrName, pKeyRight->m_lpstrName ) ;
	if( i==0 ) {
		i = (LONG_PTR)(pKeyLeft->m_pfnCompare) - (LONG_PTR)(pKeyRight->m_pfnCompare) ;
		if( i==0 ) {
			i = (LONG_PTR)(pKeyLeft->m_pfnHash) - (LONG_PTR)(pKeyRight->m_pfnHash) ;
			if( i==0 ) {
				i = (LONG_PTR)(pKeyLeft->m_pfnKeyDestroy) - (LONG_PTR)(pKeyRight->m_pfnKeyDestroy) ;
				if( i==0 ) {
					i = (LONG_PTR)(pKeyLeft->m_pfnDataDestroy) - (LONG_PTR)(pKeyRight->m_pfnDataDestroy) ;
				}
			}
		}
	}
	return	int(i) ;
}

DWORD
CCacheKey::HashKey(	CCacheKey*	pKey )	{
/*++

Routine Description : 

	This function computes a hash function for this item - we just 
	use our standard string hash function !

Arguments : 

	pKey - The key to compute the hash function of

Return Value : 

	The Hash Value !

--*/

	_ASSERT( pKey != 0 ) ;
	_ASSERT( pKey->IsValid() ) ;

	return	CRCHash(	(LPBYTE)pKey->m_lpstrName, lstrlen(pKey->m_lpstrName) ) ;
}

//--------
//	These two globals keep track of all the Name Cache Instance's created by clients
//
//	Protect a hash table of Name Cache's 
//
CShareLockNH	g_NameLock ;
//
//	A hash table of Name Cache's 
//
NAMECACHETABLE*	g_pNameTable = 0 ;
//
//	The global table of Security Descriptors !
//
CSDMultiContainer*	g_pSDContainer = 0 ;
//-------

BOOL
InitNameCacheManager()	{

	TraceFunctEnter( "InitNameCacheManager" ) ;

	_ASSERT( g_pNameTable == 0 ) ;
	_ASSERT( g_pSDContainer == 0 ) ;

	g_pNameTable = new	NAMECACHETABLE() ;
	if( !g_pNameTable ) {
		return	FALSE ;
	}

	g_pSDContainer = new	CSDMultiContainer() ;
	if( !g_pSDContainer ) {
		delete	g_pNameTable ;
		g_pNameTable = 0 ;
		return	FALSE ;
	}

	BOOL	fSuccess = 
		g_pNameTable->Init(	8, 
							4, 
							2, 
							CCacheKey::HashKey, 
							CNameCacheInstance::GetKey, 
							CCacheKey::MatchKey
							) ;

	if( fSuccess ) {
		fSuccess = g_pSDContainer->Init() ;
	}	
	if( !fSuccess ) {
		_ASSERT( g_pNameTable != 0 ) ;
		_ASSERT( g_pSDContainer != 0 ) ;
		delete	g_pNameTable ;
		delete	g_pSDContainer ;
		g_pNameTable = 0 ;
		g_pSDContainer = 0 ;
		_ASSERT( g_pNameTable == 0 ) ;
		_ASSERT( g_pSDContainer == 0 ) ;
	}	else	{
		_ASSERT( g_pNameTable != 0 ) ;
		_ASSERT( g_pSDContainer != 0 ) ;
	}
	return	fSuccess ;
}

void
TermNameCacheManager()	{

	TraceFunctEnter( "TermNameCacheManager" ) ;

	if( g_pNameTable ) {
		delete	g_pNameTable ;
	}
	if(	g_pSDContainer )	{
		delete	g_pSDContainer ;
	}
	g_pNameTable = 0 ;
	g_pSDContainer = 0 ;
}


CNameCacheInstance::CNameCacheInstance(	CCacheKey	&key ) : 
	m_key(key), 
	m_cRefCount( 2 ), m_pDud( 0 ), m_pfnAccessCheck( 0 )
	{
/*++

Routine Description : 

	This function initializes a name cache instance - assume client starts with 
	one reference, and the containing hash table contains one reference.

Arguments : 

	None.

Return Value : 

	None.

--*/
	m_dwSignature = SIGNATURE ;	
}

static	char	szNull[] = "\0" ;

CNameCacheInstance::~CNameCacheInstance()	{
/*++

Routine Description : 

	Destroy everything associated with this name cache - 
	NOTE ! - embedded key does not free strings within its destructor !
	Call FreeName() to do so here !

Arguments : 

	None.

Return Value : 

	None.


--*/

	TraceFunctEnter( "CNameCacheInstance::~CNameCacheInstance" ) ;

	if( m_pDud ) {
		m_pDud->Return() ;
		m_pDud = 0 ;
		//
		//	Remove the DUD Key from the cache ASAP !
		//
		DWORD	dwHashName = m_key.m_pfnHash( (LPBYTE)szNull, sizeof( szNull ) - 1 ) ;

		CNameCacheKeySearch	keySearch(	(LPBYTE)szNull, 
										sizeof(szNull)-1, 
										dwHashName, 
										0, 
										0, 
										FALSE
										) ;

		DebugTrace( DWORD_PTR(&keySearch), "Created Search Key" ) ;

		//
		//	Now attempt to remove the key !
		//
		BOOL	fSuccess = 
			m_namecache.ExpungeKey(	&keySearch	) ;	

	}

	m_key.FreeName() ;
	m_dwSignature = DEAD_SIGNATURE ;
}

BOOL
CNameCacheInstance::IsValid()	{
/*++

Routine Description : 

	This function checks that we are in a valid state.
	
Arguments : 

	None.

Return Value : 

	TRUE if we are valid !

--*/

	_ASSERT(	m_dwSignature == SIGNATURE ) ;
	_ASSERT(	m_pDud != 0 ) ;

	return	m_dwSignature == SIGNATURE && 
			m_pDud != 0 ;
}

long
CNameCacheInstance::AddRef()	{
/*++

Routine Description : 

	Add a reference to a Name Cache Instance.

Arguments : 

	None.

Return Value : 

	The resulting ref count, should always be greater than 0 !

--*/
	_ASSERT( IsValid() ) ;
	long l = InterlockedIncrement(	(long*)&m_cRefCount ) ;
	_ASSERT( l > 0 ) ;
	return	 l ;
}

long
CNameCacheInstance::Release()	{
/*++

Routine Description : 

	This function removes a reference form a Name Cache Instance object.

	If the reference count drops to one, that means that the only reference
	remaining on the object is the one from the hash table.
	So we grab the hash table lock exclusively, so we can prevent new references
	from being added, and we then do a InterlockedCompareExchange to drop 
	the reference count to 0.  We need to do this to ensure that between
	the time we decrement the ref. count and the time we grab the lock, that 
	another user doesn't simultaneously raise and drop the ref. count.
	This prevents double frees.

Arguments : 

	None.

Return Value : 

	the final ref count - 0 if the object is destroyed !

--*/
	TraceFunctEnter( "CNameCacheInstance::Release" ) ;

	DebugTrace( DWORD_PTR(this), "Dropping reference to Name Cache" ) ;

	CNameCacheInstance*	pdelete = 0 ;
	long	l = InterlockedDecrement( (long*)&m_cRefCount ) ;
	if( l==1 ) {
		g_NameLock.ExclusiveLock( ) ;
		if( InterlockedCompareExchange( (long*)&m_cRefCount, 0, 1 ) == 1 ) {
			g_pNameTable->Delete( this ) ;
			pdelete = this ;
		}
		g_NameLock.ExclusiveUnlock() ;
	}
	if( pdelete ) {
		l = 0 ;
		delete	pdelete ;
	}
	return	l ;
}

BOOL
CNameCacheInstance::fInit()	{
/*++

Routine Description : 

	This function initializes the name cache.

Arguments : 

	None.

Return Value : 

	None.

--*/

	TraceFunctEnter( "CNameCacheInstance::fInit" ) ;

	BOOL	fInit = 
	m_namecache.Init(	CNameCacheKey::NameCacheHash,
						CNameCacheKey::MatchKey,
						g_dwLifetime, // One hour expiration !
						g_cMaxHandles,  // large number of handles !
						g_cSubCaches,	// Should be plenty of parallelism
						0		 // No statistics for now !
						) ;

	if( fInit ) {
		m_pDud = new CFileCacheObject( FALSE, FALSE ) ;
		if (!m_pDud) {
		    fInit = FALSE;
		    _ASSERT(fInit);         // Out of memory
		}
	}

	if( fInit ) {
		PTRCSDOBJ	ptrcsd ;
		DWORD	dwHash = m_key.m_pfnHash( (LPBYTE)szNull, sizeof(szNull)-1 ) ;

		//
		//	Insert the dud element with an artificial name into the name cache !
		//
		CNameCacheKeyInsert	keyDud(	(LPBYTE)szNull, 
									sizeof(szNull)-1,
									0, 
									0,  
									dwHash,
									&m_key, 
									ptrcsd, 
									fInit 
									) ;
		_ASSERT( fInit ) ;

		fInit = 
		m_namecache.Insert(	dwHash, 
							keyDud, 		
							m_pDud,
							1
							) ;

		if( !fInit ) {
			delete	m_pDud ;
			m_pDud = 0 ;
		}
	}

	DebugTrace( DWORD_PTR(this), "Initialized Name Cache - %x", fInit ) ;
	return	fInit ;
}
	

FILEHC_EXPORT
PNAME_CACHE_CONTEXT	
FindOrCreateNameCache(
		//
		//	Must not be NULL ! - this is CASE SENSITVE !
		//
		LPSTR	lpstrName, 
		//
		//	Must not be NULL !
		//
		CACHE_KEY_COMPARE		pfnKeyCompare, 
		//
		//	This may be NULL, in which case the cache will provide one !
		//
		CACHE_KEY_HASH			pfnKeyHash, 
		//
		//	The following two function pointers may be NULL !
		//
		CACHE_DESTROY_CALLBACK	pfnKeyDestroy, 
		CACHE_DESTROY_CALLBACK	pfnDataDestroy
		)	{
/*++

Routine Description : 

	This function finds an existing Name Cache or creates a new one.
	If we find an existing Name Cache we add a reference to it.

	NOTE : 

	References MUST be ADDED only when the lock is held.
	This must be done so that synchronization with CNameCacheInstance::Release()
	is done correctly !

Arguments : 

	lpstrName - User provided Name for the name cache
	pfnKeyCompare - compares keys within the name cache
	pfnKeyDestroy - called when a key is destroyed within the name cache !
	pfnDataDestroy - called when data within the name cache is destroyed !

Return Value : 

	Context for a Name Cache.
	NULL if failed !

--*/

	TraceFunctEnter( "FindOrCreateNameCache" ) ;

	_ASSERT( lpstrName != 0 ) ;
	_ASSERT( *lpstrName != '\0' ) ;
	_ASSERT( pfnKeyCompare != 0 ) ;

	if( pfnKeyHash == 0 ) {
		pfnKeyHash = (CACHE_KEY_HASH)CRCHash ;
	}

	//
	//	Build a key and look for it in the hash table !
	//	
	CCacheKey	key(	lpstrName, 
						pfnKeyCompare, 
						pfnKeyHash,
						pfnKeyDestroy, 
						pfnDataDestroy
						) ;
	DWORD	dwHash = CCacheKey::HashKey(&key) ;
	CNameCacheInstance*	pInstance = 0 ;
	g_NameLock.ShareLock() ;
	NAMECACHETABLE::ITER	iter = g_pNameTable->SearchKeyHashIter(	dwHash, 
																	&key, 	
																	pInstance
																	) ;
	if( pInstance ) {
		//
		//	We found it - AddRef before releasing locks !
		//
		_ASSERT( pInstance->IsValid() ) ;
		pInstance->AddRef() ;
		g_NameLock.ShareUnlock() ;
	}	else	{
		//
		//	Convert to a partial lock while we construct a new item - 
		//	NOTE - we may have to search again !
		//
		if( !g_NameLock.SharedToPartial() ) {
			g_NameLock.ShareUnlock() ;
			g_NameLock.PartialLock() ;
			iter = g_pNameTable->SearchKeyHashIter(	dwHash,		
													&key, 
													pInstance
													) ;
		}
		if( pInstance != 0 ) {
			//
			//	found it - AddRef before releasing locks !
			//
			_ASSERT( pInstance->IsValid() ) ;
			pInstance->AddRef() ;
		}	else	{
			//
			//	Copy users strings for new item in the table !
			//
			LPSTR	lpstr = new	char[lstrlen(lpstrName)+1] ;
			if( lpstr ) {
				lstrcpy( lpstr, lpstrName ) ;
				CCacheKey	key2(	lpstr, 
									pfnKeyCompare,
									pfnKeyHash, 
									pfnKeyDestroy, 
									pfnDataDestroy
									) ;
				_ASSERT( CCacheKey::HashKey(&key2) == dwHash ) ;
				pInstance = new CNameCacheInstance(	key2 ) ;
				if( !pInstance ) {
					//
					//	failure clean up !
					//
					delete[]	lpstr ;
				}	else	{
					BOOL	fInsert = FALSE ;
					if( pInstance->fInit() ) {
						_ASSERT( pInstance->IsValid() ) ;
						//
						//	Everything's ready to go - insert into hash table !
						//
						g_NameLock.FirstPartialToExclusive() ;
						fInsert = 
							g_pNameTable->InsertDataHashIter(	iter, 
																dwHash, 
																&key2, 
																pInstance 
																) ;
						g_NameLock.ExclusiveUnlock() ;
					}	else	{
						g_NameLock.PartialUnlock() ;
					}

					//
					//	check if we have to clean up an error case !
					//
					if( !fInsert ) {
						pInstance->Release() ;
						pInstance = 0 ;
					}
					//
					//	return to caller now, skip PartialUnlock() which 
					//	was taken care of by the conversion to Exclusive above !
					//
					DebugTrace( DWORD_PTR(pInstance), "Returning Name Cache To Caller" ) ;

					return	pInstance ;
				}
			}
		}
		g_NameLock.PartialUnlock() ;
	}
	DebugTrace(DWORD(0), "Failed to find or create Name Cache" );
	return	pInstance ;
}


FILEHC_EXPORT
BOOL	__stdcall
SetNameCacheSecurityFunction(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache, 
		//
		//	This is the function pointer that will be used to evaluate security - 
		//	this may be NULL - if it is we will use the Win32 Access Check !
		//
		CACHE_ACCESS_CHECK		pfnAccessCheck
		)	{
/*++

Routine Description : 

	This function will set the function pointer used for evaluating Security Descriptors found in the
	name cache.

Arguments : 

	pNameCache - Pointer to the Name Cache who's properties we are to set !
	pfnAccessCheck - pointer to a function which can perform the AccessCheck() call !

Return Value : 

	TRUE if successfull !

--*/

	TraceFunctEnter( "SetNameCacheSecurityFunction" ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;
	if( !pInstance ) 
		return	FALSE ;

	pInstance->m_pfnAccessCheck = pfnAccessCheck ;
	return	TRUE ;	
}


//
//	API's for releasing the NAME CACHE !
//
//	The caller must guarantee the thread safety of this call - This function must not 
//	be called if any other thread is simultanesouly executing within 
//	CacheFindContectFromName(), AssociateContextWithName(), AssociateDataWithName(), or InvalidateName() 
//
FILEHC_EXPORT
long	__stdcall
ReleaseNameCache(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache
		)	{
/*++

Routine Description : 

	This function releases the NameCache Object associated with the 
	client's PNAME_CACHE_CONTEXT !

Arguments : 

	pNameCache - A context previously provided to the client through
		FindOrCreateNameCache !

Return Value : 

	Resulting Reference Count - 0 means the NAME CACHE has been destroyed !

--*/

	TraceFunctEnter( "ReleaseNameCache" ) ;

	_ASSERT( pNameCache != 0 ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;
	
	_ASSERT( pInstance->IsValid() ) ;
	return	pInstance->Release() ;
}

//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer
//	if the user has only called AssociateDataWithName().
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					)	{
/*++

Routine Description : 

	This function attempts to find the FIO_CONTEXT for a specified name !

Arguments : 

	See Above

Return Value : 
	
	TRUE if something was found matching in the case - 
		*ppContext may still be NULL however !
	
--*/

	TraceFunctEnter( "FindContextFromName" ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;

	_ASSERT( pInstance->IsValid() ) ;

	BOOL	fFound = FALSE ;

	//	
	//	Verify other arguments !
	//
	_ASSERT( lpbName != 0 ) ;
	_ASSERT( cbName != 0 ) ;

	DWORD	dwHashName = pInstance->m_key.m_pfnHash( lpbName, cbName ) ;

	CNameCacheKeySearch	keySearch(	lpbName, 
									cbName, 
									dwHashName, 
									lpvClientContext, 
									pfnCallback, 
									hToken != NULL
									) ;

	DebugTrace( DWORD_PTR(&keySearch), "Created Search Key" ) ;

	//
	//	Now do the search !
	//
	CFileCacheObject*	p 	= 
		pInstance->m_namecache.Find(	dwHashName, 
										keySearch
										) ;	

	DebugTrace( DWORD_PTR(p), "found instance item %x, m_pDud %x", p, pInstance->m_pDud ) ;
	
	if( p ) {						
		BOOL	fAccessGranted = TRUE ;
		if( hToken != NULL )	{
			fAccessGranted = 
				keySearch.DelegateAccessCheck(	hToken, 
												accessMask, 
												pInstance->m_pfnAccessCheck
												) ;
		}
		if( fAccessGranted )	{
			keySearch.PostWork() ;
			fFound = TRUE ;
		}	else	{
			SetLastError( ERROR_ACCESS_DENIED ) ;
		}

		if( p != pInstance->m_pDud ) {
			PFIO_CONTEXT pFIO = (FIO_CONTEXT*)p->GetAsyncContext() ;
			if( pFIO == 0 ) {
				p->Return() ;
				SetLastError(	ERROR_NOT_SUPPORTED ) ;
			}
			*ppContext = pFIO ;
		}	else	{
			//
			//	Need to drop the dud reference !
			//
			p->Return() ;
		}
	}	else	{
		SetLastError(	ERROR_PATH_NOT_FOUND ) ;
	} 
	DebugTrace( DWORD_PTR(p), "Returning %x GLE %x", fFound, GetLastError() ) ;
	return	fFound ;
}



//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer
//	if the user has only called AssociateDataWithName().
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindSyncContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					)	{
/*++

Routine Description : 

	This function attempts to find the FIO_CONTEXT for a specified name !

Arguments : 

	See Above

Return Value : 
	
	TRUE if something was found matching in the case - 
		*ppContext may still be NULL however !
	
--*/

	TraceFunctEnter( "FindContextFromName" ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;

	_ASSERT( pInstance->IsValid() ) ;

	BOOL	fFound = FALSE ;

	//	
	//	Verify other arguments !
	//
	_ASSERT( lpbName != 0 ) ;
	_ASSERT( cbName != 0 ) ;

	DWORD	dwHashName = pInstance->m_key.m_pfnHash( lpbName, cbName ) ;

	CNameCacheKeySearch	keySearch(	lpbName, 
									cbName, 
									dwHashName, 
									lpvClientContext, 
									pfnCallback, 
									hToken != NULL
									) ;

	DebugTrace( DWORD_PTR(&keySearch), "Created Search Key" ) ;

	//
	//	Now do the search !
	//
	CFileCacheObject*	p 	= 
		pInstance->m_namecache.Find(	dwHashName, 
										keySearch
										) ;	

	DebugTrace( DWORD_PTR(p), "found instance item %x, m_pDud %x", p, pInstance->m_pDud ) ;
	
	if( p ) {						
		BOOL	fAccessGranted = TRUE ;
		if( hToken != NULL )	{
			fAccessGranted = 
				keySearch.DelegateAccessCheck(	hToken, 
												accessMask,
												pInstance->m_pfnAccessCheck
												) ;
		}
		if( fAccessGranted )	{
			keySearch.PostWork() ;
			fFound = TRUE ;
		}	else	{
			SetLastError( ERROR_ACCESS_DENIED ) ;
		}

		if( p != pInstance->m_pDud ) {
			PFIO_CONTEXT pFIO = (FIO_CONTEXT*)p->GetSyncContext() ;
			if( pFIO == 0 ) {
				p->Return() ;
				SetLastError(	ERROR_NOT_SUPPORTED ) ;
			}
			*ppContext = pFIO ;
		}	else	{
			//
			//	Need to drop the dud reference !
			//
			p->Return() ;
		}
	}	else	{
		SetLastError(	ERROR_PATH_NOT_FOUND ) ;
	} 
	DebugTrace( DWORD_PTR(p), "Returning %x GLE %x", fFound, GetLastError() ) ;
	return	fFound ;
}


//
//	Cache Associate context with name !
//	This insert a Name into the Name cache, that will find the specified FIO_CONTEXT !
//
FILEHC_EXPORT
BOOL	__stdcall
AssociateContextWithName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User may provide some arbitrary data to assoicate with the name !
					//	
					IN	LPBYTE	lpbData, 
					IN	DWORD	cbData, 
					//
					//	User may provide a self relative security descriptor to 
					//	be associated with the name !
					//
					IN	PGENERIC_MAPPING		pGenericMapping,
					IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
					//
					//	User provides the FIO_CONTEXT that the name should reference
					//
					FIO_CONTEXT*		pContext,
					//
					//	User specifies whether they wish to keep their reference on the FIO_CONTEXT
					//
					BOOL				fKeepReference
					)	{
/*++

Routine Description : 

	This function inserts an item into the name cache !

Arguments : 

Return Value : 

	TRUE if successfully inserted, FALSE otherwise
	if FALSE is returned the FIO_CONTEXT's reference count is unchanged, 
		no matter what fKeepReference was passed as !	


--*/

	TraceFunctEnter( "AssociateContextWithName" ) ;

	_ASSERT(	pNameCache != 0 ) ;
	_ASSERT(	lpbName != 0 ) ;
	_ASSERT(	cbName != 0 ) ;
	_ASSERT(	*lpbName != '\0' ) ;
	
	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;
	_ASSERT( pInstance->IsValid() ) ;

	CFileCacheObject*	pCache = 0 ;
	if( pContext != 0 ) {
		FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;
		_ASSERT( p->IsValid() ) ;
		_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;
		pCache = CFileCacheObject::CacheObjectFromContext( p ) ;
	}	else	{
		_ASSERT( !fKeepReference ) ;
		pCache = pInstance->m_pDud ;
		fKeepReference = TRUE ;
	}

	_ASSERT( pCache != 0 ) ;

	DebugTrace( DWORD_PTR(pSecurityDescriptor), "Doing SD Search, pCache %x pDud %x fKeep %x", 
		pCache, pInstance->m_pDud, fKeepReference ) ;

	PTRCSDOBJ	pCSD ; 
	//
	//	First, get a hold of a SD if appropriate !
	//
	if(	pSecurityDescriptor != 0 ) {
		_ASSERT(	pGenericMapping != 0 ) ;
		pCSD = g_pSDContainer->FindOrCreate(	pGenericMapping, 
												pSecurityDescriptor 
												) ;
		//
		//	Failed to hold the security descriptor - fail out to the caller !
		//
		if( pCSD == 0 ) {
			SetLastError(	ERROR_OUTOFMEMORY ) ;
			return	FALSE ;
		}	
	}

	DebugTrace( DWORD(0), "Found SD %x", pCSD ) ;

	//
	//	Now build the key and insert into the name cache !
	//
	BOOL	fSuccess = FALSE ;

	DWORD	dwHashName = pInstance->m_key.m_pfnHash( lpbName, cbName ) ;

	DebugTrace( 0, "Computed Hash Value %x", dwHashName ) ;

	CNameCacheKeyInsert	key(	lpbName, 
								cbName, 
								lpbData, 
								cbData, 
								dwHashName, 
								&pInstance->m_key, 
								pCSD, 
								fSuccess
								) ;

	if( !fSuccess ) {
		SetLastError( ERROR_OUTOFMEMORY ) ;
		return	FALSE ;
	}					

	fSuccess = 
	pInstance->m_namecache.Insert(	dwHashName, 
									key, 		
									pCache
									) ;


	DebugTrace( 0, "Insert Completed with %x", fSuccess ) ;

	if( fSuccess ) {
		if( !fKeepReference ) {
			pCache->Return() ;
		}
	}	else	{
		SetLastError(	ERROR_DUP_NAME ) ;
	}
	return	fSuccess ;
}

//
//	This function breaks the association that any names may have with the specified FIO_CONTEXT, 
//	and discards all data related to the specified names from the Name cache.
//
FILEHC_EXPORT
BOOL	
InvalidateAllNames(	FIO_CONTEXT*	pContext ) ;

//
//	This function allows the user to remove a single name and all associated data
//	from the name cache.
//
FILEHC_EXPORT
BOOL
InvalidateName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName
					)	{
/*++

Routine Description : 

	This function removes the specified name and its associations from the cache !

Arguments : 

	pNameCache - the Name cache in which this operation applies
	lpbName - the Name of the item we are to remove
	cbName - the length of the name we are to remove 

Return Value : 

	TRUE if successfully removed from the cache 
	FALSE otherwise !

--*/



	TraceFunctEnter( "InvalidateName" ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;

	_ASSERT( pInstance->IsValid() ) ;

	BOOL	fFound = FALSE ;

	//	
	//	Verify other arguments !
	//
	_ASSERT( lpbName != 0 ) ;
	_ASSERT( cbName != 0 ) ;

	DWORD	dwHashName = pInstance->m_key.m_pfnHash( lpbName, cbName ) ;

	CNameCacheKeySearch	keySearch(	lpbName, 
									cbName, 
									dwHashName, 
									0, 
									0, 
									FALSE
									) ;

	DebugTrace( DWORD_PTR(&keySearch), "Created Search Key" ) ;

	//
	//	Now attempt to remove the key !
	//
	BOOL	fSuccess = 
		pInstance->m_namecache.ExpungeKey(	&keySearch	) ;	

	return	fSuccess ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\dll\fcache.cpp ===
/*++

	FCACHE.CPP

	The file implements the file handle cache used by NNTP.

--*/

#pragma	warning( disable : 4786 )

#include	"fcachimp.h"

#if	defined(_X86_)
#define	SZATQINITIALIZE			"AtqInitialize"
#define	SZATQTERMINATE			"AtqTerminate"
#define	SZATQADDASYNCHANDLE		"_AtqAddAsyncHandle@24"
#define	SZATQCLOSEFILEHANDLE	"_AtqCloseFileHandle@4"
#define	SZATQCLOSESOCKET		"_AtqCloseSocket@8"
#define	SZATQFREECONTEXT		"_AtqFreeContext@8"
#define	SZATQREADFILE			"_AtqReadFile@16"
#define	SZATQWRITEFILE			"_AtqWriteFile@16"
#elif defined(_AMD64_) || defined(_IA64_)
#define	SZATQINITIALIZE			"AtqInitialize"
#define	SZATQTERMINATE			"AtqTerminate"
#define	SZATQADDASYNCHANDLE		"AtqAddAsyncHandle"
#define	SZATQCLOSEFILEHANDLE	"AtqCloseFileHandle"
#define	SZATQCLOSESOCKET		"_AtqCloseSocket"
#define	SZATQFREECONTEXT		"AtqFreeContext"
#define	SZATQREADFILE			"AtqReadFile"
#define	SZATQWRITEFILE			"AtqWriteFile"
#else
#error "No Target Architecture"
#endif



//
//	The DLL's we load to do this stuff !
//
HINSTANCE			g_hIsAtq = 0 ;
HINSTANCE			g_hIisRtl = 0 ;
//
//	Function pointers for all our thunks into IIS stuff !
//
PFNAtqInitialize	g_AtqInitialize = 0 ;
PFNAtqTerminate		g_AtqTerminate = 0 ;
PFNAtqAddAsyncHandle	g_AtqAddAsyncHandle = 0 ;
PFNAtqCloseFileHandle	g_AtqCloseFileHandle = 0 ;
PFNAtqFreeContext		g_AtqFreeContext = 0 ;
PFNAtqIssueAsyncIO		g_AtqReadFile = 0 ;
PFNAtqIssueAsyncIO		g_AtqWriteFile = 0 ;
PFNInitializeIISRTL		g_InitializeIISRTL = 0 ;
PFNTerminateIISRTL		g_TerminateIISRTL = 0 ;

//
//	These are the globals used by the file handle cache !
//

//
//	Keep track of how ofter we're initialized !
//
static	long	g_cIOInits = 0 ;
//
//	Keep track of how often the cache is initialized !
//
static	long	g_cCacheInits = 0 ;
//
//	Keep track of the global cache !
//
static	FILECACHE*	g_pFileCache = 0 ;
//
//	Keep track of the global Name Cache !
//
static	NAMECACHE*	g_pNameCache = 0 ;
//
//	Keep track of all the different security descriptors floating through
//	the system !
//
static	CSDMultiContainer*	g_pSDCache = 0 ;
//
//	Protect our globals - setup and destroyed in DllMain() !
//
CRITICAL_SECTION	g_critInit ;


BOOL
WriteWrapper(	IN	PATQ_CONTEXT	patqContext,
				IN	LPVOID			lpBuffer,
				IN	DWORD			cbTransfer,
				IN	LPOVERLAPPED	lpo
				)	{
/*++

Routine Description :

	Issue a Write IO against the ATQ Context.
	If we're trying to do a synchronous IO, bypass ATQ so that the ATQ
	IO Reference count doesn't get messed up !

Arguments :

	SAME as ATQWriteFile

Return Value :

	Same as ATQWriteFile !

--*/

	if( (UINT_PTR)(lpo->hEvent) & 0x1 )		{
		DWORD	cbResults ;
		BOOL	fResult =
				WriteFile(
					patqContext->hAsyncIO,
					(LPCVOID)lpBuffer,
					cbTransfer,
					&cbResults,
					(LPOVERLAPPED)lpo
					) ;
		if( fResult || GetLastError() == ERROR_IO_PENDING ) {
			return	TRUE ;
		}
		return	FALSE ;
	}	else	{
		return	g_AtqWriteFile(
					patqContext,
					(LPVOID)lpBuffer,
					cbTransfer,
					(LPOVERLAPPED)lpo
					) ;
	}
}

BOOL
ReadWrapper(	IN	PATQ_CONTEXT	patqContext,
				IN	LPVOID			lpBuffer,
				IN	DWORD			cbTransfer,
				IN	LPOVERLAPPED	lpo
				)	{
/*++

Routine Description :

	Issue a Read IO against the ATQ Context.
	If we're trying to do a synchronous IO, bypass ATQ so that the ATQ
	IO Reference count doesn't get messed up !

Arguments :

	SAME as ATQWriteFile

Return Value :

	Same as ATQWriteFile !

--*/


	if( (UINT_PTR)(lpo->hEvent) & 0x1 )		{
		DWORD	cbResults ;
		BOOL	fResult =
				ReadFile(
					patqContext->hAsyncIO,
					lpBuffer,
					cbTransfer,
					&cbResults,
					(LPOVERLAPPED)lpo
					) ;
		if( fResult || GetLastError() == ERROR_IO_PENDING ) {
			return	TRUE ;
		}
		return	FALSE ;

	}	else	{
		return	g_AtqReadFile(
					patqContext,
					(LPVOID)lpBuffer,
					cbTransfer,
					(LPOVERLAPPED)lpo
					) ;
	}
}


BOOL
DOT_STUFF_MANAGER::IssueAsyncIO(
		IN	PFNAtqIssueAsyncIO	pfnIO,
		IN	PATQ_CONTEXT	patqContext,
		IN	LPVOID			lpb,
		IN	DWORD			BytesToTransfer,
		IN	DWORD			BytesAvailable,
		IN	FH_OVERLAPPED*	lpo,
		IN	BOOL			fFinalIO,
		IN	BOOL			fTerminatorIncluded
		)	{
/*++

Routine Description :

	This function munges an IO the user has given us to
	do stuff to its dot stuffing.

Arguments :

	pfnIO - Pointer to the ATQ function which will do the IO
	patqContext - the ATQ context we're using to issue the IO
	lpb - the buffer the users data lives in !
	BytesToTransfer - the number of bytes the user wants us to transfer
	BytesAvailable - the number of bytes in the buffer we can touch if need be !
	lpo - The users overlapped structure
	fFinalIO - if TRUE this is the last IO
	fTerminatorIncluded - if TRUE the "\r\n.\r\n" is included in the message

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	static	BYTE	rgbTerminator[5] = { '\r', '\n', '.', '\r', '\n' } ;

	_ASSERT( lpo != 0 ) ;
	_ASSERT( patqContext != 0 ) ;
	_ASSERT( lpb != 0 ) ;
	_ASSERT( BytesToTransfer != 0 ) ;
	_ASSERT( lpo != 0 ) ;

	//
	//	Assume everything works !
	//
	BOOL	fResult = TRUE ;

	//
	//	Munge the OVERLAPPED structure to preserve callers original state !
	//
	lpo->Reserved1 = BytesToTransfer ;
	lpo->Reserved2 = 0 ;

	//
	//	Check to see whether we need to do anything funky to this IO !
	//
	if( m_pManipulator == 0 )	{
		//
		//	Issue the IO the way the user requested it - note if they
		//	are completing the IO directly, we want to skip ATQ so that
		//	the IO reference count doesn't become bogus !
		//
		return	pfnIO(	patqContext,
						lpb,
						BytesToTransfer,
						(LPOVERLAPPED)lpo
						) ;
	}	else	{

		//
		//	All right - wherever this IO goes, we get first crack before
		//	the callers completion function !
		//
		lpo->Reserved3 = (UINT_PTR)lpo->pfnCompletion ;
		lpo->pfnCompletion = DOT_STUFF_MANAGER::AsyncIOCompletion ;

		//
		//	Okay we need to process the buffer thats passing through,
		//	and we may need to do something to the data !
		//




		DWORD	BytesToScan = BytesToTransfer ;
		DWORD	BytesAvailableToStuff = BytesAvailable ;
		BOOL	fAppend = FALSE ;

		if( fFinalIO )	{
			if( fTerminatorIncluded )	{
				if( BytesToTransfer <= sizeof( rgbTerminator ) ) {
					//
					//	This is a bizarre case - it means that part of the terminating
					//	sequence has already gone by, and we may have already modified
					//	the terminating dot !!!
					//
					//	So, what should we do here ? Just do some math and blast out the
					//	terminating sequence as we know it should be !
					//
					int	iTermBias = - (int)(sizeof(rgbTerminator) - BytesToTransfer) ;
					//
					//	Offset the write -
					//
					lpo->Offset = DWORD(((long)lpo->Offset) + m_cbCumulativeBias + iTermBias) ;
					//
					//	Now issue the users requested IO operation !
					//
					return	pfnIO(	patqContext,
									rgbTerminator,
									sizeof( rgbTerminator ),
									(LPOVERLAPPED)lpo
									) ;
				}	else	{
					BytesToTransfer -= sizeof( rgbTerminator ) ; // 5 comes from magic CRLF.CRLF
					BytesAvailable -= sizeof( rgbTerminator ) ;
					fAppend = TRUE ;
				}
			}
		}

		DWORD	cbActual = 0 ;
		LPBYTE	lpbOut = 0 ;
		DWORD	cbOut = 0 ;
		int		cBias = 0 ;

		fResult =
			m_pManipulator->ProcessBuffer(
								(LPBYTE)lpb,
								BytesToTransfer,
								BytesAvailable,
								cbActual,
								lpbOut,
								cbOut,
								cBias
								) ;

		//
		//	Add up the total amount by which we are offseting IO's within
		//	the target file !
		//
		m_cbCumulativeBias += cBias ;

		if( fResult	)	{
			//
			//	Are we going to do an extra IO ?
			//

			FH_OVERLAPPED	ovl ;
			FH_OVERLAPPED	*povl = lpo ;
			HANDLE			hEvent = 0;

			if( lpbOut && cbOut != 0 )	{
				_ASSERT( cbOut != 0 ) ;

				//
				//	Assume this fails and mark fResult appropriately
				//
				fResult = FALSE ;
				//HANDLE	hEvent = GetPerThreadEvent() ;
				hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				povl = &ovl ;
				if( hEvent == 0 )	{

					//
					//	Fatal error - die !
					//
					SetLastError( ERROR_OUTOFMEMORY ) ;
					return	FALSE ;
				}	else	{
					CopyMemory( &ovl, lpo, sizeof( ovl ) ) ;
					ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1) ;	// we want to get the completion here !
					//
					//	NOW - if fAppend is TRUE then we need to add the terminator to buffer that came from ProcessBuffer !
					//
					if( fAppend )	{
						CopyMemory( lpbOut + cbOut, rgbTerminator, sizeof( rgbTerminator ) ) ;
						cbOut += sizeof( rgbTerminator ) ;
					}
				}
			}	else	{
				//
				//	if fAppend is TRUE then we need to add the terminator
				//
				if( fAppend )	{
					CopyMemory( ((BYTE*)lpb) + cbActual, rgbTerminator, sizeof( rgbTerminator ) ) ;
					cbActual += sizeof( rgbTerminator ) ;
				}
			}

			//
			//	Adjust the offset we're writing into the file to account for the accumulated effects of dot stuffing !
			//
			povl->Offset = DWORD(((long)povl->Offset) + m_cbCumulativeBias) ;

			if( (fResult =
					pfnIO(	patqContext,
							lpb,
							cbActual,
							(OVERLAPPED*)povl
							))	)	{

				//
				//	Did we issue the users IO or our own ?
				//
				if( povl != &ovl )	{
					//
					//	Okay update the bias !
					//
					m_cbCumulativeBias += cbActual - BytesToTransfer ;

				}	else	{
					//
					//	Okay - we did our own IO !
					//
					DWORD	cbTransferred ;
					fResult = GetOverlappedResult(	patqContext->hAsyncIO,
													(OVERLAPPED*)povl,
													&cbTransferred,
													TRUE );
					if (hEvent)	_VERIFY( CloseHandle(hEvent) );
					if (fResult)	{
						//
						//	Make sure all of our bytes transferred !
						//
						_ASSERT( cbTransferred == cbActual ) ;
						//
						//	Record the buffer we issued the IO within !
						//
						lpo->Reserved2 = (UINT_PTR)lpbOut ;
						//
						//	Offset the write -
						//
						lpo->Offset = DWORD(((long)lpo->Offset) + m_cbCumulativeBias + (int)cbTransferred) ;
						//
						//	NOW - compute the correct bias !
						//
						m_cbCumulativeBias += (int)cbTransferred + (int)cbOut - (int)BytesToTransfer ;
						//
						//	Now issue the users requested IO operation !
						//
						return	pfnIO(	patqContext,
										lpbOut,
										cbOut,
										(LPOVERLAPPED)lpo
										) ;
					}
				}
			}	// pfnIO()
		}	//	fResult == TRUE !
	}
	//
	//	If we fall through to here, some kind of fatal error occurred !
	//
	return	fResult ;
} ;


BOOL
DOT_STUFF_MANAGER::IssueAsyncIOAndCapture(
		IN	PFNAtqIssueAsyncIO	pfnIO,
		IN	PATQ_CONTEXT	patqContext,
		IN	LPVOID			lpb,
		IN	DWORD			BytesToTransfer,
		IN	FH_OVERLAPPED*	lpo,
		IN	BOOL			fFinalIO,
		IN	BOOL			fTerminatorIncluded
		)	{
/*++

Routine Description :

	This function munges an IO the user has given us to
	do stuff to its dot stuffing.

Arguments :

	pfnIO - Pointer to the ATQ function which will do the IO
	patqContext - the ATQ context we're using to issue the IO
	lpb - the buffer the users data lives in !
	BytesToTransfer - the number of bytes the user wants us to transfer
	lpo - The users overlapped structure
	fFinalIO - if TRUE this is the last IO
	fTerminatorIncluded - if TRUE the "\r\n.\r\n" is included in the message

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( lpo != 0 ) ;
	_ASSERT( patqContext != 0 ) ;
	_ASSERT( lpb != 0 ) ;
	_ASSERT( BytesToTransfer != 0 ) ;
	_ASSERT( lpo != 0 ) ;

	//
	//	Assume everything works !
	//
	BOOL	fResult = TRUE ;

	//
	//	Munge the OVERLAPPED structure to preserve callers original state !
	//
	lpo->Reserved1 = BytesToTransfer ;
	lpo->Reserved2 = 0 ;

	//
	//	Check to see whether we need to do anything funky to this IO !
	//
	if( m_pManipulator == 0 )	{

		return	pfnIO(	patqContext,
						lpb,
						BytesToTransfer,
						(LPOVERLAPPED)lpo
						) ;

	}	else	{

		//
		//	The user shouldn't do synchronous reads against us - if they
		//	want us to filter the IO's
		//
		_ASSERT( ((UINT_PTR)lpo->hEvent & 0x1) == 0 ) ;

		//
		//	Setup the overlapped so that we can process the read completion !
		//
		m_pManipulator->AddRef() ;
		lpo->Reserved1 = (UINT_PTR)BytesToTransfer ;
		lpo->Reserved2 = (UINT_PTR)lpb ;
		lpo->Reserved3 = (UINT_PTR)lpo->pfnCompletion ;
		lpo->Reserved4 = (UINT_PTR)((IDotManipBase*)m_pManipulator) ;
		lpo->pfnCompletion = DOT_STUFF_MANAGER::AsyncIOAndCaptureCompletion ;
		if( fFinalIO && fTerminatorIncluded )	{
			//
			//	Assume user doesn't use high bit of BytesToTransfer - !
			//
			lpo->Reserved1 |= 0x80000000 ;
		}

		fResult = pfnIO(
						patqContext,
						lpb,
						BytesToTransfer,
						(LPOVERLAPPED)lpo
						) ;

	}
	//
	//	If we fall through to here, some kind of fatal error occurred !
	//
	return	fResult ;
} ;



void
DOT_STUFF_MANAGER::AsyncIOCompletion(
		IN	FIO_CONTEXT*	pContext,
		IN	FH_OVERLAPPED*	lpo,
		IN	DWORD			cb,
		IN	DWORD			dwStatus
		)	{
/*++

Routine Description :

	This function munges the IO completion so that it looks
	totally legit to the user !

Arguments :

	pContext - the FIO_CONTEXT that issued the IO
	lpo -		the extended overlap structure issued by the client
	cb	-		the number of bytes transferred
	dwStatus -	the result of the IO !

Return Value :

	None.

--*/


	//
	//	Get the original number of bytes the caller requested to be transferred !
	//
	DWORD	cbTransferred = (DWORD)lpo->Reserved1 ;
	//
	//	Find out if there was any additional memory we allocated that should now be freed !
	//
	LPBYTE	lpb = (LPBYTE)lpo->Reserved2 ;
	//
	//	Free the memory if present !
	//
	if( lpb )	{
		delete[]	lpb ;
	}

	//
	//	Now call the original IO requestor !
	//
	PFN_IO_COMPLETION	pfn = (PFN_IO_COMPLETION)lpo->Reserved3 ;

	_ASSERT( pfn != 0 ) ;

	pfn(	pContext,
			lpo,
			cbTransferred,
			dwStatus
			) ;
}

void
DOT_STUFF_MANAGER::AsyncIOAndCaptureCompletion(
		IN	FIO_CONTEXT*	pContext,
		IN	FH_OVERLAPPED*	lpo,
		IN	DWORD			cb,
		IN	DWORD			dwCompletionStatus
		)	{


/*++

Routine Description :

	This function munges the IO completion so that it looks
	totally legit to the user !

Arguments :

	pContext - the FIO_CONTEXT that issued the IO
	lpo -		the extended overlap structure issued by the client
	cb	-		the number of bytes transferred
	dwStatus -	the result of the IO !

Return Value :

	None.

--*/


	//
	//	Get the original number of bytes the caller requested to be transferred !
	//
	DWORD	cbTransferred = cb ;

	//
	//	Check to see if we have some work to do on the users buffer !
	//
	if( lpo->Reserved4 )	{

		//
		//	Find out if this was the final read and included the terminator !
		//
		BOOL	fFinal = !(!(lpo->Reserved1 & 0x80000000)) ;

		//
		//	Find out if there was any additional memory we allocated that should now be freed !
		//
		LPBYTE	lpb = (LPBYTE)lpo->Reserved2 ;
		_ASSERT( lpb != 0 ) ;

		//
		//	Okay - get the pointer to our object !
		//
		IDotManipBase*	pBase = (IDotManipBase*)lpo->Reserved4 ;
		DWORD	cbRemains ;
		BYTE*	lpbOut ;
		DWORD	cbOut ;
		int		cBias ;
		DWORD	cbScan = cb ;
		if( fFinal )	{
			cbScan -= 5 ;
		}

		BOOL	fResult =
		pBase->ProcessBuffer(	lpb,
								cbScan,
								cbScan,
								cbRemains,
								lpbOut,
								cbOut,
								cBias
								) ;

		//
		//	Dot scanning only should occur - buffer shouldn't change !
		//
		_ASSERT( fResult ) ;
		_ASSERT( lpbOut == 0 ) ;
		_ASSERT( cbRemains == cbScan ) ;
		_ASSERT( cbOut == 0 ) ;
		_ASSERT( cBias == 0 ) ;

		pBase->Release() ;
	}

	//
	//	Now call the original IO requestor !
	//
	PFN_IO_COMPLETION	pfn = (PFN_IO_COMPLETION)lpo->Reserved3 ;

	_ASSERT( pfn != 0 ) ;

	pfn(	pContext,
			lpo,
			cbTransferred,
			dwCompletionStatus
			) ;


}

BOOL
DOT_STUFF_MANAGER::SetDotStuffing(	BOOL	fEnable,
									BOOL	fStripDots
									)	{
/*++

Routine Description :

	This function sets the manager to do some dot stuffing state.
	Erases any previous dot stuffing state.

Arguments :

	fEnable - TURN dot stuffing on
	fStripDots - Remove Dots

Return Value :

	TRUE if successfull !

--*/

	//
	//	Destroy any existing dot stuffing state !
	//
	m_pManipulator = 0 ;

	//
	//	NOW - set up the new dot stuffing state !
	//

	if( fEnable	)	{
		BYTE*	lpbReplace = szShrink ;
		if( !fStripDots )	{
			lpbReplace = szGrow ;
		}
		m_pManipulator = new	CDotModifier(	szDotStuffed,
												lpbReplace
												) ;
		return	m_pManipulator != 0 ;
	}
	return	TRUE ;
}


BOOL
DOT_STUFF_MANAGER::SetDotScanning(	BOOL	fEnable	)	{
/*++

Routine Description :

	This function sets the manager to do some dot stuffing state.
	Erases any previous dot stuffing state.

Arguments :

	fEnable - TURN dot scanning on

Return Value :

	TRUE if successfull !

--*/

	//
	//	Destroy any existing dot stuffing state !
	//
	m_pManipulator = 0 ;

	//
	//	NOW - set up the new dot stuffing state !
	//

	if( fEnable	)	{
		m_pManipulator = new	CDotScanner(	FALSE ) ;
		return	m_pManipulator != 0 ;
	}
	return	TRUE ;
}

BOOL
DOT_STUFF_MANAGER::GetStuffState(	OUT	BOOL&	fStuffed	)	{
/*++

Routine Description :

	This function returns the results of our dot stuffing operations !

Arguments :

	fStuffed - OUT parameter -
		will return FALSE if no dots were processed, scanned or modified
		TRUE otherwise

Return Value :

	TRUE if we were actually scanning the IO's on this context
	FALSE otherwise - FALSE implies that fStuffed is useless


--*/

	fStuffed = FALSE ;

	if( m_pManipulator	)	{
		fStuffed = m_pManipulator->NumberOfOccurrences() != 0 ;
		return	TRUE ;
	}
	return	FALSE ;
}

//
//	Determine whether we have a valid Cache Key !
//
BOOL
CFileCacheKey::IsValid() {
/*++

Routine Description :

	This function is for debug and _ASSERT's -
	check to see whether the Key is in a valid state !

Arguments :

	Nont.

Return Value :

	TRUE if we are valid,
	FALSE otherwise !

--*/

	if( m_lpstrPath == 0 )
		return	FALSE ;
	if( m_cbPathLength == 0 )
		return	FALSE ;
	if( strlen( m_lpstrPath )+1 != m_cbPathLength )
		return	FALSE ;
	if( m_cbPathLength < BUFF_SIZE &&
		m_lpstrPath != m_szBuff )
		return	FALSE ;
	if( m_cbPathLength >= BUFF_SIZE &&
		m_lpstrPath == m_szBuff )
		return	FALSE ;
	return	TRUE ;
}

//
//	Construct one of these objects from the user provided key !
//
CFileCacheKey::CFileCacheKey(	LPSTR	lpstr	) :
	m_cbPathLength( strlen( lpstr ) + 1 ),
	m_lpstrPath( 0 )	{
/*++

Routine Description :

	This function constructs the CFileCacheKey from the specified
	file name !

Arguments :

	lpstr - The File name

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheKey::CFileCacheKey" ) ;

	if( m_cbPathLength > BUFF_SIZE ) {
		m_lpstrPath = new char[m_cbPathLength] ;
	}	else	{
		m_lpstrPath = m_szBuff ;
	}

	DebugTrace( (DWORD_PTR)this, "m_cbPathLength %x m_lpstrPath %x",
		m_cbPathLength, m_lpstrPath ) ;

	if( m_lpstrPath ) {
		CopyMemory( m_lpstrPath, lpstr, m_cbPathLength ) ;
	}	else	{
		m_cbPathLength = 0 ;
	}
}

//
//	We must have a Copy Constructor ! -
//	It is only used the MultiCacheEx<>, so
//	we safely wipe out the RHS CFileCacheKey !
//
CFileCacheKey::CFileCacheKey(	CFileCacheKey&	key ) {
/*++

Routine Description :

	Copy an existing file key, into another !

	We are only used by MultiCacheEx<> when it is initializing
	an entry for the cache - we know that the memory of the RHS
	may be dynamically allocated, and we take that memory rather
	than copy it.  Must set RHS's pointers to NULL so that it
	doesn't do a double free !

Arguments :

	key - RHS of the initialization

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheKey::Copy Constructor" ) ;

	if( key.m_cbPathLength > BUFF_SIZE ) {
		m_lpstrPath = key.m_lpstrPath ;
		key.m_lpstrPath = 0 ;
		key.m_cbPathLength = 0 ;
	}	else	{
		CopyMemory( m_szBuff, key.m_lpstrPath, key.m_cbPathLength ) ;
		m_lpstrPath = m_szBuff ;
	}
	m_cbPathLength = key.m_cbPathLength ;

	DebugTrace( (DWORD_PTR)this, "m_lpstrPath %x m_cbPathLength %x key.m_lpstrPath %x key.m_cbPathLength %x",
		m_lpstrPath, m_cbPathLength, key.m_lpstrPath, key.m_cbPathLength ) ;

	_ASSERT( IsValid() ) ;
}

//
//	Tell the client whether we're usable !
//
BOOL
CFileCacheKey::FInit()	{
/*++

Routine Description :

	Figure out if we are correctly constructed !
	The only time we can fail to be constructed is when
	memory needs to be allocated - which fortunately
	doesn't occur within MultiCacheEx<> - which doesn't
	check for Key initialization !

Arguments :

	None.

Return Value :

	TRUE if we're ready for use !
	FALSE otherwise !

--*/

	TraceFunctEnter( "CFileCacheKey::FInit" ) ;

	BOOL	fReturn = m_lpstrPath != 0 ;

	_ASSERT( !fReturn || IsValid() ) ;

	DebugTrace( (DWORD_PTR)this, "m_lpstrPath %x", m_lpstrPath ) ;

	return	fReturn ;
}

//
//	Destroy ourselves !
//
CFileCacheKey::~CFileCacheKey() {
/*++

Routine Description :

	Release any memory we've acquired if necessary !

Arguments :

	None.

Return Value :

	None.

--*/
	TraceFunctEnter( "CFileCacheKey::~CFIleCacheKey" ) ;

	DebugTrace( (DWORD_PTR)this, "m_lpstrPath %x m_lpstrPath %s",
		m_lpstrPath, m_lpstrPath ? m_lpstrPath : "NULL" ) ;

	if( m_lpstrPath != 0 ) {
		_ASSERT( IsValid() ) ;
		if( m_lpstrPath != m_szBuff ) {
			delete[]	m_lpstrPath ;
		}
	}
}

DWORD
CFileCacheKey::FileCacheHash(	CFileCacheKey*	p )	{
/*++

Routine Description :

	This function computes the hash value of a key.
	We call out to CRCHash - a very robust hash algorithm.

Arguments :

	p - the key we need to hash

Return Value :

	The hash value !

--*/
	_ASSERT( p != 0 ) ;
	_ASSERT( p->IsValid(  ) ) ;
	return	CRCHash( (const BYTE*)p->m_lpstrPath, p->m_cbPathLength ) ;
}

int
CFileCacheKey::MatchKey(	CFileCacheKey*	pLHS, CFileCacheKey*  pRHS ) {
/*++

Routine Description :

	Determine whether the two keys match !

Arguments :

	pLHS - A key to compare
	pRHS - the other key to compare

Return Value :

	0 if unequal !

--*/
	_ASSERT( pLHS != 0 ) ;
	_ASSERT( pRHS != 0 ) ;
	_ASSERT( pLHS->IsValid() ) ;
	_ASSERT( pRHS->IsValid() ) ;

	int	iReturn = pLHS->m_cbPathLength - pRHS->m_cbPathLength ;
	if( iReturn == 0 )
		iReturn = memcmp( pLHS->m_lpstrPath, pRHS->m_lpstrPath, pLHS->m_cbPathLength ) ;

	return	iReturn ;
}




BOOL
WINAPI
DllMain(	HMODULE		hInst,
			DWORD		dwReason,
			LPVOID		lpvReserved
			)	{
/*++

Routine Description :

	Called by the C-Runtimes to initialize our DLL.
	We will set up a critical section used in our init calls !

Arguments :

	hInst - handle to our module
	dwReason - why we were called
	lpvReserved -

Return Value :

	TRUE always - we can't fail

--*/

	if( dwReason == DLL_PROCESS_ATTACH ) {

		InitializeCriticalSection( &g_critInit ) ;
		DisableThreadLibraryCalls( hInst ) ;

	}	else	if( dwReason == DLL_PROCESS_DETACH ) {

		DeleteCriticalSection( &g_critInit ) ;

	}	else	{
		//
		//	We should not get any other notifications -
		//	we explicitly disable them !
		//
		_ASSERT( FALSE ) ;
	}
	return	TRUE ;
}


//
//	Cache Initialization Constants - These parameters control
//	the cache's behaviour !  How many files we'll hold etc...
//

//
//	The lifetime of each cache entry - in seconds !
//
DWORD	g_dwLifetime = 30 * 60 ;	// default is 30 minutes

//
//	The maximum number of elements the cache should allow
//
DWORD	g_cMaxHandles = 10000 ;	// default - 10000 items !

//
//	The number of subcaches we should use - larger number can
//	increase parallelism and reduce contention !
//
DWORD	g_cSubCaches = 64 ;

//
//	Define our registry key settings !
//
LPSTR	StrParmKey = "System\\CurrentControlSet\\Services\\Inetinfo\\Parameters";
LPSTR	StrLifetimeKey = "FileCacheLifetimeSeconds" ;
LPSTR	StrMaxHandlesKey = "FileCacheMaxHandles" ;
LPSTR	StrSubCachesKey = "FileCacheSubCaches" ;

void
GetRegistrySettings()	{
    DWORD error;
    HKEY key = NULL;
    DWORD valueType;
    DWORD dataSize;

    TraceFunctEnter("GetRegistrySettings") ;

	//
	//	First compute some defaults based on the amount of memory we have !
	//
	MEMORYSTATUS	memStatus ;
	memStatus.dwLength = sizeof( MEMORYSTATUS ) ;
	GlobalMemoryStatus( &memStatus ) ;

	DWORD	cMaxHandles = (DWORD)(memStatus.dwTotalPhys / (32 * 1024 * 1024)) ;
	if( cMaxHandles == 0 ) cMaxHandles = 1 ;
	cMaxHandles *= 800 ;
	if( cMaxHandles > 50000 ) {
		cMaxHandles = 50000 ;
	}
	g_cMaxHandles = cMaxHandles ;

    //
    // Open root key
    //

    error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                StrParmKey,
                NULL,
                KEY_QUERY_VALUE,
                &key
                );

    if ( error != NO_ERROR ) {
        ErrorTrace(0,"Error %d opening %s\n",error,StrParmKey);
        return ;
    }

	DWORD	dwLifetime = g_dwLifetime ;
	dataSize = sizeof( dwLifetime ) ;
	error = RegQueryValueEx(
						key,
						StrLifetimeKey,
						NULL,
						&valueType,
						(LPBYTE)&dwLifetime,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	The registry entry is in minutes - convert to milliseconds
		//
		g_dwLifetime = dwLifetime ;

	}

	dataSize = sizeof( DWORD ) ;
	error = RegQueryValueEx(
						key,
						StrMaxHandlesKey,
						NULL,
						&valueType,
						(LPBYTE)&cMaxHandles,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	Should be a valid switch
		//
		g_cMaxHandles = cMaxHandles ;
	}

	DWORD	cSubCaches = g_cSubCaches ;
	dataSize = sizeof( cSubCaches ) ;
	error = RegQueryValueEx(
						key,
						StrSubCachesKey,
						NULL,
						&valueType,
						(LPBYTE)&cSubCaches,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Should be a valid switch
		//
		g_cSubCaches = cSubCaches ;

	}
}




FILEHC_EXPORT
BOOL
InitializeCache()	{
/*++

Routine Description :

	Initializes the file handle cache for use by clients !

Arguments :

	None.

Return Value :

	TRUE if initialized - FALSE if not
	if we return FALSE don't call TerminateCache()

--*/
	InitAsyncTrace() ;
	TraceFunctEnter( "InitializeCache" ) ;

	EnterCriticalSection( &g_critInit ) ;

	crcinit() ;

	if( !FIOInitialize( 0 ) ) {
		DebugTrace( (DWORD_PTR)0, "FIOInitialize - failed GLE %x", GetLastError() ) ;
		LeaveCriticalSection( &g_critInit ) ;
		return	FALSE ;
	}

	BOOL	fReturn = TRUE ;
	if( InterlockedIncrement( &g_cCacheInits ) == 1 ) {

		GetRegistrySettings() ;

		//
		//	Initialize STAXMEM !
		//
		if( CreateGlobalHeap( 0, 0, 0, 0 ) )	{
			fReturn = FALSE ;
			if( CacheLibraryInit() ) {
				if(	InitNameCacheManager() )	{
					g_pFileCache = new	FILECACHE() ;
					if( g_pFileCache ) {
						if( g_pFileCache->Init(	CFileCacheKey::FileCacheHash,
												CFileCacheKey::MatchKey,
												g_dwLifetime, // One hour expiration !
												g_cMaxHandles,  // large number of handles !
												g_cSubCaches,	// Should be plenty of parallelism
												0		 // No statistics for now !
												) )	{
							fReturn = TRUE ;
						}	else	{
							delete	g_pFileCache ;
						}
					}
				}
			}
			if( !fReturn ) {
				CacheLibraryTerm() ;
				DestroyGlobalHeap() ;
			}
		}
	}

	if( !fReturn ) {
		long l = InterlockedDecrement( &g_cCacheInits ) ;
		_ASSERT( l >= 0 ) ;
	}

	DebugTrace( (DWORD_PTR)0, "FIOInitialize - result %x GLE %x", fReturn, GetLastError() ) ;

	LeaveCriticalSection( &g_critInit ) ;

	return	fReturn ;
}

FILEHC_EXPORT
BOOL
TerminateCache()	{

/*++

Routine Description :

	Initializes the file handle cache for use by clients !

Arguments :

	None.

Return Value :

	TRUE if initialized - FALSE if not
	if we return FALSE don't call TerminateCache()

--*/

	TraceFunctEnter( "TerminateCache" ) ;

	EnterCriticalSection( &g_critInit ) ;

	//
	//	We must be initialized - check this !
	//
	_ASSERT( g_pFileCache ) ;

	long l = InterlockedDecrement( &g_cCacheInits ) ;
	_ASSERT( l>=0 ) ;
	if( l==0 )	{
		TermNameCacheManager() ;
		delete	g_pFileCache ;
		g_pFileCache = 0 ;
		CacheLibraryTerm() ;
		DestroyGlobalHeap() ;
	}

	BOOL	fRet = FIOTerminate( ) ;
	DWORD	dw = GetLastError() ;
	_ASSERT( fRet ) ;

	TermAsyncTrace() ;

	LeaveCriticalSection( &g_critInit ) ;

	return	fRet ;
}



FILEHC_EXPORT
BOOL
FIOInitialize(
    IN DWORD dwFlags
    )	{
/*++

Routine Description :

	Initialize the DLL to deal with Async IO handled through ATQ !

Arguments :

	dwFlags - Place holder means nothing now !

Return Value :

	TRUE if succesfull initialized !

--*/

	InitAsyncTrace() ;
	BOOL	fReturn = TRUE ;

	EnterCriticalSection( &g_critInit ) ;

	if( InterlockedIncrement( &g_cIOInits ) == 1 ) {

		_VERIFY( CreateGlobalHeap( 0, 0, 0, 0 ) ) ;

#ifndef _NT4_TEST_
		g_hIisRtl = LoadLibrary( "iisrtl.dll" ) ;
		fReturn = fReturn && (g_hIisRtl != 0) ;
		if( fReturn ) {

			g_InitializeIISRTL = (PFNInitializeIISRTL)GetProcAddress( g_hIisRtl, "InitializeIISRTL" ) ;
			g_TerminateIISRTL = (PFNTerminateIISRTL)GetProcAddress( g_hIisRtl, "TerminateIISRTL" ) ;

			fReturn = fReturn && (g_InitializeIISRTL != 0) && (g_TerminateIISRTL != 0) ;

			if( fReturn )
				fReturn = fReturn && g_InitializeIISRTL() ;
		}
#endif
		if( fReturn ) {
			//
			//	Load up IIS !
			//
			g_hIsAtq = LoadLibrary("isatq.dll" ) ;
			g_AtqInitialize =	(PFNAtqInitialize)GetProcAddress( g_hIsAtq, SZATQINITIALIZE ) ;
			g_AtqTerminate =	(PFNAtqTerminate)GetProcAddress( g_hIsAtq, SZATQTERMINATE ) ;
			g_AtqAddAsyncHandle=	(PFNAtqAddAsyncHandle)GetProcAddress( g_hIsAtq, SZATQADDASYNCHANDLE ) ;
			g_AtqCloseFileHandle=	(PFNAtqCloseFileHandle)GetProcAddress( g_hIsAtq, SZATQCLOSEFILEHANDLE ) ;
			g_AtqFreeContext=		(PFNAtqFreeContext)GetProcAddress( g_hIsAtq, SZATQFREECONTEXT ) ;
			g_AtqReadFile =			(PFNAtqIssueAsyncIO)GetProcAddress( g_hIsAtq, SZATQREADFILE ) ;
			g_AtqWriteFile =		(PFNAtqIssueAsyncIO)GetProcAddress( g_hIsAtq, SZATQWRITEFILE ) ;

			fReturn	=	fReturn &&
						(g_AtqInitialize != 0) &&
						(g_AtqTerminate != 0) &&
						(g_AtqAddAsyncHandle != 0) &&
						(g_AtqCloseFileHandle != 0) &&
						(g_AtqFreeContext != 0) &&
						(g_AtqReadFile != 0) &&
						(g_AtqWriteFile != 0) ;
		}
		if( fReturn )	{
			_ASSERT( dwFlags == 0 ) ;
			fReturn = g_AtqInitialize( ATQ_INIT_SPUD_FLAG ) ;

		}
	}
	if( !fReturn ) {
		InterlockedDecrement( &g_cIOInits ) ;
	}

	LeaveCriticalSection( &g_critInit ) ;

	return	fReturn ;
}

FILEHC_EXPORT
BOOL
FIOTerminate(
    VOID
    )	{
/*++

Routine Description :

	Terminate Async IO in our DLL !

Arguments :

	NULL

Return Value :

	TRUE if there were no errors during uninit !

--*/

	EnterCriticalSection( &g_critInit ) ;

	BOOL	fReturn = TRUE ;
	long l = InterlockedDecrement( &g_cIOInits ) ;
	if( l == 0 ) {
		fReturn = g_AtqTerminate( ) ;
#ifndef _NT4_TEST_
        g_TerminateIISRTL() ;
        FreeLibrary( g_hIisRtl ) ;
        g_hIisRtl = 0 ;
#endif
        FreeLibrary( g_hIsAtq ) ;
        g_hIsAtq = 0 ;
    	_VERIFY( DestroyGlobalHeap() ) ;
	}
	//
	//	Save the error code so TermAsyncTrace() don't confuse things !
	//
	DWORD	dw = GetLastError() ;

	_ASSERT( l >= 0 ) ;

	TermAsyncTrace() ;

	SetLastError( dw ) ;

	LeaveCriticalSection( &g_critInit ) ;

	return	fReturn ;
}



FILEHC_EXPORT
BOOL
FIOReadFileEx(
    IN  PFIO_CONTEXT	pfioContext,
    IN  LPVOID			lpBuffer,
    IN  DWORD			BytesToRead,
	IN	DWORD			BytesAvailable,
    IN  FH_OVERLAPPED * lpo,
	IN	BOOL			fFinalRead,	// Is this the final write ?
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
    )	{
/*++

Routine description :

	Issue an Async Write IO against the file -
	Use the underlying ATQ to do it !

Arguments :

	pfioContext - the IO Context we gave to the client !
	lpBuffer - the buffer to write from !
	BytesToRead - Number of bytes we want to transfer !
	BytesAvailable - Number of bytes in the buffer we can mess with !
	lpo - the overlapped to return when this completes !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	TraceFunctEnter( "FIOReadFileEx" ) ;

	_ASSERT( pfioContext != 0 );
	_ASSERT( lpBuffer != 0 ) ;
	_ASSERT( BytesToRead != 0 ) ;
	_ASSERT( lpo != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;
	_ASSERT( BytesAvailable >= BytesToRead ) ;


	FIO_CONTEXT_INTERNAL*	pInternal = (FIO_CONTEXT_INTERNAL*)pfioContext ;

	_ASSERT( pInternal->m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pInternal->m_pAtqContext != 0 ) ;

	DebugTrace( (DWORD_PTR)pfioContext, "fioContext %x lpBuffer %x BytesToRead %x lpo %x",
		pfioContext, lpBuffer, BytesToRead , lpo ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( pInternal ) ;
	_ASSERT( pCache != 0 ) ;

	return	pCache->m_ReadStuffs.IssueAsyncIOAndCapture(
							ReadWrapper,
							pInternal->m_pAtqContext,
							(LPVOID)lpBuffer,
							BytesToRead,
							lpo,
							fFinalRead,
							fIncludeTerminator
							) ;
}


FILEHC_EXPORT
BOOL
FIOReadFile(
    IN  PFIO_CONTEXT	pfioContext,
    IN  LPVOID		lpBuffer,
    IN  DWORD		BytesToRead,
    IN  FH_OVERLAPPED * lpo
    )	{
/*++

Routine description :

	Issue an Async Read IO against the file -
	Use the underlying ATQ to do it !

Arguments :

	pfioContext - the IO Context we gave to the client !
	lpBuffer - the buffer to read into !
	BytesToRead - Number of bytes we want to get !
	lpo - the overlapped to return when this completes !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	TraceFunctEnter( "FIOReadFile" ) ;

	_ASSERT( pfioContext != 0 ) ;
	_ASSERT( lpBuffer != 0 ) ;
	_ASSERT( BytesToRead != 0 ) ;
	_ASSERT( lpo != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;


	FIO_CONTEXT_INTERNAL*	pInternal = (FIO_CONTEXT_INTERNAL*)pfioContext ;

	_ASSERT( pInternal->m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pInternal->m_pAtqContext != 0 ) ;

	DebugTrace( (DWORD_PTR)pfioContext, "fioContext %x lpBuffer %x BytesToRead %x lpo %x",
		pfioContext, lpBuffer, BytesToRead, lpo ) ;

	return	FIOReadFileEx(	pfioContext,
							lpBuffer,
							BytesToRead,
							BytesToRead,
							lpo,
							FALSE,
							FALSE
							) ;
}

FILEHC_EXPORT
BOOL
FIOWriteFileEx(
    IN  PFIO_CONTEXT	pfioContext,
    IN  LPVOID		lpBuffer,
    IN  DWORD		BytesToWrite,
	IN	DWORD		BytesAvailable,
    IN  FH_OVERLAPPED * lpo,
	IN	BOOL			fFinalWrite,	// Is this the final write ?
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
    )	{
/*++

Routine description :

	Issue an Async Write IO against the file -
	Use the underlying ATQ to do it !

Arguments :

	pfioContext - the IO Context we gave to the client !
	lpBuffer - the buffer to write from !
	BytesToRead - Number of bytes we want to transfer !
	BytesAvailable - Number of bytes in the buffer we can mess with !
	lpo - the overlapped to return when this completes !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	TraceFunctEnter( "FIOWriteFileEx" ) ;

	_ASSERT( pfioContext != 0 );
	_ASSERT( lpBuffer != 0 ) ;
	_ASSERT( BytesToWrite != 0 ) ;
	_ASSERT( lpo != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;
	_ASSERT( BytesAvailable >= BytesToWrite ) ;


	FIO_CONTEXT_INTERNAL*	pInternal = (FIO_CONTEXT_INTERNAL*)pfioContext ;

	_ASSERT( pInternal->m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pInternal->m_pAtqContext != 0 ) ;

	DebugTrace( (DWORD_PTR)pfioContext, "fioContext %x lpBuffer %x BytesToWrite %x lpo %x",
		pfioContext, lpBuffer, BytesToWrite, lpo ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( pInternal ) ;
	_ASSERT( pCache != 0 ) ;

	return	pCache->m_WriteStuffs.IssueAsyncIO(
							WriteWrapper,
							pInternal->m_pAtqContext,
							(LPVOID)lpBuffer,
							BytesToWrite,
							BytesAvailable,
							lpo,
							fFinalWrite,
							fIncludeTerminator
							) ;
}



FILEHC_EXPORT
BOOL
FIOWriteFile(
    IN  PFIO_CONTEXT	pfioContext,
    IN  LPCVOID		lpBuffer,
    IN  DWORD		BytesToWrite,
    IN  FH_OVERLAPPED * lpo
    )	{
/*++

Routine description :

	Issue an Async Write IO against the file -
	Use the underlying ATQ to do it !

Arguments :

	pfioContext - the IO Context we gave to the client !
	lpBuffer - the buffer to write from !
	BytesToRead - Number of bytes we want to transfer !
	lpo - the overlapped to return when this completes !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	TraceFunctEnter( "FIOWriteFile" ) ;

	_ASSERT( pfioContext != 0 );
	_ASSERT( lpBuffer != 0 ) ;
	_ASSERT( BytesToWrite != 0 ) ;
	_ASSERT( lpo != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;


	FIO_CONTEXT_INTERNAL*	pInternal = (FIO_CONTEXT_INTERNAL*)pfioContext ;

	_ASSERT( pInternal->m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pInternal->m_pAtqContext != 0 ) ;

	DebugTrace( (DWORD_PTR)pfioContext, "fioContext %x lpBuffer %x BytesToWrite %x lpo %x",
		pfioContext, lpBuffer, BytesToWrite, lpo ) ;

	return	FIOWriteFileEx(	pfioContext,
							(LPVOID)lpBuffer,
							BytesToWrite,
							BytesToWrite,
							lpo,
							FALSE,
							FALSE
							) ;
}

//
//	Associate a file with an async context !
//
FILEHC_EXPORT
PFIO_CONTEXT
AssociateFileEx(	HANDLE	hFile,
					BOOL	fStoredWithDots,
					BOOL	fStoredWithTerminatingDot
					)	{
/*++

Routine Description :

	Return to the client an FIO_CONTEXT that they can use to do IO's etc !

Arguments :

	hFile - the file handle that should be in the context !
	fStoredWithDots - if TRUE then this object was stored with dot stuffing !

Return Value :

	the context they got - NULL on failure !

--*/

	TraceFunctEnter( "AssociateFileEx" ) ;

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	PFIO_CONTEXT	pReturn = 0 ;

	CFileCacheObject*	pObject = new	CFileCacheObject(	fStoredWithDots,
															fStoredWithTerminatingDot
															) ;
	if( pObject ) {

		pReturn = (PFIO_CONTEXT)pObject->AsyncHandle( hFile ) ;
		if( !pReturn )
			pObject->Release() ;
	}

	DebugTrace( (DWORD_PTR)pObject, "pObject %x hFile %x pReturn %x", pObject, hFile, pReturn ) ;

	return	pReturn ;
}


//
//	Associate a file with an async context !
//
FILEHC_EXPORT
PFIO_CONTEXT
AssociateFile(	HANDLE	hFile	)	{
/*++

Routine Description :

	Return to the client an FIO_CONTEXT that they can use to do IO's etc !

Arguments :

	hFile - the file handle that should be in the context !
	fStoredWithDots - if TRUE then this object was stored with dot stuffing !

Return Value :

	the context they got - NULL on failure !

--*/

	TraceFunctEnter( "AssoicateFile" ) ;

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	return	AssociateFileEx( hFile, FALSE, FALSE ) ;
}




//
//	Release a Context !
//
FILEHC_EXPORT
void
ReleaseContext(	PFIO_CONTEXT	pContext )	{
/*++

Routine Description :

	Given a context we've previously given to clients -
	release it back to the cache or the appropriate place !
	(May not have been from the cache!)

Arguments :

	The PFIO_CONTEXT !

Return Value :

	False if there was some kind of error !

--*/

	TraceFunctEnter( "ReleaseContext" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;


	DebugTrace( (DWORD_PTR)pContext, "Release pContext %x pCache %x", pContext, pCache ) ;

	//
	//	Now do the right thing, whether this is from a cache or whatever !
	//
	pCache->Return() ;

}

FILEHC_EXPORT
void
AddRefContext(	PFIO_CONTEXT	pContext )	{
/*++

Routine Description :

	Given a context we've previously given to clients -
	Add a reference to it !

Arguments :

	The PFIO_CONTEXT !

Return Value :

	False if there was some kind of error !

--*/

	TraceFunctEnter( "AddRefContext" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;


	DebugTrace( (DWORD_PTR)pContext, "AddRef pContext %x pCache %x", pContext, pCache ) ;

	//
	//	Now do the right thing, whether this is from a cache or whatever !
	//
	pCache->Reference() ;
}


FILEHC_EXPORT
BOOL
CloseNonCachedFile(	PFIO_CONTEXT	pFIOContext)	{
/*++

Routine Description :

	This function closes the handle within an FIO_CONTEXT
	if the context is not in the cache !

Arguments :

	pFIOContext - the context who's handle we are to close !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "CloseNonCachedFile" ) ;

	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pFIOContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;


	DebugTrace( (DWORD_PTR)pFIOContext, "CloseNonCachedFile pContext %x pCache %x", pFIOContext, pCache ) ;

	//
	//	Now do the right thing, whether this is from a cache or whatever !
	//
	return	pCache->CloseNonCachedFile() ;
}




FILEHC_EXPORT
FIO_CONTEXT*
CacheCreateFile(	IN	LPSTR	lpstrName,
					IN	FCACHE_CREATE_CALLBACK	pfnCallback,
					IN	LPVOID	lpv,
					IN	BOOL	fAsyncContext
					)	{
/*++

Routine Description :

	This function creates a FIO_CONTEXT for the specified file.

Arguments :


Return Value :

	An FIO_CONTEXT that can be used for sync or async IO's

--*/

	TraceFunctEnter( "CacheCreateFile" ) ;

	FIO_CONTEXT*	pReturn = 0 ;
	CFileCacheKey	keySearch(lpstrName) ;

	if( keySearch.FInit() ) {
		CFileCacheConstructor	constructor(	lpv,
												pfnCallback,
												fAsyncContext
												) ;
		CFileCacheObject*	p = g_pFileCache->FindOrCreate(
													keySearch,
													constructor
													) ;

		DebugTrace( (DWORD_PTR)p, "CacheObject %x", p ) ;


		if( p ) {
			if( fAsyncContext ) {
				pReturn = (FIO_CONTEXT*)p->GetAsyncContext(	keySearch,
															constructor
															) ;
			}	else	{
				pReturn = (FIO_CONTEXT*)p->GetSyncContext(	keySearch,
															constructor
															) ;
			}
			if( pReturn == 0  ) {
				g_pFileCache->CheckIn( p ) ;
			}
		}
	}

	DebugTrace( (DWORD_PTR)pReturn, "Result %x lpstrName %x %s pfnCallback %x lpv %x fAsync %x",
		pReturn, lpstrName, lpstrName ? lpstrName : "NULL", pfnCallback, lpv, fAsyncContext ) ;

	//
	//	Note keySearch's destructor takes care of memory we allocated !
	//
	return	pReturn ;
}


FILEHC_EXPORT
FIO_CONTEXT*
CacheRichCreateFile(
					IN	LPSTR	lpstrName,
					IN	FCACHE_RICHCREATE_CALLBACK	pfnCallback,
					IN	LPVOID	lpv,
					IN	BOOL	fAsyncContext
					)	{
/*++

Routine Description :

	This function creates a FIO_CONTEXT for the specified file.

Arguments :


Return Value :

	An FIO_CONTEXT that can be used for sync or async IO's

--*/

	TraceFunctEnter( "CacheRichCreateFile" ) ;

	FIO_CONTEXT*	pReturn = 0 ;
	CFileCacheKey	keySearch(lpstrName) ;

	if( keySearch.FInit() ) {
		CRichFileCacheConstructor	constructor(
												lpv,
												pfnCallback,
												fAsyncContext
												) ;
		CFileCacheObject*	p = g_pFileCache->FindOrCreate(
													keySearch,
													constructor
													) ;

		DebugTrace( (DWORD_PTR)p, "CacheObject %x", p ) ;


		if( p ) {
			if( fAsyncContext ) {
				pReturn = (FIO_CONTEXT*)p->GetAsyncContext(	keySearch,
															constructor
															) ;
			}	else	{
				pReturn = (FIO_CONTEXT*)p->GetSyncContext(	keySearch,
															constructor
															) ;
			}
			if( pReturn == 0  ) {
				g_pFileCache->CheckIn( p ) ;
			}
		}
	}

	DebugTrace( (DWORD_PTR)pReturn, "Result %x lpstrName %x %s pfnCallback %x lpv %x fAsync %x",
		pReturn, lpstrName, lpstrName ? lpstrName : "NULL", pfnCallback, lpv, fAsyncContext ) ;

	//
	//	Note keySearch's destructor takes care of memory we allocated !
	//
	return	pReturn ;
}

BOOL
ReadUtil(	IN	FIO_CONTEXT*	pContext,
			IN	DWORD			ibOffset,
			IN	DWORD			cbToRead,
			IN	BYTE*			lpb,
			IN	HANDLE			hEvent,
			IN	BOOL			fFinal
			)	{
/*++

Routine Description :

	This function will issue a Read against the user's FIO_CONTEXT
	and will complete it synchronously.

Arguments :

	pContext - the FIO_CONTEXT to issue the read against !
	cbToRead - Number of bytes to read !
	lpb - Pointer to the buffer where the data goes !
	hEvent - Event to use to complete IO's
	fFinal - TRUE if this is the last IO !

Return Vlaue :

	TRUE if successfull !

--*/

	FH_OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;

	ovl.Offset = ibOffset ;
	ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1) ;	// we want to get the completion here !


	if( FIOReadFileEx(	pContext,
						lpb,
						cbToRead,
						cbToRead,
						&ovl,
						fFinal,
						FALSE
						)	)	{

		DWORD	cbTransfer = 0 ;
		if( GetOverlappedResult(	pContext->m_hFile,
									(LPOVERLAPPED)&ovl,
									&cbTransfer,
									TRUE ) )	{
			return	TRUE ;
		}
	}
	return	FALSE ;
}


BOOL
WriteUtil(	IN	FIO_CONTEXT*	pContext,
			IN	DWORD			ibOffset,
			IN	DWORD			cbToWrite,
			IN	DWORD			cbAvailable,
			IN	BYTE*			lpb,
			IN	HANDLE			hEvent,
			IN	BOOL			fFinal,
			IN	BOOL			fTerminatorIncluded
			)	{
/*++

Routine Description :

	This function will issue a Write against the user's FIO_CONTEXT
	and will complete it synchronously.

Arguments :

	pContext - the FIO_CONTEXT to issue the read against !
	cbToRead - Number of bytes to read !
	lpb - Pointer to the buffer where the data goes !
	hEvent - Event to use to complete IO's
	fFinal - TRUE if this is the last IO !

Return Vlaue :

	TRUE if successfull !

--*/

	FH_OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;

	ovl.Offset = ibOffset ;
	ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1) ;	// we want to get the completion here !

	if( FIOWriteFileEx(	pContext,
						lpb,
						cbToWrite,
						cbAvailable,
						&ovl,
						fFinal,
						fTerminatorIncluded
						)	)	{

		DWORD	cbTransfer = 0 ;
		if( GetOverlappedResult(	pContext->m_hFile,
									(LPOVERLAPPED)&ovl,
									&cbTransfer,
									TRUE ) )	{
			return	TRUE ;
		}
	}
	return	FALSE ;
}



FIO_CONTEXT*
ProduceDotStuffedContext(	IN	FIO_CONTEXT*	pContext,
							IN	LPSTR			lpstrName,
							IN	BOOL			fWantItDotStuffed
							)	{
/*++

Routine Description :

	This function will examine the provided FIO_CONTEXT and produce
	a FIO_CONTEXT that contains the necessary dot stuffing if the original
	doesn't suffice.

Arguments :

	pContext - the original FIO_CONTEXT
	lpstrName - the file name associated with the original context
	fWantItDotStuffed -

Return Value :

	Possibly the original FIO_CONTEXT with an additional reference
	or a New FIO_CONTEXT or NULL on failure !

--*/


	TraceFunctEnter( "ProduceDotStuffedContext" ) ;

	_ASSERT( pContext != 0 ) ;
	//_ASSERT( lpstrName != 0 ) ;

	FIO_CONTEXT*	pReturn = 0 ;
	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	//
	//	Okay lets see if the original Context is good enough !
	//
	if(	(fWantItDotStuffed &&
			(pCache->m_fStoredWithDots ||
			(!pCache->m_fStoredWithDots &&
			(pCache->m_fFileWasScanned && !pCache->m_fRequiresStuffing) ) )) ||
		(!fWantItDotStuffed &&
			(!pCache->m_fStoredWithDots ||
			(pCache->m_fStoredWithDots &&
			(pCache->m_fFileWasScanned && !pCache->m_fRequiresStuffing) ) ))
			)		{
		//
		//	Just duplicate the same FIO_CONTEXT !
		//
		AddRefContext( pContext ) ;
		return	pContext ;
	}	else	{
		//
		//	We need to produce a new FIO_CONTEXT !!!
		//
		//
		//	First get the temp directory !
		//
		char	szDirectory[MAX_PATH] ;
		char	szFileName[MAX_PATH] ;
		DWORD	cch = GetTempPath( sizeof( szDirectory ), szDirectory ) ;
		if( cch != 0 ) {

			DWORD	id = GetTempFileName(	szDirectory,
											"DST",
											0,
											szFileName
											) ;
			if( id != 0 ) {

				HANDLE	hFile = CreateFile(	szFileName,
											GENERIC_READ | GENERIC_WRITE,
											FILE_SHARE_READ,
											0,
											CREATE_ALWAYS,
											FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_SEQUENTIAL_SCAN,
											INVALID_HANDLE_VALUE
											) ;

				DWORD	dw = GetLastError() ;
				DebugTrace( DWORD(0), "GLE - %x", dw ) ;

				if( hFile != INVALID_HANDLE_VALUE ) {
					pReturn = AssociateFileEx(	hFile,
												fWantItDotStuffed,
												pCache->m_fStoredWithTerminatingDot
												) ;
					if( pReturn )	{
						//
						//	The file handle is now held by the context and should
						//	not be directly manipulated ever again !
						//
						hFile = INVALID_HANDLE_VALUE ;
						//
						//	We want to know if our temp copy has any changes !
						//
						BOOL	fModified = FALSE ;
						//
						//	Now - do the stuffing !
						//
						BOOL	fSuccess = ProduceDotStuffedContextInContext(
													pContext,
													pReturn,
													fWantItDotStuffed,
													&fModified
													)  ;
						//
						//	If there was a failure - release things !
						//
						if( !fSuccess )		{
							ReleaseContext( pReturn ) ;
							pReturn = 0 ;
						}	else	if( !fModified )	{
							//
							//	All that work for nothing !
							//
							ReleaseContext( pReturn ) ;
							AddRefContext( pContext ) ;
							pReturn = pContext ;
						}
					}
				}
				//
				//	A failure might require us to release the handle !
				//
				if( hFile != INVALID_HANDLE_VALUE )
					_VERIFY (CloseHandle( hFile )) ;
			}
		}
	}
	return	pReturn ;
}



BOOL
ProduceDotStuffedContextInContext(
							IN	FIO_CONTEXT*	pContextSource,
							IN	FIO_CONTEXT*	pContextDestination,
							IN	BOOL			fWantItDotStuffed,
							OUT	BOOL*			pfModified
							)	{
/*++

Routine Description :

	This function will examine the provided FIO_CONTEXT and produce
	a FIO_CONTEXT that contains the necessary dot stuffing if the original
	doesn't suffice.

Arguments :

	pContextSource - the original FIO_CONTEXT
	pContextDestination - the destination FIO_CONTEXT !
	fWantItDotStuffed -

Return Value :

	Possibly the original FIO_CONTEXT with an additional reference
	or a New FIO_CONTEXT or NULL on failure !

--*/


	TraceFunctEnter( "ProduceDotStuffedContext" ) ;

	_ASSERT(	pContextSource ) ;
	_ASSERT(	pContextDestination ) ;

	//
	//	Check arguments !
	//
	if( pContextSource == 0 ||
		pContextDestination == 0 ||
		pfModified == 0 )	{
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	FALSE ;
	}


#ifdef	DEBUG
	{
		FIO_CONTEXT_INTERNAL*	pSourceInternal = (FIO_CONTEXT_INTERNAL*)pContextSource ;

		_ASSERT( pSourceInternal->IsValid() ) ;
		_ASSERT( pSourceInternal->m_dwSignature != ILLEGAL_CONTEXT ) ;

		CFileCacheObject*	pSourceCache = CFileCacheObject::CacheObjectFromContext( pSourceInternal ) ;

		FIO_CONTEXT_INTERNAL*	pDestInternal = (FIO_CONTEXT_INTERNAL*)pContextDestination ;

		_ASSERT( pSourceInternal->IsValid() ) ;
		_ASSERT( pSourceInternal->m_dwSignature != ILLEGAL_CONTEXT ) ;

		CFileCacheObject*	pDestCache = CFileCacheObject::CacheObjectFromContext( pDestInternal ) ;

		_ASSERT( pDestCache->m_fStoredWithDots == fWantItDotStuffed ) ;
	}
#endif

	//
	//	First allocate the things we'll need !
	//
	//HANDLE	hEvent = GetPerThreadEvent() ;
	HANDLE	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ) ;
	if( hEvent == 0 )	{
		SetLastError( ERROR_OUTOFMEMORY ) ;
		return	FALSE ;
	}

	//
	//	Allocate the memory we use to do the copy !
	//
	DWORD	cbRead = 32 * 1024 ;
	DWORD	cbExtra = 1024 ;
	BYTE*	lpb = new	BYTE[cbRead+cbExtra] ;
	if( lpb == 0 )	{
		SetLastError( ERROR_OUTOFMEMORY ) ;
		if (hEvent) {
			_VERIFY( CloseHandle(hEvent) );
			hEvent = 0;
		}
		return FALSE	;
	}

	DWORD	cbSizeHigh = 0 ;
	DWORD	cbSize = GetFileSizeFromContext( pContextSource, &cbSizeHigh ) ;
	DWORD	ibOffset = 0 ;

	_ASSERT( cbSize != 0 ) ;

	//
	//	Now figure out what manipulations we should do to the destination !
	//
	BOOL	fSourceScanned ;
	BOOL	fSourceStuffed ;
	BOOL	fSourceStoredWithDots ;

	fSourceScanned =
	GetDotStuffState( pContextSource, FALSE, &fSourceStuffed, &fSourceStoredWithDots ) ;
	SetDotScanningOnReads( pContextSource, FALSE ) ;

	BOOL	fTerminatorIncluded = GetIsFileDotTerminated( pContextSource ) ;
	SetIsFileDotTerminated( pContextDestination, fTerminatorIncluded ) ;

	BOOL	fSuccess = TRUE ;

	if( fWantItDotStuffed )	{
		if( !fSourceStoredWithDots &&
			(!fSourceScanned || (fSourceScanned && fSourceStuffed) ) )		{

			fSuccess = SetDotStuffingOnWrites( pContextDestination, TRUE, FALSE ) ;

		}
	}	else	{
		if( fSourceStoredWithDots &&
			(!fSourceScanned || (fSourceScanned && fSourceStuffed) ) )	{

			fSuccess = SetDotStuffingOnWrites( pContextDestination, TRUE, TRUE ) ;
		}
	}
	//
	//  Now if everything has been good so far, go ahead and do the IO's !
	//
	if( fSuccess )	{
		do	{
			DWORD	cbToRead = min( cbSize, cbRead ) ;
			cbSize -= cbToRead ;

			fSuccess =
			ReadUtil(	pContextSource,
						ibOffset,
						cbToRead,
						lpb,
						hEvent,
						cbSize == 0
						) ;

			if( fSuccess )	{
				fSuccess =
					WriteUtil(	pContextDestination,
								ibOffset,
								cbToRead,
								cbRead + cbExtra,
								lpb,
								hEvent,
								cbSize == 0,
								fTerminatorIncluded
								) ;
			}
			ibOffset += cbToRead ;
		}	while( cbSize && fSuccess )	;
	}
	//
	//	Preserve the error codes !
	//
	DWORD	dw = GetLastError() ;

	if( fSuccess )	{
		BOOL	fModified = FALSE ;
		BOOL	fStoredWithDots = FALSE ;
		BOOL	fResult = GetDotStuffState( pContextDestination, FALSE, &fModified, &fStoredWithDots ) ;
		SetDotStuffingOnWrites( pContextDestination, FALSE, FALSE ) ;
		if( fResult && !fSourceScanned )	{
			SetDotStuffState( pContextSource, TRUE, fModified ) ;
		}
		if( pfModified )	{
			*pfModified = fModified ;
		}
	}
	//
	//	release our pre-allocated stuff !
	//
	delete	lpb ;
	SetLastError( dw ) ;
	if (hEvent) {
		_VERIFY( CloseHandle(hEvent) );
		hEvent = 0;
	}
	return	fSuccess ;
}




FILEHC_EXPORT
BOOL
InsertFile(	IN	LPSTR	lpstrName,
			IN	FIO_CONTEXT*	pContext,
			IN	BOOL	fKeepReference
			)	{
/*++

Routine Description :

	This function creates a FIO_CONTEXT for the specified file.

Arguments :


Return Value :

	An FIO_CONTEXT that can be used for sync or async IO's

--*/

	TraceFunctEnter( "InsertFile" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;
	CFileCacheKey	keySearch(lpstrName) ;

	BOOL	fReturn = FALSE ;
	if( keySearch.FInit() ) {
		fReturn = pCache->InsertIntoCache( keySearch, fKeepReference ) ;
	}


	DebugTrace( (DWORD_PTR)pContext, "Insert %x %s pContext %x fKeep %x fReturn %x",
		lpstrName, lpstrName ? lpstrName : "NULL", pContext, fKeepReference, fReturn ) ;


	//
	//	Note keySearch's destructor takes care of memory we allocated !
	//
	return	fReturn;
}

FILEHC_EXPORT
DWORD
GetFileSizeFromContext(
			IN	FIO_CONTEXT*	pContext,
			OUT	DWORD*			pcbFileSizeHigh
			)	{
/*++

Routine Description :

	This function creates a FIO_CONTEXT for the specified file.

Arguments :


Return Value :

	An FIO_CONTEXT that can be used for sync or async IO's

--*/

	TraceFunctEnter( "GetFileSizeFromContext" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->GetFileSize( pcbFileSizeHigh ) ;
}

FILEHC_EXPORT
BOOL
GetIsFileDotTerminated(
			IN	FIO_CONTEXT*	pContext
			)	{
/*++

Routine Description :

	Tell the caller whether there is a terminating DOT in the file !

Arguments :

	pContext - the context we are to look at !

Return Value :

	TRUE if there is a terminating dot, FALSE otherwise !


--*/

	TraceFunctEnter( "GetIsFileDotTerminated" ) ;


	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->m_fStoredWithTerminatingDot ;
}


FILEHC_EXPORT
void
SetIsFileDotTerminated(
			IN	FIO_CONTEXT*	pContext,
			IN	BOOL			fIsTerminatedWithDot
			)	{
/*++

Routine Description :

	Tell the caller whether there is a terminating DOT in the file !

Arguments :

	pContext - the context we are to look at !

Return Value :

	TRUE if there is a terminating dot, FALSE otherwise !


--*/

	TraceFunctEnter( "GetIsFileDotTerminated" ) ;


	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	pCache->m_fStoredWithTerminatingDot = fIsTerminatedWithDot ;
}



FILEHC_EXPORT
BOOL
SetDotStuffingOnWrites(
			IN	FIO_CONTEXT*	pContext,
			IN	BOOL			fEnable,
			IN	BOOL			fStripDots
			)	{
/*++

Routine Description :

	This function modifies an FIO_CONTEXT to do dot stuffing on writes.
	We can turn on or off the dot stuffing properties.

Arguments :

	pContext - the FIO_CONTEXT that we want to modify !
	fEnable - if TRUE than we want to turn on some dot stuffing behaviours !
	fStripDots - if TRUE we want to remove Dots, FALSE means insert dots !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "SetDotStuffingOnWrites" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	//
	//	Do some checking on whats going on here !
	//
	if( fEnable )	{
		if( pCache->m_fStoredWithDots ) {
			_ASSERT( !fStripDots ) ;
		}	else	{
			_ASSERT( fStripDots ) ;
		}
	}

	return	pCache->m_WriteStuffs.SetDotStuffing(	fEnable,
													fStripDots
													) ;
}

FILEHC_EXPORT
BOOL
SetDotScanningOnWrites(
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL			fEnable
				)	{
/*++

Routine Description :

	This function modifies an FIO_CONTEXT to do dot stuffing on writes.
	We can turn on or off the dot stuffing properties.

Arguments :

	pContext - the FIO_CONTEXT that we want to modify !
	fEnable - if TRUE than we want to turn on some dot scanning behaviours !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "SetDotScanningOnWrites" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->m_WriteStuffs.SetDotScanning(	fEnable	) ;
}

FILEHC_EXPORT
void
CompleteDotStuffingOnWrites(
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL			fStripDots
				)	{

	TraceFunctEnter( "CompleteDotStuffingOnWrites" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	pCache->CompleteDotStuffing(	FALSE, fStripDots ) ;
}

FILEHC_EXPORT
BOOL
SetDotScanningOnReads(
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL			fEnable
				)	{
/*++

Routine Description :

	This function modifies an FIO_CONTEXT to do dot stuffing on writes.
	We can turn on or off the dot stuffing properties.

Arguments :

	pContext - the FIO_CONTEXT that we want to modify !
	fEnable - if TRUE than we want to turn on some dot scanning behaviours !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "SetDotScanningOnReads" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->m_ReadStuffs.SetDotScanning(	fEnable	) ;
}


FILEHC_EXPORT
BOOL
GetDotStuffState(	IN	FIO_CONTEXT*	pContext,
					IN	BOOL			fReads,
					OUT	BOOL*			pfStuffed,
					OUT	BOOL*			pfStoredWithDots
					)	{
/*++

Routine Description :

	This function gets the information from our DOT_STUFF_MANAGER
	objects as to whether we saw dots go into the streamed in file.

Arguments :

	pContext - the FIO_CONTEXT we want to examine
	fReads -   do we want to know the dot stuff state that resulted
		from reads or from writes - if TRUE then its reads
	pfStuffed - OUT parameter indicating whether

Return Value :


--*/

	TraceFunctEnter( "GetDotStuffState" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;
	_ASSERT( pfStuffed != 0 ) ;

	if( pfStuffed == 0 )	{
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	FALSE;
	}

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->GetStuffState( fReads, *pfStuffed, *pfStoredWithDots ) ;
}


FILEHC_EXPORT
void
SetDotStuffState(	IN	FIO_CONTEXT*	pContext,
					IN	BOOL			fWasScanned,
					IN	BOOL			fRequiresStuffing
					)	{
/*++

Routine Description :

	This function gets the information from our DOT_STUFF_MANAGER
	objects as to whether we saw dots go into the streamed in file.

Arguments :

	pContext - the FIO_CONTEXT we want to examine
	fReads -   do we want to know the dot stuff state that resulted
		from reads or from writes - if TRUE then its reads
	pfStuffed - OUT parameter indicating whether

Return Value :


--*/

	TraceFunctEnter( "GetDotStuffState" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	pCache->SetStuffState( fWasScanned, fRequiresStuffing ) ;
}



FILEHC_EXPORT
void
CacheRemoveFiles(	IN	LPSTR	lpstrName,
					IN	BOOL	fAllPrefixes
					)	{
/*++

Routine Description :

	This function kicks something out of the file handle cache.
	Depending on our arguments we may kick only one item - or many !

Arguments :

	lpstrName - the name of the item to kick out OR the prefix of all the files
		we are to kick out of the cache !
	fAllPrefixes - if the is TRUE then lpstrName is the prefix of a set of files
		that should be discarded, if FALSE lpstrName is the exact file name.

Return Value :

	None.

--*/

	_ASSERT( lpstrName != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	if( lpstrName == 0 ) {
		SetLastError( ERROR_INVALID_PARAMETER ) ;
	}	else	{
		if( !fAllPrefixes )	{
			CFileCacheKey	key( lpstrName ) ;
			g_pFileCache->ExpungeKey(	&key ) ;
		}	else	{
			CFileCacheExpunge	expungeObject( lpstrName, lstrlen( lpstrName ) ) ;
			g_pFileCache->ExpungeItems( &expungeObject ) ;
		}
	}
}




BOOL
CFileCacheExpunge::fRemoveCacheItem(	CFileCacheKey*	pKey,
						CFileCacheObject*	pObject
						)	{
/*++

Routine Description :

	This function determines whether we want the item booted out of the cache.

Arguments :

	pKey - the key of the cache item !
	pObject - pointer to the file cache object !

Return Value :

	TRUE if it should be booted !


--*/

	_ASSERT( pKey != 0 ) ;

	return	strncmp(	pKey->m_lpstrPath, m_lpstrName, m_cbName ) == 0 ;
}






CFileCacheObject::CFileCacheObject(	BOOL	fStoredWithDots,
									BOOL	fStoredWithTerminatingDot
									) :
	m_dwSignature( CACHE_CONTEXT ),
	m_pCacheRefInterface( 0 ),
	m_cbFileSizeLow( 0 ),
	m_cbFileSizeHigh( 0 ),
	m_fFileWasScanned( FALSE ),
	m_fRequiresStuffing( FALSE ),
	m_fStoredWithDots( fStoredWithDots ),
	m_fStoredWithTerminatingDot( fStoredWithTerminatingDot )	{
/*++

Routine Description :

	Do minimal initialization of a CFileCacheObject -
	save work for later when the Cache can have better locking !

Arguments :

	fCached - whether we are being created in the cache or not !

Return Value :

	None/

--*/

}


#ifdef	DEBUG
CFileCacheObject::~CFileCacheObject()	{
/*++

Routine Description :

	Cleanup this object - not much to do, in debug builds we mark
	the signature so we can recognize deleted objects and more
	add some more powerfull _ASSERT's

Arguments :

	Noen.

Return Value :

	None.

--*/
	_ASSERT( m_dwSignature != DEL_CACHE_CONTEXT ) ;
	m_dwSignature = DEL_CACHE_CONTEXT ;
}
#endif

CFileCacheObject*
CFileCacheObject::CacheObjectFromContext(	PFIO_CONTEXT	p	) {
/*++

Routine Description :

	Given a client PFIO_CONTEXT get the starting address of
	the containing CFileCacheObject -

Arguments :

	p - clients PFIO_CONTEXT

Return Value :

	Pointer to containing CFileCacheObject - should never be NULL !

--*/

	_ASSERT( p ) ;
	CFileCacheObject*	pReturn = 0 ;
	if( p->m_dwSignature == ATQ_ENABLED_CONTEXT ) {
		pReturn = CONTAINING_RECORD( p, CFileCacheObject, m_AtqContext ) ;
	}	else	{
		pReturn = CONTAINING_RECORD( p, CFileCacheObject, m_Context ) ;
	}
	_ASSERT( pReturn->m_dwSignature == CACHE_CONTEXT ) ;
	return	pReturn ;
}

CFileCacheObject*
CFileCacheObject::CacheObjectFromContext(	FIO_CONTEXT_INTERNAL*	p	) {
/*++

Routine Description :

	Given a client PFIO_CONTEXT_INTERNAL get the starting address of
	the containing CFileCacheObject -

Arguments :

	p - clients PFIO_CONTEXT

Return Value :

	Pointer to containing CFileCacheObject - should never be NULL !

--*/


	_ASSERT( p ) ;
	CFileCacheObject*	pReturn = 0 ;
	if( p->m_dwSignature == ATQ_ENABLED_CONTEXT ) {
		pReturn = CONTAINING_RECORD( p, CFileCacheObject, m_AtqContext ) ;
	}	else	{
		pReturn = CONTAINING_RECORD( p, CFileCacheObject, m_Context ) ;
	}
	_ASSERT( pReturn->m_dwSignature == CACHE_CONTEXT ) ;
	return	pReturn ;
}


FIO_CONTEXT_INTERNAL*
CFileCacheObject::AsyncHandle(	HANDLE	hFile	)	{
/*++

Routine Description :

	Take the given handle and setup this CFileCacheObject
	to support async IO.

Arguments :

	hFile - users File Handle !

Return Value :

	pointer to the FIO_CONTEXT_INTERNAL if successfull,
	NULL otherwise !

--*/

	TraceFunctEnter( "CFileCacheObject::AsyncHandle" ) ;

	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	DWORD dwError = 0;
	_ASSERT( m_Context.IsValid() ) ;
	_ASSERT( m_AtqContext.IsValid() ) ;

	if(	g_AtqAddAsyncHandle(	&m_AtqContext.m_pAtqContext,
							NULL,
							this,
							(ATQ_COMPLETION)Completion,
							INFINITE,
							hFile
							) )	{
		//
		//	Successfully added this ATQ !
		//
		m_AtqContext.m_dwSignature = ATQ_ENABLED_CONTEXT ;
		m_AtqContext.m_hFile = hFile ;
		pReturn = &m_AtqContext ;

		_ASSERT( m_AtqContext.m_pAtqContext != 0 ) ;
	} else {

		//
		//  Need to free the ATQ Context even if AtqAddAsyncHandle failed.
		//  See comment in atqmain.cxx
		//
		dwError = GetLastError();
		if (m_AtqContext.m_pAtqContext != NULL) {
		    //
		    // AtqFreeContext has a side-effect of closing the handle associated
		    // with it.  (It's possible that AtqAddAsyncHandle will return context
		    // even if it fails)  To keep this from happening, we yank the handle
		    // out of the context.
		    //
		    m_AtqContext.m_pAtqContext->hAsyncIO = NULL;
			//
			//  Free the context, but try to reuse this context
			//
			g_AtqFreeContext( m_AtqContext.m_pAtqContext, TRUE ) ;
			m_AtqContext.m_pAtqContext = NULL;
		}
	}

	DebugTrace( (DWORD_PTR)this, "hFile %x pReturn %x GLE %x", hFile, pReturn, dwError ) ;

	_ASSERT( m_Context.IsValid() ) ;
	_ASSERT( m_AtqContext.IsValid() ) ;
	_ASSERT( pReturn == 0 || pReturn->IsValid() ) ;

	return	pReturn ;
}


FIO_CONTEXT_INTERNAL*
CFileCacheObject::GetAsyncContext(
		class	CFileCacheKey&	key,
		class	CFileCacheConstructorBase&	constructor
		)	{
/*++

Routine Description :

	This function does the necessary work to produce
	an async context from the provided constructor !

Arguments :

	constructor - the guy who can make the file handle !

Return Value :

	The FIO_CONTEXT to use !

--*/

	TraceFunctEnter( "CFileCacheObject::GetAsyncContext" ) ;

	HANDLE	hFile = INVALID_HANDLE_VALUE ;
	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	m_lock.ShareLock() ;
	if(	m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) {
		pReturn = (FIO_CONTEXT_INTERNAL*)&m_AtqContext ;
		m_lock.ShareUnlock() ;

		DebugTrace( (DWORD_PTR)this, "ShareLock - pReturn %x", pReturn ) ;

		return	pReturn ;
	}

	if( !m_lock.SharedToExclusive() ) {

		m_lock.ShareUnlock() ;
		m_lock.ExclusiveLock() ;
		if( m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) {
			pReturn = (FIO_CONTEXT_INTERNAL*)&m_AtqContext ;
		}
	}

	DebugTrace( (DWORD_PTR)this, "Exclusive - pReturn %x", pReturn ) ;

	if( !pReturn ) {
		HANDLE	hFile = constructor.ProduceHandle(	key,
													m_cbFileSizeLow,
													m_cbFileSizeHigh
													) ;
		if( hFile != INVALID_HANDLE_VALUE ) {
			pReturn = AsyncHandle( hFile ) ;
			if( !pReturn ) {
				_VERIFY (CloseHandle( hFile )) ;
			}
		}
		DebugTrace( (DWORD_PTR)this, "Exclusive - pReturn %x hFile %x", pReturn, hFile ) ;
	}
	m_lock.ExclusiveUnlock() ;

	_ASSERT( pReturn==0 || pReturn->IsValid() ) ;

	return	pReturn ;
}

FIO_CONTEXT_INTERNAL*
CFileCacheObject::GetAsyncContext()	{
/*++

Routine Description :

	This function returns the ASYNC FIO_CONTEXT if it is available !


--*/
	TraceFunctEnter( "CFileCacheObject::GetAsyncContext" ) ;


	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	m_lock.ShareLock() ;
	if(	m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) {
		pReturn = (FIO_CONTEXT_INTERNAL*)&m_AtqContext ;
		DebugTrace( (DWORD_PTR)this, "ShareLock - pReturn %x", pReturn ) ;
	}
	m_lock.ShareUnlock() ;
	return	pReturn ;
}




FIO_CONTEXT_INTERNAL*
CFileCacheObject::GetSyncContext(
		class	CFileCacheKey&	key,
		class	CFileCacheConstructorBase&	constructor
		)	{
/*++

Routine Description :

	This function does the necessary work to produce
	an async context from the provided constructor !

Arguments :

	constructor - the guy who can make the file handle !

Return Value :

	The FIO_CONTEXT to use !

--*/

	TraceFunctEnter( "CFileCacheObject::GetSyncContext" ) ;

	HANDLE	hFile = INVALID_HANDLE_VALUE ;
	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	m_lock.ShareLock() ;
	if(	m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
		pReturn = (FIO_CONTEXT_INTERNAL*)&m_Context ;
		m_lock.ShareUnlock() ;

		DebugTrace( (DWORD_PTR)this, "ShareLock - pReturn %x", pReturn ) ;

		return	pReturn ;
	}

	if( !m_lock.SharedToExclusive() ) {

		m_lock.ShareUnlock() ;
		m_lock.ExclusiveLock() ;
		if( m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
			pReturn = (FIO_CONTEXT_INTERNAL*)&m_Context ;
		}
	}

	DebugTrace( (DWORD_PTR)this, "Exclusive - pReturn %x", pReturn ) ;

	if( !pReturn ) {
		DWORD	cbFileSizeLow = 0 ;
		DWORD	cbFileSizeHigh = 0 ;
		HANDLE	hFile = constructor.ProduceHandle(	key,
													cbFileSizeLow,
													cbFileSizeHigh
													) ;
		if( hFile != INVALID_HANDLE_VALUE ) {

			_ASSERT( m_cbFileSizeLow == 0 || m_cbFileSizeLow == cbFileSizeLow ) ;
			_ASSERT( m_cbFileSizeHigh == 0 || m_cbFileSizeHigh == cbFileSizeHigh ) ;
			m_cbFileSizeLow = cbFileSizeLow ;
			m_cbFileSizeHigh = cbFileSizeHigh ;
			SyncHandle( hFile ) ;
			pReturn = (FIO_CONTEXT_INTERNAL*)&m_Context ;
		}
		DebugTrace( (DWORD_PTR)this, "Exclusive - pReturn %x hFile %x", pReturn, hFile ) ;
	}
	m_lock.ExclusiveUnlock() ;

	_ASSERT( pReturn==0 || pReturn->IsValid() ) ;

	return	pReturn ;
}


FIO_CONTEXT_INTERNAL*
CFileCacheObject::GetSyncContext()	{
/*++

Routine Description :

	This function returns the ASYNC FIO_CONTEXT if it is available !


--*/
	TraceFunctEnter( "CFileCacheObject::GetAsyncContext" ) ;


	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	m_lock.ShareLock() ;
	if(	m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
		pReturn = (FIO_CONTEXT_INTERNAL*)&m_Context ;
		DebugTrace( (DWORD_PTR)this, "ShareLock - pReturn %x", pReturn ) ;
	}
	m_lock.ShareUnlock() ;
	return	pReturn ;
}



void
CFileCacheObject::SyncHandle(	HANDLE	hFile ) {
/*++

Routine description :

	We have a file handle setup for synchronous IO -
	save it away into our context structures !

Arguments :

	hFile - The file handle

Return Value :

	None - we always succeed !

--*/

	TraceFunctEnter( "CFileCacheObject::SyncHandle" ) ;

	m_Context.m_dwSignature = FILE_CONTEXT ;
	m_Context.m_hFile = hFile ;


	DebugTrace( (DWORD_PTR)this, "m_hFile %x", m_Context.m_hFile ) ;

	_ASSERT( m_Context.IsValid() ) ;
	_ASSERT( m_AtqContext.IsValid() ) ;
}

void
CFileCacheObject::Return()	{
/*++

Routine Description :

	This function returns a CFileCacheObject to its origin.
	We may have been created stand-alone (outside the cache)
	so we have to determine which case occurred.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheObject::Return" ) ;

	m_lock.ShareLock() ;

	DebugTrace( (DWORD_PTR)this, "m_pCacheRefInterface %x m_cRefs %x", m_pCacheRefInterface, m_cRefs ) ;

	if( m_pCacheRefInterface == 0 ) {
    	LONG l = InterlockedDecrement(&m_cRefs);
		m_lock.ShareUnlock() ;
		_ASSERT(l >= 0);
		if( l==0 )
			delete	this ;
	}	else	{
		m_lock.ShareUnlock() ;
		g_pFileCache->CheckIn( this ) ;
	}
}

void
CFileCacheObject::Reference()	{
/*++

Routine Description :

	This function adds a client reference to the file cache obejct.
	Does so in a thread safe manner !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheObject::Reference" ) ;

	m_lock.ShareLock() ;

	DebugTrace( (DWORD_PTR)this, "m_pCacheRefInterface %x m_cRefs %x", m_pCacheRefInterface, m_cRefs ) ;

	if( m_pCacheRefInterface == 0 ) {
		AddRef() ;
	}	else	{
		g_pFileCache->CheckOut( this ) ;
	}
	m_lock.ShareUnlock() ;
}


void
CFileCacheObject::SetFileSize()	{
/*++

Routine Description :

	This function will reset our file size members based on
	the handle we are holding within ourselves !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheObject::SetFileSize" ) ;

	DebugTrace( (DWORD_PTR)this, "m_pCacheRefInterface %x", m_pCacheRefInterface ) ;

	if( m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
		m_cbFileSizeLow = ::GetFileSize( m_Context.m_hFile, &m_cbFileSizeHigh ) ;
	}	else	{
		_ASSERT( m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) ;
		m_cbFileSizeLow = ::GetFileSize( m_AtqContext.m_hFile, &m_cbFileSizeHigh ) ;
	}
}



BOOL
CFileCacheObject::InsertIntoCache(
					CFileCacheKey&	keySearch,
					BOOL			fKeepReference
					)	{
/*++

Routine Description :

	This function inserts this item into the cache,
	ensuring that our reference count is correctly maintained !

Arguments :

	key - the name this item has in the cache
	fKeepReference - whether we want to keep the reference the client provided !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;
	m_lock.ExclusiveLock() ;

	SetFileSize() ;

	_ASSERT( m_pCacheRefInterface == 0 ) ;

	//
	//	Now insert the item into the cache !
	//
	if( m_AtqContext.m_pAtqContext->hAsyncIO != 0 )		{

		//
		//	Capture the dot stuffing state for all time !
		//
		m_fFileWasScanned = m_WriteStuffs.GetStuffState( m_fRequiresStuffing ) ;
		//
		//	Disable all additional Dot Stuffing !
		//
		m_WriteStuffs.SetDotStuffing( FALSE, FALSE ) ;
		//
		//	Manage the references on this guy carefully !
		//
		long	cClientRefs = m_cRefs ;
		if( !fKeepReference )
			cClientRefs -- ;

		_ASSERT( cClientRefs >= 0 ) ;
			fReturn = g_pFileCache->Insert(
											keySearch,
											this,
											cClientRefs
											) ;

		if( fReturn )	{
			m_cRefs = 1 ;
		}
	}
	m_lock.ExclusiveUnlock() ;
	return	fReturn ;
}



BOOL
CFileCacheObject::CompleteDotStuffing(
					BOOL			fReads,
					BOOL			fStripDots
					)	{
/*++

Routine Description :

	This function inserts this item into the cache,
	ensuring that our reference count is correctly maintained !

Arguments :

	key - the name this item has in the cache
	fKeepReference - whether we want to keep the reference the client provided !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;
	m_lock.ExclusiveLock() ;
	//
	//	Now insert the item into the cache !
	//
	if( m_AtqContext.m_pAtqContext->hAsyncIO != 0 )		{

		//
		//	Capture the dot stuffing state for all time !
		//
		if( fReads )	{
			m_fFileWasScanned = m_ReadStuffs.GetStuffState( m_fRequiresStuffing ) ;
			//
			//	Disable all additional Dot Stuffing !
			//
			m_ReadStuffs.SetDotStuffing( FALSE, FALSE ) ;
		}	else	{
			m_fFileWasScanned = m_WriteStuffs.GetStuffState( m_fRequiresStuffing ) ;
			if( !fStripDots )	{
				m_fRequiresStuffing = !m_fRequiresStuffing ;
			}
			//
			//	Disable all additional Dot Stuffing !
			//
			m_WriteStuffs.SetDotStuffing( FALSE, FALSE ) ;
		}
	}
	m_lock.ExclusiveUnlock() ;
	return	fReturn ;
}


BOOL
CFileCacheObject::CloseNonCachedFile(	)	{
/*++

Routine Description :

	This function closes the file handle within out ATQ context
	member !

Arguments :

	key - the name this item has in the cache
	fKeepReference - whether we want to keep the reference the client provided !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;
	m_lock.ShareLock() ;
	if( m_pCacheRefInterface == 0 &&
		m_AtqContext.m_hFile != INVALID_HANDLE_VALUE )	{
		fReturn = g_AtqCloseFileHandle( m_AtqContext.m_pAtqContext ) ;
	}
	m_lock.ShareUnlock() ;
	return	fReturn ;
}

BOOL
CFileCacheObject::GetStuffState(	BOOL	fReads,
									BOOL&	fRequiresStuffing,
									BOOL&	fStoredWithDots
									)	{
/*++

Routine Description :

	This function returns what we know about the dot stuffing state of the file !

Arguments :

	fReads - if the file has not been put in the cache then we want to get
		the dot stuffing state as computed by any reads we issued !
	fRequiresStuffing - OUT parameter which gets whether the message requires stuffing !

Return Value :

	TRUE if we know the dot stuff state, FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;
	m_lock.ShareLock() ;
	fStoredWithDots = m_fStoredWithDots ;
	if( m_pCacheRefInterface == 0 )	{
		fReturn = (fReads ? m_ReadStuffs.GetStuffState( fRequiresStuffing ) :
							m_WriteStuffs.GetStuffState( fRequiresStuffing )) ;
		if( !fReturn && m_fFileWasScanned ) {
			fReturn = m_fFileWasScanned ;
			fRequiresStuffing = m_fRequiresStuffing ;
		}
	}	else	{
		fRequiresStuffing = m_fRequiresStuffing ;
		fReturn = m_fFileWasScanned ;
	}
	m_lock.ShareUnlock() ;
	return	fReturn ;
}

void
CFileCacheObject::SetStuffState(	BOOL	fWasScanned,
									BOOL	fRequiresStuffing
									)	{
/*++

Routine Description :

	This routine sets the dot stuffing state !

Arguments :

	fReads - if the file has not been put in the cache then we want to get
		the dot stuffing state as computed by any reads we issued !
	fRequiresStuffing - OUT parameter which gets whether the message requires stuffing !

Return Value :

	TRUE if we know the dot stuff state, FALSE otherwise !

--*/

	m_lock.ExclusiveLock() ;
	m_fFileWasScanned = fWasScanned ;
	m_fRequiresStuffing = fRequiresStuffing ;
	m_lock.ExclusiveUnlock() ;
}


BOOL
CFileCacheObject::Init(	CFileCacheKey&	key,
						class	CFileCacheConstructorBase&	constructor,
						void*	pv
						)	{
/*++

Routine Description :

	Initialize a CFileCacheObject for use in the cache !
	Turns around and calls the constuctor - because there are different
	types of them, and they have appropriate virtual functions !

Arguments :

	key - Key used to create us in the cache
	constructor - constructor object that is building us
	pv -

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "CFileCacheObject::Init" ) ;

	BOOL	fReturn = FALSE ;

	DebugTrace( (DWORD_PTR)this, "key %x constructor %x pv %x m_fAsync %x",
		&key, &constructor, pv, constructor.m_fAsync ) ;

	if( constructor.m_fAsync ) {
		fReturn = GetAsyncContext( key, constructor ) != 0 ;
	}	else	{
		fReturn = GetSyncContext( key, constructor ) != 0 ;
	}
	if( fReturn ) {
		constructor.PostInit( *this, key, pv ) ;
	}

	DebugTrace( (DWORD_PTR)this, "Init - fReturn %x", fReturn ) ;

	return	fReturn ;
}

void
CFileCacheObject::Completion(
					CFileCacheObject*	pObject,
					DWORD	cbTransferred,
					DWORD	dwStatus,
					FH_OVERLAPPED*	pOverlapped
					)	{

	TraceFunctEnter( "CFileCacheObject::Completion" ) ;

	_ASSERT( pObject != 0 ) ;
	_ASSERT( pObject->m_AtqContext.IsValid() ) ;
	_ASSERT( pObject->m_AtqContext.m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pOverlapped->pfnCompletion != 0 ) ;

	DebugTrace( (DWORD_PTR)pObject, "Complete - pObject %x cb %x dw %x pOvl %x pfn %x",
		pObject, cbTransferred, dwStatus, pOverlapped, pOverlapped->pfnCompletion ) ;

	//
	//	Before doing anything with this - give a chance to our dot manipulation
	//	code to handle this !
	//


	//
	//	Call their completion function !
	//
	pOverlapped->pfnCompletion( (PFIO_CONTEXT)&pObject->m_AtqContext,
								pOverlapped,
								cbTransferred,
								dwStatus
								) ;
}


CFileCacheConstructor::CFileCacheConstructor(
		LPVOID	lpv,
		FCACHE_CREATE_CALLBACK	pCreate,
		BOOL	fAsync
		) :
	CFileCacheConstructorBase( fAsync ),
	m_lpv( lpv ),
	m_pCreate( pCreate )	{
/*++

Routine Description :

	This function sets up a File Cache Constructor object -
	we capture the arguments that are going to be used if
	the cache decides the item isn't found and wants to use us !

Arguments :

	lpv - Arg to pass to callback function
	pCreate - the function which can create a handle
	fAsync - TRUE if we want to do Async IO on the handle

Return Value :

	None.

--*/
}


CFileCacheObject*
CFileCacheConstructorBase::Create(
				CFileCacheKey&	key,
				void*	pv
				)	{
/*++

Routine Description :

	This function creates allocates mem for and
	does initial construction of CFileCacheObject's

Arguments :

	key - contains name of the file
	pv -

Return Value :

	Pointer to a newly allocated CFileCacheObject

--*/
	return	new	CFileCacheObject(FALSE,FALSE) ;
}


void
CFileCacheConstructorBase::Release(
				CFileCacheObject*	p,
				void*	pv
				)	{
/*++

Routine Description :

	This function releases a CFileCacheObject !

Arguments :

	p - the object ot be released !
	pv -

Return Value :

	Nothing !

--*/

	p->Release() ;
}

void
CFileCacheConstructorBase::StaticRelease(
				CFileCacheObject*	p,
				void*	pv
				)	{
/*++

Routine Description :

	This function releases a CFileCacheObject !

Arguments :

	p - the object ot be released !
	pv -

Return Value :

	Nothing !

--*/
	p->Release() ;
}


CRichFileCacheConstructor::CRichFileCacheConstructor(
		LPVOID	lpv,
		FCACHE_RICHCREATE_CALLBACK	pCreate,
		BOOL	fAsync
		) :
	CFileCacheConstructorBase( fAsync ),
	m_lpv( lpv ),
	m_fStoredWithDots( FALSE ),
	m_fStoredWithTerminatingDot( FALSE ),
	m_pCreate( pCreate )	{
/*++

Routine Description :

	This function sets up a File Cache Constructor object -
	we capture the arguments that are going to be used if
	the cache decides the item isn't found and wants to use us !

Arguments :

	lpv - Arg to pass to callback function
	pCreate - the function which can create a handle
	fAsync - TRUE if we want to do Async IO on the handle

Return Value :

	None.

--*/
}




HANDLE
CRichFileCacheConstructor::ProduceHandle(
										CFileCacheKey&	key,
										DWORD&	cbFileSizeLow,
										DWORD&	cbFileSizeHigh
										)	{
/*++

Routine Description :

	This function initializes a CFileCacheObject.
	This function is virtual, and this is one of the several
	ways that CFileCacheObjects can be setup.

Arguments :

	object - the CFileCacheObject we are to initialize
	key - the filename key used to create ue
	pv - Extra args

Return Value :

	TRUE if we successfully initialize !

--*/

	TraceFunctEnter( "CRichFileCacheConstructor::ProduceHandle" ) ;

	_ASSERT( cbFileSizeLow == 0 ) ;
	_ASSERT( cbFileSizeHigh == 0 ) ;

	BOOL	fReturn = FALSE ;

	//
	//	We have work to do to create the file !
	//

	HANDLE	h = m_pCreate(	key.m_lpstrPath,
							m_lpv,
							&cbFileSizeLow,
							&cbFileSizeHigh,
							&m_fFileWasScanned,
							&m_fRequiresStuffing,
							&m_fStoredWithDots,
							&m_fStoredWithTerminatingDot
							) ;

	DebugTrace( (DWORD_PTR)this, "h %x lpstrPath %x m_lpv %x cbFilesize %x",
		h, key.m_lpstrPath, m_lpv, cbFileSizeLow ) ;

	return	h ;
}


BOOL
CRichFileCacheConstructor::PostInit(
					CFileCacheObject&	object,
					CFileCacheKey&		key,
					void*	pv
					)	{

	object.m_fFileWasScanned = m_fFileWasScanned ;
	object.m_fRequiresStuffing = m_fRequiresStuffing ;
	object.m_fStoredWithDots = m_fStoredWithDots ;
	object.m_fStoredWithTerminatingDot = m_fStoredWithTerminatingDot ;

	return	TRUE ;
}





HANDLE
CFileCacheConstructor::ProduceHandle(	CFileCacheKey&	key,
										DWORD&	cbFileSizeLow,
										DWORD&	cbFileSizeHigh
										)	{
/*++

Routine Description :

	This function initializes a CFileCacheObject.
	This function is virtual, and this is one of the several
	ways that CFileCacheObjects can be setup.

Arguments :

	object - the CFileCacheObject we are to initialize
	key - the filename key used to create ue
	pv - Extra args

Return Value :

	TRUE if we successfully initialize !

--*/

	TraceFunctEnter( "CFileCacheConstructor::ProduceHandle" ) ;

	//_ASSERT( cbFileSizeLow == 0 ) ;
	//_ASSERT( cbFileSizeHigh == 0 ) ;

	BOOL	fReturn = FALSE ;

	//
	//	We have work to do to create the file !
	//

	HANDLE	h = m_pCreate(	key.m_lpstrPath,
							m_lpv,
							&cbFileSizeLow,
							&cbFileSizeHigh
							) ;

	DebugTrace( (DWORD_PTR)this, "h %x lpstrPath %x m_lpv %x cbFilesize %x",
		h, key.m_lpstrPath, m_lpv, cbFileSizeLow ) ;

	return	h ;
}


BOOL
CFileCacheConstructor::PostInit(
					CFileCacheObject&	object,
					CFileCacheKey&		key,
					void*	pv
					)	{
	return	TRUE ;
}

#if 0
BOOL
CFileCacheConstructor::Init(
					CFileCacheObject&	object,
					CFileCacheKey&		key,
					void*	pv
					)	{
/*++

Routine Description :

	This function initializes a CFileCacheObject.
	This function is virtual, and this is one of the several
	ways that CFileCacheObjects can be setup.

Arguments :

	object - the CFileCacheObject we are to initialize
	key - the filename key used to create ue
	pv - Extra args

Return Value :

	TRUE if we successfully initialize !

--*/

	DWORD	cbFileSize = 0 ;
	BOOL	fReturn = FALSE ;

	object.m_Lock.ExclusiveLock() ;

	if( (m_fAsync &&
		object.m_AtqContext.m_hFile == INVALID_HANDLE_VALUE)	||
		(!m_fAsync &&
		object.m_Context.m_hFile == INVALID_HANDLE_VALUE) )	{

		//
		//	We have work to do to create the file !
		//

		HANDLE	h = m_pCreate(	key.m_lpstrPath,
								m_lpv,
								&cbFileSize
								) ;

		if( h != INVALID_HANDLE_VALUE ) {

			_ASSERT( cbFileSize != 0 ) ;

			if( m_fAsync ) {
				if( object.AsyncHandle( h ) != 0 ) {
					fReturn = TRUE ;
				}	else	{
					CloseHandle( h ) ;
				}
			}	else	{
				fReturn = TRUE ;
				object.SyncHandle( h ) ;
			}
		}
	}
	object.m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\dll\fcachimp.h ===
/*++

	FCACHIMP.H

	This file contains a lot of the internal guts of the 
	File Handle Cache structures.


--*/


#ifndef	_FCACHIMP_H_
#define	_FCACHIMP_H_

#define	_FILEHC_IMPLEMENTATION_
#ifndef _NT4_TEST_
#endif
#include	"atq.h"
#include	"irtlmisc.h"
#include	"xmemwrpr.h"
#include	"dbgtrace.h"
#include	"cache2.h"
#include	"filehc.h"
#include	"dotstuff.h"
#include	"sdcache.h"

// Non Public portions -
	

#include	"refptr2.h"
#include	"rwnew.h"
#include	"crchash.h"


//
//	Define a smart pointer for Dot Stuffing objects !
//
typedef	CRefPtr2< IDotManipBase >	DOTPTR ;
typedef	CRefPtr2HasRef< IDotManipBase >	DOTHASREFPTR ;


//
//	The following defines all of the functions that we call into
//	IIS and Atq to accomplish our async IO stuff !
//
typedef	
BOOL
(*PFNAtqInitialize)(
    IN DWORD dwFlags
    );

typedef	
BOOL
(*PFNAtqTerminate)(
    VOID
    );

typedef	
BOOL
(WINAPI
*PFNAtqAddAsyncHandle)(
    OUT PATQ_CONTEXT * ppatqContext,
    IN  PVOID          EndpointObject,
    IN  PVOID          ClientContext,
    IN  ATQ_COMPLETION pfnCompletion,
    IN  DWORD          TimeOut,
    IN  HANDLE         hAsyncIO
    );

typedef
BOOL
(*PFNAtqCloseSocket)(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    );

typedef
BOOL
(*PFNAtqCloseFileHandle)(
    PATQ_CONTEXT patqContext
    );


typedef
VOID
(*PFNAtqFreeContext)(
    IN PATQ_CONTEXT   patqContext,
    BOOL              fReuseContext
    );


typedef	
BOOL
(WINAPI
*PFNAtqReadFile)(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID       lpBuffer,
    IN  DWORD        BytesToRead,
    IN  OVERLAPPED * lpo OPTIONAL
    );

typedef
BOOL
(WINAPI
*PFNAtqWriteFile)(
    IN  PATQ_CONTEXT patqContext,
    IN  LPCVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

typedef	
BOOL
(WINAPI
*PFNAtqIssueAsyncIO)(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

typedef	
BOOL
(WINAPI
*PFNInitializeIISRTL)();

// call before unloading
typedef
void
(WINAPI
*PFNTerminateIISRTL)();



//
//	The DLL's we load to do this stuff !
//
extern	HINSTANCE			g_hIsAtq ;
extern	HINSTANCE			g_hIisRtl ;
//
//	Function pointers for all our thunks into IIS stuff !
//
extern	PFNAtqInitialize	g_AtqInitialize ;
extern	PFNAtqTerminate		g_AtqTerminate ;
extern	PFNAtqAddAsyncHandle	g_AtqAddAsyncHandle ;
extern	PFNAtqCloseFileHandle	g_AtqCloseFileHandle ;
extern	PFNAtqFreeContext		g_AtqFreeContext ;
extern	PFNAtqIssueAsyncIO		g_AtqReadFile ;
extern	PFNAtqIssueAsyncIO		g_AtqWriteFile ;
extern	PFNInitializeIISRTL		g_InitializeIISRTL ;
extern	PFNTerminateIISRTL		g_TerminateIISRTL ;

//
//	The lifetime of each cache entry - in seconds !
//
extern	DWORD	g_dwLifetime ;	// default is 30 minutes
//
//	The maximum number of elements the cache should allow
//
extern	DWORD	g_cMaxHandles ;	// default - 10000 items !
//
//	The number of subcaches we should use - larger number can
//	increase parallelism and reduce contention !
//
extern	DWORD	g_cSubCaches ;


//
//	These constants are used within the API's
//	on structures we export to users !
//
enum	INTERNAL_CONSTANTS	{
	ATQ_ENABLED_CONTEXT = 'banE',
	FILE_CONTEXT = 'eliF',
	CACHE_CONTEXT = 'caCF',
	DEL_FIO = 'eliX',
	DEL_CACHE_CONTEXT = 'caCX',
	ILLEGAL_CONTEXT = 'ninU'
} ;

//
//	The function that initializes all of the data structures for the
//	name cache manager !
//
extern	BOOL	InitNameCacheManager() ;
extern	void	TermNameCacheManager() ;


struct	DOT_STUFF_MANAGER	{
/*++

	This class will manage the offsets and stuff that we need to track dot stuffing changes

--*/

	//
	//	This is the accumulated bias against the users writes which we add to
	//	the offsets of their writes !
	//
	int	m_cbCumulativeBias ;
	
	//
	//	The object which intercepts and manipulates buffers !
	//
	DOTPTR	m_pManipulator ;

	//
	//	Set our intial state to a blank slate !
	//
	DOT_STUFF_MANAGER() :
		m_cbCumulativeBias( 0 ),
		m_pManipulator( 0 )	{
	}

	//
	//	Helper function which manipulates the requested IO !
	//
	BOOL
	IssueAsyncIO(
			IN	PFNAtqIssueAsyncIO	pfnIO,
			IN	PATQ_CONTEXT	patqContext,
			IN	LPVOID			lpb,
			IN	DWORD			BytesToTransfer,
			IN	DWORD			BytesAvailable,
			IN	FH_OVERLAPPED*	lpo,
			IN	BOOL			fFinalIO,
			IN	BOOL			fTerminatorIncluded
			) ;

	//
	//	Helper function for when we need to capture the IO when it completes
	//
	BOOL
	IssueAsyncIOAndCapture(
			IN	PFNAtqIssueAsyncIO	pfnIO,
			IN	PATQ_CONTEXT		patqContext,
			IN	LPVOID				lpb,
			IN	DWORD				BytesToTransfer,
			IN	FH_OVERLAPPED*		lpo,
			IN	BOOL				fFinalIO,
			IN	BOOL				fTerminatorIncluded
			) ;


	//
	//	This function manipulates completions that were issued by IssueAsyncIO()
	//
	static	void
	AsyncIOCompletion(	
			IN	FIO_CONTEXT*	pContext,
			IN	FH_OVERLAPPED*	lpo,
			IN	DWORD			cb,
			IN	DWORD			dwCompletionStatus
			) ;

	static	void
	AsyncIOAndCaptureCompletion(	
			IN	FIO_CONTEXT*	pContext,
			IN	FH_OVERLAPPED*	lpo,
			IN	DWORD			cb,
			IN	DWORD			dwCompletionStatus
			) ;

	//
	//	Setup the dot stuffing state of this item !
	//
	BOOL
	SetDotStuffing(	BOOL	fEnable,
					BOOL	fStripDots
					) ;

	//
	//	Setup the dot scanning state of this item !
	//
	BOOL
	SetDotScanning(	BOOL	fEnable	) ;

	//
	//	Return the results of our dot scanning efforts !
	//
	BOOL
	GetStuffState(	BOOL&	fStuffed ) ;

} ;



struct	FIO_CONTEXT_INTERNAL	{
	DWORD		m_dwHackDword ;	
	//
	//	The context signature !
	//
	DWORD		m_dwSignature ;
	//
	//	The file handle associated with the completion context !
	//
	HANDLE		m_hFile ;
    //
    //  Offset to lines header to back fill from
    //
    DWORD       m_dwLinesOffset;
    //
    //  Header length, nntp aware only
    //
    DWORD       m_dwHeaderLength;
	//
	//	Pointer to the AtqContext associated with this file !
	//
	PATQ_CONTEXT	m_pAtqContext ;

	BOOL
	IsValid()	{
		if( m_dwSignature == DEL_FIO )	{
			return	FALSE ;
		}	else	if( m_dwSignature == ILLEGAL_CONTEXT ) {
			if( m_hFile != INVALID_HANDLE_VALUE )
				return	FALSE ;
			if( m_pAtqContext != 0 )
				return	FALSE ;
		}	else if( m_dwSignature == FILE_CONTEXT ) {
			if( m_hFile == INVALID_HANDLE_VALUE )
				return	FALSE ;
			if( m_pAtqContext != 0 )
				return	FALSE ;
		}	else if( m_dwSignature == ATQ_ENABLED_CONTEXT ) {
			if( m_hFile == INVALID_HANDLE_VALUE )
				return	FALSE ;
			if( m_pAtqContext == 0 )
				return	FALSE ;
			if( m_pAtqContext->hAsyncIO != m_hFile && m_pAtqContext->hAsyncIO != 0 )
				return	FALSE ;
		}	else	{
			return	FALSE ;
		}
		return	TRUE ;
	}

	//
	//	
	//
	FIO_CONTEXT_INTERNAL() :
		m_dwSignature( ILLEGAL_CONTEXT ),
		m_hFile( INVALID_HANDLE_VALUE ),
		m_pAtqContext( 0 ) {
	}

	~FIO_CONTEXT_INTERNAL()	{
		//
		//	Make sure we haven't been destroyed once already !
		//
		_ASSERT( m_dwSignature !=	DEL_FIO ) ;
		if( m_hFile != INVALID_HANDLE_VALUE ) {
			_ASSERT( IsValid() ) ;
			if( m_pAtqContext != 0 ) {
				_VERIFY( g_AtqCloseFileHandle( m_pAtqContext ) ) ;
				//
				//	NOTE : probably destroyed on an expiration
				//	thread - can't reuse the AtqContext !
				//
				g_AtqFreeContext( m_pAtqContext, FALSE ) ;
			}	else	{
				_VERIFY( CloseHandle( m_hFile ) ) ;
			}
		}
		//
		//	Mark this thing as dead !
		//
		m_dwSignature = DEL_FIO ;
	}

} ;



class	CFileCacheKey	{
/*++

Class Description :

	This class is the key for entries into our file handle cache !

--*/
private :

	//
	//	This constructor is private -
	//
	CFileCacheKey() ;

	//
	//	Constants for our class
	//
	enum	CONSTANTS	{
		BUFF_SIZE	= 254,
	} ;

	//
	//	Buffer for the path !
	//
	char		m_szBuff[BUFF_SIZE] ;
	//
	//	Length of the path !
	//
	DWORD		m_cbPathLength ;
public :

	//
	//	Pointer to the path !	
	//
	LPSTR		m_lpstrPath ;

	//
	//	Determine whether we have a valid Cache Key !
	//
	BOOL
	IsValid()  ;

	//
	//	Construct one of these objects from the user provided key !
	//
	CFileCacheKey(	LPSTR	lpstr	) ;
	
	//
	//	We must have a Copy Constructor ! -
	//	It is only used the MultiCacheEx<>, so
	//	we safely wipe out the RHS CFileCacheKey !
	//
	CFileCacheKey(	CFileCacheKey&	key ) ;

	//
	//	Tell the client whether we're usable !
	//
	BOOL
	FInit()	;

	//
	//	Destroy ourselves !
	//
	~CFileCacheKey() ;

	static
	DWORD
	FileCacheHash(	CFileCacheKey*	p )	;

	static
	int
	MatchKey(	CFileCacheKey*	pLHS, CFileCacheKey*  pRHS ) ;
} ;



class	CCacheKey	{
private : 
	//
	//	The name of this name cache !	
	//
	LPSTR			m_lpstrName ;
	//
	//	Client provided arguments for the name cache !
	//
	CACHE_KEY_COMPARE	m_pfnCompare ;
	//
	//
	//
	CACHE_DESTROY_CALLBACK	m_pfnKeyDestroy ;
	//
	//
	//
	CACHE_DESTROY_CALLBACK	m_pfnDataDestroy ;
	//
	//	Can't construct without arguments 
	//
	CCacheKey() ;
	//
	//	A CNameCacheInstance gets to peek inside !
	//
	friend	class	CNameCacheInstance ;
	//
	//	The key's of name caches get to peek inside at 
	//	the function pointers we hold within !
	//
	friend	class	CNameCacheKey ;
public : 
	//
	//	Client provided hash function 
	//	
	CACHE_KEY_HASH		m_pfnHash ;
	
	inline
	CCacheKey(	LPSTR	lpstrName, 
				CACHE_KEY_COMPARE	pfnCompare, 
				CACHE_KEY_HASH		pfnKeyHash, 
				CACHE_DESTROY_CALLBACK	pfnKeyDestroy, 
				CACHE_DESTROY_CALLBACK	pfnDataDestroy
				) : 
		m_lpstrName( lpstrName ), 
		m_pfnCompare( pfnCompare ),
		m_pfnHash( pfnKeyHash ),
		m_pfnKeyDestroy( pfnKeyDestroy ), 
		m_pfnDataDestroy( pfnDataDestroy )	{
		_ASSERT(IsValid()) ;
	}

	//
	//	Check that we're correctly setup !
	//
	BOOL
	IsValid() ;

	//
	//	Free the embedded string !
	//	called by the destructor for ~CNameCacheInstance !
	//
	void
	FreeName()	{
		delete[]	m_lpstrName ;
	}
	

	//
	//	Compare two keys for equality !
	//
	static	int	
	MatchKey(	CCacheKey*	pKeyLeft,	
				CCacheKey*	pKeyRight
				) ;

	//
	//	Compute the hash function of a key !	
	//
	static	DWORD
	HashKey(	CCacheKey*	pKeyLeft ) ;
} ;	


class	CNameCacheKey	{
protected : 
	enum	CONSTANTS	{
		//
		//	Number of bytes we use off stack when we need to 
		//	extract a key for a client !
		//
		CB_STACK_COMPARE=2048,
		//
		//	Number of bytes we will embed within a key !
		//
		CB_EMBEDDED=192
	} ;

	//
	//	Byte array holding embeddable portion of the key !
	//
	BYTE					m_rgbData[CB_EMBEDDED] ;
	//
	//	The hash function of our key !
	//
	DWORD					m_dwHash ;
	//
	//	user provided key comparison function !
	//
	class	CCacheKey*		m_pCacheData ;
	//
	//	Number of bytes used to hold the key
	//
	DWORD					m_cbKey ;
	//
	//	Number of bytes used to hold client data !
	//
	DWORD					m_cbData ;
	//
	//	pointer for any portion we could not hold completely 
	//	within the key object !
	//
	LPBYTE					m_lpbExtra ;

	//
	//	Nobody is allowed to create these guys externally !
	//
	CNameCacheKey() : 
		m_dwHash( 0 ), 
		m_pCacheData( 0 ), 
		m_cbKey( 0 ),
		m_cbData( 0 ),
		m_lpbExtra( 0 ),
		m_pSD( 0 ) {
	}

	//
	//	Available for derived classes !
	//
	CNameCacheKey(
			DWORD	dwHash, 
			CCacheKey*	pCacheData, 
			PTRCSDOBJ&	pSD
			) : 
		m_dwHash( dwHash ), 
		m_pCacheData( pCacheData ), 
		m_pSD( pSD ), 
		m_lpbExtra( 0 ), 
		m_cbData( 0 )	{
	}

public : 

	//
	//	pointer to a Security Descriptor that a user associated
	//	with this name !
	//
	PTRCSDOBJ				m_pSD ;

	//
	//	Construct this guy from a copy - note the copy may be 
	//	a derived class with a different implementation !
	//
	CNameCacheKey(	CNameCacheKey&	key )	{

		_ASSERT(key.fCopyable() ) ;
		_ASSERT(key.m_cbKey != 0 ) ;
		_ASSERT(key.IsValid() ) ;

		m_cbKey = key.m_cbKey ;
		m_cbData = key.m_cbData ;

		CopyMemory( m_rgbData, key.m_rgbData, min(sizeof(m_rgbData), m_cbData+m_cbKey) ) ;

		m_dwHash = key.m_dwHash ;		
		m_pCacheData = key.m_pCacheData ;
		m_pSD = key.m_pSD ;
		m_lpbExtra = key.m_lpbExtra ;

		//
		//	Make the key useless and invalid !
		//		
		key.m_cbKey = 0 ;
		key.m_cbData = 0 ;
		key.m_lpbExtra = 0 ;

		_ASSERT(IsValid()) ;
	} 

	//
	//	Check that the key appears to be in a valid state !
	//
	virtual	BOOL
	IsValid()	{
		BOOL	fValid = TRUE ;

		fValid &= m_cbKey != 0 ;
		if( m_cbKey + m_cbData < sizeof(m_rgbData) ) {
			fValid &= m_lpbExtra == 0 ;
		}	else	{
			fValid &= m_lpbExtra != 0 ;
		}
		_ASSERT( fValid ) ;
		//fValid &= m_pSD != 0 ;
		fValid &= m_pCacheData != 0 ;
		_ASSERT( fValid ) ;
		return	fValid ;
	}

	//
	//	this function gets the key that we need to compare out of the object
	//
	virtual	inline
	LPBYTE	RetrieveKey(	DWORD&	cb ) {
		_ASSERT( IsValid() ) ;
		cb = m_cbKey ;
		if( m_cbKey < sizeof(m_rgbData) ) {
			if( m_cbKey != 0 ) {
				return	m_rgbData ;
			}	else	{
				return	0 ;
			}
		}	
		_ASSERT( m_lpbExtra != 0 ) ;
		return	m_lpbExtra ;
	}

	//
	//	return the data portion of the key to the caller !
	//
	virtual	inline
	LPBYTE	RetrieveData(	DWORD&	cb )	{
		cb = m_cbData ;
		if( cb==0 ) {
			return	0 ;
		}
		if( (m_cbKey + m_cbData) < sizeof( m_rgbData ) ) {
			return	&m_rgbData[m_cbKey] ;
		}	else	if( m_cbKey < sizeof( m_rgbData ) ) {
			return	m_lpbExtra ;
		}	else	{
			return	&m_lpbExtra[m_cbKey] ;
		}
	}


	//
	//	Destructor is virtual as we have derived classes !
	//	(although we probably aren't destroyed through pointers).
	//
	virtual
	~CNameCacheKey()	{
		if(	m_pCacheData )	{
			if( m_pCacheData->m_pfnKeyDestroy ) {
				DWORD	cb ;
				LPBYTE	lpb = RetrieveData( cb ) ;
				if( lpb )	{
					m_pCacheData->m_pfnKeyDestroy(	cb, lpb ) ;
				}
			}
			if( m_pCacheData->m_pfnDataDestroy ) {
				DWORD	cb ;
				LPBYTE	lpb = RetrieveData( cb ) ;
				if( lpb ) {
					m_pCacheData->m_pfnDataDestroy( cb, lpb ) ;
				}
			}
		}
		if( m_lpbExtra )	{
			delete[]	m_lpbExtra ;
		}
	}

	//
	//	Define a virtual function to determine whether a derived
	//	class is copyable !
	//
	virtual	inline	BOOL
	fCopyable()	{	return	FALSE ;	}

	//
	//	Define virtual function for doing stuff when we get
	//	a match on the name !
	//
	virtual	inline	void
	DoWork(	CNameCacheKey*	pKey ) {}

	//
	//	Helper function gets the hash value for the key !
	//
	static	inline
	DWORD
	NameCacheHash(	CNameCacheKey*	p )	{
		return	p->m_dwHash ;
	}

	//
	//	Compare two keys !
	//
	static
	int
	MatchKey(	CNameCacheKey*	pLHS, 
				CNameCacheKey*  pRHS 
				)	{

		LPBYTE	lpbLHS, lpbRHS ;
		DWORD	cbLHS, cbRHS ;

		lpbLHS = pLHS->RetrieveKey( cbLHS ) ;
		lpbRHS = pRHS->RetrieveKey( cbRHS ) ;

		_ASSERT(lpbLHS && lpbRHS && cbLHS && cbRHS ) ;

		int	i = pLHS->m_pCacheData->m_pfnCompare( cbLHS, lpbLHS, cbRHS, lpbRHS ) ;

		if( i==0 ) {
			pLHS->DoWork( pRHS ) ;
			pRHS->DoWork( pLHS ) ;
		}
		return	i ;
	}

	//
	//	
	//
	BOOL	DelegateAccessCheck(	HANDLE		hToken, 
									ACCESS_MASK	accessMask, 
									CACHE_ACCESS_CHECK	pfnAccessCheck
									)	{
		if( !m_pSD ) {
			return	TRUE ;
		}	else	{
			return	m_pSD->AccessCheck(	hToken, accessMask, pfnAccessCheck ) ;
		}
	}

} ;

//
//	This object is only used to search for existing entries in the 
//	cache !
//
class	CNameCacheKeySearch : public	CNameCacheKey	{
private : 

	//
	//	This points to client provided buffers for the key 
	//
	LPBYTE		m_lpbClientKey ;

	//
	//	Client provided length of the key 
	//
	DWORD		m_cbClientKey ;

	//
	//	Client provided context for the read callback 
	//
	LPVOID		m_lpvContext ;

	//
	//	Client provided function pointer which gets to examine the data 
	//	in the key !
	//
	CACHE_READ_CALLBACK		m_pfnCallback ;

	//
	//	should we extract the security descriptor !
	//
	BOOL		m_fGetSD ;
	
public : 

	//
	//	Construct one of these 
	//
	CNameCacheKeySearch(
		LPBYTE	lpbKey, 
		DWORD	cbKey, 
		DWORD	dwHash, 
		LPVOID	lpvContext,
		CACHE_READ_CALLBACK	pfnCallback, 
		BOOL	fGetSD
		) :	m_lpbClientKey( lpbKey ), 
		m_cbClientKey( cbKey ), 
		m_lpvContext( lpvContext ),
		m_pfnCallback( pfnCallback ), 
		m_fGetSD( fGetSD )	{
		m_dwHash = dwHash ;
	}

	//
	//	Determine whether a search key is valid !
	//
	BOOL
	IsValid()	{
		_ASSERT( m_lpbClientKey != 0 ) ;
		_ASSERT( m_cbClientKey != 0 ) ;

		return	m_lpbClientKey != 0 &&
				m_cbClientKey != 0 ;
	}

	//
	//	this function gets the key that we need to compare out of the object
	//
	inline
	LPBYTE	RetrieveKey(	DWORD&	cb ) {
		_ASSERT( IsValid() ) ;
		cb = m_cbClientKey ;
		return	m_lpbClientKey ;
	}

	//
	//	called when we have a match for an item in the cache - 
	//	this gives us a chance to let the caller see the embedded
	//	data associated with the name !
	//
	void
	DoWork(	CNameCacheKey*	pBuddy )	{
		if( m_fGetSD ) {
			m_pSD = pBuddy->m_pSD ;
		}
		DWORD	cbData ;
		LPBYTE	lpbData = pBuddy->RetrieveData( cbData ) ;
		if( cbData < sizeof( m_rgbData ) ) {
			CopyMemory( m_rgbData, lpbData, cbData ) ;
			m_cbData = cbData ;
		}	else	{
			if( m_pfnCallback )	{
				m_pfnCallback(	cbData, 
								lpbData, 
								m_lpvContext
								) ;
				m_pfnCallback = 0 ;
			}
		}
	}	

	//
	//	second chance to call the client callback 
	//	We may just copy the client's data out of his key 
	//	buffer to avoid expensive work in his function callbacks !
	//
	void
	PostWork()	{
		if( m_pfnCallback )	{
			m_pfnCallback( m_cbData, m_rgbData, m_lpvContext ) ;
		}
	}
} ;

//
//	This is the object we setup when we wish to insert an item into 
//	the name cache - we do all the mem allocs etc... that are 
//	required !
//	
class	CNameCacheKeyInsert	:	public	CNameCacheKey	{
public : 

	CNameCacheKeyInsert(	
		LPBYTE	lpbKey, 
		DWORD	cbKey, 
		LPBYTE	lpbData, 
		DWORD	cbData, 
		DWORD	dwHash, 
		CCacheKey*	pCacheData, 
		PTRCSDOBJ&	pCSDOBJ, 
		BOOL&	fInit
		) : CNameCacheKey(	dwHash, pCacheData, pCSDOBJ ) {

		_ASSERT( lpbKey != 0 ) ;
		_ASSERT( cbKey != 0 ) ;
		_ASSERT(	(lpbData == 0 && cbData == 0) ||
					(lpbData != 0 && cbData != 0) ) ;
		_ASSERT( pCacheData != 0 ) ;
		//_ASSERT( pCSDOBJ != 0 ) ;
	
		fInit = TRUE ;

		if(	cbKey < sizeof( m_rgbData ) ) {
			CopyMemory( m_rgbData, lpbKey, cbKey ) ;
			m_cbKey = cbKey ;
			if( cbData != 0 ) {
				if( cbData + cbKey < sizeof( m_rgbData ) ) {
					CopyMemory( m_rgbData+m_cbKey, lpbData, cbData ) ;
				}	else	{
					m_lpbExtra = new	BYTE[cbData] ;
					if( m_lpbExtra == 0 ) {
						fInit = FALSE ;
					}	else	{
						CopyMemory( m_lpbExtra, lpbData, cbData ) ;
					}
				}
			}
			m_cbData = cbData ;
		}	else	{
			m_lpbExtra = new	BYTE[cbData+cbKey] ;
			if( !m_lpbExtra ) {
				fInit = FALSE ;
			}	else	{
				CopyMemory( m_lpbExtra, lpbKey, cbKey ) ;
				m_cbKey = cbKey ;
				if( lpbData ) {
					CopyMemory( m_lpbExtra+m_cbKey, lpbData, cbData ) ;
				}
				m_cbData = cbData;
			}
		}
		_ASSERT( !fInit || IsValid() ) ;
	}


	//
	//	indicate whether this object is copyable !
	//
	BOOL
	fCopyable( )	{
		return	TRUE ;
	}

} ;



#define	FILECACHE_MAX_PATH	768


class	CFileCacheObject : public	CRefCount2	{
private :
	//
	//	My Signature !
	//
	DWORD							m_dwSignature ;

	//
	//	The optional file handle context
	//
	FIO_CONTEXT_INTERNAL			m_AtqContext ;

	//
	//	The optional file handle which is not assoicated with a
	//	completion context !
	//
	FIO_CONTEXT_INTERNAL			m_Context ;

	//
	//	The size of the file - high and low DWORD's
	//
	DWORD							m_cbFileSizeLow ;
	DWORD							m_cbFileSizeHigh ;

	//
	//	The lock used to protect this object !
	//
	class	CShareLockNH			m_lock ;
	//
	//	These constructors are private as we only want
	//	to have one possible construction method in the public space !
	//
	CFileCacheObject( CFileCacheObject& ) ;

	//
	//	Our constructors are our friends !
	//
	friend	class	CRichFileCacheConstructor ;
	friend	class	CFileCacheConstructor ;

	//
	//	some functions are friends so that they can get to the Dot Stuff managers !
	//
	

	//
	//	The completion function we give to ATQ!
	//
	static
	void
	Completion(	CFileCacheObject*	p,
				DWORD	cbTransferred,
				DWORD	dwStatus,
				FH_OVERLAPPED*	pOverlapped
				) ;
				

public :

	//
	//	Public member required by templates
	//
	class	ICacheRefInterface*	m_pCacheRefInterface ;

	//
	//	The code that does dot stuffing things !
	//
	DOT_STUFF_MANAGER				m_ReadStuffs ;
	//
	//	The code that does dot stuffing on writes !
	//
	DOT_STUFF_MANAGER				m_WriteStuffs ;

	//
	//	The following represent the Dot Stuffing state of an FIO_CONTEXT
	//	that has been inserted into the file handle cache.
	//	This state is meaningless until the file has been inserted into the
	//	cache !
	//
	//	Was the message examined to determine its dot stuff state !
	//
	BOOL							m_fFileWasScanned ;
	//
	//	If m_fFileWasScanned == TRUE then this will tell us whether the
	//	file need to be dot stuffed for protocols that require transmission
	//	to occur with dots !
	//
	BOOL							m_fRequiresStuffing ;
	//
	//	This is set by the user either through AssociateFileEx() or CacheRichCreateFile,
	//	in either case, if TRUE it indicates that this file should be stored with
	//	extra dot stuffing - i.e. the NNTP on the wire format.  if FALSE then this
	//	is stored without Dot Stuffing - i.e. the Exchange Store's native format.
	//
	BOOL							m_fStoredWithDots ;
	//
	//	This is set by the user either directly through SetIsFileDotTerminated()	
	//	or through AssociateFileEx(), as well as through FCACHE_RICHCREATE_CALLBACK
	//	And is used by ProduceDotStuffedContextInContext() to determine whether
	//	the terminating dot is present !
	//	
	BOOL							m_fStoredWithTerminatingDot ;
	
	//	
	//	Construct a CFileCacheObject !	
	//
	CFileCacheObject(	BOOL	fStoredWithDots,
						BOOL	fStoredWithTerminatingDot  ) ;

#ifdef	DEBUG
	//
	//	The destructor just marks our signature as dead !
	//
	~CFileCacheObject() ;
#endif

	//
	//	Get the containing CFIleCacheObject from this context
	//
	static
	CFileCacheObject*
	CacheObjectFromContext(	PFIO_CONTEXT	p	) ;

	//
	//	Another version for getting the Containing CFileCacheObject !
	//
	static
	CFileCacheObject*
	CacheObjectFromContext(	FIO_CONTEXT_INTERNAL*	p	) ;

	//
	//	Initialize this CFileCacheObject !
	//
	BOOL
	Init(	CFileCacheKey&	key,
			class	CFileCacheConstructorBase&	constructor,
			void*	pv
			) ;
	
	//
	//	Set up the Async File Handle !
	//
	FIO_CONTEXT_INTERNAL*
	AsyncHandle(	HANDLE	hFile	) ;

	//
	//	Set up the synchronous File Handle
	//
	void
	SyncHandle(	HANDLE	hFile	) ;

	//
	//	get the correct containing file context !
	//
	FIO_CONTEXT_INTERNAL*
	GetAsyncContext(	class	CFileCacheKey&	key,
						class	CFileCacheConstructorBase&	constructor
						) ;


	FIO_CONTEXT_INTERNAL*
	GetSyncContext(		class	CFileCacheKey&	key,
						class	CFileCacheConstructorBase&	constructor
						) ;

	//
	//	get the async context for this handle, only if it is setup correctly !
	//
	FIO_CONTEXT_INTERNAL*
	GetAsyncContext() ;

	//
	//	get the async context for this handle, only if it is setup correctly !
	//
	FIO_CONTEXT_INTERNAL*
	GetSyncContext() ;

	//
	//	Do appropriate release of this item, depending
	//	on whether its cached or not !
	//
	void
	Return() ;

	//
	//	Add a client reference to an item in the file handle cache !
	//
	void
	Reference()	;

	//
	//	Return the size of the file !
	//
	inline	DWORD
	GetFileSize(	DWORD*	pcbFileSizeHigh )	{
		DWORD	cbFileSizeLow = 0 ;
		m_lock.ShareLock() ;

		if( m_pCacheRefInterface != 0 )		{
			*pcbFileSizeHigh = m_cbFileSizeHigh ;
			cbFileSizeLow = m_cbFileSizeLow ;
		}	else	{
			if( m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
				cbFileSizeLow = ::GetFileSize( m_Context.m_hFile, pcbFileSizeHigh ) ;
			}	else	{
				_ASSERT( m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) ;
				cbFileSizeLow = ::GetFileSize( m_AtqContext.m_hFile, pcbFileSizeHigh ) ;
			}
		}
		m_lock.ShareUnlock() ;
		return	cbFileSizeLow;
	}

	//
	//	Set the size of the file !
	//
	void
	SetFileSize() ;

	//
	//	Insert the item into the cache !
	//
	BOOL
	InsertIntoCache(	CFileCacheKey&	key,
						BOOL			fKeepReference
						)	;

	//
	//	Close the handles associated with an item !
	//
	BOOL
	CloseNonCachedFile(	) ;

	//
	//	Return to the caller our Dot Stuffing state !
	//
	BOOL
	GetStuffState(	BOOL	fReads,
					BOOL&	fRequiresStuffing,
					BOOL&	fStoredWithDots
					) ;

	//
	//	Setup the Stuff State
	//
	void
	SetStuffState(	BOOL	fWasScanned,
					BOOL	fRequiresStuffing
					) ;

	BOOL
	CompleteDotStuffing(	
					BOOL			fReads,
					BOOL			fStripDots
					) ;
} ;	


class	CFileCacheConstructorBase	{
/*++

Class Description :

	Define some basic functionality for how we create
	CFileCacheObject objects.

--*/
protected :
	//
	//	Can only build derived classes of these !
	//
	CFileCacheConstructorBase( BOOL fAsync ) :
		m_fAsync( fAsync ) {}
public :

	//
	//	All constructors must publicly declare which kind of handle
	//	they are producing !
	//
	BOOL	m_fAsync ;

	//
	//	Allocate mem for CFileCacheObject - do minimal init !
	//
	CFileCacheObject*
	Create( CFileCacheKey&	key,
			void*	pv
			) ;

	
	//
	//	Release mem for CFileCacheObject -
	//	called on error allocation paths of MultiCacheEx<>
	//
	void
	Release(	CFileCacheObject*	p,
				void*	pv
				) ;

	//
	//	Release mem for CFileCacheObject -
	//	called on expiration paths of MultiCacheEx<>
	//
	static
	void
	StaticRelease(	CFileCacheObject*	p,
					void*	pv
					) ;

	//
	//	Produce the handle that the user wants placed into the
	//	CFileCacheObject !
	//
	virtual
	HANDLE
	ProduceHandle(	CFileCacheKey&	key,
					DWORD&			cbFileSizeLow,
					DWORD&			cbFileSizeHigh
					) = 0	;

	//
	//	PostInit Function is virtual - does the major
	//	amount of initialization work, which depends
	//	on how the client asked for the cache object !
	//
	virtual
	BOOL
	PostInit(	CFileCacheObject&	object,
			CFileCacheKey&		key,
			void*	pv
			) = 0 ;
		
} ;

class	CRichFileCacheConstructor	:	public	CFileCacheConstructorBase	{
private :

	//
	//	Void pointer provided by client !
	//
	LPVOID	m_lpv ;
	
	//
	//	Function pointer provided by client !
	//
	FCACHE_RICHCREATE_CALLBACK	m_pCreate ;

	//
	//	No Default Construction - or copying !
	//
	CRichFileCacheConstructor() ;
	CRichFileCacheConstructor( CRichFileCacheConstructor& ) ;
	CRichFileCacheConstructor&	operator=( CRichFileCacheConstructor & ) ;


	//
	//	These two BOOL's capture the dot stuffing state until
	//	PostInit() is called !
	//
	BOOL	m_fFileWasScanned ;
	BOOL	m_fRequiresStuffing ;
	BOOL	m_fStoredWithDots ;
	BOOL	m_fStoredWithTerminatingDot ;

public :

	//
	//	Construct a CFileCacheConstructor - just copy these args into members !
	//
	CRichFileCacheConstructor(
			LPVOID	lpv,
			FCACHE_RICHCREATE_CALLBACK	pCreate,
			BOOL	fAsync
			)  ;

	//
	//	Produce the handle we are going to use !
	//
	HANDLE
	ProduceHandle(	CFileCacheKey&	key,
					DWORD&			cbFileSizeLow,
					DWORD&			cbFileSizeHigh
					)	;

	//
	//	Do the deep initialization of the CFileCacheObject !
	//
	BOOL
	PostInit(	CFileCacheObject&	object,
			CFileCacheKey&		key,
			void*	pv
			) ;



} ;
	

class	CFileCacheConstructor	:	public	CFileCacheConstructorBase	{
private :

	//
	//	Void pointer provided by client !
	//
	LPVOID	m_lpv ;
	
	//
	//	Function pointer provided by client !
	//
	FCACHE_CREATE_CALLBACK	m_pCreate ;

	//
	//	No Default Construction !
	//
	CFileCacheConstructor() ;

public :
	
	//
	//	Construct a CFileCacheConstructor - just copy these args into members !
	//
	CFileCacheConstructor(
			LPVOID	lpv,
			FCACHE_CREATE_CALLBACK	pCreate,
			BOOL	fAsync
			)  ;

	//
	//	Produce the handle we are going to use !
	//
	HANDLE
	ProduceHandle(	CFileCacheKey&	key,
					DWORD&			cbFileSizeLow,
					DWORD&			cbFileSizeHigh
					)	;

	//
	//	Do the deep initialization of the CFileCacheObject !
	//
	BOOL
	PostInit(	CFileCacheObject&	object,
			CFileCacheKey&		key,
			void*	pv
			) ;
} ;


//
//	Define what a file cache object looks like !
//
typedef	MultiCacheEx<	CFileCacheObject,
						CFileCacheKey,
						CFileCacheConstructorBase
						>	FILECACHE ;

//
//	Define what a name cache object looks like !
//
typedef	MultiCacheEx<	CFileCacheObject, 
						CNameCacheKey, 
						CFileCacheConstructorBase
						>	NAMECACHE ;

//
//	Define out Expunge object !
//
class	CFileCacheExpunge : public	FILECACHE::EXPUNGEOBJECT	{
private :

	//
	//	Define the string we need to match !
	//
	LPSTR	m_lpstrName ;
	DWORD	m_cbName ;

public :

	CFileCacheExpunge(	LPSTR	lpstrName,
						DWORD	cbName ) :
		m_lpstrName( lpstrName ),
		m_cbName( cbName )	{}

	BOOL
	fRemoveCacheItem(	CFileCacheKey*	pKey,
						CFileCacheObject*	pObject
						) ;

} ;

	

//
//	Define an instance of our Name Cache !
//
class	CNameCacheInstance :	public	NAME_CACHE_CONTEXT	{
private : 
	enum	CONSTANTS	{
		SIGNATURE	= 'CCNF', 
		DEAD_SIGNATURE = 'CCNX'
	} ;
	//
	//	Number of client references !
	//
	volatile	long	m_cRefCount ;
	//
	//	The entry we provided for our containing hash table 
	//	to keep track of these things !
	//
	DLIST_ENTRY		m_list ;
public : 

    typedef     DLIST_ENTRY*    (*PFNDLIST)( class  CNameCacheInstance* p ) ; 

	//
	//	the key for this item !
	//
	CCacheKey		m_key ;

	//
	//	The embedded Name Cache implementation !
	//
	NAMECACHE		m_namecache ;

	//
	//	The 'DUD' pointer we use !
	//
	CFileCacheObject*	m_pDud ;

	//
	//	The function pointer we are to use for evaluating security descriptors - may be NULL !
	//
	CACHE_ACCESS_CHECK	m_pfnAccessCheck ;

	//
	//	Construct this guy - makes a copy of the key.
	//	Note : CCacheKey itself does shallow copies, it does 
	//	not duplicate embedded strings !
	//
	CNameCacheInstance(	CCacheKey&	key	) ;

	//
	//	Destroy ourselves - free any associated memory !
	//
	~CNameCacheInstance() ;

	//	
	//	Check that this item is in a valid state !
	//	should only be called after successfully calling Init() !
	//
	BOOL
	IsValid() ;

	//
	//	Add a reference to this Name Cache table !
	//
	long
	AddRef() ;

	//
	//	Release a reference to this name cache table !
	//
	long	
	Release() ;

	//
	//	Initialize this guy !
	//
	BOOL
	fInit() ;

	inline	static
	DLIST_ENTRY*
	HashDLIST(	CNameCacheInstance*	p ) {
		return	&p->m_list ;
	}

	inline		CCacheKey*
	GetKey()	{
		return	&m_key ;
	}

} ;

typedef	TFDLHash<	class	CNameCacheInstance, 
					class	CCacheKey*, 
					&CNameCacheInstance::HashDLIST
					>	NAMECACHETABLE ;


#endif	//_FCACHIMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\dottest\dottest.cpp ===
/*++

	DotTest.cpp

	This file unit tests the dot stuffing classes

--*/

#include	<windows.h>
#include    "xmemwrpr.h"
#include	"dbgtrace.h"
#include	"dotstuff.h"


class	ValidateBuffer	{
public : 

	BYTE	m_rgbBuff[256] ;

	BYTE*	GetBuff()	{
		return	m_rgbBuff+10 ;
	}

	DWORD	GetSize()	{
		return	sizeof( m_rgbBuff ) - 20 ;
	}

	void
	ResetBuffer()	{
		FillMemory( m_rgbBuff, sizeof( m_rgbBuff ), 0xCC ) ;
	}
	

	ValidateBuffer()	{
		ResetBuffer() ;
	}

	void
	FillBuffer(	char*	sz )	{
		strcpy( (char*)GetBuff(), sz ) ;
	}

	DWORD
	GetStrLen()	{
		return	strlen( (char*)GetBuff() ) ;
	}

	BOOL
	IsValid()	{

		for( int i=0; i<10; i++ )	{
			if( m_rgbBuff[i] != 0xCC ) {
				return	FALSE ;
			}
		}
		for( i=sizeof( m_rgbBuff ) - 10 ; i<sizeof( m_rgbBuff );i++ ) {
			if( m_rgbBuff[i] != 0xCC ) {
				return	FALSE ;
			}
		}
		return	TRUE ;
	}
} ;

char	*szTestStrings[] = {
	"\r\n\r\n.\r\n\r\n.\r\n",
	"fjsdklfjsdkl\r\n.",
	"\r\n.\r\n.\r\n.\r\n.\r\n.",
	"\r\n..\r\n..\r\n..\r\n..\r\n..",
	"\r\n...\r\n...\r\n...\r\n...",
	"\r\n.c\r\n.c\r\n.c\r\n.c",
	"\r\n.",
	"\r\n..\r\n\r\n.\r\n",
	"\r\nC.\r\n\r\n.\r\n",
	"\r",
	"\n",
	".",
	"chars \r",
	"\n.more\r\n",
	".what? more could you want in a test program - lots of stuff, what the heck is this line"
	"here for and why is it so long !"
} ;

int
__cdecl main( int	argc, char** argv )		{


	_VERIFY( CreateGlobalHeap( 0, 0, 0, 0 ) ) ;


	ValidateBuffer	buff ;

	int	cStrings = sizeof( szTestStrings ) / sizeof( szTestStrings[0] ) ;
	int	cBias ;

	for( int i=0; i<cStrings; i++ ) {
		CDotScanner	scan1 ;

		buff.FillBuffer( szTestStrings[i] ) ;

		DWORD	cb ;
		BYTE*	lpbOut ;
		DWORD	cbOut ;

		BOOL	fSuccess = 
		scan1.ProcessBuffer(	buff.GetBuff(),
								buff.GetStrLen(),
								buff.GetSize(),
								cb, 
								lpbOut, 
								cbOut, 
								cBias									
								) ;
		_ASSERT( fSuccess ) ;
		_ASSERT( lpbOut == 0 ) ;
		_ASSERT( cbOut == 0 ) ;
		_ASSERT( cBias == 0 ) ;
		_ASSERT( cb == buff.GetStrLen() ) ;

		CDotModifier	mod1 ;

		fSuccess = 
		mod1.ProcessBuffer(	buff.GetBuff(),
							buff.GetStrLen(),
							buff.GetSize(),
							cb,
							lpbOut,
							cbOut,
							cBias
							) ;

		_ASSERT( fSuccess ) ;
		_ASSERT( lpbOut == 0 ) ;
		_ASSERT( cbOut == 0 ) ;
		_ASSERT( cBias == 0 ) ;
		_ASSERT( buff.IsValid() ) ;

		buff.ResetBuffer() ;
		buff.FillBuffer( szTestStrings[i] ) ;
		CDotModifier	mod2( szDotStuffed, szGrow ) ;

		fSuccess = 
		mod2.ProcessBuffer(	buff.GetBuff(),
							buff.GetStrLen(),
							buff.GetSize(),
							cb,
							lpbOut, 
							cbOut,
							cBias
							) ;

		_ASSERT( fSuccess ) ;
		_ASSERT( lpbOut == 0 ) ;
		_ASSERT( cbOut == 0 ) ;
		_ASSERT( cBias == 0 ) ;
		_ASSERT( buff.IsValid() ) ;

		buff.ResetBuffer() ;
		buff.FillBuffer( szTestStrings[i] ) ;
		CDotModifier	mod3( szDotStuffed, szGrow ) ;

		fSuccess = 
		mod3.ProcessBuffer(	buff.GetBuff(),
							buff.GetStrLen(),
							buff.GetStrLen(),
							cb,
							lpbOut, 
							cbOut,
							cBias
							) ;

		_ASSERT( fSuccess ) ;
		_ASSERT( cBias == 0 ) ;
		_ASSERT( buff.IsValid() ) ;

		if( lpbOut )	delete[]	lpbOut ;

	}

	CDotModifier	modGrowSpace( szDotStuffed, szGrow ) ;
	CDotModifier	modGrowNoSpace( szDotStuffed, szGrow ) ;
	CDotModifier	modShrink ;
	CDotModifier	modShrinkNoSpace ;

	for( i=0; i<cStrings; i++ )	{

		buff.ResetBuffer() ;
		buff.FillBuffer( szTestStrings[i] ) ;

		LPBYTE	lpbOut = 0 ;
		DWORD	cbOut = 0 ;
		DWORD	cb = 0 ;

		BOOL	fSuccess = 
		modGrowSpace.ProcessBuffer(	
						buff.GetBuff(),
						buff.GetStrLen(),
						buff.GetSize(),
						cb,
						lpbOut, 
						cbOut,
						cBias
						) ;

		_ASSERT( fSuccess ) ;
		_ASSERT( lpbOut == 0 ) ;
		_ASSERT( cbOut == 0 ) ;
		_ASSERT( buff.IsValid() ) ;

		buff.ResetBuffer() ;
		buff.FillBuffer( szTestStrings[i] ) ;

		fSuccess = 
		modGrowNoSpace.ProcessBuffer(	
						buff.GetBuff(),
						buff.GetStrLen(),
						buff.GetStrLen(),
						cb,
						lpbOut, 
						cbOut,
						cBias
						) ;

		_ASSERT( fSuccess ) ;
		_ASSERT( buff.IsValid() ) ;

		if( lpbOut )	delete[]	lpbOut ;
		
		buff.ResetBuffer() ;
		buff.FillBuffer( szTestStrings[i] ) ;

		fSuccess = 
		modShrink.ProcessBuffer(	
						buff.GetBuff(),
						buff.GetStrLen(),
						buff.GetSize(),
						cb,
						lpbOut, 
						cbOut,
						cBias
						) ;

		_ASSERT( fSuccess ) ;
		_ASSERT( buff.IsValid() ) ;

		buff.ResetBuffer() ;
		buff.FillBuffer( szTestStrings[i] ) ;

		fSuccess = 
		modShrinkNoSpace.ProcessBuffer(	
						buff.GetBuff(),
						buff.GetStrLen(),
						buff.GetStrLen(),
						cb,
						lpbOut, 
						cbOut,
						cBias
						) ;

		_ASSERT( fSuccess ) ;
		_ASSERT( buff.IsValid() ) ;
	}
	_VERIFY( DestroyGlobalHeap() ) ;
	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\dotstuff\dotstuff.cpp ===
/*++

	DotStuff.cpp

	This file contains the definitions of classes that can be used to define
	Dot Stuffing operations and modifications through FILE IO.



--*/


#include	<windows.h>
#include    "xmemwrpr.h"
#include	"dbgtrace.h"
#include	"filehc.h"
#include	"dotstuff.h"


//
//	Define the sequence of characters we look for in dot stuffing situations
//
BYTE	szDot[] = "\r\n.\r\n" ;
BYTE	szDotStuffed[] = "\r\n." ;
BYTE	szShrink[] = "\r\n" ;
BYTE	szGrow[] = "\r\n.." ;



BOOL	
CDotScanner::InternalProcessBuffer(	
					BYTE*	lpb,			// The users original buffer
					DWORD	cbIn,			// Number of bytes to look at in orignal buffer
					DWORD	cbAvailable,	// Number of bytes available in the original buffer
					DWORD	&cbRemains,		// Number of bytes we left in the original Buffer - can be zero
					BYTE*	&lpbOut,		// An output buffer that holds a portion of the string !
					DWORD	&cbOut,			// The amount of stuff in our output buffer
					int		&cBias			// Whether we should offset associated IO's to overwrite
											// previous results !
					)	{

/*++

Routine Description :

	This function examines all the bytes in the incoming buffer
	and determines whether we will have a dot stuffing issue with
	this buffer.

Arguments :

	lpb - the buffer containing the text we are examining.
	cbIn - the number of bytes to examine in the buffer
	cbAvailable - total space we can touch in the buffer !
	cbRemains - The number of bytes that are in the buffer when we're done !
	lpbOut -

Return Value :

	Number of bytes the caller should use - always the same as cbIn !

--*/

	//
	//	Validate our arguments !
	//
	_ASSERT( lpb != 0 ) ;
	_ASSERT( cbIn != 0 ) ;
	_ASSERT( cbAvailable >= cbIn ) ;
	_ASSERT( cbRemains == 0 ) ;
	_ASSERT( lpbOut == 0 ) ;
	_ASSERT( cbOut == 0 ) ;
	_ASSERT( cBias == 0 ) ;

	//
	//	We treat the buffer read-only and leave the buffer
	//	exactly as we found it !
	//
	cbRemains = cbIn ;
	//
	//	Attempt to match the inbound string !
	//
	BYTE*	lpbMax = lpb + cbIn ;

	while( lpb < lpbMax )	{
		if( *lpb == *m_pchState )	{
			m_pchState++ ;
			if( *m_pchState == '\0' ) {
				m_cOccurrences ++ ;
				m_pchState = m_pchMatch ;
			}
		}	else	{
			m_pchState = m_pchMatch ;
			if( *lpb == *m_pchState )
				m_pchState++ ;
		}
		lpb++ ;
	}
	
	return	TRUE ;
}


BOOL
CDotModifier::InternalProcessBuffer(	
				BYTE*	lpb,
				DWORD	cbIn,
				DWORD	cbAvailable,
				DWORD	&cbRemains,
				BYTE*	&lpbOut,
				DWORD	&cbOut,
				int		&cBias
				)	{
/*++

Routine Description :

	This function exists to munge buffers - converting occurrences
	of one string within the buffer to another, specified when
	our object was constructed.  Amongst our challenges - we get
	called repeatedly with only portions of the users buffer provided
	which means that we may recognize a pattern after most of it has
	passed us by.  This is why we have cBias as an out parameter -
	it allows us to tell the caller to overwrite a portion of his
	last data.

Arguments :

	lpb - The buffer to be scanner
	cbIn - Number of scannable bytes in the buffer
	cbAvailable - The amount of space we can mess with in the buffer,
		hopefully this is larger than cbIn !
	cbRemains - where we return the number of bytes we left in the
		users buffer
	lpbOut - An optional out buffer that we may return to the caller -
		this occurs if cbAvailable is so small that we cannot do all
		the manipulations we'd like to do in place !
	cbOut - Return the number of usefull bytes in lpbOut
	cBias - if we figure out that a prior buffer we've examined
		contains a portion of the pattern to be replaced, this is
		the offset we should add to a file offset to cause the
		correct overwriting to occur !

Return Value ;

	TRUE if successfull FALSE otherwise -
	Note we can only fail if we need to allocate memory and fail to do so !


--*/
	cbRemains = 0 ;
	lpbOut = 0 ;
	cbOut = 0 ;
	cBias = 0 ;

	//
	//	Validate our arguments !
	//
	_ASSERT( lpb != 0 ) ;
	//_ASSERT( cbIn != 0 ) ;	Actually - we can be called with this set to 0 in a recursive case !
	//							it's okay - we handle it correctly !
	_ASSERT( cbAvailable >= cbIn ) ;
	_ASSERT( cbRemains == 0 ) ;
	_ASSERT( lpbOut == 0 ) ;
	_ASSERT( cbOut == 0 ) ;
	_ASSERT( cBias == 0 ) ;

	//
	//	Attempt to match the inbound string !
	//
	BYTE*	lpbOriginal = lpb ;
	BYTE*	lpbMax = lpb + cbIn ;
	BYTE*	lpbMaxAvail = lpb + cbAvailable ;

	//
	//	Basic Pattern matching loop, that replaces one string with another !
	//
	while( lpb < lpbMax )	{

		//
		//	invariants for our loop !
		//
		_ASSERT( lpb >= lpbOriginal ) ;
		_ASSERT( lpbMax >= lpb ) ;
		_ASSERT( lpbMaxAvail >= lpbMax ) ;

		if( *lpb == *m_pchState )	{
			lpb++ ;
			//
			//	NOTE : lpb Now bytes to the BYTE following the matched sequence !
			//
			m_pchState++ ;
			if( *m_pchState == '\0' ) {
				//
				//	Reset the matching state stuff !
				//
				m_pchState = m_pchMatch ;
				//
				//	Count the number of times we've matched the pattern !
				//
				m_cOccurrences ++ ;
				//
				//	First figure out where we want to write the replacement pattern -
				//	Because we keep getting passed buffers, we need to deal with the case
				//	where a large hunk of the matching pattern passed through on a previous
				//	call, and we want to rewrite a portion of the file !
				//
				BYTE*	lpbOverwrite = lpb - m_cchMatch ;
				if( lpbOverwrite < lpbOriginal )	{
					cBias = (int)(lpbOverwrite - lpbOriginal) ;
					_ASSERT( cBias < 0 ) ;
					lpbOverwrite = lpbOriginal ;
				}
				//
				//	cBias always computes out to a negative or zero number - we want
				//	to add its absolute value to lpbTemp, so we take advantage of the
				//	fact that we know it is negative !
				//
				_ASSERT( cBias <= 0 ) ;
				BYTE*	lpbTemp = lpbMax + m_cDiff - cBias ;
				if(	lpbTemp <= lpbMaxAvail )	{
					//
					//	Move all the bytes around cause of the Pattern Match !
					//
					MoveMemory( lpb + m_cDiff - cBias, lpb, lpbMax - lpb ) ;
					//
					//	Put the replacement pattern into place !
					//
					CopyMemory( lpbOverwrite, m_pchReplace, m_cchMatch+m_cDiff ) ;
					//
					//	Now adjust where the buffer terminates and continue !
					//
					lpbMax += m_cDiff - cBias ;
					lpb += m_cDiff - cBias ;
				}	else	{
					//
					//	Get a buffer to hold the overflow ! - First do some arithmetic to figure
					//	out how much memory we should allocate, that would guarantee that we can
					//	hold everything that results.
					//
					DWORD	cDiff = ((m_cDiff < 0) ? -m_cDiff : m_cDiff) ;
					DWORD	cbRequired = (((DWORD)(lpbMax - lpb + 1 + m_cchMatch) * (m_cchMatch + cDiff)) / m_cchMatch) + 1 - cBias;

					//
					//	Now allocate the buffer - Note that we add an arbitrary 10 characters so the caller can always
					//	append a CRLF.CRLF sequence !
					//
					lpbTemp = new	BYTE[cbRequired+10] ;
					if( !lpbTemp )	{
						SetLastError( ERROR_OUTOFMEMORY ) ;
						return	FALSE ;
					}	else	{

						BYTE*	lpbFront = lpbTemp + m_cDiff + m_cchMatch ;
						//
						//	NOW - Move all the bytes EXCLUDING the MATCHED bytes into the new buffer,
						//	BUT leave space for the for the matched pattern !
						//
						MoveMemory( lpbFront, lpb, lpbMax - lpb ) ;
						//
						//	NOW - Zap the bytes into the destination
						//
						CopyMemory( lpbTemp, m_pchReplace, m_cchMatch+m_cDiff ) ;
						//
						//	Now - recursively invoke ourselves to finish the job - because we allocated a big
						//	enough buffer we should not recurse again !
						//
						BYTE*	lpbRecurseOut = 0 ;
						DWORD	cbRecurseOut = 0 ;
						int		cRecurseBias = 0 ;
						lpbOut = lpbTemp ;							
						BOOL	fResult =
							InternalProcessBuffer(	
											lpbFront,
											(DWORD)(lpbMax - lpb),
											cbRequired - m_cDiff - m_cchMatch,
											cbOut,
											lpbRecurseOut,
											cbRecurseOut,
											cRecurseBias
											) ;
						cbOut += m_cDiff + m_cchMatch ;
						_ASSERT( fResult ) ;
						_ASSERT( cRecurseBias == 0 ) ;
						_ASSERT( lpbRecurseOut == 0 ) ;
						_ASSERT( cbRecurseOut == 0 ) ;
						//
						//	Well we're all done - return the correct results to the caller !
						//
						cbRemains = (DWORD)(lpbOverwrite - lpbOriginal) ;
						return	TRUE ;
					}
				}

			}
		}	else	{
			m_pchState = m_pchMatch ;
			if( *lpb == *m_pchState )
				m_pchState++ ;
			lpb++ ;
		}
	}

	_ASSERT( lpbMax >= lpbOriginal ) ;
	_ASSERT( cBias <= 0 ) ;

	//
	//	Let the caller know how much usable stuff remains
	//	in his buffer - could be nothing !
	//
	cbRemains = (DWORD)(lpbMax - lpbOriginal) ;
	return	TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\sdcache\sdcache.cpp ===
/*++

	SDCACHE.CPP

	This file implements the security descriptor cache.
	Our goal is to enable the file handle cache to consume less memory
	representing security descriptors, by enabling duplicate 
	security descriptors to be detected and referenced in here.

--*/

#include	<windows.h>
#include	<dbgtrace.h>
#include	"fdlhash.h"
#include	"rwnew.h"
#include	"refptr2.h"
#include	"xmemwrpr.h"
#include	"sdcache.h"
//#include	"cintrnl.h"


BOOL
IsSelfRelativeSecurityDescriptor(	PSECURITY_DESCRIPTOR	pSecDesc ) {
	SECURITY_DESCRIPTOR_CONTROL	control ;
	DWORD	dwRevision ;
	if (GetSecurityDescriptorControl( pSecDesc, &control, &dwRevision ))
		return	(control & SE_SELF_RELATIVE) != 0;
	else
		return FALSE;
}



BOOL
CSDKey::IsValid()	{
/*++

Routine Description : 

	This function validates that the key object is correctly constructed.
	We do NOT allow any NULL pointers, and we must have valid self relative
	security descriptors embedded.

Arguments : 

	NONE.

Return Value : 

	TRUE if correctly initialized, FALSE otherwise 

--*/

	_ASSERT( m_pMapping != 0 ) ;
	_ASSERT( m_pSecDesc != 0 ) ;
	_ASSERT( IsValidSecurityDescriptor( m_pSecDesc ) ) ;
	_ASSERT( IsSelfRelativeSecurityDescriptor( m_pSecDesc ) ) ;
	_ASSERT( m_cbSecDesc > 0 ) ;
	_ASSERT( (DWORD)m_cbSecDesc == GetSecurityDescriptorLength( m_pSecDesc ) ) ;

	return	m_pMapping != 0 &&
			m_pSecDesc != 0 &&
			IsValidSecurityDescriptor( m_pSecDesc ) &&
			IsSelfRelativeSecurityDescriptor( m_pSecDesc ) &&
			m_cbSecDesc > 0 && 
			(DWORD)m_cbSecDesc == GetSecurityDescriptorLength( m_pSecDesc ) ;
}

int	
CSDKey::MatchKey(	CSDKey left, 
					CSDKey	right 
					) {
/*++

Routine Description : 

	This function must compare 2 security descriptor keys, 
	and correctly define an ordering on the keys.
	(The hash table we're used in sorts buckets).

Arguments : 

	left, right - the two keys to be compared 
	
Return Value : 

	-1 if left < right
	0  if left == right
	1  if left > right 

--*/

	//
	//	Validate our arguments !
	//
	_ASSERT( left.IsValid() ) ;
	_ASSERT( right.IsValid() ) ;
	//
	//	perform the comparison !
	//
	int	iResult = memcmp( left.m_pMapping, right.m_pMapping, sizeof(GENERIC_MAPPING));
	if( iResult != 0 ) {
		iResult = left.m_cbSecDesc - right.m_cbSecDesc ;
		if( iResult == 0 ) {
			iResult = memcmp( left.m_pSecDesc, right.m_pSecDesc, left.m_cbSecDesc ) ;
		}
	}
	return	iResult ;
}

DWORD
CSDKey::HashKey(	CSDKey	Key ) {
/*++

Routine Description : 

	This function computes a hash on security descriptors.
	We ignore the GENERIC_MAPPING part of the key - this 
	will vary very rarely.
	We're a static function so we can be passed as a function 
	pointer.
	We simply look at the security descriptor as an array of DWORD's
	and sum them up.

Arguments : 

	Key - compute the hash of this security descriptor	

Return Value : 

	A Hash Value - no failure cases can occur

--*/


	//
	//	Very simple - sum all of the bits in the security descriptor !
	//
	_ASSERT( Key.IsValid() ) ;

	DWORD	cb = (DWORD)Key.m_cbSecDesc ;
	cb /= 4 ;

	DWORD*	pdw = (DWORD*)Key.m_pSecDesc ;
	DWORD*	pdwEnd = pdw + cb ;
	DWORD	Sum = 0 ;
	while( pdw != pdwEnd )	{
		Sum += *pdw++ ;
	}
	return	Sum ;
}



void*
CSDObject::operator	new(	size_t	size,	
							CSDKey&	key 
							)	{
/*++

Routine Description : 

	This function allocates memory of a CSDObject, 
	we require special handle because CSDObjects are variable length.

Arguments : 

	size - the size as generated by the compiler
	key -  the security descriptor we're going to stick in here

Return Value : 

	Allocated memory - NULL if failure 

--*/


	_ASSERT( size >= sizeof(CSDObject) ) ;
	_ASSERT( key.IsValid() ) ;

	size += key.m_cbSecDesc - sizeof( DWORD ) ;

	return	::new	BYTE[size] ;
} 


void
CSDObject::operator delete(	void*	lpv ) {
/*++

Routine Description : 

	Release a CSDObject !

Arguments : 
	
	lpv - where the CSDObject was before it was destructed

Return Value : 

	None.

--*/

	::delete(lpv) ;
}


long
CSDObject::Release()	{
/*++

Routine Description : 

	This function drops a reference to a CSDObject.
	WARNING - we will grab locks on the CSDObjectContainer 
	that is holding this item, the last reference MUST NEVER
	BE RELEASED WITHIN A LOCK !

	If the reference count drops to one, that means that the only reference
	remaining on the object is the one from the hash table.
	So we grab the hash table lock exclusively, so we can prevent new references
	from being added, and we then do a InterlockedCompareExchange to drop 
	the reference count to 0.  We need to do this to ensure that between
	the time we decrement the ref. count and the time we grab the lock, that 
	another user doesn't simultaneously raise and drop the ref. count.

Arguments : 

	None.

Return Value : 

	the resulting refcount.

--*/
	_ASSERT( IsValid() ) ;
	CSDObject*	pdelete = 0 ;
	long l = InterlockedDecrement( (long*)&m_cRefCount ) ;
	_ASSERT( l>=1 ) ;
	if( l == 1 ) {
		m_pContainer->m_lock.ExclusiveLock() ;		
		if( InterlockedCompareExchange( (long*)&m_cRefCount, 0, 1) == 1 ) {
			m_pContainer->m_table.Delete( this ) ;
			pdelete = this ;
		}
		m_pContainer->m_lock.ExclusiveUnlock() ;
	}
	if( pdelete )	{
		delete	pdelete ;
		l = 0 ;
	}
	return	l ;
}


//
//	Check that we are a valid object !
//
BOOL
CSDObject::IsValid()	{
/*++

Routine Description : 

	This function checks that we were properly constructed - 
	if allocation of our memory succeeds, nothing should stand
	in the way of producing a completely initialized object !

Arguments : 

	None.

Return Value : 

	TRUE if correctly constructed, FALSE otherwise !

--*/
	_ASSERT( m_dwSignature == SIGNATURE ) ;
	_ASSERT( m_pContainer != 0 ) ;
	_ASSERT( m_cRefCount >= 0 ) ;

	CSDKey	key( &m_mapping, SecurityDescriptor() ) ;
	_ASSERT( key.IsValid() ) ;
	_ASSERT( CSDKey::HashKey( key ) == m_dwHash ) ;

	return	m_dwSignature == SIGNATURE &&
			m_pContainer != 0 && 
			m_cRefCount >= 0 &&
			key.IsValid() &&
			CSDKey::HashKey( key ) == m_dwHash ;
}

BOOL
CSDObject::AccessCheck(	HANDLE	hToken, 
						ACCESS_MASK	accessMask,
						CACHE_ACCESS_CHECK	pfnAccessCheck
						)	{
/*++

Routine Description : 

	This function performs an ACCESS Check to determine whether
	a client has the specified permissions to the object.


Arguments : 

	hToken - Client Token
	accessMask - the Client's desired access 

Return Value : 

	TRUE if the client has access, 
	FALSE otherwise !

--*/


	if( hToken == 0 ) 
		return	TRUE ;

	_ASSERT( hToken != 0 ) ;
	_ASSERT( accessMask != 0 ) ;
	_ASSERT( IsValid() ) ;

    BYTE    psFile[256] ;
    DWORD   dwPS = sizeof( psFile ) ;
    DWORD   dwGrantedAccess = 0 ;
    BOOL    fAccess = FALSE ;

    BOOL    f = FALSE ;

	if( pfnAccessCheck ) {
		f = pfnAccessCheck(	SecurityDescriptor(),
							hToken,
							accessMask, 
							&m_mapping, 
							(PRIVILEGE_SET*)psFile, 
							&dwPS, 
							&dwGrantedAccess, 
							&fAccess
							) ;
	}	else	{
		f = ::AccessCheck(  SecurityDescriptor(),
                            hToken,
                            accessMask,
                            &m_mapping,
                            (PRIVILEGE_SET*)psFile,
                            &dwPS,
                            &dwGrantedAccess,
                            &fAccess
                            ) ;
	}
    DWORD   dw = GetLastError() ;

	return	f && fAccess ;
}



//
//	Now - find or create a given security descriptor 
//	item !
//
CSDObject*
CSDObjectContainer::FindOrCreate(	DWORD	dwHash, 
									CSDKey&	key 
									)	{
/*++

Routine Description : 

	This function will either locate a matching security 
	descriptor in the cache, or return a pointer to a new
	CSDObject created and placed into the cache.

	NOTE : We must always ADD a reference while the lock is held, 
	because Release() will try to re-enter the lock and remove
	the object from the hash table !

Arguments : 

	dwHash - the hash of the sought security descriptor
	key -	describes the security descriptor and GENERIC_MAPPING
		we are to locate !

Return Value : 

	A pointer to a CSDObject in the cache, or NULL if failure.
	A NULL means the object was not found, and we couldn't allocate
	memory to insert a new one !

--*/

	_ASSERT( key.IsValid() ) ;
	_ASSERT( CSDKey::HashKey(key) == dwHash ) ;

	CSDObject*	pObject = 0 ;
	m_lock.ShareLock() ;
	SDTABLE::ITER	iter = 
		m_table.SearchKeyHashIter(	dwHash,		
									key, 
									pObject
									) ;
	if( pObject )	{	
		pObject->AddRef() ;
		m_lock.ShareUnlock() ;
	}	else	{
		if( !m_lock.SharedToPartial() ) {
			m_lock.ShareUnlock() ;
			m_lock.PartialLock() ;
			iter = m_table.SearchKeyHashIter(	dwHash,
												key, 
												pObject
												) ;
		} 
		if( pObject != 0 ) {
			pObject->AddRef() ;
		}	else	{
			pObject = new( key )	CSDObject( dwHash, key, this ) ;
			if( pObject != 0 ) {
				m_lock.FirstPartialToExclusive() ;
				BOOL	fInsert = 
					m_table.InsertDataHashIter(	iter, 
												dwHash, 
												key, 
												pObject
												) ;	
				m_lock.ExclusiveUnlock() ;
				if( !fInsert ) {
					pObject->Release() ;
					pObject = 0 ;
				}
				return	pObject ;
			}
		}	
		m_lock.PartialUnlock() ;
	}	
	return	pObject ;
}	// End FindOrCreate()


CSDMultiContainer::Init()	{
/*++

Routine Description : 

	Initialize everything so we're ready to go !

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !


--*/

	BOOL	fReturn = TRUE ;
	for( int i=0; i<CONTAINERS && fReturn; i++ )	{
		fReturn &= m_rgContainer[i].Init() ;
	}
	return	fReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\utestexe\fcexe.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	"dbgtrace.h"
#include	"testdll.h"

//
//	Number of files to do initial kick off
//
DWORD	g_cCreatePerSecond = 50 ;

//
//	Number of times we read existing files per creation of
//	a new file !
//
DWORD	g_cFindPerSecond = 2 ;

//
//	Number of finds done in parallel !
//
DWORD	g_cParallelFinds = 10 ;

//
//	The directory where we store all of our test files !
//
char	g_szDir[MAX_PATH] ;

//
//	The filesystem DLL to load !
//
char	g_szFileSystemDll [MAX_PATH];

//
//	How long to let the Test DLL live !
//
DWORD	g_cLifetime = 5 ;	// default 10 minutes !



#define	INI_KEY_CREATEPERSEC	"CreatePerSec"
#define	INI_KEY_FINDPERSEC		"FindPerSec"
#define	INI_KEY_PARALLEL		"Parallel"
#define	INI_KEY_LIFETIME		"Lifetime"
#define	INI_KEY_DIR				"Dir"
#define INI_KEY_FILE_SYSTEM		"FileSystem"

char g_szDefaultSectionName[] = "fcexe";
char *g_szSectionName = g_szDefaultSectionName;

void usage(void) {
/*++

Routine Description : 

	Print Usage info to command line user !

Arguments : 

	None.

Return Value : 

	None.

--*/
	printf("usage: c2test.exe [<ini file>] [<ini section name>]\n"
		"  INI file keys (default section [%s]):\n"
		"    %s Test Directory - contains files created during test !\n"
		"    %s Files Created per second Default - %d\n"
		"    %s Files found per seccond per session Default %d\n"
		"    %s Parallel Find Sessions - %d\n"
		"    %s Number of minutes per test - %d\n"
		"    %s FileSystem DLL to use !\n",
		g_szDefaultSectionName,
		INI_KEY_DIR, 
		INI_KEY_CREATEPERSEC, 
		g_cCreatePerSecond, 
		INI_KEY_FINDPERSEC, 
		g_cFindPerSecond,
		INI_KEY_PARALLEL, 
		g_cParallelFinds, 
		INI_KEY_LIFETIME,
		g_cLifetime,
		INI_KEY_FILE_SYSTEM
		) ;
	exit(1);
}


int GetINIDword(
			char *szINIFile, 
			char *szKey, 
			DWORD dwDefault
			) {
/*++

Routine Description : 

	Helper function which retrieves values from .ini file !

Arguments : 

	szINIFile - name of the ini file
	szKey - name of the key
	dwDefault - default value for the parameter

Return Value : 

	The value retrieved from the .ini file or the default !

--*/
	char szBuf[MAX_PATH];

	GetPrivateProfileString(g_szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

void parsecommandline(
			int argc, 
			char **argv
			) {
/*++

Routine Description : 

	Get the name of the .ini file and 
	setup our test run !

Arguments : 

	Command line parameters

Return Value : 

	None - will exit() if the user has not
		properly configured the test !

--*/
	if (argc == 0 ) usage();
	if (strcmp(argv[0], "/help") == 0) usage(); 	// show help

	char *szINIFile = argv[0];
	if (argc == 2) char *g_szSectionName = argv[1];

	GetPrivateProfileString(	g_szSectionName,
								INI_KEY_DIR,
								"",
								g_szDir,
								sizeof( g_szDir ),
								szINIFile
								) ;

	g_cCreatePerSecond =	GetINIDword( 
								szINIFile,
								INI_KEY_CREATEPERSEC,
								g_cCreatePerSecond
								) ;

	g_cFindPerSecond =	GetINIDword( 
								szINIFile,
								INI_KEY_FINDPERSEC,
								g_cFindPerSecond
								) ;

	g_cParallelFinds =	GetINIDword( 
								szINIFile,
								INI_KEY_PARALLEL,
								g_cParallelFinds
								) ;

	g_cLifetime =		GetINIDword(
								szINIFile,
								INI_KEY_LIFETIME,
								g_cLifetime
								) ;

	GetPrivateProfileString(	g_szSectionName,
								INI_KEY_FILE_SYSTEM,
								"",
								g_szFileSystemDll,
								sizeof( g_szFileSystemDll ),
								szINIFile
								) ;
								
	if( g_szDir[0] =='\0' || g_szFileSystemDll[0] == '\0' ) {
		usage() ;
	}
}

int	__cdecl
main( int argc, char** argv ) {

	parsecommandline( --argc, ++argv ) ;

	Sleep( 10 * 100 ) ;

	for( int i=0; i<10000; i++ ) {

		HINSTANCE	hLibrary = LoadLibrary( g_szFileSystemDll ) ;

		typedef	BOOL	(*PFNSTART)( DWORD, DWORD, DWORD, char * ) ;

		PFNSTART	pStart = (PFNSTART)GetProcAddress( hLibrary, "_StartTest@16" ) ;

		typedef	void	(*PFNSTOP)() ;
		
		PFNSTOP		pStop = (PFNSTOP)GetProcAddress( hLibrary, "_StopTest@0" ) ;

		if ( pStart(	g_cCreatePerSecond, 
							g_cFindPerSecond,
							g_cParallelFinds, 
							g_szDir
							) )		{

			Sleep( g_cLifetime * 60 * 1000 ) ;

			pStop() ;

			Sleep( 5 * 1000 ) ;
		}

		FreeLibrary( hLibrary ) ;

		Sleep( 5 * 1000 ) ;

		//
		//	Clean up the mess we made before continuing !
		//	

		char	szBuff[MAX_PATH*2] ;
		wsprintf( szBuff, "%s\\*", g_szDir ) ;

		WIN32_FIND_DATA	finddata ;
		HANDLE	hFind = FindFirstFile( szBuff, &finddata ) ;
		if( hFind != INVALID_HANDLE_VALUE ) {
			BOOL	f = FALSE ;
			do	{
				if( (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
					wsprintf( szBuff, "%s\\%s", g_szDir, finddata.cFileName ) ;
					_VERIFY( DeleteFile( szBuff ) ) ;
				}
				f = FindNextFile( hFind, &finddata ) ;
			}	while(f) ;
			FindClose( hFind ) ;
		}
	}

	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\sdtest\sdtest.cpp ===
/*++

	SDTEST.CPP


	This file implements the unit test for the Security Descriptor Cache library.

--*/

#include	<windows.h>
#include	<stdio.h>
#include    <stdlib.h>
#include	<dbgtrace.h>
#include	"fdlhash.h"
#include	"rwnew.h"
#include	"refptr2.h"
#include	"xmemwrpr.h"
#include	"sdcache.h"



//
//	Number of threads in the test !
//
DWORD	g_cNumThreads = 1 ;

//
//	Number of items to hold externally from the cache !
//
DWORD	g_cNumHeld	= 100 ;

//
//	Amount of time to sleep between each request !
//
DWORD	g_cSleep = 1 ;

//
//	Variable holds the file from which we insert all of our hash table entries !
//
char	g_szRootDir[MAX_PATH] ;

//
//	Number of times each thread loops !
//
DWORD	g_cNumIter = 1000 ;

//
//	Number of times we instantiate the cache
//
DWORD	g_cNumGlobalIter = 20 ;

//
//	String constants for retrieving values from .ini file !
//
#define	INI_KEY_THREADS			"Threads"
#define	INI_KEY_NUMHELD			"NumHeld"
#define	INI_KEY_SLEEP			"Sleep"
#define	INI_KEY_ROOTDIR			"RootDir"
#define	INI_KEY_THREAD_ITER		"NumIter"
#define	INI_KEY_GLOBAL_ITER		"GlobalIter"

char g_szDefaultSectionName[] = "SDTEST";
char *g_szSectionName = g_szDefaultSectionName;

void usage(void) {
/*++

Routine Description :

	Print Usage info to command line user !

Arguments :

	None.

Return Value :

	None.

--*/
	printf("usage: sdtest.exe [<ini file>] [<ini section name>]\n"
		"  INI file keys (default section [%s]):\n"
		"    %s Root Directory - the directory from which we are start retrieving security descriptos\n"
		"    %s Number of Threads - Default %d\n"
		"    %s Time between each cache request (Milliseconds) - Default %d\n"
		"    %s Number of items to hold out of cache - default %d\n",
		g_szDefaultSectionName,
		INI_KEY_ROOTDIR,
		INI_KEY_THREADS,
		g_cNumThreads,
		INI_KEY_SLEEP,
		g_cSleep,
		INI_KEY_NUMHELD,
		g_cNumHeld
		) ;
	exit(1);
}


int GetINIDword(
			char *szINIFile,
			char *szKey,
			DWORD dwDefault
			) {
/*++

Routine Description :

	Helper function which retrieves values from .ini file !

Arguments :

	szINIFile - name of the ini file
	szKey - name of the key
	dwDefault - default value for the parameter

Return Value :

	The value retrieved from the .ini file or the default !

--*/
	char szBuf[MAX_PATH];

	GetPrivateProfileString(g_szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

void parsecommandline(
			int argc,
			char **argv
			) {
/*++

Routine Description :

	Get the name of the .ini file and
	setup our test run !

Arguments :

	Command line parameters

Return Value :

	None - will exit() if the user has not
		properly configured the test !

--*/
	if (argc == 0 ) usage();
	if (strcmp(argv[0], "/help") == 0) usage(); 	// show help

	char *szINIFile = argv[0];
	if (argc == 2) char *g_szSectionName = argv[1];

	GetPrivateProfileString(	g_szSectionName,
								INI_KEY_ROOTDIR,
								"",
								g_szRootDir,
								sizeof( g_szRootDir ),
								szINIFile
								) ;

	g_cNumThreads =	GetINIDword( szINIFile,
								INI_KEY_THREADS,
								g_cNumThreads
								) ;

	g_cNumHeld	=	GetINIDword(	szINIFile,
									INI_KEY_NUMHELD,
									g_cNumHeld
									) ;

	g_cSleep =		GetINIDword(	szINIFile,
									INI_KEY_SLEEP,
									g_cSleep
									) ;

	g_cNumIter = GetINIDword(	szINIFile,
								INI_KEY_THREAD_ITER,
								g_cNumIter
								) ;

	g_cNumGlobalIter = GetINIDword(	szINIFile,
									INI_KEY_GLOBAL_ITER,
									g_cNumGlobalIter
									) ;

	g_cNumThreads = min( g_cNumThreads, 60 ) ;
	g_cNumThreads = max( g_cNumThreads, 1 ) ;

}


HANDLE	hToken ;

CSDMultiContainer	mc ;

GENERIC_MAPPING		mapping =	{	FILE_GENERIC_READ,
									FILE_GENERIC_WRITE,
									FILE_GENERIC_EXECUTE,
									FILE_ALL_ACCESS
									} ;

void
RecursiveFunction(	LPSTR	lpstrParentDir,
					PTRCSDOBJ*	pPointers,
					DWORD		iPointer,
					BYTE		(&rgBuffer)[2048]
					)	{

	BOOL	fBad = FALSE ;

	char	szCurPath[MAX_PATH*2] ;
	lstrcpy( szCurPath, lpstrParentDir ) ;
	DWORD	ich = lstrlen( szCurPath ) + 1 ;
	lstrcat( szCurPath, "\\*" ) ;

	WIN32_FIND_DATA	findData ;
	HANDLE	hFind =
		FindFirstFile(	szCurPath,
						&findData
						) ;
	if( hFind != INVALID_HANDLE_VALUE ) {
		do	{

			lstrcpy( szCurPath + ich, findData.cFileName ) ;

			if( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )	{
				if( findData.cFileName[0] != '.' ) {
					RecursiveFunction(	szCurPath,
										pPointers,
										iPointer,
										rgBuffer
										) ;
				}	else	{
					fBad = TRUE ;
				}
			}

			DWORD	cb = 0 ;
			BOOL	f =
				GetFileSecurity(
							szCurPath,
							OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
							(PSECURITY_DESCRIPTOR)&rgBuffer,
							sizeof(rgBuffer),
							&cb
							) ;
			if( !f ) {
				printf( "Failed to get security for =%s= GLE %x, cb %d\n", szCurPath, GetLastError(), cb ) ;
			}	else	{

				pPointers[iPointer] = mc.FindOrCreate(	&mapping,
														(PSECURITY_DESCRIPTOR)rgBuffer
														) ;

				pPointers[iPointer]->AccessCheck(	hToken, FILE_GENERIC_READ, 0 ) ;
				iPointer++ ;
				iPointer %= g_cNumHeld ;

			}
			Sleep( g_cSleep ) ;
		}	while( FindNextFile( hFind, &findData ) ) ;
		FindClose( hFind ) ;
	}
}





DWORD	WINAPI
TestThread(	LPVOID	lpv ) {
/*++

Routine Description :

	This function performs test operations against the sample cache !

Arguments :

	None.

Return Value :

	None.

--*/

	BYTE	rgBuffer[2048] ;
	PTRCSDOBJ*	pPointers = new PTRCSDOBJ[g_cNumHeld] ;

	for( DWORD i=0; i<g_cNumIter; i++ ) {
		RecursiveFunction( g_szRootDir, pPointers, 0, rgBuffer ) ;
	}

	return	 0 ;
}

HANDLE	g_hShutdown ;

void
StartTest()	{


        HANDLE  hToken2 = 0 ;
        if(
                !OpenProcessToken(      GetCurrentProcess(),
                                                        TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                                                        &hToken2 ) )    {
                DWORD   dw = GetLastError() ;
                hToken = 0 ;
        }       else    {

                if( !DuplicateToken( hToken2,
                                                SecurityImpersonation,
                                                &hToken
                                                ) )     {
                        DWORD   dw = GetLastError() ;
                        hToken = 0 ;
                }

                CloseHandle( hToken2 ) ;

        }


	TraceFunctEnter( "StartTest" ) ;

	BOOL	f = mc.Init() ;

	g_hShutdown = CreateEvent( 0, TRUE, FALSE, 0 ) ;

	HANDLE	rgh[64] ;
	DWORD	dwJunk ;

	for(DWORD i=0; i<g_cNumThreads; i++ ) {
		rgh[i] = CreateThread(	0,
								0,
								TestThread,
								0,
								0,
								&dwJunk
								) ;
		if( rgh[i] == 0 ) break ;
	}
	WaitForMultipleObjects(		i,
								rgh,
								TRUE,
								INFINITE
								) ;
	for( ; (int)i >= 0; i-- ) {
		CloseHandle( rgh[i] ) ;
	}
	if( hToken != 0 )
		CloseHandle( hToken ) ;
}


int	__cdecl
main( int argc, char** argv ) {

    _VERIFY( CreateGlobalHeap( 0, 0, 0, 0 ) );

	DeleteFile( "c:\\trace.atf" ) ;

	InitAsyncTrace() ;

	parsecommandline( --argc, ++argv ) ;

	StartTest() ;

	TermAsyncTrace() ;

    _VERIFY( DestroyGlobalHeap() );

	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fcache2\testdll\testdll.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	"rwnew.h"
#include	"dbgtrace.h"
#include	"filehc.h"
#include	"TestDll.h"
#include	"perfapi.h"
#include	"perferr.h"


//
//	Define some perfmon stuff !
//
#define	IFS_PERFOBJECT_NAME	"Test DLL"
#define	IFS_PERFOBJECT_HELP	"File Handle Cache Test DLL"
#define	IFS_PERFOBJECT_INSTANCE         "ROOT"
#define	CACHE_CREATES_NAME	"File Handle Creates"
#define	CACHE_CREATES_HELP	"Number of times an inbound file has been created"
#define	CACHE_SEARCHES_NAME	"File Handle Searches"
#define	CACHE_SEARCHES_HELP	"Number of times we've searched the cache"
#define	CACHE_CALLBACKS_NAME	"Callbacks"
#define	CACHE_CALLBACKS_HELP	"Number of times the Cache Callback has been called"
#define	CACHE_CFAIL_NAME	"Create Failures"
#define	CACHE_CFAIL_HELP	"Number of Cache Creates that failed"
#define	CACHE_SFAIL_NAME	"Search Failures"
#define	CACHE_SFAIL_HELP	"Number of Cache Searches that failed"

CPerfCounter	CacheCreates ;
CPerfCounter	CacheSearches ;
CPerfCounter	CacheCallbacks ;
CPerfCounter	CacheCFails ;
CPerfCounter	CacheSFails ;

enum	COUNTERS	{
	CACHE_CREATES = 0,
	CACHE_SEARCHES,
	CACHE_CALLBACKS,
	CACHE_CFAILS,
	CACHE_SFAILS,
	MAX_PERF_COUNTERS
} ;

//
//	Time to wait before doing next find !
//
DWORD	g_cFindSleep = 0 ;

//
//	Time to wait before next create !
//
DWORD	g_cCreateSleep = 0 ;

//
//	Session objects !
//
class	SESSION*	rgSession ;

//
//	Number of pending IO's
//
long	g_cIOCount = 0 ;

//
//	Do we want to shutdown ?
//
BOOL	g_fShutdown = FALSE ;

//
//	Number of files we have created to date !
//
long	g_lFiles = 0 ;

//
//	The shutdown event for signalling the Inbound thread !
//
HANDLE	g_hShutdown = 0 ;

//
//	The handle to the thread that is creating inbound messages !
//
HANDLE	g_hCreateThread = 0 ;

//
//	The directory to put our files !
//
char	g_szDir[MAX_PATH*2] ;

//
//	The Name cache context's we are using !
//
PNAME_CACHE_CONTEXT	*g_rgpNameContext = 0 ;

//
//	The number of Name Cache Context's we have  !
//
DWORD	g_cNameContext = 10 ;

///
//	The lock protecting the Name Cache Context's !
//
CShareLockNH		g_NameContextLock ;

//
//	The thread that cyclically creates/destroys name context's
//
HANDLE	g_hNameContextThread ;

//
//	The amount of time between zaps of the name cache !
//
DWORD	g_cNameTimeout = 5 * 60 * 1000 ;

//
//	The hToken we use for all of our name stuff !
//
HANDLE	g_hToken ;

//
//	The security mapping we provide to the name cache !
//
GENERIC_MAPPING		mapping =	{	FILE_GENERIC_READ,
									FILE_GENERIC_WRITE,
									FILE_GENERIC_EXECUTE,
									FILE_ALL_ACCESS
									} ;


DWORD	FileFlags = FILE_FLAG_WRITE_THROUGH |
					FILE_FLAG_SEQUENTIAL_SCAN |
					FILE_FLAG_OVERLAPPED |
					FILE_FLAG_BACKUP_SEMANTICS ;

DWORD	FileShareFlags = FILE_SHARE_READ | FILE_SHARE_WRITE ;

GENERIC_MAPPING	g_gmFile = {
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
} ;


HANDLE
CreateCallback(
		LPSTR	lpstrName,
		LPVOID	lpvData,
		DWORD*	pdwSize,
		DWORD*	pdwSizeHigh
		)	{

	CacheCallbacks ++ ;

	HANDLE hFile = CreateFileA(
					lpstrName,
					FILE_GENERIC_READ | FILE_GENERIC_WRITE,
					FileShareFlags,
					0,
					OPEN_ALWAYS,
					FileFlags,
					NULL
					) ;
	if( hFile != INVALID_HANDLE_VALUE ) {
		*pdwSize = GetFileSize( hFile, pdwSizeHigh ) ;
	}

	DWORD	dw = GetLastError() ;
	return	hFile ;
}



HANDLE
CreateInbound( long	&l )	{

	char	szBuff[512] ;

	l = InterlockedIncrement( &g_lFiles ) ;

	DWORD	cb ;
	DWORD	cbHigh ;

	wsprintf( szBuff, "%s\\%d", g_szDir, l ) ;
	HANDLE	hFile =
				CreateCallback(		szBuff,
									0,
									&cb,
									&cbHigh
									) ;

	return	hFile ;
}

void
FillDWORD( DWORD*	pdw, DWORD l, DWORD		cDword ) {

	for( DWORD i=0; i<cDword; i++ ) {
		pdw[i] = l ;
	}
}

CRITICAL_SECTION	critRand ;
long	seed = 7782 ;

int
MyRand(	) {
	EnterCriticalSection( &critRand ) ;
	__int64	temp = seed ;
	temp = (temp * 41358) % (2147483647) ;
	int	result = (int)temp ;
	seed = result ;
	LeaveCriticalSection( &critRand ) ;
	return	result ;
}



class	SESSION	{
public :
	FH_OVERLAPPED	m_Overlapped ;
	PFIO_CONTEXT	m_pContext ;
	long			m_id ;
	DWORD			m_cReadCount ;
	HANDLE			m_hEventWrite ;
	DWORD			m_rgdwBuff[1024] ;

	SESSION() :
		m_pContext( 0 ),
		m_id( 0xFFFFFFFF ),
		m_cReadCount( 0 ),
		m_hEventWrite( 0 ) {

		m_hEventWrite = CreateEvent( 0, FALSE, TRUE, 0 ) ;

	}

	~SESSION()	{

		_VERIFY( CloseHandle( m_hEventWrite ) ) ;

	}

	static	BOOL	__stdcall
	CheckData(	IN	DWORD	cb,
				IN	LPBYTE	lpb,
				IN	LPVOID	lpv
				)	{
		DWORD_PTR i = DWORD_PTR(lpv) ;

		_ASSERT( (cb%sizeof(DWORD))==0 ) ;
		cb /= sizeof(DWORD) ;

		_ASSERT( cb == (DWORD)min(1024, i*10 ) ) ;
		LPDWORD	lpdw = (LPDWORD)lpb ;

		DWORD_PTR	iMax = min( i*10, 1024 ) ;

		for( DWORD j=0; j<iMax; j++ ) {
			_ASSERT( lpdw[j] == DWORD(i) ) ;
		}
		return	TRUE ;
	}

	void
	GetReadContext()	{

		TraceFunctEnter( "SESSION::GetReadContext" ) ;

		int	i = 0 ;
		int	iSkipCreate = 0 ;
		BOOL	fSyncCreate = FALSE ;
		BOOL	fAsyncCreate = FALSE ;
		PFIO_CONTEXT pContext = 0 ;
		PFIO_CONTEXT pSyncContext = 0 ;

		do	{
			iSkipCreate = MyRand() % 100 ;
			i = MyRand() ;
			i %= g_lFiles ;
			if( i==0 ) i = 1 ;
			char	szBuff[512] ;
			char	szNameBuff[4096] ;
			DWORD	rgbData[1024] ;
			BOOL	fOrderCreate = FALSE ;

			fSyncCreate = FALSE ;
			fAsyncCreate = FALSE ;
			if( iSkipCreate < 66 ) {
				fSyncCreate = TRUE ;
			}
			if( iSkipCreate > 33 ) {
				fAsyncCreate = TRUE ;
			}
			fOrderCreate = (iSkipCreate % 2)==0 ;

			//
			//	First search for the item
			//	with one of the several names !
			//

			BOOL	f ;
			DWORD	cb =
				wsprintf( szNameBuff, "%s\\%d.NAME1.\0", g_szDir, i ) ;

			DebugTrace( DWORD_PTR(this), "Computed Name %s len %d", szNameBuff, cb ) ;

			//
			//	In addition to this portion of the name, we add a whole lot of junk
			//
			DWORD	cbCopy = min( DWORD(4096), DWORD(i*10) ) ;
			_ASSERT(cbCopy <= 4096 ) ;
			if( cbCopy > cb ) {
				cbCopy -= cb ;
			}	else	{
				cbCopy = 0 ;
			}

			DebugTrace( DWORD_PTR(this), "Filling Memory %x with %x bytes of %x", szNameBuff+cb, cbCopy, (BYTE)i ) ;

			FillMemory( szNameBuff+cb, cbCopy, (BYTE)i ) ;
			cb += cbCopy ;

			DWORD	cbData = min( 1024, i*10 ) ;

			DebugTrace( DWORD_PTR(this), "Filling Memory %x with %x DWORDs of %x", rgbData, cbData, DWORD(i) ) ;

			for( DWORD l=0; l<cbData; l++ ) {
				rgbData[l] = DWORD(i) ;
			}
			cbData *= sizeof(DWORD) ;

			_ASSERT( cb <= sizeof(rgbData) ) ;

			DWORD	iNameCache = i % g_cNameContext ;

			DebugTrace( DWORD_PTR(this), "Going into Name Cache %d", iNameCache ) ;

			pSyncContext =0 ;
			pContext = 0 ;

			g_NameContextLock.ShareLock() ;
			PNAME_CACHE_CONTEXT	pNameCache = g_rgpNameContext[iNameCache] ;
			if( pNameCache ) {
				f =	FindContextFromName(	pNameCache,
											(LPBYTE)szNameBuff,
											cb,
											CheckData,
											(LPVOID)(SIZE_T)i,
											g_hToken,
											FILE_GENERIC_READ | FILE_GENERIC_WRITE,
											&pContext
											) ;
			}
			if( pNameCache ) {
				f =	FindSyncContextFromName(	pNameCache,
											(LPBYTE)szNameBuff,
											cb,
											CheckData,
											(LPVOID)(SIZE_T)i,
											g_hToken,
											FILE_GENERIC_READ | FILE_GENERIC_WRITE,
											&pSyncContext
											) ;
			}


			DebugTrace( 0, "Find Results - Async %x Sync %x ", pContext, pSyncContext ) ;

			g_NameContextLock.ShareUnlock() ;

			if( pSyncContext == 0 ) {
				if( fOrderCreate ) {
					if( iSkipCreate > 33 ) {
						wsprintf( szBuff, "%s\\%d", g_szDir, i ) ;
						pSyncContext =
							CacheCreateFile(	szBuff,
												CreateCallback,
												0,
												FALSE
												) ;
						DebugTrace( 0, "CacheCreateFile SYNC results %x", pSyncContext ) ;

					}
				}
			}

			if( pContext == 0 ) {
				if( iSkipCreate < 66 ) {
					wsprintf( szBuff, "%s\\%d", g_szDir, i ) ;
					pContext =
						CacheCreateFile(	szBuff,
											CreateCallback,
											0,
											TRUE
											) ;
					DebugTrace( 0, "CacheCreateFile ASYNC results %x", pContext ) ;
				}
			}
			if( pContext ) {
				BYTE	rgbSecurityDescriptor[2048] ;

				DWORD	cbSecurityDescriptor ;
				BOOL	f =
					GetFileSecurity(
								szBuff,
								OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
								(PSECURITY_DESCRIPTOR)&rgbSecurityDescriptor[0],
								sizeof(rgbSecurityDescriptor),
								&cbSecurityDescriptor
								) ;
				if( !f ) {
					ErrorTrace( 0, "Failed to get security for =%s= GLE %x, cb %d\n", szBuff, GetLastError(), cb ) ;
				}	else	{
					g_NameContextLock.ShareLock() ;
					PNAME_CACHE_CONTEXT	pNameCache = g_rgpNameContext[iNameCache] ;
					if( pNameCache ) {
						f =
						AssociateContextWithName(	pNameCache,
													(LPBYTE)szNameBuff,
													cb,
													(LPBYTE)&rgbData[0],
													cbData,
													&mapping,
													(PSECURITY_DESCRIPTOR)rgbSecurityDescriptor,
													pContext,
													TRUE
													) ;

						DebugTrace( 0, "First AssociateContextWithName - results %x pCOntext %x", f, pContext ) ;

						//
						//	Let's immediately turn around and remove the entry and then re-insert it !
						//
						f = InvalidateName( pNameCache,
											(LPBYTE)szNameBuff,
											cb
											) ;

						DebugTrace( 0, "First InvalidateName - results %x pCOntext %x", f, pContext ) ;

						//_ASSERT( f ) ;
						f =
						AssociateContextWithName(	pNameCache,
													(LPBYTE)szNameBuff,
													cb,
													(LPBYTE)&rgbData[0],
													cbData,
													&mapping,
													(PSECURITY_DESCRIPTOR)rgbSecurityDescriptor,
													pContext,
													TRUE
													) ;

						DebugTrace( 0, "Second AssociateContextWIthName - results %x pCOntext %x", f, pContext ) ;

						//_ASSERT( f ) ;


						//
						//	Now let's go ahead and stick in a plane jane name !
						//

						cb =
							wsprintf( szNameBuff, "%s\\%d.NAMEDATAONLY.\0", g_szDir, i ) ;
						f = AssociateContextWithName(	pNameCache,
														(LPBYTE)szNameBuff,
														cb,
														(LPBYTE)&rgbData[0],
														cbData,
														&mapping,
														(PSECURITY_DESCRIPTOR)rgbSecurityDescriptor,
														0,
														FALSE
														) ;

						//
						//	Now remove it !
						//
						//
						//	Let's immediately turn around and remove the entry and then re-insert it !
						//
						f = InvalidateName( pNameCache,
											(LPBYTE)szNameBuff,
											cb
											) ;
						f = AssociateContextWithName(	pNameCache,
														(LPBYTE)szNameBuff,
														cb,
														(LPBYTE)&rgbData[0],
														cbData,
														&mapping,
														(PSECURITY_DESCRIPTOR)rgbSecurityDescriptor,
														0,
														FALSE
														) ;

					}
					g_NameContextLock.ShareUnlock() ;
					DebugTrace( 0, "Insert returned %d GLE %x", f, GetLastError() ) ;
				}
			}



			if( pSyncContext == 0 ) {
				if( !fOrderCreate ) {
					if( iSkipCreate > 33 ) {
						wsprintf( szBuff, "%s\\%d", g_szDir, i ) ;
						pSyncContext =
							CacheCreateFile(	szBuff,
												CreateCallback,
												0,
												FALSE
												) ;
						DebugTrace( 0, "CacheCreateFile SYNC results %x", pSyncContext ) ;

					}
				}
			}

			if( pSyncContext ) {
				BYTE	rgbSecurityDescriptor[2048] ;

				DWORD	cbSecurityDescriptor ;
				BOOL	f =
					GetFileSecurity(
								szBuff,
								OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
								(PSECURITY_DESCRIPTOR)&rgbSecurityDescriptor[0],
								sizeof(rgbSecurityDescriptor),
								&cbSecurityDescriptor
								) ;
				if( !f ) {
					ErrorTrace( 0, "Failed to get security for =%s= GLE %x, cb %d\n", szBuff, GetLastError(), cb ) ;
				}	else	{
					g_NameContextLock.ShareLock() ;
					PNAME_CACHE_CONTEXT	pNameCache = g_rgpNameContext[iNameCache] ;
					if( pNameCache ) {
						f =
						AssociateContextWithName(	pNameCache,
													(LPBYTE)szNameBuff,
													cb,
													(LPBYTE)&rgbData[0],
													cbData,
													&mapping,
													(PSECURITY_DESCRIPTOR)rgbSecurityDescriptor,
													pSyncContext,
													TRUE
													) ;

						DebugTrace( 0, "First SYNC AssociateContextWIthName - results %x pSyncContext %x", f, pSyncContext ) ;

						//
						//	Let's immediately turn around and remove the entry and then re-insert it !
						//
						f = InvalidateName( pNameCache,
											(LPBYTE)szNameBuff,
											cb
											) ;

						DebugTrace( 0, "First SYNC InvalidateName - results %x pSyncContext %x", f, pSyncContext ) ;

						//_ASSERT( f ) ;
						f =
						AssociateContextWithName(	pNameCache,
													(LPBYTE)szNameBuff,
													cb,
													(LPBYTE)&rgbData[0],
													cbData,
													&mapping,
													(PSECURITY_DESCRIPTOR)rgbSecurityDescriptor,
													pSyncContext,
													TRUE
													) ;

						//_ASSERT( f ) ;
						DebugTrace( 0, "Second AssociateContextWithName - results %x pSyncContext %x", f, pSyncContext ) ;


						//
						//	Now let's go ahead and stick in a plane jane name !
						//

						cb =
							wsprintf( szNameBuff, "%s\\%d.NAMEDATAONLY.\0", g_szDir, i ) ;
						f = AssociateContextWithName(	pNameCache,
														(LPBYTE)szNameBuff,
														cb,
														(LPBYTE)&rgbData[0],
														cbData,
														&mapping,
														(PSECURITY_DESCRIPTOR)rgbSecurityDescriptor,
														0,
														FALSE
														) ;

						//
						//	Now remove it !
						//
						//
						//	Let's immediately turn around and remove the entry and then re-insert it !
						//
						f = InvalidateName( pNameCache,
											(LPBYTE)szNameBuff,
											cb
											) ;
						f = AssociateContextWithName(	pNameCache,
														(LPBYTE)szNameBuff,
														cb,
														(LPBYTE)&rgbData[0],
														cbData,
														&mapping,
														(PSECURITY_DESCRIPTOR)rgbSecurityDescriptor,
														0,
														FALSE
														) ;

					}
					g_NameContextLock.ShareUnlock() ;
					DebugTrace( 0, "Insert returned %d GLE %x", f, GetLastError() ) ;
				}
				ReleaseContext( pSyncContext ) ;
			}



			CacheSearches ++ ;
			if( !pContext )
				CacheSFails ++ ;

			DebugTrace( (DWORD_PTR)this, "i %x szBuff %s pContext %x", i, szBuff, pContext ) ;

		}	while( pContext == 0 ) ;

		//
		//	Go issue an read !
		//
		_ASSERT( i != 0 ) ;
		m_pContext = pContext ;
		m_id = i ;

		TraceFunctLeave() ;
	}

	void
	GetWriteContext()	{
		HANDLE	h = INVALID_HANDLE_VALUE ;
		do	{
			do	{
				h = CreateInbound( m_id ) ;
			}	while( h==INVALID_HANDLE_VALUE ) ;
			m_pContext = AssociateFile( h ) ;

			CacheCreates++ ;

			if( m_pContext == 0 )	{
				CacheCFails ++ ;
				_VERIFY( CloseHandle( h ) ) ;
			}
		}	while( m_pContext == 0 ) ;
	}

	static
	void
	WriteCompletion(	FIO_CONTEXT*	pContext,
				FH_OVERLAPPED*	pOverlapped,
				DWORD			cb,
				DWORD			dwCompletionStatus
				) {

		char	szBuff[254] ;
		TraceFunctEnter( "SESSION::WriteCompletion" ) ;

		DebugTrace( (DWORD_PTR)pOverlapped, "pOverlapped %x pContext %x cb %x dwStatus %x",
			pOverlapped, pContext, cb, dwCompletionStatus ) ;

		SESSION*	pSession = (SESSION*)pOverlapped;
		_ASSERT( pSession->m_pContext == pContext ) ;

		wsprintf( szBuff, "%s\\%d", g_szDir, pSession->m_id ) ;
		if( !InsertFile( szBuff, pSession->m_pContext, FALSE ) ) {
			ReleaseContext( pSession->m_pContext ) ;
		}
		pSession->m_pContext = 0;
		pSession->m_id = 0xFFFFFFFF ;
#if 0
		pSession->m_cReadCount = 0 ;
		//
		//	Check the file into the cache !
		//
		if( dwCompletionStatus == NO_ERROR ) {
			_ASSERT( cb = sizeof(DWORD)*1024 ) ;
			pSession->m_pContext = 0;
			pSession->m_id = 0xFFFFFFFF ;
			pSession->GetReadContext() ;
			pSession->ReadSession() ;
		}	else	{
			_ASSERT( 1==0 ) ;
		}
#endif

		SetEvent( pSession->m_hEventWrite ) ;

		InterlockedDecrement( &g_cIOCount ) ;
		TraceFunctLeave() ;
	}

	static
	void
	ReadCompletion(	FIO_CONTEXT*	pContext,
				FH_OVERLAPPED*	pOverlapped,
				DWORD			cb,
				DWORD			dwCompletionStatus
				) {

		TraceFunctEnter( "SESSION::ReadCompletion" ) ;

		_ASSERT( cb != 0 ) ;

		SESSION*	pSession = (SESSION*)pOverlapped ;

		_ASSERT( cb==sizeof( pSession->m_rgdwBuff ) ) ;


		pSession->m_cReadCount ++ ;

		DebugTrace( (DWORD_PTR)pSession, "pOverlapped %x pContext %x cb %x dw %x",
			pOverlapped, pContext, cb, dwCompletionStatus ) ;

		ReleaseContext( pSession->m_pContext ) ;
		pSession->m_pContext = 0;
		pSession->m_id = 0xFFFFFFFF ;

#if 0
		if( pSession->m_cReadCount < g_cNumReads ) {
			pSession->GetReadContext() ;
			pSession->ReadSession() ;
		}	else	{
			pSession->GetWriteContext() ;
			pSession->WriteSession() ;
		}
#endif
		if( !g_fShutdown ) {

			DebugTrace( (DWORD_PTR)pOverlapped, "Sleeping" ) ;

			Sleep( g_cFindSleep ) ;
			pSession->GetReadContext() ;
			pSession->ReadSession() ;

			DebugTrace( (DWORD_PTR)pSession, "pSession m_id %x m_pContext %x",
				pSession->m_id, pSession->m_pContext ) ;

		}
		InterlockedDecrement( &g_cIOCount ) ;
	}

	void
	ReadSession()	{

		TraceFunctEnter( "SESSION::ReadSession" ) ;
		DebugTrace( (DWORD_PTR)this, "m_pContext %x m_id %x", m_pContext, m_id ) ;

		ZeroMemory( m_rgdwBuff, sizeof( m_rgdwBuff ) ) ;
		ZeroMemory( &m_Overlapped, sizeof( m_Overlapped ) ) ;
		m_Overlapped.pfnCompletion = ReadCompletion ;
		if( FIOReadFile(	m_pContext,
						(LPVOID)&m_rgdwBuff,
						1024 * sizeof(DWORD),
						&m_Overlapped
						)	)	{
			InterlockedIncrement( &g_cIOCount ) ;
		}	else	{
			DWORD	dw = GetLastError() ;
			_ASSERT( FALSE ) ;
		}
		TraceFunctLeave( ) ;
	}

	void
	WriteSession()	{

		TraceFunctEnter( "SESSION::WriteSession" ) ;
		DebugTrace( (DWORD_PTR)this, "m_pContext %x m_id %x", m_pContext, m_id ) ;

		FillDWORD( m_rgdwBuff, m_id, 1024 ) ;
		ZeroMemory( &m_Overlapped, sizeof( m_Overlapped ) ) ;
		m_Overlapped.pfnCompletion = WriteCompletion ;
		BOOL fReturn =
			FIOWriteFile(	m_pContext,
							(LPVOID)&m_rgdwBuff,
							1024 * sizeof(DWORD),
							&m_Overlapped
							) ;
		if( fReturn ) {
			InterlockedIncrement( &g_cIOCount ) ;
		}
		_ASSERT( fReturn ) ;
		DWORD	dw = GetLastError() ;
	}
} ;



DWORD	WINAPI
InboundThread( LPVOID lpv ) {

	TraceFunctEnter( "InboundThread" ) ;

	SESSION	CreateSession[10] ;
	DWORD	iSession = 0 ;

	while( 1 ) {

		DWORD	dw = WaitForSingleObject( g_hShutdown, g_cCreateSleep ) ;
		if( dw == WAIT_OBJECT_0 )	{
			break ;
		}

		DebugTrace( 0, "create new file - CreateSession %x", &CreateSession ) ;

		WaitForSingleObject( CreateSession[iSession].m_hEventWrite, INFINITE ) ;
		CreateSession[iSession].GetWriteContext() ;
		CreateSession[iSession].WriteSession() ;
		iSession++ ;
		if( iSession == 10 )	{
			iSession = 0 ;
//			CacheRemoveFiles( g_szDir, TRUE ) ;
		}
	}

	HANDLE	rgh[10] ;
	for( int i=0; i<10; i++ )	{
		rgh[i] = CreateSession[i].m_hEventWrite ;
	}

	WaitForMultipleObjects( 10, rgh, TRUE, INFINITE ) ;

	TraceFunctLeave( ) ;
	return	 0 ;
}


int
NameCompare(	DWORD	cbKey1,
				LPBYTE	lpbKey1,
				DWORD	cbKey2,
				LPBYTE	lpbKey2
				)	{

	int	i = (int)cbKey1 - (int)cbKey2 ;
	if( i==0 ) {
		i = memcmp( lpbKey1, lpbKey2, cbKey1 ) ;
	}
	return	i ;
}

BOOL
NameAccessCheck(	IN	PSECURITY_DESCRIPTOR	pSecDesc,
					IN	HANDLE					hHandle,
					IN	DWORD					dwAccess,
					IN	PGENERIC_MAPPING		GenericMapping,
					IN	PRIVILEGE_SET*			PrivilegeSet,
					IN	LPDWORD					PrivilegeSetSize,
					IN	LPDWORD					GrantedAccess,
					IN	LPBOOL					AccessGranted
					)	{

	return
	::AccessCheck(	pSecDesc,
					hHandle,
					dwAccess,
					GenericMapping,
					PrivilegeSet,
					PrivilegeSetSize,
					GrantedAccess,
					AccessGranted
					) ;
}


DWORD	WINAPI
NameCacheThread(	LPVOID	lpv )	{

	char	szBuff[128] ;
	//
	//	Initialize a whole bunch of Name Context's to start with !
	//
	DWORD	cMax = g_cNameContext + g_cNameContext / 2 ;

	g_NameContextLock.ExclusiveLock() ;
	for( DWORD	i=0; i<g_cNameContext; i++ ) {
		DWORD	cb = wsprintf( szBuff, "NameTestCache %d", i ) ;
		g_rgpNameContext[i] = FindOrCreateNameCache(	szBuff,
														NameCompare,
														0,
														0,
														0
														) ;
		if( g_rgpNameContext[i] ) {
			::SetNameCacheSecurityFunction(	g_rgpNameContext[i], ::NameAccessCheck ) ;
		}
	}
	g_NameContextLock.ExclusiveUnlock() ;

	DWORD	iSlot = 0 ;
	DWORD	iName = cMax / 2 ;
	while( 1 ) {
		DWORD	dw = WaitForSingleObject( g_hShutdown, g_cNameTimeout ) ;
		if( dw == WAIT_OBJECT_0 ) {
			break ;
		}

		wsprintf( szBuff, "NameTestCache %d", iName ) ;

		PNAME_CACHE_CONTEXT	pNameContextTemp =
				FindOrCreateNameCache(	szBuff,
										NameCompare,
										0,
										0,
										0
										) ;
		PNAME_CACHE_CONTEXT	pDelete = 0 ;
		_ASSERT( pNameContextTemp != 0 ) ;


		//
		//	Set the security callback pointer !
		//
		if( pNameContextTemp ) {
			::SetNameCacheSecurityFunction(	pNameContextTemp, ::NameAccessCheck ) ;
		}

		g_NameContextLock.ExclusiveLock() ;
		pDelete = g_rgpNameContext[iSlot] ;
		g_rgpNameContext[iSlot] = pNameContextTemp ;
		g_NameContextLock.ExclusiveUnlock() ;

		_ASSERT( pDelete != 0 ) ;

		ReleaseNameCache( pDelete ) ;

		iSlot += 3 ;
		iSlot %= g_cNameContext ;
		iName += 5 ;
		iName %= cMax ;

	}
	g_NameContextLock.ExclusiveLock() ;
	for( i=0; i < g_cNameContext; i++ ) {
		if( g_rgpNameContext[iSlot] ) {
			ReleaseNameCache( g_rgpNameContext[iSlot] ) ;
			g_rgpNameContext[iSlot] = 0 ;
		}
	}
	g_NameContextLock.ExclusiveUnlock() ;
	return 0 ;
}


COUNTER_ID	rgCounters[MAX_PERF_COUNTERS] ;


//
//  Create a perf object
//
CPerfObject IfsPerfObject;


TESTDLL_EXPORT
BOOL
StartTest(	DWORD	cPerSecondCreates,
			DWORD	cPerSecondFind,
			DWORD	cParallelFinds ,
			char*	szDir
			)	{

	InitAsyncTrace() ;
	TraceFunctEnter( "StartTest" ) ;

#if 0
    if( !IfsPerfObject.Create(
                    IFS_PERFOBJECT_NAME,    // Name of object
                    TRUE,                   // Has instances
                    IFS_PERFOBJECT_HELP     // Object help
                    )) {
        DebugTrace( 0,"Failed to create object %s\n",IFS_PERFOBJECT_NAME);
        return	FALSE ;
    }

    //
    //  Create an instance for this object
    //
    INSTANCE_ID iid = IfsPerfObject.CreateInstance(IFS_PERFOBJECT_INSTANCE);
    if( iid == (INSTANCE_ID)-1 ) {
        DebugTrace( 0,"Failed to create instance\n");
        return	FALSE ;
    }



    rgCounters[CACHE_CREATES] = IfsPerfObject.CreateCounter(
                                                CACHE_CREATES_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                CACHE_CREATES_HELP
                                                );
    if( rgCounters[CACHE_CREATES] == (COUNTER_ID)-1 ) {
        DebugTrace( 0,"Failed to create counter\n");
        return	FALSE ;
    }

    rgCounters[CACHE_SEARCHES] = IfsPerfObject.CreateCounter(
                                                CACHE_SEARCHES_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                CACHE_SEARCHES_HELP
                                                );
    if( rgCounters[CACHE_SEARCHES] == (COUNTER_ID)-1 ) {
        DebugTrace( 0,"Failed to create counter\n");
        return	FALSE ;
    }

    rgCounters[CACHE_CALLBACKS] = IfsPerfObject.CreateCounter(
                                                CACHE_CALLBACKS_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                CACHE_CALLBACKS_HELP
                                                );
    if( rgCounters[CACHE_CALLBACKS] == (COUNTER_ID)-1 ) {
        DebugTrace( 0,"Failed to create counter\n");
        return	FALSE ;
    }

    rgCounters[CACHE_CFAILS] = IfsPerfObject.CreateCounter(
                                                CACHE_CFAIL_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                CACHE_CFAIL_HELP
                                                );
    if( rgCounters[CACHE_CFAILS] == (COUNTER_ID)-1 ) {
        DebugTrace( 0,"Failed to create counter\n");
        return	FALSE ;
    }

    rgCounters[CACHE_SFAILS] = IfsPerfObject.CreateCounter(
                                                CACHE_SFAIL_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                CACHE_SFAIL_HELP
                                                );
    if( rgCounters[CACHE_SFAILS] == (COUNTER_ID)-1 ) {
        DebugTrace( 0,"Failed to create counter\n");
        return	FALSE ;
    }

    if( !CacheCreates.Create( IfsPerfObject, rgCounters[CACHE_CREATES], iid ) ) {
        DebugTrace( 0,"Failed to create counter object : %d\n", GetLastError());
        return	FALSE ;
    }

    if( !CacheSearches.Create( IfsPerfObject, rgCounters[CACHE_SEARCHES], iid ) ) {
        DebugTrace( 0,"Failed to create counter object : %d\n", GetLastError());
        return	FALSE ;
    }

    if( !CacheCallbacks.Create( IfsPerfObject, rgCounters[CACHE_CALLBACKS], iid ) ) {
        DebugTrace( 0,"Failed to create counter object : %d\n", GetLastError());
        return	FALSE ;
    }

    if( !CacheCFails.Create( IfsPerfObject, rgCounters[CACHE_CFAILS], iid ) ) {
        DebugTrace( 0,"Failed to create counter object : %d\n", GetLastError());
        return	FALSE ;
    }

    if( !CacheSFails.Create( IfsPerfObject, rgCounters[CACHE_SFAILS], iid ) ) {
        DebugTrace( 0,"Failed to create counter object : %d\n", GetLastError());
        return	FALSE ;
    }
#endif


    HANDLE  hToken2 = 0 ;
    if(
            !OpenProcessToken(      GetCurrentProcess(),
                                                    TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                                                    &hToken2 ) )    {
            DWORD   dw = GetLastError() ;
            g_hToken = 0 ;
    }       else    {

            if( !DuplicateToken( hToken2,
                                            SecurityImpersonation,
                                            &g_hToken
                                            ) )     {
                    DWORD   dw = GetLastError() ;
                    g_hToken = 0 ;
            }

            CloseHandle( hToken2 ) ;

    }




	InitializeCriticalSection( &critRand ) ;

	if( !InitializeCache() ) {
		return	FALSE ;
	}

	if( !InitializeCache() ) {
		return	FALSE ;
	}	else	{
		if( !TerminateCache() ) {
			return	FALSE ;
		}
	}
	if( !TerminateCache() ) {
		return	FALSE ;
	}	else	{
		if( !InitializeCache() )
			return	FALSE ;
	}

	lstrcpy( g_szDir, szDir ) ;
	g_cFindSleep = 1000 / cPerSecondFind ;
	g_cCreateSleep = 1000 / cPerSecondCreates ;

	rgSession = new	SESSION[cParallelFinds] ;

	_ASSERT( rgSession ) ;

	g_rgpNameContext = new	PNAME_CACHE_CONTEXT[g_cNameContext] ;

	_ASSERT( g_rgpNameContext ) ;

	g_hShutdown = CreateEvent( 0, TRUE, FALSE, 0 ) ;

	DWORD	dwJunk ;

	g_hNameContextThread = CreateThread(	0,
											0,
											NameCacheThread,
											0,
											0,
											&dwJunk
											) ;

	g_hCreateThread =	CreateThread(	0,
										0,
										InboundThread,
										0,
										0,
										&dwJunk
										) ;

	//
	//	Wait a little to create inbound messages before
	//	starting !
	//
	Sleep( 1000 * 20 ) ;

	//
	//	Now initiate the correct number of sessions
	//

	for( DWORD	i=0; i < cParallelFinds; i++ ) {
		rgSession[i].GetReadContext() ;
		rgSession[i].ReadSession() ;
	}
	return	TRUE ;
}

TESTDLL_EXPORT
void
StopTest()	{

	TraceFunctEnter( "StopTest" ) ;

	DebugTrace( 0, "Signal Shutdown" ) ;

	SetEvent( g_hShutdown ) ;
	g_fShutdown = TRUE ;

	do	{

		Sleep( 5000 ) ;
		DebugTrace( 0, "g_cIOCount is now %x", g_cIOCount ) ;

	}	while( g_cIOCount ) ;

	DebugTrace( 0, "Close Create Thread %x", g_hCreateThread ) ;
	CloseHandle( g_hCreateThread ) ;

	DebugTrace( 0, "Delete Sessions - rgSession %x", rgSession ) ;
	delete[]	rgSession ;

	DeleteCriticalSection( &critRand ) ;

	if( !TerminateCache() )
		_ASSERT( FALSE ) ;

	CloseHandle( g_hToken ) ;
	delete[]	g_rgpNameContext ;

	TermAsyncTrace() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\fhashex\test\fhashex.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	<dbgtrace.h>
#include	"fhashex.h"
#include	<stdlib.h>
#include	<iostream.h>
#include	<fstream.h>
#include	<strstrea.h>


//
//	Variable holds the file from which we insert all of our hash table entries !
//
char	g_szInsertFile[MAX_PATH] ;

//
//	The file which we use to check entries with the hash table !
//
char	g_szCheckFile[MAX_PATH] ;

//
//	Number of times to repeat scans of files !
//
DWORD	g_numIterations = 1 ;

//
//	String constants for retrieving values from .ini file !
//
#define INI_KEY_INSERTFILE	"InsertFile"
#define INI_KEY_CHECKFILE	"CheckFile"
#define	INI_KEY_NUMITERATIONS "NumIterations"

char g_szDefaultSectionName[] = "fhashex";
char *g_szSectionName = g_szDefaultSectionName;

void usage(void) {
/*++

Routine Description : 

	Print Usage info to command line user !

Arguments : 

	None.

Return Value : 

	None.

--*/
	printf("usage: fhashex.exe [<ini file>] [<ini section name>]\n"
		"  INI file keys (default section [%s]):\n"
		"    %s (No default provided - user must specify)\n"
		"    %s (No default provided - user must specify)\n"
		"    %s (default=%d)\n"
		"    InsertFile - file must be formatted as KeyString WhiteSpace DataStrings EOL\n"
		"	    NOTE : KeyString must be unique on each line for test to be valid !\n"
		"	 CheckFile - file must be formatted as KeyString WhiteSpace DataStrings EOL \n"
		"       NOTE : If DataStrings not present the test will verify that the key is \n"
		"       not present in the hash table.  If DataStrings is present test will validate \n"
		"       that when the Key is found in hash table DataStrings match !\n",
		g_szDefaultSectionName,
		INI_KEY_INSERTFILE,
		INI_KEY_CHECKFILE,
		INI_KEY_NUMITERATIONS,
		g_numIterations
		) ;
	exit(1);
}


int GetINIDword(
			char *szINIFile, 
			char *szKey, 
			DWORD dwDefault
			) {
/*++

Routine Description : 

	Helper function which retrieves values from .ini file !

Arguments : 

	szINIFile - name of the ini file
	szKey - name of the key
	dwDefault - default value for the parameter

Return Value : 

	The value retrieved from the .ini file or the default !

--*/
	char szBuf[MAX_PATH];

	GetPrivateProfileString(g_szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

void parsecommandline(
			int argc, 
			char **argv
			) {
/*++

Routine Description : 

	Get the name of the .ini file and 
	setup our test run !

Arguments : 

	Command line parameters

Return Value : 

	None - will exit() if the user has not
		properly configured the test !

--*/
	if (argc == 0 ) usage();
	if (strcmp(argv[0], "/help") == 0) usage(); 	// show help

	char *szINIFile = argv[0];
	if (argc == 2) char *g_szSectionName = argv[1];

	g_szInsertFile[0] = '\0' ;
	g_szCheckFile[0] = '\0' ;


	GetPrivateProfileString(	g_szSectionName,
								INI_KEY_INSERTFILE,
								"",
								g_szInsertFile,
								sizeof( g_szInsertFile ),
								szINIFile
								) ;

	GetPrivateProfileString(	g_szSectionName,
								INI_KEY_CHECKFILE,
								"",
								g_szCheckFile,
								sizeof( g_szCheckFile ),
								szINIFile
								) ;

	g_numIterations =	GetINIDword( szINIFile,
									INI_KEY_NUMITERATIONS,
									g_numIterations
									) ;

	if( g_szInsertFile[0] =='\0' ||
		g_szCheckFile[0] == '\0' )	{
		usage() ;
	}
}


typedef	const	char	*	const	&	STRINGREF ;
//typedef	LPSTR	STRINGREF ;

//
//	This is a class that we use to test our TFHashEx template !
//	
//
class	TestData	{
public : 
	//
	//	Point to the data !
	//
	LPSTR	m_lpstrData ;
	//
	//	The string that is a key to our entry !
	//
	LPSTR	m_lpstrKey ;

	//
	//	Used by the template to chain Hash Buckets !
	//
	class	TestData*	m_pNext ;

#if 0 
	//
	//	Return the key - required by TFHashEx
	//
	void
	GetKey(LPSTR &lpstrValue) {	
		lpstrValue = m_lpstrKey;
	}
#endif

	STRINGREF
	GetKey( )	{
		return	m_lpstrKey ;
	}

	int
	MatchKey(	STRINGREF	lpstrMatch )	{
		return	lstrcmp( lpstrMatch, m_lpstrKey ) ==0 ;
	}

#if 0 
	//
	//	Does the key match what we're holding - required by TFHashEx
	//
	int	
	MatchKey(	LPSTR&	lpstrMatch ) {
		return	lstrcmp( lpstrMatch, m_lpstrKey ) == 0 ;
	}
#endif

	//
	//	Construct a object !
	//
	TestData(	LPSTR	lpstrKey, 
				LPSTR	lpstrData
				) : m_pNext( 0 )	{

		DWORD	cb = lstrlen( lpstrKey ) ;
		m_lpstrKey = new char[cb+1] ;
		if( m_lpstrKey ) {
			CopyMemory( m_lpstrKey, lpstrKey, cb+1 ) ;
		}
		cb = lstrlen( lpstrData ) ;
		m_lpstrData = new char[cb+1] ;
		if( m_lpstrData ) {
			CopyMemory( m_lpstrData, lpstrData, cb+1 ) ;
		}
	}
	
	//
	//	Release our strings when destroyed !
	//
	~TestData()	{
		if( m_lpstrKey ) 
			delete	m_lpstrKey ;
		if( m_lpstrData ) 
			delete	m_lpstrData ;
	}
} ;

DWORD  
HashFunction( STRINGREF lpstr )	{
/*++

Routine Description : 

	Very simple hash function - not intended to be a good performer !

Arguments : 

	Our key - a string !

Return Value : 

	Hash value 

--*/

	DWORD	dwHash = 0 ;
	
	const	char*	pch = lpstr ;
	while( *pch!=0 ) {
		dwHash += *pch++ ;
	}
	return	dwHash ;
}

typedef	TFHashEx< TestData, LPSTR, STRINGREF >	STRINGTABLE ;


int  __cdecl
main( int argc, char** argv ) {


	parsecommandline( --argc, ++argv ) ;

	//
	//	Loop the specified number of times !
	//
	for( DWORD	i=0; i<g_numIterations; i++ ) {

		//
		//	Use C++ streams to read the files !
		//
		ifstream	inserts( g_szInsertFile ) ;
		ifstream	checks( g_szCheckFile ) ;

		//
		//	Make sure we could open both files !
		//
		if( inserts.is_open() && checks.is_open() ) {


			char	szKey[1024] ;
			char	szData[1024] ;
			char	szBuffer[1024] ;
			int		lines = 0 ;

			//
			//	Initialize the hash table !
			//
			STRINGTABLE	table ;
			table.Init(	&TestData::m_pNext,
						128,
						8,
						HashFunction,
						2,
						TestData::GetKey,
						TestData::MatchKey
						) ;

			//
			//	Scan the inserts file, inserting each entry !
			//	
			while( !inserts.eof() ) {
				szKey[0] = '\0' ;
				szData[0] = '\0' ;
				char*	pKey = szKey ;

				//
				//	Get the Key !
				//
				inserts >> ws >> szKey >> ws ;
				//
				//	The rest of the line is the data !
				//
				inserts.getline( szData, sizeof( szData ), '\n' ) ;

				//
				//	If we got something - insert it !
				//
				if( szKey[0] != '\0' && szData[0] != '\0' ) {

					//
					//	Verify not already present in hash table !
					//
					TestData*	pt = table.SearchKeyHash( HashFunction( szKey ), pKey ) ;
					_ASSERT( pt == 0 ) ;
					if( pt != 0 ) {
						return	-1 ;
					}

					//
					//	Make a new structure to put into table !
					//
					pt = new TestData( szKey, szData ) ;

					//	Insert it !
					if( !table.InsertData( *pt ) ) {
						_ASSERT( FALSE ) ;
						return	-1 ;
					}
		
					//	Verify that we can immediately find it !
					pt = table.SearchKey( pKey ) ;
					_ASSERT( pt != 0 ) ;
					if( pt == 0 ) {
						return	-1 ;
					}
				}
				lines ++ ;
				if( lines %32 == 0 ) {
					printf( "INSERTS - lines scanned - %d\n", lines ) ;
				}
			}
	
			//
			//	Now go through the specified file verifying that 
			//	everything 
			//
			lines = 0 ;
			while( !checks.eof() )	{
				szKey[0] = '\0' ;
				szData[0] = '\0' ;
				STRINGREF	pKey = szKey ;
				char*	pData = szData ;

				//
				//	Get the key 
				//
				checks >> ws >> szKey ;

				//
				//	Have to be carefull getting the data - it may be blank
				//	and we don't want to consume the next line !
				//

				checks.getline( szBuffer, sizeof( szBuffer), '\n' ) ;					
				istrstream	tstr( szBuffer, lstrlen( szBuffer )) ;
				tstr >> ws ;
				tstr.getline( szData, sizeof( szData ), '\n' ) ;

				//
				//	Look for the key - and verify what we find !
				//
				TestData*	pt = table.SearchKey( pKey ) ;
				if( pt ) {
					if( lstrcmp( pt->m_lpstrKey, szKey ) != 0 ) {
						_ASSERT( FALSE ) ;
						return	-1 ;
					}
					if( lstrcmp( pt->m_lpstrData, szData ) != 0 ) {
						_ASSERT( FALSE ) ;
						return	-1 ;
					}
				}	else	{
					if( szData[0] != '\0' ) {
						_ASSERT( FALSE ) ;
						return	-1 ;
					}
				}

				//
				//	Try to delete the key - and check what happens !
				//
				pt = table.DeleteData( pKey ) ;
				if( pt ) {
					if( lstrcmp( pt->m_lpstrKey, szKey ) != 0 ) {
						_ASSERT( FALSE ) ;
						return	-1 ;
					}
					if( lstrcmp( pt->m_lpstrData, szData ) != 0 ) {
						_ASSERT( FALSE ) ;
						return	-1 ;
					}
				}
				delete	pt ;

				//
				//	By now the key better not be present no matter what happened !
				//
				pt = table.SearchKey( pKey ) ;
				if( pt ) {
					_ASSERT( FALSE ) ;
					return	-1 ;
				}
				lines ++ ;
				if( lines %32 == 0 ) {
					printf( "CHECKS - lines scanned - %d\n", lines ) ;
				}

			}
		}
	}
	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\crchash.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crchash.cpp

Abstract:
	CRC Hash function
*/

//
//
// Hashing function adopted from the INN code (see copyright below)
//

/*
    Copyright 1988 Jon Zeeff (zeeff@b-tech.ann-arbor.mi.us)
    You can use this code in any manner, as long as you leave my name on it
    and don't hold me responsible for any problems with it.

 * This is a simplified version of the pathalias hashing function.
 * Thanks to Steve Belovin and Peter Honeyman
 *
 * hash a string into a long int.  31 bit crc (from andrew appel).
 * the crc table is computed at run time by crcinit() -- we could
 * precompute, but it takes 1 clock tick on a 750.
 *
 * This fast table calculation works only if POLY is a prime polynomial
 * in the field of integers modulo 2.  Since the coefficients of a
 * 32-bit polynomial won't fit in a 32-bit word, the high-order bit is
 * implicit.  IT MUST ALSO BE THE CASE that the coefficients of orders
 * 31 down to 25 are zero.  Happily, we have candidates, from
 * E. J.  Watson, "Primitive Polynomials (Mod 2)", Math. Comp. 16 (1962):
 *  x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + x^0
 *  x^31 + x^3 + x^0
 *
 * We reverse the bits to get:
 *  111101010000000000000000000000001 but drop the last 1
 *         f   5   0   0   0   0   0   0
 *  010010000000000000000000000000001 ditto, for 31-bit crc
 *     4   8   0   0   0   0   0   0
 */

#include <windows.h>
#include "crchash.h"

static long CrcTable[128];
static BOOL bInitialized = FALSE;

/*
 - crcinit - initialize tables for hash function
 */
void crcinit()
{
    INT i, j;
    DWORD sum;

	if(bInitialized) return;

    for (i = 0; i < 128; ++i) {
        sum = 0;
        for (j = 7 - 1; j >= 0; --j) {
            if (i & (1 << j)) {
                sum ^= POLY >> j;
            }
        }
        CrcTable[i] = sum;
    }

	bInitialized = TRUE;
} // crcinit

/*
 - hash - Honeyman's nice hashing function
 */
DWORD CRCHash(const BYTE*	Key, DWORD Length)
{
    DWORD sum = 0;

    while ( Length-- ) {

        sum = (sum >> 7) ^ CrcTable[(sum ^ (*Key++)) & 0x7f];
    }
    return(sum);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\directry.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    directry.cpp

Abstract:

    This module contains definition for the CDirectory base class

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

	Alex Wetmore (AWetmore) split into directry.cpp (from hash.cpp)

--*/

#include <windows.h>
#include <xmemwrpr.h>
#include <dbgtrace.h>
#include "directry.h"
#include "hashmacr.h"

BOOL
CDirectory::IsValid()	{

	if( !(DWORD(1<<m_cBitDepth) <= m_cMaxDirEntries)	)	{
		return	FALSE ;
	}
	if( m_pDirectory == NULL )
		return	FALSE ;

	if( IsBadWritePtr( (LPVOID)m_pDirectory, m_cMaxDirEntries ) )
		return	FALSE ;

	//
	//	Now go and check that m_cDeepPages is correct - we can do this
	//	by spinning through the directory and seeing how many entries
	//	are unique (only occur once)!
	//	Note that non-unique values must occur in consecutive
	//	locations.
	//

	DWORD	UniqueCount = 0 ;
	for( DWORD	i=0; i < DWORD(1<<m_cBitDepth); ) {

		for( DWORD j=i+1; j < DWORD(1 << m_cBitDepth); j++ ) {
			if( m_pDirectory[j] != m_pDirectory[i] )
				break ;
		}
		if( j == (i+1) ) {
			if( m_pDirectory[i] != 0 ) {
				UniqueCount ++ ;
			}
		}
		i = j ;
	}
	if( UniqueCount != m_cDeepPages ) {
		return	FALSE ;
	}

	return	TRUE ;
}

BOOL
CDirectory::IsValidPageEntry(
					PMAP_PAGE	MapPage,
					DWORD		PageNum,
					DWORD		TopLevelIndex ) {
/*++

Routine Description :

	Given an actual Hash Table page, check that all of our
	directory information is consistent with the page contents.
	This function is mostly used for _ASSERT checking.

Arguments :

	MapPage - The Hash Table page we are checking.
	PageNum - The Number of the Page we are examining.
	TopLevelIndex - The index to this CDirectory object within
		the containing top level directory.  This is basically
		the m_cTopBits of a HashValue which selects this directory !

Return Value :

	TRUE if everything is correct
	FALSE otherwise.

--*/


    DWORD startPage, endPage;
	DWORD	dirDepth = m_cTopBits + m_cBitDepth ;

	//
	//	Pages cannot be split accross directory boundaries, which means
	//	they must have more depth than the top tier of the directory !
	//
	if( MapPage->PageDepth < m_cTopBits )
		return FALSE ;

	//
	//	The m_cTopBits of the Page's HashPrefix must put this page into
	//	this sub-directory - check that they do !
	//
	//  BUGBUG -- this was disabled.  since m_pDirectory[] is now a ptr
	//  in CHashMap there wasn't a simple way to generate TopLevelIndex
	//  (awetmore)
	//
//	if( (MapPage->HashPrefix >> (MapPage->PageDepth-m_cTopBits)) !=
//		TopLevelIndex )
//		return	FALSE ;

    //
    // Get the range of directory entries that point to this page
    //
    startPage = MapPage->HashPrefix << (dirDepth - MapPage->PageDepth);
    endPage = ((MapPage->HashPrefix+1) << (dirDepth - MapPage->PageDepth));

	//
	//	Now make sure that we are working with only m_cBitDepth bits and we'll be set !
	//
	startPage &= (0x1 << m_cBitDepth) - 1 ;
	endPage &= (0x1 << (m_cBitDepth)) - 1 ;
	//
	//	It could be that this page fills the entire directory,
	//	in which case we'll end up with endPage == startPage
	//	Test for this and fix the limits !
	//
	if( endPage == 0 ) {
		endPage = (1 << (m_cBitDepth)) ;
	}

	_ASSERT( startPage < endPage ) ;
	_ASSERT( endPage <= DWORD(1<<m_cBitDepth) ) ;

    //DebugTraceX( 0, "SetDirPtrs:Adjusting links for %x. start = %d end = %d", MapPage, startPage, endPage );

    //
    // Are the numbers within range
    //
    if ( (startPage >= endPage) ||
         (endPage > DWORD(1<<m_cBitDepth)) )
    {
        ErrorTraceX( 0, "Cannot map entries for page %d %d %d %d\n", PageNum, startPage, endPage, 0 );
        return FALSE;
    }

	//
	//	Check that all of the directory entries that should reference this page,
	//	actually do so !
	//
	for( DWORD i=startPage; i<endPage; i++ ) {
		if( m_pDirectory[i] != PageNum ) {
			return	FALSE ;
		}
	}
	return	TRUE ;
}


CDirectory::~CDirectory()	{
/*++

Routine Description :

	This function blows away any memory we allocated and
	cleans up everything.  We can not assume that InitializeDirectory()
	was called, as errors may have occurred during boot-up
	that caused InitializeDirectory() to not be called,
	or to fail when it was called.

Arguments :

	None.

Return Value :

	None.

--*/

	if( m_pDirectory ) {

		_ASSERT( m_cBitDepth != 0 ) ;
		_ASSERT( m_cMaxDirEntries != 0 ) ;


		if( m_fHeapAllocate ) {
			delete[]	m_pDirectory ;
		}	else	{
			_VERIFY( VirtualFree( m_pDirectory, 0, MEM_RELEASE ) ) ;
		}
		m_pDirectory = 0 ;
	}

}


LPDWORD
CDirectory::AllocateDirSpace(	WORD	cBitDepth,
								DWORD&	cMaxEntries,
								BOOL&	fHeapAllocate
								) {
/*++

Routine Description :

	Use VirtualAlloc to get some memory to use as a directory.

Arguments ;

	cBitDepth - Number of bits of depth we have to be able to
		hold !

	cMaxEntries - OUT parameter - this gets the maximum number
		of Entries there can be in the directory

	fHeapAllocate - OUT parameter - this gets whether we use the
		CRuntime allocator or VirtualAlloc !

Return Value :

	Pointer to allocated memory if successfull, NULL otherwise.

--*/

	TraceQuietEnter( "CDirectory::AllocateDirSpace" ) ;

	LPDWORD	lpdwReturn = 0 ;
	fHeapAllocate = FALSE ;
	cMaxEntries = 0 ;
	DWORD	cbAlloc = (1 << cBitDepth) * sizeof( DWORD ) ;

	//
	//	Test for OVerflow !!
	//
	if( cbAlloc < DWORD(1 << cBitDepth) || cBitDepth >= 32 ) {
		return	0 ;
	}

	if( cbAlloc < 4096 ) {

		DWORD	cBits = (cBitDepth <6) ? 6 : cBitDepth ;
		DWORD	cdw = (1<<cBits) ;
		
		lpdwReturn = new	DWORD[cdw] ;
		if( lpdwReturn != 0 ) {
			ZeroMemory( lpdwReturn, sizeof(DWORD)*cdw ) ;
			fHeapAllocate = TRUE ;
			cMaxEntries = cdw ;
		}

	}	else	{

		lpdwReturn = (LPDWORD)
						VirtualAlloc(	0,
										cbAlloc,
										MEM_COMMIT,
										PAGE_READWRITE
										) ;

		if( lpdwReturn == 0 ) {

			ErrorTrace( (DWORD_PTR)this, "VirtualAlloc failed cause of %x",
					GetLastError() ) ;

		}	else	{

			MEMORY_BASIC_INFORMATION	mbi ;

			SIZE_T	dwReturn = VirtualQuery(	
									lpdwReturn,
									&mbi,
									sizeof( mbi ) ) ;

			_ASSERT( dwReturn == sizeof( mbi ) ) ;

			cMaxEntries = (DWORD)(mbi.RegionSize / sizeof( DWORD )) ;

		}
	}

	return	lpdwReturn ;
}

BOOL
CDirectory::InitializeDirectory(
					WORD	cTopBits,
					WORD	cInitialDepth
					) {
/*++

Routine Description :

	Allocate inital memory for holding the directory.

Arguments :

	wTopBits - Number of bits that are being used by
		the containing Top Level directory which calls us.

	cInitialDepth - Number of bits of depth we are to
		start out with.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	TraceQuietEnter( "CDirectory::InitializeDirectory" ) ;

	m_pDirectory = AllocateDirSpace( cInitialDepth,
									m_cMaxDirEntries,
									m_fHeapAllocate ) ;

	if( m_pDirectory != 0 ) {
		
		m_cTopBits = cTopBits ;
		m_cBitDepth = cInitialDepth ;

		_ASSERT( IsValid() ) ;
		
	}

	return	TRUE ;
}

PDWORD
CDirectory::GetIndex(	
				DWORD	HashValue
				) {
/*++

Routine Description :

	Given a hash value, return a pointer to a location within
	the Directory corresponding to the hash value.
	The containing Directory has used th top m_cTopBits to select
	us, so we must use the following m_cBitDepth bits
	to find our entry.

	****** ASSUMES LOCK IS HELD - EXCLUSIVE OR SHARED ******

Arguments :

	HashValue - The value we wish to find.

Return Value :

	We always return a NON-NULL pointer to the Page Number
	within the directory.

--*/

	//
	//	Get the relevant m_cTopBits + m_cBitDepth bits
	//

	DWORD	Index =
		
				HashValue >> (32 - (m_cTopBits + m_cBitDepth)) ;

	//
	//	Remove the m_cTopBits leaving us with only m_cBitDepth bits !
	//

	Index &= ((1 << m_cBitDepth) - 1) ;

	_ASSERT( Index < DWORD(1<<m_cBitDepth) ) ;

	return	&m_pDirectory[Index] ;

}

BOOL
CDirectory::ExpandDirectory(
				WORD	cBitsExpand
				)	{
/*++

Routine Description :

	The directory needs to grow in bit depth.
	We will try to allocate a larger piece of memory to hold
	the directory in, and then use the old directory
	to build the new one.

	****** ASSUMES LOCK IS HELD EXCLUSIVE *******

Arguments :

	cBitsExpand - Number of bits in depth to grow by !

Return Value :

	TRUE if successfull, false otherwise !

--*/

	PDWORD	pOldDirectory = m_pDirectory ;
	BOOL	fOldHeapAllocate = m_fHeapAllocate ;

	DWORD	cNewEntries = (0x1 << (m_cBitDepth + cBitsExpand)) * sizeof( DWORD ) ;
	if( cNewEntries > m_cMaxDirEntries ) {

		DWORD	cNewMaxDirEntries = 0 ;
		m_pDirectory = AllocateDirSpace( m_cBitDepth + cBitsExpand,
										cNewMaxDirEntries,
										m_fHeapAllocate
										) ;

		if( m_pDirectory == 0 ) {

			m_pDirectory = pOldDirectory ;
			m_fHeapAllocate = fOldHeapAllocate ;

			_ASSERT( IsValid() ) ;

			return	FALSE ;

		}	else	{

			m_cMaxDirEntries = cNewMaxDirEntries ;
	
		}

	}	

	//
	//	Copy and Expand the old directory into the new, but
	//	start from the tail ends, so that we can do this in
	//	place if we are not allocating new memory.
	//

	DWORD	cRepeat = (0x1 << cBitsExpand) - 1 ;
	
	for( int	idw = (0x1 << m_cBitDepth) - 1; idw >= 0; idw -- ) {

		DWORD	iBase = idw << cBitsExpand ;

		for( int	iRepeat = cRepeat; iRepeat >= 0 ; iRepeat -- ) {

			m_pDirectory[ iBase + iRepeat ] = pOldDirectory[idw] ;

		}
	}
	m_cBitDepth += cBitsExpand ;

	m_cDeepPages = 0 ;	

	if( pOldDirectory != m_pDirectory ) {

		if( fOldHeapAllocate ) {
			delete[]	pOldDirectory ;
		}	else	{
			_VERIFY( VirtualFree( pOldDirectory, 0, MEM_RELEASE ) ) ;
		}

	}

	_ASSERT( IsValid() ) ;

	return	TRUE ;
}


BOOL
CDirectory::SetDirectoryPointers(
					IN	PMAP_PAGE	MapPage,
					IN	DWORD		PageNumber
					)	{

/*++

Routine Description :

	This function sets up the entries within a directory to ensure
	that the page is correctly referenced by the directory.

Arguments :

	MapPage - The page we want the directory to reference
	PageNumber - The number of the page
	MaxDirEntries -

Return Value :

	TRUE if successfull,
	FALSE otherwise.


--*/

	DWORD	dirDepth = m_cBitDepth + m_cTopBits ;
	DWORD	startPage, endPage ;
	
    //
    // Get the range of directory entries that point to this page
    //
    startPage = MapPage->HashPrefix << (dirDepth - MapPage->PageDepth);
    endPage = ((MapPage->HashPrefix+1) << (dirDepth - MapPage->PageDepth));

	//
	//	Now make sure that we are working with only m_cBitDepth bits and we'll be set !
	//
	startPage &= (0x1 << m_cBitDepth) - 1 ;
	endPage &= (0x1 << (m_cBitDepth)) - 1 ;
	//
	//	It could be that this page fills the entire directory,
	//	in which case we'll end up with endPage == startPage
	//	Test for this and fix the limits !
	//
	if( endPage == 0 ) {
		endPage = (1 << (m_cBitDepth)) ;
	}

	_ASSERT( startPage < endPage ) ;
	_ASSERT( endPage <= DWORD(1<<m_cBitDepth) ) ;

    DebugTraceX( 0, "SetDirPtrs:Adjusting links for %x. start = %d end = %d\n",
        MapPage, startPage, endPage );

	//
	// Do the actual mapping
	//
	DWORD	OldValue = m_pDirectory[startPage] ;
	for ( DWORD	j = startPage; j < endPage; j++ )
	{
		m_pDirectory[j] = PageNumber ;
	}

	//
	//	Whenever we split page, we always create 2 pages which are at the new depth,
	//	and if that new depth is the full depth of the directory, then we must have
	//	increased the number of deep pages by 2.
	//
	if( (startPage+1) == endPage ) {

		//
		//	OldValue == 0 implies that this is occurring during boot-up when
		//	we have not set the surrounding Page Values. So only increment by 1
		//	in that case, as we will call SetDirectoryPointer for the neighbor !
		//
		if( OldValue != 0 ) {
			m_cDeepPages += 2 ;
		}	else	{
			m_cDeepPages += 1 ;
		}

	}

	//
	//	By now, everything must be back to a valid state !
	//
	_ASSERT( IsValid() ) ;

    return TRUE;
}

BOOL
CDirectory::IsDirectoryInitGood(
	DWORD	MaxPagesInUse
	)	{
/*++

Routine Description :

	Check that all of the directory entries were completely
	initialized - the directory should contain no
	illegal Page NUmbers such as 0 or 0xFFFFFFFF.

Arguments :

	MaxPagesInUse -	The number of pages actually being used
		in the hash table - if the directory has a page number
		larger than this than something screwy is afoot !

Return Value :

	None.

--*/

	for( DWORD	i=0; i < DWORD(1<<m_cBitDepth); i++ )	{
		if( m_pDirectory[i] == 0 || m_pDirectory[i] > MaxPagesInUse )
			return	FALSE ;
	}

	return	TRUE ;
}

void
CDirectory::Reset()	{
/*++

Routine Description :

	Restore directory to clean state.

Arguments :

	None.

Return Value :

	None.

--*/

	m_cDeepPages = 0 ;
	if( m_pDirectory != 0 ) {
		ZeroMemory( m_pDirectory, m_cMaxDirEntries * sizeof( DWORD ) ) ;
	}
}

BOOL
CDirectory::SaveDirectoryInfo(
		HANDLE		hFile,
		DWORD		&cbBytes
		) {
/*++

Routine Description :

	Save the contents of the directory info the file at the
	current file pointer position within the file.
	

Arguments :

	hFile - The file in which we are to save the directory info.
	cbBytes - Out parameter which gets the number of bytes we put
		into the directory.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	DWORD	cbWrite = 0 ;
	cbBytes = 0 ;
	BOOL	fReturn =
		WriteFile(	hFile,
					&m_cBitDepth,
					sizeof( m_cBitDepth ),
					&cbWrite,
					0 ) ;
	if( fReturn ) {

		cbBytes += cbWrite ;
		cbWrite = 0 ;
		fReturn &= WriteFile(	hFile,
								m_pDirectory,
								sizeof( DWORD ) * DWORD(1<<m_cBitDepth),
								&cbWrite,
								0 ) ;
		cbBytes += cbWrite ;
	}
	return	fReturn ;
}

BOOL
CDirectory::LoadDirectoryInfo(
		HANDLE		hFile,
		DWORD		&cbBytes
		)	{
/*++

Routine Description :
	
	Load a previously saved directory from a file. (Saved with SaveDirectoryInfo()).

Arguments :

	hFile - The file from which we are to read the directory info.
	cbBytes - Number of bytes read from the file !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	cbBytes = 0 ;
	WORD	BitDepth ;
	DWORD	cbRead = 0 ;

	BOOL	fReturn = ReadFile(	hFile,
								&BitDepth,
								sizeof( BitDepth ),
								&cbRead,
								0 ) ;
	if( fReturn ) {

		cbBytes += cbRead ;
		cbRead = 0 ;

		//
		//	Initialzie to current directory - if there's room will
		//	read directly into current directory !
		//
		PDWORD	pNewDirectory = m_pDirectory ;
		BOOL	fHeapAllocate = m_fHeapAllocate ;

		//
		//	Compute how big a directory we need to hold this stuff !
		//
		DWORD	cNewEntries = (0x1 << BitDepth) * sizeof( DWORD ) ;
		DWORD	cNewMaxDirEntries = 0 ;

		if( m_pDirectory == 0 ||
			cNewEntries > m_cMaxDirEntries ) {

			pNewDirectory = AllocateDirSpace( BitDepth,	cNewMaxDirEntries, fHeapAllocate ) ;

			if( pNewDirectory == 0 ) {

				_ASSERT( IsValid() ) ;

				return	FALSE ;

			}	
		}

		fReturn &= ReadFile(	hFile,
								pNewDirectory,
								sizeof( DWORD ) * (1<<BitDepth),
								&cbRead,
								0 ) ;
		
		if( !fReturn ) {

			if( pNewDirectory != m_pDirectory ) {
				if( fHeapAllocate ) {
					_VERIFY( VirtualFree( pNewDirectory, 0, MEM_RELEASE ) ) ;
				}	else	{
					delete[]	pNewDirectory ;
				}
				pNewDirectory = 0 ;
			}

		}	else	{

			//
			//	Adjust out parm to caller for bytes we read !
			//
			cbBytes += cbRead ;

			//
			//	Set members to correct values !
			//
			m_cBitDepth = BitDepth ;
			m_cMaxDirEntries = cNewMaxDirEntries  ;

			if( pNewDirectory != m_pDirectory ) {

				//
				//	Must be non-zero since we read into pNewDirectory !
				//
				_ASSERT( pNewDirectory != 0 ) ;

				//
				//	Release old directory stuff !
				//
				if( m_pDirectory != 0 )		{
					if( m_fHeapAllocate ) {
						delete[]	m_pDirectory ;
					}	else	{
						_VERIFY( VirtualFree( m_pDirectory, 0, MEM_RELEASE ) ) ;
					}
				}

				m_pDirectory = pNewDirectory ;
				m_fHeapAllocate = fHeapAllocate ;


			}

		}
	}

	//
	//	Whether succes
	//
	_ASSERT( IsValid() ) ;

	return	fReturn ;
}

BOOL
CDirectory::LoadDirectoryInfo(
		LPVOID		lpv,
		DWORD		cbSize,
		DWORD		&cbBytes
		)	{
/*++

Routine Description :
	
	Load a previously saved directory from a file. (Saved with SaveDirectoryInfo()).

Arguments :

	hFile - The file from which we are to read the directory info.
	cbBytes - Number of bytes read from the file !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	cbBytes = 0 ;
	WORD	BitDepth ;
	DWORD	cbRead = 0 ;
	BOOL	fReturn = FALSE ;

	cbRead = 0 ;

	if( cbSize <= sizeof( WORD ) ) {
		return	FALSE ;
	}

	BitDepth = ((WORD*)lpv)[0] ;
	cbBytes += sizeof( WORD ) ;

	//
	//	Initialzie to current directory - if there's room will
	//	read directly into current directory !
	//
	PDWORD	pNewDirectory = m_pDirectory ;
	BOOL	fHeapAllocate = m_fHeapAllocate ;

	//
	//	Compute how big a directory we need to hold this stuff !
	//
	DWORD	cNewEntries = (0x1 << BitDepth) ;
	DWORD	cNewMaxDirEntries = m_cMaxDirEntries; // was 0 ;

	if( m_pDirectory == 0 ||
		cNewEntries > m_cMaxDirEntries ) {

		pNewDirectory = AllocateDirSpace( BitDepth,	cNewMaxDirEntries, fHeapAllocate ) ;

		if( pNewDirectory == 0 ) {

			return	FALSE ;

		}	
	}

	if( !((cNewEntries * sizeof( DWORD )) <= (cbSize - sizeof(WORD))) ) {

		if( pNewDirectory != m_pDirectory )	{
			if( fHeapAllocate ) {
				delete[]	pNewDirectory ;
			}	else	{
				_VERIFY( VirtualFree( pNewDirectory, 0, MEM_RELEASE ) ) ;
			}
		}
		pNewDirectory = 0 ;

	}	else	{

		cbRead = cNewEntries * sizeof( DWORD ) ;

		//
		//	Copy in the directory !
		//
		CopyMemory( pNewDirectory, &((WORD*)lpv)[1], cbRead ) ;

		//
		//	Adjust out parm to caller for bytes we read !
		//
		cbBytes += cbRead ;

		//
		//	Set members to correct values !
		//
		m_cBitDepth = BitDepth ;
		m_cMaxDirEntries = cNewMaxDirEntries  ;

		if( pNewDirectory != m_pDirectory ) {

			//
			//	Must be non-zero since we read into pNewDirectory !
			//
			_ASSERT( pNewDirectory != 0 ) ;

			//
			//	Release old directory stuff !
			//
			if( m_pDirectory != 0 )	{
				if( m_fHeapAllocate )	{
					delete[]	m_pDirectory ;
				}	else	{
					_VERIFY( VirtualFree( m_pDirectory, 0, MEM_RELEASE ) ) ;
				}
			}

			m_pDirectory = pNewDirectory ;
			m_fHeapAllocate = fHeapAllocate ;

		}
		//
		//	Now go and check that m_cDeepPages is correct - we can do this
		//	by spinning through the directory and seeing how many entries
		//	are unique (only occur once)!
		//	Note that non-unique values must occur in consecutive
		//	locations.
		//

		DWORD	UniqueCount = 0 ;
		for( DWORD	i=0; i < DWORD(1<<m_cBitDepth); ) {

			for( DWORD j=i+1; j < DWORD(1 << m_cBitDepth); j++ ) {
				if( m_pDirectory[j] != m_pDirectory[i] )
					break ;
			}
			if( j == (i+1) ) {
				if( m_pDirectory[i] != 0 ) {
					UniqueCount ++ ;
				}
			}
			i = j ;
		}
		m_cDeepPages = UniqueCount ;


		fReturn = TRUE ;

	}
	//
	//	Whether succes
	//
	_ASSERT( IsValid() ) ;

	return	fReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\directry.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lookup.h

Abstract:

    This module contains class declarations/definitions for

        CDirectory

--*/

#ifndef _DIRECTRY_
#define _DIRECTRY_

#include "hashmap.h"

//
//	CDirectory - 
//
//	This class is used to manage subdirectories - structures which
//	allows us to index Hash values to the pages which contain the
//	Hash Table entry.
//
class	CDirectory	{
private : 
	//
	//	This is set to TRUE if we allocate the memory holding 
	//	the directory from the heap instead of through VirtualAlloc.
	//
	BOOL			m_fHeapAllocate ;
	
	//
	//	Pointer to array of DWORDs which makes up the directory !
	//
	LPDWORD			m_pDirectory ;

	//
	//	Number of DWORDs we can put in location pointed to be m_pDirectory
	//	before we need to allocate a larger piece of memory !
	//
	DWORD			m_cMaxDirEntries ;

	//
	//	Number of Bits that have been used to select a CDirectory object - 
	//	this will be the same of all CDirectory objects within a given hash
	//	table.  Store it here for convenient bit fiddling.
	//
	WORD			m_cTopBits ;

	//
	//	Helper function for handling VirtualAlloc's
	//

	LPDWORD			AllocateDirSpace(	WORD	cBitDepth,
										DWORD&	cMaxEntries, 
										BOOL&	fHeapAllocate 
										) ;

public : 

	//
	//	Number of bits that are significant for this directory - 
	//	note that _ASSERT( (1<<m_cBitDepth) <= m_cMaxDirEntries) must 
	//	always be true !
	//	
	WORD			m_cBitDepth ;

	//
	//	Reader/Writer lock controlling access to the directory !
	//	This is public so callers can lock it directly !
	//
	_RWLOCK			m_dirLock ;

	//
	//	Number of pages referenced by the directory which are at the
	//	maximum bit depth (m_cBitDepth) of the directory.
	//	When this goes to zero, we should be able to collapse the directory.
	//	This is publicly accessible, as CHashMap will manipulate this
	//	directly.
	//
	DWORD			m_cDeepPages ;

	//
	//	Initialize to an Illegal state - InitializeDirectory() 
	//	must be called before this will be usefull !
	//
	CDirectory() : 
		m_pDirectory( 0 ), 
		m_cMaxDirEntries( 0 ), 
		m_cTopBits( 0 ),
		m_cBitDepth( 0 ),
		m_cDeepPages( 0 )
		{}  ;

	//
	//	Release any memory we allocated.  Don't assume that 
	//	InitializeDirectory() was called, or completed successfully
	//	if it was called.
	//
	~CDirectory() ;

	//
	//	Set up the directory !
	//
	BOOL	InitializeDirectory(
					WORD	cTopBits,
					WORD	cInitialDepth
					) ;


	//
	// reset the directory back to its initial state
	//
	void Reset(void);

	//
	//	Find an entry within the directory !
	//
	PDWORD	GetIndex(	DWORD	HashValue ) ;	

	//
	//	Grow the directory !
	//
	BOOL	ExpandDirectory(	WORD	cBitsExpand ) ;

	//
	//	Grow the directory to the specified bit depth 
	//
	BOOL	SetDirectoryDepth(	WORD	cBitsDepth )	{
				if( (m_cBitDepth + m_cTopBits) < cBitsDepth )
					return	ExpandDirectory( cBitsDepth - (m_cBitDepth + m_cTopBits)  ) ;
				return	TRUE ;
				}

	//
	//	For the given hash table page, make sure that the appropriate
	//	directory entries reference it !
	//
	BOOL	SetDirectoryPointers(	
						PMAP_PAGE	MapPage,
						DWORD		PageNumber 
						) ;

	//
	//	Check that the directory was fully initialized - we should
	//	have no Page Numbers of '0', which would indicate missing
	//	pages.
	//
	BOOL	IsDirectoryInitGood(DWORD MaxPagesInUse) ;
	
	//
	//	Check that the Directory appears to be set up safely !
	//
	BOOL	IsValid() ;

	//
	//	Check that the Directory is consistent with the data in the Page !
	//	This is mainly for use in _ASSERT checking that our data structures
	//	are consistent !!!!
	//
	BOOL	IsValidPageEntry( 
				PMAP_PAGE	MapPage, 
				DWORD		PageNum,
				DWORD		TopLevelIndex ) ;

	BOOL 	SaveDirectoryInfo(
		HANDLE		hFile, 
		DWORD		&cbBytes );

	BOOL LoadDirectoryInfo(
		HANDLE		hFile, 
		DWORD		&cbBytes);

	BOOL LoadDirectoryInfo(
		LPVOID		lpv, 
		DWORD		cbSize,
		DWORD		&cbBytes);
	

	void 	*operator new(size_t size);
	void 	operator delete(void *p, size_t size);
};

inline void *CDirectory::operator new(size_t size) { 
	return HeapAlloc(GetProcessHeap(), 0, size); 
}

inline void CDirectory::operator delete(void *p, size_t size) { 
	_VERIFY(HeapFree(GetProcessHeap(), 0, p)); 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\hashinln.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pagelock.h

Abstract:

    This module contains inline code for classes defined in hashmap.h

--*/

#ifndef _PAGELOCK_
#define _PAGELOCK_

#include "pageent.h"


//
// the class decleration for CPageLock is in hashmap.h
//
#include "hashmap.h"

inline
CPageLock::CPageLock() :
	m_pPage( 0 ),
	m_pDirectory( 0 ),
	m_pPageSecondary( 0 ),
	m_fPageShared (FALSE) 
#ifdef	DEBUG
	,m_fExclusive( FALSE ) 
#endif
	{}

#ifdef	DEBUG
//
//	In debug builds - _ASSERT check that all our members
//	are set to NULL before we are destroyed - as we release locks
//	we will set these to NULL !
//
inline
CPageLock::~CPageLock()	{
	_ASSERT( m_pPage == 0 ) ;
	_ASSERT( m_pDirectory == 0 ) ;
}
#endif

inline	void
CPageLock::AcquireDirectoryShared( 
				CDirectory*	pDirectory	
				)	{
/*++

Routine Description : 

	Lock the directory for access and record
	what directory we locked for later release.

Agruments : 

	pDirectory - pointer to the directory the caller
		wants shared access to

Return Value : 

	None.

--*/

	//
	//	Caller can only grab one directory at a time
	//
	_ASSERT( m_pDirectory == 0 ) ;

	//
	//	Directory locks must always be grabbed before 
	//	pages are !
	//
	_ASSERT( m_pPage == 0 ) ;

#ifdef	DEBUG
	m_fExclusive = FALSE ;
#endif
	m_pDirectory = pDirectory ;
	m_pDirectory->m_dirLock.ShareLock() ;

	_ASSERT( m_pDirectory->IsValid() ) ;
}

inline	void
CPageLock::AcquireDirectoryExclusive(	
				CDirectory*	pDirectory 
				)	{
/*++

Routine Description : 
	
	Lock the directory for exclusive access, and record for 
	later release

Arguments : 

	pDirectory - Directory caller wants exclusive access to !

Return Value : 

	None.

--*/

	//
	//	Caller can only have on directory locked at a time !
	//
	_ASSERT( m_pDirectory == 0 ) ;

	//
	//	Directory objects must be grabbed before pages
	//
	_ASSERT( m_pPage == 0 ) ;

#ifdef	DEBUG
	m_fExclusive = TRUE ;
#endif
	m_pDirectory = pDirectory ;
	m_pDirectory->m_dirLock.ExclusiveLock() ;


	_ASSERT( m_pDirectory->IsValid() ) ;
}


inline	PMAP_PAGE
CPageLock::AcquirePageShared(	
					PageEntry	*pageEntry,
					HANDLE	hFile,
					DWORD	PageNumber,
					BOOL	fDropDirectory
					)	{
/*++

Routine Description : 

	Get an shared lock on a page

Arguments : 

	page - The PageEntry object which manages access to the specified 
		PageNumber
	hFile - The file containing the page of data
	PageNumber - The page we want loaded into memory and exclusive access to

Return Value : 

	Pointer to the page in memory if successfull, NULL otherwise !

--*/

	//
	//	Only one page can be locked at a time
	//
	_ASSERT( m_pPage == 0 ) ;

	PMAP_PAGE	ret = pageEntry->AcquirePageShared( hFile, PageNumber, m_fPageShared, this, fDropDirectory ) ;

	//
	//	Only if the call to the PageEntry object succeeded 
	//	are we left holding a lock. So only update our m_pPage
	//	pointer in the success case, as we don't want to mistakenly
	//	release a lock we don't have in the future.
	//
	if( ret )	{
		m_pPage = pageEntry ;


		_ASSERT( m_pDirectory == 0 || m_pDirectory->IsValid() ) ;
	}

	return		ret ;
}

inline	PMAP_PAGE
CPageLock::AcquirePageExclusive(	
					PageEntry	*pageEntry,
					HANDLE	hFile,
					DWORD	PageNumber,
					BOOL	fDropDirectory
					)	{
/*++

Routine Description : 

	Get an shared lock on a page

Arguments : 

	page - The PageEntry object which manages access to the specified 
		PageNumber
	hFile - The file containing the page of data
	PageNumber - The page we want loaded into memory and exclusive access to

Return Value : 

	Pointer to the page in memory if successfull, NULL otherwise !

--*/

	//
	//	Only one page can be locked at a time
	//
	_ASSERT( m_pPage == 0 ) ;
	_ASSERT( m_pPageSecondary == 0 ) ;

	PMAP_PAGE	ret = pageEntry->AcquirePageExclusive( hFile, PageNumber, m_fPageShared, this, fDropDirectory ) ;

	//
	//	Only if the call to the PageEntry object succeeded 
	//	are we left holding a lock. So only update our m_pPage
	//	pointer in the success case, as we don't want to mistakenly
	//	release a lock we don't have in the future.
	//
	if( ret )	{
		m_pPage = pageEntry ;


		_ASSERT( m_pDirectory == 0 || m_pDirectory->IsValid() ) ;
	}

	return		ret ;
}


inline	BOOL
CPageLock::AddPageExclusive(	
					PageEntry	*pageEntry,
					HANDLE	hFile,
					DWORD	PageNumber
					)	{
/*++

Routine Description : 

	Get an shared lock on a page

Arguments : 

	page - The PageEntry object which manages access to the specified 
		PageNumber
	hFile - The file containing the page of data
	PageNumber - The page we want loaded into memory and exclusive access to

Return Value : 

	Pointer to the page in memory if successfull, NULL otherwise !

--*/

	//
	//	Only one secondary page can be locked at a time - and only 
	//	after the primary page is locked !
	//
	_ASSERT( m_pPage != 0 ) ;
	_ASSERT( m_pPageSecondary == 0 ) ;

	BOOL	ret = FALSE ;

	if( pageEntry == m_pPage ) {
		return	TRUE ;
	}	else	{
	
		BOOL	fShared = FALSE ;
		ret = pageEntry->AcquireSlotExclusive( hFile, PageNumber, fShared ) ;

		_ASSERT( fShared == FALSE ) ;

		//
		//	Only if the call to the PageEntry object succeeded 
		//	are we left holding a lock. So only update our m_pPage
		//	pointer in the success case, as we don't want to mistakenly
		//	release a lock we don't have in the future.
		//
		if( ret )	{
			m_pPageSecondary = pageEntry ;


			_ASSERT( m_pDirectory == 0 || m_pDirectory->IsValid() ) ;
		}
	}

	return		ret ;
}


inline	void
CPageLock::ReleaseAllShared(
					PMAP_PAGE	page
					)	{
/*++

Routine Description : 

	

--*/

	if( m_pDirectory ) 
		m_pDirectory->m_dirLock.ShareUnlock() ;

	if( m_pPage )
		m_pPage->ReleasePage( page, m_fPageShared ) ;

	if( m_pPageSecondary ) 
		m_pPageSecondary->ReleasePage( 0, FALSE ) ;

#ifdef	DEBUG
	_ASSERT( !m_fExclusive ) ;
#endif
	m_pDirectory = 0 ;
	m_pPage = 0 ;
	m_pPageSecondary = 0 ;
}

//
//	Release all of our locks - we had an exclusive lock on the directory !
//
inline	void
CPageLock::ReleaseAllExclusive(
					PMAP_PAGE	page
					)	{

	if( m_pDirectory ) {
		m_pDirectory->m_dirLock.ExclusiveUnlock() ;
	}

	if( m_pPage ) 
		m_pPage->ReleasePage( page, m_fPageShared ) ;

	if( m_pPageSecondary ) 
		m_pPageSecondary->ReleasePage( 0, FALSE ) ;


#ifdef	DEBUG
	_ASSERT( m_fExclusive ) ;
#endif
	m_pDirectory = 0 ;
	m_pPage = 0 ;
	m_pPageSecondary = 0 ;
}

//
//	Release the directory !
//
inline	void	
CPageLock::ReleaseDirectoryExclusive()	{

	if( m_pDirectory ) {
		m_pDirectory->m_dirLock.ExclusiveUnlock() ;
	}
	m_pDirectory = 0 ;
}



//
// Flush a page
//

inline 
BOOL CHashMap::FlushPage( 
					HPAGELOCK&	hLock,	
					PVOID Base, 
					BOOL	fDirtyOnly  
					) 
{
	return	hLock.m_pPage->FlushPage( m_hFile, Base, fDirtyOnly ) ;
}



#endif // _PAGELOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\gethost\gethost.cpp ===
#include <windows.h>
#include <svcguid.h>
#include <winsock2.h>
#include <dbgtrace.h>
#include <dnsapi.h>
#include <dbgtrace.h>
#include <cpool.h>
#include <address.hxx>
#include <dnsreci.h>
#include <listmacr.h>

//shamelessy stolen from the NT winsock code....

GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID AddressGuid =  SVCID_INET_HOSTADDRBYINETSTRING;
GUID IANAGuid    =  SVCID_INET_SERVICEBYNAME;
//
// Utility to turn a list of offsets into a list of addresses. Used
// to convert structures returned as BLOBs.
//

VOID
FixList(PCHAR ** List, PCHAR Base)
{
    if(*List)
    {
        PCHAR * Addr;

        Addr = *List = (PCHAR *)( ((ULONG_PTR)*List + Base) );
        while(*Addr)
        {
            *Addr = (PCHAR)(((ULONG_PTR)*Addr + Base));
            Addr++;
        }
    }
}


//
// Routine to convert a hostent returned in a BLOB to one with
// usable pointers. The structure is converted in-place.
//
VOID
UnpackHostEnt(struct hostent * hostent)
{
     PCHAR pch;

     pch = (PCHAR)hostent;

     if(hostent->h_name)
     {
         hostent->h_name = (PCHAR)((ULONG_PTR)hostent->h_name + pch);
     }
     FixList(&hostent->h_aliases, pch);
     FixList(&hostent->h_addr_list, pch);
}
//
// The protocol restrictions list for all emulation operations. This should
// limit the invoked providers to the set that know about hostents and
// servents. If not, then the special SVCID_INET GUIDs should take care
// of the remainder.
//
AFPROTOCOLS afp[2] = {
                      {AF_INET, IPPROTO_UDP},
                      {AF_INET, IPPROTO_TCP}
                     };

LPBLOB GetGostByNameI(PCHAR pResults,
    DWORD dwLength,
    LPSTR lpszName,
    LPGUID lpType,
    LPSTR *  lppName)
{
    PWSAQUERYSETA pwsaq = (PWSAQUERYSETA)pResults;
    int err;
    HANDLE hRnR;
    LPBLOB pvRet = 0;
    INT Err = 0;

    //
    // create the query
    //
    ZeroMemory(pwsaq,sizeof(*pwsaq));
    pwsaq->dwSize = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName = lpszName;
    pwsaq->lpServiceClassId = lpType;
    pwsaq->dwNameSpace = NS_ALL;
    pwsaq->dwNumberOfProtocols = 2;
    pwsaq->lpafpProtocols = &afp[0];

	//don't go though the cache
    err = WSALookupServiceBeginA(pwsaq,
                                 LUP_RETURN_BLOB | LUP_RETURN_NAME | LUP_FLUSHCACHE,
                                 &hRnR);

    if(err == NO_ERROR)
    {
        //
        // The query was accepted, so execute it via the Next call.
        //
        err = WSALookupServiceNextA(
                                hRnR,
                                0,
                                &dwLength,
                                pwsaq);
        //
        // if NO_ERROR was returned and a BLOB is present, this
        // worked, just return the requested information. Otherwise,
        // invent an error or capture the transmitted one.
        //

        if(err == NO_ERROR)
        {
            if(pvRet = pwsaq->lpBlob)
            {
                if(lppName)
                {
                    *lppName = pwsaq->lpszServiceInstanceName;
                }
            }
            else
            {
                err = WSANO_DATA;
            }
        }
        else
        {
            //
            // WSALookupServiceEnd clobbers LastError so save
            // it before closing the handle.
            //

            err = GetLastError();
        }
        WSALookupServiceEnd(hRnR);

        //
        // if an error happened, stash the value in LastError
        //

        if(err != NO_ERROR)
        {
            SetLastError(err);
        }
    }
    return(pvRet);
}


struct hostent FAR * GetHostByName(PCHAR Buffer, DWORD BuffSize, DWORD dwFlags, char * HostName)
{
	struct hostent * hent = NULL;	
	LPBLOB pBlob = NULL;

	pBlob = GetGostByNameI(Buffer, BuffSize, HostName, &HostnameGuid, 0);

	if(pBlob)
	{
		hent = (struct hostent *) pBlob;
		UnpackHostEnt(hent);
	}
	else
	{
		if(GetLastError() == WSASERVICE_NOT_FOUND)
		{
			SetLastError(WSAHOST_NOT_FOUND);
		}
	}
	return hent;
}



BOOL GetIpAddressFromDns(char * HostName, PSMTPDNS_RECS pDnsRec, DWORD Index)
{
    TraceFunctEnter("GetIpAddressFromDns");
    
    PDNS_RECORD pDnsRecord = NULL;
	MXIPLIST_ENTRY * pEntry = NULL;
	PDNS_RECORD pTempDnsRecord;
	DNS_STATUS  DnsStatus = 0;
	DWORD	Error = NO_ERROR;
	BOOL fReturn = TRUE;

	DnsStatus = DnsQuery_A(HostName, DNS_TYPE_A, DNS_QUERY_BYPASS_CACHE, NULL, &pDnsRecord, NULL);

    pTempDnsRecord = pDnsRecord;

	while ( pTempDnsRecord )
	{
		if(pTempDnsRecord->wType == DNS_TYPE_A)
		{
			pEntry = new MXIPLIST_ENTRY;
			if(pEntry != NULL)
			{
				pDnsRec->DnsArray[Index]->NumEntries++;
				pEntry->IpAddress  = pTempDnsRecord->Data.A.ipAddress;
				InsertTailList(&pDnsRec->DnsArray[Index]->IpListHead, &pEntry->ListEntry);
			}
			else
			{
				fReturn = FALSE;
				Error = ERROR_NOT_ENOUGH_MEMORY;
				break;
			}
		}

		pTempDnsRecord = pTempDnsRecord->pNext;
	}

    DnsFreeRRSet( pDnsRecord, TRUE );

	if(Error)
	{
		SetLastError (ERROR_NOT_ENOUGH_MEMORY);
	}

    TraceFunctLeave();
	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\hashmacr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpmacr.h

Abstract:

    This module contains macross for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPMACR_
#define _NNTPMACR_


#define ALLOCATE_HEAP( nBytes ) LocalAlloc( 0, nBytes )
#define FREE_HEAP( _heap )      LocalFree( (PVOID)(_heap) )

//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

//
// Convert FILETIME TO LIs
//

#define LI_FROM_FILETIME( _pLi, _pFt ) {               \
            (_pLi)->LowPart = (_pFt)->dwLowDateTime;   \
            (_pLi)->HighPart = (_pFt)->dwHighDateTime; \
            }

#define FILETIME_FROM_LI( _pFt, _pLi ) {               \
            (_pFt)->dwLowDateTime = (_pLi)->LowPart;   \
            (_pFt)->dwHighDateTime = (_pLi)->HighPart; \
            }

//
// CRITICAL SECTIONS
//

#define INIT_LOCK( _l )     InitializeCriticalSection( _l )
#define ACQUIRE_LOCK( _l )  EnterCriticalSection( _l )
#define RELEASE_LOCK( _l )  LeaveCriticalSection( _l )
#define DELETE_LOCK( _l )   DeleteCriticalSection( _l )

//
// LockStatistics
//

#define LockStatistics( )						ACQUIRE_LOCK( &StatLock );
#define UnlockStatistics( )						RELEASE_LOCK( &StatLock );
#define IncrementStat( _x )						(NntpStat. ## _x)++;
#define DecrementStat( _x )						(NntpStat. ## _x)--;
#define InterlockedIncrementStat( _x )			InterlockedIncrement((LPLONG)&(NntpStat. ## _x));
#define InterlockedDecrementStat( _x )			InterlockedDecrement((LPLONG)&(NntpStat. ## _x));
#define InterlockedExchangeAddStat( _x, _y )	InterlockedExchangeAdd( (PLONG)&(NntpStat. ## _x), (LONG)(_y) )
//#define AddByteStat( _x, _y ) \
//        ((NntpStat. ## _x).QuadPart += (_y));
#define AddByteStat( _x, _y ) \
        if( (ULONG)InterlockedExchangeAdd( (PLONG)&((NntpStat. ## _x).LowPart), (LONG)(_y)) \
			> ( ULONG_MAX - (ULONG)(_y) ) ) InterlockedIncrement( (LPLONG)&((NntpStat. ## _x).HighPart) );

//
// debug constants\macros
//

#define  NNTP_DEBUG_REGISTRY        0x00000004
#define  NNTP_DEBUG_EXPIRE          0x00000008
#define  NNTP_DEBUG_LOCKS           0x00000010
#define  NNTP_DEBUG_ARTMAP          0x00000020
#define  NNTP_DEBUG_HISTORY         0x00000040
#define  NNTP_DEBUG_HEAP            0x00000080
#define  NNTP_DEBUG_HASH            0x00000100
#define  NNTP_DEBUG_SECURITY        0x00000200
#define  NNTP_DEBUG_FEEDMGR         0x00000400
#define  NNTP_DEBUG_FEEDBLOCK       0x00000800

//
// on debug build define all inline functions as regular functions.
// copied from msndef.h
//

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

//
// from extcmk2.h
//

#define fCharInSet(ch, set) (NULL !=strchr(set, ch))
#define STRLEN(sz) (sizeof(sz)-1)
#define	fWhitespace(ch) fCharInSet(ch, szWSChars)
#define	fWhitespaceNull(ch) fCharInSet(ch, szWSNullChars)
#define	fWhitespaceNewLine(ch) fCharInSet(ch, szWSNLChars)
#define	fNewLine(ch) fCharInSet(ch, szNLChars)

#ifndef	Assert
#define Assert _ASSERT
#endif

#endif // _NNTPMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\crchash.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crchash.h

Abstract:
	CRC Hash function
*/

#ifndef __CRCHASH_H
#define __CRCHASH_H

#define POLY 0x48000000L    /* 31-bit polynomial (avoids sign problems) */

extern long CrcTable[128];
void crcinit();

DWORD CRCHash(IN const BYTE * Key, IN DWORD KeyLength);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\hashmap.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hash.cpp

Abstract:

    This module contains definition for the CHashMap base class

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include <windows.h>
#include <dbgtrace.h>
#include <xmemwrpr.h>
#include "hashmacr.h"
#include "pageent.h"
#include "hashmap.h"
#include "crchash.h"
#include "rw.h"
#include "directry.h"
#include "hashinln.h"


DWORD	IKeyInterface::cbJunk = 0 ;


//
// Mask array to get the bit of the hash value used to choose
// between the Hi or Lo Offset array in the leaf page.
//

DWORD
LeafMask[] = {
        0x80000000, 0x40000000, 0x20000000, 0x10000000,
        0x08000000, 0x04000000, 0x02000000, 0x01000000,
        0x00800000, 0x00400000, 0x00200000, 0x00100000,
        0x00080000, 0x00040000, 0x00020000, 0x00010000,
        0x00008000, 0x00004000, 0x00002000, 0x00001000,
        0x00000800, 0x00000400, 0x00000200, 0x00000100,
        0x00000080, 0x00000040, 0x00000020
        };


//
//	Release the directory !
//
void
CPageLock::ReleaseDirectoryShared()	{

	if( m_pDirectory ) {
		m_pDirectory->m_dirLock.ShareUnlock() ;
	}
	m_pDirectory = 0 ;
}


//
// Routine Description :
//
// 	This function will get shared access to the directory
// 	appropriate for the supplied hash value.  Once we have
// 	shared access to the directory, we will get a pointer
// 	to the directory entry for the specified Hash Value.
//
// Arguments :
//
// 	HashValue - The computed hash value which we want
// 		to find within the directory.
// 	lock - An HPAGELOCK structure which accumulates pointers
// 		to all the objects which are required to lock
// 		a single hash table entry.
//
// Return Value :
//
// 	A pointer to the DWORD Directory entry
//
inline PDWORD
CHashMap::LoadDirectoryPointerShared(
        DWORD HashValue,
		HPAGELOCK&	lock
        )
{
    ENTER("LoadDirectoryPointer")

	//
	//	Select a directory object !
	//

	DWORD	iDirectory = HashValue >> (32 - m_TopDirDepth) ;
	lock.AcquireDirectoryShared( m_pDirectory[iDirectory] ) ;
	return	lock.m_pDirectory->GetIndex( HashValue ) ;

} // LoadDirectoryPointerShared


//
// Routine Description :
//
// 	This function will get EXCLUSIVE access to the directory
// 	appropriate for the supplied hash value.  Once we have
// 	exclusive access to the directory, we will get a pointer
// 	to the directory entry for the specified Hash Value.
//
// Arguments :
//
// 	HashValue - The computed hash value which we want
// 		to find within the directory.
// 	lock - An HPAGELOCK structure which accumulates pointers
// 		to all the objects which are required to lock
// 		a single hash table entry.
//
// Return Value :
//
// 	A pointer to the DWORD Directory entry
//
inline	PDWORD
CHashMap::LoadDirectoryPointerExclusive(
		DWORD	HashValue,
		HPAGELOCK&	lock
        )
{

	DWORD	iDirectory = HashValue >> (32 - m_TopDirDepth) ;
	lock.AcquireDirectoryExclusive( m_pDirectory[iDirectory] ) ;
	return	lock.m_pDirectory->GetIndex( HashValue ) ;

} // LoadDirectoryPointerExclusive

//
// Routine Description :
//
// 	This function will split a directory, however we do it without
// 	grabbing any locks etc...  This is done only during boot-up when
// 	access to the hash tables are through a single thread.
// 	Additionally, we will initialize all the pointers to the Page !
//
// Arguments :
//
// 	MapPage -	The page we are currently examining, we need to
// 		grow the directory depth to accomodate this page.
//
// Return Value :
//
// 	TRUE if successfull, FALSE otherwise !
//
BOOL
CHashMap::I_SetDirectoryDepthAndPointers(
			PMAP_PAGE	MapPage,
			DWORD		PageNum
			)
{

	//
	//	Do some error checking on the page's data !
	//
	if( MapPage->PageDepth < m_TopDirDepth ||
		MapPage->PageDepth >= 32 ) {

		//
		//	Clearly bogus page depth - fail
		//
		SetLastError( ERROR_INTERNAL_DB_CORRUPTION ) ;
		return	FALSE ;

	}

	DWORD	iDirectory = MapPage->HashPrefix >> (MapPage->PageDepth - m_TopDirDepth) ;

	BOOL	fSuccess = m_pDirectory[iDirectory]->SetDirectoryDepth( MapPage->PageDepth ) ;

	if( fSuccess ) {

		fSuccess &= m_pDirectory[iDirectory]->SetDirectoryPointers( MapPage, PageNum ) ;

	}

	_ASSERT(	!fSuccess ||
				m_pDirectory[iDirectory]->IsValidPageEntry( MapPage, PageNum, iDirectory ) ) ;

	return	fSuccess ;
}


CHashMap::CHashMap()
{

	ENTER("CHashMap::CHashMap");

	// Initialize() marks this as active later on...
	m_active = FALSE;

    // initialize crc table used for hashing
    CRCInit();

	// initialize critical sections
	InitializeCriticalSection( &m_PageAllocator ) ;

    // initialize member variables
	m_fCleanInitialize = FALSE;
	m_TopDirDepth = 0 ;
    m_dirDepth = NUM_TOP_DIR_BITS;
    m_pageEntryThreshold = 0;
    m_pageMemThreshold = 0;
	m_fNoBuffering = FALSE ;
    m_hFile = INVALID_HANDLE_VALUE;
    m_hFileMapping = NULL;

	//
	//	The maximum number of pages should start out
	//	same as the number of CDirectory objects - we can't have
	//	two CDirectory objects referencing the same page, ever !
	//
    //m_maxPages = (1 << m_TopDirDepth) + 1 ;

    m_headPage = NULL;
	m_UpdateLock = 0 ;
    m_initialPageDepth = NUM_TOP_DIR_BITS ;
    m_nPagesUsed = 0;
    m_nInsertions = 0;
    m_nEntries = 0;
    m_nDeletions = 0;
    m_nSearches = 0;
    m_nDupInserts = 0;
    m_nPageSplits = 0;
    m_nDirExpansions = 0;
    m_nTableExpansions = 0;
	m_Fraction = 1 ;

	LEAVE;
} // CHashMap

CHashMap::~CHashMap(VOID)
{
	TraceFunctEnter( "CHashMap::~CHashMap" ) ;

    //
    // Shutdown the hash table
    //
    Shutdown( );

	//
	//	Delete the critical section we use for protecting
	//	the allocation of new pages
	//
	DeleteCriticalSection( &m_PageAllocator ) ;

	//
	//	Need to free resources in the page cache
	//
	m_pPageCache = 0 ;
}

//
// Routine Description:
//
//   This routine shuts down the hash table.
//
// Arguments:
//
//   fLocksHeld - TRUE if the dir locks are held,
// 		if this is FALSE we should grab the locks ourself !
//
// Return Value:
//
//     TRUE, if shutdown is successful.
//     FALSE, otherwise.
//
VOID
CHashMap::Shutdown(BOOL	fLocksHeld)
{
    ENTER("Shutdown")

	//
	//	Make the service inactive !!
	//
    if ( !m_active )
    {
        _ASSERT( m_hFile == INVALID_HANDLE_VALUE );
        return;
    }

    //
    // Save statistics
    //
    FlushHeaderStats( TRUE );

	//
	//	Should we try to save our directory structures !
	//
	if( m_active && m_fCleanInitialize ) {

		//
		//	Save the directory !
		//

		//
		//	Determine the name of the file we would save the directory in !
		//
		HANDLE	hDirectoryFile = INVALID_HANDLE_VALUE ;
		char	szDirFile[MAX_PATH] ;

		//
		//	Try to build the filename of the file holding the directory !
		//
		ZeroMemory(szDirFile, sizeof(szDirFile) ) ;
		lstrcpy( szDirFile, m_hashFileName ) ;
		char	*pchDot = strrchr( szDirFile, '.' ) ;

		if( pchDot && strchr( pchDot, '\\' ) == 0 ) {

			lstrcpy( pchDot, ".hdr" ) ;

			hDirectoryFile = CreateFile(
											szDirFile,
											GENERIC_READ | GENERIC_WRITE,
											0,
											0,
											CREATE_ALWAYS,
											FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
											INVALID_HANDLE_VALUE ) ;


		}

		//
		//	We were able to open a file where we think the directory information
		//	will be saved - lets try to read in the directory !!!
		//
		if( hDirectoryFile != INVALID_HANDLE_VALUE ) {

			DWORD	cbWrite = 0 ;

			//
			//	Keep Track of whether we need to delete the file due to failure !
			//
			BOOL	fDirectoryInit = FALSE ;

			//
			//	We save the hash table header info into the directory file so that
			//	we can double check that we have the right file when opening it up !!!
			//
			if( WriteFile(	hDirectoryFile,
						(LPVOID)m_headPage,
						sizeof( *m_headPage ),
						&cbWrite,
						0 ) )	{

				//
				//	Assume that everything will succeed now !
				//
				fDirectoryInit = TRUE ;

				//
				//	Looks good ! lets set up our directories !
				//
				DWORD	cb = 0 ;
				for( DWORD i=0; (i < DWORD(1<<m_TopDirDepth)) && fDirectoryInit ; i++ ) {
					fDirectoryInit &=
						m_pDirectory[i]->SaveDirectoryInfo( hDirectoryFile, cb ) ;
				}
			}
			_VERIFY( CloseHandle( hDirectoryFile ) ) ;

			//
			//	If we successfully read the directory file - DELETE it !!!
			//	This prevents us from ever mistakenly reading a directory file
			//	which is not up to date with the hash tables !
			//

			if( !fDirectoryInit )
				_VERIFY( DeleteFile( szDirFile ) ) ;
		}

	}

	if( m_pPageCache && m_hFile != INVALID_HANDLE_VALUE ) {
		m_pPageCache->FlushFileFromCache( m_hFile ) ;
	}

    //
    // Destroy mapping
    //
    I_DestroyPageMapping( );

	//
	// Delete directory objects !
	//
	DWORD i;
	for( i=0; i < DWORD(1<<m_TopDirDepth); i++ ) {
		delete m_pDirectory[i] ;
		m_pDirectory[i] = NULL ;
	}

	XDELETE m_dirLock;
	m_dirLock = NULL;

    //
    // We are not active
    //
    m_active = FALSE;

    LEAVE
    return;
} // Shutdown


//
// Routine Description:
//
//     This routine acquires a critical section
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//
// Return Value:
//
//     A handle to the lock.  This handle should be used for
//     ReleaseLock.
//
inline	PMAP_PAGE
CHashMap::AcquireLockSetShared(
                IN DWORD PageNumber,
				OUT	HPAGELOCK&	lock,
				IN	BOOL		fDropDirectory
                )


{

	return	m_pPageCache->AcquireCachePageShared( m_hFile, PageNumber, m_Fraction, lock, fDropDirectory ) ;
} // AcquireLockSetShared

inline	PMAP_PAGE
CHashMap::AcquireLockSetExclusive(
                IN DWORD PageNumber,
				OUT	HPAGELOCK&	lock,
				BOOL	fDropDirectory
                )

/*++

Routine Description:

    This routine acquires a critical section

Arguments:

    DirEntry - The directory entry to protect

Return Value:

    A handle to the lock.  This handle should be used for
    ReleaseLock.

--*/

{

	return	m_pPageCache->AcquireCachePageExclusive( m_hFile, PageNumber, m_Fraction, lock, fDropDirectory ) ;

} // AcquireLockSetExclusve

inline	BOOL
CHashMap::AddLockSetExclusive(
                IN DWORD PageNumber,
				OUT	HPAGELOCK&	lock
                )

/*++

Routine Description:

    This routine acquires a critical section

Arguments:

    DirEntry - The directory entry to protect

Return Value:

    A handle to the lock.  This handle should be used for
    ReleaseLock.

--*/

{

	_ASSERT( lock.m_pPageSecondary == 0 ) ;

	return	m_pPageCache->AddCachePageExclusive( m_hFile, PageNumber, m_Fraction, lock ) ;

} // AcquireLockSetExclusve




    //
    // releases both the page lock and the backup lock
    //

inline	VOID
CHashMap::ReleasePageShared(
						PMAP_PAGE	page,
						HPAGELOCK&	hLock
						)		{
	CPageCache::ReleasePageShared( page, hLock ) ;
	ReleaseBackupLockShared() ;
}

inline	VOID
CHashMap::ReleasePageExclusive(
						PMAP_PAGE	page,
						HPAGELOCK&	hLock
						)	{
	CPageCache::ReleasePageExclusive( page, hLock ) ;
	ReleaseBackupLockShared() ;
}


//
// Routine Description:
//
//     This routine compacts the leaf page.  It goes through the delete
//     list and collapses it.
//
//     *** Assumes DirLock is held exclusive OR Page lock is held ***
//
// Arguments:
//
// 	HLock - The lock used to grab the page !
//     MapPage - Page to be compressed.
//
// Return Value:
//
//     TRUE, if page compacted
//     FALSE, otherwise
//
BOOL
CHashMap::CompactPage(
			IN HPAGELOCK&	HLock,
            IN PMAP_PAGE MapPage
            )
{
    SHORT offsetValue;

    //
    // used to do the move
    //

    DWORD srcOffset;
    WORD entrySize = 0;
    DWORD bytesToMove;

    PDELENTRYHEADER entry;
    WORD ptr;
    WORD nextPtr;

    DebugTraceX(0, "Entering CompactPage. Page = %x\n", MapPage );

    //
    // return if there is nothing to compact
    //

    if ( (ptr = MapPage->DeleteList.Blink) == 0 )
    {

        _ASSERT(MapPage->FragmentedBytes == 0);
        return FALSE;
    }

    //
    // Scan the delete list and compact it
    //

    while ( ptr != 0 )
    {

        entry = (PDELENTRYHEADER)GET_ENTRY(MapPage,ptr);
        entrySize = entry->EntrySize;
        nextPtr = entry->Link.Blink;

        srcOffset = ptr + entrySize;
        bytesToMove = MapPage->NextFree - srcOffset;

        MoveMemory(
            (PVOID)entry,
            (PVOID)((PCHAR)MapPage + srcOffset),
            bytesToMove
            );

        MapPage->NextFree -= entrySize;

        //
        // adjust indices of other entries
        //

        for ( DWORD i = 0; i < MAX_LEAF_ENTRIES ; i++ )
        {

            offsetValue = MapPage->Offset[i];

            //
            // check if this is a deleted entry
            //

            if ( offsetValue > 0 )
            {

                //
                // Now adjust offsets that were affected by this move
                //

                if ( (WORD)offsetValue > ptr )
                {
                    MapPage->Offset[i] -= entrySize;
					_ASSERT(MapPage->Offset[i] > 0);
					_ASSERT(MapPage->Offset[i] <= HASH_PAGE_SIZE);
                }
            }
        }

        //
        // process next entry
        //

        ptr = nextPtr;
    }

    //
    // All done.
    //

    MapPage->FragmentedBytes = 0;
    MapPage->DeleteList.Flink = 0;
    MapPage->DeleteList.Blink = 0;

    FlushPage( HLock, MapPage );

    return TRUE;

} // CompactPage

//
// Routine Description:
//
//     This routine expands the directory by increasing the page depth.
//     The old directory is deleted and a new one created.
//
//     *** Assumes DirLock is held exclusive ***
//
// Arguments:
//
//     nBitsExpand - Number of bits to increment the Page depth with.
//
// Return Value:
//
//     TRUE, if expansion ok
//     FALSE, otherwise
//
BOOL
CHashMap::ExpandDirectory(
		IN HPAGELOCK&	hPageLock,
        IN WORD nBitsExpand
        )
{
    DWORD status = ERROR_SUCCESS ;

	_ASSERT( hPageLock.m_pDirectory != 0 ) ;
#ifdef	DEBUG
	_ASSERT( hPageLock.m_fExclusive ) ;
#endif

    IncrementDirExpandCount( );

	return	hPageLock.m_pDirectory->ExpandDirectory( WORD(nBitsExpand) ) ;
} // ExpandDirectory


//
// Routine Description:
//
//     This routine searches for an entry in the table
//     *** Assumes Page lock is held ***
//
// Arguments:
//
//     KeyString - key of the entry to delete
//     KeyLen - Length of the key
//     HashValue - Hash value of the key
//     MapPage - Page to search for entry
//     AvailIndex - Optional pointer to a DWORD which will contain the
//                 index to the first available slot if entry was
//                 not found.
//     MatchedIndex - Optional pointer to a DWORD which will contain the
//                 index to the entry.
//
// Return Value:
//
//     TRUE, if entry was found.
//     FALSE, otherwise.
//
BOOL
CHashMap::FindMapEntry(
				IN	const	IKeyInterface*	pIKey,
                IN	HASH_VALUE HashValue,
                IN	PMAP_PAGE MapPage,
				IN	const ISerialize*	pIEntryInterface,
                OUT PDWORD AvailIndex OPTIONAL,
                OUT PDWORD MatchedIndex OPTIONAL
                )

{
    DWORD curSearch;
    BOOL found = FALSE;
    INT delIndex = -1;

    if ( AvailIndex != NULL )
    {
        *AvailIndex = 0;
        (*AvailIndex)--;
    }

    //
    // Check if entry already exists
    //

    curSearch = GetLeafEntryIndex( HashValue );

    for ( DWORD i=0; i < MAX_LEAF_ENTRIES; i++ )
    {

        //
        // offset to the hash entry
        //

        SHORT entryOffset = MapPage->Offset[curSearch];

        //
        // if entry is unused and they are looking for a free entry, then
		// we are done
        //
        if (AvailIndex != NULL && entryOffset == 0)
        {
            //
            // if they are looking for a available entry and a deleted spot
			// is available, give that back, otherwise give them this entry.
            //
            if (delIndex < 0) *AvailIndex = curSearch;
			else *AvailIndex = delIndex;
            break;
        }

        //
        // skip deleted entries. Deleted entries are marked by setting the high bit
		// (thus they are negative in this compare)
        //
        if (entryOffset > 0) {
            //
            // see if this is what they are looking for
            //
		    PENTRYHEADER	entry;
    		entry = (PENTRYHEADER)GET_ENTRY(MapPage,entryOffset);

		    if ((entry->HashValue == HashValue) &&
				pIKey->CompareKeys( entry->Data )	)

//    		    (entry->KeyLen == KeyLen) &&
//        		(memcmp(entry->Key, Key, KeyLen) == 0) )

			{
                found = TRUE;
                break;
            }
        } else if ( delIndex < 0 ) {
            //
            // if this is a deleted entry and we haven't found one yet, then
			// remember where this one was
            //
            delIndex = curSearch;
        }

        //
        // Do linear probing p=1
        //

        curSearch = (curSearch + 1) % MAX_LEAF_ENTRIES;
    }

    //
    // set the out params.
    //

    if ( found ) {

        //
        // return the out params if specified
        //

        if ( MatchedIndex != NULL ) {
            *MatchedIndex = curSearch;
        }
    }

    return found;

} // FindMapEntry

//
// Routine Description:
//
//     this routine inserts or updates entries in a hashmap
//
// Arguments:
//
//     KeyString - MessageId of the entry to be searched
//     KeyLen - Length of the message id
//	   pHashEntry - pointer to the hash entry information
//     bUpdate - updates a map entry with new data
//
// Return Value:
//
//     ERROR_SUCCESS, Insert successful
//     ERROR_ALREADY_EXISTS, duplicate
//     ERROR_NOT_ENOUGH_MEMORY - Not able to insert entry because of resource
//         problems.
//
BOOL
CHashMap::InsertOrUpdateMapEntry(
                const	IKeyInterface	*pIKey,
				const	ISerialize		*pHashEntry,
				BOOL	bUpdate,
                BOOL    fDirtyOnly
                )
{
    PENTRYHEADER	entry;
    DWORD curSearch;
    DWORD status = ERROR_SUCCESS;
    HASH_VALUE HashValue = pIKey->Hash();
    PMAP_PAGE mapPage;
    BOOL splitPage = FALSE;
	BOOL fInsertComplete = FALSE, fFirstTime = TRUE;
	HPAGELOCK HLock;

    ENTER("InsertOrUpdateMapEntry")

	_ASSERT(pHashEntry != NULL);

	//
    // lock the page
    //
	mapPage = GetPageExclusive(HashValue, HLock);
	if (!mapPage) {
		SetLastError(ERROR_SERVICE_NOT_ACTIVE);
		LEAVE
		return FALSE;
	}

	//
	// if they wanted to update then remove the current entry
	//
	if (bUpdate) {
		if (FindMapEntry(pIKey, HashValue, mapPage, pHashEntry, NULL, &curSearch)) {
			// delete the entry (this is copied from the deletion portion
			// of LookupMapEntry().  search for SIMILAR1).
			DWORD entryOffset = mapPage->Offset[curSearch];
			I_DoAuxDeleteEntry(mapPage, entryOffset);
			LinkDeletedEntry(mapPage, entryOffset);
			mapPage->Offset[curSearch] |= OFFSET_FLAG_DELETED;
			mapPage->ActualCount--;
			IncrementDeleteCount();
		} else {
			ReleasePageShared(mapPage, HLock);
	        SetLastError(ERROR_FILE_NOT_FOUND);
			LEAVE;
			return FALSE;
		}
	}

	//
	// loop until we've found an error or we've had a successful insert
	//
	while (!fInsertComplete && status == ERROR_SUCCESS) {
		BOOL bFound;

		if (fFirstTime) {
			// the page is locked above, we don't need to lock here
			fFirstTime = FALSE;
		} else {
			//
    		// lock the page
    		//
			mapPage = GetPageExclusive(HashValue, HLock);
			if (!mapPage) {
				status = ERROR_SERVICE_NOT_ACTIVE;
				continue;
			}
		}

		//
		// see if the entry already exists
		//
		splitPage = FALSE;
		bFound = FindMapEntry(pIKey, HashValue, mapPage, pHashEntry, &curSearch,
			NULL);

	    if (!bFound) {
			//
			// the entry didn't already exist, lets insert it
			//
			DWORD entrySize = GetEntrySize(pIKey, pHashEntry);

	        if (curSearch == (DWORD)-1) {
				//
				// we can't add any more entries, we need to split the page
				//
	            splitPage = TRUE;
	            DebugTrace(0,"Split: Can't add anymore entries\n");
	            SetPageFlag( mapPage, HLock, PAGE_FLAG_SPLIT_IN_PROGRESS );
	        } else {
				//
				// add the entry
				//
	        	if ((entry = (PENTRYHEADER) ReuseDeletedSpace(mapPage,
											HLock, entrySize)) == NULL)
	        	{
		            //
		            // No delete space available, use the next free list
		            //
		            if ( GetBytesAvailable( mapPage ) < entrySize )
		            {
						//
						// not enough memory available, force a split
						//
		                splitPage = TRUE;
						entry = NULL;
		                DebugTrace(0,"Split: Cannot fit %d\n", entrySize);
		                SetPageFlag(mapPage, HLock, PAGE_FLAG_SPLIT_IN_PROGRESS);
		            } else {
						entry = (PENTRYHEADER)GET_ENTRY(mapPage, mapPage->NextFree);
			            mapPage->NextFree += (WORD)entrySize;
			        }
				}

				//
				// we found space to insert it, lets go for it.
				//
				if (entry) {
	        		//
			        // Update the map page header
			        //
	    		    if (mapPage->Offset[curSearch] == 0) {
			            //
			            // if this is a new entry, update the entry count
	    		        //
	        		    mapPage->EntryCount++;
	        		}

			        mapPage->Offset[curSearch] = (WORD)((PCHAR)entry - (PCHAR)mapPage);
					_ASSERT(mapPage->Offset[curSearch] > 0);
					_ASSERT(mapPage->Offset[curSearch] < HASH_PAGE_SIZE);
			        mapPage->ActualCount++;

			        //
			        // Initialized the entry data
	    		    //
	        		entry->HashValue = HashValue;
			        entry->EntrySize = (WORD)entrySize;

					LPBYTE	pbEntry = pIKey->Serialize(	entry->Data ) ;

					pHashEntry->Serialize( pbEntry ) ;

			        //entry->KeyLen = (WORD)KeyLen;
					//CopyMemory(entry->Key, Key, KeyLen);
					//pHashEntry->SerializeToPointer(entry->Key + entry->KeyLen);


					//
					//	Let derived classes do any 'extras'
					//

					I_DoAuxInsertEntry(	mapPage, mapPage->Offset[curSearch] ) ;

			        //
			        // Make sure everything gets written out
	    		    //

			        FlushPage( HLock, mapPage, fDirtyOnly );

					//
					// mark that we added them
					//
					fInsertComplete = TRUE;

			        //
	    		    // See if we need to compact pages
	        		//
			        if (mapPage->FragmentedBytes > FRAG_THRESHOLD) {
	    		        DebugTrace( 0, "Compact: Frag %d\n", mapPage->FragmentedBytes );
	        		    CompactPage( HLock, mapPage );
	        		}

			        //
			        // See if we need to split
			        //
			        if (
					  (GetBytesAvailable( mapPage ) < LEAF_SPACE_THRESHOLD) ||
			          (mapPage->EntryCount > LEAF_ENTRYCOUNT_THRESHOLD))
			        {

			            DebugTrace(0,"Split: Entries %d Space left %d\n",
			                    mapPage->EntryCount, GetBytesAvailable( mapPage ) );
			            splitPage = TRUE;
			            SetPageFlag(mapPage, HLock,
							PAGE_FLAG_SPLIT_IN_PROGRESS );
			        }
				} // if (entry)
			} // could add entry

			ReleasePageShared(mapPage, HLock);

			//
			// we need to split and add again
			//
			if (splitPage) {
				BOOL expandHash;

				//
				// lock the page exclusive
				//
        		mapPage = GetDirAndPageExclusive( HashValue, HLock );
		        if (!mapPage) {
        		    status = ERROR_SERVICE_NOT_ACTIVE;
		        }

				//
				// do the split
				//
		        if (!SplitPage(mapPage, HLock, expandHash)) {
                	//
	                // No more disk space
	                //
	                status = ERROR_DISK_FULL;
        		}
		        ReleasePageExclusive( mapPage, HLock );
    		}
	    } // wasn't in hash table already
	    else
	    {
			//
			// the page already exists
			//
	        IncrementDupInsertCount( );
	        status = ERROR_ALREADY_EXISTS;
			ReleasePageShared(mapPage, HLock);
	    }
	} // while split

	if (status == ERROR_SUCCESS) {
		IncrementInsertCount();
		UPDATE_HEADER_STATS();
	}

	SetLastError(status);
	LEAVE

	return status == ERROR_SUCCESS;
} // I_InsertMapEntry

//
// Routine Description:
//
//     This routine grabs the DirLock resource shared,
//     then acquires the page's lock shared as well,
//     and returns a pointer to the page.
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetDirAndPageShared(
                IN HASH_VALUE HashValue,
                OUT HPAGELOCK& hLock
                )
{
    DWORD pageNum;
    PDWORD dirEntry;
    PMAP_PAGE mapPage = 0;
    PDWORD dirPtr = NULL;
    DWORD curView = (DWORD)-1;

    //
    // Get the directory lock
    //
    AcquireBackupLockShared( );

    if ( m_active )
    {
        dirEntry = LoadDirectoryPointerShared( HashValue, hLock );
        if ( dirEntry != NULL )
        {
			pageNum = *dirEntry;
			mapPage = AcquireLockSetShared( pageNum, hLock, TRUE  );

#if 0
			//
			//	Check that the page we gets contains the hash value
			//	we are looking for.  the high mapPage->PageDepth bits of the
			//	Hash Value must be the same as the prefix !!!
			//
			_ASSERT(	mapPage == 0 ||
						((HashValue >> (32 - mapPage->PageDepth)) ^ mapPage->HashPrefix) == 0 ) ;
			_ASSERT(	mapPage == 0 ||
						hLock.m_pDirectory->IsValidPageEntry(
							mapPage,
							pageNum,
							(hLock.m_pDirectory - m_pDirectory[0]) ) ) ;
#endif
		}
    }

	if( mapPage == 0 )	{
		ReleaseBackupLockShared() ;
		hLock.ReleaseAllShared( mapPage ) ;
	}

    return mapPage;
} // GetDirAndPageShared

//
// Routine Description:
//
//     This routine grabs the DirLock resource shared,
//     then acquires the page's lock exclusive,
//     and returns a pointer to the page.
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetPageExclusive(
                IN HASH_VALUE HashValue,
                OUT HPAGELOCK& hLock
                )

{
    DWORD pageNum;
    PDWORD dirEntry;
    PMAP_PAGE mapPage = 0;
    PDWORD dirPtr = NULL;
    DWORD curView = (DWORD)-1;

    //
    // Get the directory lock
    //

    AcquireBackupLockShared( );

    if ( m_active )
    {
        dirEntry = LoadDirectoryPointerShared( HashValue, hLock );
        if ( dirEntry != NULL )
        {
			pageNum = *dirEntry;
			_ASSERT( m_headPage != 0 ) ;

			mapPage = AcquireLockSetExclusive( pageNum, hLock, TRUE  );

#if 0
			//
			//	Check that the page we gets contains the hash value
			//	we are looking for.  the high mapPage->PageDepth bits of the
			//	Hash Value must be the same as the prefix !!!
			//
			_ASSERT(	mapPage == 0 ||
						((HashValue >> (32 - mapPage->PageDepth)) ^ mapPage->HashPrefix) == 0 ) ;

			_ASSERT(	mapPage == 0 ||
						hLock.m_pDirectory->IsValidPageEntry(
							mapPage,
							pageNum,
							(hLock.m_pDirectory - m_pDirectory[0]) ) ) ;
#endif

		}

    }

	if( mapPage == 0 ) {
		hLock.ReleaseAllShared( mapPage ) ;
		ReleaseBackupLockShared() ;
	}

    return mapPage;

} // GetPageExclusive
//
// Routine Description:
//
//     This routine grabs the DirLock resource shared,
//     then acquires the page's lock exclusive,
//     and returns a pointer to the page.
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
BOOL
CHashMap::AddPageExclusive(
                IN DWORD	PageNum,
                OUT HPAGELOCK& hLock
                )

{
	return	AddLockSetExclusive( PageNum, hLock  );

} // AddPageExclusive

//
// Routine Description:
//
//     This routine grabs the DirLock resource exclusive,
//     then acquires the page's critical section,
//     and returns a pointer to the page.
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetDirAndPageExclusive(
                IN HASH_VALUE HashValue,
                OUT HPAGELOCK& hLock
                )

{
    DWORD pageNum;
    PDWORD dirEntry;
    PMAP_PAGE mapPage = 0;
    PDWORD dirPtr = NULL;
    DWORD curView = (DWORD)-1;

    //
    // Get the directory lock
    //

    AcquireBackupLockShared( );

    if ( m_active )
    {
        dirEntry = LoadDirectoryPointerExclusive( HashValue, hLock );
        if ( dirEntry != NULL )
        {
			pageNum = *dirEntry;
			_ASSERT( m_headPage != 0 ) ;

			mapPage = AcquireLockSetExclusive( pageNum, hLock, FALSE  );

#if 0
			//
			//	Check that the page we gets contains the hash value
			//	we are looking for.  the high mapPage->PageDepth bits of the
			//	Hash Value must be the same as the prefix !!!
			//
			_ASSERT(	mapPage == 0 ||
						((HashValue >> (32 - mapPage->PageDepth)) ^ mapPage->HashPrefix) == 0 ) ;

			_ASSERT(	mapPage == 0 ||
						hLock.m_pDirectory->IsValidPageEntry(
							mapPage,
							pageNum,
							(hLock.m_pDirectory - m_pDirectory[0]) ) ) ;
#endif

		}

    }

	if( mapPage == 0 ) {
		hLock.ReleaseAllExclusive( mapPage ) ;
		ReleaseBackupLockShared() ;
	}

    return mapPage;

} // GetDirAndPageExclusive

//
// Routine Description:
//
//     This routine grabs the DirLock resource shared,
//     then acquires the page's critical section,
//     and returns a pointer to the page.
//
// Arguments:
//
//     PageNumber - The page number to get the lock for
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetAndLockPageByNumber(
                IN DWORD PageNumber,
                OUT HPAGELOCK& hLock
                )

{
    PMAP_PAGE mapPage = 0;

    //
    // Get the directory lock
    //

    AcquireBackupLockShared( );

	//
	//	When Shutdown() calls FlushHeaderStats() in some error cases
	//	m_headPage could be zero - in which case we would return a
	//	mapPage as NULL without a call to release the lock we got through
	//	AcquireLockSet() !!
	//	So test m_headPage as well as m_active !!!
	//

    if ( m_active && m_headPage )
    {
        mapPage = AcquireLockSetExclusive( PageNumber, hLock, FALSE  );
    }
    else
    {
        DebugTraceX(0,"GetAndLockPageByNumber called while inactive\n");
    }

	if( mapPage == 0 )	{
		ReleaseBackupLockShared() ;
	}

    return mapPage;
} // GetAndLockPageByNumber

//
// Routine Description:
//
//     Acquire the page's critical section,
//     and returns a pointer to the page.
//
// 	***** Assume caller has Dir Lock held !  *********
//
// Arguments:
//
//     PageNumber - The page number to get the lock for
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetAndLockPageByNumberNoDirLock(
                IN DWORD PageNumber,
                OUT HPAGELOCK& hLock
                )

{
    PMAP_PAGE mapPage = NULL;

	//
	//	When Shutdown() calls FlushHeaderStats() in some error cases
	//	m_headPage could be zero - in which case we would return a
	//	mapPage as NULL without a call to release the lock we got through
	//	AcquireLockSet() !!
	//	So test m_headPage as well as m_active !!!
	//

    if ( m_active && m_headPage )
    {

        mapPage = AcquireLockSetExclusive( PageNumber, hLock, FALSE  );

    }
    else
    {
        DebugTraceX(0,"GetAndLockPageByNumber called while inactive\n");
    }
    return mapPage;
} // GetAndLockPageByNumberNoDirLock


BOOL
CHashMap::Initialize(
            IN LPCSTR HashFileName,
            IN DWORD Signature,
            IN DWORD MinimumFileSize,
			IN DWORD cPageEntry,
			IN DWORD cNumLocks,
			IN DWORD dwCheckFlags,
			IN HASH_FAILURE_PFN	HashFailurePfn,
			IN LPVOID	lpvFailureCallback,
			IN BOOL	fNoBuffering
            )	{

	CCACHEPTR	pCache = XNEW	CPageCache() ;
	if( pCache == 0 ) {
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}

	if( !pCache->Initialize(	cPageEntry, cNumLocks ) ) {
		return	FALSE ;
	}

	return	Initialize(	HashFileName,
						Signature,
						MinimumFileSize,
						1,
						pCache,
						dwCheckFlags,
						HashFailurePfn,
						lpvFailureCallback ) ;

}


DWORD
CHashMap::InitializeDirectories(
		WORD	cBitDepth
		) {
/*++

Routine Description :

	This function creates all of the necessary Directory objects !

Arguments :

	Number of bits to use to select a directory !

Returns :

	ERROR_SUCCESS if successfull - NT Error code otherwise !


--*/

    ENTER("InitializeDirectories")

	//
	//	Make sure we haven't been called already !
	//
	_ASSERT( m_TopDirDepth == cBitDepth ) ;

	if( cBitDepth > MAX_NUM_TOP_DIR_BITS ) {
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	ERROR_INVALID_PARAMETER ;
	}

	m_TopDirDepth = cBitDepth ;

	DWORD i;
	for( i=0; i < DWORD(1<<m_TopDirDepth); i++ ) {
		m_pDirectory[i] = new CDirectory;
		if (m_pDirectory[i] == NULL) break;
		//
		//	Arbitrarily init the sub directory to 8 bits -
		//	so our directory as a whole has a depth of
		//	m_TopDirDepth + 8.
		//
		if( !m_pDirectory[i]->InitializeDirectory( m_TopDirDepth, 1 ) )	{
			break ;
		}
	}

	if( i!= DWORD(1<<m_TopDirDepth) ) {
		//
		//	Failed to initialize all the CDirectory objects - Bail out !
		//
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		LEAVE
		return	ERROR_NOT_ENOUGH_MEMORY ;
	}
	return	ERROR_SUCCESS ;
}


//
// Routine Description:
//
//     This routine initializes the hash table.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE, if setup is successful.
//     FALSE, otherwise.
//
BOOL
CHashMap::Initialize(
        IN LPCSTR HashFileName,
        IN DWORD Signature,
        IN DWORD MinimumFileSize,
		IN DWORD Fraction,
		IN CCACHEPTR	pCache,
		IN DWORD dwCheckFlags,
		IN HASH_FAILURE_PFN	HashFailurePfn,
		IN LPVOID	lpvCallBack,
		IN BOOL	fNoBuffering
        )
{
    DWORD status;
    ENTER("Initialize")

	m_fNoBuffering = fNoBuffering ;

	if( Fraction == 0 ) {
		Fraction = 1 ;
	}
	m_Fraction = Fraction ;
	m_pPageCache = pCache ;

	m_dwPageCheckFlags = dwCheckFlags;

	m_dirLock = XNEW _RWLOCK;
	if (m_dirLock == NULL) {
		LEAVE
		return(FALSE);
	}

    DebugTrace( 0, "File %s MinFileSize %d\n", HashFileName, MinimumFileSize );

    if ( m_active )
    {
        DebugTrace( 0, "Routine called while active\n" );
        _ASSERT(FALSE);
        LEAVE
        return TRUE;
    }

	//
	//	Record call back information for giving fatal error
	//	notifications.
	//
	//BUGBUG
	m_HashFailurePfn = HashFailurePfn ;
	m_lpvHashFailureCallback = lpvCallBack ;

	//
	//	Initialize the many CDirectory objects
	//

#if 0
	DWORD i;
	for( i=0; i < (1<<m_TopDirDepth); i++ ) {
		m_pDirectory[i] = XNEW CDirectory;
		if (m_pDirectory[i] == NULL) break;
		//
		//	Arbitrarily init the sub directory to 8 bits -
		//	so our directory as a whole has a depth of
		//	m_TopDirDepth + 8.
		//
		if( !m_pDirectory[i]->InitializeDirectory( m_TopDirDepth, 1 ) )	{
			break ;
		}
	}

	if( i!= (1<<m_TopDirDepth) ) {
		//
		//	Failed to initialize all the CDirectory objects - Bail out !
		//
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		LEAVE
		return	FALSE ;
	}
#endif


    //
    // Copy the name and signature
    //
    lstrcpy( m_hashFileName, HashFileName );
    m_HeadPageSignature = Signature;

    //
    // Set up the minimum file size
    //
    if ( MinimumFileSize < MIN_HASH_FILE_SIZE )
    {
        MinimumFileSize = MIN_HASH_FILE_SIZE;
    }

    m_maxPages = MinimumFileSize / HASH_PAGE_SIZE;

    status = I_BuildDirectory( TRUE );
    if ( status != ERROR_SUCCESS )
    {
        ErrorTrace( 0, "BuildDirectory failed with %d\n", status );
        SetLastError( status );
        LEAVE
        return FALSE;
    }

	m_fCleanInitialize = TRUE;

    m_active = TRUE;
    LEAVE
    return TRUE;
} // Initialize

//
// Routine Description:
//
//     This routine searches for a deleted entry that can be reused.
//     *** Assumes Page lock is held ***
//
// Arguments:
//
//     MapPage - Page to search for entry.
//     NeededEntrySize - Entry size requested.
//
// Return Value:
//
//     Pointer to the entry returned.
//     NULL, if no entry can be found.
//
PVOID
CHashMap::ReuseDeletedSpace(
            IN PMAP_PAGE MapPage,
			IN HPAGELOCK&	HLock,
            IN DWORD &NeededEntrySize
            )
{
    PCHAR entryPtr = NULL;
    PDELENTRYHEADER entry;

    WORD ptr;
    WORD entrySize;

    //
    // Walk the delete list and find the first fit.
    //

    ptr = MapPage->DeleteList.Flink;

    while ( ptr != 0 )
    {

        entry = (PDELENTRYHEADER)GET_ENTRY(MapPage,ptr);
        entrySize = entry->EntrySize;

        if ( entrySize >= NeededEntrySize )
        {

            DWORD diff;

            //
            // Found an entry
            //

            diff = entrySize - NeededEntrySize;

            if ( diff >= sizeof(DELENTRYHEADER) )
            {

                //
                // give the guy what it needs but maintain the header
                //

                entry->EntrySize -= (WORD)NeededEntrySize;
                entryPtr = (PCHAR)entry + diff;

            }
            else
            {

                //
                // whole entry has to go
                //

                entryPtr = (PCHAR)entry;
                if ( entry->Link.Blink == 0 )
                {
                    MapPage->DeleteList.Flink = entry->Link.Flink;
                }
                else
                {
                    PDELENTRYHEADER prevEntry;

                    prevEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,entry->Link.Blink);
                    prevEntry->Link.Flink = entry->Link.Flink;
                }

                //
                // Set the back link
                //

                if ( entry->Link.Flink == 0 )
                {
                    MapPage->DeleteList.Blink = entry->Link.Blink;
                }
                else
                {
                    PDELENTRYHEADER nextEntry;

                    nextEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,entry->Link.Flink);
                    nextEntry->Link.Blink = entry->Link.Blink;
                }

                NeededEntrySize = entrySize;
            }

            MapPage->FragmentedBytes -= (WORD)NeededEntrySize;

            FlushPage( HLock, MapPage );
            break;
        }
        ptr = entry->Link.Flink;
    }

    return (PVOID)entryPtr;

} //ReuseDeletedSpace


//
// Routine Description:
//
//     	This routine searches for the entry with the given Key
//
//		note that this routine has a lot of functionality.  with bDelete
//		set and pHashEntry set to NULL you can delete an entry.  With
//		pHashEntry set to NULL this will tell you if the hash table contains
//		an entry.
//
// Arguments:
//
//     	KeyString - Key of the entry to be searched
//	   	KeyLen - length of key
//     	pHashEntry - where to write the contents for this entry (NULL means
//					i don't care about the contents)
//     	bDelete - boolean saying if the entry should be deleted
//
// Return Value:
//
//     TRUE, entry is found.
//     FALSE, otherwise.
//
BOOL
CHashMap::LookupMapEntry(
                IN const	IKeyInterface*	pIKey,
				IN	ISerialize*				pHashEntry,
				IN	BOOL bDelete,
				IN	BOOL fDirtyOnly
                )
{
    BOOL found = TRUE;
    HASH_VALUE val;
    PMAP_PAGE mapPage;
    HPAGELOCK	hLock;
    DWORD status = ERROR_SUCCESS;
	DWORD curSearch;
	DWORD	cbRequired = 0 ;

	if( pIKey == 0 ) {
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	FALSE ;
	}

    val = pIKey->Hash( );

    //
    // Lock the page
    //

	if (bDelete) mapPage = GetPageExclusive( val, hLock );
	else mapPage = GetDirAndPageShared( val, hLock );
    if ( !mapPage )
    {
        SetLastError(ERROR_SERVICE_NOT_ACTIVE);
        return FALSE;
    }

    //
    // Check if entry already exists
    //
    if ( FindMapEntry(
                pIKey,
                val,
                mapPage,
				pHashEntry,
                NULL,
                &curSearch
                ) )
	{
		DWORD entryOffset;

		entryOffset = mapPage->Offset[curSearch];

		//
		// they wanted the contents of the entry
		//
		if (pHashEntry) {
			PENTRYHEADER	entry;
			LPBYTE entryData;

			entry = (PENTRYHEADER)GET_ENTRY(mapPage, entryOffset);

			entryData = pIKey->EntryData( entry->Data ) ;
			if( 0==pHashEntry->Restore(entryData, cbRequired ) ) {
				ReleasePageShared( mapPage, hLock ) ;
				SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
				return	FALSE ;
			}
		}

		//
		// they wanted to delete it
		// (if this code is changed then the similar code in
		// InsertOrUpdateMapEntry has to be changed as well.  search for
		// SIMILAR1).
		//
		if (bDelete) {
	        //
	        // Let derive class do their private stuff
	        //
	        I_DoAuxDeleteEntry( mapPage, entryOffset );

	        //
	        // Link this into a chain
	        //
	        LinkDeletedEntry( mapPage, entryOffset );

	        //
	        // Set the delete bit.
	        //
	        mapPage->Offset[curSearch] |= OFFSET_FLAG_DELETED;
	        mapPage->ActualCount--;

	        //
	        // Flush
	        //
	        FlushPage( hLock, mapPage, fDirtyOnly );

	        IncrementDeleteCount( );
		}
	} else {
        found = FALSE;
        status = ERROR_FILE_NOT_FOUND;
    }

    //
    // Unlock
    //

    ReleasePageShared( mapPage, hLock );
    IncrementSearchCount( );

	if( !found )
		SetLastError( status ) ;

    return found;

} // LookupMapEntry

//
// Routine Description:
//
//     This routine splits a leaf page.
//
//     *** Exclusive DirLock assumed held ***
//
// Arguments:
//
//     OldPage - Page to split.
//     Expand - indicates whether the hash table needs to be expanded.
//
// Return Value:
//
//     TRUE, if split was successful
//     FALSE, otherwise.
//
BOOL
CHashMap::SplitPage(
            IN PMAP_PAGE OldPage,
			HPAGELOCK&	hLock,
            IN BOOL & Expand
            )
{

    PMAP_PAGE newPage;
    DWORD hashPrefix;
    SHORT offset;
    WORD newPageDepth;
    WORD oldPageDepth;
    DWORD offsetIndex;
    WORD tmpOffset[MAX_LEAF_ENTRIES];

    //
    // Do we need to split?
    //
    ENTER("SplitPage")
    DebugTrace( 0, "Splitting %x\n", OldPage );

    Expand = FALSE;
    if ( (OldPage->Flags & PAGE_FLAG_SPLIT_IN_PROGRESS) == 0 )
    {
        LEAVE
        return TRUE;
    }

	//
	//	Make sure the page depth stays reasonable !!
	//
	_ASSERT( OldPage->PageDepth <= 32 ) ;

    //
    // Update the hash prefix
    //
    oldPageDepth = OldPage->PageDepth;
    newPageDepth = OldPage->PageDepth + 1;

	DWORD	newPageNum = I_AllocatePageInFile(newPageDepth);

	if( newPageNum == INVALID_PAGE_NUM ) {

		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}

	//
	//	Exclusively lock the new slot !
	//
	if( !AddPageExclusive( newPageNum, hLock ) ) {
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}

    //
    // if the new page depth is greater than the directory depth,
    // we need to expand the directory
    //

	hLock.m_pDirectory->SetDirectoryDepth( newPageDepth ) ;

    //
    // Update fields in the old page
    //
    OldPage->HashPrefix <<= 1;
    OldPage->PageDepth++;

    //
    // compute the hash prefix for the next
    //
    hashPrefix = (DWORD)(OldPage->HashPrefix | 0x1);

    //
    // Allocate and initialize a new page
    //
    //newPage = (PMAP_PAGE)
	//        ((PCHAR)m_headPage + (m_nPagesUsed * HASH_PAGE_SIZE));

	BytePage	page ;

	newPage = (PMAP_PAGE)&page ;

    I_InitializePage( newPage, hashPrefix, newPageDepth );

    //
    // All done.  Now, change links in the directory
    //
    I_SetDirectoryPointers( hLock, newPage,  newPageNum, (DWORD)-1 );

	//
	//	Release the lock on the directory !
	//
	hLock.ReleaseDirectoryExclusive() ;

    //
    // Copy the old offsets to a temp and clear them
    //
    CopyMemory(
        tmpOffset,
        OldPage->Offset,
        MAX_LEAF_ENTRIES * sizeof(WORD)
        );

    ZeroMemory( OldPage->Offset, MAX_LEAF_ENTRIES * sizeof(WORD) );
    OldPage->EntryCount = 0;
    OldPage->ActualCount = 0;

    //
    // Go through each entry and figure out where it belongs
    //
    for ( DWORD i = 0; i < MAX_LEAF_ENTRIES; i++ )
    {

        PENTRYHEADER entry;
        PCHAR destination;
        HASH_VALUE hash;

        //
        // See what this is and clear it
        //
        offset = tmpOffset[i];
        if ( offset <= 0 )
        {
            continue;
        }

        entry = (PENTRYHEADER)GET_ENTRY( OldPage, offset );
        hash = entry->HashValue;

        //
        // See which page this belongs
        //

        if ( !I_NextBitIsOne( hash, oldPageDepth ) )
        {

            //
            // Ok, this goes to the old page
            //
            offsetIndex = I_FindNextAvail( hash, OldPage );
            OldPage->Offset[offsetIndex] = offset;
			_ASSERT(OldPage->Offset[offsetIndex] > 0);
			_ASSERT(OldPage->Offset[offsetIndex] < HASH_PAGE_SIZE);
            OldPage->EntryCount++;

        }
        else
        {

            //PCHAR destination;

            //
            // new page resident
            //
            offsetIndex = I_FindNextAvail( hash, newPage );
            newPage->Offset[offsetIndex] = newPage->NextFree;
			_ASSERT(newPage->Offset[offsetIndex] > 0);
			_ASSERT(newPage->Offset[offsetIndex] < HASH_PAGE_SIZE);

            //
            // Copy to the next free list
            //
            destination = (PCHAR)GET_ENTRY(newPage,newPage->NextFree);
            newPage->NextFree += entry->EntrySize;
            newPage->EntryCount++;

            //
            // Move the bytes
            //
            CopyMemory( destination, (PCHAR)entry, entry->EntrySize );

            //
            // Do whatever the derived class needs to do
            //
            I_DoAuxPageSplit( OldPage, newPage, destination );

            //
            // Let derive class do their private stuff
            //
            I_DoAuxDeleteEntry( OldPage, offset );

            //
            // Delete this entry from the old list
            //
            LinkDeletedEntry( OldPage, offset );
        }
    }
    OldPage->ActualCount = OldPage->EntryCount;
    newPage->ActualCount = newPage->EntryCount;

    //
    // Compact the original page
    //
    (VOID)CompactPage( hLock, OldPage );

    //
    // Update statistics
    //
    //m_nPagesUsed++;
    //m_headPage->NumPages++;

    //
    // Clear the flag
    //
    OldPage->Flags &= (WORD)~PAGE_FLAG_SPLIT_IN_PROGRESS;

    IncrementSplitCount( );
    BOOL	fSuccess = FlushPage( hLock, OldPage );


	fSuccess &= RawPageWrite(
						m_hFile,
						page,
						newPageNum
						) ;
    LEAVE
    return fSuccess;

} // SplitPage

DWORD
CHashMap::I_BuildDirectory(
        IN BOOL SetupHash
        )
/*++

Routine Description:

    This routine builds the directory given a hash file.
    *** Assumes DirLock is held ***

Arguments:

    SetupHash - If TRUE, the hash table will be read and set up.
                If FALSE, the hash table is assumed to be set up.

Return Value:

    ERROR_SUCCESS - Everything went ok.
    Otherwise, the win32 error code.

--*/
{
    DWORD status;
    DWORD nPages;
    DWORD i;
    BOOL newTable = FALSE;
    ENTER("BuildDirectory")

	//
	//	BOOL to determine whether we need to read all of the pages
	//	in the hash table to rebuild the directory - assume that we will
	//	fail to open the directory file and will need to scan hash table pages.
	//
	BOOL	fDirectoryInit = FALSE ;

	//
	//	Determine the name of the file we would save the directory in !
	//
	HANDLE	hDirectoryFile = INVALID_HANDLE_VALUE ;
	char	szDirFile[MAX_PATH] ;
	LPVOID	lpvDirectory = 0 ;
	HANDLE	hMap = 0 ;
	DWORD	cbDirInfo = 0 ;

	//
	//	Try to build the filename of the file holding the directory !
	//
	BOOL	fValidDirectoryFile = FALSE ;
	ZeroMemory(szDirFile, sizeof(szDirFile) ) ;
	lstrcpy( szDirFile, m_hashFileName ) ;
	char	*pchDot = strrchr( szDirFile, '.' ) ;

	if( !pchDot ) {
		status = ERROR_INVALID_PARAMETER ;
		LEAVE
		return(status);
	}

	if( strchr( pchDot, '\\' ) == 0 ) {
		lstrcpy( pchDot, ".hdr" ) ;
		fValidDirectoryFile = TRUE ;
	}


    //
    // open and map the hash file
    //

    if ( SetupHash ) {

        status = I_SetupHashFile( newTable );
        if ( status != ERROR_SUCCESS ) {
            goto error;
        }

		if( newTable ) {
			m_initialPageDepth = NUM_TOP_DIR_BITS ;
			m_TopDirDepth = m_initialPageDepth ;
			m_maxPages = (1<<m_TopDirDepth) + 1 ;
		}
		status = InitializeDirectories( m_initialPageDepth ) ;
		if( status != ERROR_SUCCESS ) {
			goto error ;
		}

        //
        // If this is a new hash file, then set it up with defaults
        //

        if ( newTable ) {

            status = I_InitializeHashFile( );
            if ( status != ERROR_SUCCESS ) {
                goto error;
            }

			//
			//	If we are creating a new hash table, then any old files
			//	lying around with Directory information (.hdr files) are
			//	useless.  Get rid of it.  This mostly comes up in nntpbld.exe
			//

			if( fValidDirectoryFile ) {
				DeleteFile( szDirFile ) ;
			}

        }	else	{


			if( fValidDirectoryFile ) {

				hDirectoryFile = CreateFile(
												szDirFile,
												GENERIC_READ | GENERIC_WRITE,
												0,
												0,
												OPEN_EXISTING,
												FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
												INVALID_HANDLE_VALUE ) ;

				if( hDirectoryFile != INVALID_HANDLE_VALUE ) {

					cbDirInfo = GetFileSize( hDirectoryFile, 0 ) ;

					hMap = CreateFileMapping(	hDirectoryFile,
												NULL,
												PAGE_READONLY,
												0,
												0,
												0 ) ;

					if( hMap != 0 ) {

						lpvDirectory = MapViewOfFile(	hMap,
														FILE_MAP_READ,
														0,
														0,
														0 ) ;

					}

					if( lpvDirectory == 0 ) {

						if( hMap != 0 )	{
							_VERIFY( CloseHandle( hMap ) ) ;
						}

						if( hDirectoryFile != INVALID_HANDLE_VALUE ) {
							_VERIFY( CloseHandle( hDirectoryFile ) ) ;
						}

					}

				}
			}

			//
			//	We were able to open a file where we think the directory information
			//	will be saved - lets try to read in the directory !!!
			//
			if( lpvDirectory != 0 ) {

				HASH_RESERVED_PAGE	*hashCheckPage = (HASH_RESERVED_PAGE*)lpvDirectory ;
				DWORD	cbRead = 0 ;

				//
				//	We save the hash table header info into the directory file so that
				//	we can double check that we have the right file when opening it up !!!
				//

				if( CompareReservedPage( hashCheckPage, m_headPage ) ) {

					cbRead += sizeof( *hashCheckPage ) ;
					BYTE*	lpbData = (BYTE*)lpvDirectory ;

					//
					//	Time for some optimism !
					//
					fDirectoryInit = TRUE ;

					//
					//	Looks good ! lets set up our directories !
					//
					DWORD	cb = 0 ;
					for( DWORD	i=0; (i < DWORD(1<<m_TopDirDepth)) && fDirectoryInit ; i++ ) {

						cb = 0 ;
						fDirectoryInit &=
							m_pDirectory[i]->LoadDirectoryInfo( (LPVOID)(lpbData+cbRead), cbDirInfo - cbRead, cb ) ;
						if( fDirectoryInit ) {
							fDirectoryInit &= m_pDirectory[i]->IsDirectoryInitGood( m_nPagesUsed ) ;
						}
						cbRead += cb ;

					}

					//
					//	If a failure occurs we need to restore the directories
					//	to a pristine state - so spin through a quick loop to
					//	reset the directories !
					//	We do this so that we can make a second attempt to
					//	correctly initialize the directories by examining the
					//	raw hash table pages !
					//
					if( !fDirectoryInit ) {
						for( DWORD i=0; (i < DWORD(1<<m_TopDirDepth)); i++ ) {
							m_pDirectory[i]->Reset() ;
						}
					}
				}
				_VERIFY( UnmapViewOfFile( lpvDirectory ) ) ;
				_VERIFY( CloseHandle( hMap ) ) ;
				_VERIFY( CloseHandle( hDirectoryFile ) ) ;

				//
				//	If we successfully read the directory file - DELETE it !!!
				//	This prevents us from ever mistakenly reading a directory file
				//	which is not up to date with the hash tables !
				//

				if( fDirectoryInit )
					_VERIFY( DeleteFile( szDirFile ) ) ;
			}

			if( !fDirectoryInit ) 	{

				//
				// Initialize the links.  Here we go through all the pages and update the directory
				// links. We do IOs in 64K chunks for better disk throughput.
				//

				PMAP_PAGE curPage;
				nPages = m_nPagesUsed;

                DWORD nPagesLeft = nPages-1;
                DWORD cNumPagesPerIo = min( nPagesLeft, NUM_PAGES_PER_IO ) ;
                DWORD cStartPage = nPages - nPagesLeft;

                DWORD       NumIOs = (nPagesLeft / cNumPagesPerIo);
                if( (nPagesLeft % cNumPagesPerIo) != 0 ) NumIOs++;

                //  Alloc a set of pages used for each IO
                LPBYTE lpbPages = (LPBYTE)VirtualAlloc(
                                            0,
				    			            HASH_PAGE_SIZE * cNumPagesPerIo,
								            MEM_COMMIT | MEM_TOP_DOWN,
								            PAGE_READWRITE
								            ) ;

                if( lpbPages == NULL ) {
                    status = GetLastError() ;
                    goto error ;
                }

				for ( i = 1; i <= NumIOs; i++ )
				{
			        //
        			// Read 256K chunks at a time into the virtual alloc'd buffer.
                    // Reads < 256K are issued if the NumPagesPerIo for this iteration
                    // is < 256K/PageSize.
			        //
                    _ASSERT( nPagesLeft > 0 );
                    BytePage* pPage = (BytePage*)lpbPages;
					if( !RawPageRead(
                                m_hFile,
                                *pPage,
                                cStartPage,
                                cNumPagesPerIo ) )
                    {
                        _ASSERT( lpbPages );
                   		_VERIFY( VirtualFree((LPVOID)lpbPages,0,MEM_RELEASE ) ) ;
						status = GetLastError() ;
						goto	error ;
					}

                    for( DWORD j = 0; j < cNumPagesPerIo; j++ ) {
                        curPage = (PMAP_PAGE) (lpbPages+(HASH_PAGE_SIZE*j));
    					//
	    				// call verify page on this page with some checking
		    			// to make sure that its okay
			    		//
				    	if ((m_dwPageCheckFlags & HASH_VFLAG_PAGE_BASIC_CHECKS) &&
					        !VerifyPage(curPage, m_dwPageCheckFlags, NULL, NULL, NULL))
					    {
                              _ASSERT( lpbPages );
                   		    _VERIFY( VirtualFree((LPVOID)lpbPages,0,MEM_RELEASE ) ) ;
						    status = ERROR_INTERNAL_DB_CORRUPTION;
						    goto error;
					    }
                    }

                    for( j = 0; j < cNumPagesPerIo; j++ ) {
                        curPage = (PMAP_PAGE) (lpbPages+(HASH_PAGE_SIZE*j));
    					//
	    				//	Make sure the directory is of sufficient depth to deal with this
		    			//	page we are scanning !
			    		//

					    if ( !I_SetDirectoryDepthAndPointers( curPage, cStartPage+j  ) )
					    {
                            _ASSERT( lpbPages );
                   		    _VERIFY( VirtualFree((LPVOID)lpbPages,0,MEM_RELEASE ) ) ;
						    status = ERROR_INTERNAL_DB_CORRUPTION ;
						    goto	error ;
					    }
                    }

                    //  adjust num pages left and figure out the next I/O size
                    cStartPage += cNumPagesPerIo;
                    nPagesLeft -= cNumPagesPerIo;
                    cNumPagesPerIo = min( nPagesLeft, NUM_PAGES_PER_IO );
				}

                //  Free up the pages
                _ASSERT( nPagesLeft == 0 );
                _ASSERT( lpbPages );
           		_VERIFY( VirtualFree((LPVOID)lpbPages,0,MEM_RELEASE ) ) ;
                lpbPages = NULL;
			}
		}
	}

	//
	//	Check that the directory is fully initialized, we want to make sure that no
	//	Directory entries were left unitialized !
	//
	for( i=0; i<DWORD(1<<m_TopDirDepth); i++ ) {

		if( !m_pDirectory[i]->IsDirectoryInitGood( m_nPagesUsed ) ) {
			status = ERROR_INTERNAL_DB_CORRUPTION ;
			goto	error ;
		}
	}

    m_headPage->DirDepth = m_dirDepth;
	//FlushViewOfFile( (LPVOID)m_headPage, HASH_PAGE_SIZE ) ;


    LEAVE
    return ERROR_SUCCESS;

error:

	_ASSERT( GetLastError() != ERROR_NOT_ENOUGH_MEMORY ) ;

#if 0
    NntpLogEventEx(
        NNTP_EVENT_HASH_SHUTDOWN,
        0,
        (const CHAR **)NULL,
        status
        );
#endif

    I_DestroyPageMapping( );
    LEAVE
    return(status);

} // I_BuildDirectory

//
// Routine Description :
//
// 	This function gets a page out of the hash table for us.
//
// Arguments :
//
// 	None.
//
// Return Value :
//
// 	INVALID_PAGE_NUM in failure,
// 	A page number otherwise !
//
DWORD
CHashMap::I_AllocatePageInFile(WORD Depth) {
	TraceFunctEnter("CHashMap::I_AllocatePageInFile");

	DWORD	PageReturn = INVALID_PAGE_NUM ;

	EnterCriticalSection( &m_PageAllocator ) ;

	if( m_nPagesUsed >= m_maxPages ||
		(m_maxPages - m_nPagesUsed) < DEF_PAGE_RESERVE ) {

		DWORD	numPages = m_maxPages + DEF_PAGE_INCREMENT ;
		LARGE_INTEGER	liOffset ;
		liOffset.QuadPart = numPages ;
		liOffset.QuadPart *= HASH_PAGE_SIZE ;

		//
		//	We need to grow the hash table file !!!
		//

		BOOL fSuccess = SetFilePointer(
										m_hFile,
										liOffset.LowPart,
										&liOffset.HighPart,
										FILE_BEGIN ) != 0xFFFFFFFF ||
						GetLastError() == NO_ERROR ;


		if( !fSuccess ||
			!SetEndOfFile( m_hFile ) )	{

			numPages = m_maxPages + DEF_PAGE_RESERVE ;
            liOffset.QuadPart = numPages ;
			liOffset.QuadPart *= HASH_PAGE_SIZE ;

			//
			//	We need to grow the hash table file !!!
			//

			BOOL fSuccess = SetFilePointer(
											m_hFile,
											liOffset.LowPart,
											&liOffset.HighPart,
											FILE_BEGIN ) != 0xFFFFFFFF ||
							GetLastError() == NO_ERROR ;

			if( !fSuccess ||
				!SetEndOfFile( m_hFile ) )	{

				numPages = m_maxPages ;

			}

			//
			//	Call the failure notification function -
			//	we are running low on disk space and were not able to
			//	reserve as many system pages as we'd like !!!
			//

			if(	m_HashFailurePfn ) {
				m_HashFailurePfn( m_lpvHashFailureCallback, FALSE ) ;
			}
		}

		m_maxPages = numPages ;
	}

	if( m_nPagesUsed < m_maxPages ) {
		PageReturn = m_nPagesUsed ++ ;
		m_headPage->NumPages++;
		if (Depth > m_dirDepth) {
			m_dirDepth = Depth;
			m_headPage->DirDepth = Depth;
		}
		_ASSERT( m_headPage->NumPages == m_nPagesUsed ) ;

	}
	LeaveCriticalSection( &m_PageAllocator ) ;

	TraceFunctLeave();
	return (PageReturn );

}	// I_AllocatePageInFile

//
// Routine Description:
//
//     This routine cleans up the page mapping
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
VOID
CHashMap::I_DestroyPageMapping(
                            VOID
                            )
{
    //
    // Destroy the view
    //
    if ( m_headPage )
    {

        //
        // Mark table as inactive
        //
        m_headPage->TableActive = FALSE;

        //
        // Flush the hash table
        //
        (VOID)FlushViewOfFile( m_headPage, 0 );

        //
        // Close the view
        //
        (VOID) UnmapViewOfFile( m_headPage );
        m_headPage = NULL;
    }

    //
    // Destroy the file mapping
    //
    if ( m_hFileMapping )
    {

        _VERIFY( CloseHandle( m_hFileMapping ) );
        m_hFileMapping = NULL;
    }

    //
    // Close the file
    //
    if ( m_hFile != INVALID_HANDLE_VALUE )
    {
        _VERIFY( CloseHandle( m_hFile ) );
        m_hFile = INVALID_HANDLE_VALUE;
    }

    return;

} // I_DestroyPageMapping

//
// Routine Description:
//
//     This routine searches for the next available slot in the index
//     table for a given hash value.
//     *** Assumes Page lock is held ***
//
// Arguments:
//
//     HashValue - Hash value used to do the search
//     MapPage - Page to do the search
//
// Return Value:
//
//     Location of the slot.
//     0xffffffff if not successful.
//
DWORD
CHashMap::I_FindNextAvail(
                IN HASH_VALUE HashValue,
                IN PMAP_PAGE MapPage
                )
{
    DWORD curSearch;

    //
    // Check if entry already exists
    //

    curSearch = GetLeafEntryIndex( HashValue );

    for ( DWORD i=0; i < MAX_LEAF_ENTRIES; i++ ) {

        //
        // if entry is unused, then we're done.
        //

        if ( MapPage->Offset[curSearch] == 0 ) {

            //
            // if a deleted spot is available, give that back instead
            //

            return(curSearch);
        }

        //
        // Do linear probing p=1
        //

        curSearch = (curSearch + 1) % MAX_LEAF_ENTRIES;
    }

    ErrorTraceX(0,"FindNextAvail: No available entries\n");
    return ((DWORD)-1);

} // I_FindNextAvail

//
// Routine Description:
//
//     This routine writes the temporary stat values into the header.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
VOID
CHashMap::FlushHeaderStats(
        BOOL	fLockHeld
        )
{
    //
    // Lock the header page
    //

	if( InterlockedExchange( &m_UpdateLock, 1 ) == 0 ) {

		m_headPage->InsertionCount += m_nInsertions;
		m_headPage->DeletionCount += m_nDeletions;
		m_headPage->SearchCount += m_nSearches;
		m_headPage->PageSplits += m_nPageSplits;
		m_headPage->DirExpansions += m_nDirExpansions;
		m_headPage->TableExpansions += m_nTableExpansions;
		m_headPage->DupInserts += m_nDupInserts;

		FlushViewOfFile( (LPVOID)m_headPage, HASH_PAGE_SIZE ) ;

		//
		// Clear stats
		//

		m_nInsertions = 0;
		m_nDeletions = 0;
		m_nSearches = 0;
		m_nDupInserts = 0;
		m_nPageSplits = 0;
		m_nDirExpansions = 0;
		m_nTableExpansions = 0;

		m_UpdateLock = 0 ;

	}

} // FlushHeaderStats

//
// Routine Description:
//
//     Initializes a brand new hash file.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     ERROR_SUCCESS - Initialization is ok.
//
DWORD
CHashMap::I_InitializeHashFile(
        VOID
        )
{

    PMAP_PAGE curPage;
    DWORD nPages;
    DWORD dwError = ERROR_SUCCESS;

    ENTER("InitializeHashFile")

    //
    // set up the reserved page
    //

    ZeroMemory(m_headPage, HASH_PAGE_SIZE);
    m_headPage->Signature = m_HeadPageSignature;

    //
    // Allocate and initialize leaf pages.  Add 1 to the number of
    // pages to include the reserved page.
    //

    nPages = (1 << m_initialPageDepth) + 1;
    DWORD nPagesLeft = nPages-1;

    DWORD cNumPagesPerIo = min( nPagesLeft, NUM_PAGES_PER_IO ) ;
    DWORD cStartPage = nPages - nPagesLeft;

    DWORD       NumIOs = (nPagesLeft / cNumPagesPerIo);
    if( (nPagesLeft % cNumPagesPerIo) != 0 ) NumIOs++;

    LPBYTE lpbPages = (LPBYTE)VirtualAlloc(
                                    0,
									HASH_PAGE_SIZE * cNumPagesPerIo,
									MEM_COMMIT | MEM_TOP_DOWN,
									PAGE_READWRITE
									) ;

    if( lpbPages == NULL ) {
        ErrorTrace(0,"Failed to VirtualAlloc %d bytes: error is %d", HASH_PAGE_SIZE * cNumPagesPerIo, GetLastError() );
        return GetLastError();
    }

    for ( DWORD i = 1; i <= NumIOs;i++ )
    {
#if 0
		if( !RawPageRead(	m_hFile,page,i )  )	{
			return	GetLastError() ;
		}
#endif

        _ASSERT( nPagesLeft > 0 );

        //
        // initialize set of pages for this I/O
        //

        ZeroMemory( (LPVOID)lpbPages, HASH_PAGE_SIZE * cNumPagesPerIo );
        for( DWORD j = 0; j < cNumPagesPerIo; j++ ) {
            curPage = (PMAP_PAGE) (lpbPages+(HASH_PAGE_SIZE*j));
            I_InitializePage( curPage, cStartPage-1 + j, m_initialPageDepth );
        }

        //
        // write next set of pages
        //

        BytePage* pPage = (BytePage*)lpbPages;
		if( !RawPageWrite(	m_hFile,
							*pPage,
							cStartPage,
                            cNumPagesPerIo ) ) {
			dwError = GetLastError();
            goto Exit;
		}

        for( j = 0; j < cNumPagesPerIo; j++ ) {
            curPage = (PMAP_PAGE) (lpbPages+(HASH_PAGE_SIZE*j));
    		if( !I_SetDirectoryDepthAndPointers( curPage, cStartPage + j ) ) {
	    		SetLastError( ERROR_INTERNAL_DB_CORRUPTION ) ;
                dwError = GetLastError();
                goto Exit;
		    }
        }

        //  adjust num pages left and figure out the next I/O size
        cStartPage += cNumPagesPerIo;
        nPagesLeft -= cNumPagesPerIo;
        cNumPagesPerIo = min( nPagesLeft, NUM_PAGES_PER_IO );
    }

    _ASSERT( nPagesLeft == 0 );

    //
    // Indicate that everything is set.
    //
    m_nPagesUsed = nPages;
    m_headPage->NumPages = nPages;
    m_headPage->Initialized = TRUE;
    m_headPage->TableActive = TRUE;
    m_headPage->VersionNumber = HASH_VERSION_NUMBER;

    //
    // Make sure everything gets written out
    //
    (VOID)FlushViewOfFile( m_headPage, 0 );

Exit:

	if( lpbPages != 0 ) {

		_VERIFY( VirtualFree(
							(LPVOID)lpbPages,
							0,
							MEM_RELEASE
							) ) ;
    } else {
        _ASSERT( FALSE );
    }

    LEAVE
    return dwError;

} // I_InitializeHashFile


//
// Routine Description:
//
//     This routine initializes a new page.
//
// Arguments:
//
//     MapPage - Page to link the deleted entry
//     HashPrefix - HashPrefix for this page.
//     PageDepth - The page depth for this page.
//
// Return Value:
//
//     None.
//
VOID
CHashMap::I_InitializePage(
                IN PMAP_PAGE MapPage,
                IN DWORD HashPrefix,
                IN DWORD PageDepth
                )
{
    DebugTraceX(0,"Initializing page %x prefix %x depth %d\n",
        MapPage,HashPrefix,PageDepth);

    MapPage->HashPrefix = HashPrefix;
    MapPage->PageDepth = (BYTE)PageDepth;
    MapPage->EntryCount = 0;
    MapPage->ActualCount = 0;
    MapPage->FragmentedBytes = 0;
    MapPage->DeleteList.Flink = 0;
    MapPage->DeleteList.Blink = 0;
    MapPage->Reserved1 = 0;
    MapPage->Reserved2 = 0;
    MapPage->Reserved3 = 0;
    MapPage->Reserved4 = 0;
    MapPage->LastFree = HASH_PAGE_SIZE;
    MapPage->NextFree =
        (WORD)((DWORD_PTR)&MapPage->StartEntries - (DWORD_PTR)MapPage);

    ZeroMemory(
        MapPage->Offset,
        MAX_LEAF_ENTRIES * sizeof(WORD)
        );

    return;

} // I_InitializePage


//
// Routine Description:
//
//     This routine links a deleted entry to the DeleteList.
//
// Arguments:
//
//     MapPage - Page to link the deleted entry
//     Offset - Offset of the deleted entry from the start of page
//
// Return Value:
//
//     None.
//
VOID
CHashMap::LinkDeletedEntry(
                IN PMAP_PAGE MapPage,
                IN DWORD Offset
                )
{

    PDELENTRYHEADER delEntry;
    WORD    linkOffset;
    WORD    ptr;
    DWORD   bytesDeleted;
    BOOL    merged = FALSE;

    //
    // Insert deleted entry into deleted list.  List is sorted
    // in lower to higher offset order.
    //

    delEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,Offset);
    delEntry->Reserved = DELETE_SIGNATURE;
    delEntry->Link.Blink = 0;
    bytesDeleted = delEntry->EntrySize;

    linkOffset = (WORD)((PCHAR)delEntry - (PCHAR)MapPage);

    ptr = MapPage->DeleteList.Flink;

    while ( ptr != 0 ) {

        PDELENTRYHEADER curEntry;

        curEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,ptr);

        if ( ptr > linkOffset ) {

            WORD prevPtr;
            PDELENTRYHEADER prevEntry;

            //
            // See if we can coalese with the previous block
            //

            if ( (prevPtr = curEntry->Link.Blink) != 0 ) {

                prevEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,prevPtr);

                if ( (prevPtr + prevEntry->EntrySize) == linkOffset ) {

                    //
                    // Let's volt in...
                    //

                    prevEntry->EntrySize += delEntry->EntrySize;
                    merged = TRUE;

                    delEntry = prevEntry;
                    linkOffset = prevPtr;
                }
            }

            //
            // see if we can coalese with the next block
            //

            if ( (delEntry->EntrySize + linkOffset) == ptr ) {

                WORD nextPtr;

                //
                // OK. Do the merge.  This means deleting the current entry.
                //

                delEntry->EntrySize += curEntry->EntrySize;

                //
                // Set the links of the next node
                //

                if ( (nextPtr = curEntry->Link.Flink) == 0 ) {
                    MapPage->DeleteList.Blink = linkOffset;
                } else {
                    PDELENTRYHEADER nextEntry;

                    nextEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,nextPtr);
                    nextEntry->Link.Blink = linkOffset;
                }

                delEntry->Link.Flink = nextPtr;

                //
                // Set the links of the previous node
                //

                if ( !merged ) {

                    if ( prevPtr == 0 ) {

                        MapPage->DeleteList.Flink = linkOffset;

                    } else {

                        prevEntry->Link.Flink = linkOffset;
                    }

                    merged = TRUE;
                }
            }

            //
            // if the deleted entry still exists, then insert it to the list.
            //

            if ( !merged ) {

                if ( prevPtr != 0 ) {

                    delEntry->Link.Flink = ptr;
                    prevEntry->Link.Flink = linkOffset;

                } else {

                    delEntry->Link.Flink = ptr;
                    MapPage->DeleteList.Flink = linkOffset;
                }

                //
                // Set the back link
                //

                curEntry->Link.Blink = linkOffset;
                merged = TRUE;
            }

            break;
        }

        delEntry->Link.Blink = ptr;
        ptr = curEntry->Link.Flink;
    }

    //
    // This must be the last entry in the list.
    //

    if ( !merged ) {

        WORD prevPtr;
        PDELENTRYHEADER prevEntry;

        prevPtr = delEntry->Link.Blink;
        if ( prevPtr != 0 ) {

            //PDELENTRYHEADER prevEntry;
            prevEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,prevPtr);

            //
            // Can we merge?
            //

            if ( (prevPtr + prevEntry->EntrySize) == linkOffset ) {
                prevEntry->EntrySize += delEntry->EntrySize;
                linkOffset = prevPtr;
            } else {

                delEntry->Link.Flink = prevEntry->Link.Flink;
                prevEntry->Link.Flink = linkOffset;
            }

        } else {

            delEntry->Link.Flink = 0;
            MapPage->DeleteList.Flink = linkOffset;
        }

        MapPage->DeleteList.Blink = linkOffset;
    }

    //
    // Update the fragmented value
    //

    MapPage->FragmentedBytes += (WORD)bytesDeleted;

    return;

} // LinkDeletedEntry

//
// Routine Description:
//
//     This routine sets the directory pointer for a new page.
//
// Arguments:
//
// 	hLock - The HPAGELOCK object which is holding
// 		the lock for the directory we want to modify.
// 		The lock must be exclusive !
// 	MapPage - Page to link the deleted entry.
//     PageNumber - Page number of the new page.
//
// Return Value:
//
//     None.
//
BOOL
CHashMap::I_SetDirectoryPointers(
					IN HPAGELOCK&	hLock,
                    IN PMAP_PAGE MapPage,
                    IN DWORD PageNumber,
                    IN DWORD MaxDirEntries
                    )
{
    PDWORD dirPtr = NULL;
    DWORD curView = (DWORD)-1;

	_ASSERT( hLock.m_pDirectory != 0 ) ;
#ifdef	DEBUG
	_ASSERT( hLock.m_fExclusive ) ;
#endif

	BOOL	fReturn = hLock.m_pDirectory->SetDirectoryPointers(	MapPage,
																PageNumber ) ;

	_ASSERT( hLock.m_pDirectory->IsValidPageEntry(
									MapPage,
									PageNumber,
									(DWORD)(hLock.m_pDirectory - m_pDirectory[0]) ) ) ;

	return	fReturn ;
} // I_SetDirectoryPointers

//
// Routine Description:
//
//     This routine initializes a new hash file
//
// Arguments:
//
//     NewTable - Returns whether this is a new hash file or not.
//
// Return Value:
//
//     ERROR_SUCCESS - File successfully initialized.
//     ERROR_INTERNAL_DB_CORRUPTION - File is corrupted.
//     Win32 error on failure.
//
DWORD
CHashMap::I_SetupHashFile(
        IN BOOL &NewTable
        )
{

    DWORD fileSize = 0;
    DWORD status;

    ENTER("SetupHashFile")

    //
    // Open the hash file
    //

	DWORD	FileFlags = FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_RANDOM_ACCESS ;
	if( m_fNoBuffering ) {

		char	szVolume[MAX_PATH] ;
		strncpy( szVolume, m_hashFileName, sizeof( szVolume ) ) ;
		for(  char *pch=szVolume; *pch != '\\' && *pch != '\0'; pch++ ) ;
		if( *pch == '\\' ) pch++ ;
		*pch = '\0' ;

		DWORD	SectorsPerCluster = 0 ;
		DWORD	BytesPerSector = 0 ;
		DWORD	NumberOfFreeClusters = 0 ;
		DWORD	TotalNumberOfClusters = 0 ;
		if( GetDiskFreeSpace(	szVolume,
								&SectorsPerCluster,
								&BytesPerSector,
								&NumberOfFreeClusters,
								&TotalNumberOfClusters
								) )	{

			if( BytesPerSector > HASH_PAGE_SIZE ) {

				return	ERROR_INVALID_FLAGS ;

			}	else	if( (HASH_PAGE_SIZE % BytesPerSector) != 0 ) {

				return	ERROR_INVALID_FLAGS ;

			}

		}	else	{
			return	GetLastError() ;
		}
		FileFlags |= FILE_FLAG_NO_BUFFERING ;
	}

    NewTable = FALSE;
    m_hFile = CreateFile(
                        m_hashFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ, // for MakeBackup()
                        NULL,
                        OPEN_ALWAYS,
                        FileFlags,
                        NULL
                        );

    if ( m_hFile == INVALID_HANDLE_VALUE )
    {
        status = GetLastError();
        ErrorTrace( 0, "Error %d in CreateFile.\n", status );
        goto error;
    }

    //
    // Did the file exist before? If not, then this is a new hash table.
    //

    if ( GetLastError() != ERROR_ALREADY_EXISTS )
    {
        DebugTrace( 0, "New Table detected\n" );
        NewTable = TRUE;

		//
		//	Get the initial file size correct !
		//
		if ( (DWORD)-1 == SetFilePointer( m_hFile, m_maxPages * HASH_PAGE_SIZE, NULL, FILE_BEGIN )
		   || !SetEndOfFile( m_hFile )
		   )
		{
			status = GetLastError();
			FatalTrace( 0, "Error %d in SetupHashFile size of file\n", status );
			goto error;
		}


    }
    else
    {

        //
        // Get the size of the file.  This will tell us how many pages are currently filled.
        //

        fileSize = GetFileSize( m_hFile, NULL );
        if ( fileSize == 0xffffffff )
        {
            status = GetLastError();
            ErrorTrace(0,"Error %d in GetFileSize\n",status);
            goto error;
        }

        //
        // Make sure the file size is a multiple of a page
        //

        if ( (fileSize % HASH_PAGE_SIZE) != 0 )
        {

            //
            // Not a page multiple! Corrupted!
            //

            ErrorTrace(0,"File size(%d) is not page multiple.\n",fileSize);
            status = ERROR_INTERNAL_DB_CORRUPTION;
            goto error;
        }

        m_nPagesUsed = fileSize / HASH_PAGE_SIZE;

        //
        // make sure our file is not less than the actual. That is,
        // when we map the file into memory, we want to see all of it.
        //
        if ( m_maxPages < m_nPagesUsed )
        {
            m_maxPages = m_nPagesUsed;
        }
    }

    //
    // Create File Mapping
    //

    m_hFileMapping = CreateFileMapping(
                                m_hFile,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                HASH_PAGE_SIZE,
                                NULL
                                );

    if ( m_hFileMapping == NULL )
    {
        status = GetLastError();
        ErrorTrace( 0, "Error %d in CreateFileMapping\n", status );
        goto error;
    }

    //
    // create our view
    //

    m_headPage = (PHASH_RESERVED_PAGE)MapViewOfFileEx(
                                            m_hFileMapping,
                                            FILE_MAP_ALL_ACCESS,
                                            0,                      // offset high
                                            0,                      // offset low
                                            HASH_PAGE_SIZE,                      // bytes to map
                                            NULL                    // base address
                                            );

    if ( m_headPage == NULL )
    {
        status = GetLastError();
        ErrorTrace( 0, "Error %d in MapViewOfFile\n", status );
        goto error;
    }

    if ( !NewTable ) {

        //
        // See if this is a valid reserved page
        //

        if ( m_headPage->Signature != m_HeadPageSignature )
        {

            //
            // Wrong signature
            //

            ErrorTrace( 0, "Invalid Signature %x expected %x\n",
                m_headPage->Signature, m_HeadPageSignature );
            status = ERROR_INTERNAL_DB_CORRUPTION;
            goto error;
        }

        //
        // Correct version number?
        //

        if ( m_headPage->VersionNumber != HASH_VERSION_NUMBER_MCIS10 &&
				m_headPage->VersionNumber != HASH_VERSION_NUMBER )
        {

            ErrorTrace( 0, "Invalid Version %x expected %x\n",
                m_headPage->VersionNumber, HASH_VERSION_NUMBER );

            status = ERROR_INTERNAL_DB_CORRUPTION;
            goto error;
        }

		if( m_headPage->VersionNumber == HASH_VERSION_NUMBER_MCIS10 ) {
			m_initialPageDepth = 6 ;
		}	else	{
			m_initialPageDepth = 9 ;
		}
		m_TopDirDepth = m_initialPageDepth ;


        if ( !m_headPage->Initialized )
        {
            //
            // Not initialized !
            //
            ErrorTrace( 0, "Existing file uninitialized! Assuming new.\n" );
            NewTable = TRUE;
        }

        if ( m_headPage->NumPages > m_nPagesUsed )
        {
            //
            // Bad count. Corrupt file.
            //
            ErrorTrace( 0, "NumPages in Header(%d) more than actual(%d)\n",
                m_headPage->NumPages, m_nPagesUsed );

            status = ERROR_INTERNAL_DB_CORRUPTION;
            goto error;
        }

		if( m_headPage->NumPages < DWORD(1<<m_TopDirDepth) )
		{
			//
			//	For our two tier directory we must have at least one page per 2nd tier directory !
			//	This file is too small to support that, so there's a problem !
			//
			ErrorTrace( 0, "NumPages in Header(%d) less than %d\n",
					m_headPage->NumPages, DWORD(1<<m_TopDirDepth) ) ;

			status = ERROR_INTERNAL_DB_CORRUPTION ;
			goto	error ;
		}

        m_nPagesUsed = m_headPage->NumPages;

        if ( m_dirDepth < m_headPage->DirDepth )
        {
            m_dirDepth = (WORD)m_headPage->DirDepth;
        }

        //
        // Get the number of articles in the table
        //
        m_nEntries = m_headPage->InsertionCount - m_headPage->DeletionCount;
    }

    //m_hashPages = (PMAP_PAGE)((PCHAR)m_headPage + HASH_PAGE_SIZE);

    LEAVE
    return ERROR_SUCCESS;

error:

    I_DestroyPageMapping( );
    LEAVE
    return status;

} // I_SetupHashFile

//
// get the size of a hash entry
//
DWORD CHashMap::GetEntrySize(	const	ISerialize*	pIKey,
								const	ISerialize*	pHashEntry
								) {

	DWORD dwSize = sizeof(ENTRYHEADER) -	// fixed head
		 			1	+					// less 1 for Key[1]
		 			pIKey->Size() +			// Space for Key
		 			pHashEntry->Size();		// application entry length

	// Now make this size aligned to sizeof(SIZE_T)
	if (dwSize % sizeof(SIZE_T))
		dwSize += sizeof(SIZE_T) - (dwSize % sizeof(SIZE_T));

	return dwSize;
}

//
// a generic hash function (can be overridden)
//
DWORD CHashMap::Hash(LPBYTE Key, DWORD KeyLength) {
	return CRCHash(Key, KeyLength);
}

DWORD CHashMap::CRCHash(const BYTE *	Key, DWORD KeyLength) {
	return ::CRCHash(Key, KeyLength);
}

void CHashMap::CRCInit(void) {
	::crcinit();
}

//
// --- GetFirstMapEntry/GetNextMapEntry code ---
//

//
// inputs:  none
// outputs: pKey       - the key for this entry
//          pKeyLen    - the length of the key
//          pHashEntry - memory for the hash entry to be written into
// returns: TRUE/FALSE if error
//
BOOL CHashMap::GetFirstMapEntry(	IKeyInterface*	pIKey,
									DWORD&			cbKeyRequired,
									ISerialize*		pHashEntry,
									DWORD&			cbEntryRequired,
									CHashWalkContext*	pHashWalkContext,
									IEnumInterface*	pEnum
									)
{
	pHashWalkContext->m_iCurrentPage = 0;
	pHashWalkContext->m_iPageEntry = 0;
	return GetNextMapEntry(pIKey, cbKeyRequired, pHashEntry, cbEntryRequired, pHashWalkContext, pEnum );
}

BOOL CHashMap::GetNextMapEntry(	IKeyInterface*		pIKey,
								DWORD&				cbKeyRequired,
								ISerialize*			pHashEntry,
								DWORD&				cbEntryRequired,
								CHashWalkContext*	pHashWalkContext,
								IEnumInterface*		pEnum )
{
	TraceFunctEnter("CHashMap::GetNextMapEntry");

	PMAP_PAGE pPage = (PMAP_PAGE) pHashWalkContext->m_pPageBuf;
	SHORT iEntryOffset;
	PENTRYHEADER	pEntry = 0 ;
	DWORD	iPageEntry = pHashWalkContext->m_iPageEntry ;

	//
	// search for the next undeleted entry.  deleted entries are
	// marked by having their high bit set (and thus being
	// negative).
	//
	do {
		_ASSERT(pHashWalkContext->m_iPageEntry <= MAX_LEAF_ENTRIES);
		//
		// if we are done with this page then load the next page with data
		// page 0 has directory info, so we want to skip it
		//
		if (pHashWalkContext->m_iCurrentPage == 0 ||
		    iPageEntry == MAX_LEAF_ENTRIES)
		{
			do {
				pHashWalkContext->m_iCurrentPage++;
				if (!LoadWalkPage(pHashWalkContext)) {
					DebugTrace(0, "walk: no more items in hashmap");
					SetLastError(ERROR_NO_MORE_ITEMS);
					TraceFunctLeave();
					return FALSE;
				}
				iPageEntry = pHashWalkContext->m_iPageEntry ;
			} while ((pPage->ActualCount == 0)  ||
					(pEnum && !pEnum->ExaminePage( pPage )) );
		}

		iEntryOffset = pPage->Offset[iPageEntry] ;
		iPageEntry++;

		//
		// get the key, keylen, and data for the user
		//
		pEntry = (PENTRYHEADER) GET_ENTRY(pPage, iEntryOffset);

	} while ((iEntryOffset <= 0)||
			(pEnum && !pEnum->ExamineEntry( pPage, &pEntry->Data[0] )) );

	DebugTrace(0, "found entry, m_iCurrentPage = %lu, m_iPageEntry == %lu",
		pHashWalkContext->m_iCurrentPage, pHashWalkContext->m_iPageEntry);

	LPBYTE	pbEntry  = pIKey->Restore( pEntry->Data, cbKeyRequired ) ;
	if( pbEntry ) {
		if (pHashEntry->Restore( pbEntry, cbEntryRequired ) != 0 ) {
			pHashWalkContext->m_iPageEntry = iPageEntry ;
			return	TRUE ;
		}
	}
	SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
	return FALSE ;
}

//
// load a page from the hashmap into the walk buffers
//
BOOL CHashMap::LoadWalkPage(CHashWalkContext *pHashWalkContext) {
	TraceFunctEnter("CHashMap::LoadWalkPage");

	PMAP_PAGE mapPage;
	HPAGELOCK hLock;
	DWORD iPageNum = pHashWalkContext->m_iCurrentPage;

	if (iPageNum >= m_nPagesUsed) return FALSE;

	DebugTrace(0, "loading page %lu", iPageNum);

	mapPage = (PMAP_PAGE) GetAndLockPageByNumber(iPageNum, hLock);

	if (mapPage == NULL) {
		//_ASSERT(FALSE);	This _Assert can occur during shutdown of the hashtable !
		TraceFunctLeave();
		return FALSE;
	}

	memcpy(pHashWalkContext->m_pPageBuf, mapPage, HASH_PAGE_SIZE);
	pHashWalkContext->m_iPageEntry = 0;

	ReleasePageShared(mapPage, hLock);

	TraceFunctLeave();
	return TRUE;
}

//
// make a backup copy of the hashmap.  this locks the entire hashmap, syncs
// up the memory mapped portions, and makes a backup copy
//
BOOL CHashMap::MakeBackup(LPCSTR pszBackupFilename) {
	TraceFunctEnter("CHashMap::MakeBackup");

	BOOL rc = FALSE;

	if (m_active) {
		AcquireBackupLockExclusive();
		if (FlushViewOfFile((LPVOID)m_headPage, HASH_PAGE_SIZE)) {
			FlushFileBuffers(m_hFile);
			if (CopyFile(m_hashFileName, pszBackupFilename, FALSE)) {
				rc = TRUE;
			}
		}
		ReleaseBackupLockExclusive();
	}

	if (!rc) {
		DWORD ec = GetLastError();
		DebugTrace(0, "backup failed, error code = %lu", ec);
	}
	return(rc);
}

//
// hashmap.h doesn't have definations for class CShareLock, so these need to
// be local to hashmap.cpp.  If other files start needing to refer to them
// they can be moved to a header file or not made inline
//
inline VOID CHashMap::AcquireBackupLockShared() {
	m_dirLock->ShareLock();
}

inline VOID CHashMap::AcquireBackupLockExclusive() {
	m_dirLock->ExclusiveLock();
}

inline VOID CHashMap::ReleaseBackupLockShared() {
	m_dirLock->ShareUnlock();
}

inline VOID CHashMap::ReleaseBackupLockExclusive() {
	m_dirLock->ExclusiveUnlock();
}

DWORD
CalcNumPagesPerIO( DWORD nPages )
{
    //
    //  Figure out a good chunking factor ie num pages per I/O
    //  from the number of pages.
    //
    DWORD dwRem = -1;
    DWORD cNumPagesPerIo = 1;
    for( cNumPagesPerIo = NUM_PAGES_PER_IO*4;
            dwRem && cNumPagesPerIo > 1; cNumPagesPerIo /= 4 ) {
        dwRem = (nPages-1) % cNumPagesPerIo ;
        if( nPages-1 < cNumPagesPerIo ) dwRem = -1;
    }

    return cNumPagesPerIo;
}

BOOL
CHashMap::CompareReservedPage(  HASH_RESERVED_PAGE  *ppage1,
                                HASH_RESERVED_PAGE  *ppage2 )
/*++
Routine description:

    Compare to see if two HAS_RESERVED_PAGEs are virtually the same.
    By "virtually" it means we ignore the member TableActive

Arguments:

    Two pages to be compared

Return value:

    TRUE if they are virtually the same, FALSE otherwise
--*/
{
    TraceFunctEnter( "CHashMap::ComparereservedPage" );

    return (    ppage1->Signature == ppage2->Signature &&
                ppage1->VersionNumber == ppage2->VersionNumber &&
                ppage1->Initialized == ppage2->Initialized &&
                ppage1->NumPages == ppage2->NumPages &&
                ppage1->DirDepth == ppage2->DirDepth &&
                ppage1->InsertionCount == ppage2->InsertionCount &&
                ppage1->DeletionCount == ppage2->DeletionCount &&
                ppage1->SearchCount == ppage2->SearchCount &&
                ppage1->PageSplits == ppage2->PageSplits &&
                ppage1->DirExpansions == ppage1->DirExpansions &&
                ppage1->TableExpansions == ppage2->TableExpansions &&
                ppage1->DupInserts == ppage2->DupInserts );
}

#if 0
//
// Routine Description:
//
//     This routine builds the directory given a hash file.
//     *** Assumes DirLock is held ***
//
// Arguments:
//
//     SetupHash - If TRUE, the hash table will be read and set up.
//                 If FALSE, the hash table is assumed to be set up.
//
// Return Value:
//
//     ERROR_SUCCESS - Everything went ok.
//     Otherwise, the win32 error code.
//
DWORD
CHashMap::I_BuildDirectory(
        IN BOOL SetupHash
        )
{
    DWORD status;
    DWORD nPages;
    DWORD i;
    BOOL newTable = FALSE;
    PMAP_PAGE curPage;

    ENTER("BuildDirectory")

    //
    // open and map the hash file
    //

    if ( SetupHash ) {

        status = I_SetupHashFile( newTable );
        if ( status != ERROR_SUCCESS ) {
            goto error;
        }

        //
        // If this is a new hash file, then set it up with defaults
        //

        if ( newTable ) {

            status = I_InitializeHashFile( );
            if ( status != ERROR_SUCCESS ) {
                goto error;
            }
        }
    }

    m_headPage->DirDepth = m_dirDepth;
    //FlushPage( 0, m_headPage );
	FlushViewOfFile( (LPVOID)m_headPage, HASH_PAGE_SIZE ) ;

    //
    // Initialize the links.  Here we go through all the pages and update the directory
    // links
    //
	BytePage	page ;
    curPage = (PMAP_PAGE)&page ;
    nPages = m_nPagesUsed;

    for ( i = 1; i < nPages; i++ )
    {

        //
        // Set the pointers for this page
        //

		if( !RawPageRead( m_hFile, page, i ) ) {
			status = GetLastError() ;
			goto	error ;
		}

		//
		//	Make sure the directory is of sufficient depth to deal with this
		//	page we are scanning !
		//

		if ( !I_SetDirectoryDepthAndPointers( curPage, i ) )
		{
			status = ERROR_INTERNAL_DB_CORRUPTION ;
			goto	error ;
		}

		//
		// call verify page on this page with minimal checking to make sure
		// that its okay
		//
		if ((m_dwPageCheckFlags & HASH_VFLAG_PAGE_BASIC_CHECKS) &&
		    !VerifyPage(curPage, m_dwPageCheckFlags, NULL, NULL))
		{
			status = ERROR_INTERNAL_DB_CORRUPTION;
			goto error;
		}
    }

	//
	//	Check that the directory is fully initialized, we want to make sure that no
	//	Directory entries were left unitialized !
	//
	for( i=0; i<DWORD(1<<m_TopDirDepth); i++ ) {

		if( !m_pDirectory[i]->IsDirectoryInitGood() ) {
			status = ERROR_INTERNAL_DB_CORRUPTION ;
			goto	error ;
		}
	}

    LEAVE
    return ERROR_SUCCESS;

error:

	_ASSERT( GetLastError() != ERROR_NOT_ENOUGH_MEMORY ) ;

    I_DestroyPageMapping( );
    LEAVE
    return(status);

} // I_BuildDirectory

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\rw.h ===
#ifndef	_CRW_H
#define	_CRW_H
						
#include	<limits.h>

//
// This class contains the meat - does actual locking etc...
//
class	CShareLock {
private : 
	long	cReadLock ;			// Number of Readers who have passed through the lock OR 
								// the number of readers waiting for the lock (will be negative).
								// A value of 0 means nobody in the lock
	long	cOutRdrs ;			// The number of readers remainin in the lock if 
								// there is a writer waiting.  This can become temporarily negative
	CRITICAL_SECTION	critWriters ; 	// Critical section to allow only one writer into the lock at a time
	HANDLE	hWaitingWriters ;	// Semaphore for waiting writers to block on (Only 1 ever, others will 
								// be queued on critWriters)
	HANDLE	hWaitingReaders ;	// Semaphore for waiting readers to block on 
public : 
	CShareLock( ) ;
	~CShareLock( ) ;

	void	ShareLock( ) ;
	void	ShareUnlock( ) ;
	void	ExclusiveLock( ) ;
	void	ExclusiveUnlock( ) ;
	void 	*operator new(size_t size);
	void 	operator delete(void *p, size_t size);
} ;

inline void *CShareLock::operator new(size_t size) { 
	return HeapAlloc(GetProcessHeap(), 0, size); 
}

inline void CShareLock::operator delete(void *p, size_t size) { 
	HeapFree(GetProcessHeap(), 0, p);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\pageent.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pageent.h

Abstract:

    This module contains class declarations/definitions for

        PageEntry

--*/

#ifndef _PAGEENT_
#define _PAGEENT_

#include "hashmap.h"
#include "directry.h"
#include <dbgtrace.h>

#define	INVALID_PAGE_NUM	0xFFFFFFFF

//
//	PageEntry - 
//
//	This class allows us to do our own management of 
//	reading and writing pages within a hash table, as well
//	as synchronizing access to the pages.
//
//	A large memory mapping would be preferable, however 
//	because we want to support hash tables that grow to 
//	extreme sizes (ie. a few gigabytes) we don't have sufficient
//	address space to do everything with a memory mapping.
//
//	So instead, we use PageEntry to help us manage 
//	the individual pages, reading and writing pages on demand.
//
class	PageEntry	{
public : 
	LPVOID				m_lpvPage ;
	DWORD				m_PageNum ;
	HANDLE				m_hFile ;
	//
	//	Keep track of whether we've made the page dirty !
	//
	BOOL				m_fDirty ;
	_RWLOCK				*m_pageLock;

	PageEntry() : 
		m_lpvPage( 0 ),
		m_PageNum( INVALID_PAGE_NUM ),
		m_pageLock( NULL ),
		m_hFile( INVALID_HANDLE_VALUE ), 
		m_fDirty( FALSE )	{
	}

	void *operator new(size_t size);
	void operator delete(void *p, size_t size);

	//
	// Set up the buffer to be used !
	//
	// Set our m_lpvPage pointer to point to the page we will use from now
	// on for Read'ing and Write'ing to the hash table.
	// This function must only be called once, and should only be called during
	// Initialization, so we will assume that it is safe to not bother grabbing
	// any locks.
	//
	void	InitializePage(LPVOID lpv, _RWLOCK	*pLock) { 
		m_lpvPage = lpv; 
		m_pageLock = pLock;
	}

	PMAP_PAGE
	AcquirePageShared(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared,
				IN	class	CPageLock*	pPageLock,
				IN	BOOL	fDropDirectory
				);

	PMAP_PAGE
	AcquirePageExclusive(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared,
				IN	class	CPageLock*	pPageLock,
				IN	BOOL	fDropDirectory
				);

	BOOL
	AcquireSlotExclusive(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared
				) ;

	//
	//	Save a page back to the file	
	//	NOTE : entry must equal m_lpvPage !!
	//	You must call AcquirePageAndLock before 
	//	calling FlushPage !
	//
	BOOL		FlushPage( 
					HANDLE	hFile,
					LPVOID	entry, 
					BOOL	fDirtyOnly = FALSE
					) ;

	//
	//	Get rid of a page if the handle's match !
	//
	void	
	DumpPage(
				IN	HANDLE	hFile
				) ;

	//
	//	Release a page - must be paired with a successfull 
	//	call to AcquirePageLock !!
	//
	void	ReleasePage(	
					LPVOID	entry,
					BOOL fShared
					) ;
	
} ;

//
//  Private overlapped struct for additional fields like IoSize
//

typedef struct _OVERLAPPED_EXT
{
    OVERLAPPED  ovl;            // NT OVERLAPPED struct
    DWORD       dwIoSize;       // size of IO submitted
} OVERLAPPED_EXT;

typedef	BYTE	BytePage[HASH_PAGE_SIZE] ;

//
// read a page of the hash table into our buffer
//
BOOL
RawPageRead(
				HANDLE		hFile,
				BytePage&	page, 
				DWORD		PageNum,
                DWORD       NumPages = 1
				);

//
// read a page of the table into a buffer, for use during boot time.  it
// only reads the parts interesting during the boot phase
//
BOOL
RawPageReadAtBoot(
			HANDLE		hFile,
			BytePage&	page, 
			DWORD		PageNum	);

//
// write one or more pages of the hash table back to disk
//
BOOL
RawPageWrite(
				HANDLE	hFile,
				BytePage&	page, 
				DWORD	PageNum,
                DWORD   NumPages = 1
				);


inline void *PageEntry::operator new(size_t size) { 
	return HeapAlloc(GetProcessHeap(), 0, size); 
}

inline void PageEntry::operator delete(void *p, size_t size) { 
	_VERIFY(HeapFree(GetProcessHeap(), 0, p)); 
}


inline	PMAP_PAGE
CPageCache::AcquireCachePageShared(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock, 
					IN	BOOL	fDropDirectory
					)	{

	DWORD	lockIndex = (PageNumber * Fraction) % m_cPageEntry ;
	PageEntry*	pageEntry = &m_pPageEntry[lockIndex] ;

	return	lock.AcquirePageShared( pageEntry, hFile, PageNumber, fDropDirectory ) ;
}

inline	PMAP_PAGE
CPageCache::AcquireCachePageExclusive(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock, 
					IN	BOOL	fDropDirectory
					)	{

	DWORD	lockIndex = (PageNumber * Fraction) % m_cPageEntry ;
	PageEntry*	pageEntry = &m_pPageEntry[lockIndex] ;

	return	lock.AcquirePageExclusive( pageEntry, hFile, PageNumber, fDropDirectory ) ;
}


inline	BOOL
CPageCache::AddCachePageExclusive(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock
					)	{

	DWORD	lockIndex = (PageNumber * Fraction) % m_cPageEntry ;
	PageEntry*	pageEntry = &m_pPageEntry[lockIndex] ;

	return	lock.AddPageExclusive( pageEntry, hFile, PageNumber ) ;
}


inline	VOID 
CPageCache::ReleasePageShared( 
					PMAP_PAGE	page,
					HPAGELOCK&	hLock
					)		{
	hLock.ReleaseAllShared( page ) ;
}

inline	VOID 
CPageCache::ReleasePageExclusive(	
					PMAP_PAGE	page,
					HPAGELOCK&	hLock 
					)	{
	hLock.ReleaseAllExclusive( page ) ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\pageent.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hash.cpp

Abstract:

    This module contains definition for the PageEntry base class

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include <windows.h>
#include <xmemwrpr.h>
#include <dbgtrace.h>
#include "pageent.h"


void	WINAPI
FileIOCompletionRoutine(
		DWORD	dwError,
		DWORD	cbBytes,
		LPOVERLAPPED	povl
		)	{

    OVERLAPPED_EXT * povlExt = (OVERLAPPED_EXT*)povl;

	if( dwError == ERROR_SUCCESS &&
		cbBytes == povlExt->dwIoSize ) {
		(povlExt->ovl).hEvent = (HANDLE)TRUE ;
	}	else	{
		(povlExt->ovl).hEvent = (HANDLE)FALSE ;
	}
}

PMAP_PAGE
PageEntry::AcquirePageShared(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared,
				IN	HPAGELOCK*	pageLock,
				IN	BOOL	fDropDirectory
				)	{
/*++

Routine Description :

	The goal is to get a page of the hash table
	into memory and then return a pointer to the page
	with a lock for the page held non-exclusively.

	So we will grab our lock in shared mode and see if
	the page is already present. If it ain't we drop
	the lock and get it exclusively and then load the page.

	The fShared Out parameter must be passed to our ReleasePage()
	function so that we can release the lock in the correct manner.


Arguments :

	hFile - File handle of the Hash table file
	PageNum - The page within the file that we want
	fShared - Out parameter - if we set this to TRUE then
		we really did manage to grab the lock in shared
		mode, otherwise we had to grab the lock exclusively
		and re-read the page.
	

Return Value :

	if successfull, we will return a pointer to our buffer
	NULL otherwise !

--*/

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( PageNum != INVALID_PAGE_NUM ) ;

	//
	//	If the page was already loaded - use it and
	//	get a shared lock !
	//

	m_pageLock->ShareLock() ;

	if( m_PageNum == PageNum && m_hFile == hFile ) {

		fShared = TRUE ;

		if(	fDropDirectory && pageLock ) {
			pageLock->ReleaseDirectoryShared() ;
		}

		return	(PMAP_PAGE)m_lpvPage ;

	}

	m_pageLock->ShareUnlock() ;

	//
	//	Oh oh ! the page was not already in memory - need to
	//	read it from the file.  We will leave the page
	//	exclusively locked when we return from this function,
	//	as there's no easy way to get the lock exclusively,
	//	load the page, and the convert the lock to a shared lock !
	//

	fShared = FALSE ;
	m_pageLock->ExclusiveLock() ;

	if(	fDropDirectory && pageLock ) {
		pageLock->ReleaseDirectoryShared() ;
	}

	//
	//	If the file is dirty we need to flush this page !
	//
	if( m_fDirty ) {
		//
		//	Write the page to disk !
		//
		FlushPage( m_hFile, m_lpvPage, FALSE ) ;
		_ASSERT( !m_fDirty ) ;
	}

	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	m_PageNum = PageNum ;
	m_hFile = hFile ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = m_PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

	HANDLE  hEvent = GetPerThreadEvent();
    ovlExt.ovl.hEvent = hEvent ;
    ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE ;

	DWORD   cbResults = 0;
    BOOL	fSuccess = FALSE ;
	if( ReadFile(	hFile, m_lpvPage, HASH_PAGE_SIZE, &cbResults, (LPOVERLAPPED)&ovlExt) ||
        (GetLastError() == ERROR_IO_PENDING &&
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
		if (cbResults != ovlExt.dwIoSize) {
            fSuccess = FALSE;
        } else {
            fSuccess = TRUE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );
    
    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	if( !fSuccess ) {
		m_PageNum = INVALID_PAGE_NUM ;
		m_hFile = INVALID_HANDLE_VALUE ;
		m_pageLock->ExclusiveUnlock( ) ;
		return	0 ;
	}

	return	(PMAP_PAGE)m_lpvPage ;
}

PMAP_PAGE
PageEntry::AcquirePageExclusive(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared,
				IN	HPAGELOCK*	pageLock,
				IN	BOOL	fDropDirectory
				)	{
/*++

Routine Description :

	Read a page of the hash table into our buffer.
	Must grab the page lock first !!!


Arguments :

	hFile - File handle of the Hash table file
	PageNum - The page within the file that we want
	fShared - Out parameter - if we set this to TRUE then
		we really did manage to grab the lock in shared
		mode, otherwise we had to grab the lock exclusively
		and re-read the page.
	

Return Value :

	if successfull, we will return a pointer to our buffer
	NULL otherwise !

--*/

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( PageNum != INVALID_PAGE_NUM ) ;

	//
	//	Oh oh ! the page was not already in memory - need to
	//	read it from the file.  We will leave the page
	//	exclusively locked when we return from this function,
	//	as there's no easy way to get the lock exclusively,
	//	load the page, and the convert the lock to a shared lock !
	//

	fShared = FALSE ;
	m_pageLock->ExclusiveLock() ;

	if(	fDropDirectory && pageLock ) {
		pageLock->ReleaseDirectoryShared() ;
	}

	if( m_PageNum == PageNum && m_hFile == hFile ) {

		return	(PMAP_PAGE)m_lpvPage ;

	}

	//
	//	If the file is dirty we need to flush this page !
	//
	if( m_fDirty ) {
		//
		//	Write the page to disk !
		//
		FlushPage( m_hFile, m_lpvPage, FALSE ) ;
		_ASSERT( !m_fDirty ) ;
	}

	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	m_PageNum = PageNum ;
	m_hFile = hFile ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = m_PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

	HANDLE hEvent = GetPerThreadEvent();
	ovlExt.ovl.hEvent = hEvent ;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE ;

	DWORD   cbResults = 0;
    BOOL	fSuccess = FALSE ;
	if( ReadFile( hFile, m_lpvPage, HASH_PAGE_SIZE, &cbResults, (LPOVERLAPPED)&ovlExt ) ||
        (GetLastError() == ERROR_IO_PENDING &&
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
		if (cbResults != ovlExt.dwIoSize) {
            fSuccess = FALSE;
        } else {
            fSuccess = TRUE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );
    
    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );


	if( !fSuccess ) {
		m_PageNum = INVALID_PAGE_NUM ;
		m_hFile = INVALID_HANDLE_VALUE ;
		m_pageLock->ExclusiveUnlock( ) ;
		return	0 ;
	}

	return	(PMAP_PAGE)m_lpvPage ;
}


BOOL
PageEntry::AcquireSlotExclusive(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared
				)	{
/*++

Routine Description :

	Grab a slot used for holding pages Exclusively.
	This is used when adding pages to the hash table during
	page splits.we grab the slot so that nobody mistakenly tries to
	access the page before the write of it has completed !


Arguments :

	hFile - File handle of the Hash table file
	PageNum - The page within the file that we want
	fShared - Out parameter - if we set this to TRUE then
		we really did manage to grab the lock in shared
		mode, otherwise we had to grab the lock exclusively
		and re-read the page.
	

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( PageNum != INVALID_PAGE_NUM ) ;

	//
	//	Oh oh ! the page was not already in memory - need to
	//	read it from the file.  We will leave the page
	//	exclusively locked when we return from this function,
	//	as there's no easy way to get the lock exclusively,
	//	load the page, and the convert the lock to a shared lock !
	//

	fShared = FALSE ;
	m_pageLock->ExclusiveLock() ;

	return	TRUE ;
}



BOOL
PageEntry::FlushPage(
				HANDLE	hFile,
				LPVOID	entry, 
				BOOL	fDirtyOnly
				) {
/*++

Routine Description :

	Commit a page back to the disk.
	We've been passed the address that the user wants to flush,
	this must be a page we previously acquired throuh AcquirePageAndLock()
	so we will ensure that we get the same address as we're currently
	sitting on.

	****** Lock must be held ***********

Arguments :

	entry - Pointer to the page to be flushed ! Must be the same
		as our m_lpvPage member !

Return Value : 
	fDirtyOnly - if TRUE then we don't write the page, we only 
		mark the page as dirty !

	Nothing.
	
--*/

	_ASSERT( (LPVOID)entry == m_lpvPage ) ;
	_ASSERT( m_PageNum != INVALID_PAGE_NUM ) ;
	_ASSERT( m_hFile == hFile ) ;

	if( fDirtyOnly ) {
		m_fDirty = TRUE ;
		return	TRUE ;
	}
	
	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = m_PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

    HANDLE  hEvent = GetPerThreadEvent();
    ovlExt.ovl.hEvent = hEvent;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE ;

	DWORD   cbResults = 0;
    BOOL	fSuccess = FALSE ;
	if( WriteFile(	hFile, m_lpvPage, HASH_PAGE_SIZE, &cbResults, (LPOVERLAPPED)&ovlExt) ||
        (GetLastError() == ERROR_IO_PENDING && 
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
        
		if (cbResults == ovlExt.dwIoSize) {
		    fSuccess = TRUE;
        } else {
            fSuccess = FALSE;
        }
		m_fDirty = FALSE ;
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );

    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	return	fSuccess ;
}

void
PageEntry::DumpPage(
				HANDLE	hFile
				)	{
/*++

Routine Description : 

	Discard a page from the cache if it falls in the specified file !

Arguments : 

	hFile - The file we don't want anymore !

Return Value : 

	Nothing.
	
--*/

	BOOL	fMatch = FALSE ;

	m_pageLock->ShareLock() ;

	fMatch = hFile == m_hFile ;	

	m_pageLock->ShareUnlock() ;

	if( fMatch )	{
	
		m_pageLock->ExclusiveLock() ;
		if( hFile == m_hFile ) {
			//
			//	If the file is dirty we need to flush this page !
			//
			if( m_fDirty ) {
				//
				//	Write the page to disk !
				//
				FlushPage( m_hFile, m_lpvPage, FALSE ) ;
				_ASSERT( !m_fDirty ) ;
			}
			hFile = INVALID_HANDLE_VALUE ;
			m_PageNum = INVALID_PAGE_NUM ;
			m_fDirty = FALSE ;
		}
		m_pageLock->ExclusiveUnlock() ;
	}
}

void
PageEntry::ReleasePage(
				LPVOID	page,
				BOOL	fShared
				)	{
/*++

Routine Description :

	This function releases the lock we have on a page !

Arguments :

	page - pointer to the page we had earlier provided to the user
		This must be the same as m_lpvPage !!!

Return Value :

	None.

--*/	

	_ASSERT( (LPVOID)page == m_lpvPage || page == 0) ;

	if( fShared ) {

		m_pageLock->ShareUnlock() ;

	}	else	{

		m_pageLock->ExclusiveUnlock( ) ;

	}
}


/*++

Routine Description :

	Read a page of the hash table into our buffer.

Arguments :

	hFile - File handle of the Hash table file
	page - Place where we want to save the page contents.
	PageNum - The page within the file that we want

Return Value :

	TRUE or FALSE depending on success

--*/
BOOL
RawPageRead(
				HANDLE		hFile,
				BytePage&	page,
				DWORD		PageNum,
                DWORD       NumPages
				)	
{

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	

	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

	HANDLE  hEvent = GetPerThreadEvent() ;
	ovlExt.ovl.hEvent = hEvent;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE*NumPages ;

    DWORD   cbResults = 0;
	BOOL	fSuccess = FALSE ;
	if( ReadFile( hFile, &page, HASH_PAGE_SIZE*NumPages, &cbResults, (LPOVERLAPPED)&ovlExt )  ||
        (GetLastError() == ERROR_IO_PENDING &&
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
		if (cbResults != ovlExt.dwIoSize) {
            fSuccess = FALSE;
        } else {
            fSuccess = TRUE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );
    
    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	return	fSuccess;
}

BOOL
RawPageReadAtBoot(
			HANDLE		hFile,
			BytePage&	page,
			DWORD		PageNum	)	{

/*++

Routine Description :

	Read a portion of a page of the hash table into our buffer.
	This function is called only during boot initialization, when
	we don't care to read the entire page, just the interesting
	header bits.

Arguments :

	hFile - File handle of the Hash table file
	page - Place where we want to save the page contents.
	PageNum - The page within the file that we want

Return Value :

	if successfull, we will return a pointer to our buffer
	NULL otherwise !

--*/

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;

	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

	HANDLE  hEvent = GetPerThreadEvent() ;
	ovlExt.ovl.hEvent = hEvent;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE ;

    DWORD   cbResults = 0;
	BOOL	fSuccess = FALSE ;
	if( ReadFile( hFile, &page, HASH_PAGE_SIZE, &cbResults, (LPOVERLAPPED)&ovlExt ) ||
        (GetLastError() == ERROR_IO_PENDING &&
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
		if (cbResults != ovlExt.dwIoSize) {
            fSuccess = FALSE;
        } else {
            fSuccess = TRUE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );

    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	return	fSuccess;
}

/*++

Routine Description :

	Commit a page back to the disk.
	We've been passed the address that the user wants to flush,
	this must be a page we previously acquired throuh AcquirePageAndLock()
	so we will ensure that we get the same address as we're currently
	sitting on.

	****** Lock must be held ***********

Arguments :

	entry - Pointer to the page to be flushed ! Must be the same
		as our m_lpvPage member !

Return Value :

	TRUE or FALSE depending on success
	
--*/
RawPageWrite(
				HANDLE	hFile,
				BytePage&	page,
				DWORD	PageNum,
                DWORD   NumPages
				)
{

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	
	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

    HANDLE  hEvent = GetPerThreadEvent();
    ovlExt.ovl.hEvent = hEvent;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE*NumPages ;

    DWORD   cbResults = 0;
	BOOL	fSuccess = FALSE ;
	if( WriteFile( hFile, page, HASH_PAGE_SIZE*NumPages, &cbResults, (LPOVERLAPPED)&ovlExt ) ||
        (GetLastError() == ERROR_IO_PENDING && 
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
        
		if (cbResults == ovlExt.dwIoSize) {
		    fSuccess = TRUE;
        } else {
            fSuccess = FALSE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );

    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	return	fSuccess ;	
}


CPageCache::CPageCache()	:
	m_lpvBuffers( 0 ),
	m_cPageEntry( 0 ),
	m_pPageEntry( 0 ),
	m_cpageLock( 0 ),
	m_ppageLock( 0 )	{

}

BOOL
CPageCache::Initialize(
					DWORD	cPageEntry,
					DWORD	cLocks
					) {


	MEMORYSTATUS	memStatus ;
	memStatus.dwLength = sizeof( memStatus ) ;
	GlobalMemoryStatus( &memStatus ) ;


	//
	//	If the number is zero make up a default !
	//
	if( cPageEntry == 0 ) {

		DWORD	block = (DWORD)(memStatus.dwTotalPhys / 4096) ;
		//
		//	We want to take a 3rd of available ram !
		//
		block /= 3 ;

		//  Or 4MB, whichever is smaller - bug 76833
		block = min(block, 4 * KB * KB / 4096);

		//
		//	Now we want that to be divisible evenly by 32
		//
		
		cPageEntry = block & (~(32-1)) ;

	}

	if( cPageEntry < 32 )
		cPageEntry = 32 ;

#ifndef	_USE_RWNH_
	//
	//	If the number is zero make up a default !
	//
	if( cLocks == 0 ) {

		cLocks = memStatus.dwTotalPhys / (1024 * 1024) ;

		//
		//	We will do a lock per megabyte of RAM the system has !
		//	with a limit of 256 !
		//

		if( cLocks > 256 )
			cLocks = 256 ;

	}
	
	if( cLocks < 16 )
		cLocks = 16 ;
#else
	cLocks = cPageEntry ;
#endif

	//
	//	If for some reason there's an existing array of
	//	locks than the count should not be 0.
	//
	_ASSERT( m_ppageLock == 0 ||
				m_cpageLock != 0 ) ;

	if( m_ppageLock == 0 )	{
		m_cpageLock = cLocks ;
		m_ppageLock = new	_RWLOCK[cLocks] ;
		if( m_ppageLock == 0 ) {
			m_cpageLock = 0 ;
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			return	FALSE ;
		}
	}

	//
	//	These should not have been touched before now !
	//
	_ASSERT( m_lpvBuffers == 0 ) ;
	_ASSERT( m_cPageEntry == 0 ) ;

	m_cPageEntry = cPageEntry ;

	for( int i=0; i<3 && m_cPageEntry != 0 ; i++ ) {

		m_lpvBuffers = VirtualAlloc(	0,
										HASH_PAGE_SIZE * m_cPageEntry,
										MEM_COMMIT | MEM_TOP_DOWN,
										PAGE_READWRITE
										) ;

		if( m_lpvBuffers )
			break ;

		m_cPageEntry /= 2 ;
	}

	if( m_lpvBuffers == 0 ) {
		m_cPageEntry = 0 ;
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}

	m_pPageEntry = new PageEntry[ m_cPageEntry ] ;
	if( m_pPageEntry != 0 ) {

		DWORD	iLock = 0 ;
		BYTE*	lpb = (BYTE*)m_lpvBuffers ;
		for( DWORD i = 0; i < m_cPageEntry; i++ ) {

			m_pPageEntry[i].InitializePage( (LPVOID)lpb, &m_ppageLock[iLock] ) ;

			iLock ++ ;
			iLock %= m_cpageLock ;

			lpb += HASH_PAGE_SIZE ;

		}
	}	else	{
		_VERIFY( VirtualFree(	m_lpvBuffers,
								0,
								MEM_RELEASE
								) ) ;
		m_lpvBuffers = 0 ;

		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}
	return	TRUE ;
}

void
CPageCache::FlushFileFromCache( 
				HANDLE	hFile
				)	{
/*++

Routine Description : 

	This function forces all pages from the specified file
	out of the cache !

Arguments : 

	hFile - Handle to the file that is to be rid of !

Return Value : 

	None.

--*/

	for( DWORD i=0; i<m_cPageEntry; i++ ) {
		m_pPageEntry[i].DumpPage( hFile ) ;
	}
}


CPageCache::~CPageCache()	{

	if( m_lpvBuffers != 0 ) {

		_VERIFY( VirtualFree(
							m_lpvBuffers,
							0,
							MEM_RELEASE
							) ) ;
	}

	if( m_pPageEntry ) {

		delete[]	m_pPageEntry ;

	}

	if( m_ppageLock ) {

		delete[]	m_ppageLock ;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\scan.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    scan.cpp

Abstract:

    This module contains the scanning code for the chkhash program.

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include <windows.h>
#include <xmemwrpr.h>
#include "dbgtrace.h"
#include "directry.h"
#include "pageent.h"
#include "hashmap.h"

#define FOUND_ERROR(__error_flag__) {									\
	if (pdwErrorFlags != NULL) *pdwErrorFlags |= __error_flag__;		\
	SetLastError(ERROR_INTERNAL_DB_CORRUPTION);							\
	TraceFunctLeave();													\
	return FALSE;														\
}

BOOL CHashMap::VerifyPage(	PMAP_PAGE pPage,
							DWORD dwCheckFlags,
							DWORD *pdwErrorFlags,
							IKeyInterface*	pIKey,
							ISerialize	*pHashEntry)
{
	TraceQuietEnter("CHashMap::VerifyPage");

	if (!(dwCheckFlags & HASH_VFLAG_PAGE_BASIC_CHECKS)) {
		TraceFunctLeave();
		return(TRUE);
	}
	
    DWORD j, nDel = 0, nOk = 0;
    SHORT offset;

	// these are parallel arrays that are used for checking for overlapping
	// pages
	SHORT rgEntryOffset[MAX_LEAF_ENTRIES];
	SHORT rgEntryLength[MAX_LEAF_ENTRIES];
	BOOL  rgIsDeleted[MAX_LEAF_ENTRIES];
	// the size of each array
	SHORT nEntries = 0;

	// get the mask for hash bits
	DWORD cMaskDepth = 32 - pPage->PageDepth;
	DWORD dwHashMask = (0xffffffff >> cMaskDepth) << cMaskDepth;

    //
    // check every entry in the page
    //
    for (j = 0; j < MAX_LEAF_ENTRIES; j++) {
        offset = pPage->Offset[j];
        if (offset != 0) {

			//
			// make sure the entry offset is valid
			//
			if (offset > HASH_PAGE_SIZE) {
				// the entry offset is too large
				ErrorTrace(0, "offset %lu is too large on entry %lu",
					offset, j);
				FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
			}

            if (offset < 0) {
				// deleted entry
				nDel++;
				continue;
			} else {
				// this isn't a deleted entry
				nOk++;


				PENTRYHEADER pEntry = (PENTRYHEADER) GET_ENTRY(pPage, offset);

				//
				// make sure the entry size is valid
				//
				if (pEntry->EntrySize < sizeof(ENTRYHEADER) ||
					offset + pEntry->EntrySize > HASH_PAGE_SIZE)
				{
					// the size is invalid
					ErrorTrace(0, "entry size %lu is invalid on entry %lu",
						pEntry->EntrySize, j);
					FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
				}
				
	            //
	            // Make sure hash values are mapped to correct pages
	            //
				if ((dwHashMask & pEntry->HashValue) != 
					(dwHashMask & (pPage->HashPrefix << (32-pPage->PageDepth)))) 
				{
					// this entry has an invalid hash value
					ErrorTrace(0, "hash value %x does not equal prefix %x (depth = %lu)",
						pEntry->HashValue, pPage->HashPrefix,
						pPage->PageDepth);
					FOUND_ERROR(HASH_FLAG_ENTRY_BAD_HASH)
				}

				//
				// verify that the KeyLen is valid
				//
				if( pIKey != NULL ) {

					if( !pIKey->Verify( pEntry->Data, pEntry->Data, pEntry->EntrySize ) ) {
						// the keylen is invalid
						FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
					}

					if (pHashEntry != NULL && (dwCheckFlags & HASH_VFLAG_PAGE_VERIFY_DATA) ) {
						//
						// call the verify function for this entry to make sure that
						// its valid
						//
						PBYTE pEntryData = pIKey->EntryData( pEntry->Data ) ;
						if (!pHashEntry->Verify(pEntry->Data, pEntryData, pEntry->EntrySize ))
						{
							ErrorTrace(0, "CHashEntry::Verify failed");
							FOUND_ERROR(HASH_FLAG_ENTRY_BAD_DATA)
						}
					}
				}
#if 0
				if (offset + pEntry->KeyLen >
					offset + pEntry->Header.EntrySize)
				{
					// the keylen is invalid
					ErrorTrace(0, "the key length %lu is invalid",
						pEntry->KeyLen);
					FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
				}
				if (dwCheckFlags & HASH_VFLAG_PAGE_VERIFY_DATA &&
					pHashEntry != NULL)
				{
					//
					// call the verify function for this entry to make sure that
					// its valid
					//
					PBYTE pEntryData = pEntry->Key + pEntry->KeyLen;
					if (!pHashEntry->Verify(pEntry->Key, pEntry->KeyLen,
										    pEntryData))
					{
						ErrorTrace(0, "CHashEntry::Verify failed");
						FOUND_ERROR(HASH_FLAG_ENTRY_BAD_DATA)
					}
				}
#endif

				rgEntryLength[nEntries] = pEntry->EntrySize;
				rgIsDeleted[nEntries] = FALSE;
				rgEntryOffset[nEntries] = offset;
				nEntries++;
	        }
		}
    }


	//
	// walk the delete list
	//
    WORD iDeletedEntry;
    iDeletedEntry = pPage->DeleteList.Flink;
	while (iDeletedEntry != 0) {
		PDELENTRYHEADER pDelEntry;
		pDelEntry = (PDELENTRYHEADER) GET_ENTRY(pPage, iDeletedEntry);

		//
		// make sure the entry size is valid
		//
		if (pDelEntry->EntrySize < sizeof(DELENTRYHEADER) ||
			offset + pDelEntry->EntrySize > HASH_PAGE_SIZE)
		{
			// the size is invalid
			ErrorTrace(0, "entry size %lu is invalid on entry %lu",
				pDelEntry->EntrySize, j);
			FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
		}

		rgEntryOffset[nEntries] = iDeletedEntry;
		rgEntryLength[nEntries] = pDelEntry->EntrySize;
		rgIsDeleted[nEntries] = TRUE;
		nEntries++;

        iDeletedEntry = pDelEntry->Link.Flink;
	}

	//
    // Check to see that all numbers are consistent
    //
    if (nOk + nDel != pPage->EntryCount) {
        ErrorTrace(0, "page entry counts don't match (should be %i, is %i)",
			nOk + nDel, pPage->EntryCount);
		FOUND_ERROR(HASH_FLAG_BAD_ENTRY_COUNT)
    }

	//
	// do the check for overlapping entries
	//
	if (dwCheckFlags & HASH_VFLAG_PAGE_CHECK_OVERLAP) {
		//
		// GUBGUB - check for overlapping entries
		//
	}

	//TraceFunctLeave();
	return TRUE;
}

#undef FOUND_ERROR
#define FOUND_ERROR(__error_flag__) {									\
	if (pdwErrorFlags != NULL) *pdwErrorFlags |= __error_flag__;		\
	SetLastError(ERROR_INTERNAL_DB_CORRUPTION);							\
	goto error;															\
}

//
// verify that a hashmap file is okay
//
BOOL CHashMap::VerifyHashFile(	LPCSTR szFilename,
								DWORD dwSignature,
								DWORD dwCheckFlags,
								DWORD *pdwErrorFlags,
								IKeyInterface*	pIKey,
								ISerialize	*pHashEntry)
{
	TraceFunctEnter("CHashMap::VerifyHashFile");
	
    DWORD fileSize = 0;
    DWORD nPages;
    HANDLE hFile = INVALID_HANDLE_VALUE, hMap = NULL;
    DWORD dirDepth;
    DWORD nEntries;
    PDWORD pDirectory = NULL;
    DWORD i;
    BOOL ret = FALSE;
	BytePage pHeadPageBuf, pThisPageBuf;
	PHASH_RESERVED_PAGE pHeadPage = (PHASH_RESERVED_PAGE) pHeadPageBuf;
	PMAP_PAGE pThisPage = (PMAP_PAGE) pThisPageBuf;

    //
    // Open the hash file
    //
    hFile = CreateFile(szFilename,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                       NULL
                       );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
			ErrorTrace(0, "hash file not found");
			FOUND_ERROR(HASH_FLAG_NO_FILE)
        } else {
        	if (*pdwErrorFlags != NULL) *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
            ErrorTrace(0, "Error %d in CreateFile", GetLastError());
			goto error;
        }
		_ASSERT(FALSE);
    }

    //
    // Get the size of the file.  This will tell us how many pages
    // are currently filled.
    //
    fileSize = GetFileSize(hFile, NULL);
    if (fileSize == 0xffffffff) {
        ErrorTrace(0, "Error %d in GetFileSize", GetLastError());
        if (*pdwErrorFlags != NULL) *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
        goto error;
    }

	DebugTrace(0, "File size is %d", fileSize);

    //
    // Make sure the file size is a multiple of a page
    //
    if ((fileSize % HASH_PAGE_SIZE) != 0) {
        ErrorTrace(0, "File size(%d) is not page multiple", fileSize);
		FOUND_ERROR(HASH_FLAG_BAD_SIZE)
    }

    nPages = fileSize / HASH_PAGE_SIZE;

    DebugTrace(0, "pages allocated %d", nPages);

	//
	// read the head page
	//
	if (!RawPageRead(hFile, pHeadPageBuf, 0)) {
		ErrorTrace(0, "Error %d in in RawPageRead", GetLastError());
        *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
        goto error;
	}

    //
    // Check the signature and the initialize bit
    //
    if (pHeadPage->Signature != dwSignature) {
        //
        // Wrong signature
        //
        ErrorTrace(0, "Invalid signature %x (expected %x)",
            pHeadPage->Signature, dwSignature);
		FOUND_ERROR(HASH_FLAG_BAD_SIGNATURE)
    }

    if (!pHeadPage->Initialized) {
        //
        // Not initialized !
        //
        ErrorTrace(0, "Existing file uninitialized!!!!.");
		FOUND_ERROR(HASH_FLAG_NOT_INIT)
    }

    if (pHeadPage->NumPages > nPages) {
        //
        // bad count. Corrupt file.
        //
        ErrorTrace(0, "NumPages in Header(%d) more than actual(%d)",
            pHeadPage->NumPages, nPages);
        FOUND_ERROR(HASH_FLAG_BAD_PAGE_COUNT)
    }

    //
    // Create links and print stats for each page
    //
    nPages = pHeadPage->NumPages;
    dirDepth = pHeadPage->DirDepth;

#if 0
	// dirDepth isn't always accurate.  when a file is first created it sets
	// dirDepth = 2, even though it makes 256 pages (and thus dirDepth should
	// be 8).  checking for this special case here...
	if (dirDepth == 2 && nPages == 257) dirDepth = 8;
#endif
    nEntries = (DWORD)(1 << dirDepth);
    if (nEntries < (nPages-1)) {
        ErrorTrace(0, "dir depth(%i) is not sufficient for pages(%i)",
			dirDepth, nPages - 1);
		FOUND_ERROR(HASH_FLAG_BAD_DIR_DEPTH)
    }

	DebugTrace(0, "dirDepth = %lu", dirDepth);

	if (dwCheckFlags & HASH_VFLAG_FILE_CHECK_DIRECTORY) {
	    //
	    // OK, build the directory
	    //
	    DebugTrace(0, "Setting up directory of %d entries",nEntries);

	    pDirectory = (PDWORD)LocalAlloc(0, nEntries * sizeof(DWORD));
	    if (pDirectory == NULL) {
	        ErrorTrace(0, "Cannot allocate directory of %d entries!!!",
				nEntries);
	        *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
	        goto error;
	    }

	    ZeroMemory(pDirectory, nEntries * sizeof(DWORD));
	} else {
		pDirectory = NULL;
	}

	if (dwCheckFlags != 0) {
	    //
	    // verify each page
	    //
	    for ( i = 1; i < nPages; i++ ) {
	        DebugTrace(0, "Processing page %d",i);
	
			//
			// read this page
			//
			if (!RawPageRead(hFile, pThisPageBuf, i)) {
				ErrorTrace(0, "Error %d in in RawPageRead", GetLastError());
		        *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
		        goto error;
			}
	
			if (dwCheckFlags & HASH_VFLAG_FILE_CHECK_DIRECTORY) {
				_ASSERT(pDirectory != NULL);
	
		        //
		        // Set the pointers for this page
		        //
		        DWORD startPage, endPage;
		        DWORD j;
	
		        //
		        // Get the range of directory entries that point to this page
		        //
		        startPage = pThisPage->HashPrefix << (dirDepth - pThisPage->PageDepth);
		        endPage = ((pThisPage->HashPrefix+1) << (dirDepth - pThisPage->PageDepth));
	
		        DebugTrace(0, "Directory ptrs <%d:%d>",startPage,endPage-1);
	
		        if ((startPage > nEntries) || (endPage > nEntries)) {
		            ErrorTrace(0, "Corrupt prefix for page %d",i);
		            FOUND_ERROR(HASH_FLAG_PAGE_PREFIX_CORRUPT)
		        }
	
		        for ( j = startPage; j < endPage; j++ ) {
		            pDirectory[j] = i;
		        }
			}
	
			if (dwCheckFlags & HASH_VFLAG_PAGE_BASIC_CHECKS) {
		        if (!VerifyPage(pThisPage, dwCheckFlags, pdwErrorFlags,
								pIKey, pHashEntry))
				{
					ErrorTrace(0, "invalid page data %d", i);
					goto error;
				}
			}
		}
	}

	if (dwCheckFlags & HASH_VFLAG_FILE_CHECK_DIRECTORY) {
	    //
	    // Make sure all the links have been initialized.  If not, then
		// something terrible has happened.  Do a comprehensive rebuilt.
	    //

	    for (i = 0;i < nEntries; i++) {
	        if (pDirectory[i] == 0) {
	            ErrorTrace(0, "Directory link check failed on %d",i);
	            FOUND_ERROR(HASH_FLAG_BAD_LINK)
	            goto error;
	        }
	    }
	}

    ret = TRUE;

error:

    //
    // Delete the Directory
    //

	// cleanup allocated memory
    if (pDirectory != NULL) {
        LocalFree(pDirectory);
        pDirectory = NULL;
    }

    //
    // Close the file
    //
    if (hFile != INVALID_HANDLE_VALUE) {
        _VERIFY( CloseHandle(hFile) );
        hFile = INVALID_HANDLE_VALUE;
    }

	TraceFunctLeave();
    return(ret);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\utest\tstrhmap.h ===
/************************************************/
/*												*/
/*		 S T R I N G    H A S H    M A P		*/
/*												*/
/* file: tstrhmap.h								*/
/* classes: CTStringHashMap						*/
/* Copyright (C) by Microsoft Corporation, 1996 */
/* Written by Dmitriy Meyerzon					*/
/************************************************/

#ifndef __TSTRHMAP_H
#define __TSTRHMAP_H

#include "hashmap.h"

//class T has to be publicly derived from CHashEntry
// the purpose of the template is only to provide type safe operations 

template <class T> class CTStringHashMap : private CHashMap
{
	public:
	CTStringHashMap(LPCTSTR pszHashFileName, DWORD dwMinFileSize = 0) :
		CHashMap(pszHashFileName, Signature, dwMinFileSize) {}

	~CTStringHashMap() {}

    //
    // Delete an entry
    //

    BOOL DeleteMapEntry(LPCTSTR pszKey)
	{
		return CHashMap::DeleteMapEntry((LPBYTE) pszKey, lstrlen(pszKey));
	}

	//
	// Lookup, test delete integrity, and delete, atomic
	//

	BOOL LookupAndDelete(LPCTSTR pszKey, T* pHashEntry)
	{
		return CHashMap::LookupAndDelete((LPBYTE)pszKey, lstrlen(pszKey), pHashEntry);
	}
		
    //
    // See if the entry is here
    //

	BOOL Contains(LPCTSTR pszKey)
	{
		return CHashMap::Contains((LPBYTE) pszKey, lstrlen(pszKey));
	}

    BOOL LookupMapEntry(LPCTSTR pszKey, T* pHashEntry)
	{
		return CHashMap::LookupMapEntry((LPBYTE) pszKey, lstrlen(pszKey),
										(CHashEntry *)pHashEntry);
	}

	BOOL UpdateMapEntry(LPCTSTR pszKey, const T* pHashEntry)
	{
		return CHashMap::UpdateMapEntry((LPBYTE) pszKey, lstrlen(pszKey),
										pHashEntry);
	}

    //
	// Insert new intry
	//

	BOOL InsertMapEntry(LPCTSTR pszKey, const T *pHashEntry)
	{
		return CHashMap::InsertMapEntry((LPBYTE) pszKey, lstrlen(pszKey),
										(CHashEntry *)pHashEntry);
	}

	
	//
	// Return total entries in hash map - export from the base class
	//

	CHashMap::GetEntryCount;

	static const DWORD Signature;	//this will have to be defined per template instance
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\src\rw.cpp ===
//
// This file contains test implmentations of reader and writer locks.
// These are intended to be used with the template class in rw.h so that
// different implementations can be plugged in and tested.
// 
// The semantics of the read/write classes should be as follows : 
//	Functions CAN NOT be recursively called,
//	Multiple Readers should be able to enter the lock 
//	Only a single writer may execute at a time.
//



#include	<windows.h>
#include    <xmemwrpr.h>
#include	<limits.h>
#include	"rw.h"

long	const	BlockValue = (-LONG_MAX) / 2; 
							// Large in magnitude, negative value.  Used to 
							// indicate a waiting writer in cReadLock


CShareLock::CShareLock( ) : cReadLock( 0  ), cOutRdrs( 0 )	{
	InitializeCriticalSection( &critWriters ) ;
	hWaitingWriters = CreateSemaphore( NULL, 0, 1, NULL ) ;
	hWaitingReaders = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
}

CShareLock::~CShareLock( ) {
	CloseHandle( hWaitingWriters );
	CloseHandle( hWaitingReaders );
	DeleteCriticalSection( &critWriters ) ;
}


void
CShareLock::ShareLock( ) {
	long	sign = InterlockedIncrement( &cReadLock ) ;
	if( sign > 0 ) {
		return ;
	}	else 	{
		// There must be a writer in the lock.  Wait for him to leave.
		// The InterlockedIncrement recorded our presence so that the writer
		// can later release the correct number of threads.
		WaitForSingleObject( hWaitingReaders, INFINITE ) ;
	}
}

void
CShareLock::ShareUnlock( ) {
	//
	// Leave the lock.  The return value will be negative if there is a writer
	// waiting.
	BOOL fWriterWaiting = InterlockedDecrement( &cReadLock ) < 0 ;

	if( fWriterWaiting ) {
		//
		// The following increment occurs when there is writer waiting, but
		// readers own the lock.  So although cReadLock is temporarily inaccurate
		// about the number of readers waiting for the lock, it is not inaccurate 
		// when it matters in WriteUnlock (which assumes a writer owns the lock.)
		//
		long junk = InterlockedIncrement( &cReadLock ) ;	// restore the value in cReadLock, so that we
												// end up with an accurate count of readers waiting
												// for entry.  

		long sign = InterlockedDecrement( &cOutRdrs ) ;	// Make sure we don't lose track of the 
												// number for readers who have left the lock.
		//
		// Are we the last reader out of the lock ?
		//
		if( sign == 0 ) {
			//
			// Definately the last reader out !
			//
			ReleaseSemaphore( hWaitingWriters, 1, &junk ) ;
		}
	}
}

void
CShareLock::ExclusiveLock( ) {
	// Only one writer allowed to try for the lock at a time.
	//
	EnterCriticalSection( &critWriters ) ;

	//
	// Need to track the number of readers who leave the lock while we 
	// are trying to grab it.
	//
	cOutRdrs = 0 ;
	// Grab the lock 
 	long	oldsign = InterlockedExchange( &cReadLock, BlockValue ) ;
	// How many readers left while we grabbed the lock ??
	long	oldval = InterlockedExchange( &cOutRdrs, oldsign ) ;

	//
	// Accurately track all the readers who left the lock.
	//
	long	cursign = 1 ;	// Initialize to 1 so that if while loop not executed
							// following if statement works correctly.
	while( oldval++ ) 
		cursign = InterlockedDecrement( &cOutRdrs ) ; 

	//
	// Do we own the lock ?  Only if there were no readers, or they have all left already.
	//
	if( oldsign == 0 || cursign == 0 ) {
		// We have the lock
	}	else	{
		// Wait for a reader to signal us.
		WaitForSingleObject( hWaitingWriters, INFINITE ) ;
	}
}



void
CShareLock::ExclusiveUnlock( ) 	{

	// Estimate how many readers are waiting for the lock
	long	cWaiting = cReadLock - BlockValue ;

	// This Exchange allows any readers who have just arrived to grab the lock.
	// Also, it accounts for cWaiting of the blocked readers.
	long	cNewWaiting = InterlockedExchange( &cReadLock, cWaiting ) - BlockValue ;
	
	// cNewWaiting is the EXACT number of blocked readers - we will increment cReadLock
	// until we have accounted for the difference between our estimate and the correct
	// number !
	long	cTotal = cNewWaiting ;	// Save cNewWaiting for later use
	while( cNewWaiting-- > cWaiting ) 
		InterlockedIncrement( &cReadLock ) ;

	if( cTotal > 0 ) {
		long	junk = 0 ;
		ReleaseSemaphore( hWaitingReaders, cTotal, &junk ) ;	// let all those readers go!
	}
	// Let the next writer take his shot at the lock!
	LeaveCriticalSection( &critWriters ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\hashmap\utest\main.cpp ===
//
// unit test for CHashMap
//
// awetmore - august 21, 1996
//

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <dbgtrace.h>
#include "hashmap.h"

BOOL checkdata(DWORD key, DWORD size, DWORD c, LPBYTE data);

//
// a simple hash entry for testing purposes
//
// contains 4 members that are accessible and saved in the hash table.  they are:
//   dwKey - the integer key that is used for this item
//   dwCounter - a counter value
//   dwSize - the number of bytes in lpData
//   lpData - some data
//
// the test app uses the key and counter values to verify that the data in lpData
// has not been altered.
//
class CSampleHashEntry : public CHashEntry {
	public:
		CSampleHashEntry(void) { m_lpData = NULL; }
		void SetData(DWORD dwCounter, DWORD dwKey, DWORD dwSize, LPVOID lpData) {
			m_dwCounter = dwCounter;
			m_dwKey = dwKey;
			m_dwSize = dwSize;
			SetBuffer(lpData);
		}

		void SetBuffer(LPVOID lpData) {
			m_lpData = lpData;
		}

		// dstdata must be at least GetSize() big
		DWORD GetSize(void) { return m_dwSize; }
		DWORD GetKey(void) { return m_dwKey; }
		DWORD GetCounter(void) { return m_dwCounter; }

		//
		// derived from HashEntry
		//
		virtual void SerializeToPointer(LPBYTE pbPtr) const {
			DWORD *pdwPtr = (DWORD *) pbPtr;

			pdwPtr[0] = m_dwCounter;
			pdwPtr[1] = m_dwKey;
			pdwPtr[2] = m_dwSize;
			CopyMemory(pbPtr + (3 * sizeof(DWORD)), m_lpData, m_dwSize);
		}

		virtual void RestoreFromPointer(LPBYTE pbPtr) {
			TraceFunctEnter("RestoreFromPointer");

			DWORD *pdwPtr = (DWORD *) pbPtr;

			m_dwCounter = pdwPtr[0];
			m_dwKey = pdwPtr[1];
			m_dwSize = pdwPtr[2];
			DebugTrace(0, "m_dwSize = %lu\n", m_dwSize);
			CopyMemory(m_lpData, pbPtr + (3 * sizeof(DWORD)), m_dwSize);
		}

		virtual DWORD GetEntrySize() const {
			return m_dwSize + (3 * sizeof(DWORD));
		}

		BOOL Verify(LPBYTE pKey, DWORD cKey, LPBYTE pbPtr) const {
			DWORD *pdwPtr = (DWORD *) pbPtr;

			// verify the key first
			for (DWORD x = 0; x < cKey; x++) if (!isdigit(pKey[x])) {
				printf("non-digit character found in key string\n");
				return(FALSE);
			}

			// verify the data
			DWORD dwCounter = pdwPtr[0];
			DWORD dwKey = pdwPtr[1];
			DWORD dwSize = pdwPtr[2];
			LPBYTE pbData = (BYTE *) (pdwPtr + 3);

			char buf[10];
			memcpy(buf, pKey, cKey);
			buf[cKey] = 0;
			if ((DWORD) atoi(buf) != dwKey) {
				printf("key string (%s) != match key number (%lu)\n",
					buf, dwKey);
				return(FALSE);
			}

			if (!checkdata(dwKey, dwSize, dwCounter, pbData)) {
				printf("check data failed on %i\n", dwKey);
				return(FALSE);
			}

			return TRUE;
		}

	private:
		DWORD m_dwCounter;
		DWORD m_dwKey;
		DWORD m_dwSize;
		LPVOID m_lpData;
};

//
// A hash table indexed by a TSTR
//
template <class T> class CTSTRHashMap : private CStringHashMap	{
	public:
		static BOOL VerifyHashFile(LPCTSTR pszHashFileName, DWORD dwCheckFlags, DWORD *pdwErrorFlags) {
			T he;

			return CStringHashMap::VerifyHashFile(pszHashFileName, Signature, 
				dwCheckFlags, pdwErrorFlags, &he);
		}

		BOOL Initialize(LPCTSTR pszHashFileName, DWORD dwMinFileSize = 0) {
			return CStringHashMap::Initialize(pszHashFileName, Signature, dwMinFileSize);
		}

		BOOL MakeBackup(LPCTSTR pszBackupFileName) {
			return CStringHashMap::MakeBackup(pszBackupFileName);
		}

		BOOL DeleteMapEntry(LPCTSTR pszKey) {
			return CStringHashMap::DeleteMapEntry((LPBYTE) pszKey, lstrlen(pszKey));
		}

		//
		// Lookup, test delete integrity, and delete, atomic
		//

		BOOL LookupAndDelete(LPCTSTR pszKey, T* pHashEntry) {
			return CStringHashMap::LookupAndDelete((LPBYTE)pszKey, lstrlen(pszKey), pHashEntry);
		}
		
	    //
	    // See if the entry is here
	    //
		BOOL Contains(LPCTSTR pszKey) {
			return CStringHashMap::Contains((LPBYTE) pszKey, lstrlen(pszKey));
		}

		//
		// get a map entry
		//
	    BOOL LookupMapEntry(LPCTSTR pszKey, T* pHashEntry) {
			return CStringHashMap::LookupMapEntry((LPBYTE) pszKey, lstrlen(pszKey),
											(CHashEntry *)pHashEntry);
		}

		//
		// update a map entry with new information
		//
		BOOL UpdateMapEntry(LPCTSTR pszKey, const T* pHashEntry) {
			return CStringHashMap::UpdateMapEntry((LPBYTE) pszKey, lstrlen(pszKey),
											pHashEntry);
		}

	    //
		// Insert new intry
		//
		BOOL InsertMapEntry(LPCTSTR pszKey, const T *pHashEntry) {
			return CStringHashMap::InsertMapEntry((LPBYTE) pszKey, lstrlen(pszKey),
											(CHashEntry *)pHashEntry);
		}

		BOOL GetFirstMapEntry(LPTSTR pszKey, PDWORD pcKey, T *pHashEntry, 
			CHashWalkContext *pHashWalkContext) 
		{
			BOOL f = CStringHashMap::GetFirstMapEntry((LPBYTE) pszKey, pcKey, 
				pHashEntry, pHashWalkContext);
			pszKey[*pcKey] = 0;
			return f;
		}

		BOOL GetNextMapEntry(LPTSTR pszKey, PDWORD pcKey, T *pHashEntry,
			CHashWalkContext *pHashWalkContext) 
		{
			BOOL f =  CStringHashMap::GetNextMapEntry((LPBYTE) pszKey, pcKey, 
				pHashEntry, pHashWalkContext);
			if( f ) 
				pszKey[*pcKey] = 0;
			return f;
		}

		//
		// Return total entries in hash map - export from the base class
		//
		CStringHashMap::GetEntryCount;

		// this will have to be defined per template instance		
		static const DWORD Signature;
};

typedef CTSTRHashMap<CSampleHashEntry> CSampleHashMap;

//
// a couple of constants
//
#define MAXKEY RAND_MAX					// maximum number to use for a key
// #define MAXKEY 2
#define MINLEN 1						// minimum amount of data 
#define MAXLEN 512						// maximum amount of data

//
// options given on the command line
//
long g_cInsertThreads = 10;				// number of threads doing inserts
long g_cDeleteThreads = 10;				// number of threads doing deletes
long g_cWalkThreads = 10;				// number of threads doing walks
long g_cInsertIterations = 100;			// number of inserts per thread
long g_cDeleteIterations = 100;			// number of deletes per thread
long g_cWalkIterations = 2;				// number of walks per thread
BOOL g_fVerbose = FALSE;				// should we print everything 
long g_iBackupCount = 0;				// g_cTotalOps to do backup at
long g_nSeed;							// random number seed

//
// this contains information similar to what is in the hash table to be
// able to verify it
//
typedef struct _KEY_DATA {
	CRITICAL_SECTION	cs;
	DWORD				counter;
	DWORD				size;			// 0xffffffff means deleted
} KEY_DATA;

#define KEY_DELETED 0xffffffff

// indexed by key
KEY_DATA keyinfo[MAXKEY];

const DWORD CSampleHashMap::Signature = (DWORD)'CSHM';

//
// this global buffer is used for saving debugging output (which
// is written to stdout when the program exits).
//
// g_cBuffer should always be updated with InterlockedAdd
//
long g_cBuffer;						// the size of the output buffer
char *g_pBuffer;						// the output buffer

//
// operation counts (always updated with InterlockedIncrement)
//
long g_cInserts = 0;
long g_cDeletes = 0;
long g_cUpdates = 0;
long g_cTotalOps = 0;

//
// check some data from the hash file to make sure that it is valid
//
BOOL checkdata(DWORD key, DWORD size, DWORD c, LPBYTE data) {
	DWORD x;

	if (data[0] != (BYTE) (key * c)) 
		return FALSE;
	for (x = 1; x < size; x++) {
		if (data[x] != (BYTE) (data[x - 1] + c % 10)) 
			return FALSE;
	}
	return TRUE;
}

//
// update the information in the keyinfo array
//
void updatekeyinfo(DWORD key, DWORD counter, DWORD size) {
	keyinfo[key].counter = counter;
	keyinfo[key].size = size;
}

#define LOCK(__key__) EnterCriticalSection(&(keyinfo[__key__].cs))
#define UNLOCK(__key__) LeaveCriticalSection(&(keyinfo[__key__].cs))

inline void updatecounter(CSampleHashMap *hm, long *pCounter) {
	InterlockedIncrement(pCounter);
	InterlockedIncrement(&g_cTotalOps);

	if (g_cTotalOps == g_iBackupCount) {
		_VERIFY(hm->MakeBackup("\\testhash.bak"));
	}
}

typedef struct {
	CSampleHashMap  *hm;			// pointer to a hashmap
	DWORD 			iThread;		// thread number
} WORKERARGS;

//
// a thread to enter some randomly generated entries into the hash file
//
DWORD enterkeys(WORKERARGS *pWA) {
	CSampleHashMap *hm = pWA->hm;
	CSampleHashEntry he;
	int i;

	srand(g_nSeed * pWA->iThread);

	for (i = 0; i < g_cInsertIterations; i++) {
		DWORD key = rand() % MAXKEY;
		DWORD size, x;
		char keytext[256];
		BYTE data[MAXLEN], olddata[MAXLEN];
		DWORD c = g_cTotalOps;

		size = key % (MAXLEN - MINLEN) + MINLEN;
		data[0] = (BYTE) (key * c);
		for (x = 1; x < size; x++) data[x] = (BYTE) (data[x - 1] + c % 10);
		_ASSERT(checkdata(key, size, c, data));

		sprintf(keytext, "%i", key);
		LOCK(key);
		if (hm->Contains(keytext)) {
			he.SetBuffer(olddata);
			hm->LookupMapEntry(keytext, &he);

			if (g_fVerbose) {
				char buf[80];
				sprintf(buf, "%8s: update %i:%i:%i -> %i:%i:%i", 
					keytext, he.GetKey(), he.GetCounter(), he.GetSize(),
					key, c, size);
				DWORD i = InterlockedExchangeAdd(&g_cBuffer, strlen(buf) + 1);
				strcpy(g_pBuffer + i, buf);
			}

			he.SetData(c, key, size, data);
			updatekeyinfo(key, c, size);
			hm->UpdateMapEntry(keytext, &he);
			updatecounter(hm, &g_cUpdates);
		} else {
			if (g_fVerbose) {
				char buf[80];
				sprintf(buf, "%8s: insert -> %i:%i:%i", 
					keytext, key, c, size);
				DWORD i = InterlockedExchangeAdd(&g_cBuffer, strlen(buf) + 1);
				strcpy(g_pBuffer + i, buf);
			}
			he.SetData(c, key, size, data);
			updatekeyinfo(key, c, size);
			hm->InsertMapEntry(keytext, &he);
			updatecounter(hm, &g_cInserts);
		}
		UNLOCK(key);
	}
	return 0;
}

//
// a thread to randomly delete entries from the hash file
//
DWORD deletekeys(WORKERARGS *pWA) {
	CSampleHashMap *hm = pWA->hm;
	CSampleHashEntry he;
	int i;

	srand(g_nSeed * pWA->iThread);

	for (i = 0; i < g_cDeleteIterations; i++) {
		int randnum = rand() % MAXKEY;
		char key[256];

		sprintf(key, "%i", randnum);
		LOCK(randnum);
		if (hm->Contains(key)) {
			BYTE data[MAXLEN];

			he.SetBuffer(data);
			updatecounter(hm, &g_cDeletes);
			hm->LookupAndDelete(key, &he);
			updatekeyinfo(randnum, 0, KEY_DELETED);
			_ASSERT(checkdata(he.GetKey(), he.GetSize(), he.GetCounter(), data));
			if (g_fVerbose) {
				char buf[80];
				sprintf(buf, "%8s: delete <- %i:%i:%i", 
					key, he.GetKey(), he.GetCounter(), he.GetSize());
				DWORD i = InterlockedExchangeAdd(&g_cBuffer, strlen(buf) + 1);
				strcpy(g_pBuffer + i, buf);
			}
		}
		UNLOCK(randnum);
	}
	return 0;
}

//
// a thread to constantly walk the hashmap and verify keys
//
DWORD walkkeys(CSampleHashMap *hm) {
	int i;
	
	// sleep a while to wait for things to get put into the map
	Sleep(1000);
	
	for (i = 0; i < g_cWalkIterations; i++) {
		CSampleHashEntry he;
		CHashWalkContext hwc;
		DWORD cKey;
		char pszKey[256];
		BYTE data[MAXLEN];

		he.SetBuffer(data);
		cKey = 256;
		if (hm->GetFirstMapEntry(pszKey, &cKey, &he, &hwc)) {
			do {
#if 0
				// this is a bad check.  its valid for an entry to disappear
				// out from under us while we are walking...
				_ASSERT(hm->LookupMapEntry(pszKey, &he));
#endif
				_ASSERT(checkdata(he.GetKey(), he.GetSize(), he.GetCounter(), data));

				he.SetBuffer(data);
				cKey = 256;
			} while (hm->GetNextMapEntry(pszKey, &cKey, &he, &hwc));
		}
	}

	return 0;
}

//
// a function to dump out all of the keys in the hash file
//
BOOL verifykeys(CSampleHashMap *hm) {
	CSampleHashEntry he;
	BYTE data[MAXLEN];
	char pszKey[256];
	DWORD cKey;
	long cTotalEntries = 0;
	BOOL bNoErrors = TRUE;
	CHashWalkContext hwc;

	he.SetBuffer(data);

	cKey = 256;
	if (hm->GetFirstMapEntry(pszKey, &cKey, &he, &hwc)) {
		do {
			DWORD iKey = atoi(pszKey);

			cTotalEntries++;

			_ASSERT(hm->LookupMapEntry(pszKey, &he));
			_ASSERT(checkdata(he.GetKey(), he.GetSize(), he.GetCounter(), data));

			if (keyinfo[iKey].size == KEY_DELETED) {
				printf("%8i: exists in hashmap, not in memory\n", iKey);
				bNoErrors = FALSE;
			} else if (keyinfo[iKey].counter != he.GetCounter() || 
				keyinfo[iKey].size != he.GetSize())
			{
				printf("%8i: corrupt hkey=%i akey=%i hsize=%i asize=%i hctr=%i, actr=%i checkdata=%c,%c\n", 
					iKey, he.GetKey(), iKey, he.GetSize(), keyinfo[iKey].size, 
					he.GetCounter(), keyinfo[iKey].counter,
					checkdata(he.GetKey(), he.GetSize(), he.GetCounter(), data) 
						? 'T' : 'F',
					checkdata(iKey, keyinfo[iKey].size, keyinfo[iKey].counter, data) 
						? 'T' : 'F');
				bNoErrors = FALSE;
			}
			hm->DeleteMapEntry(pszKey);
			keyinfo[iKey].size = KEY_DELETED;

			cKey = 256;
		} while (hm->GetNextMapEntry(pszKey, &cKey, &he, &hwc));
	}

	if (cTotalEntries != g_cInserts - g_cDeletes) {
		bNoErrors = FALSE;
		printf("entries (%lu) != inserts (%lu) - deletes (%lu)\n", 
			cTotalEntries, g_cInserts, g_cDeletes);
	}

	for (int i = 0; i < MAXKEY; i++) {
		char key[256];

		sprintf(key, "%i", i);

		if (hm->Contains(key)) {
			bNoErrors = FALSE;
			printf("%8i: isn't deleted, it should be\n", i);
		} else {
			if (keyinfo[i].size != KEY_DELETED)	{
				printf("%8i: exists in memory, not in hashmap\n", i);
				bNoErrors = FALSE;
			}
		}
	}

	return bNoErrors;
}

#if 0
void dumphelp(void) {
	printf("usage: testhash.exe [-v] [-s <random seed>]\n"
	    "    [-it <number of insert threads>] [-ii <insert iterations per thread>]\n"
		"    [-dt <number of delete threads>] [-di <delete iterations per thread>]\n"
		"    [-wt <number of walk threads>] [-wi <walks iterations per thread>]\n"
		"    [-b <operations to do a backup at>]\n");
	exit(0);
}
#endif

void dumphelp(void) {
	printf("usage: testhash.exe [<ini file>] [<ini section name>]\n"
		"  INI file keys (in section [testhash]):\n"
		"    NumInsertThreads (default = %i)\n"
		"    NumDeleteThreads (default = %i)\n"
		"    NumWalkThreads (default = %i)\n"
		"    NumInsertIterations (default = %i)\n"
		"    NumDeleteIterations (default = %i)\n"
		"    NumWalkIterations (default = %i)\n"
		"    Verbose (default = %i)\n"
		"    BackupCount (default = %i)\n"
		"    RandomSeed (default = GetTickCount())\n",
		g_cInsertThreads,
		g_cDeleteThreads,
		g_cWalkThreads,
		g_cInsertIterations,
		g_cDeleteIterations,
		g_cWalkIterations,
		g_fVerbose,
		g_iBackupCount,
		g_nSeed);

	exit(1);
}

#if 0
void parsecommandline(int argc, char **argv) {
	while (argc > 0) {
		if (!(argv[0][0] == '-' || argv[0][0] == '/')) dumphelp();
		if (strcmp(argv[0] + 1, "v") == 0) {
			g_fVerbose = TRUE;
		} else if (strcmp(argv[0] + 1, "it") == 0) {
			if (argc == 1) dumphelp();
			g_cInsertThreads = atoi(argv[1]);
			argv++; argc--;
		} else if (strcmp(argv[0] + 1, "dt") == 0) {
			if (argc == 1) dumphelp();
			g_cDeleteThreads = atoi(argv[1]);
			argv++; argc--;
		} else if (strcmp(argv[0] + 1, "wt") == 0) {
			if (argc == 1) dumphelp();
			g_cWalkThreads = atoi(argv[1]);
			argv++; argc--;
		} else if (strcmp(argv[0] + 1, "ii") == 0) {
			if (argc == 1) dumphelp();
			g_cInsertIterations = atoi(argv[1]);
			argv++; argc--;
		} else if (strcmp(argv[0] + 1, "di") == 0) {
			if (argc == 1) dumphelp();
			g_cDeleteIterations = atoi(argv[1]);
			argv++; argc--;
		} else if (strcmp(argv[0] + 1, "wi") == 0) {
			if (argc == 1) dumphelp();
			g_cWalkIterations = atoi(argv[1]);
			argv++; argc--;
		} else if (strcmp(argv[0] + 1, "b") == 0) {
			if (argc == 1) dumphelp();
			g_iBackupCount = atoi(argv[1]);
			argv++; argc--;
		} else if (strcmp(argv[0] + 1, "s") == 0) {
			if (argc == 1) dumphelp();
			g_nSeed = atoi(argv[1]);
			argv++; argc--;
		} else {
			dumphelp();
		}
		argv++; argc--;
	}
}
#endif

#define INI_KEY_VERBOSE "verbose"
#define INI_KEY_INSERT_THREADS "NumInsertThreads"
#define INI_KEY_DELETE_THREADS "NumDeleteThreads"
#define INI_KEY_WALK_THREADS "NumWalkThreads"
#define INI_KEY_INSERT_ITERATIONS "NumInsertIterations"
#define INI_KEY_DELETE_ITERATIONS "NumDeleteIterations"
#define INI_KEY_WALK_ITERATIONS "NumWalkIterations"
#define INI_KEY_BACKUP_COUNT "BackupCount"
#define INI_KEY_SEED "RandomSeed"

char g_szDefaultSectionName[] = "testhash";
char *g_szSectionName = g_szDefaultSectionName;

int GetINIDWord(char *szINIFile, char *szKey, DWORD dwDefault) {
	char szBuf[MAX_PATH];

	GetPrivateProfileString(g_szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

void parsecommandline(int argc, char **argv) {
	if (argc == 0) return;							// use defaults
	if (strcmp(argv[0], "/help") == 0) dumphelp(); 	// show help

	char *szINIFile = argv[0];
	if (argc == 2) g_szSectionName = argv[1];

	g_fVerbose = GetINIDWord(szINIFile, INI_KEY_VERBOSE, 0);
	g_cDeleteThreads = GetINIDWord(szINIFile, INI_KEY_DELETE_THREADS, g_cDeleteThreads);
	g_cInsertThreads = GetINIDWord(szINIFile, INI_KEY_INSERT_THREADS, g_cInsertThreads);
	g_cWalkThreads = GetINIDWord(szINIFile, INI_KEY_WALK_THREADS, g_cWalkThreads);
	g_cDeleteIterations = GetINIDWord(szINIFile, INI_KEY_DELETE_ITERATIONS, g_cDeleteIterations);
	g_cInsertIterations = GetINIDWord(szINIFile, INI_KEY_INSERT_ITERATIONS, g_cInsertIterations);
	g_cWalkIterations = GetINIDWord(szINIFile, INI_KEY_WALK_ITERATIONS, g_cWalkIterations);
	g_iBackupCount = GetINIDWord(szINIFile, INI_KEY_BACKUP_COUNT, g_iBackupCount);
	g_nSeed = GetINIDWord(szINIFile, INI_KEY_SEED, g_nSeed);
}

//
// start a bunch of threads that are entering keys and a bunch that
// are deleting them.
//
int __cdecl main(int argc, char **argv) {
	CSampleHashMap *hm;
	HANDLE hThread[256];
	DWORD tid;
	int i, e, d, w;
	long cMaxOps;
	WORKERARGS *rgWA;
	BOOL bNoErrors = TRUE;

	InitAsyncTrace();

	g_nSeed = GetTickCount();

	parsecommandline(argc - 1, argv + 1);

	cMaxOps = g_cInsertThreads * g_cInsertIterations + 
		g_cDeleteThreads * g_cDeleteIterations;

	printf("using random number seed %li\n", g_nSeed);

	hm = new CSampleHashMap;
	if (!hm->Initialize("\\testhash.hsh")) {
		printf("couldn't initialize hashmap, ec = %lu\n", GetLastError());
		return 1;
	}

	printf("initializing critical sections\n");
	for (i = 0; i < MAXKEY; i++) {
		InitializeCriticalSection(&(keyinfo[i].cs));
		keyinfo[i].size = KEY_DELETED;
	}

	if (g_fVerbose) {
		g_cBuffer = 0;
		g_pBuffer = (char *) GlobalAlloc(0, 80 * cMaxOps);

		if (g_pBuffer == NULL) {
			printf("couldn't allocate memory for output buffer, disabling"
				" verbose mode");
			g_fVerbose = FALSE;
		}
	}

	rgWA = new WORKERARGS[g_cInsertThreads + g_cDeleteThreads];
	if (rgWA == NULL) {
		printf("out of memory\n");
		return 1;
	}

	printf("starting %i insert threads (%i inserts each)\n", 
		g_cInsertThreads, g_cInsertIterations);
	printf("     and %i delete threads (%i deletes each)\n", 
		g_cDeleteThreads, g_cDeleteIterations);
	printf("     and %i walk threads (%i walks each)\n", 
		g_cWalkThreads, g_cWalkIterations);

	e = d = w = 0;
	while (e+d+w < g_cInsertThreads+g_cDeleteThreads+g_cWalkThreads) {
		if (e < g_cInsertThreads) {
			WORKERARGS *pWA = &rgWA[e + d];
			pWA->iThread = e + d + w;
			pWA->hm = hm;
			hThread[e + d + w] = CreateThread(NULL, 0, 
				(LPTHREAD_START_ROUTINE) enterkeys, (LPVOID) pWA, 0, &tid);
			e++;
		}
		if (d < g_cDeleteThreads) {
			WORKERARGS *pWA = &rgWA[e + d];
			pWA->iThread = e + d + w;
			pWA->hm = hm;
			hThread[e + d + w] = CreateThread(NULL, 0, 
				(LPTHREAD_START_ROUTINE) deletekeys, (LPVOID) pWA, 0, &tid);
			d++;
		}
		if (w < g_cWalkThreads) {
			hThread[e + d + w] = CreateThread(NULL, 0, 
				(LPTHREAD_START_ROUTINE) walkkeys, (LPVOID) hm, 0, &tid);
			w++;
		}	
	}

	WaitForMultipleObjects(e + d + w, hThread, TRUE, INFINITE);

	if (g_fVerbose) {
		printf("%s", g_pBuffer);
	}

	printf("\nworker threads complete\n");
	printf("%lu inserts + %lu updates + %lu deletes = %lu operations\n",
		g_cInserts, g_cUpdates, g_cDeletes, g_cTotalOps);

	printf("verifying and deleting all keys (%lu)\n", g_cInserts - g_cDeletes);
	if (verifykeys(hm)) {
		printf("no errors\n");
	} else {
		bNoErrors = FALSE;
		printf("errors found\n");
	}

	if (g_iBackupCount > 0) {
		printf("\nexaming contents of backup\n");

		BOOL bNoBackupErrors = TRUE;
	
		// first do a verify to see if its valid
		DWORD dwErrorFlags;
		if (!CSampleHashMap::VerifyHashFile("\\testhash.bak", HASH_VFLAG_ALL, &dwErrorFlags)) {
			printf("VerifyHashFile() failed, error flags = %x\n", dwErrorFlags);
			bNoErrors = FALSE;
			bNoBackupErrors = FALSE;
		}
	
		CSampleHashMap *hmbackup;

		hmbackup = new CSampleHashMap;
		if (!hmbackup->Initialize("\\testhash.bak")) {
			printf("couldn't initialize backup hashmap, ec = %lu\n", GetLastError());
			return 1;
		}
	
		CSampleHashEntry he;
		BYTE data[MAXLEN];
		char pszKey[256];
		DWORD cKey;
		int cBackup = 0;
		CHashWalkContext hwc;
	
		he.SetBuffer(data);
	
		cKey = 256;
		if (hmbackup->GetFirstMapEntry(pszKey, &cKey, &he, &hwc)) {
			do {
				cBackup++;
				if (!checkdata(he.GetKey(), he.GetSize(), he.GetCounter(), data)) {
					printf("%8i: failed checkdata\n", he.GetKey());
					bNoErrors = FALSE;
					bNoBackupErrors = FALSE;
				}
				cKey = 256;
			} while (hmbackup->GetNextMapEntry(pszKey, &cKey, &he, &hwc));
		}

		printf("there were %i keys in the backup file\n", cBackup);
		printf("%s errors in backup\n", (bNoBackupErrors) ? "no" : "there were");
	}

	TermAsyncTrace();

	// return 0 on success, otherwise 1
	return (!bNoErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cfactory.h ===
//+-------------------------------------------------------------------------
//
//  Class:      CMimeFilterCF
//
//  Purpose:    Class factory for Html filter class
//
//--------------------------------------------------------------------------

class CMimeFilterCF : public IClassFactory
{
public:

    CMimeFilterCF();

    virtual  HRESULT STDMETHODCALLTYPE  QueryInterface( REFIID riid,
                                                      void  ** ppvObject);

    virtual  ULONG STDMETHODCALLTYPE  AddRef();

    virtual  ULONG STDMETHODCALLTYPE  Release();

    virtual  HRESULT STDMETHODCALLTYPE  CreateInstance( IUnknown * pUnkOuter,
                                                      REFIID riid, void  * * ppvObject );

    virtual  HRESULT STDMETHODCALLTYPE  LockServer( BOOL fLock );

protected:

    friend HRESULT STDMETHODCALLTYPE DllGetClassObject( REFCLSID cid,
                                                      REFIID iid, void** ppvObj );
    virtual ~CMimeFilterCF();

    long _uRefs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmf.cpp ===
#define DEFINE_STRCONST
#define INITGUID
#include "mimefilt.h"
#include "wchar.h"

// global reference count
long gulcInstances = 0;

//
// global temp file name key
//

DWORD CMimeFilter::m_dwTempFileNameKey = 0;

// file extensions
WCHAR g_wszNewsExt[] = OLESTR(".nws");
WCHAR g_wszMailExt[] = OLESTR(".eml");
char g_szNewsExt[] = {".nws"};
char g_szMailExt[] = {".eml"};

// article id header name
WCHAR g_wszArticleId[] = OLESTR("X-Article-ID");

PROPSPEC g_psExtraHeaders[] = { \
{PRSPEC_PROPID,PID_HDR_NEWSGROUP},
{PRSPEC_PROPID,PID_HDR_ARTICLEID},
{PRSPEC_PROPID,PID_ATT_RECVTIME},
{0,0}
};

char g_State[][32] = { \
    {"STATE_INIT"},
    {"STATE_START"},
    {"STATE_END"},
    {"STATE_HEADER"},
    {"STATE_POST_HEADER"},
    {"STATE_BODY"},
    {"STATE_EMBEDDING"},
    {"STATE_ERROR"}
};

SCODE LoadIFilterA( char* pszFileName, IUnknown * pUnkOuter, void ** ppIUnk );
SCODE WriteStreamToFile(IStream* pStream, char* pszFileName);
BOOL GetFileClsid(char* pszAttFile,CLSID* pclsid);
void FreePropVariant(PROPVARIANT* pProp);
STDMETHODIMP AstrToWstr(char* pstr,WCHAR** ppwstr,UINT codepage);
ULONG FnameToArticleIdW(WCHAR *pwszPath);
BOOL IsMailOrNewsFile(char *pszPath);

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::CMimeFilter
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CMimeFilter::CMimeFilter(IUnknown* pUnkOuter) 
{
    EnterMethod("CMimeFilter::CMimeFilter");

    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pCImpIPersistFile = NULL;
    m_pCImpIPersistStream = NULL;
    m_ulChunkID = 0;
    m_locale = GetSystemDefaultLCID();
    m_fInitFlags = 0;

    m_pwszFileName  = NULL;
    m_pstmFile      = NULL;
    m_pMessageTree  = NULL;
    m_pMsgPropSet   = NULL;
    m_pHeaderEnum   = NULL;
    m_pHeaderProp   = NULL; 
    m_hBody         = 0;
    m_pstmBody      = NULL;
    m_cpiBody       = 0;
    m_fFirstAlt     = FALSE;
    m_pTextBuf      = NULL;
    m_cbBufSize     = 0;
    m_fRetrieved    = FALSE;
    m_pszEmbeddedFile   = NULL;
    m_pEmbeddedFilter   = NULL;
    m_fXRefFound        = FALSE;
    m_pszNewsGroups     = NULL;
    m_State = STATE_INIT;
    StateTrace((LPARAM)this,"New state %s",g_State[m_State]);

    m_pMalloc = NULL;
    m_pMimeIntl = NULL;

    // increment the global ref count
    InterlockedIncrement( &gulcInstances );
    LeaveMethod();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::~CMimeFilter
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CMimeFilter::~CMimeFilter()
{
    EnterMethod("CMimeFilter::~CMimeFilter");

    if( m_pCImpIPersistFile != NULL )
        delete m_pCImpIPersistFile;
    if( m_pCImpIPersistStream != NULL )
        delete m_pCImpIPersistStream;
    if( m_pwszFileName != NULL )
        delete m_pwszFileName;
    if( m_pstmFile != NULL )
        m_pstmFile->Release();
    if( m_pMessageTree != NULL )
        m_pMessageTree->Release();
    if( m_pMsgPropSet != NULL )
        m_pMsgPropSet->Release();
    if( m_pHeaderEnum != NULL )
        m_pHeaderEnum->Release();
    if( m_pHeaderProp != NULL && m_fRetrieved == FALSE )
        FreePropVariant(m_pHeaderProp);
    if( m_pstmBody != NULL )
        m_pstmBody->Release();
    if( m_pTextBuf != NULL )
        delete m_pTextBuf;
    if( m_pEmbeddedFilter != NULL )
        m_pEmbeddedFilter->Release();
    if( m_pszEmbeddedFile != NULL )
    {
        if( *m_pszEmbeddedFile != 0 )
            DeleteFile(m_pszEmbeddedFile);
        delete m_pszEmbeddedFile;
    }
    if( m_pszNewsGroups != NULL )
        delete m_pszNewsGroups;
    if( m_pMalloc != NULL )
        m_pMalloc->Release();
    if( m_pMimeIntl != NULL )
        m_pMimeIntl->Release();

    // decrement the global ref count
    InterlockedDecrement( &gulcInstances );

    LeaveMethod();
}
//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::HRInit
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [pUnkOuter] -- controlling outer IUnknown
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CMimeFilter::HRInitObject()
{
    EnterMethod("CMimeFilter::FInit");
    LPUNKNOWN       pIUnknown=(LPUNKNOWN)this;

    if (NULL!=m_pUnkOuter)
        pIUnknown=m_pUnkOuter;

    // create IPersistStream interface
    if( !(m_pCImpIPersistFile = new CImpIPersistFile(this, pIUnknown)) )
        return E_OUTOFMEMORY;

    // create IPersistStream interface
    if( !(m_pCImpIPersistStream = new CImpIPersistStream(this, pIUnknown)) )
        return E_OUTOFMEMORY;
    
    LeaveMethod();
    return NOERROR;
}
//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CMimeFilter::QueryInterface( REFIID riid,
                                                          void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IFilter      = 89BCB740-6119-101A-BCB7-00DD010655AF
    // IID_IPersist     = 0000010c-0000-0000-C000-000000000046
    // IID_IPersistFile = 0000010b-0000-0000-C000-000000000046
    // IID_IPersistFile = 00000109-0000-0000-C000-000000000046
    //                          --
    //                           |
    //                           +--- Unique!

    _ASSERT( (IID_IUnknown.Data1        & 0x000000FF) == 0x00 );
    _ASSERT( (IID_IFilter.Data1         & 0x000000FF) == 0x40 );
    _ASSERT( (IID_IPersist.Data1        & 0x000000FF) == 0x0c );
    _ASSERT( (IID_IPersistFile.Data1    & 0x000000FF) == 0x0b );
    _ASSERT( (IID_IPersistStream.Data1  & 0x000000FF) == 0x09 );

    IUnknown *pUnkTemp = 0;
    HRESULT hr = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( IID_IUnknown == riid )
            pUnkTemp = (IUnknown *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x40:
        if ( IID_IFilter == riid )
            pUnkTemp = (IUnknown *)(IFilter *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x0c:
        if ( IID_IPersist == riid )
            pUnkTemp = (IUnknown *)(IPersist *)m_pCImpIPersistFile;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x0b:
        if ( IID_IPersistFile == riid )
            pUnkTemp = (IUnknown *)(IPersistFile *)m_pCImpIPersistFile;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x09:
        if ( IID_IPersistStream == riid )
            pUnkTemp = (IUnknown *)(IPersistStream *)m_pCImpIPersistStream;
        else
            hr = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        hr = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilter::AddRef()
{
    return InterlockedIncrement( &m_cRef );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilter::Release()
{
    unsigned long uTmp = InterlockedDecrement( &m_cRef );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}




//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::Init
//
//  Synopsis:   Initializes instance of NNTP filter
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array pAttributes
//              [pAttributes] -- array of attributes
//              [pFlags]      -- Set to 0 version 1
//
//  Note:   Since for now we only need  one type of filtering for news
//          articles we can disregard the arguments.
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilter::Init( ULONG grfFlags,
        ULONG cAttributes, FULLPROPSPEC const * pAttributes, ULONG * pFlags )
{
    EnterMethod("CMimeFilter::Init");

    HRESULT hr = S_OK ;

    DebugTrace((LPARAM)this,"grfFlags = 0x%08x, cAttributes = %d",grfFlags,cAttributes);

    m_fInitFlags = grfFlags;

    // get MimeOLE global allocator interface
    if( m_pMalloc == NULL )
    {
        hr = CoCreateInstance(CLSID_IMimeAllocator, NULL, CLSCTX_INPROC_SERVER, 
            IID_IMimeAllocator, (LPVOID *)&m_pMalloc);
        if (FAILED(hr))
        {
            TraceHR(hr);
            goto Exit;
        }
    }

    // do we have an existing IMimeMessageTree
    if( m_pMessageTree != NULL )
    {
        if( m_pHeaderProp != NULL && m_fRetrieved == FALSE )
            FreePropVariant(m_pHeaderProp);
        m_pHeaderProp = NULL;
        if( m_pHeaderEnum != NULL )
            m_pHeaderEnum->Release();
        m_pHeaderEnum = NULL;
        if( m_pMsgPropSet != NULL )
            m_pMsgPropSet->Release();
        m_pMsgPropSet = NULL;

        // yes, reset it's state
        hr = m_pMessageTree->InitNew();

    }
    else
    {
        // no, create a new one
        hr = CoCreateInstance(CLSID_IMimeMessageTree, NULL, CLSCTX_INPROC_SERVER, 
            IID_IMimeMessageTree, (LPVOID *)&m_pMessageTree);
    }
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // load message file into message object
    hr = m_pMessageTree->Load(m_pstmFile);
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // reset chunk id
    m_ulChunkID = 0;

    // set state
    m_State     = STATE_START;
    StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
    m_fFirstAlt = FALSE;
    m_fRetrieved    = FALSE;
    m_fXRefFound    = FALSE;
    m_SpecialProp   = PROP_NEWSGROUP;

	if( pFlags != NULL )
		*pFlags = 0;

Exit:
    if( FAILED(hr) )
    {
        m_State = STATE_ERROR;
        StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
    }


    LeaveMethod();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in ppStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilter::GetChunk( STAT_CHUNK * pStat )
{
    EnterMethod("CMimeFilter::GetChunk");
    HRESULT hr = S_OK;
    BOOL    fForceBreak = FALSE;

    // common pStat information
    pStat->locale         = GetLocale() ;
    pStat->cwcStartSource = 0 ;
    pStat->cwcLenSource   = 0 ;

    while( TRUE )
    {
        // get started
        if( m_State == STATE_START )
        {
            HBODY hBody = 0;

            // get m_hBody for IBL_ROOT
            hr = m_pMessageTree->GetBody(IBL_ROOT,NULL,&hBody);
            if (FAILED(hr))
            {
                TraceHR(hr);
                break;
            }

            // get IMimePropertySet interface
            hr = m_pMessageTree->BindToObject(hBody,IID_IMimePropertySet,(void**)&m_pMsgPropSet);
            if (FAILED(hr))
            {
                TraceHR(hr);
                break;
            }

            // set new state
            if( m_fInitFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES )
            {
                // get header enumerator
                hr = m_pMsgPropSet->EnumProps(NULL,&m_pHeaderEnum);
                if (FAILED(hr))
                {
                    TraceHR(hr);
                    break;
                }

                // caller wants properties and text
                m_State = STATE_HEADER;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
            }
            else
            {
                // caller want text only
                m_State = STATE_BODY;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
            }
        }

        // process headers
        else if( m_State == STATE_HEADER )
        {
            ENUMPROPERTY rgHeaderRow;
            
            // free last prop variant if necessary
            if( m_fRetrieved == FALSE && m_pHeaderProp != NULL )
            {
                FreePropVariant(m_pHeaderProp);
                m_pHeaderProp = NULL;
            }

            // get the next header line
            hr = m_pHeaderEnum->Next(1,&rgHeaderRow,NULL);
            // if got the next header line
            if( hr == S_OK )
            {
                // get the header data
				static char szEmptyString[] = "";
                PROPVARIANT varProp;
                varProp.vt = VT_LPSTR;
                hr = m_pMsgPropSet->GetProp(rgHeaderRow.pszName,0,&varProp);
				// workaround for Bcc: problem
				if (hr == MIME_E_NOT_FOUND) {

					varProp.pszVal = szEmptyString;
					varProp.vt = VT_LPSTR;
					hr = S_OK;
				}

                if( FAILED(hr) )
                {
                    TraceHR(hr);
                    break;
                }

                // clear retrieved flag
                m_fRetrieved = FALSE;

                // header specific pStat information
                pStat->flags                       = CHUNK_VALUE;
                pStat->breakType                   = CHUNK_EOP;
                
                // map header to property id or lpwstr
                hr = MapHeaderProperty(&rgHeaderRow, varProp.pszVal, &pStat->attribute);

                if( varProp.pszVal != NULL && varProp.pszVal != szEmptyString )
                    m_pMalloc->PropVariantClear(&varProp);

                // free header row
                _VERIFY(SUCCEEDED(m_pMalloc->FreeEnumPropertyArray(
                    1,&rgHeaderRow,FALSE)));
                break;
            }
            // if no more headers
            else if( hr == S_FALSE )
            {
                // release enumerator
                m_pHeaderEnum->Release();
                m_pHeaderEnum = NULL;

                // set state to post header processing
                m_State = STATE_POST_HEADER;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
            }
            // an error occured
            else
            {
                TraceHR(hr);
                break;
            }
        }

        // process extra headers
        else if( m_State == STATE_POST_HEADER )
        {
            // free last prop variant if necessary
            if( m_fRetrieved == FALSE && m_pHeaderProp != NULL )
            {
                FreePropVariant(m_pHeaderProp);
                m_pHeaderProp = NULL;
            }

            // are we at the end of special props?
            if( m_SpecialProp == PROP_END )
            {
                // set state to body
                m_State = STATE_BODY;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
            }
            else
            {
                // clear retrieved flag
                m_fRetrieved = FALSE;

                // map special props
                hr = MapSpecialProperty(&pStat->attribute);
                m_SpecialProp++;
                if( SUCCEEDED(hr) && hr != S_FALSE )
                    break;
            }
        }

        // process body
        else if( m_State == STATE_BODY )
        {
            // is there an existing body part pStream
            if( m_pstmBody != NULL )
            {
                // free last body part
                m_pstmBody->Release();
                m_pstmBody = NULL;
            }

            // get next body part
            hr = GetNextBodyPart();

            // if got the next body part
            if( hr == S_OK )
            {
                // is this body part an embedding
                if( m_pEmbeddedFilter != NULL )
                {
                    // set state to embedding
                    m_State = STATE_EMBEDDING;
                    StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
                    fForceBreak = TRUE;
                }
                else
                {
                    // clear retrieved flag
                    m_fRetrieved = FALSE;

                    // body specific pStat information
                    pStat->flags                       = CHUNK_TEXT;
                    pStat->breakType                   = CHUNK_NO_BREAK;
                    pStat->attribute.guidPropSet       = CLSID_Storage;
                    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
                    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;

                    break;
                }
            }
            // if no more body parts
            else if( hr == MIME_E_NOT_FOUND )
            {
                // set state to end
                m_State = STATE_END;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);

                // return no more body chunks
                hr = FILTER_E_END_OF_CHUNKS;
                break;
            }
            // an error occured
            else
            {
                TraceHR(hr);
                break;
            }
        }

        // process embedded objects
        else if( m_State == STATE_EMBEDDING )
        {
            // get the chunks from the embedded object
            _ASSERT(m_pEmbeddedFilter != NULL);
            hr = m_pEmbeddedFilter->GetChunk(pStat);
            if( FAILED(hr) )
            {
                // free embedding's IFilter
                m_pEmbeddedFilter->Release();
                m_pEmbeddedFilter = NULL;

                // delete the file
                if( m_pszEmbeddedFile != NULL && *m_pszEmbeddedFile != 0 )
                {
                    _VERIFY(DeleteFile(m_pszEmbeddedFile));
                    *m_pszEmbeddedFile = 0;
                }

                // back to processing body parts
                m_State = STATE_BODY;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
                continue;
            }
            // This flag is set for the first Chunk after we load an embedded filter
            // to make sure there is a break for different body parts
            if (fForceBreak&&pStat->breakType==CHUNK_NO_BREAK)
                pStat->breakType = CHUNK_EOP;
            fForceBreak = FALSE;
            // got a chunk
            break;
        }

        // handle error state
        else if( m_State == STATE_ERROR )
        {
            // we shouldn't get here!
            _ASSERT(hr != S_OK);
            break;
        }

        // handle done state
        else if( m_State == STATE_END )
        {
            hr = FILTER_E_END_OF_CHUNKS;
            break;
        }
    }

    if( FAILED(hr) && hr != FILTER_E_END_OF_CHUNKS )
    {
        m_State = STATE_ERROR;
        StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
    }
    else
    {
        // get chunk id
        pStat->idChunk        = GetNextChunkId();
        pStat->idChunkSource  = pStat->idChunk;
    }


    LeaveMethod();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilter::GetText( ULONG * pcwcOutput, WCHAR * awcOutput )
{
    EnterMethod("CMimeFilter::GetText");
    HRESULT hr = S_OK;
	DWORD cch;
    
    switch( m_State )
    {
    case STATE_BODY:
        // current chunk is body
        if( m_fRetrieved )
        {
            hr = FILTER_E_NO_MORE_TEXT;
            break;
        }

        // read as much as we can from the stream
        hr = m_pstmBody->Read((void*)awcOutput,*pcwcOutput,pcwcOutput);
        if( FAILED(hr) )
        {
            TraceHR(hr);
            break;
        }

        // if no more text
        if( *pcwcOutput == 0 )
        {
            // set data retrieved flag
            m_fRetrieved = TRUE;

            // return no more text
            hr = FILTER_E_NO_MORE_TEXT;
            break;
        }

        break;

    case STATE_EMBEDDING:
        // current chunk is an embedded object
        _ASSERT(m_pEmbeddedFilter != NULL);
        hr = m_pEmbeddedFilter->GetText(pcwcOutput,awcOutput);
        break;
    default:
        // shouldn't get here
        hr = FILTER_E_NO_TEXT;
        break;
    }

    LeaveMethod();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMimeFilter::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//----------------------------------------------------------------------------

STDMETHODIMP CMimeFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    EnterMethod("CMimeFilter::GetValue");
    HRESULT hr = S_OK;
    ULONG   cb = 0;
    char*   pszSrc = NULL;

    if( ppPropValue == NULL )
        return E_INVALIDARG;

    switch( m_State )
    {
    case STATE_HEADER:
    case STATE_POST_HEADER:
        // has current chunk already been retrieved
        if( m_fRetrieved || m_pHeaderProp == NULL )
        {
            hr = FILTER_E_NO_MORE_VALUES;
            TraceHR(hr);
            break;
        }

        // use pProp allocated in GetChunk()
        *ppPropValue = m_pHeaderProp;

        // set data retrieved flag
        m_fRetrieved = TRUE;
		m_pHeaderProp = NULL;
        break;
    case STATE_EMBEDDING:
        // current chunk is an embedded object
        _ASSERT(m_pEmbeddedFilter != NULL);
        hr = m_pEmbeddedFilter->GetValue(ppPropValue);
        break;
    default:
        // shouldn't get here
        hr = FILTER_E_NO_VALUES;
        break;
    }

    if( FAILED(hr) )
    {
        if( *ppPropValue != NULL )
        {
            if( (*ppPropValue)->pwszVal != NULL )
                CoTaskMemFree((*ppPropValue)->pwszVal);
            CoTaskMemFree(*ppPropValue);
        }
        *ppPropValue = NULL;
    }

    LeaveMethod();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::GetNextChunkId
//
//  Synopsis:   Return a brand new chunk id. Chunk id overflow is very unlikely.
//
//--------------------------------------------------------------------------

ULONG CMimeFilter::GetNextChunkId()
{
    EnterMethod("CMimeFilter::GetNextChunkId");
    _ASSERT( m_ulChunkID != 0xFFFFFFFF );

    LeaveMethod();
    return ++m_ulChunkID;
}


// This method gets the next body part to be indexed.
// The MIME message is represented as a tree with
// interior nodes and leaf nodes. Only leaf nodes 
// contain content that may be indexed. Mulitpart
// Content-Type represent interior nodes, while 
// non-multipart represent leaf nodes. We traverse
// the tree using the "preorder" method. The current
// position in the tree is represented by the current
// body (m_hBody). From the current body we can get
// the next body at the same level in the tree. If 
// the body is multipart then we can get its first 
// child. If there are no more children or leaf nodes
// we backup and go down the next branch. When all
// leaves have been visited, body processing is 
// finished.
//
//  HEADER
//  IBL_ROOT, type=multipart/mixed
//      +---Child1, type=multipart/alternative
//      |       +---Child1, type=text/plain     ; process this body part
//      |       +---Child2, type=text/html      ; skip this body part
//      +---Child2, type=application/octet-stream
//
STDMETHODIMP CMimeFilter::GetNextBodyPart()
{
    EnterMethod("CMimeFilter::GetNextBodyPart");
    HRESULT         hr = S_OK;
    IMimeBody*      pBody = NULL;
    HBODY           hBodyNext = 0;

    // The outter loop gets the next child
    // or backs up a level if necessary.
    while(hr == S_OK)
    {
        // Get the next body part at this level in the tree. 
        // If no current body part then get the root body part.
        if( m_hBody == 0 )
        {
            // get the message root body
            hr = m_pMessageTree->GetBody(IBL_ROOT,NULL,&m_hBody);
        }
        else
        {
            // Special case: 
            // If the last body part was the first alternative
            // of a multipart/alternative body part then need
            // to get the parent of the current body part. 
            // See sample tree above.
            if( m_fFirstAlt )
            {
                m_fFirstAlt = FALSE;
                hr = m_pMessageTree->GetBody(IBL_PARENT, m_hBody, &m_hBody);
                if( hr == MIME_E_NOT_FOUND )
                {
                    // we've hit the top of the tree
                    // and there are no more children
                    break;
                }
            }

            // get the next body part
            hr = m_pMessageTree->GetBody(IBL_NEXT, m_hBody, &hBodyNext);
            if( hr == S_OK && hBodyNext != 0 )
                m_hBody = hBodyNext;
        }

        // did we find another body part at this level in the tree
        if( hr == MIME_E_NOT_FOUND )
        {
            // no more body parts at this level so current body part's parent
            hr = m_pMessageTree->GetBody(IBL_PARENT, m_hBody, &m_hBody);
            if( hr == MIME_E_NOT_FOUND )
            {
                // we've hit the top of the tree
                // which means we've visited all 
                // nodes in the tree.
                break;
            }

            // get the next child of the new parent
            continue;
        }
        else if( FAILED(hr) )
        {
            TraceHR(hr);
            break;
        }

Again:
        // is multipart body part
        if( S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_MULTIPART, NULL) )
        {
            // is it multipart/alternative
            m_fFirstAlt = (S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_MULTIPART, 
                STR_SUB_ALTERNATIVE));

            // get first child and try again
            hr = m_pMessageTree->GetBody(IBL_FIRST, m_hBody, &m_hBody);
            if(FAILED(hr))
            {
                // a multipart body part must always contain a child
                _ASSERT(FALSE);

                // unable to get first child
                TraceHR(hr);
                break;
            }

            // we have the first part of a multipart
            // body and we need to repeat the above 
            // logic
            goto Again;
        }
        // skip these binary types
        else if(    ( S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_IMAGE, NULL)) || 
                    ( S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_AUDIO, NULL)) ||
                    ( S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_VIDEO, NULL)) ) 
        {
            continue;
        }
        // every other type
        else
        {
            // application, message, and all other types
            // treat as embedding
            hr = BindEmbeddedObjectToIFilter(m_hBody);
            if(FAILED(hr))
            {
                // could not bind embedded object to IFilter
                // rather than aborting we just continue
                // with the next body part
                hr = S_OK;
                continue;
            }
            break;
        }
    }

    // release open pBody
    if( pBody != NULL )
    {
        pBody->Release();
        pBody = NULL;
    }
    LeaveMethod();
    return hr;
}

STDMETHODIMP CMimeFilter::MapHeaderProperty(ENUMPROPERTY* pHeaderRow, char* pszData, FULLPROPSPEC* pProp)
{
    EnterMethod("CMimeFilter::MapHeaderProperty");
    HRESULT hr = NOERROR;

    // alloc prop variant
    m_pHeaderProp = (PROPVARIANT*) CoTaskMemAlloc (sizeof (PROPVARIANT));
    if( m_pHeaderProp == NULL )
    {
        hr = E_OUTOFMEMORY;
        TraceHR(hr);
        return hr;
    }

    // set prop value type
    m_pHeaderProp->vt = VT_LPWSTR;
    m_pHeaderProp->pwszVal = NULL;

    // set propset guid
    pProp->guidPropSet = CLSID_NNTP_SummaryInformation;

    // default to kind to prop id
    pProp->psProperty.ulKind = PRSPEC_PROPID;
    pProp->psProperty.propid = 0;
    pProp->psProperty.lpwstr = NULL;

    if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_NEWSGROUPS) )
    {
        // we need to make a copy of the newsgroup line just
        // incase we don't get a XRef line.
        int nLen = lstrlen(pszData);
        if( m_pszNewsGroups != NULL )
            delete m_pszNewsGroups;

        m_pszNewsGroups = new char[nLen+1];
        if( m_pszNewsGroups != NULL )
            lstrcpy(m_pszNewsGroups,pszData);

        // now replace delimiting commas with spaces
        char* ptmp = NULL;
        while( NULL != (ptmp = strchr(pszData,',')) )
            *ptmp = ' ';

        pProp->psProperty.propid = PID_HDR_NEWSGROUPS;
    }
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_SUBJECT) )
        pProp->psProperty.propid = PID_HDR_SUBJECT;
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_FROM) )
        pProp->psProperty.propid = PID_HDR_FROM;
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_MESSAGEID) )
    {
        pProp->psProperty.propid = PID_HDR_MESSAGEID;

        // remove < >'s from message id
        char* ptmp = pszData;
        if( *ptmp++ == '<' )
        {
            while( *ptmp != 0 )
            {
                if( *ptmp == '>' )
                    *ptmp = 0;
                *(ptmp-1) = *ptmp++;
            }
        }
    }
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_REFS) )
        pProp->psProperty.propid = PID_HDR_REFS;
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_XREF) )
    {
        // we take the newsgroup from the xref header
        // to get the newsgroup the message was posted to.
        char* pszSrc = pszData;
        char* pszDst = pszData;

        while( *pszSrc != ' ' )
        {
            _ASSERT(*pszSrc != '\0');
            pszSrc++;
        }
        pszSrc++;
        while( *pszSrc != ':' )
        {
            _ASSERT(*pszSrc != '\0');
            *pszDst++ = *pszSrc++;
        }
        *pszDst = '\0';
        pProp->psProperty.propid = PID_HDR_NEWSGROUP;
        m_fXRefFound = TRUE;
    }
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_DATE) )
    {
        // set prop value type
        m_pHeaderProp->vt = VT_FILETIME;
        // bug #32922: If this is a mail message then it should have a receive
        // line that contains the time that the message was received at the server.
        // If this is not available (always true for nws files) then get the Date
        // header.
        // try to get received time
        hr = m_pMsgPropSet->GetProp(PIDTOSTR(STR_ATT_RECVTIME),0,m_pHeaderProp);
        // if this fails then just get the regular date header
        if( FAILED(hr) )
            hr = m_pMsgPropSet->GetProp(PIDTOSTR(PID_HDR_DATE),0,m_pHeaderProp);
        pProp->psProperty.propid = PID_HDR_DATE;
    }
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_LINES) )
    {
        // set prop value type
        m_pHeaderProp->vt = VT_UI4;
        m_pHeaderProp->ulVal = (ULONG)atol(pszData);
    }

    if( pProp->psProperty.propid == 0 )
    {
        // property does not have a PROPID
        // use the property name
        int cb = lstrlen(pHeaderRow->pszName);
		// _ASSERT( cb <= MAX_HEADER_BUF);
        pProp->psProperty.lpwstr = m_wcHeaderBuf;
        if( !MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,
            pHeaderRow->pszName,-1,pProp->psProperty.lpwstr,
            min(cb, MAX_HEADER_BUF) + 1) )
            return HRGetLastError();
        pProp->psProperty.ulKind = PRSPEC_LPWSTR;
    }

    if( m_pHeaderProp->vt == VT_LPWSTR )
        hr = AstrToWstr(pszData,&m_pHeaderProp->pwszVal,CP_ACP);

    LeaveMethod();
    return hr;
}


STDMETHODIMP CMimeFilter::MapSpecialProperty(FULLPROPSPEC* pProp)
{
    HRESULT hr = NOERROR;
    char*   pstr = NULL;
    EnterMethod("CMimeFilter::MapSpecialProperty");

    // alloc prop variant
    m_pHeaderProp = (PROPVARIANT*) CoTaskMemAlloc (sizeof (PROPVARIANT));
    if( m_pHeaderProp == NULL )
    {
        hr = E_OUTOFMEMORY;
        TraceHR(hr);
        return hr;
    }

    // set prop value type
    m_pHeaderProp->vt = VT_LPWSTR;
    m_pHeaderProp->pwszVal = NULL;

    // set propset guid
    pProp->guidPropSet = CLSID_NNTP_SummaryInformation;

    // default to kind to prop id
    pProp->psProperty.ulKind = PRSPEC_PROPID;
    pProp->psProperty.propid = 0;
    pProp->psProperty.lpwstr = NULL;

    switch( m_SpecialProp )
    {
    case PROP_NEWSGROUP:
        if( !m_fXRefFound && m_pszNewsGroups != NULL )
        {
            // set the XRefFound flag
            m_fXRefFound = TRUE;

            // get the first newsgroup from newsgroups line
            if( NULL != (pstr = strchr(m_pszNewsGroups,',')))
                *pstr = '\0';

            pstr = m_pszNewsGroups;

            pProp->psProperty.ulKind = g_psExtraHeaders[m_SpecialProp].ulKind;
            pProp->psProperty.propid = g_psExtraHeaders[m_SpecialProp].propid;
        }
        else
            hr = S_FALSE;
        break;

    case PROP_ARTICLEID:

        if( m_pwszFileName != NULL )
        {
            // clear retrieved flag
            m_fRetrieved = FALSE;

            // set prop value type
            m_pHeaderProp->vt = VT_UI4;
            m_pHeaderProp->ulVal = FnameToArticleIdW(m_pwszFileName);

            pProp->psProperty.ulKind = g_psExtraHeaders[m_SpecialProp].ulKind;
            pProp->psProperty.propid = g_psExtraHeaders[m_SpecialProp].propid;
        }
        else
            hr = S_FALSE;

        break;

	case PROP_RECVTIME:
        // clear retrieved flag
        m_fRetrieved = FALSE;

		// set variant type
        m_pHeaderProp->vt = VT_FILETIME;

        // try to get received time
        hr = m_pMsgPropSet->GetProp(PIDTOSTR(STR_ATT_RECVTIME),0,m_pHeaderProp);

        // if this fails then just get the regular date header
        if( FAILED(hr) )
            hr = m_pMsgPropSet->GetProp(PIDTOSTR(PID_HDR_DATE),0,m_pHeaderProp);

		// set return prop info
        pProp->psProperty.ulKind = g_psExtraHeaders[m_SpecialProp].ulKind;
        pProp->psProperty.propid = g_psExtraHeaders[m_SpecialProp].propid;
		break;

    default:
        hr = S_FALSE;
        break;
    }

    if( m_pHeaderProp->vt == VT_LPWSTR && hr == NOERROR )
        hr = AstrToWstr(pstr,&m_pHeaderProp->pwszVal,CP_ACP);

    LeaveMethod();
    return hr;
}


STDMETHODIMP CMimeFilter::BindEmbeddedObjectToIFilter(HBODY hBody)
{
    HRESULT     hr = S_OK;
    IMimeBody*  pBody = NULL;
    IStream*    pstmBody = NULL;
    PROPVARIANT varFileName = {0};
    DWORD       dwFlags = 0;
    STATSTG     stat = {0};
    BOOL        fIsMailOrNewsFile = FALSE;
    ULONG       grfFlags = m_fInitFlags;
    IMimePropertySet*   pMsgPropSet = NULL;
    CHAR        szTempFileKey[9];
    DWORD		dwStrLen1, dwStrLen2;

    EnterMethod("CMimeFilter::BindEmbeddedObjectToIFilter");

    // get IMimePropertySet interface
    hr = m_pMessageTree->BindToObject(hBody,IID_IMimePropertySet,(void**)&pMsgPropSet);
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // open the body
    hr = m_pMessageTree->BindToObject(hBody,IID_IMimeBody,(void**)&pBody);
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // get stream to attached data
    hr = pBody->GetData(IET_BINARY,&pstmBody);
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // release existing IFilter
    if( m_pEmbeddedFilter != NULL )
    {
        m_pEmbeddedFilter->Release();
        m_pEmbeddedFilter = NULL;
    }

#if 0
    	// XXX: This is overwritten below

    if( SUCCEEDED(hr = pstmBody->Stat(&stat,STATFLAG_NONAME)) )
    {
        fIsMailOrNewsFile = ( IsEqualCLSID(stat.clsid,CLSID_NNTPFILE) || IsEqualCLSID(stat.clsid,CLSID_MAILFILE) );

#if 0
        // Attempt to bind stream to IFilter
        // this only works if the IFilter supports
        // IPersistStream
        hr = BindIFilterFromStream(pstmBody, NULL, (void**)&m_pEmbeddedFilter);
#else
		// this will cause the below code to write the stream to a file and do
		// its work that way.
		hr = E_FAIL;
#endif
    }

    if( FAILED(hr) )	// Always want to do this
#endif
    {
        // couldn't bind to stream, try binding to file

        // does it have a file name associated with it
        varFileName.vt = VT_LPSTR;
        hr = pMsgPropSet->GetProp(STR_ATT_FILENAME, 0, &varFileName);
        if( hr == MIME_E_NOT_FOUND )
            hr = pMsgPropSet->GetProp(STR_ATT_GENFNAME, 0, &varFileName);
        if (FAILED(hr))
        {
            TraceHR(hr);
            goto Exit;
        }

        // create temp file name
        if( m_pszEmbeddedFile == NULL )
        {
            m_pszEmbeddedFile = new char[MAX_PATH*2];
            if( m_pszEmbeddedFile == NULL )
            {
                hr = E_OUTOFMEMORY;
                TraceHR(hr);
                goto Exit;
            }
        }
        else if( *m_pszEmbeddedFile != '\0' )
        {
            // we have an existing file so delete it
            DeleteFile(m_pszEmbeddedFile);
        }
        *m_pszEmbeddedFile = '\0';

        // get the temp dir
        GetTempPath(MAX_PATH,m_pszEmbeddedFile);

        // add the temp file key
        _VERIFY( SUCCEEDED( GenTempFileKey( szTempFileKey ) ) );
        lstrcat(m_pszEmbeddedFile, szTempFileKey );

		// sometime the filename could be too long for the buffer, we need to check that
        dwStrLen1 = lstrlen (m_pszEmbeddedFile);
        dwStrLen2 = lstrlen (varFileName.pszVal);

        if (dwStrLen1+dwStrLen2>=MAX_PATH-1)
        {
        	if (dwStrLen2>MAX_PATH-1-dwStrLen1)
        	{
        		// trucate some part of the file name so it could fit into the buffer is for the termaination NULL
        		lstrcat(m_pszEmbeddedFile,varFileName.pszVal+dwStrLen2-MAX_PATH+1+dwStrLen1);
        	}
        	else
       		{
        		hr = ERROR_FILENAME_EXCED_RANGE;
	            TraceHR(hr);
    	        goto Exit;
        	}
        }
        else
       	{
	        // add the file name
    	    lstrcat(m_pszEmbeddedFile,varFileName.pszVal);
        }

        // copy stream to file
        hr = WriteStreamToFile(pstmBody,m_pszEmbeddedFile);
        if( FAILED(hr) )
        {
            // couldn't copy stream to file
            TraceHR(hr);
            goto Exit;
        }

        // load ifilter
        hr = LoadIFilterA(m_pszEmbeddedFile, NULL, (void**)&m_pEmbeddedFilter);
        if( FAILED(hr) )
        {
            // no IFilter found for this embedded file
            // rather than aborting we just goto the next
            // body part
            TraceHR(hr);
            DebugTrace((LPARAM)this,"No IFilter for = %s",varFileName.pszVal);
            goto Exit;
        }
        fIsMailOrNewsFile = IsMailOrNewsFile(m_pszEmbeddedFile);
    }

    // init ifilter
    if( fIsMailOrNewsFile )
    {
        // use the flags from Init call, but do not include any properties.
        grfFlags = m_fInitFlags & ~IFILTER_INIT_APPLY_INDEX_ATTRIBUTES & ~IFILTER_INIT_APPLY_OTHER_ATTRIBUTES;
    }
    hr = m_pEmbeddedFilter->Init(grfFlags,0,NULL,&dwFlags);
    if( FAILED(hr) )
    {
        // unable to init IFilter
        TraceHR(hr);
        goto Exit;
    }

Exit:
    // clean up
    if(varFileName.pszVal)
        m_pMalloc->PropVariantClear(&varFileName);
    if(pBody)
        pBody->Release();
    if(pstmBody)
        pstmBody->Release();
    if(pMsgPropSet)
        pMsgPropSet->Release();

    LeaveMethod();
    return hr;
}


STDMETHODIMP CMimeFilter::GetBodyCodePage(IMimeBody* pBody,CODEPAGEID* pcpiBody)
{
    HRESULT     hr = S_OK;
    HCHARSET    hCharSet = 0;
    INETCSETINFO    CsetInfo = {0};


    EnterMethod("CMimeFilter::GetBodyCodePage");

    while(TRUE)
    {
        hr = pBody->GetCharset(&hCharSet);
        if( FAILED(hr) )
        {
            TraceHR(hr);
            break;
        }
        if( m_pMimeIntl == NULL )
        {
            // get the mime international interface
            hr = CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER, 
                IID_IMimeInternational, (LPVOID *)&m_pMimeIntl);
            if (FAILED(hr))
            {
                TraceHR(hr);
                break;
            }
        }

        // get charset info
        hr = m_pMimeIntl->GetCharsetInfo(hCharSet,&CsetInfo);
        if( FAILED(hr) )
        {
            TraceHR(hr);
            break;
        }

        // return codepage id
        *pcpiBody = CsetInfo.cpiWindows;

        break;
    }

    LeaveMethod();
    return hr;
}

HRESULT
CMimeFilter::GenTempFileKey(    LPSTR   szOutput )
/*++
Routine description:

    Generate the temp file key, to be composed into the temp file 
    name.  The key monotonically increases.  Caller must prepare a 
    buffer of no less than 9 bytes, because the key is going to 
    be convert into string in hex mode.

Arguments:

    szOutput - to return the key in the form of string

Return value:

    S_OK - if succeeded, other error code otherwise
--*/
{
    _ASSERT( szOutput );

    DWORD    dwKey = InterlockedIncrement( (PLONG)&m_dwTempFileNameKey );
    sprintf( szOutput, "%x", dwKey );
    return S_OK;
}

SCODE WriteStreamToFile(IStream* pStream, char* pszFileName)
{
    HRESULT hr = S_OK;
    BYTE    bBuffer[4096];
    DWORD   cb, cbWritten;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    if( pStream == NULL || pszFileName == NULL || *pszFileName == 0 )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // create the file
    hFile = CreateFile(pszFileName,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY,
        NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        hr = HRGetLastError();
        goto Exit;
    }

    // copy stream to file
    while( SUCCEEDED(pStream->Read(&bBuffer,4096,&cb)) && cb != 0 )
    {
        if(!WriteFile(hFile,bBuffer,cb,&cbWritten,NULL))
        {
            hr = HRGetLastError();
            goto Exit;
        }
    }

Exit:
    if( hFile != INVALID_HANDLE_VALUE )
        _VERIFY(CloseHandle(hFile));

    return hr;
}

SCODE LoadIFilterA( char* pszFileName, IUnknown * pUnkOuter, void ** ppIUnk )
{
    WCHAR wcFileName[MAX_PATH];

    if( !MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,
        pszFileName,-1,wcFileName,MAX_PATH) )
        return HRGetLastError();

    // load ifilter
    return LoadIFilter(wcFileName, pUnkOuter, ppIUnk);
}

#if 0
BOOL GetFileClsid(char* pszAttFile,CLSID* pclsid)
{
    DWORD   cb = 0;
    char*   pszExt = NULL;
    char    szTypeName[256];
    char    szSubKey[256];
    char    szClsId[128];
    OLECHAR oszClsId[128];

    // get file extension from filename
    if( NULL == (pszExt = strrchr(pszAttFile,'.')) )
        return FALSE; // no filter

    // get the file's type name
    cb = sizeof(szTypeName);
    if(!GetStringRegValue(HKEY_CLASSES_ROOT,pszExt,NULL,szTypeName,cb))
        return FALSE;

    // get the file's type name clsid
    cb = sizeof(szClsId);
    wsprintf(szSubKey,"%s\\CLSID",szTypeName);
    if(!GetStringRegValue(HKEY_CLASSES_ROOT,szSubKey,"",szClsId,cb))
        return FALSE;

    // convert szClsId to CLSID
    if( !MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,
        szClsId,-1,oszClsId,sizeof(oszClsId)/2) )
        return FALSE;

    return SUCCEEDED(CLSIDFromString(oszClsId,pclsid));
}
#endif

STDMETHODIMP CMimeFilter::LoadFromFile( LPCWSTR psszFileName, DWORD dwMode )
{
    EnterMethod("CImpIPersistFile::LoadFromFile");
    HRESULT hr = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    // free previously allocated storage
    if ( m_pwszFileName != NULL )
    {
        delete m_pwszFileName;
        m_pwszFileName = NULL;
    }

#if !defined( NOTRACE )
    char szFile[MAX_PATH];
    WideCharToMultiByte(CP_ACP,0,psszFileName,-1,szFile,sizeof(szFile)-1,NULL,NULL);
    DebugTrace((LPARAM)this,"psszFileName = %s",szFile);
#endif

    // get length of filename
    unsigned cLen = wcslen( psszFileName ) + 1;

    // if filename is empty then we have a problem
    if( cLen == 1 )
    {
        hr = E_INVALIDARG;
        TraceHR(hr);
        return hr;
    }

    // allocate storage for filename
    m_pwszFileName = new WCHAR[cLen];
    if( m_pwszFileName == NULL )
    {
        hr = E_OUTOFMEMORY;
        TraceHR(hr);
        return hr;
    }
    
    _VERIFY( 0 != wcscpy( m_pwszFileName, psszFileName ) );

    // open message file
    hFile = CreateFileW(m_pwszFileName,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,
        OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        hr = HRGetLastError();
        TraceHR(hr);
        return hr;
    }

    // create Stream on hfile
    m_pstmFile = (IStream*) new CStreamFile(hFile,TRUE);
    if( m_pstmFile == NULL )
    {
        _VERIFY(CloseHandle(hFile));
        hr = E_OUTOFMEMORY;
        TraceHR(hr);
        return hr;
    }

    LeaveMethod();
    return hr;
}

STDMETHODIMP CMimeFilter::LoadFromStream(IStream* pstm)
{
    EnterMethod("CImpIPersistFile::LoadFromStream");
    HRESULT hr = S_OK;

    if( pstm == NULL )
        return E_INVALIDARG;

    // do we have an existing IStream
    if( m_pstmFile != NULL )
    {
        // release it
        m_pstmFile->Release();
        m_pstmFile = NULL;
    }

    m_pstmFile = pstm;
    m_pstmFile->AddRef();

    LeaveMethod();
    return hr;
}


void FreePropVariant(PROPVARIANT* pProp)
{
    if( pProp == NULL )
        return;

    if( pProp->vt == VT_LPWSTR && pProp->pwszVal != NULL )
        CoTaskMemFree(pProp->pwszVal);

    CoTaskMemFree(pProp);
}


STDMETHODIMP AstrToWstr(char* pstr,WCHAR** ppwstr,UINT codepage)
{
    int cb = 0;

    // alloc mem for prop
    cb = lstrlen(pstr) + 1;
    *ppwstr = (WCHAR *) CoTaskMemAlloc(cb * sizeof(WCHAR));
    if( *ppwstr == NULL )
        return E_OUTOFMEMORY;

    // convert to unicode
    if( !MultiByteToWideChar(codepage,MB_PRECOMPOSED,
        pstr,-1,*ppwstr,cb) )
        return HRGetLastError();

    return NOERROR;
}

DWORD ulFactor[8] = {0x10,0x1,0x1000,0x100,0x100000,0x10000,0x10000000,0x1000000};
ULONG FnameToArticleIdW(WCHAR *pwszPath)
{
    WCHAR   wszFname[MAX_PATH];
    WCHAR   wszExt[MAX_PATH];
    ULONG   ulRet = 0;
    ULONG   ulNum = 0;
    int     nLen = 0;
    int     n = 0;
    int     f = 0;

    _wcslwr(pwszPath);
    _wsplitpath(pwszPath,NULL,NULL,wszFname,wszExt);
    nLen = wcslen(wszFname);
    //
    //  MAIL and NEWS file naming convention is slightly different.
    //
    if( (0 == wcscmp(wszExt,g_wszNewsExt)) && (nLen <= 8))
    {
        if( nLen % 2 != 0 )
            f = 1;
        for(;n < nLen;n++, f++)
        {
            if( wszFname[n] >= L'0' && wszFname[n] <= L'9' )
                ulNum = wszFname[n] - L'0';
            else if( wszFname[n] >= L'a' && wszFname[n] <= L'f' )
                ulNum = wszFname[n] - L'a' + 10;
            else
                return 0; // not a valid article id

            ulRet += ulNum * ulFactor[f];
        }
    } else if( (0 == wcscmp(wszExt,g_wszMailExt)) && (nLen == 8)) {
        //
        //  Exp will be zero when we point to dot in extension.
        //
        for ( DWORD exp = 1;  exp;  n++, exp <<= 4) {
            if(  wszFname[ n] >= L'0' && wszFname[ n] <= L'9' ) {
                ulNum = wszFname[ n] - L'0';
            } else if ( wszFname[ n] >= L'a' && wszFname[ n] <= L'f' ) {
                ulNum = wszFname[ n] - L'a' + 10;
            } else {
                return( 0);
            }
            ulRet += ulNum * exp;
        }
    }
    return ulRet;
}

BOOL IsMailOrNewsFile(char *pszPath)
{
    char szFname[MAX_PATH];
    char szExt[MAX_PATH];

    _strlwr(pszPath);
    _splitpath(pszPath,NULL,NULL,szFname,szExt);
    return ( 0 == strcmp(szExt,g_szNewsExt) || 0 == strcmp(szExt,g_szMailExt) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmf.h ===
#ifndef __CMF_H__
#define __CMF_H__

#include <fstream.h>

#define MAX_HEADER_BUF 128


enum _tagSPECIALPROP {
	PROP_NEWSGROUP,
	PROP_ARTICLEID,
	PROP_RECVTIME,
	PROP_END
};

class CImpIPersistFile;
class CImpIPersistStream;

//+---------------------------------------------------------------------------
//
//  Class:      CMimeFilter
//
//  Purpose:    MIME Filter
//
//----------------------------------------------------------------------------
class CMimeFilter: public IFilter
{
	friend class CImpIPersistFile;
	friend class CImpIPersistStream;

public:
	CMimeFilter(IUnknown* pUnkOuter);
	~CMimeFilter();

	// IUnknown 
    STDMETHODIMP QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IFilter
	STDMETHODIMP Init(ULONG,ULONG,FULLPROPSPEC const*,ULONG*);
	STDMETHODIMP GetChunk( STAT_CHUNK* );
	STDMETHODIMP GetText( ULONG*,WCHAR*);
	STDMETHODIMP GetValue( PROPVARIANT** );
	STDMETHODIMP BindRegion( FILTERREGION, const struct _GUID &,void**) {return E_NOTIMPL;};

	STDMETHODIMP HRInitObject();

private:
	// private methods
	STDMETHODIMP	LoadFromFile(LPCWSTR,DWORD);
	STDMETHODIMP	LoadFromStream(LPSTREAM);
	STDMETHODIMP	GetNextBodyPart();
	STDMETHODIMP	MapHeaderProperty(ENUMPROPERTY*,char*,FULLPROPSPEC*);
	STDMETHODIMP	MapSpecialProperty(FULLPROPSPEC*);
	STDMETHODIMP	BindEmbeddedObjectToIFilter(HBODY);
	STDMETHODIMP	GetBodyCodePage(IMimeBody*,CODEPAGEID*);
	STDMETHODIMP_(ULONG)	GetNextChunkId();
	STDMETHODIMP_(LCID)		GetLocale()                    { return m_locale; };
	STDMETHODIMP_(void)		SetLocale( LCID locale )       { m_locale = locale; };
	STDMETHODIMP    GenTempFileKey( LPSTR );

	//
	// class wide static variable
	//

	//
	// Global temp file key as part of temp file name - it monotonically increases
	// until hitting the max limit and then rolls back to zero
	//

	static DWORD         m_dwTempFileNameKey;

	// private data
    LONG				m_cRef;						// object ref count
	IUnknown*			m_pUnkOuter;				// outer controlling IUnknown
	CImpIPersistFile*	m_pCImpIPersistFile;		// IPersistFile for this object
	CImpIPersistStream*	m_pCImpIPersistStream;		// IPersistStream for this object


	ULONG			m_ulChunkID;		// Current chunk id
	LCID			m_locale;			// Locale
	ULONG			m_fInitFlags;		// flags passed into Init()

	WCHAR *					m_pwszFileName;	// message file
	IStream*				m_pstmFile;		// stream wrapper on message file
    IMimeMessageTree*		m_pMessageTree;	// main object interface to MIME message
	IMimePropertySet*		m_pMsgPropSet;	// header property set
	IMimeEnumProperties*	m_pHeaderEnum;	// header enumerator (main header only)
	WCHAR					m_wcHeaderBuf[MAX_HEADER_BUF + 1];	// holds header name between GetChunk calls
	PROPVARIANT*			m_pHeaderProp;	// pointer to header prop returned in GetValue()
	HBODY					m_hBody;		// current body part handle
	IStream*				m_pstmBody;		// stream interface to current body part
	CODEPAGEID				m_cpiBody;		// codepage mapping for current body part
	BOOL					m_fFirstAlt;
	char*					m_pTextBuf;		// temporary buffer for converting text
	ULONG					m_cbBufSize;	// size of temporary buffer
	BOOL					m_fRetrieved;	// flag to indicate data has be retrieved
	char*					m_pszEmbeddedFile;
	IFilter*				m_pEmbeddedFilter;
	BOOL					m_fXRefFound;
	char*					m_pszNewsGroups;

	enum {
		STATE_INIT,
		STATE_START,
		STATE_END,
		STATE_HEADER,
		STATE_POST_HEADER,
		STATE_BODY,
		STATE_EMBEDDING,
		STATE_ERROR
	} m_State;

	UINT					m_SpecialProp;

	IMimeAllocator*			m_pMalloc;		// MimeOLE global allocator
	IMimeInternational*		m_pMimeIntl;
};

class CImpIPersistFile : public IPersistFile
{
protected:
    LONG			m_cRef;
    CMimeFilter*	m_pObj;
    LPUNKNOWN		m_pUnkOuter;

public:
    CImpIPersistFile(CMimeFilter*, LPUNKNOWN);
    ~CImpIPersistFile(void);

	// IUnknown
    STDMETHODIMP QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IPersist
    STDMETHODIMP GetClassID(LPCLSID);

	// IPersistFile
	STDMETHODIMP IsDirty(void);
	STDMETHODIMP Load(LPCWSTR pszFileName, DWORD dwMode);
	STDMETHODIMP Save(LPCWSTR pszFileName, BOOL fRemember);
	STDMETHODIMP SaveCompleted(LPCWSTR pszFileName);
	STDMETHODIMP GetCurFile(LPWSTR * ppszFileName);
};

class CImpIPersistStream : public IPersistStream
{
protected:
    LONG			m_cRef;
    CMimeFilter*	m_pObj;
    LPUNKNOWN		m_pUnkOuter;

public:
    CImpIPersistStream(CMimeFilter*, LPUNKNOWN);
    ~CImpIPersistStream(void);

	// IUnknown
    STDMETHODIMP QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IPersist
    STDMETHODIMP GetClassID(LPCLSID);

	// IPersistFile
	STDMETHODIMP IsDirty(void);
	STDMETHODIMP Load(IStream* pstm);
	STDMETHODIMP Save(IStream* pstm,BOOL fClearDirty);
	STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);
};

#endif  //  __CMF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmfbase.h ===
#if !defined( __CMFBASE_H__ )
#define __CMFBASE_H__


extern  GUID CLSID_MimeIFilter;

//+-------------------------------------------------------------------------
//
//  Class:      CMimeFilterBase
//
//  Purpose:    Manage aggregation, refcounting for CMimeFilter
//
//--------------------------------------------------------------------------

class CMimeFilterBase : public IFilter, public IPersistFile
{
public:

    //
    // From IUnknown
    //

    virtual  HRESULT STDMETHODCALLTYPE  QueryInterface(REFIID riid, void  * * ppvObject);

    virtual  ULONG STDMETHODCALLTYPE  AddRef();

    virtual  ULONG STDMETHODCALLTYPE  Release();

    //
    // From IFilter
    //

    virtual  HRESULT STDMETHODCALLTYPE  Init( ULONG grfFlags,
                                            ULONG cAttributes,
                                            FULLPROPSPEC const * aAttributes,
                                            ULONG * pFlags ) = 0;

    virtual  HRESULT STDMETHODCALLTYPE  GetChunk( STAT_CHUNK * pStat) = 0;

    virtual  HRESULT STDMETHODCALLTYPE  GetText( ULONG * pcwcBuffer,
                                               WCHAR * awcBuffer ) = 0;

    virtual  HRESULT STDMETHODCALLTYPE  GetValue( PROPVARIANT * * ppPropValue ) = 0;

    virtual  HRESULT STDMETHODCALLTYPE  GetMoniker( FILTERREGION origPos,
                                                  IMoniker * * ppmnk) = 0;

    //
    // From IPersistFile
    //

    virtual  HRESULT STDMETHODCALLTYPE  GetClassID( CLSID * pClassID ) = 0;

    virtual  HRESULT STDMETHODCALLTYPE  IsDirty() = 0;

    virtual  HRESULT STDMETHODCALLTYPE  Load( LPCWSTR pszFileName,
                                            DWORD dwMode) = 0;

    virtual  HRESULT STDMETHODCALLTYPE  Save( LPCWSTR pszFileName,
                                            BOOL fRemember ) = 0;

    virtual  HRESULT STDMETHODCALLTYPE  SaveCompleted( LPCWSTR pszFileName ) = 0;

    virtual  HRESULT STDMETHODCALLTYPE  GetCurFile( LPWSTR  * ppszFileName ) = 0;

protected:

            CMimeFilterBase();
    virtual ~CMimeFilterBase();

    long _uRefs;
};



#endif // __CMFBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmfbase.cpp ===
#include "mimefilt.h"

long gulcInstances = 0;

//
// Guids for Nntp filter and class
//

extern "C" GUID CLSID_MimeFilter ;

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterBase::CMimeFilterBase
//
//  Synopsis:   Base constructor
//
//  Effects:    Manages global refcount
//
//--------------------------------------------------------------------------

CMimeFilterBase::CMimeFilterBase()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterBase::~CMimeFilterBase
//
//  Synopsis:   Base destructor
//
//  Effects:    Manages global refcount
//
//--------------------------------------------------------------------------

CMimeFilterBase::~CMimeFilterBase()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterBase::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CMimeFilterBase::QueryInterface( REFIID riid,
                                                          void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IFilter      = 89BCB740-6119-101A-BCB7-00DD010655AF
    // IID_IPersist     = 0000010c-0000-0000-C000-000000000046
    // IID_IPersistFile = 0000010b-0000-0000-C000-000000000046
    //                          --
    //                           |
    //                           +--- Unique!

    _ASSERT( (IID_IUnknown.Data1     & 0x000000FF) == 0x00 );
    _ASSERT( (IID_IFilter.Data1      & 0x000000FF) == 0x40 );
    _ASSERT( (IID_IPersist.Data1     & 0x000000FF) == 0x0c );
    _ASSERT( (IID_IPersistFile.Data1 & 0x000000FF) == 0x0b );

    IUnknown *pUnkTemp;
    HRESULT hr = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( IID_IUnknown == riid )
            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x40:
        if ( IID_IFilter == riid )
            pUnkTemp = (IUnknown *)(IFilter *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x0c:
        if ( IID_IPersist == riid )
            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x0b:
        if ( IID_IPersistFile == riid )
            pUnkTemp = (IUnknown *)(IPersistFile *)this;
        else
            hr = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        hr = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterBase::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilterBase::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterBase::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilterBase::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmfpf.cpp ===
#include "mimefilt.h"

//+---------------------------------------------------------------------------
// CImpIPersistFile::CImpIPersistFile
// CImpIPersistFile::~CImpIPersistFile
//
// Constructor Parameters:
//  pObj            LPVOID pointing to the object we live in.
//  pUnkOuter       LPUNKNOWN of the controlling unknown.
//+---------------------------------------------------------------------------

CImpIPersistFile::CImpIPersistFile(CMimeFilter* pObj
    , LPUNKNOWN pUnkOuter)
    {
	EnterMethod("CImpIPersistFile::CImpIPersistFile");
    m_cRef=0;
    m_pObj=pObj;
    m_pUnkOuter=pUnkOuter;
	LeaveMethod();
    return;
    }


CImpIPersistFile::~CImpIPersistFile(void)
    {
	EnterMethod("CImpIPersistFile::~CImpIPersistFile");
	_ASSERT( m_cRef == 0 );
	LeaveMethod();
    return;
    }


//+---------------------------------------------------------------------------
//
// CImpIPersistFile::QueryInterface
// CImpIPersistFile::AddRef
// CImpIPersistFile::Release
//
// Purpose:
//  Standard set of IUnknown members for this interface
//
//+---------------------------------------------------------------------------


STDMETHODIMP CImpIPersistFile::QueryInterface(REFIID riid
    , void** ppv)
    {
	EnterMethod("CImpIPersistFile::QueryInterface");
	LeaveMethod();
    return m_pUnkOuter->QueryInterface(riid, ppv);
    }

STDMETHODIMP_(ULONG) CImpIPersistFile::AddRef(void)
    {
	EnterMethod("CImpIPersistFile::AddRef");
    InterlockedIncrement(&m_cRef);
	LeaveMethod();
    return m_pUnkOuter->AddRef();
    }

STDMETHODIMP_(ULONG) CImpIPersistFile::Release(void)
    {
	EnterMethod("CImpIPersistFile::Release");
	InterlockedDecrement(&m_cRef);
	LeaveMethod();
    return m_pUnkOuter->Release();
    }

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::GetClassID( CLSID * pClassID )
{
	EnterMethod("GetClassID");
	*pClassID = CLSID_MimeFilter;
	LeaveMethod();
	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since the filter is read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::IsDirty()
{
	EnterMethod("CImpIPersistFile::IsDirty");
	LeaveMethod();
	return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode] -- the mode to load the file in
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::Load( LPCWSTR psszFileName, DWORD dwMode )
{
	EnterMethod("CImpIPersistFile::Load");
	HRESULT hr = S_OK;

	hr = m_pObj->LoadFromFile(psszFileName,dwMode);

	LeaveMethod();
	return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::Save( LPCWSTR pszFileName, BOOL fRemember )
{
	EnterMethod("CImpIPersistFile::Save");
	LeaveMethod();
	return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::SaveCompleted( LPCWSTR pszFileName )
{
	EnterMethod("CImpIPersistFile::SaveCompleted");
	LeaveMethod();
	return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::GetCurFile( LPWSTR * ppwszFileName )
{
	EnterMethod("CImpIPersistFile::GetCurFile");
	if ( m_pObj->m_pwszFileName == 0 )
		return E_FAIL;

	if( ppwszFileName == NULL )
		return E_INVALIDARG;

	unsigned cLen = wcslen( m_pObj->m_pwszFileName ) + 1;

	if( cLen == 1 )
		return E_INVALIDARG;

	*ppwszFileName = (WCHAR *)CoTaskMemAlloc( cLen * sizeof(WCHAR) );

	if ( *ppwszFileName == NULL )
		return E_OUTOFMEMORY;

	_VERIFY( 0 != wcscpy( *ppwszFileName, m_pObj->m_pwszFileName ) );

	LeaveMethod();
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmfpstm.cpp ===
#include "mimefilt.h"

//+---------------------------------------------------------------------------
// CImpIPersistStream::CImpIPersistStream
// CImpIPersistStream::~CImpIPersistStream
//
// Constructor Parameters:
//  pObj            LPVOID pointing to the object we live in.
//  pUnkOuter       LPUNKNOWN of the controlling unknown.
//+---------------------------------------------------------------------------

CImpIPersistStream::CImpIPersistStream(CMimeFilter* pObj
    , LPUNKNOWN pUnkOuter)
    {
	EnterMethod("CImpIPersistStream::CImpIPersistStream");
    m_cRef=0;
    m_pObj=pObj;
    m_pUnkOuter=pUnkOuter;
	LeaveMethod();
    return;
    }


CImpIPersistStream::~CImpIPersistStream(void)
    {
	EnterMethod("CImpIPersistStream::~CImpIPersistStream");
	_ASSERT( m_cRef == 0 );
	LeaveMethod();
    return;
    }


//+---------------------------------------------------------------------------
//
// CImpIPersistStream::QueryInterface
// CImpIPersistStream::AddRef
// CImpIPersistStream::Release
//
// Purpose:
//  Standard set of IUnknown members for this interface
//
//+---------------------------------------------------------------------------


STDMETHODIMP CImpIPersistStream::QueryInterface(REFIID riid
    , void** ppv)
    {
	EnterMethod("CImpIPersistStream::QueryInterface");
	LeaveMethod();
    return m_pUnkOuter->QueryInterface(riid, ppv);
    }

STDMETHODIMP_(ULONG) CImpIPersistStream::AddRef(void)
    {
	EnterMethod("CImpIPersistStream::AddRef");
    InterlockedIncrement(&m_cRef);
	LeaveMethod();
    return m_pUnkOuter->AddRef();
    }

STDMETHODIMP_(ULONG) CImpIPersistStream::Release(void)
    {
	EnterMethod("CImpIPersistStream::Release");
	InterlockedDecrement(&m_cRef);
	LeaveMethod();
    return m_pUnkOuter->Release();
    }

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::GetClassID( CLSID * pClassID )
{
	EnterMethod("GetClassID");
	*pClassID = CLSID_MimeFilter;
	LeaveMethod();
	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since the filter is read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::IsDirty()
{
	EnterMethod("CImpIPersistStream::IsDirty");
	LeaveMethod();
	return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pstm] -- stream to load from
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::Load( IStream*  pstm )
{
	EnterMethod("CImpIPersistStream::Load");
	HRESULT hr = S_OK;

	hr = m_pObj->LoadFromStream(pstm);

	LeaveMethod();
	return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::Save(IStream* pstm,BOOL fClearDirty)
{
	EnterMethod("CImpIPersistStream::Save");
	LeaveMethod();
	return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::GetSizeMax, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
	EnterMethod("CImpIPersistStream::GetSizeMax");

	LeaveMethod();
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\def_guid.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       htmlguid.cxx
//
//  Contents:   Definitions of NNTP properties
//
//  This code and information is provided "as is" without warranty of
//  any kind, either expressed or implied, including but not limited to
//  the implied warranties of merchantability and/or fitness for a
//  particular purpose.
//
//--------------------------------------------------------------------------

#include <ole2.h>
#include <stgprop.h>
#pragma hdrstop

//
// Guids for property sets - storage, summary information and NNTP information
//

GUID CLSID_Storage = PSGUID_STORAGE;


// {AA568EEC-E0E5-11cf-8FDA-00AA00A14F93}
GUID CLSID_NNTP_SummaryInformation =
{ 0xaa568eec, 0xe0e5, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

EXTERN_C const  GUID IID_IFilter = {
    0x89BCB740,
    0x6119,
    0x101A,
    { 0xBC, 0xB7, 0x00, 0xDD, 0x01, 0x06, 0x55, 0xAF }
};



// {5645C8C0-E277-11cf-8FDA-00AA00A14F93}
  GUID CLSID_NNTPFILE  = 
{ 0x5645c8c0, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

// {5645C8C1-E277-11cf-8FDA-00AA00A14F93}
 GUID CLSID_NNTP_PERSISTENT  = 
{ 0x5645c8c1, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

// {5645C8C2-E277-11cf-8FDA-00AA00A14F93}
 GUID CLSID_MimeFilter  = 
{ 0x5645c8c2, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

// {53524bdc-3e9c-101b-abe2-00608c86f49a}
 GUID CLSID_InsoUniversalFilter  = 
{ 0x53524bdc, 0x3e9c, 0x101b, { 0xab, 0xe2, 0x00, 0x60, 0x8c, 0x86, 0xf4, 0x9a } };

// {5645C8C0-E277-11cf-8FDA-00AA00A14F93}
  GUID CLSID_MAILFILE  = 
{ 0x5645c8c3, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

// {5645C8C1-E277-11cf-8FDA-00AA00A14F93}
 GUID CLSID_MAIL_PERSISTENT  = 
{ 0x5645c8c4, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\mimefilt.h ===
#if !defined( __MIMEFILT_H__ )
#define __MIMEFILT_H__

#include <ole2.h>
#include <windows.h>
#define OLEDBVER 0x0250
#include <oledb.h>
#include <cmdtree.h>
#include <stdio.h>
#include <query.h>
#include <ciintf.h>
#include <ntquery.h>
#include <filterr.h>
// having tracing in the filter basically makes tracing other parts of
// the system useless, since the filter is always running
// #define NOTRACE
#include <dbgtrace.h>
#include <mimeole.h>
#include <cstream.h>

#include "def_guid.h"
#include "regutil.h"

#include "cmf.h"
#include "cfactory.h"

#define HRGetLastError() HRESULT_FROM_WIN32(GetLastError())

#define EnterMethod(sz) TraceFunctEnterEx((LPARAM)this,sz)
#define LeaveMethod() TraceFunctLeaveEx((LPARAM)this)
#define TraceHR(hr) DebugTrace((LPARAM)this,"hr = 0x%08x", hr)
#endif // __MIMEFILT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\regutil.h ===
//																	-*- c++ -*-
// regutil.h
//
//		utility funcitons for manipulating the registry
//

#ifndef _regutil_H_
#define _regutil_H_

#include <windows.h>
#include <ole2.h>

//-----------------------------------------------------------------------------
// general registry functions
//-----------------------------------------------------------------------------

// open a key
BOOL OpenOrCreateRegKey( HKEY hKey, LPCTSTR pctstrKeyName, PHKEY phKeyOut );

// get a string value
BOOL GetStringRegValue( HKEY hKeyRoot,
						LPCTSTR lpcstrKeyName, LPCTSTR lpcstrValueName,
						LPTSTR ptstrValue, DWORD dwMax );
BOOL GetStringRegValue( HKEY hkey,
						LPCTSTR lpcstrValueName,
						LPTSTR ptstrValue, DWORD dwMax );

// set a string value
BOOL SetStringRegValue( HKEY hKey,
						LPCTSTR lpcstrValueName,
						LPCTSTR lpcstrString );
BOOL SetStringRegValue( HKEY hKeyRoot,
						LPCTSTR lpcstrKeyName,
						LPCTSTR lpcstrValueName,
						LPCTSTR lpcstrString );

// get a dword value
BOOL GetDwordRegValue( HKEY hKeyRoot, LPCTSTR lpcstrKeyName,
					   LPCTSTR lpcstrValueName, PDWORD pdw );
BOOL GetDwordRegValue( HKEY hKeyRoot,
					   LPCTSTR lpcstrValueName, PDWORD pdw );

// set a dword value
BOOL SetDwordRegValue( HKEY hKeyRoot,
					   LPCTSTR lpcstrKeyName,
					   LPCTSTR lpcstrValueName,
					   DWORD dwValue );
BOOL SetDwordRegValue( HKEY hKeyRoot,
					   LPCTSTR lpcstrValueName,
					   DWORD dwValue );

// delete a reg. key
void DeleteRegSubtree( HKEY hkey, LPCSTR pcstrSubkeyName );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\ver.h ===
// VERSION INFORMATION
#define RC_VERSION_FILE_DESCRIPTION "Microsoft (R) IMimeFilter Persistent Handler DLL\0"
#define RC_VERSION_INTERNAL_NAME "mimefilt.dll\0"
#define RC_VERSION_ORIGINAL_FILE_NAME "mimefilt.dll\0"
#include <bldver.rc>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\mimefilt.cpp ===
#include "mimefilt.h"

extern long gulcInstances;

char szNewsExt[] = {".nws"};
char szNewsProgId[] ="Microsoft Internet News Message";
char szNewsFileDesc[] ="Internet News Message";

char szMailExt[] =".eml";
char szMailProgId[] ="Microsoft Internet Mail Message";
char szMailFileDesc[] ="Internet E-Mail Message";

void RegisterFilter(HINSTANCE hInst,LPSTR pszExt,LPSTR pszProgId,LPSTR pszDesc,GUID ClsId,GUID PersistId)
{
	//   The following are the set of reg keys required for Tripoli
	//
	//   1. Create entry ".nws", with value "Microsoft Internet News Message"
	//   2. Create entry "Microsoft Internet News Message", value="Internet News Message"
	//   3. Create entry "Microsoft Internet News Message\CLSID" value = CLSID_NNTPFILE
	//   4. Create entry "CLSID\CLSID_NNTPFILE" value = "NNTP filter"
	//   5. Create entry "CLSID\CLSID_NNTPFILE\PersistentHandler" 
	//						value = CLSID_NNTP_PERSISTENT
	//   6. Create entry "CLSID\CLSID_NNTP_PERSISTENT" value = ""
	//   7. create "CLSID\CLSID_MimeFilter\InprocServer32"
	//

    HKEY    hKey;
    char    szSubKey[256];
    char    szClsId[128];
    OLECHAR oszClsId[128];

	//   1. Create the extension entry, with value nntpfile

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, pszExt, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, pszProgId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   2. Create entry "Microsoft Internet News Message", value="Internet News Message"

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, pszProgId, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, pszDesc, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   3. Create entry "Microsoft Internet News Message\CLSID"

    StringFromGUID2( ClsId, oszClsId, sizeof(oszClsId));
    WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId), NULL, NULL);

    wsprintf(szSubKey, "%s\\CLSID", pszProgId );

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   4. Create entry "CLSID\CLSID_NNTPFILE" value = "NNTP file"

    wsprintf(szSubKey, "CLSID\\%s", szClsId );
	wsprintf(szClsId, "NNTP filter");

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   5. Create entry "CLSID\CLSID_NNTPFILE\PersistentHandler" 
	//						value = CLSID_NNTP_PERSISTENT

    wsprintf(szClsId, "%s", szSubKey );
    wsprintf(szSubKey, "%s\\PersistentHandler", szClsId );

    StringFromGUID2( PersistId, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
    WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId),
						NULL, NULL);

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   6. Create entry "CLSID\CLSID_NNTP_PERSISTENT" value = ""
	char szClsId1[128];

    StringFromGUID2( IID_IFilter, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
    WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId1, sizeof(szClsId1), NULL, NULL);

	wsprintf(szSubKey, "CLSID\\%s\\PersistentAddinsRegistered\\%s",szClsId,szClsId1);

    StringFromGUID2( CLSID_MimeFilter, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
    WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId), NULL, NULL);

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//    7. create "CLSID\CLSID_MimeFilter\InprocServer32"
	wsprintf(szSubKey, "CLSID\\%s\\InprocServer32",szClsId);

	// filename
    GetModuleFileName(hInst, szClsId, sizeof(szClsId));

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	SetStringRegValue( hKey, "ThreadingModel", "Both" );
		RegCloseKey(hKey);
    }

}

void UnregisterFilter(LPSTR pszExt,LPSTR pszProgId,LPSTR pszDesc,GUID ClsId,GUID PersistId)
{
	//
	// remove the reg key installed
	//

	char    szSubKey[256];
	char    szClsId[128];
	OLECHAR oszClsId[128];
    HKEY    hKey;
	HKEY	hKeyExt;
	DWORD	cb = 0;

	// open HKEY_CLASSES_ROOT
	if( 0 == RegOpenKeyEx(HKEY_CLASSES_ROOT,NULL,0,KEY_ALL_ACCESS,&hKey) )
	{
		StringFromGUID2( ClsId, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
		WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId),
				NULL, NULL);

		wsprintf(szSubKey, "CLSID\\%s", szClsId);
		DeleteRegSubtree(hKey, szSubKey );

		StringFromGUID2( PersistId, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
		WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId),
				NULL, NULL);

		wsprintf(szSubKey, "CLSID\\%s", szClsId);
		DeleteRegSubtree(hKey, szSubKey );

		StringFromGUID2( CLSID_MimeFilter, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
		WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId),
				NULL, NULL);

		wsprintf(szSubKey, "CLSID\\%s", szClsId);
		DeleteRegSubtree(hKey, szSubKey );

		// open the .nws subkey
		if( 0 == RegOpenKeyEx(hKey,pszExt,0,KEY_ALL_ACCESS,&hKeyExt) )
		{
			// get size of "Content Type" value
			RegQueryValueEx(hKeyExt,"Content Type",NULL,NULL,NULL,&cb);
			RegCloseKey(hKeyExt);
		}

		if( cb != 0 )
		{
			// "Content Type" value exists. Because this was created by Athena
			// we do not want to delete the szFileExtesion or szFileType keys
			wsprintf(szSubKey, "%s\\CLSID", pszProgId);
			RegDeleteKey(hKey, szSubKey );
		}
		else
		{
			// "Content Type" does not exist so delete both keys.
			RegDeleteKey(hKey,pszExt);
			DeleteRegSubtree(hKey,pszProgId);
		}

		RegCloseKey(hKey);
	}
}

STDAPI _DllRegisterServer(HINSTANCE hInst)
{
	RegisterFilter(hInst,szNewsExt,szNewsProgId,szNewsFileDesc,CLSID_NNTPFILE,CLSID_NNTP_PERSISTENT);
	RegisterFilter(hInst,szMailExt,szMailProgId,szMailFileDesc,CLSID_MAILFILE,CLSID_MAIL_PERSISTENT);
	return S_OK;
}

STDAPI _DllUnregisterServer()
{
	UnregisterFilter(szNewsExt,szNewsProgId,szNewsFileDesc,CLSID_NNTPFILE,CLSID_NNTP_PERSISTENT);
	UnregisterFilter(szMailExt,szMailProgId,szMailFileDesc,CLSID_MAILFILE,CLSID_MAIL_PERSISTENT);
	return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    NNTP filter class factory
//
//--------------------------------------------------------------------------

extern "C" STDMETHODIMP DllGetClassObject( REFCLSID   cid,
		REFIID     iid,
		void **    ppvObj )
{

	IUnknown *  pResult = 0;
	HRESULT       hr      = S_OK;

		if ( cid == CLSID_MimeFilter )
		{
			pResult = (IUnknown *) new CMimeFilterCF;
		}
		else
		{
			hr = E_NOINTERFACE;
		}

		if ( pResult )
		{
			hr = pResult->QueryInterface( iid, ppvObj );
			pResult->Release();     // Release extra refcount from QueryInterface
		}

	return (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//--------------------------------------------------------------------------

extern "C" STDMETHODIMP DllCanUnloadNow( void )
{
	if ( 0 == gulcInstances )
		return( S_OK );
	else
		return( S_FALSE );
}

static HINSTANCE g_hInst;

extern "C" STDAPI DllRegisterServer()
{
	return _DllRegisterServer(g_hInst);
}

extern "C" STDAPI DllUnregisterServer()
{
	return _DllUnregisterServer();
}

extern "C" BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID lbv)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:

			g_hInst = hInst;

			break;

		case DLL_PROCESS_DETACH:

			break;
	}

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::CMimeFilterCF
//
//  Synopsis:   NNTP IFilter class factory constructor
//
//+-------------------------------------------------------------------------

CMimeFilterCF::CMimeFilterCF()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
	InitAsyncTrace();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::~CMimeFilterCF
//
//  Synopsis:   NNTP IFilter class factory destructor
//
//--------------------------------------------------------------------------

CMimeFilterCF::~CMimeFilterCF()
{
	TermAsyncTrace();
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilterCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    _ASSERT( (IID_IUnknown.Data1      & 0x000000FF) == 0x00 );
    _ASSERT( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp = 0;
    HRESULT hr = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( IID_IUnknown == riid )
            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x01:
        if ( IID_IClassFactory == riid )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            hr = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        hr = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }

    return(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilterCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::CreateInstance
//
//  Synopsis:   Creates new CMimeFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                            REFIID riid,
                                            void  * * ppvObject )
{
    CMimeFilter *  pIUnk = 0;
    HRESULT hr = NOERROR;

	_ASSERT( ppvObject != NULL );

	// check args
	if( ppvObject == NULL )
		return E_INVALIDARG;

	// create object
    pIUnk = new CMimeFilter(pUnkOuter);
	if( pIUnk == NULL )
		return E_OUTOFMEMORY;

	// init object
	hr = pIUnk->HRInitObject();

	if( FAILED(hr) )
	{
		delete pIUnk;
		return hr;
	}

	// get requested interface
    hr = pIUnk->QueryInterface(  riid , ppvObject );
	if( FAILED(hr) )
	{
		pIUnk->Release();
		return hr;
	}

    return (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\def_guid.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       htmlguid.hxx
//
//  Contents:   Declarations of Html properties
//
//  This code and information is provided "as is" without warranty of
//  any kind, either expressed or implied, including but not limited to
//  the implied warranties of merchantability and/or fitness for a
//  particular purpose.
//
//--------------------------------------------------------------------------

#if !defined( __HTMLGUID_HXX__ )
#define __HTMLGUID_HXX__
#include "stgprop.h"

//
// Various property sets - storage, summary information and html information
//
extern GUID CLSID_Storage;

extern GUID CLSID_NNTP_SummaryInformation;

const PID_NEWSGROUP  = 2;
const PID_NEWSGROUPS = 3;
const PID_REFERENCES = 4;
const PID_SUBJECT    = 5;
const PID_FROM       = 6;
const PID_MSGID      = 7;
const PID_EXTRA      = 8;

// extern GUID CLSID_NNTPInformation;
extern GUID CLSID_NNTPFILE ;
extern GUID CLSID_NNTP_PERSISTENT ;
extern GUID CLSID_MimeFilter;
extern GUID CLSID_InsoUniversalFilter;
extern GUID CLSID_MAILFILE ;
extern GUID CLSID_MAIL_PERSISTENT ;


// extern GUID CLSID_HtmlInformation;

// const DOC_TITLE = 2;

#endif // __HTMLGUID_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\imalcspy\heapdet.cpp ===
#define	_HEAPDET_INTERNAL_

#include    <stdio.h>
#include    <windows.h>
#include    <dbgtrace.h>
#include    <objbase.h>
#include    <objidl.h>
#include "HeapDet.h"

HMODULE	CoHeapDetective::g_HeapdetLib = 0 ;
long	CoHeapDetective::g_cLibRefs = 0 ;


CoHeapDetective*
CoHeapDetective::GetDetective()	{

	if( InterlockedIncrement( &g_cLibRefs ) == 1 ) {

		g_HeapdetLib = LoadLibrary( "heapdet.dll" ) ;

	}

	return	new	CoHeapDetective() ;
}

// initialize data members
CoHeapDetective::CoHeapDetective() :
	m_cRefs( 1 )	{

	TraceFunctEnter("CoHeapDetective::CoHeapDetective");
	m_cbLastAlloc = 0;
	m_pvLastRealloc = 0;
	m_dwBytesAlloced = 0;

	m_list.m_pNext = &m_list ;
	m_list.m_pPrev = &m_list ;

	TraceFunctLeave();
}

CoHeapDetective::~CoHeapDetective() {
	TraceFunctEnter("CoHeapDetective::~CoHeapDetective");
	if (m_dwBytesAlloced == 0) {
		DebugTrace(0, "shutting down, no leaks");
	} else {
		ErrorTrace(0, "%lu leaked", m_dwBytesAlloced);
		DebugBreak();
	}
	TraceFunctLeave();
}

// return the current byte count
SIZE_T
CoHeapDetective::GetBytesAlloced() const
{
	return m_dwBytesAlloced;
}

// optionally write trace statement to output device
void
CoHeapDetective::Trace(SIZE_T cb, PVOID pv, LPCTSTR szAction, BOOL bSuccess)
{
	TraceQuietEnter("CoHeapDetective::Trace");

  	StateTrace((DWORD_PTR) pv, "%p at 0x%x bytes were %s%s", cb, pv, szAction,
		(bSuccess ? "." : "...NOT!"));
	BinaryTrace((DWORD_PTR) pv, (BYTE *) pv, (DWORD)cb);
}

// write signature and alloc size
void
CoHeapDetective::SetArenaHeader(void *ptr, SIZE_T dwAllocSize)
{
	if (ptr)
	{
		ArenaHeader& arena = *((ArenaHeader *)ptr);
		arena.m_dwSignature = ArenaHeader::SIGNATURE;
		arena.m_dwAllocSize = dwAllocSize;
	}
}

// return pointer to valid header or null
CoHeapDetective::ArenaHeader *
CoHeapDetective::GetHeader(void *ptr)
{
	ArenaHeader *result = 0;
	if (ptr) {
		result = (ArenaHeader *)(LPBYTE(ptr)-sizeof(ArenaHeader));
		if (result->m_dwSignature != ArenaHeader::SIGNATURE) {
			_ASSERT(FALSE);
		}
	}
	return result;
}

// IUnknown Methods ////////////////////

STDMETHODIMP
CoHeapDetective::QueryInterface(REFIID riid, void**ppv)
{
	if (riid == IID_IUnknown || riid == IID_IMallocSpy) {
		LPUNKNOWN(*ppv = (IMallocSpy*)this)->AddRef();
		return S_OK;
	} else {
		*ppv = 0;
		return E_NOINTERFACE;
	}
}

//
// this object is global and doesn't hold server, so punt
//
STDMETHODIMP_(ULONG)
CoHeapDetective::AddRef()
{
	return InterlockedIncrement( &m_cRefs ) ;
}

STDMETHODIMP_(ULONG)
CoHeapDetective::Release()
{
	long	lReturn = InterlockedDecrement( &m_cRefs ) ;
	if( lReturn == 0 ) {
		delete	this ;
	}
	if( InterlockedDecrement( &g_cLibRefs ) == 0 ) {
		FreeLibrary( g_HeapdetLib ) ;
	}
	return	ULONG(lReturn) ;
}

// IMallocSpy Methods //////////////////

//
// PreAlloc reserves space for our arena header
//
STDMETHODIMP_(SIZE_T)
CoHeapDetective::PreAlloc(SIZE_T cbRequest)
{
	// cache user request for post processing
	m_cbLastAlloc = cbRequest;
	// reserve space for arena header	
	return cbRequest + sizeof(ArenaHeader);
}

//
// PostAlloc writes the arena header and updates the alloc count
//
STDMETHODIMP_(void*)
CoHeapDetective::PostAlloc(void *pActual)
{
	LPBYTE result = LPBYTE(pActual);
	if (pActual) {
		// write arena header
		SetArenaHeader(pActual, m_cbLastAlloc);

		//
		//	Link into the list !
		//
		ArenaHeader *phdr = (ArenaHeader*)pActual ;
		phdr->m_pNext = m_list.m_pNext ;
		phdr->m_pPrev = &m_list ;
		phdr->m_pNext->m_pPrev = phdr ;
		m_list.m_pNext = phdr ;




		// adjust result
		result += sizeof(ArenaHeader);
		// tally allocation
	    m_dwBytesAlloced += m_cbLastAlloc;
	}
	Trace(m_cbLastAlloc, pActual, __TEXT("alloced"), pActual != 0);
	return result;
}


//
// PreFree verifies the header, and adjusts the alloc count
//
STDMETHODIMP_(void*)
CoHeapDetective::PreFree(void *pRequest, BOOL fSpyed)
{
	LPBYTE result = LPBYTE(pRequest);

	if (pRequest && fSpyed) {

		ArenaHeader*	phdr = GetHeader( pRequest ) ;
		if( phdr ) {
			phdr->m_pNext->m_pPrev = phdr->m_pPrev ;
			phdr->m_pPrev->m_pNext = phdr->m_pNext ;
			phdr->m_pNext = 0 ;
			phdr->m_pPrev = 0 ;
		}

		// adjust result
		result -= sizeof(ArenaHeader);
		// tally deallocation
		m_dwBytesAlloced -= phdr->m_dwAllocSize;

		Trace(phdr->m_dwAllocSize, phdr, __TEXT("freed"), TRUE);
	}
	return result;
}

//
// PostFree gets called after the task allocator overwrites
// our block, so there is very little we can do
//
STDMETHODIMP_(void)
CoHeapDetective::PostFree(BOOL fSpyed)
{
}

//
// PreRealloc must verify the header, subtract the old size
// from the alloc count, and cache the arguments for PostRealloc
//
STDMETHODIMP_(SIZE_T)
CoHeapDetective::PreRealloc(void *pRequest,	SIZE_T cbRequest,
                            void **ppNewRequest, BOOL fSpyed)
{
	LPBYTE pNewRequest = LPBYTE(pRequest);

	if (fSpyed)  // it is ours
	{

		ArenaHeader*	phdr = GetHeader( pRequest ) ;
		if( phdr ) {
			phdr->m_pNext->m_pPrev = phdr->m_pPrev ;
			phdr->m_pPrev->m_pNext = phdr->m_pNext ;
			phdr->m_pNext = 0 ;
			phdr->m_pPrev = 0 ;
		}

		// cache the pointer for PostRealloc
		m_pvLastRealloc = pRequest;
		if (pRequest)  // genuine realloc
		{
			ArenaHeader *phdr = GetHeader(pRequest);
			// cache size
			m_cbLastAlloc = cbRequest;
			// adjust byte count
			m_dwBytesAlloced -= phdr->m_dwAllocSize;
			// adjust allocation to accomodate header
			cbRequest += sizeof(ArenaHeader);
			pNewRequest -= sizeof(ArenaHeader);
		}
		else  // call to realloc(0, size)
		{
			// cache size
			m_cbLastAlloc = cbRequest;
			// adjust allocation to accomodate header
			cbRequest += sizeof(ArenaHeader);
		}
	}
	*ppNewRequest = pNewRequest;
	return cbRequest;
}

//
// Post realloc must adjust the alloc count and write the
// new arena header if succeeded
//
STDMETHODIMP_(void*)
CoHeapDetective::PostRealloc(void *pActual, BOOL fSpyed)
{
	LPBYTE result = LPBYTE(pActual);
	if (fSpyed)	// it is ours
	{
		Trace(m_cbLastAlloc, pActual, __TEXT("realloced"), pActual != 0);
		if (pActual)   // realloc succeeded
		{

			//
			//	Link into the list !
			//
			ArenaHeader *phdr = (ArenaHeader*)pActual ;
			phdr->m_pNext = m_list.m_pNext ;
			phdr->m_pPrev = &m_list ;
			phdr->m_pNext->m_pPrev = phdr ;
			m_list.m_pNext = phdr ;


			// write arena header
			SetArenaHeader(pActual, m_cbLastAlloc);
			// adjust result
			result += sizeof(ArenaHeader);
			// tally allocation
			m_dwBytesAlloced += m_cbLastAlloc;
		}
		else 		   // realloc failed
		{
			// watch out for realloc(p, size) that fails (old block still valid)
			if (m_pvLastRealloc)
				m_dwBytesAlloced += GetHeader(m_pvLastRealloc)->m_dwAllocSize;
		}			
	}
	return result;
}

//
// PreGetSize simply needs to shear off and verify the header
//
STDMETHODIMP_(void*)
CoHeapDetective::PreGetSize(void *pRequest, BOOL fSpyed)
{
	LPBYTE result = LPBYTE(pRequest);
	if (fSpyed && pRequest && GetHeader(pRequest)) // it is ours and valid
	    result -= sizeof(ArenaHeader);
	return result;
}

//
// PostGetSize adjusts the size reported by sizeof(ArenaHeader)
//
STDMETHODIMP_(SIZE_T)
CoHeapDetective::PostGetSize(SIZE_T cbActual, BOOL fSpyed)
{
	return fSpyed ? (cbActual - sizeof(ArenaHeader)) : cbActual;
}


//
// PreDidAlloc simply needs to shear off and verify the header
//
STDMETHODIMP_(void*)
CoHeapDetective::PreDidAlloc(void *pRequest, BOOL fSpyed)
{
	LPBYTE result = LPBYTE(pRequest);
	if (fSpyed && pRequest  && GetHeader(pRequest)) // it is ours and valid
	    result -= sizeof(ArenaHeader);  // adjust result pointer
	return result;
}

//
// PostDidAlloc is a no-op
//
STDMETHODIMP_(int)
CoHeapDetective::PostDidAlloc(void *pRequest, BOOL fSpyed, int fActual)
{
	return fActual;
}

//
// PreHeapMinimize is a no-op
//
STDMETHODIMP_(void)
CoHeapDetective::PreHeapMinimize(void)
{
}

//
// PostHeapMinimize is a no-op
//
STDMETHODIMP_(void)
CoHeapDetective::PostHeapMinimize(void)
{
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\regutil.cpp ===
//
// regutil.cpp
//
//		functions for manipulating the registry
//

#include "mimefilt.h"


BOOL OpenOrCreateRegKey( HKEY hKey, LPCTSTR pctstrKeyName, PHKEY phKeyOut )
{
	DWORD dwDisposition;

	return (RegCreateKeyEx(hKey, pctstrKeyName, 0, NULL,
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, NULL,
			phKeyOut, &dwDisposition ) == ERROR_SUCCESS );
}


BOOL GetStringRegValue( HKEY hKeyRoot,
		LPCTSTR lpcstrKeyName, LPCTSTR lpcstrValueName,
		LPTSTR ptstrValue, DWORD dwMax )
{
	HKEY hKey;

	if( RegOpenKeyEx( hKeyRoot, lpcstrKeyName,
			0, KEY_READ, &hKey ) != ERROR_SUCCESS )
		return FALSE;

	if( ! GetStringRegValue( hKey, lpcstrValueName, ptstrValue, dwMax ) )
	{
		RegCloseKey( hKey );
		return FALSE;
	}

	RegCloseKey( hKey );
	return TRUE;
}


BOOL GetStringRegValue( HKEY hkey,
		LPCTSTR lpcstrValueName,
		LPTSTR ptstrValue, DWORD dwMax )
{
	DWORD dwType;

	if( RegQueryValueEx( hkey, lpcstrValueName, NULL, &dwType,
			(PBYTE) ptstrValue, &dwMax ) != ERROR_SUCCESS ||
			dwType != REG_SZ )
	{
		return FALSE;
	}

	return TRUE;
}


BOOL SetStringRegValue( HKEY hKey,
		LPCTSTR lpcstrValueName,
		LPCTSTR lpcstrString )
{
	return RegSetValueEx( hKey, lpcstrValueName, 0, REG_SZ,
			(PBYTE) lpcstrString,
			lstrlen(lpcstrString) + 1 ) == ERROR_SUCCESS ;
}


BOOL SetStringRegValue( HKEY hKeyRoot,
		LPCTSTR lpcstrKeyName,
		LPCTSTR lpcstrValueName,
		LPCTSTR lpcstrString )
{
	HKEY hKey;
	BOOL fOk;

	if(!OpenOrCreateRegKey(hKeyRoot,
			lpcstrKeyName,
			&hKey ) )
		return FALSE;

	fOk = SetStringRegValue( hKey, lpcstrValueName, lpcstrString );

	RegCloseKey( hKey );

	return fOk;
}


BOOL GetDwordRegValue( HKEY hKeyRoot, LPCTSTR lpcstrKeyName,
		LPCTSTR lpcstrValueName, PDWORD pdw )
{
	HKEY hKey;

	if( RegOpenKeyEx( hKeyRoot, lpcstrKeyName,
			0, KEY_READ, &hKey ) != ERROR_SUCCESS )
		return FALSE;

	if( !GetDwordRegValue( hKey, lpcstrValueName, pdw ) )
	{
		RegCloseKey( hKey );
		return FALSE;
	}

	RegCloseKey( hKey );
	return TRUE;
}

BOOL GetDwordRegValue( HKEY hKey,
		LPCTSTR lpcstrValueName,
		PDWORD pdw )
{
	DWORD dwType;
	DWORD dwSize;

	dwSize = sizeof(DWORD);
	if( RegQueryValueEx( hKey, lpcstrValueName, NULL, &dwType,
			(PBYTE) pdw, &dwSize ) != ERROR_SUCCESS ||
			dwType != REG_DWORD )
	{
		return FALSE;
	}

	return TRUE;
}

BOOL SetDwordRegValue( HKEY hKeyRoot,
		LPCTSTR lpcstrKeyName,
		LPCTSTR lpcstrValueName,
		DWORD dwValue )
{
	HKEY hKey;
	BOOL fOk;

	if( ! OpenOrCreateRegKey(hKeyRoot,
			lpcstrKeyName,
			&hKey ) )
		return FALSE;

	fOk = RegSetValueEx( hKey, lpcstrValueName, 0, REG_DWORD,
			(PBYTE) &dwValue, sizeof(DWORD) ) == ERROR_SUCCESS ;

	RegCloseKey( hKey );

	return fOk;
}


BOOL SetDwordRegValue( HKEY hKey,
		LPCTSTR lpcstrValueName,
		DWORD dwValue )
{
	return RegSetValueEx( hKey, lpcstrValueName, 0, REG_DWORD,
			(PBYTE) &dwValue, sizeof(DWORD) ) == ERROR_SUCCESS ;
}


void
DeleteRegSubtree( HKEY hkey, LPCSTR pcstrSubkeyName )
{
	CHAR szName[MAX_PATH];
	DWORD cbName;
	FILETIME ft;
	HKEY hkeySubkey;

	if (RegOpenKeyEx( hkey, pcstrSubkeyName, 0, KEY_ALL_ACCESS, &hkeySubkey ) == ERROR_SUCCESS) {

    	for(;;)
	    {
		    cbName = sizeof(szName);
    		if( RegEnumKeyEx( hkeySubkey, 0, szName, &cbName, 0, NULL,
				NULL, &ft ) != ERROR_SUCCESS )
	    	{
		    	break;
    		}

	    	DeleteRegSubtree( hkeySubkey, szName );
	    }

    	RegCloseKey( hkeySubkey );
    }
	RegDeleteKey( hkey, pcstrSubkeyName ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\imsg\imsg.cpp ===
#include "windows.h"
#ifndef __nntpfilt_h__
#include "imsg.h"
#endif

HINSTANCE g_hInst;

extern "C" {
BOOL WINAPI RPCProxyDllMain(HINSTANCE, DWORD, LPVOID);
HRESULT STDAPICALLTYPE RPCProxyDllRegisterServer();
HRESULT STDAPICALLTYPE RPCProxyDllUnregisterServer();
HRESULT STDAPICALLTYPE RPCProxyDllGetClassObject(REFCLSID, REFIID, void **);
HRESULT STDAPICALLTYPE RPCProxyDllCanUnloadNow();
}

BOOL WINAPI DllMain(
        HINSTANCE  hinstDLL,
        DWORD  fdwReason,
        LPVOID  lpvReserved)
{
    if(fdwReason == DLL_PROCESS_ATTACH)
        g_hInst = hinstDLL;
    return RPCProxyDllMain(hinstDLL, fdwReason, lpvReserved);
}

HRESULT STDAPICALLTYPE DllRegisterServer() {
	HRESULT hr;
	WCHAR wszFilename[MAX_PATH];

	if (GetModuleFileNameW(g_hInst, wszFilename, MAX_PATH) <= 0) {
		return HRESULT_FROM_WIN32(GetLastError());
	}
	ITypeLib *ptLib;
	hr = LoadTypeLib(wszFilename, &ptLib);
	if (SUCCEEDED(hr)) {
		hr = RegisterTypeLib(ptLib, wszFilename, NULL);
		if (SUCCEEDED(hr)) {
			hr = RPCProxyDllRegisterServer();
		}
		ptLib->Release();
	}

	return hr;
}

HRESULT STDAPICALLTYPE DllUnregisterServer()
{
	HRESULT hr;
	WCHAR wszFilename[MAX_PATH];

	// load the type library from our module
	if (GetModuleFileNameW(g_hInst, wszFilename, MAX_PATH) <= 0) {
		return HRESULT_FROM_WIN32(GetLastError());
	}

	ITypeLib *ptLib;
	hr = LoadTypeLib(wszFilename, &ptLib);
	if (SUCCEEDED(hr)) {
		// get the type library properties
		TLIBATTR *pTLAttributes;
		hr = ptLib->GetLibAttr(&pTLAttributes);
		if (SUCCEEDED(hr)) {
			// unregister the type library using those properties
			hr = UnRegisterTypeLib(pTLAttributes->guid, 
								   pTLAttributes->wMajorVerNum, 
								   pTLAttributes->wMinorVerNum,
								   pTLAttributes->lcid,
								   pTLAttributes->syskind);
		
			if (SUCCEEDED(hr)) {
				hr = RPCProxyDllRegisterServer();
				if (SUCCEEDED(hr)) {
					hr = RPCProxyDllUnregisterServer();
				}
			}
		}
		ptLib->Release();
	}

	return hr;
}

HRESULT STDAPICALLTYPE DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv) {
	return RPCProxyDllGetClassObject(rclsid, riid, ppv);
}

HRESULT STDAPICALLTYPE DllCanUnloadNow() {
	return RPCProxyDllCanUnloadNow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\imsg\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the Server
	Extension Object resources.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	11/26/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\isquery\utest\testqry.cpp ===
#include <windows.h>
#include <stdio.h>
#include <isquery.h>
#include <dbgtrace.h>

void dotest(int argc, char **argv) {
    CIndexServerQuery isq;
    WCHAR wszQueryString[4096];
    HRESULT hr;
    PROPVARIANT *rgpvResults[7 * 6];
    BOOL fMore;

    *wszQueryString = 0;
    for (int i = 1; i < argc; i++) {
        WCHAR wszBuf[1024];

        MultiByteToWideChar(CP_ACP, 0, argv[i], -1, wszBuf, sizeof(wszBuf));
        printf("%s -> %ws\n", argv[i], wszBuf);
        lstrcatW(wszQueryString, wszBuf);
        if (i != argc - 1) lstrcatW(wszQueryString, L" ");
    }

    printf("making query \"%ws\"\n", wszQueryString);
    WCHAR szColumns[256];
    lstrcpyW(szColumns, L"newsgroup,newsarticleid,newsmsgid,newsfrom,newssubject,filename");
    hr = isq.MakeQuery( TRUE, wszQueryString, NULL, L"Web", NULL, 
                       szColumns, szColumns);
    if (FAILED(hr)) {
        printf("MakeQuery failed with 0x%08x\n", hr);
        return;
    }

    printf("results:\n");
    DWORD c = 0;
    do {
        DWORD cResults = 7;
        hr = isq.GetQueryResults(&cResults, rgpvResults, &fMore);
        if (FAILED(hr)) {
            printf("GetQueryResults failed with 0x%08x\n", hr);
            return;
        }
        for (DWORD i = 0; i < cResults; i++) {
            PROPVARIANT **ppvRow = rgpvResults + (6 * i);
			WCHAR *wszNewsgroup = L"badtype";
			DWORD dwArticleID = 0xffffffff;
			WCHAR *wszMessageID = L"badtype";
			WCHAR *wszFrom = L"badtype";
			WCHAR *wszSubject = L"badtype";
			WCHAR *wszFilename = L"badtype";

            if (ppvRow[0]->vt == VT_LPWSTR) wszNewsgroup = ppvRow[0]->pwszVal;
            if (ppvRow[1]->vt == VT_UI4) dwArticleID = ppvRow[1]->uiVal;
            if (ppvRow[2]->vt == VT_LPWSTR) wszMessageID = ppvRow[2]->pwszVal;
            if (ppvRow[3]->vt == VT_LPWSTR) wszFrom = ppvRow[3]->pwszVal;
            if (ppvRow[4]->vt == VT_LPWSTR) wszSubject = ppvRow[4]->pwszVal;
            if (ppvRow[5]->vt == VT_LPWSTR) wszFilename = ppvRow[5]->pwszVal;
            printf("%3i. Newsgroup-ArticleID: %ws:%lu\n     Message-ID: <%ws>\n     From: %ws\n     Subject: %ws\n     Filename: %ws\n\n", 
                c++, wszNewsgroup, dwArticleID, wszMessageID, wszFrom, 
				wszSubject, wszFilename);
        }
    } while (fMore);
    printf("end\n");
}

int __cdecl main(int argc, char **argv) {
	HRESULT hr;

    InitAsyncTrace();

	hr = CIndexServerQuery::GlobalInitialize();
	if (FAILED(hr)) {
		printf("GlobalInitialize failed with 0x%08x\n", hr);
		TermAsyncTrace();
		return 0;
	}

	dotest(argc, argv);

	hr = CIndexServerQuery::GlobalShutdown();
	if (FAILED(hr)) {
		printf("GlobalShutdown failed with 0x%08x\n", hr);
	}

    TermAsyncTrace();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\isquery\src\isquery.cpp ===
#define INC_OLE2
#define UNICODE

#include <stdio.h>
#include <windows.h>

#include <isquery.h>
#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <query.h>
#include <ntquery.h>
#include <stgprop.h>
#define NTSTATUS HRESULT
#include <dbcmdtre.hxx>
#include <vquery.hxx>
#include <dbgtrace.h>

// {AA568EEC-E0E5-11cf-8FDA-00AA00A14F93}
GUID CLSID_NNTP_SummaryInformation =
{ 0xaa568eec, 0xe0e5, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

static GUID guidSystem = PSGUID_STORAGE;
static GUID guidNews = CLSID_NNTP_SummaryInformation;
static DBID dbidNewsgroup;
static DBID dbidNewsArticleID;
static DBID dbidNewsMessageID;
static DBID dbidFilename;
static DBID dbidNewsFrom;
static DBID dbidNewsSubject;
static DBID dbidPath;

static struct {
    WCHAR wszColumnName[16];
    DBID *pdbidColumn;
} rgColumnMap[] = {
    { L"filename",      &dbidFilename         },
    { L"newsarticleid", &dbidNewsArticleID    },
	{ L"path",			&dbidPath			  },
    { L"newsfrom",      &dbidNewsFrom         },
    { L"newsgroup",     &dbidNewsgroup        },
    { L"newsmsgid",     &dbidNewsMessageID    },
    { L"newssubject",   &dbidNewsSubject      },
    { NULL,             0                     }
};

static DBBINDING skelbinding = {
    0,4*0,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED,
    DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0
};

CIndexServerQuery::CIndexServerQuery() {
    m_pRowset = NULL;
    m_hAccessor = NULL;
    m_cRowHandlesInUse = 0;
    m_phRows = NULL;
	m_cPropDef = 0;
	m_pPropDef = 0;
}

HMODULE CIndexServerQuery::m_hmQuery = NULL;
PCIMAKEICOMMAND CIndexServerQuery::m_pfnCIMakeICommand = NULL;
PCITEXTTOFULLTREE CIndexServerQuery::m_pfnCITextToFullTree = NULL;

//
// global initialization for all CIndexServerQuery objects
//
HRESULT CIndexServerQuery::GlobalInitialize() {
	TraceFunctEnter("CIndexServerQuery::GlobalInitialize");
	HRESULT hr = E_FAIL;

	dbidNewsgroup.uGuid.pguid = &guidNews;
	dbidNewsgroup.eKind = DBKIND_PGUID_PROPID;
	dbidNewsgroup.uName.ulPropid = 0x2;

	dbidNewsArticleID.uGuid.pguid = &guidNews;
	dbidNewsArticleID.eKind = DBKIND_PGUID_PROPID;
	dbidNewsArticleID.uName.ulPropid = 0x3c;

	dbidNewsMessageID.uGuid.pguid = &guidNews;
	dbidNewsMessageID.eKind = DBKIND_PGUID_PROPID;
	dbidNewsMessageID.uName.ulPropid = 0x7;

	dbidFilename.uGuid.pguid = &guidSystem;
	dbidFilename.eKind = DBKIND_PGUID_PROPID;
	dbidFilename.uName.ulPropid = 0xa;

	dbidPath.uGuid.pguid = &guidSystem;
	dbidPath.eKind = DBKIND_PGUID_PROPID;
	dbidPath.uName.ulPropid = 0xb;

	dbidNewsFrom.uGuid.pguid = &guidNews;
	dbidNewsFrom.eKind = DBKIND_PGUID_PROPID;
	dbidNewsFrom.uName.ulPropid = 0x6;

	dbidNewsSubject.uGuid.pguid = &guidNews;
	dbidNewsSubject.eKind = DBKIND_PGUID_PROPID;
	dbidNewsSubject.uName.ulPropid = 0x5;

	m_hmQuery = LoadLibrary(L"query.dll");
	if (m_hmQuery != NULL) {
		m_pfnCIMakeICommand = (PCIMAKEICOMMAND) GetProcAddress(m_hmQuery,
														"CIMakeICommand");
		if (m_pfnCIMakeICommand != NULL) {
			m_pfnCITextToFullTree =
				(PCITEXTTOFULLTREE) GetProcAddress(m_hmQuery,
												  "CITextToFullTree");
			if (m_pfnCITextToFullTree != NULL) {
				hr = S_OK;
			}
		}

		if (hr != S_OK) {
			hr = HRESULT_FROM_WIN32(GetLastError());
			FreeLibrary(m_hmQuery);
			m_hmQuery = NULL;
			m_pfnCIMakeICommand = NULL;
			m_pfnCITextToFullTree = NULL;
		} else {
			_ASSERT(m_pfnCIMakeICommand != NULL);
			_ASSERT(m_pfnCITextToFullTree != NULL);
			_ASSERT(hr == S_OK);
		}
	} else {
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	TraceFunctLeave();
	return hr;
}

//
// undo the work that was done in GlobalInitialize
//
HRESULT CIndexServerQuery::GlobalShutdown() {
	TraceFunctEnter("CIndexServerQuery::GlobalShutdown");

	if (m_hmQuery != NULL) FreeLibrary(m_hmQuery);
	m_hmQuery = NULL;

	TraceFunctLeave();
	return S_OK;
}

//
// build an Accessor for the rowset given the names of the rows that we
// are interested in.
//
// Arguments:
//  [in] wszCols - the columns that you are interested in, comma delimited
//
HRESULT CIndexServerQuery::CreateAccessor(WCHAR *szColumns) {
    TraceFunctEnter("CIndexServerQuery::CreateAccessor");

    IColumnsInfo *pColumnsInfo = NULL;
    DBBINDING rgBindings[MAX_COLUMNS];
    IAccessor *pIAccessor = NULL;
    DBID rgColumnIDs[MAX_COLUMNS];
    DBORDINAL rgMappedColumnIDs[MAX_COLUMNS];
    DWORD i, cCols;
    WCHAR *rgszColumn[MAX_COLUMNS];

    //
    // find the column names
    //
    cCols = 1;
    rgszColumn[0] = szColumns;
    for (i = 0; szColumns[i] != 0; i++) {
        if (szColumns[i] == ',') {
            // check to make sure we don't overflow rgszColumn
            if (cCols == MAX_COLUMNS) {
                ErrorTrace((DWORD_PTR) this, "too many columns passed into CreateAccessor");
                TraceFunctLeave();
                return E_INVALIDARG;
            }
            rgszColumn[cCols] = szColumns + i + 1;
            if (*rgszColumn[cCols] == 0) {
                ErrorTrace((DWORD_PTR) this, "trailing comma found in szColumns");
                TraceFunctLeave();
                return E_INVALIDARG;
            }
            cCols++;
            szColumns[i] = 0;
        }
    }

    //
    // map the column names passed in by the user into column IDs
    //
    DebugTrace((DWORD_PTR) this, "%i columns in szColumns", cCols);
    for (i = 0; i < cCols; i++) {
        DWORD j;
        for (j = 0; rgColumnMap[j].wszColumnName != NULL; j++) {
            DWORD x = lstrcmpi(rgColumnMap[j].wszColumnName, rgszColumn[i]);

            if (x == 0) {
                rgColumnIDs[i] = *(rgColumnMap[j].pdbidColumn);
                DebugTrace((DWORD_PTR) this, "Column %i is %ws", i, rgszColumn[i]);
                break;
            }
        }
        // check to make sure that we found a matching column
        if (rgColumnMap[j].wszColumnName == NULL) {
            ErrorTrace((DWORD_PTR) this, "unsupported column %ws in szColumns", rgszColumn[i]);
            TraceFunctLeave();
            return E_INVALIDARG;
        }
    }

    //
    // get a IColumnsInfo interface and use it to map the column IDs
    //
    HRESULT hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **)&pColumnsInfo);
    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "QI(IID_IColumnsInfo) returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }
    hr = pColumnsInfo->MapColumnIDs(cCols, rgColumnIDs, rgMappedColumnIDs);
    pColumnsInfo->Release();
    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "MapColumnIDs returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }

    //
    // build up the binding array
    //
    for (i = 0; i < cCols; i++) {
        memcpy(&(rgBindings[i]), &(skelbinding), sizeof(DBBINDING));
        rgBindings[i].obValue = 4 * i;
        rgBindings[i].iOrdinal = rgMappedColumnIDs[i];
    }

    //
    // get the IAccessor interface and use that to build an accessor to
    // these columns.
    //
    hr = m_pRowset->QueryInterface( IID_IAccessor, (void **)&pIAccessor);
    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "QI(IID_IAccessor) returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }
    hr = pIAccessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                    cCols, rgBindings, 0, &m_hAccessor, 0 );
    pIAccessor->Release();

    m_cCols = cCols;

    DebugTrace((DWORD_PTR) this, "returning 0x%08x", hr);
    TraceFunctLeave();
    return hr;
}

//
// release's an accessor that was created with CreateAccessor
//
void CIndexServerQuery::ReleaseAccessor() {
    TraceFunctEnter("CIndexServerQuery::ReleaseAccessor");

    IAccessor * pIAccessor = 0;

    HRESULT hr = m_pRowset->QueryInterface(IID_IAccessor, (void **)&pIAccessor);
    if (FAILED(hr)) {
        DebugTrace((DWORD_PTR) this, "QI(IID_IAccessor) returned 0x%08x", hr);
        TraceFunctLeave();
        return;
    }

    hr = pIAccessor->ReleaseAccessor( m_hAccessor, 0 );
    if (FAILED(hr)) DebugTrace((DWORD_PTR) this, "ReleaseAccessor returned 0x%08x", hr);
    m_hAccessor = NULL;
    hr = pIAccessor->Release();
    if (FAILED(hr)) DebugTrace((DWORD_PTR) this, "pAccessor->Release returned 0x%08x", hr);

    TraceFunctLeave();
}

//
// scan the query string and see if there are property names that are being
// queried that don't have friendly names.  if there are then we build up
// new friendly names
//
#define HEADERPREFIX L"@MSGH-"
#define HEADERPREFIXLEN 6
HRESULT CIndexServerQuery::BuildFriendlyNames(const WCHAR *pwszQueryString) {
	TraceFunctEnter("CIndexServerQuery::BuildFriendlyNames");
	
	const WCHAR *pwszHeaderPrefix;
	DWORD cFriendlyNames = 0;

	// count the number of friendly names in the string
	pwszHeaderPrefix = pwszQueryString;
	do {
		pwszHeaderPrefix = wcsstr(pwszHeaderPrefix, HEADERPREFIX);
		if (pwszHeaderPrefix != NULL) {
			cFriendlyNames++;
			pwszHeaderPrefix += HEADERPREFIXLEN;
		}
	} while (pwszHeaderPrefix != NULL);

	if (cFriendlyNames == 0) return S_OK;

	m_pPropDef = new CIPROPERTYDEF[cFriendlyNames];
	if (m_pPropDef == NULL) return E_OUTOFMEMORY;

	ZeroMemory(m_pPropDef, sizeof(CIPROPERTYDEF) * cFriendlyNames);

	pwszHeaderPrefix = wcsstr(pwszQueryString, HEADERPREFIX);
	while (pwszHeaderPrefix != NULL) {
		// copy from past the Mime to the next space into the friendly name
		WCHAR *pwszFriendlyName = new WCHAR[MAX_FRIENDLYNAME];
		if (pwszFriendlyName == NULL) {
			ErrorTrace((DWORD_PTR) this, "couldn't allocate mem for new friendlyname");
			TraceFunctLeave();
			return E_OUTOFMEMORY;
		}
		wcscpy(pwszFriendlyName, HEADERPREFIX + 1);
		WCHAR *pwszHeaderName = pwszFriendlyName + HEADERPREFIXLEN - 1;
		const WCHAR *p = pwszHeaderPrefix + HEADERPREFIXLEN;
		for (DWORD i = HEADERPREFIXLEN - 1; *p != 0 && *p != ' '; p++, i++) {
			if (i >= MAX_FRIENDLYNAME) {
				ErrorTrace((DWORD_PTR) this, "friendlyname %S is too long",
					pwszHeaderPrefix);
				TraceFunctLeave();
				return E_INVALIDARG;
			}
			pwszFriendlyName[i] = *p;
		}
		pwszFriendlyName[i] = 0;

		// see if this property has already been defined
		BOOL fFound = FALSE;
		for (DWORD m_iPropDef = 0; m_iPropDef < m_cPropDef; m_iPropDef++) {
			if (lstrcmpiW(m_pPropDef[m_iPropDef].wcsFriendlyName, pwszFriendlyName)) {
				fFound = TRUE;
			}
		}

		// if it hasn't been defined then add it to the list of defined
		// properties
		if (!fFound) {
			// build a new CIPROPERTYDEF
			_ASSERT(m_cPropDef <= cFriendlyNames);
			m_pPropDef[m_cPropDef].wcsFriendlyName = pwszFriendlyName;
			m_pPropDef[m_cPropDef].dbType = DBTYPE_WSTR;
			m_pPropDef[m_cPropDef].dbCol.eKind = DBKIND_GUID_NAME;
			m_pPropDef[m_cPropDef].dbCol.uGuid.guid = guidNews;
			m_pPropDef[m_cPropDef].dbCol.uName.pwszName = pwszHeaderName;

			DebugTrace((DWORD_PTR) this, "new friendly name %S", pwszFriendlyName);
			DebugTrace((DWORD_PTR) this, "pwszHeaderName = %S", pwszHeaderName);
			BinaryTrace((DWORD_PTR) this, (BYTE *) &guidNews, sizeof(guidNews));

			m_cPropDef++;
		}

		// p points to the end of the @MsgH-<header> part, where we might
		// expect to find another such word.
		pwszHeaderPrefix = wcsstr(p, HEADERPREFIX);
	}

	DebugTrace((DWORD_PTR) this, "defined %lu friendly names", m_cPropDef);
	TraceFunctLeave();
	return S_OK;
}

//
// make a query
//
// Arguments:
//  bDeepQuery - [in] TRUE if deep query, FALSE if shallow
//  pwszQueryString - [in] the Tripoli query string
//  pwszMachine - [in] the machine to query against (. for localhost)
//  pwszCatalog - [in] the catalog to query against
//  pwszScope - [in] the scope to query against
//  pwszColumns - [in] the columns to return.
//                Supports filename, newsgroup, newsarticleid
//  pwszSortOrder - [in] how to sort the above columns
//
HRESULT CIndexServerQuery::MakeQuery(BOOL bDeepQuery,
                                     WCHAR const *pwszQueryString,
                                     WCHAR const *pwszMachine,
                                     WCHAR const *pwszCatalog,
                                     WCHAR const *pwszScope,
                                     WCHAR *pwszColumns,
                                     WCHAR const *pwszSortOrder,
									 LCID LocalID,
									 DWORD const cMaxRows)
{
    TraceFunctEnter("MakeQuery");

    ULONG rgDepths[] = { bDeepQuery ? QUERY_DEEP : QUERY_SHALLOW};
    WCHAR const *rgScopes[] = { (pwszScope == NULL) ? L"\\" : pwszScope };
    WCHAR const *rgCatalogs[] = { pwszCatalog };
    WCHAR const *rgMachines[] = { (pwszMachine == NULL) ? L"." : pwszMachine };
    ICommand *pCommand = 0;

	if (m_hmQuery == NULL) {
		return E_UNEXPECTED;
	}

	_ASSERT(m_pfnCIMakeICommand != NULL);
	_ASSERT(m_pfnCITextToFullTree != NULL);

    DebugTrace((DWORD_PTR) this, "pwszQueryString = %ws", pwszQueryString);
    DebugTrace((DWORD_PTR) this, "pwszMachine = %ws", pwszMachine);
    DebugTrace((DWORD_PTR) this, "pwszCatalog = %ws", pwszCatalog);
    DebugTrace((DWORD_PTR) this, "pwszScope = %ws", pwszScope);
    DebugTrace((DWORD_PTR) this, "pwszColumns = %ws", pwszColumns);
    DebugTrace((DWORD_PTR) this, "pwszSortOrder = %ws", pwszSortOrder);

	_ASSERT(pwszColumns != NULL);
	if (pwszCatalog == NULL || pwszColumns == NULL) {
		ErrorTrace((DWORD_PTR) this, "pwszCatalog == NULL or pwszColumns == NULL");
		TraceFunctLeave();
		return E_POINTER;
	}

    _ASSERT(m_pRowset == NULL);
    if (m_pRowset != NULL) {
        ErrorTrace((DWORD_PTR) this, "MakeQuery called with pRowset != NULL");
        TraceFunctLeave();
        return E_UNEXPECTED;
    }

	HRESULT hr = BuildFriendlyNames(pwszQueryString);
	if (FAILED(hr)) return hr;

    DebugTrace((DWORD_PTR) this, "calling CIMakeICommand");
    hr = m_pfnCIMakeICommand(&pCommand,
                               1,
                               rgDepths,
                               (WCHAR const * const *) rgScopes,
                               (WCHAR const * const *) rgCatalogs,
                               (WCHAR const * const *) rgMachines);

    if (SUCCEEDED(hr))
    {
        const unsigned MAX_PROPS = 8;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP aProp[MAX_PROPS];
        ULONG cProps = 0;

        // We can handle PROPVARIANTs, not just ole automation variants
        static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
        static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

        aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProps].dwOptions = DBPROPOPTIONS_SETIFCHEAP;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;
        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidQueryExt;
        cProps++;

        ICommandProperties *pCmdProp = 0;
        hr = pCommand->QueryInterface(IID_ICommandProperties,
                                      (void **)&pCmdProp);
        if (SUCCEEDED(hr)) {
            DebugTrace((DWORD_PTR) this, "calling SetProperties");
            hr = pCmdProp->SetProperties( cProps, aPropSet );
            pCmdProp->Release();
        }

        DBCOMMANDTREE *pTree;
        DebugTrace((DWORD_PTR) this, "calling CITextToFullTree");
        hr = m_pfnCITextToFullTree(pwszQueryString,       // query
                              	   pwszColumns,           // columns
                              	   pwszSortOrder,         // sort
                              	   0,                     // grouping
                              	   &pTree,                // resulting tree
                              	   m_cPropDef,            // custom properties
                              	   m_pPropDef,            // custom properties
                                   LocalID);      		  // default locale

		//
		// if the max rows is specified then set this property at the
		// top of the command tree
		//
		if (cMaxRows != 0) {
			DBCOMMANDTREE *pdbTop = (DBCOMMANDTREE *) CoTaskMemAlloc(sizeof(DBCOMMANDTREE));
			ZeroMemory(pdbTop, sizeof(DBCOMMANDTREE));
			pdbTop->pctFirstChild = pTree;
			pdbTop->op = DBOP_top;
			pdbTop->wKind = DBVALUEKIND_UI4;
			pdbTop->value.ulValue = cMaxRows;
			pTree = pdbTop;
		}

        if (SUCCEEDED(hr)) {
            ICommandTree *pCmdTree = NULL;
            hr = pCommand->QueryInterface(IID_ICommandTree,
                                          (void **)&pCmdTree);

            DebugTrace((DWORD_PTR) this, "calling SetCommandTree");
            hr = pCmdTree->SetCommandTree(&pTree, DBCOMMANDREUSE_NONE, FALSE);
            pCmdTree->Release();
            IRowset *pRowset = 0;

            if (SUCCEEDED(hr)) {
                DebugTrace((DWORD_PTR) this, "calling Execute");
                hr = pCommand->Execute(0,            // no aggr. IUnknown
                                       IID_IRowset,  // IID for i/f to return
                                       0,            // disp. params
                                       0,            // chapter
                                       (IUnknown **) &pRowset );

	            if (SUCCEEDED(hr))
	            {
	                DebugTrace((DWORD_PTR) this, "calling CreateAccessor");
	
	                m_pRowset = pRowset;
	
	                hr = CreateAccessor(pwszColumns);
	
	                m_fNoMoreRows = FALSE;
	                m_phRows = NULL;
	                m_cRowHandlesInUse = 0;
	                m_cRowHandlesAllocated = 0;
	            }
			}
        }
        pCommand->Release();
    }

    DebugTrace((DWORD_PTR) this, "returning 0x%08x", hr);
    TraceFunctLeave();
    return hr;
}

//
// Get back some query results after making a query
//
// Arguments:
//  pcResults - [in/out] The number of results to retrieve.  When the function
//              returns is has the number of results retrieved
//  ppvResults - [out] The array of propvariant pointers to receive the results
//  pfMore - [out] Set to FALSE when there are no more results to retrieve
//
HRESULT CIndexServerQuery::GetQueryResults(DWORD *pcResults,
                                           PROPVARIANT **ppvResults,
                                           BOOL *pfMore)
{
    TraceFunctEnter("GetQueryResults");

    HRESULT hr;
    DBCOUNTITEM cDesiredRows;
    DBCOUNTITEM iCurrentRow;

    // check to make sure that they've called MakeQuery successfully
    if (m_pRowset == NULL) {
        ErrorTrace((DWORD_PTR) this, "GetQueryResults called without MakeQuery");
        TraceFunctLeave();
        return E_UNEXPECTED;
    }

    if (m_fNoMoreRows) {
        *pfMore = FALSE;
        TraceFunctLeave();
        return S_OK;
    }

    cDesiredRows = *pcResults;
    *pcResults = 0;
    *pfMore = TRUE;

    if (m_cRowHandlesInUse != 0) {
        m_pRowset->ReleaseRows(m_cRowHandlesInUse, m_phRows, 0, 0, 0);
        m_cRowHandlesInUse = 0;
        if (cDesiredRows > m_cRowHandlesAllocated) {
            delete[] m_phRows;
            m_phRows = NULL;
            m_cRowHandlesAllocated = 0;
        }
    }

    // allocate memory for the row handles
    if (cDesiredRows > m_cRowHandlesAllocated) {
        _ASSERT(m_phRows == NULL);
        m_phRows = new HROW[(size_t)cDesiredRows];
        if (m_phRows == NULL) {
            DebugTrace((DWORD_PTR) this, "out of memory trying to alloc %lu row handles", cDesiredRows);
            return E_OUTOFMEMORY;
        }
        m_cRowHandlesAllocated = cDesiredRows;
    }

    // fetch some more rows from tripoli
    DebugTrace((DWORD_PTR) this, "getting more tripoli rows");
    hr = m_pRowset->GetNextRows(0,
                                0,
                                cDesiredRows,
                                &m_cRowHandlesInUse,
                                &m_phRows);

    DebugTrace((DWORD_PTR) this, "GetNextRows returned %lu rows", m_cRowHandlesInUse);

    // check for end of rowset
    if (hr == DB_S_ENDOFROWSET) {
        DebugTrace((DWORD_PTR) this, "GetNextRows returned end of rowset");
        hr = S_OK;
        m_fNoMoreRows = TRUE;
        *pfMore = FALSE;
    }

    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "GetNextRows failed with 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }

    // get the data for each of the rows
    for (iCurrentRow = 0; iCurrentRow < m_cRowHandlesInUse; iCurrentRow++) {
        // fetch the data for this row
        hr = m_pRowset->GetData(m_phRows[iCurrentRow], m_hAccessor,
                                ppvResults + ((*pcResults) * m_cCols));
        if (FAILED(hr)) {
            ErrorTrace((DWORD_PTR) this, "GetData failed with 0x%08x", hr);
            TraceFunctLeave();
            return hr;
        } else {
            (*pcResults)++;
        }
    }

    DebugTrace((DWORD_PTR) this, "*pcResults = %lu, *pfMore = %lu", *pcResults, *pfMore);

    TraceFunctLeave();
    return hr;
}

CIndexServerQuery::~CIndexServerQuery() {
    TraceFunctEnter("CIndexServerQuery");

	// clean up any custom named properties
	if (m_cPropDef != 0) {
		while (m_cPropDef-- != 0) {
			delete[] m_pPropDef[m_cPropDef].wcsFriendlyName;
		}
		delete[] m_pPropDef;
	} else {
		_ASSERT(m_pPropDef == NULL);
	}
    if (m_cRowHandlesInUse != 0) {
        m_pRowset->ReleaseRows(m_cRowHandlesInUse, m_phRows, 0, 0, 0);
        m_cRowHandlesInUse = 0;
    }
    if (m_phRows != NULL) {
        delete[] m_phRows;
        m_phRows = NULL;
        m_cRowHandlesAllocated = 0;
    }

    if (m_pRowset != NULL) {
        if (m_hAccessor != NULL) {
            DebugTrace((DWORD_PTR) this, "releasing accessor");
            ReleaseAccessor();
        }
        DebugTrace((DWORD_PTR) this, "releasing rowset");
        m_pRowset->Release();
        m_pRowset = NULL;
    }

    TraceFunctLeave();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\cthdutil.h ===
#ifndef __CTHDUTIL_H__
#define __CTHDUTIL_H__

class CRandomNumber
{
  public:

	CRandomNumber(
				DWORD	dwSeed = 0
				);

	~CRandomNumber();

	void SetSeed(
				DWORD	dwSeed
				);

	DWORD Rand();

	DWORD Rand(
				DWORD	dwLower,
				DWORD	dwUpper
				);

	DWORD Rand25(
				DWORD	dwMedian
				);

	DWORD Rand50(
				DWORD	dwMedian
				);

	DWORD Rand75(
				DWORD	dwMedian
				);

  private:

	DWORD		m_dwSeed;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\cthrdapp.cpp ===
#include <stdio.h>
#include <windows.h>

#include "cthrdapp.h"

//
// An instance of the application
//
CMultiThreadedApp	theApp;

// 
// We actually implement main()
//
int __cdecl main (int argc, char *argv[])
{
	HRESULT				hrRes = S_OK;

	do
	{
		//
		// Call the prologue code
		//
		hrRes = Prologue(argc, argv);
		if (!SUCCEEDED(hrRes))
			break;

		//
		// Make sure the prologue code called SetApplicationParameters
		//
		if (!theApp.IsPoolCreated())
		{
			puts("Run time error: Thread pool not created in Prologue( ... )");
			puts("Program terminating abnormally.");
			break;
		}

		//
		// We unleash the thread pool, and let it do its work ...
		//
		hrRes = theApp.GetPool().SignalThreadPool();
		if (!SUCCEEDED(hrRes))
		{
			printf("Run time error: Unable to signal threads, error %08x\n", hrRes);
			puts("Program terminating abnormally.");
			break;
		}

		//
		// Wait for the pool to return, while generating notifications
		//
		hrRes = theApp.GetPool().WaitForAllThreadsToTerminate(
					theApp.GetNotifyPeriod(),
					NotificationProc,
					theApp.GetCallbackContext());

		//
		// OK, pass the information to the epilogue code
		//
		hrRes = Epilogue(
					theApp.GetCallbackContext(),
					hrRes);

	} while (0);

	//
	// Always call the cleanup function
	//
	CleanupApplication();

	return((int)hrRes);
}

CMultiThreadedApp::CMultiThreadedApp()
{
	m_fPoolCreated = FALSE;
	m_dwNotifyPeriod = 0;
	m_pvCallBackContext = NULL;
}

CMultiThreadedApp::~CMultiThreadedApp()
{
}

BOOL CMultiThreadedApp::IsPoolCreated()
{ 
	return(m_fPoolCreated); 
}

CThreadPool &CMultiThreadedApp::GetPool()
{
	return(m_Pool);
}

DWORD CMultiThreadedApp::GetNotifyPeriod()
{
	return(m_dwNotifyPeriod);
}

LPVOID CMultiThreadedApp::GetCallbackContext()
{
	return(m_pvCallBackContext);
}

HRESULT CMultiThreadedApp::CreateThreadPool(
			DWORD		dwThreads,
			LPVOID		*rgpvContexts,
			LPVOID		pvCallbackContext,
			DWORD		dwWaitNotificationPeriodInMilliseconds,
			DWORD		*pdwThreadsCreated
			)
{
	HRESULT	hrRes;
	
	if (!pdwThreadsCreated)
		return(E_INVALIDARG);

	m_dwNotifyPeriod = dwWaitNotificationPeriodInMilliseconds;
	m_pvCallBackContext = pvCallbackContext;
	
	hrRes = m_Pool.CreateThreadPool(
				dwThreads,
				pdwThreadsCreated,
				ThreadProc,
				rgpvContexts);

	if (SUCCEEDED(hrRes))
		m_fPoolCreated = TRUE;

	return(hrRes);
}

HRESULT CMultiThreadedApp::StartTimer(
			DWORD		*pdwStartMarker
			)
{
	*pdwStartMarker = GetTickCount();
	return(S_OK);
}

HRESULT CMultiThreadedApp::AddElapsedToTimer(
			DWORD		*pdwElapsedTime,
			DWORD		dwStartMarker
			)
{
	InterlockedExchangeAdd((PLONG)pdwElapsedTime, (LONG)(GetTickCount() - dwStartMarker));
	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\cthdutil.cpp ===
#include <windows.h>

#include "macros.h"
#include "cthdutil.h"

#include "stdlib.h"

#define SPINLOCK_ACQUIRED	1
#define SPINLOCK_AVAILABLE	0

CRandomNumber::CRandomNumber(
			DWORD	dwSeed
			)
{
	srand((unsigned int)dwSeed);
}

CRandomNumber::~CRandomNumber()
{
}

void CRandomNumber::SetSeed(
			DWORD	dwSeed
			)
{
	srand((unsigned int)dwSeed);
}

DWORD CRandomNumber::Rand()
{
	return((DWORD)rand());
}

DWORD CRandomNumber::Rand(
			DWORD	dwLower,
			DWORD	dwUpper
			)
{
	return(MulDiv(Rand(), dwUpper-dwLower, RAND_MAX + 1) + dwLower);
}

DWORD CRandomNumber::Rand25(
			DWORD	dwMedian
			)
{
	DWORD	dwUpper, dwLower;

	GET_25_PERCENT_RANGE(dwMedian, dwLower, dwUpper);
	return(Rand(dwLower, dwUpper));
}

DWORD CRandomNumber::Rand50(
			DWORD	dwMedian
			)
{
	DWORD	dwUpper, dwLower;

	GET_50_PERCENT_RANGE(dwMedian, dwLower, dwUpper);
	return(Rand(dwLower, dwUpper));
}

DWORD CRandomNumber::Rand75(
			DWORD	dwMedian
			)
{
	DWORD	dwUpper, dwLower;

	GET_75_PERCENT_RANGE(dwMedian, dwLower, dwUpper);
	return(Rand(dwLower, dwUpper));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\crnddata.cpp ===
#include <windows.h>

#include "addr821.hxx"
#include "crnddata.h"

#define DATA_LEADER			(DWORD)'vLDS'
#define DATA_TRAILER		(DWORD)'vTDS'

CRandomData::CRandomData(
			DWORD	dwSeed
			)
			: CRandomNumber(dwSeed)
{
	m_rgNames = NULL;
	m_rgDomains = NULL;
	m_dwNames = 0;
	m_dwDomains = 0;
}

CRandomData::~CRandomData()
{
	FreeNames();
	FreeDomains();
}

void CRandomData::FreeNames()
{
	if (m_rgNames)
	{
		LPSTR	*pTemp = m_rgNames;
		while (m_dwNames--)
			HeapFree(GetProcessHeap(), 0, *pTemp++);
		HeapFree(GetProcessHeap(), 0, m_rgNames);
	}
	m_rgNames = NULL;
}

void CRandomData::FreeDomains()
{
	if (m_rgDomains)
	{
		LPSTR	*pTemp = m_rgDomains;
		while (m_dwDomains--)
			HeapFree(GetProcessHeap(), 0, *pTemp++);
		HeapFree(GetProcessHeap(), 0, m_rgDomains);
	}
	m_rgDomains = NULL;
}

HRESULT CRandomData::GenerateRandomData(
			LPSTR	pData,
			DWORD	dwAvgLength,
			DWORD	*pdwLength
			)
{
	DWORD	dwLength;
	DWORD	dwCheckSum = 0;
	LPDWORD	pdwPtr = (LPDWORD)pData;
	
	dwLength = Rand75(dwAvgLength);

	dwLength >>= 2;
	*pdwLength = (dwLength << 2) + RANDOM_DATA_OVERHEAD;
	*pdwPtr++ = DATA_LEADER;
	*pdwPtr++ = dwLength;
	while (dwLength--)
	{
		*pdwPtr = Rand();
		*pdwPtr &= 0x7f7f7f7f;
		dwCheckSum += *pdwPtr++;
	}
	*pdwPtr++ = dwCheckSum;
	*pdwPtr = DATA_TRAILER;
	return(S_OK);
}

HRESULT CRandomData::VerifyData(
			LPSTR	pData,
			DWORD	dwLength
			)
{
	LPDWORD	pdwPtr = (LPDWORD)pData;
	DWORD	dwCheckSum = 0;

	// Must be in DWORDS
	if (dwLength & 3 || dwLength < 12)
		return(E_FAIL);	

	dwLength -= RANDOM_DATA_OVERHEAD;
	dwLength >>= 2;

	if (*pdwPtr++ != DATA_LEADER)
		return(E_FAIL);
	if (*pdwPtr++ != dwLength)
		return(E_FAIL);
	while (dwLength--)
	{
		if (*pdwPtr & 0x80808080)
			return(E_FAIL);
		else
			dwCheckSum += *pdwPtr++;
	}
	if (*pdwPtr++ != dwCheckSum)
		return(E_FAIL);
	if (*pdwPtr != DATA_TRAILER)
		return(E_FAIL);
	return(S_OK);
}

HRESULT CRandomData::VerifyStackedData(
			LPSTR	pData,
			DWORD	dwLength,
			DWORD	*pdwBlocks
			)
{
	LPDWORD	pdwPtr = (LPDWORD)pData;
	DWORD	dwChunkLength;
	DWORD	dwCheckSum = 0;
	DWORD	dwBlocks = 0;

	// Must be in DWORDS
	if (dwLength & 3 || dwLength < RANDOM_DATA_OVERHEAD)
		return(E_FAIL);	

	dwLength >>= 2;

	while (dwLength)
	{
		dwLength -= (RANDOM_DATA_OVERHEAD >> 2);
		dwCheckSum = 0;
		
		if (*pdwPtr++ != DATA_LEADER)
			return(E_FAIL);

		dwChunkLength = *pdwPtr++;
		if (dwChunkLength > dwLength)
			return(E_FAIL);
		dwLength -= dwChunkLength;

		while (dwChunkLength--)
			if (*pdwPtr & 0x80808080)
				return(E_FAIL);
			else
				dwCheckSum += *pdwPtr++;

		if (*pdwPtr++ != dwCheckSum)
			return(E_FAIL);
		if (*pdwPtr++ != DATA_TRAILER)
			return(E_FAIL);

		dwBlocks++;
	}

	*pdwBlocks = dwBlocks;
	return(S_OK);
}

char CRandomData::GenerateNameChar(
			BOOL	fDotAllowed
			)
{
	char	ch, chout;

	chout = 0;
	do
	{
		ch = (char)Rand(0, 65);
		if (ch >= 62 && fDotAllowed)
			chout = '.';
		else if ((ch >= 0) && (ch <= 9))
			chout = '0' + ch;
		else if ((ch >= 10) && (ch <= 35))
			chout = 'a' + ch - 10;
		else if ((ch >= 36) && (ch <= 61))
			chout = 'A' + ch - 36;

	} while (!chout);

	return(chout);
}

BOOL CRandomData::GenerateDottedName(
			char	*szAlias,
			DWORD	dwLength
			)
{
	BOOL	fDotAllowed = TRUE;
	char	ch;

	if (dwLength < 3)
		return(FALSE);

	dwLength -= 3;
	*szAlias++ = GenerateNameChar(FALSE);

	while (dwLength--)
	{
		ch = GenerateNameChar(fDotAllowed);
		if (ch == '.')
			fDotAllowed = FALSE;
		else
			fDotAllowed = TRUE;
		*szAlias++ = ch;
	}

	*szAlias++ = GenerateNameChar(FALSE);
	*szAlias++ = '\0';
	return(TRUE);
}

HRESULT CRandomData::Generate821NameTable(
			DWORD	dwNumberToGenerate,
			DWORD	dwAvgLength
			)
{
	HRESULT	hrRes = S_OK;

	FreeNames();
	m_rgNames = (LPSTR *)HeapAlloc(
				GetProcessHeap(), 
				0, 
				dwNumberToGenerate * sizeof(char *));
	if (!m_rgNames)
		return(E_FAIL);

	for (DWORD i =  0; i < dwNumberToGenerate; i++)
	{
		DWORD	dwLength = Rand75(dwAvgLength);

		m_rgNames[i] = (char *)HeapAlloc(GetProcessHeap(), 0, dwLength);
		if (!m_rgNames[i])
		{
			m_dwNames = i;
			FreeNames();
			return(E_FAIL);
		}
		if (!GenerateDottedName(m_rgNames[i], dwLength))
		{
			hrRes = E_FAIL;
			m_dwNames = i;
			FreeNames();
			break;
		}
	}

	if (SUCCEEDED(hrRes))
		m_dwNames = dwNumberToGenerate;
	return(hrRes);
}

HRESULT CRandomData::Generate821DomainTable(
			DWORD	dwNumberToGenerate,
			DWORD	dwAvgLength
			)
{
	HRESULT	hrRes = S_OK;

	FreeDomains();
	m_rgDomains = (LPSTR *)HeapAlloc(
				GetProcessHeap(), 
				0, 
				dwNumberToGenerate * sizeof(char *));
	if (!m_rgDomains)
		return(E_FAIL);

	for (DWORD i =  0; i < dwNumberToGenerate; i++)
	{
		DWORD	dwLength = Rand75(dwAvgLength);

		m_rgDomains[i] = (char *)HeapAlloc(GetProcessHeap(), 0, dwLength);
		if (!m_rgDomains[i])
		{
			m_dwDomains = i;
			FreeDomains();
			return(E_FAIL);
		}
		if (!GenerateDottedName(m_rgDomains[i], dwLength))
		{
			hrRes = E_FAIL;
			m_dwDomains = i;
			FreeDomains();
			break;
		}
	}

	if (SUCCEEDED(hrRes))
		m_dwDomains = dwNumberToGenerate;
	return(hrRes);
}
		
HRESULT CRandomData::Generate821AddressFromTable(
			LPSTR	pAddress,
			DWORD	*pdwLength,
			DWORD	*pdwNameIndex,
			DWORD	*pdwDomainIndex
			)
{
	if (!m_dwNames || !m_dwDomains)
		return(E_FAIL);

	*pdwNameIndex = Rand(0, m_dwNames - 1);
	*pdwDomainIndex = Rand(0, m_dwDomains - 1);

	lstrcpy(pAddress, m_rgNames[*pdwNameIndex]);
	lstrcat(pAddress, "@");
	lstrcat(pAddress, m_rgDomains[*pdwDomainIndex]);
	*pdwLength = lstrlen(pAddress);
	return(S_OK);
}

HRESULT CRandomData::GetNameAndDomainIndicesFromAddress(
			LPSTR	pAddress,
			DWORD	dwLength,
			DWORD	*pdwNameIndex,
			DWORD	*pdwDomainIndex
			)
{
	char *pTemp = strchr(pAddress, '@');
	DWORD i, j;
	BOOL  fFound = FALSE;
	if (!pTemp)
		return(E_INVALIDARG);
	*pTemp++ = '\0';

	for (i = 0; i < m_dwNames; i++)
		if (!lstrcmpi(pAddress, m_rgNames[i]))
		{
			*pdwNameIndex = i;

			for (j = 0; j < m_dwDomains; j++)
				if (!lstrcmpi(pTemp, m_rgDomains[j]))
				{
					*pdwDomainIndex = j;
					fFound = TRUE;
					break;
				}

			if (fFound)
				break;
		}

	*--pTemp = '@';

	return(fFound?S_OK:E_FAIL);
}

HRESULT CRandomData::Generate821Name(
			LPSTR	pName,
			DWORD	dwAvgLength,
			DWORD	*pdwLength
			)
{
	*pdwLength = Rand75(dwAvgLength);
	if (!GenerateDottedName(pName, *pdwLength))
		return(E_FAIL);
	return(S_OK);
}

HRESULT CRandomData::Generate821Domain(
			LPSTR	pDomain,
			DWORD	dwAvgLength,
			DWORD	*pdwLength
			)
{
	return(Generate821Name(pDomain, dwAvgLength, pdwLength));
}
		
HRESULT CRandomData::Generate821Address(
			LPSTR	pAddress,
			DWORD	dwAvgNameLength,
			DWORD	dwAvgDomainLength,
			DWORD	*pdwLength
			)
{
	HRESULT	hrRes;
	DWORD	dwLength;
	
	hrRes = Generate821Name(pAddress, dwAvgNameLength, &dwLength);
	if (SUCCEEDED(hrRes))
	{
		pAddress += dwLength;
		*(pAddress - 1) = '@';
		hrRes = Generate821Domain(
					pAddress, 
					dwAvgDomainLength, 
					pdwLength);
		if (SUCCEEDED(hrRes))
			*pdwLength += dwLength;
	}
	return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\crnddata.h ===
#ifndef __CRNDDATA_H__
#define __CRNDDATA_H__

#include "cthdutil.h"

#define RANDOM_DATA_OVERHEAD		16

class CRandomData : public CRandomNumber
{
  public:

	CRandomData(
				DWORD	dwSeed = 0
				);

	~CRandomData();

	// Generates a block of random data
	//
	// pData - buffer to hold random data, must be at least 
	//			(1.75 * dwAvgLength) + RANDOM_DATA_OVERHEAD bytes
	// dwAvgLength - Average length of random block. The final length
	//			is dwAvgLength +/- 75% of dwAvgLength + 
	//			RANDOM_DATA_OVERHEAD bytes
	// pdwLength - returns the total length of the random block
	HRESULT GenerateRandomData(
				LPSTR	pData,
				DWORD	dwAvgLength,
				DWORD	*pdwLength
				);

	// Verifies a block of random data returned from GenerateRandomData
	//
	// pData - buffer containing data to verify
	// dwLength - Total length of data to verify
	HRESULT VerifyData(
				LPSTR	pData,
				DWORD	dwLength
				);

	// Verifies stacked blocks of random data returned from
	// GenerateRandomData, one block followed immediately by another
	//
	// pData - buffer containing data to verify
	// dwLength - Total length of data to verify
	// pdwBlocks - returns the number of blocks found
	HRESULT VerifyStackedData(
				LPSTR	pData,
				DWORD	dwLength,
				DWORD	*pdwBlocks
				);

	// Generates a table of RFC 821 names 
	//
	// dwNumberToGenerate - number of names to generate
	// dwAvgLength - average length for any name
	HRESULT Generate821NameTable(
				DWORD	dwNumberToGenerate,
				DWORD	dwAvgLength
				);

	// Generates a table of RFC 821 domains 
	//
	// dwNumberToGenerate - number of domains to generate
	// dwAvgLength - average length for any domain
	HRESULT Generate821DomainTable(
				DWORD	dwNumberToGenerate,
				DWORD	dwAvgLength
				);
			
	// Generates an RFC 821 name from the name and domain table,
	// return a full name@domain address.
	//
	// pAddress - buffer receiving the address, must be large 
	//			enough to hold the longest address in the tables.
	// pdwLength - returns the length of the resulting address,
	//			including the @ sign and trailing NULL.
	// pdwNameIndex - returns the index to its name
	// pdwDomainIndex - returns the index to its domain
	HRESULT Generate821AddressFromTable(
				LPSTR	pAddress,
				DWORD	*pdwLength,
				DWORD	*pdwNameIndex,
				DWORD	*pdwDomainIndex
				);

	// Given an address, looks up its respective name and domain
	// indices from the table
	HRESULT GetNameAndDomainIndicesFromAddress(
				LPSTR	pAddress,
				DWORD	dwLength,
				DWORD	*pdwNameIndex,
				DWORD	*pdwDomainIndex
				);

	// Generates an RFC 821 name
	//
	// pName - buffer reciving the name, must be at least 
	//			1.75 * dwAvgLength + 1
	// dwAvgLength - Average length
	// pdwLenght - returns the actual length
	HRESULT Generate821Name(
				LPSTR	pName,
				DWORD	dwAvgLength,
				DWORD	*pdwLength
				);

	// Generates an RFC 821 domain
	//
	// pDomain - buffer reciving the domain, must be at least
	// 1.75 * dwAvgLength + 1
	// dwAvgLength - Average length
	// pdwLenght - returns the actual length
	HRESULT Generate821Domain(
				LPSTR	pDomain,
				DWORD	dwAvgLength,
				DWORD	*pdwLength
				);
			
	// Generates an RFC 821 address
	//
	// pAddress - buffer reciving the address, must be at least
	//			1.5 * dwAvgNameLength + 1.5 * dwAvgDomainLength + 2
	// dwAvgNameLength - Average name length
	// dwAvgDomainLength - Average domain length
	// pdwLength - returns the actual length
	HRESULT Generate821Address(
				LPSTR	pAddress,
				DWORD	dwAvgNameLength,
				DWORD	dwAvgDomainLength,
				DWORD	*pdwLength
				);

	LPSTR		*m_rgNames;
	LPSTR		*m_rgDomains;
	DWORD		m_dwNames;
	DWORD		m_dwDomains;

  private:

	void FreeNames();

	void FreeDomains();

	char GenerateNameChar(
				BOOL	fDotAllowed
				);

	BOOL GenerateDottedName(
				char	*szAlias,
				DWORD	dwLength
				);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\cthrdapp.h ===
#ifndef __CTHRDAPP_H__
#define __CTHRDAPP_H__

#include "thrdpool.h"
#include "cthdutil.h"

class CMultiThreadedApp
{
  public:

	CMultiThreadedApp();
	~CMultiThreadedApp();

	BOOL IsPoolCreated();

	CThreadPool &GetPool();

	DWORD GetNotifyPeriod();

	LPVOID GetCallbackContext();

	HRESULT CreateThreadPool(
				DWORD		dwThreads,
				LPVOID		*rgpvContexts,
				LPVOID		pvCallbackContext,
				DWORD		dwWaitNotificationPeriodInMilliseconds,
				DWORD		*pdwThreadsCreated
				);

	HRESULT StartTimer(
				DWORD		*pdwStartMarker
				);

	HRESULT AddElapsedToTimer(
				DWORD		*pdwElapsedTime,
				DWORD		dwStartMarker
				);

  private:

	CThreadPool			m_Pool;

	BOOL				m_fPoolCreated;
	DWORD				m_dwNotifyPeriod;
	LPVOID				m_pvCallBackContext;


};

//
// Omnipresent instance of the application ...
//
extern CMultiThreadedApp	theApp;

//
// Applications must provide implementations for these functions
//
extern HRESULT Prologue(
			int		argc,
			char	*argv[]
			);

extern DWORD WINAPI ThreadProc(
			LPVOID	pvContext
			);

extern HRESULT NotificationProc(
			LPVOID	pvCallbackContext
			);

extern HRESULT Epilogue(
			LPVOID	pvCallbackContext,
			HRESULT	hrRes
			);

extern HRESULT CleanupApplication();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\macros.h ===
#ifndef __MACROS_H__
#define __MACROS_H__

//
// Macro to bail out or break the debugger
//
#define BAIL_WITH_ERROR(hrRes)			\
			{							\
				if (fUseDebugBreak)		\
					DebugBreak();		\
				else					\
					return((hrRes));	\
			}

//
// Macro to decide whether to write to the console or to the debugger
//
#define WRITE(szString)								\
			{										\
				if (fToDebugger)					\
					OutputDebugString(szString);	\
				else								\
					puts(szString);					\
			}

//
// Macro to obtain a 25%, 50%, and 75% spread range given an average
//
#define GET_25_PERCENT_RANGE(dwAverage, dwLower, dwUpper)	\
			{												\
				(dwLower) = (dwAverage) >> 2;				\
				(dwUpper) = (dwAverage) + (dwLower);		\
				(dwLower) = (dwAverage) - (dwLower);		\
			}
#define GET_50_PERCENT_RANGE(dwAverage, dwLower, dwUpper)	\
			{												\
				(dwLower) = (dwAverage) >> 1;				\
				(dwUpper) = (dwAverage) + (dwLower);		\
			}
#define GET_75_PERCENT_RANGE(dwAverage, dwLower, dwUpper)	\
			{												\
				(dwLower) = (dwAverage) - ((dwAverage) >> 2);\
				(dwUpper) = (dwAverage) + (dwLower);		\
				(dwLower) = (dwAverage) >> 2;				\
			}
					

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\parsearg.h ===
#ifndef __PARSEARG_H__
#define __PARSEARG_H__

typedef enum _ARGUMENT_TYPES
{
	AT_NONE	= 0,
	AT_STRING,
	AT_VALUE

} ARGUMENT_TYPES;

typedef struct _ARGUMENT_DESCRIPTOR
{
	BOOL			fRequired;		// Whether this is a required argument
	char			*szSwitch;		// String representing switch "-x", etc.
	char			*szUsage;		// Descriptive text for usage help
	ARGUMENT_TYPES	atType;			// Type of argument value
	LPVOID			pvReserved;		// Internal, must be initialized to NULL

} ARGUMENT_DESCRIPTOR, *LPARGUMENT_DESCRIPTOR;

class CParseArgs
{
  public:

	CParseArgs(
				char					*szAppDescription,
				DWORD					dwDescriptors,
				LPARGUMENT_DESCRIPTOR	rgDescriptors
				);

	~CParseArgs();

	HRESULT ParseArguments(
				int						argc,
				char					*argv[]
				);

	HRESULT Exists(
				DWORD	dwDescriptorIndex
				);

	HRESULT GetSwitch(
				DWORD	dwDescriptorIndex,
				BOOL	*pfExists
				);

	HRESULT GetString(
				DWORD	dwDescriptorIndex,
				char	**ppszStringValue
				);

	HRESULT GetDword(
				DWORD	dwDescriptorIndex,
				DWORD	*pdwDwordValue
				);

	HRESULT GenerateUsage(
				DWORD	*pdwLength,
				char	*szUsage
				);

	HRESULT GetErrorString(
				DWORD	*pdwLength,
				char	*szErrorString
				);

  private:

	HRESULT Cleanup();

	LPARGUMENT_DESCRIPTOR FindArgument(
				char	*szSwitch
				);

	BOOL StringToValue(
				char	*szString,
				DWORD	*pdwValue
				);

	void SetParseError(
				HRESULT	hrRes,
				char	*szSwitch
				);

	DWORD					m_dwDescriptors;
	LPARGUMENT_DESCRIPTOR	m_rgDescriptors;
	char					*m_szAppDescription;

	HRESULT					m_hrRes;
	char					m_szErrorSwitch[64];
	char					m_szBuffer[4096];

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\thrdpool.h ===
#ifndef __THRDPOOL_H__
#define __THRDPOOL_H__

typedef HRESULT (*PFN_NOTIFICATION)(LPVOID);

typedef struct _THD_CONTEXT
{
	LPVOID	pvThis;
	LPVOID	pvContext;

} THD_CONTEXT, *LPTHD_CONTEXT;

class CThreadPool
{
  public:

	CThreadPool();
	~CThreadPool();

	HRESULT CreateThreadPool(
				DWORD					dwThreads,
				DWORD					*pdwThreadsCreated,
				LPTHREAD_START_ROUTINE	pfnThreadProc,
				LPVOID					*rgpvContexts
				);

	HRESULT SignalAndDestroyThreadPool();

	HRESULT SignalThreadPool();

	HRESULT WaitForAllThreadsToTerminate(
				DWORD					dwNotificationPeriodInMilliseconds,
				PFN_NOTIFICATION		pfnNotification,
				LPVOID					pvNotificationContext
				);
				
	static DWORD WINAPI ThreadProc(
				LPVOID	pvContext
				);

	DWORD LocalThreadProc(
				LPTHD_CONTEXT	pContext
				);

  private:

	HRESULT Cleanup();

	long					m_lThreadCounter;

	HANDLE					m_hStartEvent;
	DWORD					m_dwThreads;
	HANDLE					*m_phThreads;

	LPTHREAD_START_ROUTINE	m_pfnThreadProc;
	LPTHD_CONTEXT			m_rgContexts;
	BOOL					m_fDestroy;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\atl.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:       atl.cpp
//
//  Contents:   Includes atlimpl.cpp, so that we don't rely on atl.dll
//
//  Classes:    All ATL classes.
//
//  Functions:  All ATL functions.
//
//  History:    October 23, 1997 - Milans, Created.
//
//-----------------------------------------------------------------------------

//#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include "dbgtrace.h"
#include "stdafx.h"
#include "statreg.h"
#include "statreg.cpp"
#include "atlimpl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\thrdpool.cpp ===
#include <windows.h>
#include <crtdbg.h>

#include "thrdpool.h"

CThreadPool::CThreadPool()
{
	m_hStartEvent = NULL;
	m_phThreads = NULL;
	m_dwThreads = 0;
	m_fDestroy = FALSE;
	m_pfnThreadProc = NULL;
	m_rgContexts = NULL;
	m_lThreadCounter = 0;
}

CThreadPool::~CThreadPool()
{
	Cleanup();

	_ASSERT(m_lThreadCounter == 0);
}

HRESULT CThreadPool::Cleanup()
{
	if (m_hStartEvent)
	{
		CloseHandle(m_hStartEvent);
		m_hStartEvent = NULL;
	}

	if (m_phThreads)
	{
		for (DWORD i = 0; i < m_dwThreads; i++)
		{
			if (m_phThreads[i])
			{
				CloseHandle(m_phThreads[i]);
				m_phThreads[i] = NULL;
			}
		}
		delete [] m_phThreads;
		m_phThreads = NULL;
	}

	if (m_rgContexts)
	{
		delete [] m_rgContexts;
		m_rgContexts = NULL;
	}

	m_dwThreads = 0;

	return(S_OK);
}

HRESULT CThreadPool::CreateThreadPool(
			DWORD					dwThreads,
			DWORD					*pdwThreadsCreated,
			LPTHREAD_START_ROUTINE	pfnThreadProc,
			LPVOID					*rgpvContexts
			)
{
	DWORD	dwThreadId;

	if (m_hStartEvent || m_phThreads)
		return(E_FAIL);

	if (!pdwThreadsCreated ||
		!pfnThreadProc)
		return(E_INVALIDARG);

	m_hStartEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (!m_hStartEvent)
		return(E_OUTOFMEMORY);

	m_phThreads = new HANDLE [dwThreads];
	if (!m_phThreads)
	{
		Cleanup();
		return(E_OUTOFMEMORY);
	}

	m_rgContexts = new THD_CONTEXT [dwThreads];
	if (!m_rgContexts)
	{
		Cleanup();
		return(E_OUTOFMEMORY);
	}

	for (DWORD i = 0; i < dwThreads; i++)
	{
		m_rgContexts[i].pvThis = (LPVOID)this;
		m_rgContexts[i].pvContext = rgpvContexts?rgpvContexts[i]:NULL;

		m_phThreads[i] = CreateThread(NULL,
								0,
								CThreadPool::ThreadProc,
								&(m_rgContexts[i]),
								0,
								&dwThreadId);
		if (!m_phThreads[i])
			break;
	}

	*pdwThreadsCreated = i;
	m_dwThreads = i;
	m_fDestroy = FALSE;
	m_pfnThreadProc = pfnThreadProc;

	return(S_OK);
}

HRESULT CThreadPool::SignalAndDestroyThreadPool()
{
	m_fDestroy = TRUE;
	return(SignalThreadPool());
}

HRESULT CThreadPool::SignalThreadPool()
{
	if (!m_hStartEvent)
		return(E_INVALIDARG);

	if (SetEvent(m_hStartEvent))
		return(S_OK);
	return(HRESULT_FROM_WIN32(GetLastError()));
}

HRESULT CThreadPool::WaitForAllThreadsToTerminate(
			DWORD					dwNotificationPeriodInMilliseconds,
			PFN_NOTIFICATION		pfnNotification,
			LPVOID					pvNotificationContext
			)
{
	HRESULT	hrRes = S_OK;

	while (WaitForMultipleObjects(
				m_dwThreads,
				m_phThreads,
				TRUE,
				dwNotificationPeriodInMilliseconds) == WAIT_TIMEOUT)
	{
		hrRes = pfnNotification(pvNotificationContext);
		if (!SUCCEEDED(hrRes))
			break;
	}

	return(hrRes);
}

DWORD WINAPI CThreadPool::ThreadProc(
			LPVOID	pvContext
			)
{
	LPTHD_CONTEXT	pContext = (LPTHD_CONTEXT)pvContext;
	CThreadPool		*ptpPool = (CThreadPool *)pContext->pvThis;

	return(ptpPool->LocalThreadProc(pContext));
}

DWORD CThreadPool::LocalThreadProc(
			LPTHD_CONTEXT	pContext
			)
{
	DWORD			dwResult;
	
	InterlockedIncrement(&m_lThreadCounter);

	//
	// Wait for everybody to get ready...
	//
	WaitForSingleObject(m_hStartEvent, INFINITE);

	if (m_fDestroy)
		return(0);

	dwResult = m_pfnThreadProc(pContext->pvContext);

	InterlockedDecrement(&m_lThreadCounter);

	return(dwResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\parsearg.cpp ===
#include <stdio.h>
#include <windows.h>

#include "parsearg.h"

#define BAIL_WITH_ERROR(x)				\
		{								\
		SetParseError((x), szSwitch);	\
		return(x);						\
		}

#define RETURN_SUCCESS(x)				\
		{								\
		SetParseError((x), NULL);		\
		return(x);						\
		}

CParseArgs::CParseArgs(
			char					*szAppDescription,
			DWORD					dwDescriptors,
			LPARGUMENT_DESCRIPTOR	rgDescriptors
			)
{
	m_dwDescriptors = dwDescriptors;
	m_rgDescriptors = rgDescriptors;
	m_szAppDescription = szAppDescription;

	for (DWORD i = 0; i < m_dwDescriptors; i++)
		m_rgDescriptors[i].pvReserved = NULL;

	m_hrRes = S_OK;
}

CParseArgs::~CParseArgs()
{
	Cleanup();

	m_rgDescriptors = NULL;
	m_dwDescriptors = 0;
}

HRESULT CParseArgs::Cleanup()
{
	if (m_rgDescriptors)
	{
		for (DWORD i = 0; i < m_dwDescriptors; i++)
		{
			if ((m_rgDescriptors[i].pvReserved) &&
				(m_rgDescriptors[i].atType != AT_NONE))
			{
				delete [] (char *)(m_rgDescriptors[i].pvReserved);
				m_rgDescriptors[i].pvReserved = NULL;
			}
		}
	}
	return(S_OK);
}

LPARGUMENT_DESCRIPTOR CParseArgs::FindArgument(
			char	*szSwitch
			)
{
	for (DWORD i = 0; i < m_dwDescriptors; i++)
	{
		if (!lstrcmpi(szSwitch, m_rgDescriptors[i].szSwitch))
			return(&(m_rgDescriptors[i]));
	}

	return(NULL);
}

HRESULT CParseArgs::ParseArguments(
			int						argc,
			char					*argv[]
			)
{
	char					*szSwitch = NULL;
	LPARGUMENT_DESCRIPTOR	pArg = NULL;

	Cleanup();

	if ((argc < 1) || !argv)
		BAIL_WITH_ERROR(DISP_E_BADPARAMCOUNT);

	// Skip the first argument
	argc--;
	argv++;

	// Walk it!
	while (argc)
	{
		szSwitch = *argv;
		pArg = FindArgument(szSwitch);
		if (!pArg)
			BAIL_WITH_ERROR(DISP_E_UNKNOWNNAME);

		// See if it's already set
		if (pArg->pvReserved)
		{
			BAIL_WITH_ERROR(STG_E_FILEALREADYEXISTS);
		}

		// Process the known argument
		if (pArg->atType == AT_NONE)
		{
			pArg->pvReserved = (LPVOID)1;
		}
		else
		{
			DWORD	dwSize;
			DWORD	dwValue;
			LPVOID	pvBuffer;

			argc--;
			argv++;
			if (!argc)
				BAIL_WITH_ERROR(DISP_E_BADPARAMCOUNT);

			switch (pArg->atType)
			{
			case AT_STRING:
				dwSize = lstrlen(*argv) + 1;
				pvBuffer = (LPVOID)new char [dwSize];
				if (!pvBuffer)
					BAIL_WITH_ERROR(E_OUTOFMEMORY);
				lstrcpy((char *)pvBuffer, *argv);
				pArg->pvReserved = pvBuffer;
				break;

			case AT_VALUE:
				dwSize = sizeof(DWORD);
				pvBuffer = (LPVOID)new char [dwSize];
				if (!pvBuffer)
					BAIL_WITH_ERROR(E_OUTOFMEMORY);
				if (!StringToValue(*argv, &dwValue))
					BAIL_WITH_ERROR(DISP_E_BADVARTYPE);
				*(DWORD *)pvBuffer = dwValue;
				pArg->pvReserved = pvBuffer;
				break;

			default:
				BAIL_WITH_ERROR(NTE_BAD_TYPE);
			}
		}
		
		argc--;
		argv++;
	}

	// Make sure all the required ones are there ...
	for (DWORD i = 0; i < m_dwDescriptors; i++)
		if (m_rgDescriptors[i].fRequired &&
			!m_rgDescriptors[i].pvReserved &&
			m_rgDescriptors[i].atType != AT_NONE)
		{
			szSwitch = m_rgDescriptors[i].szSwitch;
			BAIL_WITH_ERROR(DISP_E_PARAMNOTFOUND);
		}

	RETURN_SUCCESS(S_OK);
}

HRESULT CParseArgs::Exists(
			DWORD	dwDescriptorIndex
			)
{
	if (dwDescriptorIndex > m_dwDescriptors)
		return(E_INVALIDARG);

	if (m_rgDescriptors[dwDescriptorIndex].pvReserved)
		return(S_OK);

	return(E_FAIL);
}

HRESULT CParseArgs::GetSwitch(
			DWORD	dwDescriptorIndex,
			BOOL	*pfExists
			)
{
	LPARGUMENT_DESCRIPTOR	pArg = NULL;
	char					*szSwitch;

	if (dwDescriptorIndex > m_dwDescriptors)
		return(E_INVALIDARG);

	pArg = m_rgDescriptors + dwDescriptorIndex;
	szSwitch = pArg->szSwitch;

	if (pArg->atType != AT_NONE)
		BAIL_WITH_ERROR(DISP_E_TYPEMISMATCH);

	if (pArg->pvReserved)
		*pfExists = TRUE;

	RETURN_SUCCESS(S_OK);
}

HRESULT CParseArgs::GetString(
			DWORD	dwDescriptorIndex,
			char	**ppszStringValue
			)
{
	LPARGUMENT_DESCRIPTOR	pArg = NULL;
	char					*szSwitch;

	if (dwDescriptorIndex > m_dwDescriptors)
		return(E_INVALIDARG);

	pArg = m_rgDescriptors + dwDescriptorIndex;
	szSwitch = pArg->szSwitch;

	if (!pArg->pvReserved)
		BAIL_WITH_ERROR(DISP_E_PARAMNOTFOUND);

	if (pArg->atType != AT_STRING)
		BAIL_WITH_ERROR(DISP_E_TYPEMISMATCH);

	*ppszStringValue = (char *)pArg->pvReserved;
	RETURN_SUCCESS(S_OK);
}

HRESULT CParseArgs::GetDword(
			DWORD	dwDescriptorIndex,
			DWORD	*pdwDwordValue
			)
{
	LPARGUMENT_DESCRIPTOR	pArg = NULL;
	char					*szSwitch;

	if (dwDescriptorIndex > m_dwDescriptors)
		return(E_INVALIDARG);

	pArg = m_rgDescriptors + dwDescriptorIndex;
	szSwitch = pArg->szSwitch;

	if (!pArg->pvReserved)
		BAIL_WITH_ERROR(DISP_E_PARAMNOTFOUND);

	if (pArg->atType != AT_VALUE)
		BAIL_WITH_ERROR(DISP_E_TYPEMISMATCH);

	*pdwDwordValue = *(DWORD *)(pArg->pvReserved);
	RETURN_SUCCESS(S_OK);
}

HRESULT CParseArgs::GenerateUsage(
			DWORD	*pdwLength,
			char	*szUsage
			)
{
	DWORD	dwLength = 0;
	char	*pBuffer = m_szBuffer;

	dwLength = sprintf(pBuffer, "\n%s\n\nUsage:\n", m_szAppDescription);
	pBuffer += dwLength;

	for (DWORD i = 0; i < m_dwDescriptors; i++)
	{
		DWORD	dwTempLength;

		dwTempLength = sprintf(pBuffer, "\t%s\n", m_rgDescriptors[i].szUsage);
		pBuffer += dwTempLength;
		dwLength += dwTempLength;
	}

	if (dwLength < *pdwLength)
	{
		*pdwLength = dwLength;
		lstrcpy(szUsage, m_szBuffer);
		return(S_OK);
	}
	*pdwLength = dwLength;
	return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
}

HRESULT CParseArgs::GetErrorString(
			DWORD	*pdwLength,
			char	*szErrorString
			)
{
	DWORD	dwLength;

	if (m_hrRes == S_OK)
	{
		lstrcpy(m_szBuffer, "The operation completed successfully.");
	}
	else
	{
		switch (m_hrRes)
		{
		case DISP_E_UNKNOWNNAME:
			sprintf(m_szBuffer, "The command switch %s is invalid.",
					m_szErrorSwitch);
			break;

		case DISP_E_PARAMNOTFOUND:
			sprintf(m_szBuffer, "The required command switch %s is not specified.",
					m_szErrorSwitch);
			break;

		case DISP_E_TYPEMISMATCH:
			sprintf(m_szBuffer, 
					"The argument value for command switch %s is of the wrong type.",
					m_szErrorSwitch);
			break;

		case DISP_E_BADVARTYPE:
			sprintf(m_szBuffer, 
					"The argument value supplied for command switch %s is not a valid number.",
					m_szErrorSwitch);
			break;

		case E_OUTOFMEMORY:
			sprintf(m_szBuffer, 
					"The system does not have sufficient resources to complete the operation.",
					m_szErrorSwitch);
			break;

		case DISP_E_BADPARAMCOUNT:
			sprintf(m_szBuffer, "The number of arguments specified is invalid.",
					m_szErrorSwitch);
			break;

		case STG_E_FILEALREADYEXISTS:
			sprintf(m_szBuffer, "The command switch %s is specified more than once.",
					m_szErrorSwitch);
			break;

		case NTE_BAD_TYPE:
			sprintf(m_szBuffer, "Internal error: A invalid argument type is specified.",
					m_szErrorSwitch);
			break;

		default:
			sprintf(m_szBuffer, "Unknown error code %08x on switch %s", 
						m_hrRes,
						m_szErrorSwitch);
		}
		
	}

	dwLength = lstrlen(m_szBuffer);			
	if (dwLength < *pdwLength)
	{
		*pdwLength = dwLength + 1;
		lstrcpy(szErrorString, m_szBuffer);
		return(S_OK);
	}

	*pdwLength = dwLength + 1;
	return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
}

void CParseArgs::SetParseError(
			HRESULT	hrRes,
			char	*szSwitch
			)
{
	if (szSwitch)
		lstrcpy(m_szErrorSwitch, szSwitch);
	m_hrRes = hrRes;
}

BOOL CParseArgs::StringToValue(
			char	*szString,
			DWORD	*pdwValue
			)
{
	DWORD	dwValue = 0;
	char	ch;

	while (*szString)
	{
		ch = *szString;
		if ((ch < '0') || (ch > '9'))
			return(FALSE);
		ch -= '0';
		dwValue *= 10;
		dwValue += (DWORD)ch;
		szString++;
	}

	*pdwValue = dwValue;
	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\mailmsg.cpp ===
// imsg.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f imsgps.mk in the project directory.

//#define WIN32_LEAN_AND_MEAN
#include <atq.h>
#include "dbgtrace.h"
#define _ASSERTE _ASSERT

#include "stdafx.h"


#include "resource.h"
#include "initguid.h"

#include "filehc.h"
#include "mailmsg.h"
#include "mailmsgi.h"

#include "cmailmsg.h"
#include "transmem.h"
#include "msg.h"


CComModule _Module;

HANDLE g_hTransHeap = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MsgImp, CMsg)
END_OBJECT_MAP()

// =================================================================
// Static declarations
//
CPool CMsg::m_Pool((DWORD)'pMCv');

//
// CPool parameters 
//
#define DEFAULT_CMSG_ABSOLUTE_MAX_POOL_SIZE	100000
#define DEFAULT_CMSG_NORMAL_POOL_SIZE		90000
#define DEFAULT_ADD_POOL_SIZE				10000
#define DEFAULT_BLOCK_POOL_SIZE				100000

BOOL	g_fCMsgPoolInitialized	= FALSE;
BOOL	g_fAddPoolInitialized	= FALSE;
BOOL	g_fBlockPoolInitialized	= FALSE;
DWORD	g_dwCMsgPoolSize		= DEFAULT_CMSG_ABSOLUTE_MAX_POOL_SIZE;
DWORD	g_dwCMsgNormalPoolSize	= DEFAULT_CMSG_NORMAL_POOL_SIZE;
DWORD	g_dwAddPoolSize			= DEFAULT_ADD_POOL_SIZE;
DWORD	g_dwBlockPoolSize		= DEFAULT_BLOCK_POOL_SIZE;

DWORD	g_dwObjectCount = 0;

//
// Function to get registry values
//
BOOL g_mailmsg_GetRegistryDwordParameter(
			LPCSTR	pcszParameterName,
			DWORD	*pdwValue
			)
{
	HKEY	hKey = NULL;
	DWORD	dwRes;
	DWORD	dwType;
	DWORD	dwLength;
	DWORD	dwValue;
	BOOL	fRes = FALSE;

	// Open the registry key
	dwRes = (DWORD)RegOpenKeyEx(
				HKEY_LOCAL_MACHINE,
				_T("Software\\Microsoft\\Exchange\\MailMsg"),
				0,
				KEY_ALL_ACCESS,
				&hKey);
	if (dwRes == ERROR_SUCCESS)
	{
		// Adjust the buffer size for character type ...
		dwLength = sizeof(DWORD);
		dwRes = (DWORD)RegQueryValueEx(
					hKey,
					pcszParameterName,
					NULL,
					&dwType,
					(LPBYTE)&dwValue,
					&dwLength);
		if ((dwRes == ERROR_SUCCESS) && dwType == REG_DWORD)
		{
			*pdwValue = dwValue;
			fRes = TRUE;
		}

		_VERIFY(RegCloseKey(hKey) == NO_ERROR);
	}

	return(fRes);
}


//
// Track the allocations of CMailMsg objects
//
#ifdef DEBUG
#define MAILMSG_TRACKING_LOCKED		1
#define MAILMSG_TRACKING_UNLOCKED	0

LIST_ENTRY	g_leTracking;
DWORD		g_dwAllocThreshold = 0;
LONG		g_lSpinLock = MAILMSG_TRACKING_UNLOCKED;
DWORD		g_dwOutOfMemoryErrors = 0;

void g_mailmsg_Lock()
{
	while (InterlockedCompareExchange(&g_lSpinLock, MAILMSG_TRACKING_LOCKED, MAILMSG_TRACKING_UNLOCKED) == MAILMSG_TRACKING_LOCKED)
		;
}

void g_mailmsg_Unlock()
{
	if (InterlockedExchange(&g_lSpinLock, MAILMSG_TRACKING_UNLOCKED) != MAILMSG_TRACKING_LOCKED)
	{ _ASSERT(FALSE); }
}

void g_mailmsg_Init()
{
	InitializeListHead(&g_leTracking);
	g_dwObjectCount = 0;
	g_lSpinLock = MAILMSG_TRACKING_UNLOCKED;

	// Get threshold from registry, if specified
	g_dwAllocThreshold = 0;
	g_mailmsg_GetRegistryDwordParameter(
			_T("AllocThreshold"),
			&g_dwAllocThreshold);
}

DWORD g_mailmsg_Add(PLIST_ENTRY	ple)
{
	DWORD	dwTemp;
	g_mailmsg_Lock();
	InsertHeadList(&g_leTracking, ple);
	dwTemp = ++g_dwObjectCount;
	if (g_dwAllocThreshold)
	{
		_ASSERT(dwTemp <= g_dwAllocThreshold);
	}
	g_mailmsg_Unlock();
	return(dwTemp);
}

DWORD g_mailmsg_Remove(PLIST_ENTRY	ple)
{
	DWORD	dwTemp;
	g_mailmsg_Lock();
	RemoveEntryList(ple);
	_ASSERT(g_dwObjectCount > 0);
	dwTemp = --g_dwObjectCount;
	g_mailmsg_Unlock();
	return(dwTemp);
}

DWORD g_mailmsg_Check()
{
	TraceFunctEnter("g_mailmsg_Check");
	g_mailmsg_Lock();
	if (g_dwObjectCount)
	{
		ErrorTrace((LPARAM)0, "Leaked %u objects", g_dwObjectCount);
		PLIST_ENTRY	ple = g_leTracking.Flink;
		for (DWORD i = 0; i < g_dwObjectCount; i++)
		{
			_ASSERT(ple != &g_leTracking);
			ErrorTrace((LPARAM)ple, "Object at %p not released.", ple);
			ple = ple->Flink;
		}
		_ASSERT(ple == &g_leTracking);
		_ASSERT(FALSE);
	}
	g_mailmsg_Unlock();
	TraceFunctLeave();
	return(g_dwObjectCount);
}

#endif // DEBUG


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		TraceFunctEnterEx((LPARAM)hInstance, "mailmsg!DllMain!ATTACH");
	
        // init transmem
        TrHeapCreate();

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

#ifdef DEBUG
		// Initialize the tracking list
		g_mailmsg_Init();
#endif

        // initialize the crc library
        crcinit();

		// Clear the object counter
		g_dwObjectCount = 0;

		// Get the sizes for each of our CPools from 
		// the registry, if specified ...
		g_mailmsg_GetRegistryDwordParameter(
					_T("MaxMessageObjects"),
					&g_dwCMsgPoolSize);
		DebugTrace((LPARAM)hInstance, 
			"IMailMsgProperties absolute max pool size: %u objects", g_dwCMsgPoolSize);

		g_mailmsg_GetRegistryDwordParameter(
					_T("MessageObjectsInboundCutoffCount"),
					&g_dwCMsgNormalPoolSize);
		DebugTrace((LPARAM)hInstance, 
			"IMailMsgProperties inbound cutoff threshold: %u objects", g_dwCMsgNormalPoolSize);

		g_mailmsg_GetRegistryDwordParameter(
					_T("MaxMessageAddObjects"),
					&g_dwAddPoolSize);
		DebugTrace((LPARAM)hInstance, 
			"IMailMsgPropertiesAdd pool size: %u objects", g_dwAddPoolSize);

		g_mailmsg_GetRegistryDwordParameter(
					_T("MaxPropertyBlocks"),
					&g_dwBlockPoolSize);
		DebugTrace((LPARAM)hInstance, 
			"BLOCK_HEAP_NODE pool size: %u objects", g_dwBlockPoolSize);

		// Checking the message count and cutoff values
		if (g_dwCMsgPoolSize <= g_dwCMsgNormalPoolSize)
		{
			g_dwCMsgNormalPoolSize = (g_dwCMsgPoolSize * 9) / 10;

			// If we have so pathetically few message objects, might 
			// as well set the cutoff to the upper bound
			if (!g_dwCMsgNormalPoolSize)
				g_dwCMsgNormalPoolSize = g_dwCMsgPoolSize;

			DebugTrace((LPARAM)0, "Adjusted inbound cutoff to %u objects",
				g_dwCMsgNormalPoolSize);
		}

		// Globally initialize the cpools

		// CMsg objects
		if (!CMsg::m_Pool.ReserveMemory(
					g_dwCMsgPoolSize,
					sizeof(CMsg)))
		{
			SetLastError(ERROR_DLL_INIT_FAILED);
			return(FALSE);
		}
		g_fCMsgPoolInitialized = TRUE;

		// CMailMsgRecipientsAdd objects
		if (!CMailMsgRecipientsAdd::m_Pool.ReserveMemory(
					g_dwAddPoolSize,
					sizeof(CMailMsgRecipientsAdd)))
		{
			SetLastError(ERROR_DLL_INIT_FAILED);
			return(FALSE);
		}
		g_fAddPoolInitialized = TRUE;

		// BLOCK_HEAP_NODE structures, these are slightly out of the ordinary
		if (!CBlockMemoryAccess::m_Pool.ReserveMemory(
					g_dwBlockPoolSize, 
					sizeof(BLOCK_HEAP_NODE)))
		{
			SetLastError(ERROR_DLL_INIT_FAILED);
			return(FALSE);
		}
		g_fBlockPoolInitialized = TRUE;

		TraceFunctLeave();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		TraceFunctEnterEx((LPARAM)hInstance, "mailmsg!DllMain!DETACH");

#ifdef DEBUG
		// 
		// Verify the tracking list
		//  This must happen *before* we release CPool
		//
		g_mailmsg_Check();
#endif
		// Release all the CPools
		// These will assert if we are not shutdown cleanly
		if (g_fBlockPoolInitialized)
		{
			_ASSERT(CBlockMemoryAccess::m_Pool.GetAllocCount() == 0);
			CBlockMemoryAccess::m_Pool.ReleaseMemory();
			g_fBlockPoolInitialized = FALSE;
		}
		if (g_fAddPoolInitialized)
		{
			_ASSERT(CMailMsgRecipientsAdd::m_Pool.GetAllocCount() == 0);
			CMailMsgRecipientsAdd::m_Pool.ReleaseMemory();
			g_fAddPoolInitialized = FALSE;
		}
		if (g_fCMsgPoolInitialized)
		{
			_ASSERT(CMsg::m_Pool.GetAllocCount() == 0);
			CMsg::m_Pool.ReleaseMemory();
			g_fCMsgPoolInitialized = FALSE;
		}

        _Module.Term();

        // shutdown transmem
        TrHeapDestroy();

		TraceFunctLeave();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
//
// S_OK means we can unload this DLL
//
// S_FALSE means we cannot unload this DLL

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

    //
    //  LKRHash keeps a static list of outstanding hash tables.
    //  If we say that we can unload with outstanding hash tables,
    //  then LKRHash will be pointing to unitialized memory.  If
    //  we otherwise think we can be unloaded... make sure that
    //  we check the count of oustanding RecipientAdd objects, because
    //  we do not want to crash because someone leaked.
    //
    if ((S_OK == hr) && CMailMsgRecipientsAdd::m_Pool.GetAllocCount())
        hr = S_FALSE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\msg.cpp ===
//+----------------------------------------------------------------------------
//
//  Msg.cpp : Implementation of CMsg
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       msg.cpp
//
//  Contents:   Implementation of CMsg.
//
//  Classes:    CMsg
//
//  Functions:
//
//  History:    3/27/98		KeithLau		Created
//
//-----------------------------------------------------------------------------

//#define WIN32_LEAN_AND_MEAN
#include "atq.h"
#include "dbgtrace.h"
#include "stdafx.h"

#include "filehc.h"
#include "mailmsg.h"
#include "mailmsgi.h"
#include "cmailmsg.h"
#include "Msg.h"

/////////////////////////////////////////////////////////////////////////////
// CMsg

DECLARE_DEBUG_PRINTS_OBJECT()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgp.h $(O)\mailmsgp_i.c : $(STAXINC)\export\mailmsgp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgp_i.c \
    -header $@ \
    -tlb $(O)\mailmsgp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dumpmsg\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgp.h $(O)\mailmsgp_i.c : $(STAXINC)\export\mailmsgp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgp_i.c \
    -header $@ \
    -tlb $(O)\mailmsgp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mailmsg.rc
//
#define IDS_PROJNAME                    100
#define IDR_MAILMSG                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\msg.h ===
// Msg.h : Declaration of the CMsg

#ifndef __MSG_H_
#define __MSG_H_

#include "resource.h"       // main symbols

#ifdef DEBUG
DWORD g_mailmsg_Add(PLIST_ENTRY	ple);
DWORD g_mailmsg_Remove(PLIST_ENTRY	ple);
#endif

extern DWORD g_dwCMsgNormalPoolSize;
extern DWORD g_dwObjectCount;

/////////////////////////////////////////////////////////////////////////////
// CMsg

class ATL_NO_VTABLE CMsg :
	public CMailMsg,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CMsg, &CLSID_MsgImp>
{
public:
    CMsg() {}
    ~CMsg() {}

	//
	// CPool
	//
	static CPool m_Pool;
	inline void *operator new(size_t size)
	{
		return m_Pool.Alloc();
	}
	inline void operator delete(void *p)
	{
		m_Pool.Free(p);
	}

	ULONG InternalAddRef()
	{
		ULONG ulTemp = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalAddRef();
		TraceFunctEnterEx((LPARAM)this, "CMsg::InternalAddRef");
		DebugTrace((LPARAM)this, "After InternalAddRef : %u", ulTemp);
		return(ulTemp);
	}

	ULONG InternalRelease()
	{
		ULONG ulTemp = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalRelease();
		TraceFunctEnterEx((LPARAM)this, "CMsg::InternalRelease");
		DebugTrace((LPARAM)this, "After InternalRelease : %u", ulTemp);
		return(ulTemp);
	}

	HRESULT FinalConstruct()
	{
		TraceFunctEnterEx((LPARAM)this, "CMsg::FinalConstruct");
#ifdef DEBUG
		// Add object to tracking list
		DWORD dwCount = g_mailmsg_Add(&m_leTracking);
#else
        // Bump object count
        DWORD dwCount = InterlockedIncrement((LONG *)&g_dwObjectCount);
#endif

        // If the count is more than the normal pool size
        // (i.e. inbound cutoff), then we set a special creation flag
        if (dwCount > g_dwCMsgNormalPoolSize)
        {
            DebugTrace((LPARAM)this, "Object #%u exceeding inbound cutoff", dwCount);
            CMailMsg::m_dwCreationFlags |= MPV_INBOUND_CUTOFF_EXCEEDED;
        }

		HRESULT hrRes = Initialize();
		return(hrRes);
	}

	HRESULT FinalRelease()
	{
		TraceFunctEnterEx((LPARAM)this, "CMsg::FinalRelease");
        CMailMsg::FinalRelease();
#ifdef DEBUG
		// Add object to tracking list
		g_mailmsg_Remove(&m_leTracking);
#else
        // Drop object count
        InterlockedDecrement((LONG *)&g_dwObjectCount);
#endif
		return(S_OK);
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MAILMSG)

BEGIN_COM_MAP(CMsg)
    COM_INTERFACE_ENTRY(IMailMsgProperties)
    COM_INTERFACE_ENTRY(IMailMsgRecipients)
    COM_INTERFACE_ENTRY(IMailMsgRecipientsBase)
    COM_INTERFACE_ENTRY(IMailMsgQueueMgmt)
    COM_INTERFACE_ENTRY(IMailMsgBind)
    COM_INTERFACE_ENTRY(IMailMsgPropertyReplication)
    COM_INTERFACE_ENTRY(IMailMsgPropertyManagement)
    COM_INTERFACE_ENTRY(IMailMsgAQueueListEntry)
    COM_INTERFACE_ENTRY(IMailMsgValidate)
    COM_INTERFACE_ENTRY(IMailMsgValidateContext)
END_COM_MAP()

private:
	LIST_ENTRY	m_leTracking;

};

#define IMSG_DIRECTORY_CONFIG_KEY_NAME _T("Exchange.MailMsg")

#endif //__MSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dumpmsg\main.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "atq.h"
#include <stdio.h>

#include "cthrdapp.h"
#include "parsearg.h"
#include "macros.h"

#include "signatur.h"
#include "blockmgr.h"
#include "cmmprops.h"
#include "cmailmsg.h"
#include "dumpmsg.h"
//
// Description of the application
//
char *szAppDescription = "DUMPMSG - Application to dump the contents of a file system-based message";

//
// Define the argument list domain
//
ARGUMENT_DESCRIPTOR rgArguments[] =
{
	{
		FALSE,
		"-?",
		"-? - Displays usage help message",
		AT_NONE,
		NULL
	},
	{
		TRUE,
		"-f",
		"-f <filename> - Required, file name of the property stream\n"
		"\t    For NTFS, the property stream is the name of the\n"
		"\t    EML file, plus a \":PROPERTIES\" stream suffix.",
		AT_STRING,
		NULL
	},
	{
		FALSE,
		"-c",
		"-c - Correct the stream signature if it is marked as invalid, yet\n"
		"\t    contains valid data\n",
		AT_NONE,
		NULL
	},
};

#define ARGUMENT_LIST_SIZE	(sizeof(rgArguments) / sizeof(ARGUMENT_DESCRIPTOR))

//
// G L O B A L   V A R I A B L E S
//

// Need these for using macros
BOOL			fToDebugger = FALSE;
BOOL			fUseDebugBreak = FALSE;
char			*szFileName = NULL;
HANDLE			hStream = INVALID_HANDLE_VALUE;
BOOL            fFixCorruption = FALSE;

typedef struct {
    DWORD       dwSignature;
    DWORD       dwVersion;
    GUID        guidInstance;
} NTFS_STREAM_HEADER;

#define STREAM_OFFSET               sizeof(NTFS_STREAM_HEADER)
#define STREAM_SIGNATURE            'rvDN'
#define STREAM_SIGNATURE_INVALID    'rvD!'
#define STREAM_SIGNATURE_NOOFFSET   'MMCv'

class CDumpMsgGetStream : public CBlockManagerGetStream {
	public:
		CDumpMsgGetStream(IMailMsgPropertyStream *pStream = NULL) {
			SetStream(pStream);
		}

		void SetStream(IMailMsgPropertyStream *pStream) {
			m_pStream = pStream;
		}
	
		virtual HRESULT GetStream(IMailMsgPropertyStream **ppStream,
								  BOOL fLockAcquired)
		{
			*ppStream = m_pStream;
			return S_OK;
		}

	private:
		IMailMsgPropertyStream *m_pStream;
};

CDumpMsgGetStream	bmGetStream;
CBlockManager		bmManager(NULL, &bmGetStream);

class CPropertyStream :
	public IMailMsgPropertyStream
{
public:

    CPropertyStream(HANDLE hStream, BOOL fFixInvalidSignature = FALSE);
    ~CPropertyStream();

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				){return(S_OK);}

	ULONG STDMETHODCALLTYPE AddRef(){return(S_OK);}

	ULONG STDMETHODCALLTYPE Release(){return(S_OK);}

	//
	// IMailMsgPropertyStream
	//
	HRESULT STDMETHODCALLTYPE GetSize(
                IMailMsgProperties  *pMsg,
				DWORD			*pdwSize,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReadBlocks(
                IMailMsgProperties  *pMsg,
				DWORD			dwCount,
				DWORD			*pdwOffset,
				DWORD			*pdwLength,
				BYTE			**ppbBlock,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE WriteBlocks(
                IMailMsgProperties  *pMsg,
				DWORD			dwCount,
				DWORD			*pdwOffset,
				DWORD			*pdwLength,
				BYTE			**ppbBlock,
				IMailMsgNotify	*pNotify
				);

    HRESULT STDMETHODCALLTYPE StartWriteBlocks(
                IMailMsgProperties  *pMsg,
                DWORD               cBlocksToWrite,
                DWORD               cTotalBytesToWrite)
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE EndWriteBlocks(
                IMailMsgProperties  *pMsg)
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE CancelWriteBlocks(
                IMailMsgProperties  *pMsg)
    {
        return S_OK;
    }

    void FixSignature() {
        m_fFixInvalidSignature = TRUE;
    }

private:
	HANDLE				m_hStream;
    DWORD               m_cStreamOffset;
    BOOL                m_fFixInvalidSignature;
    BOOL                m_fInvalidSignature;
};



//
// I M P L E M E N T A T I O N
//
char* LookupCommonName(char** pSzArray, DWORD* dwArray, DWORD dwSizeOfArray, DWORD dwPropID)
{
	char* fRetVal = NULL;

	for( DWORD i = 0; i < dwSizeOfArray; ++i) {
		if(dwArray[i] == dwPropID) {
			fRetVal = pSzArray[i];
		}
	}
	return fRetVal;
}

char* FindPropName(DWORD dwPropID)
{
	char* fRetVal = NULL;
	fRetVal = LookupCommonName((char**)&szMPValues,(DWORD*)&dwMPNameId,sizeof(dwMPNameId)/sizeof(DWORD),dwPropID);
	if(fRetVal) {
		return fRetVal;
	}
	fRetVal = LookupCommonName((char**)&szRPValues,(DWORD*)&dwRPNameId,sizeof(dwRPNameId)/sizeof(DWORD),dwPropID);
	if(fRetVal) {
		return fRetVal;
	}
	fRetVal = LookupCommonName((char**)&szMPVValues,(DWORD*)&dwMPVNameId,sizeof(dwMPVNameId)/sizeof(DWORD),dwPropID);
	if(fRetVal) {
		return fRetVal;
	}
	fRetVal = LookupCommonName((char**)&szNMPValues,(DWORD*)&dwNMPNameId,sizeof(dwNMPNameId)/sizeof(DWORD),dwPropID);
	if(fRetVal) {
		return fRetVal;
	}
	// if we got here, it wasn't in any of our lists
	return "Unknown";
}

	
	
	HRESULT CompareProperty(
			LPVOID			pvPropKey,
			LPPROPERTY_ITEM	pItem
			)
{
	if (*(PROP_ID *)pvPropKey == ((LPGLOBAL_PROPERTY_ITEM)pItem)->idProp)
		return(S_OK);
	return(STG_E_UNKNOWN);
}						


HRESULT Prologue(
			int		argc,
			char	*argv[]
			)
{
	HRESULT		hrRes = S_OK;
	CParseArgs	Parser(szAppDescription, ARGUMENT_LIST_SIZE, rgArguments);

	char	szBuffer[2048];
	DWORD	dwSize = sizeof(szBuffer);
	ZeroMemory(szBuffer,sizeof(szBuffer));	
	//
	// Parse the command arguments
	//
	hrRes = Parser.ParseArguments(argc, argv);
	if (!SUCCEEDED(hrRes))
	{
		//
		// Display the explanatory error message
		//
		hrRes = Parser.GetErrorString(&dwSize, szBuffer);
		WRITE(szBuffer);

		//
		// Display automatically-generated usage help
		//
		dwSize = sizeof(szBuffer);
		hrRes = Parser.GenerateUsage(&dwSize, szBuffer);
		WRITE(szBuffer);

		BAIL_WITH_ERROR(E_FAIL);
	}

	//
	// Process the arguments
	//
	if (SUCCEEDED(Parser.Exists(0)))
	{
		hrRes = Parser.GenerateUsage(&dwSize, szBuffer);
		WRITE(szBuffer);
		BAIL_WITH_ERROR(E_FAIL);
	}

	// These functions don't modify the original value if the argument
	// is not specified
	Parser.GetString(1, &szFileName);

    Parser.GetSwitch(2, &fFixCorruption);

	DWORD	dwThreadsCreated;
	hrRes = theApp.CreateThreadPool(
				1,
				NULL,
				NULL,
				1000000,
				&dwThreadsCreated);
	if (!SUCCEEDED(hrRes) || 1 != dwThreadsCreated)
	{
		sprintf(szBuffer,
				"Failed to create worker thread. Error: %08x\n", hrRes);
		WRITE(szBuffer);
		BAIL_WITH_ERROR(E_FAIL);
	}

	if (!CBlockMemoryAccess::m_Pool.ReserveMemory(
				200000,
				sizeof(BLOCK_HEAP_NODE)))
	{
		sprintf(szBuffer,
				"Failed to reserve memory. Error: %u\n", GetLastError());
		WRITE(szBuffer);
		BAIL_WITH_ERROR(E_FAIL);
	}

	//
	// Synchronization measures will prevent the threadprocs from executing
	// until we exit this function. If we return anything other than success,
	// the thread pool will be destroyed, and the program will terminate.
	//
	hStream = CreateFile(
				szFileName,
				GENERIC_READ | GENERIC_WRITE,	// Read / Write
				FILE_SHARE_READ,				// Read sharing
				NULL,							// Default security
				OPEN_EXISTING,					// Open existing file
				FILE_FLAG_SEQUENTIAL_SCAN,		// Seq scan
				NULL);							// No template
	if (hStream == INVALID_HANDLE_VALUE)
	{
		sprintf(szBuffer,
				"Failed to open file. Error: %u\n", GetLastError());
		WRITE(szBuffer);
		BAIL_WITH_ERROR(E_FAIL);
	}

	return(S_OK);
}

HRESULT DumpMasterHeader(
			MASTER_HEADER	*pmh,
            DWORD           cStream
			)
{
	char	szBuffer[4096];

	sprintf(szBuffer,
			"Master header:\n"
			"\tSignature: %08x (valid sig: %08x)\n"
			"\tVersion High: %u\n"
			"\tVersion Low: %u\n"
			"\tHeader size: %u (valid size: %u)\n\n"
            "\tStream file size: %x\n\n",
			pmh->dwSignature,
			CMAILMSG_SIGNATURE_VALID,
			pmh->wVersionHigh,
			pmh->wVersionLow,
			pmh->dwHeaderSize,
			sizeof(MASTER_HEADER),
            cStream);
	WRITE(szBuffer);

    PROPERTY_TABLE_INSTANCE *rgpti[] = {
        &(pmh->ptiGlobalProperties),
        &(pmh->ptiRecipients),
        &(pmh->ptiPropertyMgmt)
    };

    for (DWORD i = 0; i < 3; i++) {
        char szName[80];
        switch (i) {
            case 0: strcpy(szName, "ptiGlobalProperties"); break;
            case 1: strcpy(szName, "ptiRecipients"); break;
            case 2: strcpy(szName, "ptiPropertyMgmt"); break;
            default: strcpy(szName, "(unknown)"); break;
        }
        sprintf(szBuffer,
            "\tProperty Table Instance: %s\n"
            "\t\tSignature: 0x%08x\n"
            "\t\tfaFirstFragment: 0x%08x\n"
            "\t\tdwFragmentSize: 0x%08x\n"
            "\t\tdwItemBits: 0x%08x\n"
            "\t\tdwItemSize: 0x%08x\n"
            "\t\tdwProperties: 0x%08x\n"
            "\t\tfaExtendedInfo: 0x%08x\n",
			szName,
            rgpti[i]->dwSignature,
            rgpti[i]->faFirstFragment,
            rgpti[i]->dwFragmentSize,
            rgpti[i]->dwItemBits,
            rgpti[i]->dwItemSize,
            rgpti[i]->dwProperties,
            rgpti[i]->faExtendedInfo);
	    WRITE(szBuffer);
    }


	if ((pmh->dwSignature != CMAILMSG_SIGNATURE_VALID) ||
		(pmh->dwHeaderSize != sizeof(MASTER_HEADER)))
		return(E_FAIL);
	return(S_OK);
}

void DoDump(char *pBuffer, DWORD dwLength)
{
	DWORD i, j, l;
	char *p = pBuffer;
	char ch;

	puts("\t00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f | 0123456789abcdef");
	puts("\t------------------------------------------------+-----------------");

	j = 0;
	while (dwLength)
	{
		l = dwLength;
		p = pBuffer;
		printf("%05x0  ", j++);
		for (i = 0; i < 16; i++)
		{
			if (l)
			{
				printf("%02x ", ((DWORD) *p++) & 0xff);
				l--;
			}
			else
				printf("   ");
		}

		l = dwLength;
		p = pBuffer;
		printf("| ");
		for (i = 0; i < 16; i++)
		{
			ch = *p++;
			if (ch < ' ')
				ch = '.';
			printf("%c", ch);
			if (!--l)
				break;
		}

		puts("");

		dwLength = l;
		pBuffer = p;
	}

	puts("\n");
}

HRESULT DumpProps(
			LPPROPERTY_TABLE_INSTANCE	pInst,
			char						*szPrefix
			)
{
	HRESULT				hrRes = S_OK;
	DWORD				dwCount, dwSize, i;
	char				szLine[8192];
	char				szBuffer[256];
	GLOBAL_PROPERTY_ITEM gpi;	
	CPropertyTable	ptTable(
				PTT_PROPERTY_TABLE,
				pInst->dwSignature,
				&bmManager,
				pInst,
				CompareProperty,
				NULL,
				NULL);

	hrRes = ptTable.GetCount(&dwCount);
	if (FAILED(hrRes))
		return(hrRes);

	for (i = 0; i < dwCount; i++)
	{
		char* szCommonName = NULL;
		hrRes = ptTable.GetPropertyItemAndValueUsingIndex(
					i,
					(LPPROPERTY_ITEM)&gpi,
					sizeof(szLine),
					&dwSize,
					(LPBYTE)szLine);
		if (FAILED(hrRes))
			return(hrRes);

		szCommonName = FindPropName(gpi.idProp);
		_ASSERT(szCommonName);
		sprintf(szBuffer, "%sProp ID: %u (%s) at offset 0x%x, length (%u, 0x%x)",
					szPrefix,
					gpi.idProp,
					szCommonName,
					gpi.piItem.faOffset,
					gpi.piItem.dwSize,
					gpi.piItem.dwSize);


		WRITE(szBuffer);
		DoDump(szLine, gpi.piItem.dwSize);
	}
	return(S_OK);
}

DWORD dwNameId[MAX_COLLISION_HASH_KEYS] =
{
	IMMPID_RP_ADDRESS_SMTP,
	IMMPID_RP_ADDRESS_X400,
	IMMPID_RP_ADDRESS_X500,
	IMMPID_RP_LEGACY_EX_DN,
	IMMPID_RP_ADDRESS_OTHER
};

char *szNames[MAX_COLLISION_HASH_KEYS] =
{
	"SMTP",
	"X400",
	"X500",
	"Legacy DN",
    "Other"
};

HRESULT DumpRecipientNames(
			LPRECIPIENTS_PROPERTY_ITEM	prspi
			)
{
	HRESULT	hrRes = S_OK;
	char	szAddress[8192];
	char	szBuffer[1024];
	DWORD	dwSize;
    DWORD   dwTotalSize = sizeof(RECIPIENT_PROPERTY_ITEM);

	sprintf(szBuffer, "\tFlags: %08X", prspi->dwFlags);
	WRITE(szBuffer);

    sprintf(szBuffer,
        "\tProperty Table Instance (%i)\n"
        "\t\tSignature: 0x%08x\n"
        "\t\tfaFirstFragment: 0x%08x\n"
        "\t\tdwFragmentSize: 0x%08x\n"
        "\t\tdwItemBits: 0x%08x\n"
        "\t\tdwItemSize: 0x%08x\n"
        "\t\tdwProperties: 0x%08x\n"
        "\t\tfaExtendedInfo: 0x%08x\n",
        sizeof(RECIPIENTS_PROPERTY_ITEM),
        prspi->ptiInstanceInfo.dwSignature,
        prspi->ptiInstanceInfo.faFirstFragment,
        prspi->ptiInstanceInfo.dwFragmentSize,
        prspi->ptiInstanceInfo.dwItemBits,
        prspi->ptiInstanceInfo.dwItemSize,
        prspi->ptiInstanceInfo.dwProperties,
        prspi->ptiInstanceInfo.faExtendedInfo);
    WRITE(szBuffer);

	for (DWORD i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
	{
		if (prspi->faNameOffset[i] != INVALID_FLAT_ADDRESS)
		{
			for (DWORD j = 0; j < MAX_COLLISION_HASH_KEYS; j++)
				if (prspi->idName[i] == dwNameId[j])
				{
					hrRes = bmManager.ReadMemory(
								(LPBYTE)szAddress,
								prspi->faNameOffset[i],
								prspi->dwNameLength[i],
								&dwSize,
								NULL);
                    dwTotalSize += prspi->dwNameLength[i];
					if (FAILED(hrRes))
						return(hrRes);

					sprintf(szBuffer, "\t(0x%x-0x%x) %s: %s",
                            prspi->faNameOffset[i],
                            prspi->faNameOffset[i] + prspi->dwNameLength[i],
							szNames[j],
							szAddress);
					WRITE(szBuffer);
					break;
				}
			if (j == MAX_COLLISION_HASH_KEYS)
				return(E_FAIL);
		}
	}

    sprintf(szBuffer, "\tRecipient Size: %i\n", dwTotalSize);
	WRITE(szBuffer);

	WRITE("\n");
	return(S_OK);
}

DWORD WINAPI ThreadProc(
			LPVOID	pvContext
			)
{
	char	szBuffer[2048];
	HRESULT	hrRes = S_OK;
	DWORD	dwSize, cStream;

	MASTER_HEADER	Header;

	CPropertyStream	Stream(hStream);
	ZeroMemory((void*)&Header,sizeof(Header));

	// Set the stream
	bmGetStream.SetStream(&Stream);
    Stream.GetSize(NULL, &dwSize, NULL);
    bmManager.SetStreamSize(dwSize);
    cStream = dwSize;

    __try {
        // Read the master header
        hrRes = bmManager.ReadMemory(
                    (LPBYTE)&Header,
                    0,
                    sizeof(MASTER_HEADER),
                    &dwSize,
                    NULL);
        if (FAILED(hrRes))
        {
            sprintf(szBuffer,
                    "Failed to read master header. Error: %08x\n", hrRes);
            WRITE(szBuffer);
            BAIL_WITH_ERROR(E_FAIL);
        }

        hrRes = DumpMasterHeader(&Header, cStream);
        if (FAILED(hrRes))
        {
            sprintf(szBuffer,
                    "Invalid master header. Error: %08x\n", hrRes);
            WRITE(szBuffer);
            BAIL_WITH_ERROR(E_FAIL);
        }

        // Global properties
        {
            sprintf(szBuffer,
                    "Message properties (%u):\n", Header.ptiGlobalProperties.dwProperties);
            WRITE(szBuffer);
            hrRes = DumpProps(
                        &(Header.ptiGlobalProperties),
                        "\t");
            if (FAILED(hrRes))
            {
                sprintf(szBuffer,
                        "Failed to dump global properties. Error: %08x\n", hrRes);
                WRITE(szBuffer);
                BAIL_WITH_ERROR(E_FAIL);
            }
        }

        // Recipient list and their properties
        {
            DWORD	dwCount;

            RECIPIENTS_PROPERTY_ITEM	rspi;

            CPropertyTableItem	ptiItem(
                        &bmManager,
                        &(Header.ptiRecipients));

            sprintf(szBuffer, "Dumping recipients (%u) and their properties:\n",
                        Header.ptiRecipients.dwProperties);
            WRITE(szBuffer);

            dwCount = 0;
            hrRes = ptiItem.GetItemAtIndex(dwCount, (LPPROPERTY_ITEM)&rspi, NULL);
            while (SUCCEEDED(hrRes))
            {
                sprintf(szBuffer, "Recipient %u:\n", dwCount++);
                WRITE(szBuffer);

                // Dump all the names first ...
                hrRes = DumpRecipientNames(&rspi);
                if (FAILED(hrRes))
                {
                    sprintf(szBuffer,
                            "Failed to dump recipient names. Error: %08x\n", hrRes);
                    WRITE(szBuffer);
                    // BAIL_WITH_ERROR(E_FAIL);
                }

                sprintf(szBuffer, "Recipient properties (%u):\n",
                            rspi.ptiInstanceInfo.dwProperties);
                WRITE(szBuffer);
                hrRes = DumpProps(
                            &(rspi.ptiInstanceInfo),
                            "\t");
                if (FAILED(hrRes))
                {
                    sprintf(szBuffer,
                            "Failed to dump recipient properties. Error: %08x\n", hrRes);
                    WRITE(szBuffer);
                    // BAIL_WITH_ERROR(E_FAIL);
                }

                hrRes = ptiItem.GetNextItem((LPPROPERTY_ITEM)&rspi);

            }
            if (FAILED(hrRes) && (hrRes != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)))
            {
                sprintf(szBuffer,
                        "Failed to load recipient record. Error: %08x\n", hrRes);
                WRITE(szBuffer);
                BAIL_WITH_ERROR(E_FAIL);
            }
        }

        if (fFixCorruption) Stream.FixSignature();
    } __except(1) {
        printf("\nERROR!!!: block stream is invalid, aborting dump\n");
    }

	return(NO_ERROR);
}

HRESULT NotificationProc(
			LPVOID	pvCallbackContext
			)
{
	// Report status
	Epilogue(NULL, S_OK);
	return(S_OK);
}

HRESULT Epilogue(
			LPVOID	pvCallbackContext,
			HRESULT	hrRes
			)
{
	return(S_OK);
}

HRESULT CleanupApplication()
{
	if (hStream != INVALID_HANDLE_VALUE)
		CloseHandle(hStream);

	bmManager.Release();

	DWORD	dwLeft = CBlockMemoryAccess::m_Pool.GetAllocCount();
	if (dwLeft)
	{
		char szBuffer[128];
		sprintf(szBuffer,
				"Error, leaking %u cpool objects", dwLeft);
		WRITE(szBuffer);
	}
	CBlockMemoryAccess::m_Pool.ReleaseMemory();
	return(S_OK);
}


CPropertyStream::CPropertyStream(
			HANDLE	hStream,
            BOOL    fFixInvalidSignature
			)
{
	m_hStream = hStream;
    m_cStreamOffset = 0;
    m_fFixInvalidSignature = FALSE;
    m_fInvalidSignature = FALSE;

	if (SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN) == 0xffffffff)
	{
        printf("ERROR: couldn't set file pointer on stream\n");
		return;
	}

    NTFS_STREAM_HEADER header;
    header.dwSignature = 0;
    DWORD dwSizeRead;
	if (!ReadFile(m_hStream, &header, sizeof(NTFS_STREAM_HEADER), &dwSizeRead, NULL)) {
        printf("ERROR: couldn't read NTFS stream header\n");
        return;
	}

    if (header.dwSignature == STREAM_SIGNATURE ||
        header.dwSignature == STREAM_SIGNATURE_INVALID)
    {
        if (header.dwSignature == STREAM_SIGNATURE_INVALID) {
            printf("WARNING: Invalid NTFS stream signature found, analyzing anyway\n");
            m_fInvalidSignature = TRUE;
        }
        m_cStreamOffset = STREAM_OFFSET;
    } else {
        m_fInvalidSignature = FALSE;
    }
}

CPropertyStream::~CPropertyStream(
			)
{
    if (m_fFixInvalidSignature && m_fInvalidSignature) {
        printf("Updating invalid signature\n");
        if (SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN) == 0xffffffff)
        {
            printf("ERROR: couldn't set file pointer on stream\n");
            return;
        }

        NTFS_STREAM_HEADER header;
        header.dwSignature = STREAM_SIGNATURE;
        DWORD dwSizeWritten;
        if (!WriteFile(m_hStream, &header, sizeof(header.dwSignature), &dwSizeWritten, NULL) ||
            dwSizeWritten != sizeof(header.dwSignature))
        {
            printf("ERROR: couldn't write NTFS stream header\n");
            return;
        }
    }
}


//
// IMailMsgPropertyStream
//
HRESULT STDMETHODCALLTYPE CPropertyStream::GetSize(
            IMailMsgProperties  *pMsg,
			DWORD			*pdwSize,
			IMailMsgNotify	*pNotify
			)
{
	DWORD	dwHigh, dwLow;

	if (m_hStream == INVALID_HANDLE_VALUE)
		return(E_FAIL);

	dwLow = GetFileSize(m_hStream, &dwHigh);
	if (dwHigh)
		return(HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));

	*pdwSize = dwLow - m_cStreamOffset;
	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CPropertyStream::ReadBlocks(
            IMailMsgProperties  *pMsg,
			DWORD			dwCount,
			DWORD			*pdwOffset,
			DWORD			*pdwLength,
			BYTE			**ppbBlock,
			IMailMsgNotify	*pNotify
			)
{
	DWORD	dwSizeRead;
	HRESULT	hrRes = S_OK;

	if (m_hStream == INVALID_HANDLE_VALUE)
		return(E_FAIL);

	for (DWORD i = 0; i < dwCount; i++, pdwOffset++, pdwLength++, ppbBlock++)
	{
		if (SetFilePointer(
					m_hStream,
					*pdwOffset + m_cStreamOffset,
					NULL,
					FILE_BEGIN) == 0xffffffff)
		{
			hrRes = HRESULT_FROM_WIN32(GetLastError());
			break;
		}

		if (!ReadFile(
					m_hStream,
					*ppbBlock,
					*pdwLength,
					&dwSizeRead,
					NULL) ||
			(dwSizeRead != *pdwLength))
		{
			hrRes = HRESULT_FROM_WIN32(GetLastError());
			break;
		}
	}
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CPropertyStream::WriteBlocks(
            IMailMsgProperties  *pMsg,
			DWORD			dwCount,
			DWORD			*pdwOffset,
			DWORD			*pdwLength,
			BYTE			**ppbBlock,
			IMailMsgNotify	*pNotify
			)
{
	DWORD	dwSizeWritten;
	HRESULT	hrRes = S_OK;

	if (m_hStream == INVALID_HANDLE_VALUE)
		return(E_FAIL);

	for (DWORD i = 0; i < dwCount; i++, pdwOffset++, pdwLength++, ppbBlock++)
	{
		if (SetFilePointer(
					m_hStream,
					*pdwOffset + m_cStreamOffset,
					NULL,
					FILE_BEGIN) == 0xffffffff)
		{
			hrRes = HRESULT_FROM_WIN32(GetLastError());
			break;
		}

		if (!WriteFile(
					m_hStream,
					*ppbBlock,
					*pdwLength,
					&dwSizeWritten,
					NULL) ||
			(dwSizeWritten != *pdwLength))
		{
			hrRes = HRESULT_FROM_WIN32(GetLastError());
			break;
		}
	}
	return(hrRes);
}


DECLARE_DEBUG_PRINTS_OBJECT()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED_)
#define AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif


#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define _ASSERTE _ASSERT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\dumpmsg\dumpmsg.h ===
#ifndef __DUMPMSG_H_
#define __DUMPMSG_H_

// per-message properties DWORD values

DWORD dwMPNameId[] =
{	4096,
	4097,
	4098,
	4099,
	4100,
	4101,
	4102,
	4103,
	4104,
	4105,
	4106,
	4107,
	4108,
	4109,
	4110,
	4111,
	4112,
	4113,
	4114,
	4115,
	4116,
	4117,
	4118,
	4119,
	4120,
	4121,
	4122,
	4123,
	4124,
	4125,
	4126,
	4127,
	4128,
	4129,
	4130,
	4131,
	4132,
	4133,
	4134,
	4135,
	4136,
	4137,
	4138,
	4139,
	4140,
	4141,
	4142,
	4143,
	4144,
	4145,
	4146
};

// per-message properties string values

char* szMPValues[] =
{	"IMMPID_MP_RECIPIENT_LIST",
	"IMMPID_MP_CONTENT_FILE_NAME",
	"IMMPID_MP_SENDER_ADDRESS_SMTP",
	"IMMPID_MP_SENDER_ADDRESS_X500",
	"IMMPID_MP_SENDER_ADDRESS_X400",
	"IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN",
	"IMMPID_MP_DOMAIN_LIST",
	"IMMPID_MP_PICKUP_FILE_NAME",
	"IMMPID_MP_AUTHENTICATED_USER_NAME",
	"IMMPID_MP_CONNECTION_IP_ADDRESS",
	"IMMPID_MP_HELO_DOMAIN",
	"IMMPID_MP_EIGHTBIT_MIME_OPTION",
	"IMMPID_MP_CHUNKING_OPTION",
	"IMMPID_MP_BINARYMIME_OPTION",
	"IMMPID_MP_REMOTE_AUTHENTICATION_TYPE",
	"IMMPID_MP_ERROR_CODE",
	"IMMPID_MP_DSN_ENVID_VALUE",
	"IMMPID_MP_DSN_RET_VALUE",
	"IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE",
	"IMMPID_MP_ARRIVAL_TIME",
	"IMMPID_MP_MESSAGE_STATUS",
	"IMMPID_MP_EXPIRE_DELAY",
	"IMMPID_MP_EXPIRE_NDR",
	"IMMPID_MP_LOCAL_EXPIRE_DELAY",
	"IMMPID_MP_LOCAL_EXPIRE_NDR",
	"IMMPID_MP_ARRIVAL_FILETIME",
	"IMMPID_MP_HR_CAT_STATUS",
	"IMMPID_MP_MSG_GUID",
	"IMMPID_MP_SUPERSEDES_MSG_GUID",
	"IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF",
	"IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF",
	"IMMPID_MP_MSG_SIZE_HINT",
	"IMMPID_MP_RFC822_MSG_ID",
	"IMMPID_MP_RFC822_MSG_SUBJECT",
	"IMMPID_MP_RFC822_FROM_ADDRESS",
	"IMMPID_MP_RFC822_TO_ADDRESS",
	"IMMPID_MP_RFC822_CC_ADDRESS",
	"IMMPID_MP_RFC822_BCC_ADDRESS",
	"IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS",
	"IMMPID_MP_SERVER_NAME",
	"IMMPID_MP_SERVER_VERSION",
	"IMMPID_MP_NUM_RECIPIENTS",
	"IMMPID_MP_X_PRIORITY",
	"IMMPID_MP_FROM_ADDRESS",
	"IMMPID_MP_SENDER_ADDRESS",
	"IMMPID_MP_DEFERRED_DELIVERY_FILETIME",
	"IMMPID_MP_SENDER_ADDRESS_OTHER",
	"IMMPID_MP_ORIGINAL_ARRIVAL_TIME",
	"IMMPID_MP_MSGCLASS",
	"IMMPID_MP_CONTENT_TYPE",
	"IMMPID_MP_ENCRYPTION_TYPE"
};

// per-recipient properties DWORD values

DWORD dwRPNameId[] =
{	8192,
	8193,
	8194,
	8195,
	8196,
	8197,
	8198,
	8199,
	8200,
	8201,
	8202,
	8203,
	8204,
	8205,
	8206,
	8207,
	8208,
	8209,
	8210,
	8211
};

// per-recipient properties string values

char* szRPValues[] =
{	"IMMPID_RP_DSN_NOTIFY_SUCCESS",
	"IMMPID_RP_DSN_NOTIFY_INVALID",
	"IMMPID_RP_ADDRESS_TYPE",
	"IMMPID_RP_ADDRESS",
	"IMMPID_RP_ADDRESS_TYPE_SMTP",
	"IMMPID_RP_ERROR_CODE",
	"IMMPID_RP_ERROR_STRING",
	"IMMPID_RP_DSN_NOTIFY_VALUE",
	"IMMPID_RP_DSN_ORCPT_VALUE",
	"IMMPID_RP_ADDRESS_SMTP",
	"IMMPID_RP_ADDRESS_X400",
	"IMMPID_RP_ADDRESS_X500",
	"IMMPID_RP_LEGACY_EX_DN",
	"IMMPID_RP_RECIPIENT_FLAGS",
	"IMMPID_RP_SMTP_STATUS_STRING",
	"IMMPID_RP_DSN_PRE_CAT_ADDRESS",
	"IMMPID_RP_MDB_GUID",
	"IMMPID_RP_USER_GUID",
	"IMMPID_RP_DOMAIN",
	"IMMPID_RP_ADDRESS_OTHER"
};

// per-message volatile properties DWORD values

DWORD dwMPVNameId[] =
{	12288,
	12289
};

// per-message volatile properties string values

char* szMPVValues[] =
{	"IMMPID_MPV_STORE_DRIVER_HANDLE",
	"IMMPID_MPV_MESSAGE_CREATION_FLAGS"
};

// per-recipient volatile properties DWORD values

DWORD dwRPVNameId[] =
{	16384,
	16385
};

// per-recipient volatile properties string values

char* szRPVValues[] =
{	"IMMPID_RPV_DONT_DELIVER",
	"IMMPID_RPV_NO_NAME_COLLISIONS"
};

// per-recipient properties for NNTP DWORD values

DWORD dwNMPNameId[] =
{	24576,
	24577,
	24578,
	24579,
	24580,
	24581,
	24582,
	24583,
	24584
};

// per-recipient properties for NNTP string values

char* szNMPValues[] =
{	"IMMPID_NMP_SECONDARY_GROUPS",
	"IMMPID_NMP_SECONDARY_ARTNUM",
	"IMMPID_NMP_PRIMARY_GROUP",
	"IMMPID_NMP_PRIMARY_ARTID",
	"IMMPID_NMP_POST_TOKEN",
	"IMMPID_NMP_NEWSGROUP_LIST",
	"IMMPID_NMP_HEADERS",
	"IMMPID_NMP_NNTP_PROCESSING",
	"IMMPID_NMP_NNTP_APPROVED_HEADER"
};
#endif //__DUMPMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmailmsg.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmailmsg.cpp

Abstract:

    This module contains the implementation of the mail message class

Author:

    Keith Lau   (keithlau@microsoft.com)

Revision History:

    keithlau    03/10/98    created

--*/

#pragma warning (error : 4032)
#pragma warning (error : 4057)
//#define WIN32_LEAN_AND_MEAN
#include "atq.h"
#include <stddef.h>

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"

// =================================================================
// Private Definitions
//

#define CMAILMSG_VERSION_HIGH                   ((WORD)1)
#define CMAILMSG_VERSION_LOW                    ((WORD)0)



// =================================================================
// Static declarations
//
CPool CMailMsgRecipientsAdd::m_Pool((DWORD)'pAMv');

long CMailMsg::g_cOpenContentHandles = 0;
long CMailMsg::g_cOpenStreamHandles = 0;
long CMailMsg::g_cTotalUsageCount = 0;
long CMailMsg::g_cTotalReleaseUsageCalls = 0;
long CMailMsg::g_cTotalReleaseUsageNonZero = 0;
long CMailMsg::g_cTotalReleaseUsageCloseStream = 0;
long CMailMsg::g_cTotalReleaseUsageCloseContent = 0;
long CMailMsg::g_cTotalReleaseUsageCloseFail = 0;
long CMailMsg::g_cTotalReleaseUsageCommitFail = 0;
long CMailMsg::g_cTotalReleaseUsageNothingToClose = 0;
long CMailMsg::g_cTotalExternalReleaseUsageZero = 0;
long CMailMsg::g_cCurrentMsgsClosedByExternalReleaseUsage = 0;

//
// Specific property table instance info for this type of property table
//
const MASTER_HEADER CMailMsg::s_DefaultHeader =
{
    // Header stuff
    CMAILMSG_SIGNATURE_VALID,
    CMAILMSG_VERSION_HIGH,
    CMAILMSG_VERSION_LOW,
    sizeof(MASTER_HEADER),

    // Global property table instance info
    {
        GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID,
        INVALID_FLAT_ADDRESS,
        GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE,
        GLOBAL_PROPERTY_ITEM_BITS,
        GLOBAL_PROPERTY_ITEM_SIZE,
        0,
        INVALID_FLAT_ADDRESS
    },

    // Recipients table instance info
    {
        RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID,
        INVALID_FLAT_ADDRESS,
        RECIPIENTS_PROPERTY_TABLE_FRAGMENT_SIZE,
        RECIPIENTS_PROPERTY_ITEM_BITS,
        RECIPIENTS_PROPERTY_ITEM_SIZE,
        0,
        INVALID_FLAT_ADDRESS
    },

    // Property management table instance info
    {
        PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID,
        INVALID_FLAT_ADDRESS,
        PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE,
        PROPID_MGMT_PROPERTY_ITEM_BITS,
        PROPID_MGMT_PROPERTY_ITEM_SIZE,
        0,
        IMMPID_CP_START
    }

};


//
// Well-known global properties
//
INTERNAL_PROPERTY_ITEM
                *const CMailMsg::s_pWellKnownProperties = NULL;
const DWORD     CMailMsg::s_dwWellKnownProperties = 0;


// =================================================================
// Compare function
//

HRESULT CMailMsg::CompareProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem
            )
{
    if (*(PROP_ID *)pvPropKey == ((LPGLOBAL_PROPERTY_ITEM)pItem)->idProp)
        return(S_OK);
    return(STG_E_UNKNOWN);
}


// =================================================================
// Implementation of CMailMsg
//
CMailMsg::CMailMsg() :
    CMailMsgPropertyManagement(
                &m_bmBlockManager,
                &(m_Header.ptiPropertyMgmt)
                ),
    CMailMsgRecipients(
                &m_bmBlockManager,
                &(m_Header.ptiRecipients)
                ),
    m_ptProperties(
                PTT_PROPERTY_TABLE,
                GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID,
                &m_bmBlockManager,
                &(m_Header.ptiGlobalProperties),
                CompareProperty,
                s_pWellKnownProperties,
                s_dwWellKnownProperties
                ),
    m_SpecialPropertyTable(
                &g_SpecialMessagePropertyTable
                ),

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4355)

    m_bmBlockManager(
                this,
                (CBlockManagerGetStream *)this
                )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif

{
    m_ulUsageCount = 0;
    m_ulRecipientCount = 0;
    m_pbStoreDriverHandle = NULL;
    m_dwStoreDriverHandle = 0;
    m_cContentFile = 0xffffffff;
    m_fCommitCalled = FALSE;
    m_fDeleted = FALSE;
    m_cCloseOnExternalReleaseUsage = 0;

    // Copy the default master header into our instance
    MoveMemory(&m_Header, &s_DefaultHeader, sizeof(MASTER_HEADER));

    m_dwCreationFlags = 0;

    // Initialize our members.
    m_hContentFile          = NULL;
    m_pStream               = NULL;
    m_pStore                = NULL;
    m_pvClientContext       = NULL;
    m_pfnCompletion         = NULL;
    m_dwTimeout             = INFINITE;
    m_pDefaultRebindStoreDriver = NULL;
    InitializeListHead(&m_leAQueueListEntry);
}

void CMailMsg::FinalRelease()
{
#ifdef MAILMSG_FORCE_RELEASE_USAGE_BEFORE_FINAL_RELEASE
    // Make sure the usage count is already zero
    // If this assert fires, someone is still holding a usage count
    // to the object without a reference count
    _ASSERT(m_ulUsageCount == 0);
#endif //MAILMSG_FORCE_RELEASE_USAGE_BEFORE_FINAL_RELEASE
    InternalReleaseUsage(RELEASE_USAGE_FINAL_RELEASE);

    // Invalidate the master header
    m_Header.dwSignature = CMAILMSG_SIGNATURE_INVALID;

    if (m_cCloseOnExternalReleaseUsage)
        InterlockedDecrement(&g_cCurrentMsgsClosedByExternalReleaseUsage);

    // Free the store driver handle blob, if allocated
    if (m_pbStoreDriverHandle)
    {
        CMemoryAccess   cmaAccess;
        if (!SUCCEEDED(cmaAccess.FreeBlock(m_pbStoreDriverHandle)))
        {
            _ASSERT(FALSE);
        }
        m_pbStoreDriverHandle = NULL;
    }
}

CMailMsg::~CMailMsg()
{
    //
    // In normal usage CMailMsg::FinalRelease() should be called.  This is
    // here for legacy unit tests which don't use that interface.
    //
    if (m_Header.dwSignature != CMAILMSG_SIGNATURE_INVALID) {
        FinalRelease();
    }
}

HRESULT CMailMsg::Initialize()
{
    HRESULT         hrRes       = S_OK;
    FLAT_ADDRESS    faOffset;
    DWORD           dwSize;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::Initialize");

    // On initialize, we would have to allocate sufficient memory for
    // our master header.

    DebugTrace((LPARAM)this,
                "Allocating memory for master header");
    hrRes = m_bmBlockManager.AllocateMemory(
                    sizeof(MASTER_HEADER),
                    &faOffset,
                    &dwSize,
                    NULL);
    if (!SUCCEEDED(hrRes))
        return(hrRes);

    // Note that we don't have to write this to flat memory until we are
    // asked to commit, so we defer that write

    // Nobody should have allocated memory before Initialize is called.
    _ASSERT(faOffset == (FLAT_ADDRESS)0);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsg::QueryBlockManager(
            CBlockManager   **ppBlockManager
            )
{
    if (!ppBlockManager)
        return(STG_E_INVALIDPARAMETER);
    *ppBlockManager = &m_bmBlockManager;
    return(S_OK);
}


// =================================================================
// Implementation of IMailMsgProperties
//

HRESULT STDMETHODCALLTYPE CMailMsg::PutProperty(
            DWORD   dwPropID,
            DWORD   cbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                 hrRes = S_OK;
    GLOBAL_PROPERTY_ITEM    piItem;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::PutProperty");

    // Handle special properties first
    hrRes = m_SpecialPropertyTable.PutProperty(
                (PROP_ID)dwPropID,
                (LPVOID)this,
                NULL,
                PT_NONE,
                cbLength,
                pbValue,
                TRUE);
    if (SUCCEEDED(hrRes) && (hrRes != S_OK))
    {
        piItem.idProp = dwPropID;
        hrRes = m_ptProperties.PutProperty(
                        (LPVOID)&dwPropID,
                        (LPPROPERTY_ITEM)&piItem,
                        cbLength,
                        pbValue);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::GetProperty(
            DWORD   dwPropID,
            DWORD   cbLength,
            DWORD   *pcbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                 hrRes = S_OK;
    GLOBAL_PROPERTY_ITEM    piItem;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetProperty");

    // Special properties are optimized
    // Handle special properties first
    hrRes = m_SpecialPropertyTable.GetProperty(
                (PROP_ID)dwPropID,
                (LPVOID)this,
                NULL,
                PT_NONE,
                cbLength,
                pcbLength,
                pbValue,
                TRUE);
    if (SUCCEEDED(hrRes) && (hrRes != S_OK))
    {
        hrRes = m_ptProperties.GetPropertyItemAndValue(
                        (LPVOID)&dwPropID,
                        (LPPROPERTY_ITEM)&piItem,
                        cbLength,
                        pcbLength,
                        pbValue);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::Commit(
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::Commit");

    // We are doing a global commit, this means several things:
    // 0) Commit the content
    // 1) Commit all global properties
    // 2) Commit all recipients and per-recipient properties
    // 3) Commit PROP ID management information
    // 4) Commit the master header

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary(FALSE, TRUE);
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_pStream);
    _ASSERT(!m_fDeleted);

    // Flush the content 1st... a valid P1 does us no good without
    // the message content.  If the machine is turned off after
    // we commit the P1, but before the P2 is commited, then we
    // may attempt delivery of corrupt messages
    //      6/2/99 - MikeSwa
    if (m_hContentFile &&
        !FlushFileBuffers(m_hContentFile->m_hFile))
    {
        m_bmBlockManager.SetDirty(TRUE);
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hrRes))
            hrRes = E_FAIL;
    }

    if (SUCCEEDED(hrRes))
    {
#ifdef DEBUG
        MASTER_HEADER MasterHeaderOrig;
        memcpy(&MasterHeaderOrig, &m_Header, sizeof(MASTER_HEADER));
#endif

        hrRes = m_bmBlockManager.AtomicWriteAndIncrement(
                        (LPBYTE)&m_Header,
                        (FLAT_ADDRESS)0,
                        sizeof(MASTER_HEADER),
                        NULL,
                        0,
                        0,
                        NULL);
        if (SUCCEEDED(hrRes))
        {
            m_bmBlockManager.SetDirty(FALSE);
            hrRes = GetProperties(m_pStream, MAILMSG_GETPROPS_MARKCOMMIT |
                                             MAILMSG_GETPROPS_COMPLETE, NULL);
            if (FAILED(hrRes)) {
                m_bmBlockManager.SetCommitMode(FALSE);
                m_bmBlockManager.SetDirty(TRUE);
            }
        }

#ifdef DEBUG
        // verify that none of the global state changed during the commit
        _ASSERT(memcmp(&MasterHeaderOrig, &m_Header, sizeof(MASTER_HEADER)) == 0);
#endif
    }

    if (SUCCEEDED(hrRes)) {
        m_fCommitCalled = TRUE;
        _ASSERT(!(m_bmBlockManager.IsDirty()));
    } else {
        _ASSERT(m_bmBlockManager.IsDirty());
    }
    m_bmBlockManager.SetCommitMode(FALSE);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::GetContentSize(
            DWORD           *pdwSize,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwHigh;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetContentSize");

    if (!pdwSize) return E_POINTER;

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    if (m_cContentFile == 0xffffffff) {
        // Call WIN32
        *pdwSize = GetFileSizeFromContext(m_hContentFile, &dwHigh);

        // If the size is more than 32 bits, barf.
        if (*pdwSize == 0xffffffff)
            hrRes = HRESULT_FROM_WIN32(GetLastError());
        else if (dwHigh)
            hrRes = HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

        if (m_fCommitCalled) m_cContentFile = *pdwSize;
    } else {
        // m_cContentFile should only be saved after Commit has been
        // called.  Otherwise the size of the file could be changed
        // by the store writing to the content file.
        _ASSERT(m_fCommitCalled);
        *pdwSize = m_cContentFile;
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::SetContentSize(
            DWORD           dwSize,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwHigh;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetContentSize");

    // make sure that the store supports writeable content
    hrRes = m_pStore->SupportWriteContent();
    _ASSERT(SUCCEEDED(hrRes));
    if (hrRes != S_OK) {
        return((hrRes == S_FALSE) ? HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) : hrRes);
    }

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    // set the file size
    if (SetFilePointer(m_hContentFile->m_hFile, dwSize, 0, FILE_BEGIN) == 0xffffffff)
        return HRESULT_FROM_WIN32(GetLastError());

    // set end of file
    if (!SetEndOfFile(m_hContentFile->m_hFile))
        return HRESULT_FROM_WIN32(GetLastError());

    m_dwCreationFlags |= MPV_WRITE_CONTENT;

    TraceFunctLeave();
    return(hrRes);
}

HRESULT DummyAsyncReadOrWriteFile(
            BOOL            fRead,
            PFIO_CONTEXT    pFIO,
            HANDLE          hEvent,
            DWORD           dwOffset,
            DWORD           dwLength,
            DWORD           *pdwLength,
            BYTE            *pbBlock
            )
{
    BOOL            fRet;
    HRESULT         hrRes       = S_OK;
    FH_OVERLAPPED   ol;

    TraceFunctEnter("::DummyAsyncReadOrWriteFile");

    // Set up the overlapped structure
    ol.Internal     = 0;
    ol.InternalHigh = 0;
    ol.Offset       = dwOffset;
    ol.OffsetHigh   = 0;

    //There is no way to accurately tell if a handle is associated with an
    //ATQ context... until we standardize on how async writes are
    //happening, we will force synchonous writes by setting the low
    //bits (previously we waited for completion anyway).
    ol.hEvent       = (HANDLE) (((DWORD_PTR)hEvent) | 0x00000001);
    ol.pfnCompletion = NULL;

    // Deals with both synchronous and async read/Write
    if (fRead)
        fRet = FIOReadFile(
                    pFIO,
                    pbBlock,
                    dwLength,
                    &ol);
    else
        fRet = FIOWriteFile(
                    pFIO,
                    pbBlock,
                    dwLength,
                    &ol);
    DWORD dwError;
    if (fRet) {
        dwError = ERROR_IO_PENDING;
    } else {
        dwError = GetLastError();
    }

    if (dwError != ERROR_IO_PENDING) {
        hrRes = HRESULT_FROM_WIN32(dwError);
    } else {
        // Async, wait on the event to complete
        dwError = WaitForSingleObject(hEvent, INFINITE);
        _ASSERT(dwError == WAIT_OBJECT_0);

        if (!GetOverlappedResult(
                    pFIO->m_hFile,
                    (OVERLAPPED *) &ol,
                    pdwLength,
                    FALSE))
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            if (hrRes == S_OK)
                hrRes = E_FAIL;

            DebugTrace((LPARAM)&ol, "GetOverlappedResult failed tih %08x", hrRes);
        }
    }

    // The caller would have to make sure the bytes read/written
    // is the same as requested. This is consistent with NT ReadFile

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::ReadContent(
            DWORD           dwOffset,
            DWORD           dwLength,
            DWORD           *pdwLength,
            BYTE            *pbBlock,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes       = S_OK;
    HANDLE  hEvent      = NULL;

    if (!pdwLength || !pbBlock) return E_POINTER;
    if (dwLength == 0) return E_INVALIDARG;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::ReadContent");

    if (!m_pStore) return E_ACCESSDENIED;

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    // Set up the event just to feign asynchronous operations
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hEvent)
        hrRes = HRESULT_FROM_WIN32(GetLastError());
    else
    {
        // Call our own dummy function for now
        hrRes = DummyAsyncReadOrWriteFile(
                    TRUE,
                    m_hContentFile,
                    hEvent,
                    dwOffset,
                    dwLength,
                    pdwLength,
                    pbBlock);

        if (!CloseHandle(hEvent)) { _ASSERT((GetLastError() == NO_ERROR) && FALSE); }
    }

    // Call the async completion routine
    if (pNotify)
        hrRes = pNotify->Notify(hrRes);

    TraceFunctLeave();
    //
    // When we move to the real async model, make sure we
    // return MAILMSG_S_PENDING instead of S_OK
    //
    return(pNotify?S_OK:hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::WriteContent(
            DWORD           dwOffset,
            DWORD           dwLength,
            DWORD           *pdwLength,
            BYTE            *pbBlock,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes       = S_OK;
    HANDLE  hEvent      = NULL;

    if (!pdwLength || !pbBlock) return E_POINTER;
    if (dwLength == 0) return E_INVALIDARG;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::WriteContent");

    if (!m_pStore) return E_ACCESSDENIED;

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    // see if the driver allows writable content
    hrRes = m_pStore->SupportWriteContent();
    _ASSERT(SUCCEEDED(hrRes));
    if (hrRes != S_OK) {
        return((hrRes == S_FALSE) ? HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) : hrRes);
    }

    // Set up the event just to feign asynchronous operations
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hEvent)
        hrRes = HRESULT_FROM_WIN32(GetLastError());
    else
    {
        m_cContentFile = 0xffffffff;

        // Call our own dummy function for now
        hrRes = DummyAsyncReadOrWriteFile(
                    FALSE,
                    m_hContentFile,
                    hEvent,
                    dwOffset,
                    dwLength,
                    pdwLength,
                    pbBlock);

        if (!CloseHandle(hEvent)) { _ASSERT((GetLastError() == NO_ERROR) && FALSE); }
    }

    if (SUCCEEDED(hrRes)) m_dwCreationFlags |= MPV_WRITE_CONTENT;

    // Call the async completion routine
    if (pNotify)
        hrRes = pNotify->Notify(hrRes);

    TraceFunctLeave();
    //
    // When we move to the real async model, make sure we
    // return MAILMSG_S_PENDING instead of S_OK
    //
    return(pNotify?S_OK:hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToFile(
            PFIO_CONTEXT    hCopy,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;

    if (!hCopy) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToFile");

    hrRes = CopyContentToStreamOrFile(
                FALSE,
                hCopy,
                pNotify, 0);

    TraceFunctLeave();
    return(hrRes);
}

#if 0
HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToFile(
            PFIO_CONTEXT    hCopy,
            IMailMsgNotify  *pNotify
            )
{
    return CopyContentToFileEx(hCopy, FALSE, pNotify);
}
#endif

HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToFileEx(
            PFIO_CONTEXT    hCopy,
            BOOL            fDotStuffed,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;

    if (!hCopy) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToFile");

    BOOL fModified;

    if (!ProduceDotStuffedContextInContext(m_hContentFile,
                                           hCopy,
                                           fDotStuffed,
                                           &fModified))
    {
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        _ASSERT(hrRes != S_OK);
        if (hrRes == S_OK) hrRes = E_FAIL;
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToStream(
            IMailMsgPropertyStream  *pStream,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;

    if (!pStream) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToStream");

    hrRes = CopyContentToStreamOrFile(
                TRUE,
                (LPVOID)pStream,
                pNotify, 0);

    TraceFunctLeave();
    return(hrRes);
}

//Copies the content of an IMailMsg to a file starting at the given
//offset (used for embedding and attaching messages).
HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToFileAtOffset(
                PFIO_CONTEXT    hCopy,  //handle to copy to
                DWORD           dwOffset, //offset to start copy at
                IMailMsgNotify  *pNotify  //notification routing
                )
{
    HRESULT hrRes = S_OK;

    if (!hCopy) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToFileAtOffset");

    hrRes = CopyContentToStreamOrFile(
                FALSE,
                hCopy,
                pNotify, dwOffset);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsg::CopyContentToStreamOrFile(
            BOOL            fIsStream,
            LPVOID          pStreamOrHandle,
            IMailMsgNotify  *pNotify,
            DWORD           dwDestOffset //offset to start at in dest file
            )
{
    HRESULT hrRes       = S_OK;
    BYTE    bBuffer[64 * 1024];
    LPBYTE  pbBuffer    = bBuffer;;
    DWORD   dwCurrent   = dwDestOffset;
    DWORD   dwRemaining = 0;
    DWORD   dwCopy      = 0;
    DWORD   dwOffset    = 0;
    DWORD   dwCopied;
    HANDLE  hEvent      = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToStreamOrFile");

    // Parameter checking
    if (!pStreamOrHandle) return STG_E_INVALIDPARAMETER;

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    // Copy in fixed size chunks
    hrRes = GetContentSize(&dwRemaining, pNotify);
    if (!SUCCEEDED(hrRes))
        goto Cleanup;

    // Set up the event just to feign asynchronous operations
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hEvent)
    {
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    while (dwRemaining)
    {
        dwCopy = sizeof(bBuffer);
        if (dwRemaining < dwCopy)
            dwCopy = dwRemaining;

        // Read content
        hrRes = DummyAsyncReadOrWriteFile(
                    TRUE,
                    m_hContentFile,
                    hEvent,
                    dwOffset,
                    dwCopy,
                    &dwCopied,
                    bBuffer);
        if (SUCCEEDED(hrRes))
        {
            // Write content
            if (fIsStream)
            {
                IMailMsgPropertyStream  *pStream;
                pStream = (IMailMsgPropertyStream *)pStreamOrHandle;

                hrRes = pStream->WriteBlocks(
                            this,
                            1,
                            &dwCurrent,
                            &dwCopy,
                            &pbBuffer,
                            pNotify);
                dwCurrent += dwCopy;
            }
            else
            {
                hrRes = DummyAsyncReadOrWriteFile(
                            FALSE,
                            (PFIO_CONTEXT) pStreamOrHandle,
                            hEvent,
                            dwOffset + dwDestOffset,
                            dwCopy,
                            &dwCopied,
                            bBuffer);
            }

            if (!SUCCEEDED(hrRes))
                break;
        }
        else
            break;

        dwRemaining -= dwCopy;
        dwOffset += dwCopy;
    }

    // Call the async completion routine if provided
    if (pNotify)
        pNotify->Notify(hrRes);

Cleanup:

    if (hEvent)
        if (!CloseHandle(hEvent)) { _ASSERT((GetLastError() == NO_ERROR) && FALSE); }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::MapContent(
                BOOL            fWrite,
                BYTE            **ppbContent,
                DWORD           *pcContent
                )
{
    TraceFunctEnter("CMailMsg::MapContent");

    HANDLE hFileMapping;
    HRESULT hr;

    //
    // Make sure that we are allowed to write to the file if they want
    // write access
    //
    if (fWrite) {
        hr = m_pStore->SupportWriteContent();
        _ASSERT(SUCCEEDED(hr));
        if (hr != S_OK) {
            return((hr == S_FALSE) ?
                        HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) : hr);
        }
    }

    //
    // Make sure we have a content handle
    //
    hr = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hr)) {
        ErrorTrace((LPARAM) this, "RestoreResourcesIfNecessary returned %x", hr);
        TraceFunctLeave();
        return(hr);
    }
    _ASSERT(m_hContentFile != NULL);

    //
    // Get the size of the file
    //
    hr = GetContentSize(pcContent, NULL);
    if (!SUCCEEDED(hr)) {
        ErrorTrace((LPARAM) this, "GetContentSize returned %x", hr);
        TraceFunctLeave();
        return(hr);
    }

    //
    // Create the file mapping
    //
    hFileMapping = CreateFileMapping(m_hContentFile->m_hFile,
                                     NULL,
                                     (fWrite) ? PAGE_READWRITE : PAGE_READONLY,
                                     0,
                                     0,
                                     NULL);
    if (hFileMapping == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "MapContent failed with 0x%x", hr);
        TraceFunctLeave();
        return hr;
    }

    //
    // Map the file into memory
    //
    *ppbContent = (BYTE *) MapViewOfFile(hFileMapping,
                                         (fWrite) ?
                                            FILE_MAP_WRITE : FILE_MAP_READ,
                                         0,
                                         0,
                                         0);
    // don't need the mapping handle now
    CloseHandle(hFileMapping);
    if (*ppbContent == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "MapViewOfFile failed with 0x%x", hr);
    } else {
        DebugTrace((LPARAM) this,
                   "MapContent succeeded, *ppbContent = 0x%x, *pcContent = %i",
                   *ppbContent,
                   *pcContent);
        hr = S_OK;
    }

    if (fWrite && SUCCEEDED(hr)) m_dwCreationFlags |= MPV_WRITE_CONTENT;

    TraceFunctLeave();
    return hr;
}

HRESULT STDMETHODCALLTYPE CMailMsg::UnmapContent(BYTE *pbContent) {
    TraceFunctEnter("CMailMsg::UnmapContent");

    HRESULT hr = S_OK;

    DebugTrace((LPARAM) this, "pbContent = 0x%x", pbContent);

    //
    // Just call the Win32 API to unmap the content
    //
    if (!UnmapViewOfFile(pbContent)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "UnmapViewOfFile returned %x", hr);
    }

    TraceFunctLeave();
    return hr;
}

HRESULT CMailMsg::ValidateProperties(CBlockManager *pBM,
                                     DWORD cStream,
                                     PROPERTY_TABLE_INSTANCE *pti)
{
    TraceFunctEnter("CMailMsg::ValidateProperties");

    DWORD dwItemBits;
    DWORD dwItemSize;
    DWORD dwFragmentSize;
    HRESULT hr;

    //
    // Validate that all of the property table entries are valid.
    //
    switch(pti->dwSignature) {
        case GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID:
            DebugTrace((LPARAM) this, "Global property table");
            dwItemBits = GLOBAL_PROPERTY_ITEM_BITS;
            dwItemSize = GLOBAL_PROPERTY_ITEM_SIZE;
            dwFragmentSize = GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE;
            break;
        case RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID:
            DebugTrace((LPARAM) this, "Recipients property table");
            dwItemSize = RECIPIENTS_PROPERTY_ITEM_SIZE;
            // these two values are changed during writelist, so we
            // can't count on their values being consistent.  Setting
            // them to 0 tells the code below to skip the check
            dwItemBits = 0;
            dwFragmentSize = 0;
            break;
        case RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID:
            DebugTrace((LPARAM) this, "Recipient property table");
            dwItemBits = RECIPIENT_PROPERTY_ITEM_BITS;
            dwItemSize = RECIPIENT_PROPERTY_ITEM_SIZE;
            dwFragmentSize = RECIPIENT_PROPERTY_TABLE_FRAGMENT_SIZE;
            break;
        case PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID:
            DebugTrace((LPARAM) this, "PropID Mgmt property table");
            dwItemBits = PROPID_MGMT_PROPERTY_ITEM_BITS;
            dwItemSize = PROPID_MGMT_PROPERTY_ITEM_SIZE;
            dwFragmentSize = PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE;
            break;
        default:
            DebugTrace((LPARAM) this, "Signature 0x%x isn't valid for CMM",
                pti->dwSignature);
            TraceFunctLeave();
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    //
    // check all of the fields in the property table instance header.
    // note that some property tables abuse the fields and we have to
    // allow them:
    //   recipients property table doesn't have a fragment size or item bits
    //   property management table uses faExtendedInfo as an arbitrary DWORD,
    //     not a flat address
    //
    if ((pti->dwFragmentSize != dwFragmentSize && dwFragmentSize != 0) ||
        (pti->dwItemBits != dwItemBits && dwItemBits != 0) ||
         pti->dwItemSize != dwItemSize ||
         !ValidateFA(pti->faFirstFragment, dwFragmentSize, cStream, TRUE) ||
         (!ValidateFA(pti->faExtendedInfo, dwFragmentSize, cStream, TRUE) &&
          pti->dwSignature != PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID))
    {
        DebugTrace((LPARAM) this, "Invalid property table");
        TraceFunctLeave();
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // Walk each of the fragments and make sure they point to valid data
    FLAT_ADDRESS faFragment = pti->faFirstFragment;
    PROPERTY_TABLE_FRAGMENT ptf;
    while (faFragment != INVALID_FLAT_ADDRESS) {
        if (!ValidateFA(faFragment, sizeof(PROPERTY_TABLE_FRAGMENT), cStream)) {
            DebugTrace((LPARAM) this, "Invalid property table");
            TraceFunctLeave();
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        DWORD cRead;
        hr = pBM->ReadMemory((BYTE *) &ptf,
                             faFragment,
                             sizeof(PROPERTY_TABLE_FRAGMENT),
                             &cRead,
                             NULL);
        if (FAILED(hr) ||
            cRead != sizeof(PROPERTY_TABLE_FRAGMENT) ||
            ptf.dwSignature != PROPERTY_FRAGMENT_SIGNATURE_VALID)
        {
            DebugTrace((LPARAM) this, "Couldn't read fragment at 0x%x",
                faFragment);
            TraceFunctLeave();
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        faFragment = ptf.faNextFragment;
    }

    //
    // construct the property table
    //
    CPropertyTable pt(PTT_PROPERTY_TABLE,
                      pti->dwSignature,
                      pBM,
                      pti,
                      CompareProperty,
                      NULL,
                      NULL);
    DWORD i, cProperties;
    union {
        PROPERTY_ITEM pi;
        GLOBAL_PROPERTY_ITEM gpi;
        RECIPIENT_PROPERTY_ITEM rpi;
        RECIPIENTS_PROPERTY_ITEM rspi;
        PROPID_MGMT_PROPERTY_ITEM pmpi;
    } pi;


    // get the count of properties
    hr = pt.GetCount(&cProperties);
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "GetCount returned 0x%x", hr);
        TraceFunctLeave();
        return hr;
    }

    // walk the properties and make sure that they point to valid addresses
    for (i = 0; i < cProperties; i++) {
        DWORD c;
        BYTE b;
        hr = pt.GetPropertyItemAndValueUsingIndex(
                i,
                (PROPERTY_ITEM *) &pi,
                1,
                &c,
                &b);
		// we just want the size, so it is okay if the buffer is too small
		if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) hr = S_OK;
        if (FAILED(hr)) {
            DebugTrace((LPARAM) this,
				"GetPropertyItemAndValueUsingIndex returned 0x%x", hr);
            TraceFunctLeave();
            return hr;
        }

		// check the location of the property value to make sure that it is
		// valid.  We don't need to do this for properties in the recipients
		// table because they contain property tables rather then
		// property values.  the property table will be checked by
		// ValidateRecipient
		if (pti->dwSignature != RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID) {
	        if (!(pi.pi.dwSize <= pi.pi.dwMaxSize &&
		          ValidateFA(pi.pi.faOffset, pi.pi.dwMaxSize, cStream, TRUE)))
			{
				DebugTrace((LPARAM) this, "Property points to invalid data", hr);
				TraceFunctLeave();
				return hr;
			}
		}
    }

    return S_OK;
}

HRESULT CMailMsg::ValidateRecipient(CBlockManager *pBM,
                                     DWORD cStream,
                                     RECIPIENTS_PROPERTY_ITEM *prspi)
{
    TraceFunctEnter("CMailMsg::ValidateRecipient");

    DWORD i, cAddresses = 0;
    HRESULT hr;

    // validate the rspi
    if (prspi->ptiInstanceInfo.dwSignature !=
            RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID)
    {
        DebugTrace((LPARAM) this, "rspi invalid");
        TraceFunctLeave();
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }


    // validate the recipient names
    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
        if (prspi->faNameOffset[i] != INVALID_FLAT_ADDRESS) {
            cAddresses++;

            // check the offset and length
            if (!ValidateFA(prspi->faNameOffset[i],
                            prspi->dwNameLength[i],
                            cStream))
            {
                DebugTrace((LPARAM) this, "address offset and length invalid");
                TraceFunctLeave();
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            // check the property id
            if (prspi->idName[i] != IMMPID_RP_ADDRESS_SMTP &&
                prspi->idName[i] != IMMPID_RP_ADDRESS_X400 &&
                prspi->idName[i] != IMMPID_RP_ADDRESS_X500 &&
                prspi->idName[i] != IMMPID_RP_LEGACY_EX_DN &&
                prspi->idName[i] != IMMPID_RP_ADDRESS_OTHER)
            {
                DebugTrace((LPARAM) this, "prop id %lu is invalid",
                    prspi->idName[i]);
                TraceFunctLeave();
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            // the 2nd-to-last character should be non-0, the last should be 0
            BYTE szTail[2];
            DWORD cTail;
            hr = pBM->ReadMemory(szTail,
                                 prspi->faNameOffset[i] +
                                    prspi->dwNameLength[i] - 2,
                                 2,
                                 &cTail,
                                 NULL);
            if (FAILED(hr)) {
                DebugTrace((LPARAM) this, "ReadMemory returned 0x%x", hr);
                TraceFunctLeave();
                return hr;
            }

            if (szTail[0] == 0 || szTail[1] != 0) {
                DebugTrace((LPARAM) this, "Recipient address %i is invalid", i);
                TraceFunctLeave();
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
        }
    }
    if (cAddresses == 0) {
        DebugTrace((LPARAM) this, "No valid addresses for recipient");
        TraceFunctLeave();
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // now check each of the recipient properties
    return ValidateProperties(pBM, cStream, &(prspi->ptiInstanceInfo));

    return S_OK;
}

//
// This is only used for the validation functions.
//
class CDumpMsgGetStream : public CBlockManagerGetStream {
    public:
        CDumpMsgGetStream(IMailMsgPropertyStream *pStream = NULL) {
            SetStream(pStream);
        }

        void SetStream(IMailMsgPropertyStream *pStream) {
            m_pStream = pStream;
        }

        virtual HRESULT GetStream(IMailMsgPropertyStream **ppStream,
                                  BOOL fLockAcquired)
        {
            *ppStream = m_pStream;
            return S_OK;
        }

    private:
        IMailMsgPropertyStream *m_pStream;
};

HRESULT STDMETHODCALLTYPE CMailMsg::ValidateStream(
                                IMailMsgPropertyStream *pStream)
{
    TraceFunctEnter("CMailMsg::ValidateStream");

    CDumpMsgGetStream bmGetStream(pStream);
    CBlockManager bm(NULL, &bmGetStream);
    DWORD cStream, cHeader;
    HRESULT hr;
    MASTER_HEADER header;

    if (!pStream) {
        ErrorTrace((LPARAM) this, 
            "Error, NULL stream passed to ValidateStream");
        TraceFunctLeave();
        return E_POINTER;
    }

    // get the size of the stream
    hr = pStream->GetSize(NULL, &cStream, NULL);
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "GetSize returned 0x%x", hr);
        TraceFunctLeave();
        return hr;
    }

    bm.SetStreamSize(cStream);

    // read the master header
    hr = bm.ReadMemory((BYTE *) &header,
                       0,
                       sizeof(MASTER_HEADER),
                       &cHeader,
                       NULL);
    if (FAILED(hr) || cHeader != sizeof(MASTER_HEADER)) {
        DebugTrace((LPARAM) this, "couldn't read master header, 0x%x", hr);
        TraceFunctLeave();
        return hr;
    }

    // examine the master header
    if (header.dwSignature != CMAILMSG_SIGNATURE_VALID ||
        header.dwHeaderSize != sizeof(MASTER_HEADER) ||
        header.ptiGlobalProperties.dwSignature !=
            GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID ||
        header.ptiRecipients.dwSignature !=
            RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID ||
        header.ptiPropertyMgmt.dwSignature !=
            PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID)
    {
        DebugTrace((LPARAM) this, "header invalid");
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        return hr;
    }

    // check each property in the three property tables
    hr = ValidateProperties(&bm, cStream, &(header.ptiGlobalProperties));
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "global property table invalid");
        return hr;
    }
    hr = ValidateProperties(&bm, cStream, &(header.ptiRecipients));
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "recipients property table invalid");
        return hr;
    }
    hr = ValidateProperties(&bm, cStream, &(header.ptiPropertyMgmt));
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "propid property table invalid");
        return hr;
    }

    // get each recipient and check its properties
    CPropertyTableItem ptiItem(&bm, &(header.ptiRecipients));
    DWORD iRecip = 0;
    RECIPIENTS_PROPERTY_ITEM rspi;
    hr = ptiItem.GetItemAtIndex(iRecip, (PROPERTY_ITEM *) &rspi, NULL);
    while (SUCCEEDED(hr)) {
        hr = ValidateRecipient(&bm, cStream, &rspi);
        if (FAILED(hr)) {
            DebugTrace((LPARAM) this, "recipient %i invalid", iRecip);
        } else {
            hr = ptiItem.GetNextItem((PROPERTY_ITEM *) &rspi);
        }
    }

    // if we just ran out of items then everything is okay
    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
        hr = S_OK;
    }

    TraceFunctLeave();
    return hr;
}

HRESULT STDMETHODCALLTYPE CMailMsg::ValidateContext()
{
    TraceFunctEnter("CMailMsg::ValidateContext");

	HRESULT 							hr = S_OK;
	IMailMsgStoreDriverValidateContext 	*pIStoreDriverValidateContext = NULL;
    BYTE    							pbContext[1024];
    DWORD   							cbContext = sizeof(pbContext);

    if (m_fDeleted) 
    {
        DebugTrace((LPARAM) this, 
            "Calling ValidateContext on deleted message");
        hr  = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

	// Get the validation interface off our store driver
    hr = m_pStore->QueryInterface(
                IID_IMailMsgStoreDriverValidateContext,
                (LPVOID *)&pIStoreDriverValidateContext);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) m_pStore,
            "Unable to QI for IMailMsgStoreDriverValidateContext 0x%08X",hr);
        goto Exit;
    }

	// Call in to driver to validate
    hr = GetProperty(IMMPID_MPV_STORE_DRIVER_HANDLE,
                                    sizeof(pbContext), &cbContext, pbContext);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "GetProperty failed with 0x%08X", hr);
        goto Exit;
    }

    hr = pIStoreDriverValidateContext->ValidateMessageContext(pbContext,
                                                              cbContext);
    DebugTrace((LPARAM) pIStoreDriverValidateContext,
    	"ValidateMessageContext returned 0x%08X", hr);

  Exit:

    // RELEASE
    if (pIStoreDriverValidateContext)
        pIStoreDriverValidateContext->Release();

    TraceFunctLeave();
    return hr;
}

HRESULT STDMETHODCALLTYPE CMailMsg::ForkForRecipients(
            IMailMsgProperties      **ppNewMessage,
            IMailMsgRecipientsAdd   **ppRecipients
            )
{
    HRESULT         hrRes = S_OK;
    FLAT_ADDRESS    faOffset;
    DWORD           dwSize;

    IMailMsgProperties      *pMsg   = NULL;
    IMailMsgRecipientsAdd   *pAdd   = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::ForkForRecipients");

    if (!ppNewMessage ||
        !ppRecipients)
        return(STG_E_INVALIDPARAMETER);

    // This is a really crude implementation, but would work
    // nonetheless.
    //
    // What we do is create a new instance of IMailMsgProperties,
    // then replicate the entire property stream (including the
    // recipients), then marking the recipients as void. Then we
    // also create a new Recipient Add list to go with it.
    hrRes = CoCreateInstance(
                CLSID_MsgImp,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IMailMsgProperties,
                (LPVOID *)&pMsg);
    if (SUCCEEDED(hrRes))
    {
        CMailMsg        *pCMsg;

        // Lock the original message
        m_bmBlockManager.WriteLock();

        // Get the underlying CMailMsg object
        pCMsg = (CMailMsg *)pMsg;

        // We make a copy of the current master header. Note we must
        // do this up front to make sure whatever props we copy later is
        // at least as up-to-date as this header snapshot.
        CopyMemory(&(pCMsg->m_Header), &m_Header, sizeof(MASTER_HEADER));

        // Find out how big are our properties
        hrRes = m_bmBlockManager.GetAllocatedSize(&faOffset);
        dwSize = (DWORD)faOffset;
        if (SUCCEEDED(hrRes))
        {
            DWORD           dwAllocated;
            CBlockManager   *pBlockManager;

            // Allocate a large enough block on the new message
            hrRes = pCMsg->QueryBlockManager(&pBlockManager);
            _ASSERT(SUCCEEDED(hrRes));

            // The new message already came with an empty master header
            dwSize = (DWORD)faOffset - sizeof(MASTER_HEADER);
            hrRes = pBlockManager->AllocateMemory(
                        dwSize,
                        &faOffset,
                        &dwAllocated,
                        NULL);
            if (SUCCEEDED(hrRes))
            {
                _ASSERT(faOffset == (FLAT_ADDRESS)sizeof(MASTER_HEADER));
                _ASSERT(dwAllocated >= dwSize);

                // Copy the memory over
                hrRes = m_bmBlockManager.CopyTo(
                            faOffset,
                            dwSize,
                            pBlockManager,
                            TRUE);
                if (SUCCEEDED(hrRes))
                {
                    // OK. Now duplicate the master header, but
                    // zero out the recipient count
                    CopyMemory(&((pCMsg->m_Header).ptiRecipients),
                                &(s_DefaultHeader.ptiRecipients),
                                sizeof(PROPERTY_TABLE_INSTANCE));
                }
            }
        }

        // Store a reference to the store driver
        pCMsg->SetDefaultRebindStore(m_pStore);

        // Release the original message
        m_bmBlockManager.WriteUnlock();
    }

    //
    // If all is fine, we will create an add interface
    //
    if (SUCCEEDED(hrRes))
    {
        IMailMsgRecipients  *pRcpts = NULL;

        // OK, now we simply create an add interface
        hrRes = pMsg->QueryInterface(
                    IID_IMailMsgRecipients,
                    (LPVOID *)&pRcpts);
        if (SUCCEEDED(hrRes))
        {
            hrRes = pRcpts->AllocNewList(&pAdd);
        }

        pRcpts->Release();
    }

    if (!SUCCEEDED(hrRes))
    {
        // Failed, release our resources
        if (pMsg)
            pMsg->Release();
    }
    else
    {
        // Fill in the output variables
        *ppNewMessage = pMsg;
        *ppRecipients = pAdd;
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::RebindAfterFork(
            IMailMsgProperties  *pOriginalMsg,
            IUnknown            *pStoreDriver
            )
{
    HRESULT                 hrRes = S_OK;

    PFIO_CONTEXT            hContent = NULL;
    IMailMsgPropertyStream  *pStream = NULL;
    IMailMsgStoreDriver     *pDriver = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::RebindAfterFork");

    if (!pOriginalMsg)
        return(E_POINTER);

    if (!pStoreDriver)
        pDriver = m_pDefaultRebindStoreDriver;
    else
    {
        hrRes = pStoreDriver->QueryInterface(
                    IID_IMailMsgStoreDriver,
                    (LPVOID *)&pDriver);
        if (FAILED(hrRes))
            return(hrRes);
    }

    if (!pDriver)
        return(E_POINTER);

    hrRes = pDriver->ReAllocMessage(
        pOriginalMsg,
        (IMailMsgProperties *)this,
        &pStream,
        &hContent,
        NULL);

    if(SUCCEEDED(hrRes)) {

        hrRes = BindToStore(
            pStream,
            pDriver,
            hContent);

        // Release the extra refcount on the stream
        pStream->Release();
    }

    TraceFunctLeave();
    return(hrRes);
}


// =================================================================
// Implementation of IMailMsgQueueMgmt
//
HRESULT CMailMsg::GetStream(
            IMailMsgPropertyStream  **ppStream,
            BOOL                    fLockAcquired
            )
{
    HRESULT                 hrRes = S_OK;

    if (!ppStream) return E_POINTER;

    if (m_pStream)
    {
        *ppStream = m_pStream;
    }
    else
    {
        hrRes = RestoreResourcesIfNecessary(fLockAcquired, TRUE);
        if (SUCCEEDED(hrRes))
        {
            _ASSERT(m_pStream);
            *ppStream = m_pStream;
            hrRes = S_OK;
        }
    }

    return(hrRes);
}

HRESULT CMailMsg::RestoreResourcesIfNecessary(
            BOOL    fLockAcquired,
            BOOL    fStreamOnly
            )
{
    HRESULT hrRes = S_OK;
    IMailMsgPropertyStream  **ppStream;
    PFIO_CONTEXT            *phHandle;
    BOOL                    fOpenStream = FALSE;
    BOOL                    fOpenContent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::RestoreResourcesIfNecessary");

    if (!m_pStore) return E_UNEXPECTED;

    m_lockReopen.ShareLock();
    ppStream = &m_pStream;
    phHandle = &m_hContentFile;

    // If we transition from zero to one, we will re-establish the
    // handles and pointers.
    _ASSERT(m_pStore);

    // Only reopen the ones that were closed
    if (m_pStream) ppStream = NULL;
    if (fStreamOnly || m_hContentFile != NULL) phHandle = NULL;

    // If we don't want either of them, we just return
    if (!ppStream && !phHandle) {
        m_lockReopen.ShareUnlock();
        return(S_OK);
    }

    //
    // switch our lock to an exclusive one
    //
    if (!m_lockReopen.SharedToExclusive()) {
        //
        // we couldn't do this in one operation.  acquire the exclusive
        // the hard way and retest our state.
        //
        m_lockReopen.ShareUnlock();
        m_lockReopen.ExclusiveLock();
        ppStream = &m_pStream;
        phHandle = &m_hContentFile;
        if (m_pStream) ppStream = NULL;
        if (fStreamOnly || m_hContentFile != NULL) phHandle = NULL;
        if (!ppStream && !phHandle) {
            m_lockReopen.ExclusiveUnlock();
            return(S_OK);
        }
    }

    if (ppStream)
    {
        _ASSERT(!m_pStream);
        fOpenStream = TRUE;
    }

    if (phHandle)
    {
        _ASSERT(!m_hContentFile);
        fOpenContent = TRUE;
    }

    hrRes = m_pStore->ReOpen(
                this,
                ppStream,
                phHandle,
                NULL);
    if (SUCCEEDED(hrRes))
    {
        // Make sure both are opened now
        _ASSERT(m_pStream);
        if (!fStreamOnly) _ASSERT(m_hContentFile != NULL);

        if (fOpenContent)
            InterlockedIncrement(&g_cOpenContentHandles);

        if (fOpenStream)
            InterlockedIncrement(&g_cOpenStreamHandles);

        //_ASSERT(g_cOpenContentHandles <= 6000);
        //_ASSERT(g_cOpenStreamHandles <= 6000);

        if ((m_cCloseOnExternalReleaseUsage) &&
            (0 == InterlockedDecrement(&m_cCloseOnExternalReleaseUsage)))
            InterlockedDecrement(&g_cCurrentMsgsClosedByExternalReleaseUsage);

        // Also propagate the stream to CMailMsgRecipients
        CMailMsgRecipients::SetStream(m_pStream);
    }

    m_lockReopen.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

// =================================================================
// Implementation of IMailMsgQueueMgmt
//

HRESULT STDMETHODCALLTYPE CMailMsg::AddUsage()
{
    HRESULT hrRes;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::AddUsage");

    m_lockUsageCount.ExclusiveLock();

    if (!m_ulUsageCount)
        hrRes = S_OK;
    else if (m_ulUsageCount < 0)
        hrRes = E_FAIL;
    else
        hrRes = S_FALSE;

    if (SUCCEEDED(hrRes)) {
        m_ulUsageCount++;
        InterlockedIncrement(&g_cTotalUsageCount);
    }

    m_lockUsageCount.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::ReleaseUsage()
{
    return (InternalReleaseUsage(RELEASE_USAGE_EXTERNAL));
}

HRESULT STDMETHODCALLTYPE CMailMsg::Delete(
            IMailMsgNotify *pNotify
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::Delete");

    hrRes = InternalReleaseUsage(RELEASE_USAGE_DELETE);
    _ASSERT(SUCCEEDED(hrRes));

    m_fDeleted = TRUE;
    if(m_pStore)
    {
        // OK, just call the store driver to delete this file
        hrRes = m_pStore->Delete(
                (IMailMsgProperties *)this,
                pNotify);
    }

    TraceFunctLeave();
    return(hrRes);
}

// =================================================================
// Implementation of IMailMsgBind
//

HRESULT STDMETHODCALLTYPE CMailMsg::BindToStore(
            IMailMsgPropertyStream  *pStream,
            IMailMsgStoreDriver     *pStore,
            PFIO_CONTEXT            hContentFile
            )
{
    HRESULT hrRes = S_OK;

    // hContentFile is optional, can be INVALID_HANDLE_VALUE

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::BindToStore");

    if (!pStream || !pStore)
    {
        hrRes = STG_E_INVALIDPARAMETER;
        goto Cleanup;
    }



    // 3/17/99 - Mikeswa
    // should not be calling BindToStore twice
    _ASSERT(!m_pStore);

    // If the handle must not be already specified
    if (hContentFile != NULL &&
        m_hContentFile != NULL)
        hrRes = E_HANDLE;
    else
    {
        m_pStore = pStore;
        m_hContentFile  = hContentFile;
        if (m_hContentFile) InterlockedIncrement(&g_cOpenContentHandles);

        // Hold a reference to the stream
        _ASSERT(!m_pStream);
        m_pStream = pStream;
        pStream->AddRef();
        InterlockedIncrement(&g_cOpenStreamHandles);

        // See if this is an existing file
        hrRes = RestoreMasterHeaderIfAppropriate();
        if (FAILED(hrRes))
        {
            pStream->Release();
            goto Cleanup;
        }

        // Also propagate the stream to CMailMsgRecipients
        CMailMsgRecipients::SetStream(pStream);

        // Set the usage count to 1
        if (InterlockedExchange(&m_ulUsageCount, 1) != 0)
        {
            _ASSERT(FALSE);
            hrRes = E_FAIL;
        } else {
            InterlockedIncrement(&g_cTotalUsageCount);
        }
    }

Cleanup:

    if (FAILED(hrRes))
    {
        m_pStore = NULL;
        m_hContentFile = NULL;
        m_pStream = NULL;
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::GetProperties(
            IMailMsgPropertyStream  *pStream,
            DWORD                   dwFlags,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetProperties");
    BOOL fDontMarkAsCommit = !(dwFlags & MAILMSG_GETPROPS_MARKCOMMIT);

    if (!pStream) {
        hrRes = STG_E_INVALIDPARAMETER;
    } else {
        hrRes = m_bmBlockManager.AtomicWriteAndIncrement(
                    (LPBYTE)&m_Header,
                    (FLAT_ADDRESS)0,
                    sizeof(MASTER_HEADER),
                    NULL,
                    0,
                    0,
                    NULL);
        if (pStream == m_pStream) {
            m_bmBlockManager.SetDirty(FALSE);
            m_bmBlockManager.SetCommitMode(TRUE);
        }
        if (SUCCEEDED(hrRes)) {
            DWORD cTotalBlocksToWrite = 0;
            DWORD cTotalBytesToWrite = 0;
            int f;
            for (f = 1; f >= 0; f--) {
                if (SUCCEEDED(hrRes)) {
                    if (!f) {
                        hrRes = pStream->StartWriteBlocks(this,
                                                          cTotalBlocksToWrite,
                                                          cTotalBytesToWrite);
                    }
                    hrRes = m_bmBlockManager.CommitDirtyBlocks(
                                (FLAT_ADDRESS)0,
                                INVALID_FLAT_ADDRESS,
                                dwFlags,
                                pStream,
                                fDontMarkAsCommit,
                                f,
                                &cTotalBlocksToWrite,
                                &cTotalBytesToWrite,
                                pNotify);
                    if (!f) {
                        if (FAILED(hrRes)) {
                           pStream->CancelWriteBlocks(this);
                        } else {
                            hrRes = pStream->EndWriteBlocks(this);
                        }
                    }
                }
            }
        }
    }

    // Set the recipient commit state
    if (SUCCEEDED(hrRes) && pStream == m_pStream)
        CMailMsgRecipients::SetCommitState(TRUE);

    if (FAILED(hrRes) && pStream == m_pStream) {
        m_bmBlockManager.SetDirty(FALSE);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsg::RestoreMasterHeaderIfAppropriate()
{
    HRESULT hrRes = S_OK;
    DWORD   dwStreamSize = 0;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::RestoreMasterHeaderIfAppropriate");

    // Get the size and fill it in. If get size fails, we
    // will default to sizeof the master header.
    hrRes = m_pStream->GetSize(this, &dwStreamSize, NULL);
    if (SUCCEEDED(hrRes))
    {
        // If the size is zero, we have a new file
        if (!dwStreamSize)
            return(S_OK);

        // Make sure the stream is at least the size of the
        // MASTER_HEADER
        if (dwStreamSize < sizeof(MASTER_HEADER))
        {
            ErrorTrace((LPARAM)this, "Stream size too small (%u bytes)", dwStreamSize);
            goto InvalidFile;
        }

        m_bmBlockManager.Release();
        hrRes = m_bmBlockManager.SetStreamSize(dwStreamSize);
        if (SUCCEEDED(hrRes))
        {
            // Make sure we can restore the master header
            DWORD   dwT;
            hrRes = m_bmBlockManager.ReadMemory(
                        (LPBYTE)&m_Header,
                        0,
                        sizeof(MASTER_HEADER),
                        &dwT,
                        NULL);
            if (SUCCEEDED(hrRes) && (dwT == sizeof(MASTER_HEADER)))
            {
                // Check the signature ...
                if (m_Header.dwSignature != CMAILMSG_SIGNATURE_VALID)
                {
                    ErrorTrace((LPARAM)this,
                            "Corrupted signature (%*s)", 4, &(m_Header.dwSignature));
                    goto InvalidFile;
                }
                if (m_Header.dwHeaderSize != sizeof(MASTER_HEADER))
                {
                    ErrorTrace((LPARAM)this,
                            "Bad header size (%u, expected %u)",
                            m_Header.dwHeaderSize, sizeof(MASTER_HEADER));
                    goto InvalidFile;
                }

                TraceFunctLeaveEx((LPARAM)this);
                return(hrRes);
            }

            ErrorTrace((LPARAM)this, "Failed to get master header (%08x, %u)", hrRes, dwT);
        }
        else
        {
            ErrorTrace((LPARAM)this, "Failed to set stream size (%08x)", hrRes);
        }
    }
    else
    {
        ErrorTrace((LPARAM)this, "Failed to get stream size (%08x)", hrRes);
    }

InvalidFile:

    TraceFunctLeaveEx((LPARAM)this);
    return(HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT));
}

#if 0
// =================================================================
// Implementation of IMailMsgBindATQ
//

HRESULT STDMETHODCALLTYPE CMailMsg::BindToStore(
            IMailMsgPropertyStream      *pStream,
            IMailMsgStoreDriver         *pStore,
            PFIO_CONTEXT                hContentFile,
            void                        *pvClientContext,
            ATQ_COMPLETION              pfnCompletion,
            DWORD                       dwTimeout,
            struct _ATQ_CONTEXT_PUBLIC  **ppATQContext,
            PFNAtqAddAsyncHandle        pfnAtqAddAsyncHandle,
            PFNAtqFreeContext           pfnAtqFreeContext
            )
{
#if 0
    HRESULT hrRes = S_OK;

    _ASSERT(pfnCompletion);
    _ASSERT(hContentFile != NULL);
    // pvClientContext can technically be NULL ...
    _ASSERT(pfnAtqAddAsyncHandle);
    _ASSERT(pfnAtqFreeContext);

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::BindToStore");

    if (!pfnCompletion ||
        hContentFile == NULL ||
        !pfnAtqAddAsyncHandle ||
        !pfnAtqFreeContext)
        hrRes = STG_E_INVALIDPARAMETER;
    else
    {
        // Make sure we don't have a stream and store already
        _ASSERT(!m_pStream);
        _ASSERT(!m_pStore);

        if (m_hContentFile != NULL)
            hrRes = E_HANDLE;
        else if (ppATQContext)
        {
            // Call ATQ to associate the handle
            if (pfnAtqAddAsyncHandle(
                        ppATQContext,
                        NULL,
                        pvClientContext,
                        pfnCompletion,
                        dwTimeout,
                        hContentFile))
            {
                // Hold a reference to the stream
                m_pStore = pStore;
                m_hContentFile = hContentFile;
                m_pStream = pStream;
                hrRes = pStream->AddRef();

                // See if this is an existing file
                hrRes = RestoreMasterHeaderIfAppropriate();
                if (FAILED(hrRes))
                {
                    pStream->Release();

                    // Free the ATQ context
                    if (*ppATQContext)
                    {
                        pfnAtqFreeContext(*ppATQContext, FALSE );
                    }
                    goto Cleanup;
                }

                // Copy into our members
                m_pvClientContext   = pvClientContext;
                m_pATQContext       = *ppATQContext;
                m_pfnCompletion     = pfnCompletion;
                m_dwTimeout         = dwTimeout;
                m_pfnAtqAddAsyncHandle = pfnAtqAddAsyncHandle;
                m_pfnAtqFreeContext = pfnAtqFreeContext;

                // Also propagate the stream to CMailMsgRecipients
                CMailMsgRecipients::SetStream(pStream);

                // Set the usage count to 1
                if (InterlockedExchange(&m_ulUsageCount, 1) != 0)
                {
                    _ASSERT(FALSE);
                    hrRes = E_FAIL;
                } else {
                    InterlockedIncrement(&g_cTotalUsageCount);
                }
            }
            else
            {
                hrRes = HRESULT_FROM_WIN32(GetLastError());
                ErrorTrace( (LPARAM)this, "AtqAddAsyncHandle failed. err: %u", GetLastError());

                // The context still might have been allocated even if it failed.
                if (*ppATQContext)
                {
                    pfnAtqFreeContext(*ppATQContext, FALSE );
                }
            }
        }
        else
        {
            hrRes = BindToStore(pStream, pStore, hContentFile);
        }
    }

Cleanup:

    if (FAILED(hrRes))
    {
        m_pStore = NULL;
        m_hContentFile = NULL;
        m_pStream = NULL;
    }

    TraceFunctLeave();
    return(hrRes);
#endif
    return E_NOTIMPL;
}
#endif

HRESULT STDMETHODCALLTYPE CMailMsg::GetBinding(
            PFIO_CONTEXT                *phAsyncIO,
            IMailMsgNotify              *pNotify
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetATQInfo");

    if (!phAsyncIO)
        hrRes = STG_E_INVALIDPARAMETER;
    else
    {
        // Make sure we have a stream and store
        _ASSERT(m_pStore);

        // Up the usage count
        hrRes = AddUsage();
        if (SUCCEEDED(hrRes))
        {
            hrRes = RestoreResourcesIfNecessary();
            if(SUCCEEDED(hrRes))
            {
                // Copy the values
                *phAsyncIO          = m_hContentFile;
                _ASSERT(m_pStream);
            }
        }
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::ReleaseContext()
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::ReleaseContext");

    // Call to ReleaseUsage()
    hrRes = InternalReleaseUsage(RELEASE_USAGE_INTERNAL);

    TraceFunctLeave();
    return(hrRes);
}


//---[ CMailMsg::InternalReleaseUsage ]---------------------------------------
//
//
//  Description:
//      Internal implementation of ReleaseUsage.  Allows added internal
//      functionality on delete and the final release.
//  Parameters:
//      dwReleaseUsageFlags     Flag specifying behavior
//              RELEASE_USAGE_EXTERNAL      - External interface normal behavior
//              RELEASE_USAGE_FINAL_RELEASE - Drops usage count to 0
//              RELEASE_USAGE_DELETE        - Drops usage count to 0 and will
//                                            not commit (if commiting on
//                                            release usage feature is added).
//              RELEASE_USAGE_INTERNAL      - Internal usage of release usage
//                                            that may be called before the
//                                            usage count is incremented
//                                            above zero.
//  Returns:
//      S_OK on success (and resulting usage count is 0)
//      S_FALSE on success (and resulting usage count is > 0)
//      E_FAIL if usage count is already < 0 (all cases)
//      E_FAIL if usage count is already 0 (RELEASE_USAGE_EXTERNAL only)
//  History:
//      8/3/98 - MikeSwa Created (implementation mostly from original release usage)
//
//  Notes:
//      There is some debate if this function should commit data.  Currently it
//      does not.  See bug #73040.
//-----------------------------------------------------------------------------
HRESULT CMailMsg::InternalReleaseUsage(DWORD  dwReleaseUsageFlags)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::InternalReleaseUsage");

    //Exactly one flag should be set
    ASSERT((dwReleaseUsageFlags & RELEASE_USAGE_EXTERNAL) ^
           (dwReleaseUsageFlags & RELEASE_USAGE_FINAL_RELEASE) ^
           (dwReleaseUsageFlags & RELEASE_USAGE_INTERNAL) ^
           (dwReleaseUsageFlags & RELEASE_USAGE_DELETE));

    InterlockedIncrement(&g_cTotalReleaseUsageCalls);
    m_lockUsageCount.ExclusiveLock();

    if (m_ulUsageCount <= 1 &&
       (!(dwReleaseUsageFlags & RELEASE_USAGE_DELETE)) &&
        !m_fDeleted)
    {
        // if there are any dirty blocks then do a commit to write them back
        // to the P1 stream
        if (m_pStore && m_bmBlockManager.IsDirty()) {
            HRESULT hrCommit = Commit(NULL);
            if (FAILED(hrCommit)) {
                InterlockedIncrement(&g_cTotalReleaseUsageCommitFail);
                ErrorTrace((DWORD_PTR) this, "InternalReleaseUsage: automatic commit failed with 0x%x", hrCommit);
            }
            _ASSERT(SUCCEEDED(hrCommit) || m_bmBlockManager.IsDirty());
        }
    }

    DebugTrace((LPARAM)this, "Usage count is %u. Release flags: %08x",
            m_ulUsageCount, dwReleaseUsageFlags);

    if ((dwReleaseUsageFlags & (RELEASE_USAGE_FINAL_RELEASE |
                                RELEASE_USAGE_INTERNAL |
                                RELEASE_USAGE_DELETE)) &&
        (m_ulUsageCount == 0))
    {
        _ASSERT(S_OK == hrRes); //resulting usage count is still 0
        m_ulUsageCount++; //prepare for decrement at end
        InterlockedIncrement(&g_cTotalUsageCount);

        DebugTrace((LPARAM)this, "Usage count already zero");
    }

    if ((m_ulUsageCount == 1) ||
        ((m_ulUsageCount >= 1) &&
         (dwReleaseUsageFlags & (RELEASE_USAGE_FINAL_RELEASE |
                                 RELEASE_USAGE_DELETE))))
    {
        LONG ulUsageDiff = -(m_ulUsageCount - 1);
        m_ulUsageCount = 1; //on delete and final release cases we drop it to 0
        InterlockedExchangeAdd(&g_cTotalUsageCount, ulUsageDiff);

        DebugTrace((LPARAM)this, "Dropping usage count to zero");

        // When we hit zero, we will release the stream, content
        // handle, and unassociate the ATQ context
        _ASSERT((RELEASE_USAGE_EXTERNAL ^ dwReleaseUsageFlags) || m_pStore);

        if (RELEASE_USAGE_EXTERNAL & dwReleaseUsageFlags)
            InterlockedIncrement(&g_cTotalExternalReleaseUsageZero);

        if ((!(m_bmBlockManager.IsDirty())) ||
            (dwReleaseUsageFlags & (RELEASE_USAGE_FINAL_RELEASE |
                                    RELEASE_USAGE_DELETE)))
        {
            if (m_pStore &&
                (m_bmBlockManager.IsDirty()) &&
                !m_fDeleted &&
                (!(dwReleaseUsageFlags & RELEASE_USAGE_DELETE)))
            {
                ErrorTrace((DWORD_PTR) this, "InternalReleaseUsage: automatic commit failed, must close anyway");
            }

            if (!m_hContentFile && !m_pStream)
                InterlockedIncrement(&g_cTotalReleaseUsageNothingToClose);
            else if (RELEASE_USAGE_EXTERNAL & dwReleaseUsageFlags)
            {
                //If we are an external caller, then update our count global and member
                //counts

                //If m_cCloseOnExternalReleaseUsage, then we are going through this
                //code path twice without calling RestoreResourcesIfNecessary
                _ASSERT(!m_cCloseOnExternalReleaseUsage);
                InterlockedIncrement(&m_cCloseOnExternalReleaseUsage);
                InterlockedIncrement(&g_cCurrentMsgsClosedByExternalReleaseUsage);
            }

            if (m_hContentFile != NULL)
            {
                DebugTrace((LPARAM)this, "Closing content file");

                 _ASSERT(m_pStore); //we must have a store in this case
                hrRes = m_pStore->CloseContentFile(this, m_hContentFile);
                InterlockedIncrement(&g_cTotalReleaseUsageCloseContent);
                InterlockedDecrement(&g_cOpenContentHandles);
                _ASSERT(SUCCEEDED(hrRes)); //assert before blowing away m_hContentFile
                m_hContentFile = NULL;
            }

            // Release the stream
            if (m_pStream)
            {
                DebugTrace((LPARAM)this, "Releasing stream");

                m_pStream->Release();
                m_pStream = NULL;

                InterlockedIncrement(&g_cTotalReleaseUsageCloseStream);
                InterlockedDecrement(&g_cOpenStreamHandles);
                // Also invalidate the stream in CMailMsgRecipients
                CMailMsgRecipients::SetStream(NULL);
            }

            // Dump the memory held onto by blockmgr
            m_bmBlockManager.Release();
        }
        else
            InterlockedIncrement(&g_cTotalReleaseUsageCloseFail);
        hrRes = S_OK;
    }
    else if (m_ulUsageCount <= 0)
    {
        _ASSERT(0 && "Usage count already 0");
        hrRes = E_FAIL;
    }
    else
    {
        hrRes = S_FALSE;
        InterlockedIncrement(&g_cTotalReleaseUsageNonZero);
    }

    if (SUCCEEDED(hrRes)) {
        m_ulUsageCount--;
        InterlockedDecrement(&g_cTotalUsageCount);
    }

    m_lockUsageCount.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmailmsg.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmailmsg.h

Abstract:

	This module contains the definition of the master message class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/09/98	created

--*/

#ifndef _CMAILMSG_H_
#define _CMAILMSG_H_

#include "filehc.h"
#include "mailmsgi.h"
#include "mailmsgp.h"

#include "blockmgr.h"
#include "cmmprops.h"

#include "mailmsgprops.h"

#include "cmmutils.h"
#include "cmmsprop.h"

/***************************************************************************/
// Definitions
//

//
// Define recipient flags
//
#define FLAG_RECIPIENT_DO_NOT_DELIVER			0x00000001
#define FLAG_RECIPIENT_NO_NAME_COLLISIONS		0x00000002

//
// Define the invalid domain index
//
#define INVALID_DOMAIN_INDEX					((DWORD)(-2))


//
// Define InternalReleaseUsage options
//
#define RELEASE_USAGE_EXTERNAL                  0x00000001
#define RELEASE_USAGE_FINAL_RELEASE             0x00000002
#define RELEASE_USAGE_DELETE                    0x00000004
#define RELEASE_USAGE_INTERNAL                  0x00000008

/***************************************************************************/
// Structures
//


// Define a local master header structure. This structure always
// starts at offset 0 in the flat memory space
typedef struct _MASTER_HEADER
{
	DWORD						dwSignature;
	WORD						wVersionHigh;
	WORD						wVersionLow;
	DWORD						dwHeaderSize;

	// Got space for each essential property table
	PROPERTY_TABLE_INSTANCE		ptiGlobalProperties;
	PROPERTY_TABLE_INSTANCE		ptiRecipients;
	PROPERTY_TABLE_INSTANCE		ptiPropertyMgmt;

} MASTER_HEADER, *LPMASTER_HEADER;


/***************************************************************************/
// Special property tables
//
extern PTABLE g_SpecialMessagePropertyTable;
extern PTABLE g_SpecialRecipientsPropertyTable;
extern PTABLE g_SpecialRecipientsAddPropertyTable;

/***************************************************************************/
//
//

class CMailMsgPropertyManagement :
	public IMailMsgPropertyManagement
{
  public:

	CMailMsgPropertyManagement(
				CBlockManager				*pBlockManager,
				LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
				);

	~CMailMsgPropertyManagement();

	/***************************************************************************/
	//
	// Implementation of IMailMsgPropertyManagement
	//

	HRESULT STDMETHODCALLTYPE AllocPropIDRange(
				REFGUID	rguid,
				DWORD	cCount,
				DWORD	*pdwStart
				);

	HRESULT STDMETHODCALLTYPE EnumPropIDRange(
				DWORD	*pdwIndex,
				GUID	*pguid,
				DWORD	*pcCount,
				DWORD	*pdwStart
				);

  private:

	// The specific compare function for this type of property table
	static HRESULT CompareProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem
				);

	// CMailMsgPropertyManagement is an instance of CPropertyTable
	CPropertyTable				m_ptProperties;

	// We have a need to keep a pointer to the instance data
	LPPROPERTY_TABLE_INSTANCE	m_pInstanceInfo;

	// Keep a pointer to the block manager
	CBlockManager				*m_pBlockManager;
};



/***************************************************************************/
//
//

class CMailMsgRecipientsPropertyBase
{
  public:

	// Generic method for setting the value of a property given
	// LPRECIPIENTS_PROPERTY_ITEM
	HRESULT PutProperty(
				CBlockManager				*pBlockManager,
				LPRECIPIENTS_PROPERTY_ITEM	pItem,
				DWORD						dwPropID,
				DWORD						cbLength,
				LPBYTE						pbValue
				);

	// Generic method for getting the value of a property given
	// LPRECIPIENTS_PROPERTY_ITEM
	HRESULT GetProperty(
				CBlockManager				*pBlockManager,
				LPRECIPIENTS_PROPERTY_ITEM	pItem,
				DWORD						dwPropID,
				DWORD						cbLength,
				DWORD						*pcbLength,
				LPBYTE						pbValue
				);

	// The specific compare function for this type of property table
	static HRESULT CompareProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem
				);

	// Well known properties
	static INTERNAL_PROPERTY_ITEM			*const s_pWellKnownProperties;
	static const DWORD						s_dwWellKnownProperties;
};


/***************************************************************************/
//
//

class CMailMsgRecipients :
	public CMailMsgRecipientsPropertyBase,
	public IMailMsgRecipients,
	public IMailMsgPropertyReplication
{
  public:

	CMailMsgRecipients(
				CBlockManager				*pBlockManager,
				LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
				);

	~CMailMsgRecipients();

	HRESULT SetStream(
				IMailMsgPropertyStream	*pStream
				);

	HRESULT SetCommitState(
				BOOL	fGlobalCommitDone
				);

	// Virtual method to restore the handles if necessary
	virtual HRESULT RestoreResourcesIfNecessary(
				BOOL	fLockAcquired,
                BOOL    fStreamOnly
				) = 0;

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	/***************************************************************************/
	//
	// Implementation of IMailMsgRecipients
	//

	// The commit must be called after a global commit is called on the current
	// list. Commit will refuse to continue (i.e. return E_FAIL) if the one or more
	// of the following is TRUE:
	// 1) Global commit was not called
	// 2) A WriteList is called after the last global commit.
	HRESULT STDMETHODCALLTYPE Commit(
				DWORD			dwIndex,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE DomainCount(
				DWORD	*pdwCount
				);

	HRESULT STDMETHODCALLTYPE DomainItem(
				DWORD	dwIndex,
				DWORD	cchLength,
				LPSTR	pszDomain,
				DWORD	*pdwRecipientIndex,
				DWORD	*pdwRecipientCount
				);


	HRESULT STDMETHODCALLTYPE SetNextDomain(
				DWORD	dwDomainIndex,
				DWORD	dwNextDomainIndex,
				DWORD	dwFlags
				);

	HRESULT STDMETHODCALLTYPE InitializeRecipientFilterContext(
				LPRECIPIENT_FILTER_CONTEXT	pContext,
				DWORD						dwStartingDomain,
				DWORD						dwFilterFlags,
				DWORD						dwFilterMask
				);

	HRESULT STDMETHODCALLTYPE TerminateRecipientFilterContext(
				LPRECIPIENT_FILTER_CONTEXT	pContext
				);

	HRESULT STDMETHODCALLTYPE GetNextRecipient(
				LPRECIPIENT_FILTER_CONTEXT	pContext,
				DWORD						*pdwRecipientIndex
				);


	HRESULT STDMETHODCALLTYPE AllocNewList(
				IMailMsgRecipientsAdd	**ppNewList
				);

	HRESULT STDMETHODCALLTYPE WriteList(
				IMailMsgRecipientsAdd	*pNewList
				);

	/***************************************************************************/
	//
	// Implementation of IMailMsgRecipientsBase
	//

	HRESULT STDMETHODCALLTYPE Count(
				DWORD	*pdwCount
				);

	HRESULT STDMETHODCALLTYPE Item(
				DWORD	dwIndex,
				DWORD	dwWhichName,
				DWORD	cchLength,
				LPSTR	pszName
				);

	HRESULT STDMETHODCALLTYPE PutProperty(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE GetProperty(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cbLength,
				DWORD	*pcbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE PutStringA(
				DWORD	dwIndex,
				DWORD	dwPropID,
				LPCSTR	pszValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,pszValue?strlen(pszValue)+1:0,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringA(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cchLength,
				LPSTR	pszValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,cchLength,&dwLength,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutStringW(
				DWORD	dwIndex,
				DWORD	dwPropID,
				LPCWSTR	pszValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringW(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cchLength,
				LPWSTR	pszValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,cchLength*sizeof(WCHAR),&dwLength,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutDWORD(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,sizeof(DWORD),(LPBYTE) &dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetDWORD(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,sizeof(DWORD),&dwLength,(LPBYTE) pdwValue));
	}

	HRESULT STDMETHODCALLTYPE PutBool(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		dwValue = dwValue ? 1 : 0;
		return (PutProperty(dwIndex,dwPropID,sizeof(DWORD),(LPBYTE) &dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetBool(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		HRESULT hrRes;
		DWORD dwLength;

		hrRes = GetProperty(dwIndex,dwPropID,sizeof(DWORD),&dwLength,(LPBYTE) pdwValue);
		if (pdwValue)
			*pdwValue = *pdwValue ? 1 : 0;
		return (hrRes);
	}

	/***************************************************************************/
	//
	// Implementation of IMailMsgPropertyReplication
	//

	// Method to copy all the properties of the source recipient to
	// the specified. The caller can specify a list of PROP IDs
	HRESULT STDMETHODCALLTYPE CopyTo(
				DWORD					dwSourceRecipientIndex,
				IMailMsgRecipientsBase	*pTargetRecipientList,
				DWORD					dwTargetRecipientIndex,
				DWORD					dwExemptCount,
				DWORD					*pdwExemptPropIdList
				);

  private:

	HRESULT DomainItemEx(
				DWORD	dwIndex,
				DWORD	cchLength,
				LPSTR	pszDomain,
				DWORD	*pdwRecipientIndex,
				DWORD	*pdwRecipientCount,
				DWORD	*pdwNextDomainIndex
				);

	// Reference count
	LONG						m_ulRefCount;

	// Count the number of domains in our list
	DWORD						m_dwDomainCount;

	// This tracks the commit state of the recipient list
	BOOL						m_fGlobalCommitDone;

	// We have a need to keep a pointer to the recipient table
	// for domain operations ...
	LPPROPERTY_TABLE_INSTANCE	m_pInstanceInfo;

	// Keep a pointer to the block manager
	CBlockManager				*m_pBlockManager;

	// Wee need to keep a pointer to the property stream
	IMailMsgPropertyStream		*m_pStream;

	// Special property table class instance
	CSpecialPropertyTable		m_SpecialPropertyTable;

};


/***************************************************************************/
//
//

class CMailMsgRecipientsAdd :
	public CMailMsgRecipientsPropertyBase,
	public IMailMsgRecipientsAdd,
	public IMailMsgPropertyReplication
{
	friend CRecipientsHash;
  public:

	CMailMsgRecipientsAdd(
				CBlockManager	*pBlockManager
				);

	~CMailMsgRecipientsAdd();

	//
	// CPool
	//
	static CPool m_Pool;
	inline void *operator new(size_t size)
	{
		return m_Pool.Alloc();
	}
	inline void operator delete(void *p, size_t size)
	{
		m_Pool.Free(p);
	}

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	CRecipientsHash *GetHashTable() { return(&m_Hash); }

	/***************************************************************************/
	//
	// Implementation of IMailMsgRecipientsAdd
	//

	HRESULT STDMETHODCALLTYPE AddPrimary(
				DWORD dwCount,
				LPCSTR *ppszNames,
				DWORD *pdwPropIDs,
				DWORD *pdwIndex,
				IMailMsgRecipientsBase *pFrom,
				DWORD dwFrom
				);

	HRESULT STDMETHODCALLTYPE AddSecondary(
				DWORD dwCount,
				LPCSTR *ppszNames,
				DWORD *pdwPropIDs,
				DWORD *pdwIndex,
				IMailMsgRecipientsBase *pFrom,
				DWORD dwFrom
				);

	/***************************************************************************/
	//
	// Implementation of IMailMsgRecipientsBase
	//

	HRESULT STDMETHODCALLTYPE Count(
				DWORD	*pdwCount
				);

	HRESULT STDMETHODCALLTYPE Item(
				DWORD	dwIndex,
				DWORD	dwWhichName,
				DWORD	cchLength,
				LPSTR	pszName
				);

	HRESULT STDMETHODCALLTYPE PutProperty(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE GetProperty(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cbLength,
				DWORD	*pcbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE PutStringA(
				DWORD	dwIndex,
				DWORD	dwPropID,
				LPCSTR	pszValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,pszValue?strlen(pszValue)+1:0,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringA(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cchLength,
				LPSTR	pszValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,cchLength,&dwLength,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutStringW(
				DWORD	dwIndex,
				DWORD	dwPropID,
				LPCWSTR	pszValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringW(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cchLength,
				LPWSTR	pszValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,cchLength*sizeof(WCHAR),&dwLength,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutDWORD(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,sizeof(DWORD),(LPBYTE) &dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetDWORD(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,sizeof(DWORD),&dwLength,(LPBYTE) pdwValue));
	}

	HRESULT STDMETHODCALLTYPE PutBool(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		dwValue = dwValue ? 1 : 0;
		return (PutProperty(dwIndex,dwPropID,sizeof(DWORD),(LPBYTE) &dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetBool(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		HRESULT hrRes;
		DWORD dwLength;

		hrRes = GetProperty(dwIndex,dwPropID,sizeof(DWORD),&dwLength,(LPBYTE) pdwValue);
		if (pdwValue)
			*pdwValue = *pdwValue ? 1 : 0;
		return (hrRes);
	}

	/***************************************************************************/
	//
	// Implementation of IMailMsgPropertyReplication
	//

	// Method to copy all the properties of the source recipient to
	// the specified. The caller can specify a list of PROP IDs
	HRESULT STDMETHODCALLTYPE CopyTo(
				DWORD					dwSourceRecipientIndex,
				IMailMsgRecipientsBase	*pTargetRecipientList,
				DWORD					dwTargetRecipientIndex,
				DWORD					dwExemptCount,
				DWORD					*pdwExemptPropIdList
				);

  private:

	HRESULT AddPrimaryOrSecondary(
				DWORD					dwCount,
				LPCSTR					*ppszNames,
				DWORD					*pdwPropIDs,
				DWORD					*pdwIndex,
				IMailMsgRecipientsBase	*pFrom,
				DWORD					dwFrom,
				BOOL					fPrimary
				);

	HRESULT GetPropertyInternal(
				LPRECIPIENTS_PROPERTY_ITEM_EX	pItem,
				DWORD	dwPropID,
				DWORD	cbLength,
				DWORD	*pcbLength,
				LPBYTE	pbValue
				);

	// Global default instance info
	static const PROPERTY_TABLE_INSTANCE s_DefaultInstance;

	// The reference count to the object
	LONG						m_ulRefCount;

	// It needs its own instance of a property table
	PROPERTY_TABLE_INSTANCE		m_InstanceInfo;

	// Pointer to block manager
	CBlockManager				*m_pBlockManager;

	// We have an instance of the hash table
	CRecipientsHash				m_Hash;

	// Special property table class instance
	CSpecialPropertyTable		m_SpecialPropertyTable;


};


/***************************************************************************/
//
//

class CMailMsg :
	public IMailMsgProperties,
	public CMailMsgPropertyManagement,
	public CMailMsgRecipients,
	public IMailMsgQueueMgmt,
	public IMailMsgBind,
    public IMailMsgAQueueListEntry,
	public IMailMsgValidate,
	public IMailMsgValidateContext,
	public CBlockManagerGetStream
{
  public:

	CMailMsg();
	~CMailMsg();

    void FinalRelease();

	//
	// Method to initialize the CMailMsg. This must precede any access to
	// the object. When this method is called, absolutely no other threads
	// can be inside this object or its derivatives.
	//
	HRESULT Initialize();

	HRESULT QueryBlockManager(
				CBlockManager	**ppBlockManager
				);

	HRESULT RestoreResourcesIfNecessary(
				BOOL	fLockAcquired = FALSE,
                BOOL    fStreamOnly = FALSE
				);

	HRESULT GetStream(
				IMailMsgPropertyStream	**ppStream,
				BOOL					fLockAcquired
				);

	HRESULT SetDefaultRebindStore(
				IMailMsgStoreDriver	*pStoreDriver
				)
	{
		m_pDefaultRebindStoreDriver = pStoreDriver;
		return(S_OK);
	}

	/***************************************************************************/
	//
	// Implementation of IMailMsgProperties
	//

	HRESULT STDMETHODCALLTYPE PutProperty(
				DWORD	dwPropID,
				DWORD	cbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE GetProperty(
				DWORD	dwPropID,
				DWORD	cbLength,
				DWORD	*pcbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE Commit(
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE PutStringA(
				DWORD	dwPropID,
				LPCSTR	pszValue
				)
	{
		return(PutProperty(dwPropID, pszValue?strlen(pszValue)+1:0, (LPBYTE)pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringA(
				DWORD	dwPropID,
				DWORD	cchLength,
				LPSTR	pszValue
				)
	{
		DWORD dwLength;
		return(GetProperty(dwPropID, cchLength, &dwLength, (LPBYTE)pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutStringW(
				DWORD	dwPropID,
				LPCWSTR	pszValue
				)
	{
		return(PutProperty(dwPropID, pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0, (LPBYTE)pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringW(
				DWORD	dwPropID,
				DWORD	cchLength,
				LPWSTR	pszValue
				)
	{
		DWORD dwLength;
		return(GetProperty(dwPropID, cchLength*sizeof(WCHAR), &dwLength, (LPBYTE)pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutDWORD(
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetDWORD(
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		DWORD dwLength;
		return(GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue));
	}

	HRESULT STDMETHODCALLTYPE PutBool(
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		dwValue = dwValue ? 1 : 0;
		return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetBool(
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		HRESULT hrRes;
		DWORD dwLength;

		hrRes = GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue);
		if (pdwValue)
			*pdwValue = *pdwValue ? 1 : 0;
		return (hrRes);
	}

	HRESULT STDMETHODCALLTYPE GetContentSize(
				DWORD			*pdwSize,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReadContent(
				DWORD			dwOffset,
				DWORD			dwLength,
				DWORD			*pdwLength,
				BYTE			*pbBlock,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE WriteContent(
				DWORD			dwOffset,
				DWORD			dwLength,
				DWORD			*pdwLength,
				BYTE			*pbBlock,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE CopyContentToFile(
				PFIO_CONTEXT	hCopy,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE CopyContentToFileEx(
				PFIO_CONTEXT	hCopy,
				BOOL			fDotStuffed,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE CopyContentToStream(
				IMailMsgPropertyStream	*pStream,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE ForkForRecipients(
				IMailMsgProperties		**ppNewMessage,
				IMailMsgRecipientsAdd	**ppRecipients
				);

  	HRESULT STDMETHODCALLTYPE CopyContentToFileAtOffset(
				PFIO_CONTEXT	hCopy,
                DWORD           dwOffset,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE RebindAfterFork(
				IMailMsgProperties		*pOriginalMsg,
				IUnknown				*pStoreDriver
				);

	HRESULT STDMETHODCALLTYPE SetContentSize(
				DWORD			dwSize,
				IMailMsgNotify	*pNotify
				);

    HRESULT STDMETHODCALLTYPE MapContent(
                BOOL            fWrite,
                BYTE            **ppbContent,
                DWORD           *pcContent
                );

    HRESULT STDMETHODCALLTYPE UnmapContent(
                BYTE            *ppbContent
                );

    HRESULT STDMETHODCALLTYPE ValidateStream(
                IMailMsgPropertyStream *pStream
                );

    HRESULT STDMETHODCALLTYPE ValidateContext(
                );

	/***************************************************************************/
	//
	// Implementation of IMailMsgQueueMgmt
	//

	HRESULT STDMETHODCALLTYPE AddUsage();
	HRESULT STDMETHODCALLTYPE ReleaseUsage();

	HRESULT STDMETHODCALLTYPE SetRecipientCount(
				DWORD dwCount
				);
	HRESULT STDMETHODCALLTYPE GetRecipientCount(
				DWORD *pdwCount
				);

	HRESULT STDMETHODCALLTYPE DecrementRecipientCount(
				DWORD dwDecrement
				);
	HRESULT STDMETHODCALLTYPE IncrementRecipientCount(
				DWORD dwIncrement
				);

	HRESULT STDMETHODCALLTYPE Delete(
				IMailMsgNotify *pNotify
				);

	/***************************************************************************/
	//
	// Implementation of IMailMsgBind
	//

	HRESULT STDMETHODCALLTYPE BindToStore(
				IMailMsgPropertyStream	*pStream,
				IMailMsgStoreDriver		*pStore,
				PFIO_CONTEXT			hContentFile
				);

#define MAILMSG_GETPROPS_MARKCOMMIT		0xf0000000
	HRESULT STDMETHODCALLTYPE GetProperties(
				IMailMsgPropertyStream	*pStream,
				DWORD					dwFlags,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE GetBinding(
				PFIO_CONTEXT				*phAsyncIO,
				IMailMsgNotify				*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReleaseContext();

#if 0
	/***************************************************************************/
	//
	// Implementation of IMailMsgBindATQ
	//

	HRESULT STDMETHODCALLTYPE BindToStore(
				IMailMsgPropertyStream		*pStream,
				IMailMsgStoreDriver			*pStore,
				PFIO_CONTEXT				hContentFile,
				void						*pvClientContext,
				ATQ_COMPLETION				pfnCompletion,
				DWORD						dwTimeout,
				struct _ATQ_CONTEXT_PUBLIC	**ppATQContext,
				PFNAtqAddAsyncHandle		pfnAtqAddAsyncHandle,
				PFNAtqFreeContext			pfnAtqFreeContext
				);

	HRESULT STDMETHODCALLTYPE GetATQInfo(
				struct _ATQ_CONTEXT_PUBLIC	**ppATQContext,
				PFIO_CONTEXT				*phAsyncIO,
				IMailMsgNotify				*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReleaseATQHandle();
#endif

	/***************************************************************************/
	//
	// Implementation of IMailMsgAQueueListEntry
	//

	HRESULT STDMETHODCALLTYPE GetListEntry(void **pple) {
        *((LIST_ENTRY **) pple) = &m_leAQueueListEntry;
        return S_OK;
    }

  private:

	// The specific compare function for this type of property table
	static HRESULT CompareProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem
				);

	// Copies
	HRESULT CopyContentToStreamOrFile(
				BOOL			fIsStream,
				LPVOID			pStreamOrHandle,
				IMailMsgNotify	*pNotify,
                DWORD           dwDestOffset //offset in destination file to start
				);

	// Enumeration: restore a master header and make sure it is at
	// least sane.
	HRESULT RestoreMasterHeaderIfAppropriate();

    //Function with internal implementation of ReleaseUsage - MikeSwa
  	HRESULT InternalReleaseUsage(DWORD  dwReleaseUsageFlags);

    //
    // validate that all of the properties in a property table are valid
    //
    HRESULT ValidateProperties(CBlockManager *pBM,
                               DWORD cStream,
                               PROPERTY_TABLE_INSTANCE *pti);

    //
    // validate that the recipient structures are valid
    //
    HRESULT ValidateRecipient(CBlockManager *pBM,
                              DWORD cStream,
                              RECIPIENTS_PROPERTY_ITEM *prspi);

    //
    // Make sure that a flat address is in a valid range
    //
    BOOL ValidateFA(FLAT_ADDRESS fa,
                    DWORD cRange,
                    DWORD cStream,
                    BOOL fInvalidFAOk = FALSE)
    {
        return ((fa == INVALID_FLAT_ADDRESS &&
                 fInvalidFAOk) ||
                (fa >= sizeof(MASTER_HEADER) &&
                 fa + cRange <= cStream));
    }


  public:

	// Blob for storing the store driver handle blob
	LPBYTE							m_pbStoreDriverHandle;
	DWORD							m_dwStoreDriverHandle;

	// DWORD holding some special creation property flags
	DWORD							m_dwCreationFlags;

  private:

	// Usage count
	LONG							m_ulUsageCount;

    // this lock is held when the usage count is going through a transition
    CShareLockNH                m_lockUsageCount;

	// Recipient counter for queue management
	LONG							m_ulRecipientCount;

	// A master header structure for the message object and its blueprint
	MASTER_HEADER					m_Header;
	static const MASTER_HEADER		s_DefaultHeader;

	// Bind information
	PFIO_CONTEXT					m_hContentFile;		// IO/Content file handle
	DWORD							m_cContentFile;		// size of m_hContentFile, -1 if unknown
	IMailMsgPropertyStream			*m_pStream;			// Property Stream interface
	IMailMsgStoreDriver				*m_pStore;			// Store driver interface
//	struct _ATQ_CONTEXT_PUBLIC		*m_pATQContext;		// ATQ Context
	LPVOID							m_pvClientContext;	// Client Context
	ATQ_COMPLETION					m_pfnCompletion;	// ATQ Completion routine
	DWORD							m_dwTimeout;		// ATQ Timeout
	BOOL							m_fCommitCalled;	// set to TRUE after the first successful call to Commit
	BOOL							m_fDeleted;         // Delete has been called

    //The following counter is used to maintain the static
    //g_cCurrentMsgsClosedByExternalReleaseUsage counter.
    //It is only decremented in RestoreResources
    //and only incremented in InteralReleaseUsage
    LONG                            m_cCloseOnExternalReleaseUsage;

	// Reference for RebindAfterFork ...
	IMailMsgStoreDriver				*m_pDefaultRebindStoreDriver;

	// Well known properties
	static INTERNAL_PROPERTY_ITEM	*const s_pWellKnownProperties;
	static const DWORD				s_dwWellKnownProperties;

	// IMailMsgProperties is an instance of CPropertyTable
	CPropertyTable					m_ptProperties;

	// Special property table class instance
	CSpecialPropertyTable			m_SpecialPropertyTable;

	// An instance of the block memory manager
	CBlockManager					m_bmBlockManager;

#if 0
	// Function pointers to ATQ methods
	PFNAtqAddAsyncHandle			m_pfnAtqAddAsyncHandle;
	PFNAtqFreeContext				m_pfnAtqFreeContext;
#endif

    //The list entry must be immediately followed by the context
    LIST_ENTRY                      m_leAQueueListEntry;
    PVOID                           m_pvAQueueListEntryContext;

    CShareLockNH                    m_lockReopen;

    static long                     g_cOpenContentHandles;
    static long                     g_cOpenStreamHandles;
    static long                     g_cTotalUsageCount;
    static long                     g_cTotalReleaseUsageCalls;
    static long                     g_cTotalReleaseUsageNonZero;
    static long                     g_cTotalReleaseUsageCloseStream;
    static long                     g_cTotalReleaseUsageCloseContent;
    static long                     g_cTotalReleaseUsageNothingToClose;
    static long                     g_cTotalReleaseUsageCloseFail;
    static long                     g_cTotalReleaseUsageCommitFail;
    static long                     g_cTotalExternalReleaseUsageZero;
    static long                     g_cCurrentMsgsClosedByExternalReleaseUsage;
  public:
    static long                     cTotalOpenContentHandles()
                                        {return g_cOpenContentHandles;};
    static long                     cTotalOpenStreamHandles()
                                        {return g_cOpenStreamHandles;};
    BOOL                            fIsStreamOpen()
                                        {return (m_pStream ? TRUE : FALSE);};
    BOOL                            fIsContentOpen()
                                        {return (m_hContentFile ? TRUE : FALSE);};
};

inline HRESULT STDMETHODCALLTYPE CMailMsg::SetRecipientCount(DWORD dwCount)
{
	InterlockedExchange(&m_ulRecipientCount, dwCount);
	return(S_OK);
}

inline HRESULT STDMETHODCALLTYPE CMailMsg::GetRecipientCount(DWORD *pdwCount)
{
	_ASSERT(pdwCount);
	if (!pdwCount) return(E_POINTER);
	*pdwCount = InterlockedExchangeAdd(&m_ulRecipientCount, 0);
	return(S_OK);
}

inline HRESULT STDMETHODCALLTYPE CMailMsg::DecrementRecipientCount(DWORD dwDecrement)
{
	if ((LONG)dwDecrement > m_ulRecipientCount)
	{
		_ASSERT(FALSE);
		return(E_FAIL);
	}
	return((InterlockedExchangeAdd(
				&m_ulRecipientCount,
				-(LONG)dwDecrement) == (LONG)dwDecrement)?S_OK:S_FALSE);
}

inline HRESULT STDMETHODCALLTYPE CMailMsg::IncrementRecipientCount(DWORD dwIncrement)
{
	if (m_ulRecipientCount < 0)
	{
		_ASSERT(FALSE);
		return(E_FAIL);
	}
	return((InterlockedExchangeAdd(
				&m_ulRecipientCount,
				dwIncrement) == 0)?S_OK:S_FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmmmgmt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmmgmt.cpp

Abstract:

	This module contains the implementation of the property ID management
	class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/10/98	created

--*/

//#define WIN32_LEAN_AND_MEAN
#include "atq.h"

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"


// =================================================================
// Private Definitions
//



// =================================================================
// Static declarations
//


// =================================================================
// Compare functions
//
HRESULT CMailMsgPropertyManagement::CompareProperty(
			LPVOID			pvPropKey,
			LPPROPERTY_ITEM	pItem
			)
{
	if (*(GUID *)pvPropKey == ((LPPROPID_MGMT_PROPERTY_ITEM)pItem)->Guid)
		return(S_OK);
	return(STG_E_UNKNOWN);
}						


// =================================================================
// Implementation of CMailMsgPropertyManagement
//
CMailMsgPropertyManagement::CMailMsgPropertyManagement(
			CBlockManager				*pBlockManager,
			LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
			)
			:
			m_ptProperties(
					PTT_PROP_ID_TABLE,
					PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID,
					pBlockManager,
					pInstanceInfo,
					CompareProperty,
					NULL,	// Well-known properties not supported
					0		// for this type of table
					)
{
	_ASSERT(pBlockManager);
	_ASSERT(pInstanceInfo);
	m_pBlockManager = pBlockManager;
	m_pInstanceInfo = pInstanceInfo;
}

CMailMsgPropertyManagement::~CMailMsgPropertyManagement()
{
}

HRESULT STDMETHODCALLTYPE CMailMsgPropertyManagement::AllocPropIDRange(
			REFGUID	rguid,
			DWORD	cCount,
			DWORD	*pdwStart
			)
{
	HRESULT						hrRes		= S_OK;
	PROPID_MGMT_PROPERTY_ITEM	pmpiItem;

	_ASSERT(m_pBlockManager);
	_ASSERT(m_pInstanceInfo);

	if (!pdwStart) return E_POINTER;
	
	// OK, 2 scenarios: Either the GUID is not registered or
	// already registered
	hrRes = m_ptProperties.GetPropertyItem(
				(LPVOID)&rguid,
				(LPPROPERTY_ITEM)&pmpiItem);
	if (SUCCEEDED(hrRes))
	{
		_ASSERT(pmpiItem.piItem.faOffset == INVALID_FLAT_ADDRESS);

		if (pmpiItem.piItem.dwMaxSize == cCount)
		{
			// Scenario 1a: Item is found and the count matches,
			// so just return the index
			*pdwStart = pmpiItem.piItem.dwSize;
			hrRes = S_OK;
		}
		else
		{
			// Scenario 1b: Item found but size does not match, this
			// is considered an error!
			hrRes = E_FAIL;
		}
	}
	else
	{
		if (hrRes == STG_E_UNKNOWN)
		{
			// Property not found, now we should create it ...
			DWORD				dwIndex;
			DWORD				dwSpaceLeft;
			CPropertyTableItem	ptiItem(
									m_pBlockManager,
									m_pInstanceInfo);

			// Set the info ...
			pmpiItem.Guid = rguid;
			pmpiItem.piItem.faOffset = INVALID_FLAT_ADDRESS;
			pmpiItem.piItem.dwMaxSize = cCount;

			// OK, we store the next available propid in
			// m_pInstanceInfo->faExtendedInfo. If it is INVALID_FLAT_ADDRESS
			// then we start with IMMPID_CP_START.
			if (m_pInstanceInfo->faExtendedInfo == INVALID_FLAT_ADDRESS)
				pmpiItem.piItem.dwSize = IMMPID_CP_START;
			else
				pmpiItem.piItem.dwSize = (DWORD)(m_pInstanceInfo->faExtendedInfo);

			// See if we have enough slots left ...
			dwSpaceLeft = (DWORD)(INVALID_FLAT_ADDRESS - pmpiItem.piItem.dwSize);
			if (dwSpaceLeft >= cCount)
			{
				hrRes = ptiItem.AddItem(
							(LPPROPERTY_ITEM)&pmpiItem,
							&dwIndex);
				if (SUCCEEDED(hrRes))
				{
					// Bump the start
					m_pInstanceInfo->faExtendedInfo += (FLAT_ADDRESS)cCount;
					*pdwStart = pmpiItem.piItem.dwSize;
				}
			}
			else
				hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
	}

	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgPropertyManagement::EnumPropIDRange(
			DWORD	*pdwIndex,
			GUID	*pguid,
			DWORD	*pcCount,
			DWORD	*pdwStart
			)
{
	return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgp.h $(O)\mailmsgp_i.c : $(STAXINC)\export\mailmsgp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgp_i.c \
    -header $@ \
    -tlb $(O)\mailmsgp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\mmdbgext\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgp.h $(O)\mailmsgp_i.c : $(STAXINC)\export\mailmsgp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgp_i.c \
    -header $@ \
    -tlb $(O)\mailmsgp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\accessor.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	accessor.inl

Abstract:

	This module contains the special property accessors

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	04/19/98	created

--*/

// ======================================================================
// Define macros for declaring accessors
//
#define GET_ACCESSOR(PropertyName)		\
	static HRESULT Get##PropertyName(	\
			PROP_ID	idProp,				\
			LPVOID	pContext,			\
			LPVOID	pParam,				\
			DWORD	cbLength,			\
			LPDWORD	pcbLength,			\
			LPBYTE	pbBuffer			\
			)

#define PUT_ACCESSOR(PropertyName)		\
	static HRESULT Put##PropertyName(	\
			PROP_ID	idProp,				\
			LPVOID	pContext,			\
			LPVOID	pParam,				\
			DWORD	cbLength,			\
			LPBYTE	pbBuffer			\
			)

#define DECLARE_ACCESSORS(PropertyName)	\
	GET_ACCESSOR(PropertyName);			\
	PUT_ACCESSOR(PropertyName);			\

#define ACCESSOR_LIST(PropertyName)		\
	Get##PropertyName, Put##PropertyName


// ======================================================================
// Forward declarations for the accessor functions
//
DECLARE_ACCESSORS(StoreDriverHandle);
DECLARE_ACCESSORS(MessageCreationFlags);
DECLARE_ACCESSORS(MessageOpenHandles);
DECLARE_ACCESSORS(TotalOpenHandles);
DECLARE_ACCESSORS(TotalOpenStreamHandles);
DECLARE_ACCESSORS(TotalOpenContentHandles);

DECLARE_ACCESSORS(SmtpAddress);
DECLARE_ACCESSORS(X400Address);
DECLARE_ACCESSORS(X500Address);
DECLARE_ACCESSORS(LegacyExDn);
DECLARE_ACCESSORS(OtherAddress);
DECLARE_ACCESSORS(SmtpAddressBM);
DECLARE_ACCESSORS(X400AddressBM);
DECLARE_ACCESSORS(X500AddressBM);
DECLARE_ACCESSORS(LegacyExDnBM);
DECLARE_ACCESSORS(OtherAddressBM);
DECLARE_ACCESSORS(DoNotDeliver);
DECLARE_ACCESSORS(NoNameCollisions);
DECLARE_ACCESSORS(RecipientFlags);

DECLARE_ACCESSORS(AddressValue);
DECLARE_ACCESSORS(AddressValueBM);
DECLARE_ACCESSORS(RecipientFlag);


// ======================================================================
// Special property table for CMailMsgProperties
//
SPECIAL_PROPERTY_ITEM	g_SpecialMessagePropertyTableItems[] =
{
	{	IMMPID_MPV_STORE_DRIVER_HANDLE,		PT_NONE,	PA_READ_WRITE,	1, ACCESSOR_LIST(StoreDriverHandle) },
	{	IMMPID_MPV_MESSAGE_CREATION_FLAGS,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(MessageCreationFlags) },
	{	IMMPID_MPV_MESSAGE_OPEN_HANDLES,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(MessageOpenHandles) },
	{	IMMPID_MPV_TOTAL_OPEN_HANDLES,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(TotalOpenHandles) },
	{	IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(TotalOpenStreamHandles) },
	{	IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(TotalOpenContentHandles) },
};

// Special property table info
PTABLE g_SpecialMessagePropertyTable =
{
	g_SpecialMessagePropertyTableItems,
	(sizeof(g_SpecialMessagePropertyTableItems) / sizeof(SPECIAL_PROPERTY_ITEM)),
	TRUE
};


// ======================================================================
// Special property table for CMailMsgRecipients
//
SPECIAL_PROPERTY_ITEM	g_SpecialRecipientsPropertyTableItems[] =
{
	{	IMMPID_RP_ADDRESS_SMTP,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(SmtpAddressBM) },
	{	IMMPID_RP_ADDRESS_X400,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(X400AddressBM) },
	{	IMMPID_RP_ADDRESS_X500,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(X500AddressBM) },
	{	IMMPID_RP_LEGACY_EX_DN,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(LegacyExDnBM) },
	{	IMMPID_RP_RECIPIENT_FLAGS,		PT_DWORD,	PA_READ_WRITE,	1, ACCESSOR_LIST(RecipientFlags) },
	{	IMMPID_RP_ADDRESS_OTHER,		PT_STRING,	PA_READ,		1, ACCESSOR_LIST(OtherAddressBM) },
};

// Special property table info
PTABLE g_SpecialRecipientsPropertyTable =
{
	g_SpecialRecipientsPropertyTableItems,
	(sizeof(g_SpecialRecipientsPropertyTableItems) / sizeof(SPECIAL_PROPERTY_ITEM)),
	TRUE
};


// ======================================================================
// Special property table for CMailMsgRecipientsAdd
//
SPECIAL_PROPERTY_ITEM	g_SpecialRecipientsAddPropertyTableItems[] =
{
	{	IMMPID_RP_ADDRESS_SMTP,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(SmtpAddress) },
	{	IMMPID_RP_ADDRESS_X400,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(X400Address) },
	{	IMMPID_RP_ADDRESS_X500,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(X500Address) },
	{	IMMPID_RP_LEGACY_EX_DN,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(LegacyExDn) },
	{	IMMPID_RP_RECIPIENT_FLAGS,		PT_DWORD,	PA_READ_WRITE,	1, ACCESSOR_LIST(RecipientFlags) },
	{	IMMPID_RP_ADDRESS_OTHER,		PT_STRING,	PA_READ,		1, ACCESSOR_LIST(OtherAddress) },
	{	IMMPID_RPV_DONT_DELIVER,		PT_BOOL,	PA_READ_WRITE,	1, ACCESSOR_LIST(DoNotDeliver) },
	{	IMMPID_RPV_NO_NAME_COLLISIONS,	PT_BOOL,	PA_READ_WRITE,	1, ACCESSOR_LIST(NoNameCollisions) },
};

// Special property table info
PTABLE g_SpecialRecipientsAddPropertyTable =
{
	g_SpecialRecipientsAddPropertyTableItems,
	(sizeof(g_SpecialRecipientsAddPropertyTableItems) / sizeof(SPECIAL_PROPERTY_ITEM)),
	TRUE
};



// ======================================================================
// Implementation of property accessors
//

// ======================================================================
// Get methods
//
// The get methods are implementation-specific. It first checks if the
// desired property is already cached. If so, the cached value is returned
// Otherwise, it will fetch the value from the media. This makes sure
// that the properties will not be loaded if not necessary.

GET_ACCESSOR(StoreDriverHandle)
{
	HRESULT		hrRes = S_OK;
	CMailMsg	*pMsg = (CMailMsg *)pContext;

	if (!pMsg || !pbBuffer)
		return(E_POINTER);
	if (pMsg->m_pbStoreDriverHandle)
	{
		if (pcbLength)
			*pcbLength = pMsg->m_dwStoreDriverHandle;
		if (pMsg->m_dwStoreDriverHandle > cbLength)
			hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		else
		{
		    MoveMemory(pbBuffer,
		               pMsg->m_pbStoreDriverHandle,
			       pMsg->m_dwStoreDriverHandle);
		}
	}
	else
	{
		if (pcbLength)
			*pcbLength = 0;
		hrRes = STG_E_UNKNOWN;
	}
	return(hrRes);
}

GET_ACCESSOR(MessageCreationFlags)
{
	HRESULT		hrRes = S_OK;
	CMailMsg	*pMsg = (CMailMsg *)pContext;

	if (!pMsg || !pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
		*(DWORD *)pbBuffer = pMsg->m_dwCreationFlags;
	}
	return(hrRes);
}

GET_ACCESSOR(MessageOpenHandles)
{
	HRESULT		hrRes = S_OK;
	CMailMsg	*pMsg = (CMailMsg *)pContext;
	DWORD		cHandles = 0;

	if (!pMsg || !pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
        
        //Check if there is a content file
        if (pMsg->fIsContentOpen())
            cHandles++;
        
        //Check if there is a property stream
        if (pMsg->fIsStreamOpen())
            cHandles++;

		*(DWORD *)pbBuffer = cHandles;
	}
	return(hrRes);
}

GET_ACCESSOR(TotalOpenHandles)
{
	HRESULT		hrRes = S_OK;

	if (!pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
        
        //Get the total number of content and stream handles open
        *(DWORD *)pbBuffer = (DWORD) CMailMsg::cTotalOpenStreamHandles() + 
                             (DWORD) CMailMsg::cTotalOpenContentHandles();
	}
	return(hrRes);
}

GET_ACCESSOR(TotalOpenStreamHandles)
{
	HRESULT		hrRes = S_OK;

	if (!pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
        
        //Get the total number of stream handles open
        *(DWORD *)pbBuffer = (DWORD) CMailMsg::cTotalOpenStreamHandles();
	}
	return(hrRes);
}

GET_ACCESSOR(TotalOpenContentHandles)
{
	HRESULT		hrRes = S_OK;

	if (!pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
        
        //Get the total number of content and stream handles open
        *(DWORD *)pbBuffer = (DWORD) CMailMsg::cTotalOpenContentHandles();
	}
	return(hrRes);
}

GET_ACCESSOR(SmtpAddress)
{
	return(GetAddressValue(
				AT_SMTP,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(X400Address)
{
	return(GetAddressValue(
				AT_X400,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(X500Address)
{
	return(GetAddressValue(
				AT_X500,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(LegacyExDn)
{
	return(GetAddressValue(
				AT_LEGACY_EX_DN,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(OtherAddress)
{
	return(GetAddressValue(
				AT_OTHER,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(SmtpAddressBM)
{
	return(GetAddressValueBM(
				AT_SMTP,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(X400AddressBM)
{
	return(GetAddressValueBM(
				AT_X400,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(X500AddressBM)
{
	return(GetAddressValueBM(
				AT_X500,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(LegacyExDnBM)
{
	return(GetAddressValueBM(
				AT_LEGACY_EX_DN,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(OtherAddressBM)
{
	return(GetAddressValueBM(
				AT_OTHER,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(DoNotDeliver)
{
	return(GetRecipientFlag(
				FLAG_RECIPIENT_DO_NOT_DELIVER,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(NoNameCollisions)
{
	return(GetRecipientFlag(
				FLAG_RECIPIENT_NO_NAME_COLLISIONS,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(RecipientFlag)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem || !pbBuffer)
		return(E_POINTER);

	*pcbLength = sizeof(BOOL);
	if (cbLength < sizeof(BOOL))
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
	*(BOOL *)pbBuffer = ((pItem->dwFlags & idProp) != 0)?TRUE:FALSE;
	return(S_OK);
}

GET_ACCESSOR(RecipientFlags)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem || !pbBuffer)
		return(E_POINTER);

	*pcbLength = sizeof(DWORD);
	if (cbLength < sizeof(DWORD))
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
	*(DWORD *)pbBuffer = pItem->dwFlags;
	return(S_OK);
}

GET_ACCESSOR(AddressValue)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem)
		return(E_POINTER);

	// See if the name type is valid
	if ((DWORD)idProp >= MAX_COLLISION_HASH_KEYS)
		return(E_INVALIDARG);

	// See if the name is set
	if (!pItem->faNameOffset[idProp] ||
		!pItem->dwNameLength[idProp])
		return(STG_E_UNKNOWN);

	// See if we have sufficient buffer
	*pcbLength = pItem->dwNameLength[idProp];
	if (cbLength < *pcbLength)
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

	// OK, copy the property value over
	MoveMemory(pbBuffer,
		   (LPVOID)pItem->faNameOffset[idProp],
		   *pcbLength);

	return(S_OK);
}

GET_ACCESSOR(AddressValueBM)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	// The parameter is a pointer to CBlockManager
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	CBlockManager				*pBlockManager = (CBlockManager *)pParam;

	if (!pItem || !pBlockManager)
		return(E_POINTER);

	// See if the name type is valid
	if ((DWORD)idProp >= MAX_COLLISION_HASH_KEYS)
		return(E_INVALIDARG);

	// See if the name is set
	if (pItem->faNameOffset[idProp] == INVALID_FLAT_ADDRESS)
		return(STG_E_UNKNOWN);

	// See if we have sufficient buffer
	*pcbLength = pItem->dwNameLength[idProp];
	if (cbLength < *pcbLength)
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

	// OK, load the property value
	return(pBlockManager->ReadMemory(
				pbBuffer,
				pItem->faNameOffset[idProp],
				pItem->dwNameLength[idProp],
				pcbLength,
				NULL));
}

// ======================================================================
// Set methods
//
// We provide and use generic set methods.

PUT_ACCESSOR(StoreDriverHandle)
{
	HRESULT			hrRes = S_OK;
	LPBYTE			pbWriteBuf;
	CMailMsg		*pMsg = (CMailMsg *)pContext;
	CMemoryAccess	cmaAccess;
	BOOL			fExistedBefore = (pMsg->m_pbStoreDriverHandle != NULL);

	if (!pMsg || !pbBuffer)
		return(E_POINTER);

	pbWriteBuf = pMsg->m_pbStoreDriverHandle;
	if (pMsg->m_dwStoreDriverHandle < cbLength)
	{
		if (pbWriteBuf)
		{
			hrRes = cmaAccess.FreeBlock((LPVOID)pbWriteBuf);
			_ASSERT(SUCCEEDED(hrRes));
		}
		hrRes = cmaAccess.AllocBlock(
					(LPVOID *)&pbWriteBuf,
					cbLength);

		pMsg->m_pbStoreDriverHandle = pbWriteBuf;
	}
	if (SUCCEEDED(hrRes) && pMsg->m_pbStoreDriverHandle) {
	    MoveMemory(pMsg->m_pbStoreDriverHandle,
		       pbBuffer,
		       cbLength);
	    pMsg->m_dwStoreDriverHandle = cbLength;
        }
	else
	{
		pMsg->m_dwStoreDriverHandle = 0;
		hrRes = HRESULT_FROM_WIN32(GetLastError());
		if (SUCCEEDED(hrRes))
			hrRes = E_FAIL;
	}

	if (FAILED(hrRes) && pbWriteBuf)
		cmaAccess.FreeBlock((LPVOID)pbWriteBuf);
	
	if (hrRes == S_OK && !fExistedBefore) hrRes = S_FALSE;

	return(hrRes);
}

PUT_ACCESSOR(MessageCreationFlags)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(MessageOpenHandles)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(TotalOpenHandles)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(TotalOpenStreamHandles)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(TotalOpenContentHandles)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(SmtpAddress)
{
	return(PutAddressValue(
				AT_SMTP,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(X400Address)
{
	return(PutAddressValue(
				AT_X400,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(X500Address)
{
	return(PutAddressValue(
				AT_X500,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(LegacyExDn)
{
	return(PutAddressValue(
				AT_LEGACY_EX_DN,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(OtherAddress)
{
	return(PutAddressValue(
				AT_OTHER,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(SmtpAddressBM)
{
	return(PutAddressValueBM(
				AT_SMTP,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(X400AddressBM)
{
	return(PutAddressValueBM(
				AT_X400,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(X500AddressBM)
{
	return(PutAddressValueBM(
				AT_X500,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(LegacyExDnBM)
{
	return(PutAddressValueBM(
				AT_LEGACY_EX_DN,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(OtherAddressBM)
{
	return(PutAddressValueBM(
				AT_OTHER,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(DoNotDeliver)
{
	return(PutRecipientFlag(
				FLAG_RECIPIENT_DO_NOT_DELIVER,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(NoNameCollisions)
{
	return(PutRecipientFlag(
				FLAG_RECIPIENT_NO_NAME_COLLISIONS,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(RecipientFlag)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
    //pbBuffer is a PBOOL is TRUE to set the bits, FALSE to unset
    //idProp contains the Bits to set
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem || !pbBuffer)
		return(E_POINTER);

    //make sure we don't stray from allowed bits
    _ASSERT(!(idProp & ~RP_RECIP_FLAGS_RESERVED));

	if (*(BOOL *)pbBuffer)
		pItem->dwFlags |= idProp;
	else
		pItem->dwFlags &= ~(idProp);
	return(S_OK);
}

PUT_ACCESSOR(RecipientFlags)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem || !pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		return(E_INVALIDARG);

    //make sure that the reserved bits are not being touched
    _ASSERT((pItem->dwFlags & RP_RECIP_FLAGS_RESERVED) == ((*(DWORD *)pbBuffer) & RP_RECIP_FLAGS_RESERVED));


    //Add additional checks to make sure that the multi-bit properties are being
    //set properly.  If any of the following ASSERT's fire, then the *calling*
    //code needs to be fixed.
#ifdef DEBUG
    if (RP_HANDLED & pItem->dwFlags) //check handled flags
    {
        //if one of the following fires, then the handled flag is set incorrectly
        _ASSERT((RP_DELIVERED & pItem->dwFlags) == RP_DELIVERED ||
                (RP_DSN_SENT_NDR & pItem->dwFlags) == RP_DSN_SENT_NDR ||
                (RP_FAILED & pItem->dwFlags) == RP_FAILED ||
                (RP_UNRESOLVED & pItem->dwFlags) == RP_UNRESOLVED ||
                (RP_ENPANDED & pItem->dwFlags) == RP_ENPANDED);
    }
    if (RP_GENERAL_FAILURE & pItem->dwFlags) //check failure flags
    {
        //if one of the following fires, then the failure flag is set incorrectly
        _ASSERT((RP_FAILED & pItem->dwFlags) == RP_FAILED ||
                (RP_UNRESOLVED & pItem->dwFlags) == RP_UNRESOLVED);
    }
    if (RP_DSN_HANDLED & pItem->dwFlags)
    {
        //if one of the following fires, then the RP_DSN_HANDLED flag is set incorrectly
        _ASSERT((RP_DSN_SENT_EXPANDED & pItem->dwFlags) == RP_DSN_SENT_EXPANDED ||
                (RP_DSN_SENT_RELAYED & pItem->dwFlags) == RP_DSN_SENT_RELAYED ||
                (RP_DSN_SENT_DELIVERED & pItem->dwFlags) == RP_DSN_SENT_DELIVERED ||
                (RP_DSN_SENT_NDR & pItem->dwFlags) == RP_DSN_SENT_NDR);
    }
    _ASSERT(0x00400100 != pItem->dwFlags); //bug #73596 - smoke out the offender!
#endif //DEBUG
    //Make sure reserved bits are not touched in retail builds
    pItem->dwFlags = (*(DWORD *)pbBuffer & ~RP_RECIP_FLAGS_RESERVED) |
                     (pItem->dwFlags & RP_RECIP_FLAGS_RESERVED);
	return(S_OK);
}

PUT_ACCESSOR(AddressValue)
{
	HRESULT	hrRes = S_OK;
	HRESULT	hrTemp;

	
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	LPVOID						pvName;
	LPVOID						pvTemp;

	// Preferred memory allocator
	CMemoryAccess				baAccess;

	if (!pItem)
		return(E_POINTER);

	// See if the name type is valid
	if ((DWORD)idProp >= MAX_COLLISION_HASH_KEYS)
		return(E_INVALIDARG);

	// See if the name is set
	pvTemp = NULL;
	pvName = (LPVOID)pItem->faNameOffset[idProp];
	if (pvName && (cbLength > pItem->dwNameLength[idProp]))
	{
		// We don't have enough space to store the new name, so
		// we will allocate a new block
		pvTemp = pvName;
		pvName = NULL;

	}

	if (!pvName)
	{
		// Allocate a new block
		hrRes = baAccess.AllocBlock(&pvName, cbLength);
	}

	if (SUCCEEDED(hrRes))
	{
	    // OK, copy the property value over
	    MoveMemory(pvName,
		       pbBuffer,
		       cbLength);
	}

	// OK, we got everything we need, so we silently update the
	// name pointer and free the old block if we have one
	if (SUCCEEDED(hrRes))
	{
		pItem->faNameOffset[idProp] = (FLAT_ADDRESS)(DWORD_PTR)pvName;

		if (pvTemp)
		{
			// We can interpret the result of this free, but for all practical
			// purposes, this operation succeeded.
			hrTemp = baAccess.FreeBlock(pvTemp);
			_ASSERT(SUCCEEDED(hrTemp));
		}
	}
	else if (pvName && pvTemp)
	{
		// We failed and we have allocated a new block, so we free
		// the new block and keep the old one
		hrTemp = baAccess.FreeBlock(pvName);
		_ASSERT(SUCCEEDED(hrTemp));
	}

	return(hrRes);
}

PUT_ACCESSOR(AddressValueBM)
{
	return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmmrcpts.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmrcpts.cpp

Abstract:

	This module contains the implementation of the recipient list class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/10/98	created

--*/

#define WIN32_LEAN_AND_MEAN 1
#include "atq.h"
#include "stddef.h"

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"

// =================================================================
// Private Definitions
//

// Define a structure describing a domain in the stream
typedef struct _DOMAIN_TABLE_ENTRY
{
	DWORD						dwStartingIndex;
	DWORD						dwCount;
	FLAT_ADDRESS				faOffsetToName;
	DWORD						dwNameLength;
	DWORD						dwNextDomain;

} DOMAIN_TABLE_ENTRY, *LPDOMAIN_TABLE_ENTRY;

// Define an extended info structure
typedef struct _EXTENDED_INFO
{
	DWORD						dwDomainCount;
	DWORD						dwTotalSizeIncludingThisStruct;

} EXTENDED_INFO, *LPEXTENDED_INFO;

// The following is the list of default address types
PROP_ID		rgDefaultAddressTypes[MAX_COLLISION_HASH_KEYS] =
{
	IMMPID_RP_ADDRESS_SMTP,		// The first address type will be used for domain grouping
	IMMPID_RP_ADDRESS_X400,
	IMMPID_RP_ADDRESS_X500,
	IMMPID_RP_LEGACY_EX_DN,
    IMMPID_RP_ADDRESS_OTHER
};


// =================================================================
// Static declarations
//

// Recipients table instance info for CMailMsgRecipientsAdd instantiation
const PROPERTY_TABLE_INSTANCE CMailMsgRecipientsAdd::s_DefaultInstance =
{
	RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID,
	INVALID_FLAT_ADDRESS,
	RECIPIENTS_PROPERTY_TABLE_FRAGMENT_SIZE,
	RECIPIENTS_PROPERTY_ITEM_BITS,
	RECIPIENTS_PROPERTY_ITEM_SIZE,
	RECIPIENTS_PROPERTY_ITEMS,
	INVALID_FLAT_ADDRESS
};

//
// Well-known per-recipient properties
//
INTERNAL_PROPERTY_ITEM
				*const CMailMsgRecipientsPropertyBase::s_pWellKnownProperties = NULL;
const DWORD		CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties = 0;


// =================================================================
// Compare function
//

HRESULT CMailMsgRecipientsPropertyBase::CompareProperty(
			LPVOID			pvPropKey,
			LPPROPERTY_ITEM	pItem
			)
{
	if (*(PROP_ID *)pvPropKey == ((LPRECIPIENT_PROPERTY_ITEM)pItem)->idProp)
		return(S_OK);
	return(STG_E_UNKNOWN);
}


// =================================================================
// Inline code for special properties
//
#include "accessor.inl"


// =================================================================
// Implementation of CMailMsgRecipientsPropertyBase
//

HRESULT CMailMsgRecipientsPropertyBase::PutProperty(
			CBlockManager				*pBlockManager,
			LPRECIPIENTS_PROPERTY_ITEM	pItem,
			DWORD						dwPropID,
			DWORD						cbLength,
			LPBYTE						pbValue
			)
{
	HRESULT							hrRes = S_OK;
	RECIPIENT_PROPERTY_ITEM			piRcptItem;

	if (!pBlockManager || !pItem || !pbValue) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsPropertyBase::PutProperty");

	// Instantiate a property table for the recipient properties
	CPropertyTable				ptProperties(
									PTT_PROPERTY_TABLE,
									RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
									pBlockManager,
									&(pItem->ptiInstanceInfo),
									CMailMsgRecipientsPropertyBase::CompareProperty,
									CMailMsgRecipientsPropertyBase::s_pWellKnownProperties,
									CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties
									);

	// Put the recipient property
	piRcptItem.idProp = dwPropID;
	hrRes = ptProperties.PutProperty(
					(LPVOID)&dwPropID,
					(LPPROPERTY_ITEM)&piRcptItem,
					cbLength,
					pbValue);

	DebugTrace((LPARAM)this,
				"PutProperty: Prop ID = %u, HRESULT = %08x",
				dwPropID, hrRes);

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CMailMsgRecipientsPropertyBase::GetProperty(
			CBlockManager				*pBlockManager,
			LPRECIPIENTS_PROPERTY_ITEM	pItem,
			DWORD						dwPropID,
			DWORD						cbLength,
			DWORD						*pcbLength,
			LPBYTE						pbValue
			)
{
	HRESULT							hrRes = S_OK;
	RECIPIENT_PROPERTY_ITEM			piRcptItem;

	if (!pBlockManager || !pItem || !pcbLength || !pbValue) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsPropertyBase::GetProperty");

	// Instantiate a property table for the recipient properties
	CPropertyTable				ptProperties(
									PTT_PROPERTY_TABLE,
									RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
									pBlockManager,
									&(pItem->ptiInstanceInfo),
									CMailMsgRecipientsPropertyBase::CompareProperty,
									CMailMsgRecipientsPropertyBase::s_pWellKnownProperties,
									CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties
									);

	// Get the recipient property using an atomic operation
	hrRes = ptProperties.GetPropertyItemAndValue(
						(LPVOID)&dwPropID,
						(LPPROPERTY_ITEM)&piRcptItem,
						cbLength,
						pcbLength,
						pbValue);

	DebugTrace((LPARAM)this,
				"GetPropertyItemAndValue: Prop ID = %u, HRESULT = %08x",
				dwPropID, hrRes);

	TraceFunctLeave();
	return(hrRes);
}



// =================================================================
// Implementation of CMailMsgRecipients
//

CMailMsgRecipients::CMailMsgRecipients(
			CBlockManager				*pBlockManager,
			LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
			)
			:
			m_SpecialPropertyTable(&g_SpecialRecipientsPropertyTable)
{
	_ASSERT(pBlockManager);
	_ASSERT(pInstanceInfo);
	m_pBlockManager = pBlockManager;
	m_pInstanceInfo = pInstanceInfo;
	m_ulRefCount = 0;
	m_dwDomainCount = 0;

	m_pStream = NULL;
	m_fGlobalCommitDone = FALSE;
}

CMailMsgRecipients::~CMailMsgRecipients()
{
}

HRESULT CMailMsgRecipients::SetStream(
			IMailMsgPropertyStream	*pStream
			)
{
	// The stream can be NULL for all we know
	m_pStream = pStream;
	return(S_OK);
}

HRESULT CMailMsgRecipients::SetCommitState(
			BOOL		fGlobalCommitDone
			)
{
	m_fGlobalCommitDone = fGlobalCommitDone;
	return(S_OK);
}

HRESULT CMailMsgRecipients::QueryInterface(
			REFIID		iid,
			void		**ppvObject
			)
{
	if (iid == IID_IUnknown)
	{
		// Return our identity
		*ppvObject = (IUnknown *)(IMailMsgRecipients *)this;
		AddRef();
	}
	else if (iid == IID_IMailMsgRecipients)
	{
		// Return the recipient list interface
		*ppvObject = (IMailMsgRecipients *)this;
		AddRef();
	}
	else if (iid == IID_IMailMsgRecipientsBase)
	{
		// Return the base recipients interface
		*ppvObject = (IMailMsgRecipientsBase *)this;
		AddRef();
	}
	else if (iid == IID_IMailMsgPropertyReplication)
	{
		// Return the base recipients interface
		*ppvObject = (IMailMsgPropertyReplication *)this;
		AddRef();
	}
	else
		return(E_NOINTERFACE);

	return(S_OK);
}

ULONG CMailMsgRecipients::AddRef()
{
	return(InterlockedIncrement(&m_ulRefCount));
}

ULONG CMailMsgRecipients::Release()
{
	LONG	lRefCount = InterlockedDecrement(&m_ulRefCount);
	if (lRefCount == 0)
	{
		delete this;
	}
	return(lRefCount);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::Commit(
			DWORD			dwIndex,
			IMailMsgNotify	*pNotify
			)
{
	HRESULT						hrRes = S_OK;
	RECIPIENTS_PROPERTY_ITEM	piItem;
	FLAT_ADDRESS				faOffset;
	DWORD cTotalBlocksToWrite = 0;
	DWORD cTotalBytesToWrite = 0;

	_ASSERT(m_pBlockManager);
	_ASSERT(m_pInstanceInfo);

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::Commit");

	// Make sure we have a content handle
	hrRes = RestoreResourcesIfNecessary(FALSE, TRUE);
	if (!SUCCEEDED(hrRes))
		return(hrRes);

	_ASSERT(m_pStream);
	if (!m_pStream)
		return(STG_E_INVALIDPARAMETER);

	// Now, see if a global commit call is called [recently enough].
	if (!m_fGlobalCommitDone)
		return(E_FAIL);

	// Get the recipient item first
	{
		CPropertyTableItem		ptiItem(m_pBlockManager, m_pInstanceInfo);

		hrRes = ptiItem.GetItemAtIndex(
						dwIndex,
						(LPPROPERTY_ITEM)&piItem,
						&faOffset
						);

		DebugTrace((LPARAM)this,
					"GetItemAtIndex: index = %u, HRESULT = %08x",
					dwIndex, hrRes);
	}
	for (int fComputeBlockSizes = 1;
		 SUCCEEDED(hrRes) && fComputeBlockSizes >= 0;
		 fComputeBlockSizes--)
	{
		LPPROPERTY_TABLE_INSTANCE	pInstance = &(piItem.ptiInstanceInfo);
		CPropertyTableItem			ptiItem(m_pBlockManager, pInstance);

		if (fComputeBlockSizes) {
			m_pStream->StartWriteBlocks((IMailMsgProperties *) this,
										cTotalBlocksToWrite,
									    cTotalBytesToWrite);
		}

		// Write out the recipient item, this includes the instance
		// info for the recipient property table
		hrRes = m_pBlockManager->CommitDirtyBlocks(
					faOffset,
					sizeof(RECIPIENTS_PROPERTY_ITEM),
					0,
					m_pStream,
					FALSE,
					fComputeBlockSizes,
					&cTotalBlocksToWrite,
					&cTotalBytesToWrite,
					pNotify);
		if (SUCCEEDED(hrRes))
		{
			DWORD						dwLeft;
			DWORD						dwLeftInFragment;
			DWORD						dwSizeRead;
			FLAT_ADDRESS				faFragment;
			LPRECIPIENT_PROPERTY_ITEM	pItem;
			CBlockContext				bcContext;

			RECIPIENT_PROPERTY_TABLE_FRAGMENT	ptfFragment;

			// Commit the special properties
			for (DWORD i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
				if (piItem.faNameOffset[i] != INVALID_FLAT_ADDRESS)
				{
					hrRes = m_pBlockManager->CommitDirtyBlocks(
								piItem.faNameOffset[i],
								piItem.dwNameLength[i],
								0,
								m_pStream,
								FALSE,
								fComputeBlockSizes,
								&cTotalBlocksToWrite,
								&cTotalBytesToWrite,
								pNotify);
					if (!SUCCEEDED(hrRes))
						goto Cleanup;
				}

			// OK, now commit each property
			dwLeft = pInstance->dwProperties;
			faFragment = pInstance->faFirstFragment;

			// $REVIEW(dbraun)
			// WORKAROUND FOR IA64 FRE COMPILER BUG

			//while (faFragment != INVALID_FLAT_ADDRESS)
			while (TRUE)
			{
			    if (faFragment == INVALID_FLAT_ADDRESS)
			    	break;

			// END WORKAROUND

				// Make sure there are items to commit
				_ASSERT(dwLeft);

				// Commit the fragment
				hrRes = m_pBlockManager->CommitDirtyBlocks(
							faFragment,
							sizeof(RECIPIENT_PROPERTY_TABLE_FRAGMENT),
							0,
							m_pStream,
							FALSE,
							fComputeBlockSizes,
							&cTotalBlocksToWrite,
							&cTotalBytesToWrite,
							pNotify);
				if (!SUCCEEDED(hrRes))
					goto Cleanup;

				// Load the fragment info to find the next hop
				hrRes = m_pBlockManager->ReadMemory(
							(LPBYTE)&ptfFragment,
							faFragment,
							sizeof(RECIPIENT_PROPERTY_TABLE_FRAGMENT),
							&dwSizeRead,
							&bcContext);
				if (!SUCCEEDED(hrRes))
					goto Cleanup;

				// Commit each property in the fragment
				dwLeftInFragment = RECIPIENT_PROPERTY_ITEMS;
				pItem = ptfFragment.rgpiItems;
				while (dwLeft && dwLeftInFragment)
				{
					hrRes = m_pBlockManager->CommitDirtyBlocks(
								pItem->piItem.faOffset,
								pItem->piItem.dwSize,
								0,
								m_pStream,
								FALSE,
								fComputeBlockSizes,
								&cTotalBlocksToWrite,
								&cTotalBytesToWrite,
								pNotify);
					if (!SUCCEEDED(hrRes))
						goto Cleanup;

					pItem++;
					dwLeftInFragment--;
					dwLeft--;
				}

				// Next
				faFragment = ptfFragment.ptfFragment.faNextFragment;
			}

			// No more fragments, make sure no more properties as well
			_ASSERT(!dwLeft);
		}

		if (fComputeBlockSizes) {
			m_pStream->EndWriteBlocks((IMailMsgProperties *) this);
		}
	}

Cleanup:

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::DomainCount(
			DWORD	*pdwCount
			)
{
	HRESULT				hrRes = S_OK;
	EXTENDED_INFO		eiInfo;
	DWORD				dwSize;

	_ASSERT(m_pInstanceInfo);

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::DomainCount");

	if (!pdwCount)
		return(E_POINTER);

	// Load up the extended info
	hrRes = m_pBlockManager->ReadMemory(
				(LPBYTE)&eiInfo,
				m_pInstanceInfo->faExtendedInfo,
				sizeof(EXTENDED_INFO),
				&dwSize,
				NULL);
	if (SUCCEEDED(hrRes))
		*pdwCount = eiInfo.dwDomainCount;
	else
		*pdwCount = 0;

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::DomainItem(
			DWORD	dwIndex,
			DWORD	cchLength,
			LPSTR	pszDomain,
			DWORD	*pdwRecipientIndex,
			DWORD	*pdwRecipientCount
			)
{
	return(DomainItemEx(
				dwIndex,
				cchLength,
				pszDomain,
				pdwRecipientIndex,
				pdwRecipientCount,
				NULL));
}

HRESULT CMailMsgRecipients::DomainItemEx(
			DWORD	dwIndex,
			DWORD	cchLength,
			LPSTR	pszDomain,
			DWORD	*pdwRecipientIndex,
			DWORD	*pdwRecipientCount,
			DWORD	*pdwNextDomainIndex
			)
{
	HRESULT				hrRes = S_OK;
	EXTENDED_INFO		eiInfo;
	DWORD				dwSize;

	CBlockContext		cbContext;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::DomainItemEx");

	if (pdwRecipientIndex) *pdwRecipientIndex = 0;
	if (pdwRecipientCount) *pdwRecipientCount = 0;
	if (pdwNextDomainIndex) *pdwNextDomainIndex = 0;
    if (pszDomain) *pszDomain = 0;

	// Load up the extended info
	hrRes = m_pBlockManager->ReadMemory(
				(LPBYTE)&eiInfo,
				m_pInstanceInfo->faExtendedInfo,
				sizeof(EXTENDED_INFO),
				&dwSize,
				&cbContext);
	if (SUCCEEDED(hrRes))
	{
		if (dwIndex >= eiInfo.dwDomainCount)
			hrRes = E_INVALIDARG;
		else
		{
			FLAT_ADDRESS		faOffset;
			DOMAIN_TABLE_ENTRY	dteDomain;

			// Locate the record to load
			faOffset = dwIndex * sizeof(DOMAIN_TABLE_ENTRY);
			faOffset += (m_pInstanceInfo->faExtendedInfo + sizeof(EXTENDED_INFO));

			hrRes = m_pBlockManager->ReadMemory(
						(LPBYTE)&dteDomain,
						faOffset,
						sizeof(DOMAIN_TABLE_ENTRY),
						&dwSize,
						&cbContext);
			if (SUCCEEDED(hrRes))
			{
				// Return the starting index and count regardless
				if (pdwRecipientIndex)
					*pdwRecipientIndex = dteDomain.dwStartingIndex;
				if (pdwRecipientCount)
					*pdwRecipientCount = dteDomain.dwCount;

				if (pdwNextDomainIndex)
					*pdwNextDomainIndex = dteDomain.dwNextDomain;

				if (pszDomain)
				{
					// Check length
					if (dteDomain.dwNameLength > cchLength)
						hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
					else
					{
						// Load up the domain name
						hrRes = m_pBlockManager->ReadMemory(
									(LPBYTE)pszDomain,
									dteDomain.faOffsetToName,
									dteDomain.dwNameLength,
									&dwSize,
									&cbContext);
					}
				}
			}
		}
	}

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::SetNextDomain(
			DWORD	dwDomainIndex,
			DWORD	dwNextDomainIndex,
			DWORD	dwFlags
			)
{
	HRESULT				hrRes = S_OK;
	EXTENDED_INFO		eiInfo;
	DWORD				dwSize;
    DWORD               dwNextDomainIndexValue = dwNextDomainIndex;

	CBlockContext		cbContext;
	CBlockContext		cbNextContext;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::SetNextDomain");

    // Input flags check - mikeswa 7/3/98
    if (FLAG_OVERWRITE_EXISTING_LINKS & dwFlags)
    {
        if ((FLAG_FAIL_IF_NEXT_DOMAIN_LINKED | FLAG_FAIL_IF_SOURCE_DOMAIN_LINKED) & dwFlags)
        {
            hrRes = E_INVALIDARG;
            goto Cleanup;
        }
    }

    if (FLAG_SET_FIRST_DOMAIN & dwFlags)
    {
        //if this flag is set, we will terminate with this domain
        dwNextDomainIndexValue = INVALID_DOMAIN_INDEX;
    }

	// Load up the extended info
	hrRes = m_pBlockManager->ReadMemory(
				(LPBYTE)&eiInfo,
				m_pInstanceInfo->faExtendedInfo,
				sizeof(EXTENDED_INFO),
				&dwSize,
				&cbContext);
	if (SUCCEEDED(hrRes))
	{
		if ((dwDomainIndex >= eiInfo.dwDomainCount) ||
			(!(FLAG_SET_FIRST_DOMAIN & dwFlags) &&  //we only care about 2nd domain if setting it
              (dwNextDomainIndex >= eiInfo.dwDomainCount)))
			hrRes = E_INVALIDARG;
		else
		{
			FLAT_ADDRESS		faOffset;
			FLAT_ADDRESS		faNextOffset;
			DWORD				dwOriginalLink;
			DWORD				dwNextLink;

			// Locate the offset to write
			faOffset = (m_pInstanceInfo->faExtendedInfo + sizeof(EXTENDED_INFO));
			faOffset += offsetof(DOMAIN_TABLE_ENTRY, dwNextDomain);

			faNextOffset = faOffset + (dwNextDomainIndex * sizeof(DOMAIN_TABLE_ENTRY));
			faOffset += dwDomainIndex * sizeof(DOMAIN_TABLE_ENTRY);

            //we only care about the original domain if we aren't overwriting it
            if (!((FLAG_OVERWRITE_EXISTING_LINKS | FLAG_SET_FIRST_DOMAIN) & dwFlags))
            {
			    // Read the original Link's next link
			    hrRes = m_pBlockManager->ReadMemory(
						    (LPBYTE)&dwOriginalLink,
						    faOffset,
						    sizeof(DWORD),
						    &dwSize,
						    &cbContext);
			    if (!SUCCEEDED(hrRes))
				    goto Cleanup;

			    // Observe the flags
			    if ((dwOriginalLink != INVALID_DOMAIN_INDEX) &&
				    (dwFlags & FLAG_FAIL_IF_SOURCE_DOMAIN_LINKED))
			    {
				    hrRes = E_FAIL;
				    goto Cleanup;
			    }

			    // Read the target Link's next link
			    hrRes = m_pBlockManager->ReadMemory(
						    (LPBYTE)&dwNextLink,
						    faNextOffset,
						    sizeof(DWORD),
						    &dwSize,
						    &cbNextContext);
			    if (!SUCCEEDED(hrRes))
				    goto Cleanup;

			    // Observe the flags
			    // Also, if both the original and target domains are linked, we
			    // have no way of fixing these links so we have to fail if
                // FLAG_OVERWRITE_EXISTING_LINKS is not specified
			    if ((dwNextLink != INVALID_DOMAIN_INDEX) &&
				    (
				     (dwFlags & FLAG_FAIL_IF_NEXT_DOMAIN_LINKED) ||
				     (dwOriginalLink != INVALID_DOMAIN_INDEX)
				    ))
			    {
				    hrRes = E_FAIL;
				    goto Cleanup;
			    }
            }
            else
            {
                //we are overwriting exiting link information
                dwNextLink = INVALID_DOMAIN_INDEX;
                dwOriginalLink = INVALID_DOMAIN_INDEX;
            }
			// Write the source's next link
			hrRes = m_pBlockManager->WriteMemory(
						(LPBYTE)&dwNextDomainIndexValue,
						faOffset,
						sizeof(DWORD),
						&dwSize,
						&cbContext);
			if (!SUCCEEDED(hrRes))
				goto Cleanup;

			// Hook'em up! (if there is a next link)
            if (!(FLAG_SET_FIRST_DOMAIN & dwFlags))
            {
			    if (dwOriginalLink != INVALID_DOMAIN_INDEX)
				    dwNextLink = dwOriginalLink;
			    if ((dwNextLink != INVALID_DOMAIN_INDEX) ||
                    (FLAG_OVERWRITE_EXISTING_LINKS & dwFlags))
			    {
				    // Write the next link's next link
				    hrRes = m_pBlockManager->WriteMemory(
							    (LPBYTE)&dwNextLink,
							    faNextOffset,
							    sizeof(DWORD),
							    &dwSize,
							    &cbNextContext);
			    }
            }
		}
	}

Cleanup:

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::InitializeRecipientFilterContext(
			LPRECIPIENT_FILTER_CONTEXT	pContext,
			DWORD						dwStartingDomain,
			DWORD						dwFilterFlags,
			DWORD						dwFilterMask
			)
{
	HRESULT	hrRes = S_OK;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::InitializeRecipientFilterContext");

	if (!pContext)
		return(E_POINTER);

	// First, get the domain item ...
	hrRes = DomainItemEx(
				dwStartingDomain,
				0,
				NULL,
				&(pContext->dwCurrentRecipientIndex),
				&(pContext->dwRecipientsLeftInDomain),
				&(pContext->dwNextDomain));
	if (SUCCEEDED(hrRes))
	{
		pContext->dwCurrentDomain = dwStartingDomain;
		pContext->dwFilterFlags = dwFilterFlags;
		pContext->dwFilterMask = dwFilterMask;
	}
	else
		pContext->dwCurrentDomain = INVALID_DOMAIN_INDEX;

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::TerminateRecipientFilterContext(
			LPRECIPIENT_FILTER_CONTEXT	pContext
			)
{
	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::TerminateRecipientFilterContext");

	if (!pContext)
		return(E_POINTER);
	pContext->dwCurrentDomain = INVALID_DOMAIN_INDEX;
	TraceFunctLeaveEx((LPARAM)this);
	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::GetNextRecipient(
			LPRECIPIENT_FILTER_CONTEXT	pContext,
			DWORD						*pdwRecipientIndex
			)
{
	HRESULT	hrRes = E_FAIL;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::GetNextRecipient");

	if (!pContext || !pdwRecipientIndex)
		return(E_POINTER);

	if (INVALID_DOMAIN_INDEX == pContext->dwCurrentDomain)
		return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

	// Fetch the next recipient that matches the criteria
	do
	{
		if (pContext->dwRecipientsLeftInDomain)
		{
			// This is easy, just return the index index
			*pdwRecipientIndex = (pContext->dwCurrentRecipientIndex)++;
			(pContext->dwRecipientsLeftInDomain)--;
			DebugTrace((LPARAM)this, "Returning next recipient, index %u",
						*pdwRecipientIndex);
			hrRes = S_OK;
		}
		else
		{
			DWORD	dwNextDomain;
			DWORD	dwStartingIndex;
			DWORD	dwRecipientCount;

			// See if we have a next domain, we are done if not
			if (pContext->dwNextDomain == INVALID_DOMAIN_INDEX)
			{
				DebugTrace((LPARAM)this, "No more domains, we are done");
				hrRes = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
				break;
			}

			// Go on to the next domain
			DebugTrace((LPARAM)this, "Loading next domain, index %u",
						pContext->dwNextDomain);
			hrRes = DomainItemEx(
						pContext->dwNextDomain,
						0,
						NULL,
						&dwStartingIndex,
						&dwRecipientCount,
						&dwNextDomain);
			if (SUCCEEDED(hrRes))
			{
				// A domain with zero recipients is by definition not allowed
				_ASSERT(dwRecipientCount);

				*pdwRecipientIndex = dwStartingIndex++;
				DebugTrace((LPARAM)this, "Returning first recipient, index %u",
							*pdwRecipientIndex);
				pContext->dwCurrentDomain = pContext->dwNextDomain;
				pContext->dwCurrentRecipientIndex = dwStartingIndex;
				pContext->dwRecipientsLeftInDomain = --dwRecipientCount;
				pContext->dwNextDomain = dwNextDomain;
			}
			else
				pContext->dwCurrentDomain = INVALID_DOMAIN_INDEX;
		}

		// Now check if the recipient flags match the criteria
		if (SUCCEEDED(hrRes))
		{
			FLAT_ADDRESS	faOffset;
			DWORD			dwFlags, dwSize;

			// See if this is the one we want ...
			faOffset = m_pInstanceInfo->faFirstFragment;
			if (faOffset == INVALID_FLAT_ADDRESS)
			{
				hrRes = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				break;
			}
			faOffset += (sizeof(PROPERTY_TABLE_FRAGMENT) +
						 offsetof(RECIPIENTS_PROPERTY_ITEM, dwFlags) +
						 (sizeof(RECIPIENTS_PROPERTY_ITEM) * *pdwRecipientIndex)
						);
			hrRes = m_pBlockManager->ReadMemory(
						(LPBYTE)&dwFlags,
						faOffset,
						sizeof(DWORD),
						&dwSize,
						NULL);
			if (!SUCCEEDED(hrRes))
				break;

			// Compare the flags : we mask out the bits that we are interested in,
			// then we will make sure the interested bits are a perfect match.
			dwFlags &= pContext->dwFilterMask;
			if (dwFlags ^ pContext->dwFilterFlags)
				hrRes = E_FAIL;
			DebugTrace((LPARAM)this, "Masked recipient flags %08x, required flags: %08x, %smatched",
						dwFlags, pContext->dwFilterFlags,
						(dwFlags == pContext->dwFilterFlags)?"":"not ");
		}

	} while (!SUCCEEDED(hrRes));

	// Invalidate the context if we are done or we hit an error
	if (!SUCCEEDED(hrRes))
		pContext->dwCurrentDomain = INVALID_DOMAIN_INDEX;

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::AllocNewList(
			IMailMsgRecipientsAdd	**ppNewList
			)
{
	HRESULT					hrRes = S_OK;
	CMailMsgRecipientsAdd	*pNewList;

	_ASSERT(m_pInstanceInfo);

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::AllocNewList");

	if (!ppNewList)
		return(E_POINTER);
	pNewList = new CMailMsgRecipientsAdd(m_pBlockManager);
	if (!pNewList)
		hrRes = E_OUTOFMEMORY;

	if (SUCCEEDED(hrRes))
	{
		// Get the correct interface
		hrRes = pNewList->QueryInterface(
					IID_IMailMsgRecipientsAdd,
					(LPVOID *)ppNewList);
		if (!SUCCEEDED(hrRes))
			pNewList->Release();
	}

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::WriteList(
			IMailMsgRecipientsAdd	*pNewList
			)
{
	HRESULT					hrRes = S_OK;
	CRecipientsHash			*pHash;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::WriteList");

	if (!pNewList)
		return(E_POINTER);

	// Get the underlying implementation
	pHash = ((CMailMsgRecipientsAdd *)pNewList)->GetHashTable();

	do
	{
		DWORD						dwDomainNameSize;
		DWORD						dwRecipientNameSize;
		DWORD						dwRecipientCount;
		DWORD						dwDomainCount;

		DWORD						dwTotalSize;
		DWORD						dwSize;
		FLAT_ADDRESS				faBuffer;
		FLAT_ADDRESS				faFirstFragment;
		FLAT_ADDRESS				faDomainList;
		FLAT_ADDRESS				faRecipient;
		FLAT_ADDRESS				faStringTable;

		// Have different contexts for fastest access
		CBlockContext				bcDomain;
		CBlockContext				bcRecipient;
		CBlockContext				bcString;

		// This is a lengthy process since CMailMsgRecipientAdd will actually
		// go in and build the entire domain list
		hrRes = pHash->BuildDomainListFromHash((CMailMsgRecipientsAdd *)pNewList);
		if (!SUCCEEDED(hrRes))
			break;

		// OK, now we have a domain list, then collect the memory requirements
		pHash->GetDomainCount(&dwDomainCount);
		pHash->GetDomainNameSize(&dwDomainNameSize);
		pHash->GetRecipientCount(&dwRecipientCount);
		pHash->GetRecipientNameSize(&dwRecipientNameSize);
		m_dwDomainCount = dwDomainCount;

		//
		// The data will be laid out as follows:
		//
		// An EXTENDED_INFO structure
		// dwDomainCount entries of DOMAIN_TABLE_ENTRY
		// A single fragment of RECIPIENT_PROPERTY_TABLE_FRAGMENT with:
		//      dwRecipientCount entries of RECIPIENTS_PROPERTY_ITEM
		// A flat string table for all the domain and recipient name strings
		//

		// Calculate all the memory needed
		dwTotalSize = sizeof(EXTENDED_INFO) +
						(sizeof(DOMAIN_TABLE_ENTRY) * dwDomainCount) +
						sizeof(PROPERTY_TABLE_FRAGMENT) +
						(sizeof(RECIPIENTS_PROPERTY_ITEM) * dwRecipientCount) +
						dwDomainNameSize +
						dwRecipientNameSize;

		DebugTrace((LPARAM)this, "%u bytes required to write recipient list",
						dwTotalSize);

		// Allocate the memory
		hrRes = m_pBlockManager->AllocateMemory(
						dwTotalSize,
						&faBuffer,
						&dwSize,
						NULL);
		DebugTrace((LPARAM)this, "AllocateMemory: HRESULT = %08x", hrRes);
		if (!SUCCEEDED(hrRes))
			break;

		_ASSERT(dwSize >= dwTotalSize);

		// Fill in the info ... try to use the stack so that we minimize
		// other memory overhead
		{
			EXTENDED_INFO	eiInfo;

			eiInfo.dwDomainCount = dwDomainCount;
			eiInfo.dwTotalSizeIncludingThisStruct = dwTotalSize;

			hrRes = m_pBlockManager->WriteMemory(
						(LPBYTE)&eiInfo,
						faBuffer,
						sizeof(EXTENDED_INFO),
						&dwSize,
						&bcDomain);
			DebugTrace((LPARAM)this, "WriteMemory: HRESULT = %08x", hrRes);
			if (!SUCCEEDED(hrRes))
				break;

		}

		// Set up all the pointers
		faDomainList = faBuffer + sizeof(EXTENDED_INFO);
		faRecipient = faDomainList +
						(sizeof(DOMAIN_TABLE_ENTRY) * dwDomainCount);
		faStringTable = faRecipient +
						sizeof(PROPERTY_TABLE_FRAGMENT) +
						(sizeof(RECIPIENTS_PROPERTY_ITEM) * dwRecipientCount);

		// Build and write out the recipient table fragment
		{
			PROPERTY_TABLE_FRAGMENT		ptfFragment;

			ptfFragment.dwSignature = PROPERTY_FRAGMENT_SIGNATURE_VALID;
			ptfFragment.faNextFragment = INVALID_FLAT_ADDRESS;

			hrRes = m_pBlockManager->WriteMemory(
						(LPBYTE)&ptfFragment,
						faRecipient,
						sizeof(PROPERTY_TABLE_FRAGMENT),
						&dwSize,
						&bcRecipient);
			if (!SUCCEEDED(hrRes))
				break;

			// Mark this for later
			faFirstFragment = faRecipient;
			faRecipient += sizeof(PROPERTY_TABLE_FRAGMENT);
		}

		// Build the domain table
		{
			DOMAIN_TABLE_ENTRY				dteEntry;
			DOMAIN_ITEM_CONTEXT				dicContext;
			LPRECIPIENTS_PROPERTY_ITEM_EX	pItemEx;
			LPRECIPIENTS_PROPERTY_ITEM		pItem;
			DWORD							dwCurrentDomain = 0;
			DWORD							dwCurrentIndex = 0;
			DWORD							dwCount;
			DWORD							dwLength;
            LPDOMAIN_LIST_ENTRY             pDomainListEntry;
            BOOL                            fGetFirstDomain = FALSE;

			hrRes = pHash->GetFirstDomain(
						&dicContext,
						&pItemEx,
                        &pDomainListEntry);
			DebugTrace((LPARAM)this, "GetFirstDomain: HRESULT = %08x", hrRes);
            fGetFirstDomain = TRUE;

			while (SUCCEEDED(hrRes))
			{
				dwCount = 0;
				// OK, process the domain by walking it's members
				while (pItemEx)
				{
					DWORD	dwCurrentName;
					DWORD_PTR faStack[MAX_COLLISION_HASH_KEYS];

					// Obtain the record in stream form
					pItem = &(pItemEx->rpiRecipient);

					for (dwCurrentName = 0;
						 dwCurrentName < MAX_COLLISION_HASH_KEYS;
						 dwCurrentName++)
					{
						// Store the pointers ...
						faStack[dwCurrentName] = pItem->faNameOffset[dwCurrentName];

						// Write out valid names
						if (faStack[dwCurrentName] != (FLAT_ADDRESS)NULL)
						{
							// Write out the first name
							dwLength = pItem->dwNameLength[dwCurrentName];
							hrRes = m_pBlockManager->WriteMemory(
										(LPBYTE)faStack[dwCurrentName],
										faStringTable,
										dwLength,
										&dwSize,
										&bcString);
							if (!SUCCEEDED(hrRes))
								break;

							// Convert the pointer to an offset and bump the ptr
							pItem->faNameOffset[dwCurrentName] = faStringTable;
							faStringTable += dwLength;
						}
						else
						{
							// Name is not valid, so set it to invalid
							pItem->faNameOffset[dwCurrentName] = INVALID_FLAT_ADDRESS;
						}
					}

					// Finally, write out the recipient record
					hrRes = m_pBlockManager->WriteMemory(
								(LPBYTE)pItem,
								faRecipient,
								sizeof(RECIPIENTS_PROPERTY_ITEM),
								&dwSize,
								&bcRecipient);
					if (!SUCCEEDED(hrRes))
						break;

					for (dwCurrentName = 0;
						 dwCurrentName < MAX_COLLISION_HASH_KEYS;
						 dwCurrentName++)
					{
						// Restore the pointers ...
						pItem->faNameOffset[dwCurrentName] = (FLAT_ADDRESS) faStack[dwCurrentName];
					}

					// Bump the ptr
					faRecipient += sizeof(RECIPIENTS_PROPERTY_ITEM);

					// Do next item
					dwCount++;
					pItemEx = pItemEx->pNextInDomain;
				}

				// Don't continue if failed!
				if (!SUCCEEDED(hrRes))
					break;

				// Write out the domain record
				dwLength = pDomainListEntry->dwDomainNameLength;
				dteEntry.dwStartingIndex = dwCurrentIndex;
				dteEntry.dwCount = dwCount;
				dteEntry.faOffsetToName = faStringTable;
				dteEntry.dwNameLength = dwLength;
				dteEntry.dwNextDomain = INVALID_DOMAIN_INDEX;
				dwCurrentIndex += dwCount;

				hrRes = m_pBlockManager->WriteMemory(
							(LPBYTE)&dteEntry,
							faDomainList,
							sizeof(DOMAIN_TABLE_ENTRY),
							&dwSize,
							&bcDomain);
				if (!SUCCEEDED(hrRes))
					break;

				// Bump the ptr
				faDomainList += sizeof(DOMAIN_TABLE_ENTRY);

				// Write out the domain name
				hrRes = m_pBlockManager->WriteMemory(
							(LPBYTE)pDomainListEntry->szDomainName,
							faStringTable,
							dwLength,
							&dwSize,
							&bcString);
				if (!SUCCEEDED(hrRes))
					break;

				// Bump the ptr
				faStringTable += dwLength;

				// OKay, up the count and get the next domain
				dwCurrentDomain++;
				hrRes = pHash->GetNextDomain(
						&dicContext,
						&pItemEx,
                        &pDomainListEntry);

				DebugTrace((LPARAM)this, "GetNextDomain: HRESULT = %08x", hrRes);
			}

			// Now, if everything is in order, we should have a failed
			// HRESULT of HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS).
			if (hrRes != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			{
                if (fGetFirstDomain) {
                    HRESULT hr = pHash->CloseDomainContext(&dicContext);
                    _ASSERT(SUCCEEDED(hr));
                }
				ErrorTrace((LPARAM)this, "Expecting ERROR_NO_MORE_ITEMS, got = %08x", hrRes);
			} else {
			    hrRes = S_OK;
            }

		}// Stack frame

		// OKay, we've come this far, now all we are left to do is to
		// update our instance info structure to link to this new list
		// Note this will be flushed when the master header is committed
		dwSize = sizeof(PROPERTY_TABLE_FRAGMENT) +
				(sizeof(RECIPIENTS_PROPERTY_ITEM) * dwRecipientCount);

		// Hook up first fragment
		m_pInstanceInfo->faFirstFragment = faFirstFragment;

		// Update the fragment size
		m_pInstanceInfo->dwFragmentSize = dwSize;

		// Force to evaluate only 1 fragment
		m_pInstanceInfo->dwItemBits = 31;

		// Should not change, but for good measure
		m_pInstanceInfo->dwItemSize = sizeof(RECIPIENTS_PROPERTY_ITEM);

		// Properties = number of recipient records
		m_pInstanceInfo->dwProperties = dwRecipientCount;

		// Hook up to the EXTENDED_INFO struct
		m_pInstanceInfo->faExtendedInfo = faBuffer;

	} while (0);

	// Update the commit state
	if (SUCCEEDED(hrRes))
		m_fGlobalCommitDone = FALSE;

	TraceFunctLeave();
	return(hrRes);
}


/***************************************************************************/
//
// Implementation of CMailMsgRecipients::CMailMsgRecipientsPropertyBase
//



HRESULT STDMETHODCALLTYPE CMailMsgRecipients::Count(
			DWORD	*pdwCount
			)
{
	_ASSERT(m_pInstanceInfo);

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::Count");

	if (!pdwCount)
		return(E_POINTER);
	*pdwCount = m_pInstanceInfo->dwProperties;

	TraceFunctLeave();
	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::Item(
			DWORD	dwIndex,
			DWORD	dwWhichName,
			DWORD	cchLength,
			LPSTR	pszName
			)
{
	HRESULT						hrRes = S_OK;
	RECIPIENTS_PROPERTY_ITEM	piItem;

	_ASSERT(m_pBlockManager);
	_ASSERT(m_pInstanceInfo);

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::Item");

	if (!pszName)
		return(E_POINTER);

	// We know where the name is immediately
	if (dwWhichName >= MAX_COLLISION_HASH_KEYS)
		return(E_INVALIDARG);

	// Get the recipient item first
	{
		CPropertyTableItem		ptiItem(m_pBlockManager, m_pInstanceInfo);

		hrRes = ptiItem.GetItemAtIndex(
						dwIndex,
						(LPPROPERTY_ITEM)&piItem
						);

		DebugTrace((LPARAM)this,
					"GetItemAtIndex: index = %u, HRESULT = %08x",
					dwIndex, hrRes);
	}
	if (SUCCEEDED(hrRes))
	{
		DWORD			dwSizeToRead;
		DWORD			dwSize;
		FLAT_ADDRESS	faOffset;

		dwSizeToRead = piItem.dwNameLength[dwWhichName];
		faOffset = piItem.faNameOffset[dwWhichName];

		if (faOffset == INVALID_FLAT_ADDRESS)
			return(STG_E_UNKNOWN);

		// See if we have enough buffer
		if (cchLength < dwSizeToRead)
			return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

		// Issue the read
		hrRes = m_pBlockManager->ReadMemory(
						(LPBYTE)pszName,
						faOffset,
						dwSizeToRead,
						&dwSize,
						NULL);
	}

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::PutProperty(
			DWORD	dwIndex,
			DWORD	dwPropID,
			DWORD	cbLength,
			LPBYTE	pbValue
			)
{
	HRESULT						hrRes = S_OK;
	RECIPIENTS_PROPERTY_ITEM	piItem;
	FLAT_ADDRESS				faOffset;

	_ASSERT(m_pBlockManager);
	_ASSERT(m_pInstanceInfo);

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::PutProperty");

	// Get the recipient item first
	{
		CPropertyTableItem		ptiItem(m_pBlockManager, m_pInstanceInfo);

		hrRes = ptiItem.GetItemAtIndex(
						dwIndex,
						(LPPROPERTY_ITEM)&piItem,
						&faOffset
						);

		DebugTrace((LPARAM)this,
					"GetItemAtIndex: index = %u, HRESULT = %08x",
					dwIndex, hrRes);
	}
	if (SUCCEEDED(hrRes))
	{
		HRESULT	myRes = S_OK;

		// Handle special properties first
		hrRes = m_SpecialPropertyTable.PutProperty(
					(PROP_ID)dwPropID,
					(LPVOID)&piItem,
					(LPVOID)m_pBlockManager,
					PT_NONE,
					cbLength,
					pbValue,
					TRUE);
		if (SUCCEEDED(hrRes) && (hrRes != S_OK))
		{
			// Call the derived generic method
			hrRes = CMailMsgRecipientsPropertyBase::PutProperty(
						m_pBlockManager,
						&piItem,
						dwPropID,
						cbLength,
						pbValue);

			//
			// There is a window here for concurrency problems: if two threads
			// try to add properties to the same recipient using this method, then
			// we will have a property ID step over, since we acquire and increment the
			// property ID value in a non-atomic manner.
			//
			// Note that IMailMsgRecipientsAdd::PutProperty does not have this problem
			//
		    if (SUCCEEDED(hrRes) &&
			    (hrRes == S_FALSE))
		    {
                //mikeswa - changed 7/8/98 write entire item to memory
			    LPBYTE		pbTemp = (LPBYTE)&piItem;
			    myRes = m_pBlockManager->WriteMemory(
						    pbTemp,
						    faOffset,
						    sizeof(RECIPIENTS_PROPERTY_ITEM),
						    &cbLength,
						    NULL);
		    }

		}
		else if (SUCCEEDED(hrRes))
		{
			LPBYTE		pbTemp = (LPBYTE)&piItem;
			myRes = m_pBlockManager->WriteMemory(
						pbTemp,
						faOffset,
						sizeof(RECIPIENTS_PROPERTY_ITEM),
						&cbLength,
						NULL);
		}

		// Here, if any of the writes failed, we will return an error
		// note, myRes being not S_OK implies hrRes being successful.
		if (FAILED(myRes))
			hrRes = myRes;
	}

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::GetProperty(
			DWORD	dwIndex,
			DWORD	dwPropID,
			DWORD	cbLength,
			DWORD	*pcbLength,
			LPBYTE	pbValue
			)
{
	HRESULT						hrRes = S_OK;
	RECIPIENTS_PROPERTY_ITEM	piItem;

	_ASSERT(m_pBlockManager);
	_ASSERT(m_pInstanceInfo);

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::GetProperty");

	if (!pcbLength || !pbValue)
		return(E_POINTER);

	*pcbLength = 0;

	// Get the recipient item first
	{
		CPropertyTableItem		ptiItem(m_pBlockManager, m_pInstanceInfo);

		hrRes = ptiItem.GetItemAtIndex(
						dwIndex,
						(LPPROPERTY_ITEM)&piItem
						);

		DebugTrace((LPARAM)this,
					"GetItemAtIndex: index = %u, HRESULT = %08x",
					dwIndex, hrRes);
	}
	if (SUCCEEDED(hrRes))
	{
		// Special properties are optimized
		// Handle special properties first
		hrRes = m_SpecialPropertyTable.GetProperty(
					(PROP_ID)dwPropID,
					(LPVOID)&piItem,
					(LPVOID)m_pBlockManager,
					PT_NONE,
					cbLength,
					pcbLength,
					pbValue,
					TRUE);
		if (SUCCEEDED(hrRes) && (hrRes != S_OK))
		{
			// Call the derived generic method
			hrRes = CMailMsgRecipientsPropertyBase::GetProperty(
						m_pBlockManager,
						&piItem,
						dwPropID,
						cbLength,
						pcbLength,
						pbValue);
		}
	}

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::CopyTo(
			DWORD					dwSourceRecipientIndex,
			IMailMsgRecipientsBase	*pTargetRecipientList,
			DWORD					dwTargetRecipientIndex,
			DWORD					dwExemptCount,
			DWORD					*pdwExemptPropIdList
			)
{
	HRESULT							hrRes = S_OK;
	RECIPIENTS_PROPERTY_ITEM		piItem;
	LPRECIPIENTS_PROPERTY_ITEM		pRcptItem;
	RECIPIENT_PROPERTY_ITEM			piRcptItem;
	DWORD							dwIndex;
	DWORD							dwExempt;
	DWORD							*pdwExemptId;
	BOOL							fExempt;

	BYTE							rgbCopyBuffer[4096];
	DWORD							dwBufferSize = sizeof(rgbCopyBuffer);
	DWORD							dwSizeRead;
	LPBYTE							pBuffer = rgbCopyBuffer;

	if (!pTargetRecipientList)
		return(E_POINTER);
	if (dwExemptCount)
	{
		_ASSERT(pdwExemptPropIdList);
		if (!pdwExemptPropIdList)
			return(E_POINTER);
	}
	_ASSERT(m_pBlockManager);
	_ASSERT(m_pInstanceInfo);

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::CopyTo");

	// Get the recipient item first
	{
		CPropertyTableItem		ptiItem(m_pBlockManager, m_pInstanceInfo);

		hrRes = ptiItem.GetItemAtIndex(
						dwSourceRecipientIndex,
						(LPPROPERTY_ITEM)&piItem
						);

		DebugTrace((LPARAM)this,
					"GetItemAtIndex: index = %u, HRESULT = %08x",
					dwSourceRecipientIndex, hrRes);
	}

	if (SUCCEEDED(hrRes))
	{
		DWORD	dwTempFlags;

		pRcptItem = &piItem;

		// Iteratively copy all properties from the source to the target, avoiding
		// those in the exempt list note that special name properties are not copied.

		// First, copy the recipient flags as a special property
		dwTempFlags = piItem.dwFlags &
			~(FLAG_RECIPIENT_DO_NOT_DELIVER | FLAG_RECIPIENT_NO_NAME_COLLISIONS);
		DebugTrace((LPARAM)this, "Copying recipient flags (%08x)", dwTempFlags);
		hrRes = pTargetRecipientList->PutProperty(
					dwTargetRecipientIndex,
					IMMPID_RP_RECIPIENT_FLAGS,
					sizeof(DWORD),
					(LPBYTE)&dwTempFlags);
		if (FAILED(hrRes))
		{
			ErrorTrace((LPARAM)this, "Failed to copy recipient flags (%08x)", hrRes);
			TraceFunctLeaveEx((LPARAM)this);
			return(hrRes);
		}

		// Instantiate a property table for the recipient properties
		LPPROPERTY_TABLE_INSTANCE	pInstance =
										&(pRcptItem->ptiInstanceInfo);
		CPropertyTable				ptProperties(
										PTT_PROPERTY_TABLE,
										RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
										m_pBlockManager,
										pInstance,
										CMailMsgRecipientsPropertyBase::CompareProperty,
										CMailMsgRecipientsPropertyBase::s_pWellKnownProperties,
										CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties
										);

		dwIndex = 0;
		do
		{
			// Get the recipient property using an atomic operation
			hrRes = ptProperties.GetPropertyItemAndValueUsingIndex(
								dwIndex,
								(LPPROPERTY_ITEM)&piRcptItem,
								dwBufferSize,
								&dwSizeRead,
								pBuffer);
			if (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
			{
				// Insufficient buffer, try a bigger buffer
				do { dwBufferSize <<= 1; } while (dwBufferSize < piRcptItem.piItem.dwSize);
				pBuffer = new BYTE [dwBufferSize];
				if (!pBuffer)
				{
					hrRes = E_OUTOFMEMORY;
					ErrorTrace((LPARAM)this,
								"Unable to temporarily allocate %u bytes, HRESULT = %08x",
								dwBufferSize, hrRes);
					goto Cleanup;
				}

				// Read it with the proper buffer
				hrRes = m_pBlockManager->ReadMemory(
							pBuffer,
							piRcptItem.piItem.faOffset,
							piRcptItem.piItem.dwSize,
							&dwSizeRead,
							NULL);
			}

			DebugTrace((LPARAM)this,
						"Read: [%u] PropID = %u, length = %u, HRESULT = %08x",
						dwIndex,
						piRcptItem.idProp,
						piRcptItem.piItem.dwSize,
						hrRes);

			if (SUCCEEDED(hrRes))
			{
				// See if this is an exempt property
				for (dwExempt = 0,
					 pdwExemptId = pdwExemptPropIdList,
					 fExempt = FALSE;
					 dwExempt < dwExemptCount;
					 dwExempt++,
					 pdwExemptId++)
					if (piRcptItem.idProp == *pdwExemptId)
					{
						DebugTrace((LPARAM)this, "Property exempted");
						fExempt = TRUE;
						break;
					}

				if (!fExempt)
				{
					// Write it out the the target object
					hrRes = pTargetRecipientList->PutProperty(
								dwTargetRecipientIndex,
								piRcptItem.idProp,
								piRcptItem.piItem.dwSize,
								pBuffer);

					DebugTrace((LPARAM)this, "Write: HRESULT = %08x", hrRes);
				}

				// Next
				dwIndex++;
			}

		} while (SUCCEEDED(hrRes));

		// Correct the error code
		if (hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			hrRes = S_OK;
	}

Cleanup:

	if (pBuffer && pBuffer != rgbCopyBuffer)
		delete [] pBuffer;

	TraceFunctLeave();
	return(hrRes);
}

// *************************************************************************************
// *************************************************************************************
// *************************************************************************************
// *************************************************************************************

// =================================================================
// Implementation of CMailMsgRecipientsAdd
//

#define ADD_DEFAULT_RECIPIENT_NAME_BUFFER_SIZE		2048


CMailMsgRecipientsAdd::CMailMsgRecipientsAdd(
			CBlockManager				*pBlockManager
			)
			:
			m_SpecialPropertyTable(&g_SpecialRecipientsAddPropertyTable)
{
	_ASSERT(pBlockManager);

	// Initialize the refcount
	m_ulRefCount = 0;

	// Acquire the block manager
	m_pBlockManager = pBlockManager;

	// Initialize the internal property table instance
	MoveMemory(
			&m_InstanceInfo,
			&s_DefaultInstance,
			sizeof(PROPERTY_TABLE_INSTANCE));
}

CMailMsgRecipientsAdd::~CMailMsgRecipientsAdd()
{
}

HRESULT CMailMsgRecipientsAdd::QueryInterface(
			REFIID		iid,
			void		**ppvObject
			)
{
	if (iid == IID_IUnknown)
	{
		// Return our identity
		*ppvObject = (IUnknown *)(IMailMsgRecipientsAdd *)this;
		AddRef();
	}
	else if (iid == IID_IMailMsgRecipientsAdd)
	{
		// Return the add recipients interface
		*ppvObject = (IMailMsgRecipientsAdd *)this;
		AddRef();
	}
	else if (iid == IID_IMailMsgRecipientsBase)
	{
		// Return the base recipients interface
		*ppvObject = (IMailMsgRecipientsBase *)this;
		AddRef();
	}
	else if (iid == IID_IMailMsgPropertyReplication)
	{
		// Return the base recipients interface
		*ppvObject = (IMailMsgPropertyReplication *)this;
		AddRef();
	}
	else
		return(E_NOINTERFACE);

	return(S_OK);
}

ULONG CMailMsgRecipientsAdd::AddRef()
{
	return(InterlockedIncrement(&m_ulRefCount));
}

ULONG CMailMsgRecipientsAdd::Release()
{
	LONG	lRefCount = InterlockedDecrement(&m_ulRefCount);
	if (lRefCount == 0)
	{
		delete this;
	}
	return(lRefCount);
}

HRESULT CMailMsgRecipientsAdd::AddPrimaryOrSecondary(
			DWORD					dwCount,
			LPCSTR					*ppszNames,
			DWORD					*pdwPropIDs,
			DWORD   				*pdwIndex,
			IMailMsgRecipientsBase	*pFrom,
			DWORD					dwFrom,
			BOOL					fPrimary
			)
{
	HRESULT hrRes = S_OK;
	BOOL	fLockTaken = FALSE;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::AddPrimaryOrSecondary");

	if (dwCount)
	{
		if (!ppszNames || !pdwPropIDs || !pdwIndex)
			return(E_POINTER);
	}

	// If we have a count of zero, by default, we will copy all the
	// names of the source recipient to the new recipient. However,
	// if a source recipient is not specified, then this is an error
	if (dwCount || pFrom)
	{
		DWORD	i;
		BOOL	rgfAllocated[MAX_COLLISION_HASH_KEYS];
		DWORD	rgPropIDs[MAX_COLLISION_HASH_KEYS];
		LPBYTE	rgszNames[MAX_COLLISION_HASH_KEYS];

		for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
			rgfAllocated[i] = FALSE;

		CMemoryAccess	cmaAccess;

		if (!dwCount)
		{
			DWORD	dwPropID;
			DWORD	dwLength;
			BYTE	pBuffer[ADD_DEFAULT_RECIPIENT_NAME_BUFFER_SIZE];
			LPBYTE	pNameStart;
			DWORD	dwRemaining		= ADD_DEFAULT_RECIPIENT_NAME_BUFFER_SIZE;

			ppszNames = (LPCSTR*)rgszNames;
			pdwPropIDs = rgPropIDs;
			pNameStart = pBuffer;

			// OK, copy the default names ...
			for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
			{
				rgfAllocated[i] = FALSE;
				dwPropID = rgDefaultAddressTypes[i];
				hrRes = pFrom->GetProperty(
							dwFrom,
							dwPropID,
							dwRemaining,
							&dwLength,
							pNameStart);
				if (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
				{
					// Insufficient buffer, allocate and retry
					hrRes = cmaAccess.AllocBlock(
								(LPVOID *)&(rgszNames[dwCount]),
								dwLength);
					if (SUCCEEDED(hrRes))
					{
						hrRes = pFrom->GetProperty(
									dwFrom,
									dwPropID,
									dwLength,
									&dwLength,
									rgszNames[dwCount]);
						rgfAllocated[dwCount] = TRUE;
					}
				}
				else if (SUCCEEDED(hrRes))
				{
					_ASSERT(dwRemaining >= dwLength);
					rgszNames[dwCount] = pNameStart;
					pNameStart += dwLength;
					dwRemaining -= dwLength;
				}

				if (SUCCEEDED(hrRes))
				{
					// OK, got a name, now set the prop ID and
					// bump the count
					rgPropIDs[dwCount] = dwPropID;
					dwCount++;
				}
				else if (hrRes == STG_E_UNKNOWN)
					hrRes = S_OK;
                else
                {
                    ErrorTrace((LPARAM)this, "Error in GetProperty, hr=%08x", hrRes);
                }
			}
		}

		if (SUCCEEDED(hrRes))
		{
			if (dwCount)
			{
				_ASSERT(ppszNames);
				_ASSERT(pdwPropIDs);

				m_Hash.Lock();
				fLockTaken = TRUE;
				if (fPrimary)
				{
					hrRes = m_Hash.AddPrimary(
									dwCount,
									ppszNames,
									pdwPropIDs,
									pdwIndex);
				}
				else
				{
					hrRes = m_Hash.AddSecondary(
									dwCount,
									ppszNames,
									pdwPropIDs,
									pdwIndex);
				}
			}
			else
			{
				ErrorTrace((LPARAM)this, "No recipient names specified or an error occurred");
				hrRes = E_FAIL;
			}
		}

		// Free any allocated memory
		for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
			if (rgfAllocated[i])
			{
				HRESULT	myRes;
				myRes = cmaAccess.FreeBlock((LPVOID)rgszNames[i]);
				_ASSERT(SUCCEEDED(myRes));
			}
	}
	else
	{
		ErrorTrace((LPARAM)this, "No recipient names specified, and no source to copy from");
		hrRes = E_INVALIDARG;
	}

	if (SUCCEEDED(hrRes) && pFrom)
	{
		HRESULT						hrRep;
		IMailMsgPropertyReplication	*pReplication = NULL;

		// Copy the properties over
		hrRep = pFrom->QueryInterface(
					IID_IMailMsgPropertyReplication,
					(LPVOID *)&pReplication);
		if (SUCCEEDED(hrRep))
		{
			// Copy all properties, be careful not to overwrite anything
			// that we just set.
			hrRep = pReplication->CopyTo(
					dwFrom,
					(IMailMsgRecipientsBase *)this,
					*pdwIndex,
					dwCount,
					pdwPropIDs);

			// Done with the replication interface
			pReplication->Release();
		}

		// Remove the recipient if we fail here
		if (FAILED(hrRep))
		{
			HRESULT	myRes =	m_Hash.RemoveRecipient(*pdwIndex);
			_ASSERT(SUCCEEDED(myRes));

			// Return this error instead
			hrRes = hrRep;
		}
	}

	if (fLockTaken)
		m_Hash.Unlock();

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CMailMsgRecipientsAdd::AddPrimary(
			DWORD					dwCount,
			LPCSTR					*ppszNames,
			DWORD					*pdwPropIDs,
			DWORD   				*pdwIndex,
			IMailMsgRecipientsBase	*pFrom,
			DWORD					dwFrom
			)
{
	HRESULT hrRes = S_OK;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::AddPrimary");

	hrRes = AddPrimaryOrSecondary(
				dwCount,
				ppszNames,
				pdwPropIDs,
				pdwIndex,
				pFrom,
				dwFrom,
				TRUE);

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CMailMsgRecipientsAdd::AddSecondary(
			DWORD					dwCount,
			LPCSTR					*ppszNames,
			DWORD					*pdwPropIDs,
			DWORD   				*pdwIndex,
			IMailMsgRecipientsBase	*pFrom,
			DWORD					dwFrom
			)
{
	HRESULT hrRes = S_OK;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::AddSecondary");

	hrRes = AddPrimaryOrSecondary(
				dwCount,
				ppszNames,
				pdwPropIDs,
				pdwIndex,
				pFrom,
				dwFrom,
				FALSE);

	TraceFunctLeave();
	return(hrRes);
}

/***************************************************************************/
//
// Implementation of CMailMsgRecipientsAdd::CMailMsgRecipientsPropertyBase
//


HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::Count(
			DWORD	*pdwCount
			)
{
	HRESULT hrRes;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::Count");

	if (!pdwCount)
		return(E_POINTER);
	hrRes = m_Hash.GetRecipientCount(pdwCount);

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::Item(
			DWORD	dwIndex,
			DWORD	dwWhichName,
			DWORD	cchLength,
			LPSTR	pszName
			)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem = NULL;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::Item");

	// Get a pointer to the recipient from the index
	hrRes = m_Hash.GetRecipient(dwIndex, &pItem);

	if (FAILED(hrRes))
		return(E_POINTER);

	if (!pItem || !pszName)
		return(E_POINTER);

	if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
		return E_POINTER;

	if (dwWhichName >= MAX_COLLISION_HASH_KEYS)
		return(E_INVALIDARG);

	// Copy the name over
	if (!pItem->rpiRecipient.faNameOffset[dwWhichName])
		return(STG_E_UNKNOWN);
	if (cchLength < pItem->rpiRecipient.dwNameLength[dwWhichName])
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
	MoveMemory(pszName,
				(LPVOID)((pItem->rpiRecipient).faNameOffset[dwWhichName]),
				pItem->rpiRecipient.dwNameLength[dwWhichName]);

	TraceFunctLeave();
	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::PutProperty(
			DWORD	dwIndex,
			DWORD	dwPropID,
			DWORD	cbLength,
			LPBYTE	pbValue
			)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem = NULL;
	LPRECIPIENTS_PROPERTY_ITEM		pRcptItem;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::PutProperty");

	// Get a pointer to the recipient from the index
	hrRes = m_Hash.GetRecipient(dwIndex, &pItem);

	if (FAILED(hrRes))
		return(E_POINTER);

	if (!pItem || !pbValue)
		return(E_POINTER);

	if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
		return E_POINTER;

	pRcptItem = &(pItem->rpiRecipient);
	_ASSERT(pRcptItem);

	// Handle special properties first
	hrRes = m_SpecialPropertyTable.PutProperty(
				(PROP_ID)dwPropID,
				(LPVOID)pRcptItem,
				NULL,
				PT_NONE,
				cbLength,
				pbValue,
				TRUE);
	if (SUCCEEDED(hrRes) && (hrRes != S_OK))
	{
		// Call the derived generic method
		hrRes = CMailMsgRecipientsPropertyBase::PutProperty(
					m_pBlockManager,
					pRcptItem,
					dwPropID,
					cbLength,
					pbValue);
	}

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::GetProperty(
			DWORD	dwIndex,
			DWORD	dwPropID,
			DWORD	cbLength,
			DWORD	*pcbLength,
			LPBYTE	pbValue
			)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem = NULL;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::GetProperty");

	// Get a pointer to the recipient from the index
	hrRes = m_Hash.GetRecipient(dwIndex, &pItem);

	if (FAILED(hrRes))
		return(E_POINTER);

	hrRes = GetPropertyInternal(
				pItem,
				dwPropID,
				cbLength,
				pcbLength,
				pbValue);

	return hrRes;
}


HRESULT CMailMsgRecipientsAdd::GetPropertyInternal(
			LPRECIPIENTS_PROPERTY_ITEM_EX	pItem,
			DWORD	dwPropID,
			DWORD	cbLength,
			DWORD	*pcbLength,
			LPBYTE	pbValue
			)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM		pRcptItem;

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::GetProperty");

	if (!pItem || !pcbLength || !pbValue)
		return(E_POINTER);

	if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
		return E_POINTER;

	*pcbLength = 0;

	pRcptItem = &(pItem->rpiRecipient);
	_ASSERT(pRcptItem);

	// Special properties are optimized
	// Handle special properties first
	hrRes = m_SpecialPropertyTable.GetProperty(
				(PROP_ID)dwPropID,
				(LPVOID)pRcptItem,
				NULL,
				PT_NONE,
				cbLength,
				pcbLength,
				pbValue,
				TRUE);
	if (SUCCEEDED(hrRes) && (hrRes != S_OK))
	{
		// Call the derived generic method
		hrRes = CMailMsgRecipientsPropertyBase::GetProperty(
					m_pBlockManager,
					pRcptItem,
					dwPropID,
					cbLength,
					pcbLength,
					pbValue);
	}

	TraceFunctLeave();
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::CopyTo(
			DWORD					dwSourceRecipientIndex,
			IMailMsgRecipientsBase	*pTargetRecipientList,
			DWORD					dwTargetRecipientIndex,
			DWORD					dwExemptCount,
			DWORD					*pdwExemptPropIdList
			)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem = NULL;
	LPRECIPIENTS_PROPERTY_ITEM		pRcptItem;
	RECIPIENT_PROPERTY_ITEM			piRcptItem;
	DWORD							dwTempFlags;
	DWORD							dwIndex;
	DWORD							dwExempt;
	DWORD							*pdwExemptId;
	BOOL							fExempt;

	BYTE							rgbCopyBuffer[4096];
	DWORD							dwBufferSize = sizeof(rgbCopyBuffer);
	DWORD							dwSizeRead;
	LPBYTE							pBuffer = rgbCopyBuffer;

	if (!pTargetRecipientList)
		return(E_POINTER);
	if (dwExemptCount)
	{
		if (!pdwExemptPropIdList)
			return(E_POINTER);
	}

	TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::CopyTo");

	// Get a pointer to the recipient from the index
	hrRes = m_Hash.GetRecipient(dwSourceRecipientIndex, &pItem);

	if (FAILED(hrRes))
		return(E_POINTER);

	if (!pItem)
		return E_POINTER;

	if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
		return E_POINTER;

	pRcptItem = &(pItem->rpiRecipient);

	// Iteratively copy all properties from the source to the target, avoiding
	// those in the exempt list note that special name properties are not copied.

	// First, copy the recipient flags as a special property
	dwTempFlags = pRcptItem->dwFlags &
		~(FLAG_RECIPIENT_DO_NOT_DELIVER | FLAG_RECIPIENT_NO_NAME_COLLISIONS);
	DebugTrace((LPARAM)this, "Copying recipient flags (%08x)", dwTempFlags);
	hrRes = pTargetRecipientList->PutProperty(
				dwTargetRecipientIndex,
				IMMPID_RP_RECIPIENT_FLAGS,
				sizeof(DWORD),
				(LPBYTE)&dwTempFlags);
	if (FAILED(hrRes))
	{
		ErrorTrace((LPARAM)this, "Failed to copy recipient flags (%08x)", hrRes);
		TraceFunctLeaveEx((LPARAM)this);
		return(hrRes);
	}

	// Instantiate a property table for the recipient properties
	LPPROPERTY_TABLE_INSTANCE	pInstance =
									&(pRcptItem->ptiInstanceInfo);
	CPropertyTable				ptProperties(
									PTT_PROPERTY_TABLE,
									RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
									m_pBlockManager,
									pInstance,
									CMailMsgRecipientsPropertyBase::CompareProperty,
									CMailMsgRecipientsPropertyBase::s_pWellKnownProperties,
									CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties
									);

	dwIndex = 0;
	do
	{
		// Get the recipient property using an atomic operation
		hrRes = ptProperties.GetPropertyItemAndValueUsingIndex(
							dwIndex,
							(LPPROPERTY_ITEM)&piRcptItem,
							dwBufferSize,
							&dwSizeRead,
							pBuffer);
		if (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
		{
			// Insufficient buffer, try a bigger buffer
			do { dwBufferSize <<= 1; } while (dwBufferSize < piRcptItem.piItem.dwSize);
			pBuffer = new BYTE [dwBufferSize];
			if (!pBuffer)
			{
				hrRes = E_OUTOFMEMORY;
				ErrorTrace((LPARAM)this,
							"Unable to temporarily allocate %u bytes, HRESULT = %08x",
							dwBufferSize, hrRes);
				goto Cleanup;
			}

			// Read it with the proper buffer
			hrRes = m_pBlockManager->ReadMemory(
						pBuffer,
						piRcptItem.piItem.faOffset,
						piRcptItem.piItem.dwSize,
						&dwSizeRead,
						NULL);
		}

		DebugTrace((LPARAM)this,
					"Read: [%u] PropID = %u, length = %u, HRESULT = %08x",
					dwIndex,
					piRcptItem.idProp,
					piRcptItem.piItem.dwSize,
					hrRes);

		// See if this is an exempt property
		for (dwExempt = 0,
			 pdwExemptId = pdwExemptPropIdList,
			 fExempt = FALSE;
			 dwExempt < dwExemptCount;
			 dwExempt++,
			 pdwExemptId++)
			if (piRcptItem.idProp == *pdwExemptId)
			{
				DebugTrace((LPARAM)this, "Property exempted");
				fExempt = TRUE;
				break;
			}

		if (SUCCEEDED(hrRes) && !fExempt)
		{
			// Write it out the the target object
			hrRes = pTargetRecipientList->PutProperty(
						dwTargetRecipientIndex,
						piRcptItem.idProp,
						piRcptItem.piItem.dwSize,
						pBuffer);

			DebugTrace((LPARAM)this, "Write: HRESULT = %08x", hrRes);
		}

		// Next
		dwIndex++;

	} while (SUCCEEDED(hrRes));

	// Correct the error code
	if (hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		hrRes = S_OK;

Cleanup:

	if (pBuffer && pBuffer != rgbCopyBuffer)
		delete [] pBuffer;

	TraceFunctLeave();
	return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmmutils.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmutils.cpp

Abstract:

	This module contains the implementation of various utilities

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/11/98	created

--*/

//#define WIN32_LEAN_AND_MEAN
#include "atq.h"

#include "dbgtrace.h"
#include "synconst.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmmutils.h"
#include "cmailmsg.h"

// RFC 821 parser
#include "addr821.hxx"

// =================================================================
// Private Definitions
//

//
// Define which PROP_ID correspondes to which name index
//
PROP_ID	g_PropIdToNameIndexMapping[MAX_COLLISION_HASH_KEYS] =
{
	IMMPID_RP_ADDRESS_SMTP,
	IMMPID_RP_ADDRESS_X400,
	IMMPID_RP_ADDRESS_X500,
	IMMPID_RP_LEGACY_EX_DN,
    IMMPID_RP_ADDRESS_OTHER
};



// =================================================================
// Static declarations
//

// Per-recipient property table instance info
static const PROPERTY_TABLE_INSTANCE s_ptiDefaultRecipientInstanceInfo =
{
	RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
	INVALID_FLAT_ADDRESS,
	RECIPIENT_PROPERTY_TABLE_FRAGMENT_SIZE,
	RECIPIENT_PROPERTY_ITEM_BITS,
	RECIPIENT_PROPERTY_ITEM_SIZE,
	0,
	INVALID_FLAT_ADDRESS
};


// =================================================================
// Implementation of CRecipientsHash
//

CRecipientsHash::CRecipientsHash()
{
	m_dwDomainCount = 0;
	m_dwDomainNameSize = 0;
	m_dwRecipientCount = 0;
	m_dwRecipientNameSize = 0;
#ifdef DEBUG
	m_dwAllocated = 0;
#endif
    m_pListHead = NULL;
    m_pvMapContext 	= NULL;
}

CRecipientsHash::~CRecipientsHash()
{
	Release();
}

HRESULT CRecipientsHash::ReleaseDomainList()
{
	DWORD				dwBucket;
	LPDOMAIN_LIST_ENTRY	pItem, pNextItem;

	TraceFunctEnter("CRecipientsHash::CloseDomainContext");

    m_hashDomains.Clear();

#ifdef DEADCODE
	for (dwBucket = 0; dwBucket < DOMAIN_HASH_BUCKETS; dwBucket++)
	{
		pItem = m_rgpDomains[dwBucket];
		while (pItem)
		{
			// OK, delete the node
			pNextItem = pItem->pNextDomain;
			m_cmaAccess.FreeBlock((LPVOID)pItem);
			pItem = pNextItem;
		}

		// Void each bucket as we go along ...
		m_rgpDomains[dwBucket] = NULL;
	}
#endif

	TraceFunctLeave();
	return(S_OK);
}

HRESULT CRecipientsHash::Release()
{
	HRESULT							hrRes, hrResult = S_OK;
	DWORD							dwCount = 0;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem, pNextItem;

	TraceFunctEnterEx((LPARAM)this, "CRecipientsHash::Release");

	// This algorithm first release any domain list resources, then
	// releases each recipient node by walking the single linked
	// list of all allocated nodes.

	// First, release all resources affiliated with the domain list
	ReleaseDomainList();

    // Clear out our hash tables
    m_hashEntries0.Clear();
    m_hashEntries1.Clear();
    m_hashEntries2.Clear();
    m_hashEntries3.Clear();
    m_hashEntries4.Clear();

	// Walk and release each recipient node
	hrResult = S_OK;
	pItem = m_pListHead;
	while (pItem)
	{
		pNextItem = pItem->pNextInList;
        // there should be one reference always for the list
        _ASSERT(pItem->m_cRefs == 1);
		hrRes = m_cmaAccess.FreeBlock((LPVOID)pItem);
		_ASSERT(SUCCEEDED(hrRes));
		if (!SUCCEEDED(hrRes))
			hrResult = hrRes;

		dwCount++;
		pItem = pNextItem;
	}
#ifdef DEBUG
	_ASSERT(dwCount == m_dwAllocated);
	m_dwAllocated = 0;
#endif
	m_pListHead = NULL;

	TraceFunctLeave();
	return(hrResult);
}

HRESULT CRecipientsHash::AllocateAndPrepareRecipientsItem(
			DWORD							dwCount,
			DWORD							*pdwMappedIndices,
			LPCSTR							*rgszName,
			PROP_ID							*pidProp,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppItem
			)
{
	HRESULT							hrRes = S_OK;
	DWORD							dwTotal;
	LPBYTE							pbTemp;
	LPCSTR							szName;
	DWORD							dwNameIndex;
	DWORD							*pdwLength;
	DWORD							rgdwLength[MAX_COLLISION_HASH_KEYS];
	BOOL							fIsInitialized[MAX_COLLISION_HASH_KEYS];
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem = NULL;
	LPRECIPIENTS_PROPERTY_ITEM		pRcptItem = NULL;
	DWORD							i;

	if (!ppItem) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::AllocateAndPrepareRecipientsItem");

	// The count cannot be zero, the caller must make sure of that!
	if (!dwCount)
	{
		return(E_INVALIDARG);
	}

	// Make sure we have at least one good name
	dwTotal = sizeof(RECIPIENTS_PROPERTY_ITEM_EX);
	hrRes = E_FAIL;
	for (i = 0; i < dwCount; i++)
	{
		if (rgszName[i])
		{
            /*
             * -- no longer need to compute the hash here, its done
             * in lkhash -- awetmore
			 * // Generate the hash, this will convert everything to lowe case
			 * rgdwHash[i] = GenerateHash(rgszName[i], rgdwLength + i);
             */

            rgdwLength[i] = (strlen(rgszName[i]) + 1);
			dwTotal += rgdwLength[i];
			hrRes = S_OK;
		}
	}
	if (!SUCCEEDED(hrRes))
	{
		// We don't
		return(E_INVALIDARG);
	}

	hrRes = m_cmaAccess.AllocBlock(
					(LPVOID *)&pItem,
					dwTotal);
	if (!SUCCEEDED(hrRes))
		return(hrRes);

	// OK, got a block, now fill in the essential info
	pRcptItem = &(pItem->rpiRecipient);
	ZeroMemory(pItem, sizeof(RECIPIENTS_PROPERTY_ITEM_EX));
    // start with one reference for the recipient list
    pItem->m_cRefs = 1;
	pItem->dwSignature = RECIPIENTS_PROPERTY_ITEM_EX_SIG;
	MoveMemory(&(pRcptItem->ptiInstanceInfo),
				&s_ptiDefaultRecipientInstanceInfo,
				sizeof(PROPERTY_TABLE_INSTANCE));

	// Move past the record, and append in the strings
	pbTemp = ((LPBYTE)pItem) + sizeof(RECIPIENTS_PROPERTY_ITEM_EX);

	//
	// We now populate the recipient item, taking care to also remap
	// the incoming names into the proper PROP_ID order, since the prop
	// IDs can come in any order. We must reorder the names into our
	// internal order. Any unsupported names will be promptly rejected.
	//
	for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
		fIsInitialized[i] = FALSE;

	pdwLength = rgdwLength;
	for (i = 0; i < dwCount; i++)
	{
		// We gotta figure out which slot this actually goes to
		for (dwNameIndex = 0; dwNameIndex < MAX_COLLISION_HASH_KEYS; dwNameIndex++)
			if (g_PropIdToNameIndexMapping[dwNameIndex] == *pidProp)
				break;
		if (dwNameIndex == MAX_COLLISION_HASH_KEYS)
		{
			// The prop id is not found, so we return error
			hrRes = E_INVALIDARG;
			goto Cleanup;
		}

		// Make sure the prop ID is not already taken (we want to prevent
		// duplicates since it creates a loop in the linked list ...
		if (pRcptItem->idName[dwNameIndex] != 0)
		{
			// Duplicate, reject flat out
			hrRes = E_INVALIDARG;
			goto Cleanup;
		}

		// Save the mapped indices
		pdwMappedIndices[i] = dwNameIndex;

		szName = *rgszName++;
		if (szName && *szName)
		{
			pRcptItem->faNameOffset[dwNameIndex] = (FLAT_ADDRESS)(DWORD_PTR)pbTemp;
			pRcptItem->dwNameLength[dwNameIndex] = *pdwLength;
			pRcptItem->idName[dwNameIndex] = *pidProp;
			DebugTrace((LPARAM)this, "Inserting string %u <%s>, prop ID %u",
						dwNameIndex, szName, *pidProp);

			// Copy the name to its place
			strcpy((char *) pbTemp, szName);
			pbTemp += *pdwLength;

			// OK, this is initialized
			fIsInitialized[dwNameIndex] = TRUE;
		}

		// Next
		pdwLength++;
		pidProp++;
	}

	// Invalidate entries that we haven't initialized
	for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
		if (!fIsInitialized[i])
		{
			pRcptItem->faNameOffset[i] = (FLAT_ADDRESS)NULL;
			pRcptItem->dwNameLength[i] = 0;
			pRcptItem->idName[i] = 0;
		}

    // build up the hash keys
    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
        pItem->rgHashKeys[i].pbKey = (BYTE *) pRcptItem->faNameOffset[i];
        pItem->rgHashKeys[i].cKey = pRcptItem->dwNameLength[i];
    }

	*ppItem = pItem;
    m_dwAllocated++;

	TraceFunctLeave();
	return(S_OK);

Cleanup:

	m_cmaAccess.FreeBlock(pItem);
	return(hrRes);
}

inline static HRESULT MapLKtoHR(LK_RETCODE rc ) {
    switch (rc) {
        case LK_SUCCESS:
            return S_OK;
        case LK_UNUSABLE:
            return HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT);
        case LK_ALLOC_FAIL:
            return E_OUTOFMEMORY;
        case LK_BAD_ITERATOR:
            return E_INVALIDARG;
        case LK_BAD_RECORD:
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        case LK_KEY_EXISTS:
            return HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
        case LK_NO_SUCH_KEY:
            return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        case LK_NO_MORE_ELEMENTS:
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        default:
            _ASSERT(FALSE);
            return E_FAIL;
    }
}

HRESULT CRecipientsHash::InsertHashRecord(
                DWORD                           dwIndex,
                LPRECIPIENTS_PROPERTY_ITEM_EX   pRecipientItem,
                bool                            fOverwrite)
{
    HRESULT hr = S_OK;
    LK_RETCODE rc = LK_SUCCESS;

    switch (dwIndex) {
        case 0:
            rc = m_hashEntries0.InsertRecord(pRecipientItem, fOverwrite);
            break;
        case 1:
            rc = m_hashEntries1.InsertRecord(pRecipientItem, fOverwrite);
            break;
        case 2:
            rc = m_hashEntries2.InsertRecord(pRecipientItem, fOverwrite);
            break;
        case 3:
            rc = m_hashEntries3.InsertRecord(pRecipientItem, fOverwrite);
            break;
        case 4:
            rc = m_hashEntries4.InsertRecord(pRecipientItem, fOverwrite);
            break;
        default:
            _ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    if (rc != LK_SUCCESS) hr = MapLKtoHR(rc);

    return hr;
}

HRESULT CRecipientsHash::FindHashRecord(
                DWORD                               dwIndex,
                RECIPIENTS_PROPERTY_ITEM_HASHKEY    *pKey,
                LPRECIPIENTS_PROPERTY_ITEM_EX       *ppRecipientItem)
{
    HRESULT hr = S_OK;
    LK_RETCODE rc = LK_SUCCESS;

    switch (dwIndex) {
        case 0:
            rc = m_hashEntries0.FindKey(pKey, ppRecipientItem);
            break;
        case 1:
            rc = m_hashEntries1.FindKey(pKey, ppRecipientItem);
            break;
        case 2:
            rc = m_hashEntries2.FindKey(pKey, ppRecipientItem);
            break;
        case 3:
            rc = m_hashEntries3.FindKey(pKey, ppRecipientItem);
            break;
        case 4:
            rc = m_hashEntries4.FindKey(pKey, ppRecipientItem);
            break;
        default:
            _ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    if (rc != LK_SUCCESS) hr = MapLKtoHR(rc);

    return hr;
}

HRESULT CRecipientsHash::DeleteHashRecord(
                DWORD                           dwIndex,
                LPRECIPIENTS_PROPERTY_ITEM_EX   pRecipientItem)
{
    HRESULT hr = S_OK;
    LK_RETCODE rc = LK_SUCCESS;

    switch (dwIndex) {
        case 0:
            rc = m_hashEntries0.DeleteRecord(pRecipientItem);
            break;
        case 1:
            rc = m_hashEntries1.DeleteRecord(pRecipientItem);
            break;
        case 2:
            rc = m_hashEntries2.DeleteRecord(pRecipientItem);
            break;
        case 3:
            rc = m_hashEntries3.DeleteRecord(pRecipientItem);
            break;
        case 4:
            rc = m_hashEntries4.DeleteRecord(pRecipientItem);
            break;
        default:
            _ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    if (rc != LK_SUCCESS) hr = MapLKtoHR(rc);

    return hr;
}

HRESULT CRecipientsHash::AddRecipient(
				DWORD		dwCount,
				LPCSTR		*ppszNames,
				PROP_ID		*pidProp,
				DWORD		*pdwIndex,
                bool    	fPrimary
				)
{
    TraceFunctEnter("CRecipientsHash::AddRecipient");

	DWORD							rgdwNameIndex[MAX_COLLISION_HASH_KEYS];
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem = NULL;
	DWORD							dwNameIndex;
	DWORD							i;
	BOOL							fCollided = FALSE;
	// These are used to support NO_NAME_COLLISIONS.  If we run into a conflict
	// where the conflicting record has NO_NAME_COLLISIONS set then we will
	// set the corresponding flag in rgfOverwriteConflict to TRUE.
	// fOverwriteConflict is the same as ORing every element in
	// rgfOverwriteConflict.
	BOOL							fOverwriteConflict = FALSE;
    BOOL                            rgfOverwriteConflict[MAX_COLLISION_HASH_KEYS];


	if (!dwCount || (dwCount > MAX_COLLISION_HASH_KEYS))
	{
        TraceFunctLeave();
		return(E_INVALIDARG);
	}

	// Allocate and setup the recipient record
	hrRes = AllocateAndPrepareRecipientsItem(
					dwCount,
					rgdwNameIndex,
					ppszNames,
					pidProp,
					&pItem);
	if (!SUCCEEDED(hrRes)) {
        TraceFunctLeave();
		return(hrRes);
    }

    // do a lookup to see if there is another recipient with the
    // same record
    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
        rgfOverwriteConflict[i] = FALSE;
		if (pItem->rpiRecipient.faNameOffset[i] != 0) {
			LPRECIPIENTS_PROPERTY_ITEM_EX pConflictingItem = NULL;
			hrRes = FindHashRecord(i, &(pItem->rgHashKeys[i]), &pConflictingItem);
			if (hrRes == S_OK) {
	            _ASSERT(pConflictingItem != NULL);
				fCollided = TRUE;
				if (fPrimary) {
					// we have to do this so that we don't find the
                    // colliding recipient in the list of recipients.
					pConflictingItem->rpiRecipient.dwFlags |=
                        FLAG_RECIPIENT_DO_NOT_DELIVER;
				} else if (pConflictingItem->rpiRecipient.dwFlags &
                           FLAG_RECIPIENT_NO_NAME_COLLISIONS)
                {
                    // this recipient is set to allow us to overwrite it
                    rgfOverwriteConflict[i] = TRUE;
					fOverwriteConflict = TRUE;
                }

				// update the conflicting item's reference count
				CRecipientsHashTable<0>::AddRefRecord(pConflictingItem, -1);
			} else if (hrRes != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
                // we can return another error when we are low on memory
                m_cmaAccess.FreeBlock(pItem);
                m_dwAllocated--;
                DebugTrace((LPARAM) this, "FindHashRecord returned 0x%x", hrRes);
                TraceFunctLeave();
		        return(hrRes);
            }
		}
    }

	// insert this item into the hash tables if allowed
    if (fPrimary || !fCollided || fOverwriteConflict) {
        for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
			if (pItem->rpiRecipient.faNameOffset[i] != 0) {
		        hrRes = InsertHashRecord(i, pItem,
                                         (fPrimary || rgfOverwriteConflict[i]));
			    if (FAILED(hrRes)) {
                    m_cmaAccess.FreeBlock(pItem);
                    m_dwAllocated--;
				    DebugTrace((DWORD_PTR) this,
					           "InsertHashRecord failed with 0x%x",
						       hrRes);
					TraceFunctLeave();
					return hrRes;
				}
			}
        }
    	// Add it to the recipients list
    	pItem->pNextInList = m_pListHead;
    	m_pListHead = pItem;

		if (!fCollided) {
			// update our counter
			m_dwRecipientCount++;
		}

		// Append this recipient to the index-recipient ptr map
        m_rwLockQuickList.ExclusiveLock();
		hrRes = m_qlMap.HrAppendItem(pItem, pdwIndex);
        m_rwLockQuickList.ExclusiveUnlock();
		if (FAILED(hrRes)) {
            m_cmaAccess.FreeBlock(pItem);
            m_dwAllocated--;
			DebugTrace((DWORD_PTR) this,
						"HrAppendItem failed with 0x%x",
						hrRes);
			TraceFunctLeave();
			return hrRes;
		}

		// Obfuscate the index so that it is not used as an index
		*pdwIndex = ObfuscateIndex(*pdwIndex);

    } else if (fCollided) {
        // free up the memory that we just allocated
        m_cmaAccess.FreeBlock(pItem);
        m_dwAllocated--;
        *pdwIndex = 0;
    }

    // four return code:
    // fPrimary && fCollided -> S_FALSE
    // !fPrimary && fCollided && !fOverwriteConflict -> MAILMSG_E_DUPLICATE
	// !fPrimary && fCollided && fOverwriteConflict -> S_OK
    // !fCollided -> S_OK
    TraceFunctLeave();
	return(fCollided ? (fPrimary ? S_FALSE : (fOverwriteConflict ? S_OK : MAILMSG_E_DUPLICATE)) : S_OK);
}

HRESULT CRecipientsHash::RemoveRecipient(
			DWORD		dwIndex
			)
{
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem 		= NULL;
	HRESULT							hrRes = S_OK;

	// Recover index that we obfuscated before handing it to the client
	dwIndex = RecoverIndex(dwIndex);

	// Get a pointer to the recipient from the passed in index
    m_rwLockQuickList.ShareLock();
    pItem = (LPRECIPIENTS_PROPERTY_ITEM_EX)m_qlMap.pvGetItem(dwIndex, &m_pvMapContext);
    m_rwLockQuickList.ShareUnlock();

	if (!pItem)
		return(E_POINTER);

	if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
		return(E_POINTER);

	// mark it as don't deliver and no name collisions
	pItem->rpiRecipient.dwFlags |= FLAG_RECIPIENT_DO_NOT_DELIVER;
	pItem->rpiRecipient.dwFlags |= FLAG_RECIPIENT_NO_NAME_COLLISIONS;

    // Remove this entry from the hashtable
    DWORD i;
    HRESULT hr;
    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
        LPCSTR szKey = (LPCSTR) pItem->rpiRecipient.faNameOffset[i];
        if (szKey) {
            hr = DeleteHashRecord(i, pItem);
            // this should never fail
            _ASSERT(SUCCEEDED(hr));
        }
    }

    //
    // Why we don't remove the recipient from the QuickList map:
    //     m_rwLockQuickList.ExclusiveLock();
    //     pItem = (LPRECIPIENTS_PROPERTY_ITEM_EX)m_qlMap.pvDeleteItem(dwIndex, &m_pvMapContext);
    //     m_rwLockQuickList.ExclusiveUnlock();
    //
    // This changes the indexes we have already allocated, since CQuickList tries to
    // compact any unused entries in it's internal table.
    //

	return(S_OK);
}

HRESULT CRecipientsHash::GetRecipient(
			DWORD							dwIndex,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppRecipient
			)
{
	// Recover index that we obfuscated before handing it to the client
	dwIndex = RecoverIndex(dwIndex);

	// Get a pointer to the recipient from the passed in index
    m_rwLockQuickList.ShareLock();
    *ppRecipient = (LPRECIPIENTS_PROPERTY_ITEM_EX)m_qlMap.pvGetItem(dwIndex, &m_pvMapContext);
    m_rwLockQuickList.ShareUnlock();

   	if (!(*ppRecipient))
		return(E_POINTER);

	return(S_OK);
}

HRESULT CRecipientsHash::BuildDomainListFromHash(CMailMsgRecipientsAdd *pList)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem;
	DWORD							dwTemp;
	char							*pbDomain;
	static char						szDefaultDomain = '\0';

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::BuildDomainListFromHash");

	// This is strictly single-threaded
	m_rwLock.ExclusiveLock();

	// Destroy the domain list
	ReleaseDomainList();

	// Reset all counters
	m_dwDomainCount = 0;
	m_dwRecipientCount = 0;
	m_dwDomainNameSize = 0;

	// Walk the entire list of recipients, then for each recipient, if the
	// recipient has an SMTP address, we group it by domain, otherwise, we
	// just throw it into an "empty" domain
	pItem = m_pListHead;
	while (pItem)
	{
		// We will skip the item if it's marked as don't deliver
		if ((pItem->rpiRecipient.dwFlags & FLAG_RECIPIENT_DO_NOT_DELIVER) == 0)
		{
            // see if there is a domain property
            char szDomain[1024];
            char *pszDomain = szDomain;
            DWORD cDomain = sizeof(szDomain);

            do {
    		    hrRes = pList->GetPropertyInternal(pItem,
    					                   IMMPID_RP_DOMAIN,
    					                   cDomain,
    					                   &cDomain,
    					                   (BYTE *) pszDomain);
                if (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                    HRESULT hrAlloc;
                    // we should never reach this point twice in a row
                    _ASSERT(pszDomain == szDomain);
                    hrAlloc = m_cmaAccess.AllocBlock((LPVOID *) &pszDomain,
                                                     cDomain);
                    if (FAILED(hrAlloc)) {
                        hrRes = E_OUTOFMEMORY;
                        goto cleanup;
                    }
                }
            } while (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

			// We will group if it has an SMTP name
            if (SUCCEEDED(hrRes)) {
                pbDomain = pszDomain;
            } else if (pItem->rpiRecipient.faNameOffset[AT_SMTP]) {
				// We get the name, and then extract its domain
				DebugTrace((LPARAM)this, "  Name: %s",
					(LPBYTE)pItem->rpiRecipient.faNameOffset[AT_SMTP]);

				if (!Get821AddressDomain(
								(char *)pItem->rpiRecipient.faNameOffset[AT_SMTP],
								pItem->rpiRecipient.dwNameLength[AT_SMTP],
								&pbDomain))
				{
					// The address is invalid! This should not happen at this point
					_ASSERT(FALSE);
					ErrorTrace((LPARAM)this, "Failed to extract domain!");
					hrRes = HRESULT_FROM_WIN32(GetLastError());
                    // if we got here then there was no IMMPID_RP_DOMAIN
                    // record, so pszDomain shouldn't have been allocated
                    _ASSERT(pszDomain == szDomain);
					goto cleanup;
				}
                if (pbDomain == NULL) pbDomain = &szDefaultDomain;
			} else {
				// No SMTP name, we throuw it into our generic domain
				pbDomain = &szDefaultDomain;
			}

			// Got the domain, insert this item into the domain list
			DebugTrace((LPARAM)this, "  Domain: %s", pbDomain);
			hrRes = InsertRecipientIntoDomainList(pItem, (LPCSTR) pbDomain);

            // if we had to allocate memory to look up the domain record
            // then free it at this point
            if (pszDomain != szDomain) {
                m_cmaAccess.FreeBlock((LPVOID *) &pszDomain);
                pszDomain = szDomain;
            }

			if (!SUCCEEDED(hrRes))
			{
				ErrorTrace((LPARAM)this, "Failed to insert recipient into domain list!");
				goto cleanup;
			}

			// Also adjust the recipient name size counter
			for (dwTemp = 0; dwTemp < MAX_COLLISION_HASH_KEYS; dwTemp++)
				if (pItem->rpiRecipient.faNameOffset[dwTemp] != (FLAT_ADDRESS)NULL)
					m_dwRecipientNameSize += pItem->rpiRecipient.dwNameLength[dwTemp];
		}

		// OK, next item!
		pItem = pItem->pNextInList;
	}

cleanup:

	m_rwLock.ExclusiveUnlock();

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CRecipientsHash::GetDomainCount(
			DWORD					*pdwCount
			)
{
	if (!pdwCount) return E_POINTER;
	*pdwCount = m_dwDomainCount;
	return(S_OK);
}

HRESULT CRecipientsHash::GetRecipientCount(
			DWORD					*pdwCount
			)
{
	if (!pdwCount) return E_POINTER;
	*pdwCount = m_dwRecipientCount;
	return(S_OK);
}

HRESULT CRecipientsHash::GetDomainNameSize(
			DWORD					*pdwSize
			)
{
	if (!pdwSize) return E_POINTER;
	*pdwSize = m_dwDomainNameSize;
	return(S_OK);
}

HRESULT CRecipientsHash::GetRecipientNameSize(
			DWORD					*pdwSize
			)
{
	if (!pdwSize) return E_POINTER;
	*pdwSize = m_dwRecipientNameSize;
	return(S_OK);
}

HRESULT CRecipientsHash::GetFirstDomain(
			LPDOMAIN_ITEM_CONTEXT			pContext,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppFirstItem,
            LPDOMAIN_LIST_ENTRY             *ppDomainListEntry
			)
{
	HRESULT	hrRes = S_OK;

	if (!pContext) return E_POINTER;
	if (!ppFirstItem) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::GetFirstDomain");

    LK_RETCODE lkrc;

    lkrc = m_hashDomains.InitializeIterator(pContext);
    if (lkrc == LK_SUCCESS) {
        DOMAIN_LIST_ENTRY *pDomainListEntry = pContext->Record();
        _ASSERT(pDomainListEntry != NULL);
        if (ppDomainListEntry) *ppDomainListEntry = pDomainListEntry;
        *ppFirstItem = pDomainListEntry->pFirstDomainMember;
    } else {
        hrRes = MapLKtoHR(lkrc);
    	lkrc = m_hashDomains.CloseIterator(pContext);
    	_ASSERT(lkrc == LK_SUCCESS);
    }

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CRecipientsHash::GetNextDomain(
			LPDOMAIN_ITEM_CONTEXT			pContext,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppFirstItem,
            LPDOMAIN_LIST_ENTRY             *ppDomainListEntry
			)
{
	HRESULT				hrRes		= S_OK;
	DWORD				dwBucket	= 0;
	LPDOMAIN_LIST_ENTRY	pDomain;

	if (!pContext || !ppFirstItem) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::GetNextDomain");

    LK_RETCODE lkrc;
    lkrc = m_hashDomains.IncrementIterator(pContext);
    if (lkrc != LK_SUCCESS) {
        hrRes = MapLKtoHR(lkrc);
        lkrc = m_hashDomains.CloseIterator(pContext);
        _ASSERT(lkrc == LK_SUCCESS);
    } else {
        DOMAIN_LIST_ENTRY *pDomainListEntry = pContext->Record();
        _ASSERT(pDomainListEntry != NULL);
        if (ppDomainListEntry) *ppDomainListEntry = pDomainListEntry;
        *ppFirstItem = pDomainListEntry->pFirstDomainMember;
    }

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CRecipientsHash::CloseDomainContext(
			LPDOMAIN_ITEM_CONTEXT			pContext)
{
	HRESULT				hrRes		= S_OK;
	DWORD				dwBucket	= 0;
	LPDOMAIN_LIST_ENTRY	pDomain;

	if (!pContext) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::CloseDomainContext");

    LK_RETCODE lkrc;
    lkrc = m_hashDomains.CloseIterator(pContext);
    hrRes = MapLKtoHR(lkrc);

	TraceFunctLeave();
	return(hrRes);
}


// Method to compare two items
inline HRESULT CRecipientsHash::CompareEntries(
			DWORD							dwNameIndex,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pItem1,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pItem2
			)
{
	int	iRes;

	_ASSERT(dwNameIndex < MAX_COLLISION_HASH_KEYS);
	iRes = lstrcmpi((LPCSTR)(pItem1->rpiRecipient.faNameOffset[dwNameIndex]),
					(LPCSTR)(pItem2->rpiRecipient.faNameOffset[dwNameIndex]));
	return((!iRes)?MAILMSG_E_DUPLICATE:S_OK);
}


// Method to walk a sinlge hash chain and look for a collision
HRESULT CRecipientsHash::DetectCollision(
			DWORD							dwNameIndex,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pStartingItem,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pRecipientItem,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppCollisionItem
			)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem;

	_ASSERT(dwNameIndex < MAX_COLLISION_HASH_KEYS);
	_ASSERT(pRecipientItem);
	_ASSERT(ppCollisionItem);

	// If the name is not specified, we return no collision
	if (!pRecipientItem->rpiRecipient.dwNameLength[dwNameIndex])
		return(S_OK);

	// Initialize
	*ppCollisionItem = NULL;

	pItem = pStartingItem;
	while (pItem)
	{
		// Skip if it has the no name collisions bit set
		if (!(pItem->rpiRecipient.dwFlags & FLAG_RECIPIENT_NO_NAME_COLLISIONS))
		{
			// Loop until the end of the open chain
			hrRes = CompareEntries(dwNameIndex, pRecipientItem, pItem);
			if (!SUCCEEDED(hrRes))
			{
				_ASSERT(hrRes != E_FAIL);

				// The item is found, return the colliding item
				*ppCollisionItem = pItem;
				return(hrRes);
			}
		}

		// Next item in chain ...
		pItem = pItem->pNextHashEntry[dwNameIndex];
	}

	return(S_OK);
}

#ifdef DEADCODE
// Method to insert an entry into the hash bucket
inline HRESULT CRecipientsHash::InsertRecipientIntoHash(
			DWORD							dwCount,
			DWORD							*pdwNameIndex,
			DWORD							*rgdwBucket,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pRecipientItem
			)
{
	DWORD	dwNameIndex;
	DWORD	i;

	_ASSERT(pRecipientItem);

	for (i = 0; i < dwCount; i++)
		if (rgdwBucket[pdwNameIndex[i]] >= COLLISION_HASH_BUCKETS)
		{
			return(E_INVALIDARG);
		}

	for (i = 0; i < dwCount; i++)
	{
		dwNameIndex = pdwNameIndex[i];

		// Fill in the links in the item only if a name is specified
		if (pRecipientItem->rpiRecipient.faNameOffset[dwNameIndex] != (FLAT_ADDRESS)NULL)
		{
			// Hook up the new node
			pRecipientItem->pNextHashEntry[dwNameIndex] =
					m_rgEntries[rgdwBucket[dwNameIndex]].pFirstEntry[dwNameIndex];
			m_rgEntries[rgdwBucket[dwNameIndex]].pFirstEntry[dwNameIndex] = pRecipientItem;
		}
	}

	pRecipientItem->pNextInDomain = NULL;

	// Bump the counter
	m_dwRecipientCount++;

	// Add it to the recipients list
	pRecipientItem->pNextInList = m_pListHead;
	m_pListHead = pRecipientItem;

#ifdef DEBUG
	m_dwAllocated++;
#endif

	return(S_OK);
}
#endif

inline HRESULT CRecipientsHash::InsertRecipientIntoDomainList(
			LPRECIPIENTS_PROPERTY_ITEM_EX	pItem,
            LPCSTR                          szDomain
			)
{
	HRESULT						hrRes = S_OK;
	LPDOMAIN_LIST_ENTRY			pDomain;
    LK_RETCODE                  lkrc;
    DWORD                       dwDomainLength = lstrlen(szDomain) + 1;

	if (!pItem) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::InsertRecipientIntoDomainList");

    lkrc = m_hashDomains.FindKey(szDomain, &pDomain);
    if (lkrc == LK_SUCCESS) {
		// Found a match, insert it
		DebugTrace((LPARAM)this, "Inserting to existing domain record");
		pItem->pNextInDomain = pDomain->pFirstDomainMember;
		pDomain->pFirstDomainMember = pItem;

        // update our reference count
        CDomainHashTable::AddRefRecord(pDomain, -1);

		// Update stats.
		m_dwRecipientCount++;
		m_dwDomainNameSize += dwDomainLength;

		return(S_OK);
    }

	// No match, create a new domain item
	DebugTrace((LPARAM)this, "Creating new domain record for %s", szDomain);
	hrRes = m_cmaAccess.AllocBlock(
				(LPVOID *)&pDomain,
				sizeof(DOMAIN_LIST_ENTRY) + dwDomainLength);
	if (!SUCCEEDED(hrRes))
		return(hrRes);

	// fill in the domain record
	pItem->pNextInDomain = NULL;
    pDomain->m_cRefs = 0;
    pDomain->m_pcmaAccess = &m_cmaAccess;
	pDomain->pFirstDomainMember = pItem;
	pDomain->dwDomainNameLength = dwDomainLength;
	lstrcpy(pDomain->szDomainName, (LPCSTR)szDomain);

    // insert the new domain into the domain hash table
    lkrc = m_hashDomains.InsertRecord(pDomain, FALSE);
    if (lkrc != LK_SUCCESS) {
        DebugTrace((LPARAM) this,
                   "Inserting domain %s into m_hashDomains failed with %lu",
                   szDomain, lkrc);
        hrRes = MapLKtoHR(lkrc);
        m_cmaAccess.FreeBlock(pDomain);
        return hrRes;
    }

	// Hook up the recipient in the domain
	pItem->pNextInDomain = NULL;
	pDomain->pFirstDomainMember = pItem;
	pDomain->dwDomainNameLength = dwDomainLength;
	lstrcpy(pDomain->szDomainName, (LPCSTR)szDomain);

	// Update stats.
	m_dwDomainCount++;
	m_dwRecipientCount++;
	m_dwDomainNameSize += dwDomainLength;

	TraceFunctLeave();
	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmmutils.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmutils.h

Abstract:

	This module contains the definition of the support facilities for
	CMailMsg

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/11/98	created

--*/

#ifndef _CMMUTILS_H_
#define _CMMUTILS_H_

#include "rwnew.h"

#include "blockmgr.h"
#include "cmmtypes.h"
#include "lkrhash.h"
#include "crchash.h"

#include "qwiklist.h"

class CMailMsgRecipientsAdd;

// =================================================================
// Definitions
//

//
// Define a structure that constitutes to a node in the domain
// name list. Note this structure is only used as an overlay
// for pre-allocated block of memory that includes sufficient
// storage for the domain name. Never trust sizeof(DOMAIN_MEMBER_LIST)
//
typedef struct _DOMAIN_LIST_ENTRY
{
    long                            m_cRefs;            // reference count
    CMemoryAccess                   *m_pcmaAccess;      // memory allocator to
                                                        //   free with
	LPRECIPIENTS_PROPERTY_ITEM_EX	pFirstDomainMember; // Link to first in domain
	DWORD							dwDomainNameLength;	// Length of domain name
	char							szDomainName[1];	// Dummy marker for domain name

} DOMAIN_LIST_ENTRY, *LPDOMAIN_LIST_ENTRY;



//
// Define a structure that constitutes an entry in the hash table
//
typedef struct _COLLISION_HASH_ENTRY
{
	LPRECIPIENTS_PROPERTY_ITEM_EX	pFirstEntry[MAX_COLLISION_HASH_KEYS];
									// First entry in each hash

} COLLISION_HASH_ENTRY, *LPCOLLISION_HASH_ENTRY;

//
// We'll use a constant for the hash size for now ...
//
#define COLLISION_HASH_BUCKETS_BITS		8
#define COLLISION_HASH_BUCKETS			(1 << COLLISION_HASH_BUCKETS_BITS)
#define COLLISION_HASH_BUCKETS_MASK		(COLLISION_HASH_BUCKETS - 1)

#define DOMAIN_HASH_BUCKETS_BITS		3
#define DOMAIN_HASH_BUCKETS				(1 << DOMAIN_HASH_BUCKETS_BITS)
#define DOMAIN_HASH_BUCKETS_MASK		(DOMAIN_HASH_BUCKETS - 1)


// =================================================================
// Definitions
//

//
// There is one of these hash tables for each of the address types.
// The key for each table is the address and length of the address.
// The data is the RECIPIENTS_PROPERTY_ITEM_EX for this recipient.
//
template <int __iKey>
class CRecipientsHashTable :
    public CTypedHashTable<CRecipientsHashTable<__iKey>,
                           RECIPIENTS_PROPERTY_ITEM_EX,
                           const RECIPIENTS_PROPERTY_ITEM_HASHKEY *>
{
    public:
        CRecipientsHashTable() :
            CTypedHashTable<CRecipientsHashTable<__iKey>,
                            RECIPIENTS_PROPERTY_ITEM_EX,
                            const RECIPIENTS_PROPERTY_ITEM_HASHKEY *>(
                                "recipientshash",
                                LK_DFLT_MAXLOAD,
                                LK_SMALL_TABLESIZE)
        {
            TraceFunctEnter("CRecipientsHashTable");
            TraceFunctLeave();
        }

        ~CRecipientsHashTable() {
            TraceFunctEnter("~CRecipientsHashTable");
            TraceFunctLeave();
        }

        static const RECIPIENTS_PROPERTY_ITEM_HASHKEY *ExtractKey(const RECIPIENTS_PROPERTY_ITEM_EX *pRpie) {
            _ASSERT(__iKey >= 0 && __iKey <= MAX_COLLISION_HASH_KEYS);
            return &(pRpie->rgHashKeys[__iKey]);
        }

        static DWORD CalcKeyHash(const RECIPIENTS_PROPERTY_ITEM_HASHKEY *pHashkey) {
            return CRCHashNoCase(pHashkey->pbKey, pHashkey->cKey);
        }

        static bool EqualKeys(const RECIPIENTS_PROPERTY_ITEM_HASHKEY *pKey1,
                              const RECIPIENTS_PROPERTY_ITEM_HASHKEY *pKey2) {
            return (pKey1->cKey == pKey2->cKey &&
                    _strnicmp((const char *) pKey1->pbKey,
                              (const char *) pKey2->pbKey,
                              pKey1->cKey) == 0);
        }

        static void AddRefRecord(RECIPIENTS_PROPERTY_ITEM_EX *pRpie,
                                 int nIncr)
        {
            if (nIncr == 1) {
                _ASSERT(pRpie->m_cRefs >= 1);
                InterlockedIncrement(&pRpie->m_cRefs);
            } else if (nIncr == -1) {
                _ASSERT(pRpie->m_cRefs >= 2);
                long x = InterlockedDecrement(&pRpie->m_cRefs);
                // we should never drop to 0 references because the
                // list should always hold one
                _ASSERT(pRpie->m_cRefs != 0);
            } else {
                _ASSERT(nIncr == 1 || nIncr == -1);
            }
        }
};

//
// A hash table of domain list entries, key'd by domain name.  This is
// used to build up the domain list.  Each bucket contains a linked list
// of recipients who are in the same domain.
//
class CDomainHashTable :
    public CTypedHashTable<CDomainHashTable,
                           DOMAIN_LIST_ENTRY,
                           LPCSTR>
{
    public:
        CDomainHashTable() :
            CTypedHashTable<CDomainHashTable,
                            DOMAIN_LIST_ENTRY,
                            LPCSTR>("domainhash",
                                     LK_DFLT_MAXLOAD,
                                     LK_SMALL_TABLESIZE
                                     )
        {
            TraceFunctEnter("CDomainHashTable");
            TraceFunctLeave();
        }

        ~CDomainHashTable() {
            TraceFunctEnter("~CDomainHashTable");
            TraceFunctLeave();
        }

        static const LPCSTR ExtractKey(const DOMAIN_LIST_ENTRY *pDomainListEntry) {
            return pDomainListEntry->szDomainName;
        }

        static DWORD CalcKeyHash(LPCSTR szDomainName) {
            return CRCHashNoCase((BYTE *) szDomainName, lstrlen(szDomainName));
        }

        static bool EqualKeys(LPCSTR pszKey1, LPCSTR pszKey2) {
            if (pszKey1 == NULL && pszKey2 == NULL) return true;
            if (pszKey1 == NULL || pszKey2 == NULL) return false;
            return (_stricmp(pszKey1, pszKey2) == 0);
        }

        static void AddRefRecord(DOMAIN_LIST_ENTRY *pDomainListEntry,
                                 int nIncr)
        {
            if (nIncr == 1) {
                _ASSERT(pDomainListEntry->m_cRefs >= 0);
                InterlockedIncrement(&(pDomainListEntry->m_cRefs));
            } else if (nIncr == -1) {
                _ASSERT(pDomainListEntry->m_cRefs >= 1);
                long x = InterlockedDecrement(&pDomainListEntry->m_cRefs);
                if (x == 0) {
                    CMemoryAccess *pcmaAccess = pDomainListEntry->m_pcmaAccess;
                    _ASSERT(pcmaAccess != NULL);
                    pcmaAccess->FreeBlock(pDomainListEntry);
                }
            } else {
                _ASSERT(nIncr == 1 || nIncr == -1);
            }
        }
};

typedef CDomainHashTable::CIterator
    DOMAIN_ITEM_CONTEXT, *LPDOMAIN_ITEM_CONTEXT;

class CRecipientsHash
{
  public:

	CRecipientsHash();
	~CRecipientsHash();

	// Releases all memory associated with this object
	HRESULT Release();

	// Releases the domain list only
	HRESULT ReleaseDomainList();

	// Add a primary recipient, voids all predecessors of the same name
	HRESULT AddPrimary(
				DWORD		dwCount,
				LPCSTR		*ppszNames,
				DWORD		*pdwPropIDs,
				DWORD		*pdwIndex
				)
    {
        return AddRecipient(dwCount, ppszNames, pdwPropIDs, pdwIndex, true);
    }

	// Add a secondary recipients, yields if a collision is detected
	HRESULT AddSecondary(
				DWORD		dwCount,
				LPCSTR		*ppszNames,
				DWORD		*pdwPropIDs,
				DWORD		*pdwIndex
				)
    {
        return AddRecipient(dwCount, ppszNames, pdwPropIDs, pdwIndex, false);
    }

	// Remove a recipient, given a recipient index
	HRESULT RemoveRecipient(
				DWORD		dwIndex
				);

	HRESULT GetRecipient(
				DWORD							dwIndex,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppRecipient
				);

	// Builds a list of domains given a hash, groups recipients in
	// domain order and discards "do not deliver" recipients
	HRESULT BuildDomainListFromHash(CMailMsgRecipientsAdd *pList);

	// Get count of domains
	HRESULT GetDomainCount(
				DWORD					*pdwCount
				);

	// Get count of recipients
	HRESULT GetRecipientCount(
				DWORD					*pdwCount
				);

	// Get the total space needed to write all domain names, including
	// NULL terminators.
	HRESULT GetDomainNameSize(
				DWORD					*pdwSize
				);

	// Get the total space needed to write all recipient names
	HRESULT GetRecipientNameSize(
				DWORD					*pdwSize
				);

	// Returns a context for enumeration as well as the first item
	// in the first domain
	// Returns HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) if no more domains
	HRESULT GetFirstDomain(
				LPDOMAIN_ITEM_CONTEXT			pContext,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppFirstItem,
                LPDOMAIN_LIST_ENTRY             *ppDomainListEntry = NULL
				);

	// Enumerates along and returns the first item in the next domain.
	// Returns HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) if no more domains
	HRESULT GetNextDomain(
				LPDOMAIN_ITEM_CONTEXT			pContext,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppFirstItem,
                LPDOMAIN_LIST_ENTRY             *ppDomainListEntry = NULL
				);

    // This must be called if GetNextDomain isn't called until it returns
    // ERROR_NO_MORE_ITEMS
    HRESULT CloseDomainContext(
                LPDOMAIN_ITEM_CONTEXT           pContext);

	HRESULT Lock() { m_rwLock.ExclusiveLock(); return(S_OK); }
	HRESULT Unlock() { m_rwLock.ExclusiveUnlock(); return(S_OK); }

  private:

	// Method to allocate an in-memory recipient block
	HRESULT AllocateAndPrepareRecipientsItem(
				DWORD							dwCount,
				DWORD							*pdwMappedIndices,
				LPCSTR							*rgszName,
				PROP_ID							*pidProp,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppItem
				);

	// Add a recipient
	HRESULT AddRecipient(
				DWORD		dwCount,
				LPCSTR		*ppszNames,
				DWORD		*pdwPropIDs,
				DWORD		*pdwIndex,
                bool    	fPrimary
				);
	// Method to compare two in-memory items
	HRESULT CompareEntries(
				DWORD							dwNameIndex,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pItem1,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pItem2
				);

	// Method to walk the hash chain and look for a collision
	HRESULT DetectCollision(
				DWORD							dwNameIndex,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pStartingItem,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pRecipientItem,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppCollisionItem
				);

#ifdef DEADCODE
	// Method to insert an entry into the hash bucket, taking
	// consideration for both hash values
	HRESULT InsertRecipientIntoHash(
				DWORD							dwCount,
				DWORD							*pdwNameIndex,
				DWORD							*rgdwBucket,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pRecipientItem
				);
#endif

	// Insert an entry into the domain list, creating an new
	// domain entry if needed
	HRESULT InsertRecipientIntoDomainList(
				LPRECIPIENTS_PROPERTY_ITEM_EX	pItem,
                LPCSTR                          szDomain
				);

    //
    // wrappers for hash functions.  these are used to encapsulate
    // operations to m_hashEntries*
    //
    HRESULT InsertHashRecord(DWORD dwIndex,
                             LPRECIPIENTS_PROPERTY_ITEM_EX pRecipientItem,
                             bool fOverwrite = FALSE);
    HRESULT DeleteHashRecord(DWORD dwIndex,
                             LPRECIPIENTS_PROPERTY_ITEM_EX pRecipientItem);
    HRESULT FindHashRecord(DWORD dwIndex,
                           RECIPIENTS_PROPERTY_ITEM_HASHKEY *pKey,
                           LPRECIPIENTS_PROPERTY_ITEM_EX *ppRecipientItem);

	// Statistical info
	DWORD							m_dwDomainCount;
	DWORD							m_dwDomainNameSize;
	DWORD							m_dwRecipientCount;
	DWORD							m_dwRecipientNameSize;
    DWORD                           m_dwAllocated;

    // Head of allocation list
    LPRECIPIENTS_PROPERTY_ITEM_EX   m_pListHead;

    // these are all different types, so we can't make a true array.
    // there is one hash table for each address type.  The number
    // corresponds with the address in the faNameOffset array of
    // RECIPIENTS_PROPERTY_ITEM
    CRecipientsHashTable<0>         m_hashEntries0;
    CRecipientsHashTable<1>         m_hashEntries1;
    CRecipientsHashTable<2>         m_hashEntries2;
    CRecipientsHashTable<3>         m_hashEntries3;
    CRecipientsHashTable<4>         m_hashEntries4;

    CDomainHashTable                m_hashDomains;

	// Need a lock for multi-threaded hash access
	CShareLockNH					m_rwLock;
    CShareLockNH                    m_rwLockQuickList;

	// Keep a pointer to the block manager
	CMemoryAccess					m_cmaAccess;

	// List for mapping indexes to pointers
	CQuickList						m_qlMap;

	// Context for the quick list (perf)
	PVOID   						m_pvMapContext;
};

// Index obfuscation functions

// Play bit games so no one tries to treat this as an index
// The approach here is to :
//      (1) : Leave the top bit zero (we assume it IS zero)
//		(2) : Set bit 30
// 		(3) : Swap bits 29 and 30 down to positions 0 and 1
inline DWORD ObfuscateIndex(DWORD dwIndex)
	{
	_ASSERT(!(dwIndex & 0xC0000000)); 				// Assert that top two bits are zero
	dwIndex += 0x40000000;							// Add bit 30
	dwIndex = (dwIndex << 2) | (dwIndex >> 29);   	// Flip things around
	return dwIndex;
	}

inline DWORD RecoverIndex(DWORD dwIndex)
	{
	dwIndex = (dwIndex >> 2) | ((dwIndex & 0x3) << 29);	// Flip things back into place
	dwIndex -= 0x40000000;								// Subtract bit 30
	return dwIndex;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\makecab\infutil2\filefind.h ===
typedef struct  _finddata_t SysFindData;
struct MyFindDataStruct 
{
	unsigned	attrib;   // File attribute
	time_t		time_create; //   Time of file creation ( 1L for FAT file systems)
	time_t		time_access; //   Time of last file access (1L for FAT file systems)
	time_t		time_write; //   Time of last write to file
	unsigned long size; //   Length of file in bytes
	char *		name; //   Null-terminated name of matched file/directory, without the path
	char *		ShortName;
};
typedef struct MyFindDataStruct finddata;


#define ALL_FILES		0xff
#define STRING_TABLE_SIZE   100000

int  InitStringTable(long size);
void EndStringTable();
void AddString(char * s, finddata * f);
long GetStringTableSize();
void ResetStringTable();
int  FindFirst(char * ss, unsigned attr, long * hFile, finddata * s);
int  FindNext(int attr, long hFile, finddata * s);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\qwiklist.h ===
//-----------------------------------------------------------------------------
//
//
//	File: qwiklist.h
//
//	Description: Provides a quick paged/growable list implementation.
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		6/15/1998 - MikeSwa Created
//      9/9/1998 - MikeSwa Modified to include functionality to delete entries
//		3/14/2000 - dbraun : Slightly modified for use in mailmsg.dll
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __QWIKLIST_H__
#define __QWIKLIST_H__

#include "blockmgr.h"

//#include <aqincs.h>
#include <listmacr.h>

#define QUICK_LIST_SIG  'tsLQ'
#define QUICK_LIST_SIG_DELETE 'slQ!'

const DWORD QUICK_LIST_PAGE_SIZE = 512;  //must be a power of 2

//Mask used to quickly determine if a given index is on the current page
const DWORD QUICK_LIST_INDEX_MASK = ~(QUICK_LIST_PAGE_SIZE-1);

//When m_cItems is set to this value... we know this is not the head page.
const DWORD QUICK_LIST_LEAF_PAGE = 0xFFFF7EAF;

class CQuickList
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_dwCurrentIndexStart;
    LIST_ENTRY  m_liListPages;
    DWORD       m_cItems;
    PVOID       m_rgpvData[QUICK_LIST_PAGE_SIZE];
    inline BOOL fIsIndexOnThisPage(DWORD dwIndex);
  public:
    CQuickList(); //initialize entry as head
    CQuickList(CQuickList *pqlstHead); //initialize as new page in list
    ~CQuickList();

    DWORD dwGetCount() {return m_cItems;};
    PVOID pvGetItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext);
    HRESULT HrAppendItem(IN PVOID pvData, OUT DWORD *pdwIndex);
};

//---[ CQuickList::fIsIndexOnThisPage ]----------------------------------------
//
//
//  Description:
//      Returns TRUE is the given index is on this page
//  Parameters:
//      dwIndex     - Index to check for
//  Returns:
//      TRUE if index is on this page... FALSE otherwise
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CQuickList::fIsIndexOnThisPage(DWORD dwIndex)
{
    return ((dwIndex & QUICK_LIST_INDEX_MASK) == m_dwCurrentIndexStart);
}

#endif //__QWIKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\msgcodes.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	msgcodes.h

Abstract:

	This module contains the definitions of various HRESULT codes

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/20/98	created

--*/

#ifndef _MSGCODES_H_
#define _MSGCODES_H_

//#define MAILMSG_S_EXISTS						((HRESULT)0x00000002)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\mmdbgext\mmdumps.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdumps.cpp
//
//  Description:  Definitions of AQ structure dumps for use with ptdbgext.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_

#define private public
#define protected public

#include <atq.h>
#include <stddef.h>

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"

#include "dbgdumpx.h"
PEXTLIB_INIT_ROUTINE g_pExtensionInitRoutine = NULL;
DECLARE_DEBUG_PRINTS_OBJECT();

DEFINE_EXPORTED_FUNCTIONS

LPSTR ExtensionNames[] = {
    "MailMsg debugger extensions",
    0
};

LPSTR Extensions[] = {
    0
};

//Define some mailmsg specific types
#define FieldTypeFlatAddress FieldTypeDWordBitMask

BEGIN_FIELD_DESCRIPTOR(CMailMsg_Fields)
    FIELD3(FieldTypeClassSignature, CMailMsg, m_Header.dwSignature)
    FIELD3(FieldTypeClassSignature, CMailMsg, m_Header.ptiGlobalProperties.dwSignature)
    FIELD3(FieldTypeClassSignature, CMailMsg, m_Header.ptiRecipients.dwSignature)
    FIELD3(FieldTypeClassSignature, CMailMsg, m_Header.ptiPropertyMgmt.dwSignature)
    FIELD3(FieldTypePointer, CMailMsg, m_pbStoreDriverHandle)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_dwStoreDriverHandle)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_dwCreationFlags)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_ulUsageCount)
    FIELD3(FieldTypeStruct, CMailMsg, m_lockUsageCount)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_ulRecipientCount)
    FIELD3(FieldTypeStruct, CMailMsg, m_Header)
    FIELD3(FieldTypePointer, CMailMsg, m_hContentFile)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_cContentFile)
    FIELD3(FieldTypePointer, CMailMsg, m_pStream)
    FIELD3(FieldTypePointer, CMailMsg, m_pStore)
    FIELD3(FieldTypeBool, CMailMsg, m_fCommitCalled)
    FIELD3(FieldTypeBool, CMailMsg, m_fDeleted)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_cCloseOnExternalReleaseUsage)
    FIELD3(FieldTypePointer, CMailMsg, m_pDefaultRebindStoreDriver)
    FIELD3(FieldTypeStruct, CMailMsg, m_ptProperties)
    FIELD3(FieldTypeStruct, CMailMsg, m_SpecialPropertyTable)
    FIELD3(FieldTypeStruct, CMailMsg, m_bmBlockManager)
    FIELD3(FieldTypeStruct, CMailMsg, m_lockReopen)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CBlockManager_Fields)
    FIELD3(FieldTypeClassSignature, CBlockManager, m_dwSignature)
    FIELD3(FieldTypeFlatAddress, CBlockManager, m_faEndOfData)
    FIELD3(FieldTypeDWordBitMask, CBlockManager, m_idNodeCount)
    FIELD3(FieldTypePointer, CBlockManager, m_pRootNode)
    FIELD3(FieldTypePointer, CBlockManager, m_pParent)
    FIELD3(FieldTypeStruct, CBlockManager, m_bma)
    FIELD3(FieldTypePointer, CBlockManager, m_pMsg)
    FIELD3(FieldTypeBool, CBlockManager, m_fDirty)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CBlockContext_Fields)
    FIELD3(FieldTypeClassSignature, CBlockContext, m_dwSignature)
    FIELD3(FieldTypePointer, CBlockContext, m_pLastAccessedNode)
    FIELD3(FieldTypeFlatAddress, CBlockContext, m_faLastAccessedNodeOffset)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(BLOCK_HEAP_NODE_ATTRIBUTES_Fields)
    FIELD3(FieldTypePointer, BLOCK_HEAP_NODE_ATTRIBUTES, pParentNode)
    FIELD3(FieldTypeDWordBitMask, BLOCK_HEAP_NODE_ATTRIBUTES, idChildNode)
    FIELD3(FieldTypeDWordBitMask, BLOCK_HEAP_NODE_ATTRIBUTES, idNode)
    FIELD3(FieldTypeFlatAddress, BLOCK_HEAP_NODE_ATTRIBUTES, faOffset)
    FIELD3(FieldTypeDWordBitMask, BLOCK_HEAP_NODE_ATTRIBUTES, fFlags)
END_FIELD_DESCRIPTOR

EMBEDDED_STRUCT(BLOCK_HEAP_NODE_ATTRIBUTES, 
                BLOCK_HEAP_NODE_ATTRIBUTES_Fields, 
                BLOCK_HEAP_NODE_ATTRIBUTES_EmbeddedFields)

BEGIN_FIELD_DESCRIPTOR(BLOCK_HEAP_NODE_Fields)
    FIELD3(FieldTypeStruct, BLOCK_HEAP_NODE, rgpChildren)
    FIELD3(FieldTypeStruct, BLOCK_HEAP_NODE, stAttributes)
    //FIELD3(FieldTypeEmbeddedStruct, BLOCK_HEAP_NODE, stAttributes, 
                                    //BLOCK_HEAP_NODE_ATTRIBUTES_EmbeddedFields)
    FIELD3(FieldTypeStruct, BLOCK_HEAP_NODE, rgbData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(PROPERTY_TABLE_INSTANCE_Fields)
    FIELD3(FieldTypeClassSignature, PROPERTY_TABLE_INSTANCE, dwSignature)
    FIELD3(FieldTypeFlatAddress, PROPERTY_TABLE_INSTANCE, faFirstFragment)
    FIELD3(FieldTypeDWordBitMask, PROPERTY_TABLE_INSTANCE, dwFragmentSize)
    FIELD3(FieldTypeDWordBitMask, PROPERTY_TABLE_INSTANCE, dwItemBits)
    FIELD3(FieldTypeDWordBitMask, PROPERTY_TABLE_INSTANCE, dwItemSize)
    FIELD3(FieldTypeDWordBitMask, PROPERTY_TABLE_INSTANCE, dwProperties)
    FIELD3(FieldTypeFlatAddress, PROPERTY_TABLE_INSTANCE, faExtendedInfo)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(PROPERTY_TABLE_FRAGMENT_Fields)
    FIELD3(FieldTypeClassSignature, PROPERTY_TABLE_FRAGMENT, dwSignature)
    FIELD3(FieldTypeFlatAddress, PROPERTY_TABLE_FRAGMENT, faNextFragment)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(GLOBAL_PROPERTY_TABLE_FRAGMENT_Fields)
    FIELD3(FieldTypeClassSignature, GLOBAL_PROPERTY_TABLE_FRAGMENT, 
                                    ptfFragment.dwSignature)
    FIELD3(FieldTypeFlatAddress, GLOBAL_PROPERTY_TABLE_FRAGMENT, 
                                    ptfFragment.faNextFragment)
    FIELD3(FieldTypeStruct, GLOBAL_PROPERTY_TABLE_FRAGMENT, rgpiItems)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(GLOBAL_PROPERTY_ITEM_Fields)
    FIELD3(FieldTypeFlatAddress, GLOBAL_PROPERTY_ITEM, piItem.faOffset)
    FIELD3(FieldTypeDWordBitMask, GLOBAL_PROPERTY_ITEM, piItem.dwSize)
    FIELD3(FieldTypeDWordBitMask, GLOBAL_PROPERTY_ITEM, piItem.dwMaxSize)
    FIELD3(FieldTypeDWordBitMask, GLOBAL_PROPERTY_ITEM, idProp)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RECIPIENT_PROPERTY_ITEM_Fields)
    FIELD3(FieldTypeFlatAddress, RECIPIENT_PROPERTY_ITEM, piItem.faOffset)
    FIELD3(FieldTypeDWordBitMask, RECIPIENT_PROPERTY_ITEM, piItem.dwSize)
    FIELD3(FieldTypeDWordBitMask, RECIPIENT_PROPERTY_ITEM, piItem.dwMaxSize)
    FIELD3(FieldTypeDWordBitMask, RECIPIENT_PROPERTY_ITEM, idProp)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(PROPID_MGMT_PROPERTY_ITEM_Fields)
    FIELD3(FieldTypeFlatAddress, PROPID_MGMT_PROPERTY_ITEM, piItem.faOffset)
    FIELD3(FieldTypeDWordBitMask, PROPID_MGMT_PROPERTY_ITEM, piItem.dwSize)
    FIELD3(FieldTypeDWordBitMask, PROPID_MGMT_PROPERTY_ITEM, piItem.dwMaxSize)
    FIELD3(FieldTypeGuid, PROPID_MGMT_PROPERTY_ITEM, Guid)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MASTER_HEADER_Fields)
    FIELD3(FieldTypeClassSignature, MASTER_HEADER, dwSignature)
    FIELD3(FieldTypeClassSignature, MASTER_HEADER, ptiGlobalProperties.dwSignature)
    FIELD3(FieldTypeClassSignature, MASTER_HEADER, ptiRecipients.dwSignature)
    FIELD3(FieldTypeClassSignature, MASTER_HEADER, ptiPropertyMgmt.dwSignature)
    FIELD3(FieldTypeStruct, MASTER_HEADER, ptiGlobalProperties)
    FIELD3(FieldTypeStruct, MASTER_HEADER, ptiRecipients)
    FIELD3(FieldTypeStruct, MASTER_HEADER, ptiPropertyMgmt)
END_FIELD_DESCRIPTOR

BEGIN_STRUCT_DESCRIPTOR
    STRUCT(CMailMsg, CMailMsg_Fields)
    STRUCT(CBlockManager, CBlockManager_Fields)
    STRUCT(CBlockContext, CBlockContext_Fields)
    STRUCT(BLOCK_HEAP_NODE_ATTRIBUTES, BLOCK_HEAP_NODE_ATTRIBUTES_Fields)
    STRUCT(BLOCK_HEAP_NODE, BLOCK_HEAP_NODE_Fields)
    STRUCT(PROPERTY_TABLE_INSTANCE, PROPERTY_TABLE_INSTANCE_Fields)
    STRUCT(PROPERTY_TABLE_FRAGMENT, PROPERTY_TABLE_FRAGMENT_Fields)
    STRUCT(GLOBAL_PROPERTY_TABLE_FRAGMENT, 
           GLOBAL_PROPERTY_TABLE_FRAGMENT_Fields)
    STRUCT(GLOBAL_PROPERTY_ITEM,  GLOBAL_PROPERTY_ITEM_Fields)
    STRUCT(RECIPIENT_PROPERTY_ITEM,  RECIPIENT_PROPERTY_ITEM_Fields)
    STRUCT(PROPID_MGMT_PROPERTY_ITEM,  PROPID_MGMT_PROPERTY_ITEM_Fields)
    STRUCT(MASTER_HEADER,  MASTER_HEADER_Fields)
END_STRUCT_DESCRIPTOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\nntpfilt\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the Server
	Extension Object resources.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	11/26/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\makecab\infutil2\filefind.cpp ===
/********************************************************************************
* Description:
*	 Functions that do what _dos_findfirst and _dos_findnext SHOULD do
*******************************************************************************/
#include <io.h>
#include <string.h>
#include <malloc.h>
#include "filefind.h"

static char * StringTable;
static long offset = 0 ;
static long MaxOffset;


int InitStringTable(long size)
{
	StringTable=(char *) malloc(size);
    ResetStringTable();
	return StringTable != 0;
}

void EndStringTable()
{
	if (StringTable)
		free (StringTable);

}

void AddString (char * StringToAdd, finddata * s)
{
	int len;

	len=strlen(StringToAdd);
	
   	strcpy(StringTable+offset, StringToAdd);
	s->name=StringTable+offset;
	offset+=len+1;
	if (len>12) {
		strcpy(StringTable+offset, StringToAdd);
		StringTable[offset+11]='~';
		StringTable[offset+12]='\0';
		s->ShortName=StringTable+offset;
		offset+=13;
	}
	else
		s->ShortName=s->name;
	
	MaxOffset= (offset > MaxOffset) ? offset : MaxOffset;
	
}

long GetStringTableSize()
{
	return MaxOffset;
}

void ResetStringTable()
{
	offset=0;
}

int
FindFirst(char * ss, unsigned attr, long * hFile, finddata * s)
{
	int         found;
	SysFindData s2;
	
	*hFile=(long)_findfirst(ss, &s2);
	found = (*hFile != -1L);
	if (found) {
		if ( attr == ALL_FILES ) {
			while(found && s2.name[0] == '.')
				found=(_findnext(*hFile, &s2) == 0);
		}
		else if ( attr & _A_SUBDIR )  {
			while(found && (((s2.attrib & _A_SUBDIR) == 0) || s2.name[0] == '.'))
				found=(_findnext(*hFile, &s2) == 0);
		}
		else  {
			while(found && (s2.attrib & _A_SUBDIR))
				found=(_findnext(*hFile, &s2) == 0);
		}
		if (!found)
			_findclose(*hFile);
		else {
			memcpy(s, &s2, sizeof(finddata));
			AddString(s2.name, s);
		}
    }
	return(found);
} /* FindFirst() */






int
FindNext(int attr, long hFile, finddata * s)
{
	int      found;
	SysFindData s2;

	
	found=(_findnext(hFile, &s2) == 0);
	if (found  &&  attr != ALL_FILES) {
		if ( attr & _A_SUBDIR )	{
			while(found && (((s2.attrib & _A_SUBDIR) == 0) || s2.name[0] == '.'))
				found=(_findnext(hFile, &s2) == 0);
		}
		else {
			while(found && (s2.attrib & _A_SUBDIR))
				found=(_findnext(hFile, &s2) == 0);
		}
    }
	if (!found)
		_findclose(hFile);
	else {
		memcpy(s, &s2, sizeof(finddata));
		AddString(s2.name, s);
	}
	return(found);
} /* FindNext() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\mmdbgext\mmdbgext.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: mmdbgext.cpp
//
//  Description: Custom mailmsg debugger extensions 
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_

#define private public
#define protected public

#include <atq.h>
#include <stddef.h>

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"

#include "dbgdumpx.h"

PT_DEBUG_EXTENSION(flataddress)
{
    FLAT_ADDRESS  faDump    = INVALID_FLAT_ADDRESS;
    FLAT_ADDRESS  faOffset  = INVALID_FLAT_ADDRESS;
    DWORD         dwNodeId  = 0;

    if (!szArg || ('\0' == szArg[0]))
    {
        dprintf("You must specify a flat address\n");
        return;
    }

    faDump = (FLAT_ADDRESS) (DWORD_PTR) GetExpression(szArg);

    if (INVALID_FLAT_ADDRESS == faDump)
    {
        dprintf("Flat Address is NULL (INVALID_FLAT_ADDRESS)\n");
        return;
    }

    //Find the offset into the current block
    faOffset = faDump & BLOCK_HEAP_PAYLOAD_MASK;

    //Find the node id from the address
    dwNodeId = ((DWORD) ((faDump) >> BLOCK_HEAP_PAYLOAD_BITS));

    dprintf("Flat Address 0x%X is at block #%d offset 0x%X\n", 
            faDump, dwNodeId+1, faOffset);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\nntpfilt\nntpfilt.cpp ===
#include "windows.h"
#include "nntpfilt.h"
#include "..\imsg\imsg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\qwiklist.cpp ===
//-----------------------------------------------------------------------------
//
//
//	File: qwiklist.cpp
//
//	Description:  Implementation of CQuickList
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		6/15/1998 - MikeSwa Created
//		3/14/2000 - dbraun : Slightly modified for use in mailmsg.dll
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "atq.h"
#include "qwiklist.h"


//---[ CQuickList::CQuickList ]------------------------------------------------
//
//
//  Description:
//      Default contructor for CQuikList... initializes as head of list
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::CQuickList()
{
    m_dwSignature = QUICK_LIST_SIG;

    //ASSERT constants
    _ASSERT(!(~QUICK_LIST_INDEX_MASK & QUICK_LIST_PAGE_SIZE));
    _ASSERT((~QUICK_LIST_INDEX_MASK + 1)== QUICK_LIST_PAGE_SIZE);
    m_dwCurrentIndexStart = 0;
    InitializeListHead(&m_liListPages);
    m_cItems = 0;
    ZeroMemory(m_rgpvData, QUICK_LIST_PAGE_SIZE*sizeof(PVOID));
}


//---[ CQuickList::CQuickList ]------------------------------------------------
//
//
//  Description:
//      Constructor for QQuickList, inserts it into the tail of current list
//  Parameters:
//
//  Returns:
//
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::CQuickList(CQuickList *pqlstHead)
{
    _ASSERT(pqlstHead);
    _ASSERT(pqlstHead->m_liListPages.Blink);
    CQuickList *pqlstTail = CONTAINING_RECORD(pqlstHead->m_liListPages.Blink, CQuickList, m_liListPages);
    _ASSERT(QUICK_LIST_SIG == pqlstTail->m_dwSignature);
    m_dwSignature = QUICK_LIST_SIG;
    m_dwCurrentIndexStart = pqlstTail->m_dwCurrentIndexStart + QUICK_LIST_PAGE_SIZE;
    m_cItems = QUICK_LIST_LEAF_PAGE;
    ZeroMemory(m_rgpvData, QUICK_LIST_PAGE_SIZE*sizeof(PVOID));
    InsertTailList(&(pqlstHead->m_liListPages), &m_liListPages);
}


//---[ CQuickList::~CQuickList ]-----------------------------------------------
//
//
//  Description:
//      CQuickList destructor
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::~CQuickList()
{
    m_dwSignature = QUICK_LIST_SIG_DELETE;
    CQuickList *pqlstCurrent = NULL;
    CQuickList *pqlstNext = NULL;
    if (QUICK_LIST_LEAF_PAGE != m_cItems)
    {
        //head node... loop through every thing and delete leaf pages
        pqlstCurrent = CONTAINING_RECORD(m_liListPages.Flink,
                        CQuickList, m_liListPages);
        while (this != pqlstCurrent)
        {
            pqlstNext = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink,
                        CQuickList, m_liListPages);
            delete pqlstCurrent;
            pqlstCurrent = pqlstNext;
        }
    }
}


//---[ CQuickList::pvGetItem ]-------------------------------------------------
//
//
//  Description:
//      Looks up item at given index
//  Parameters:
//      IN     dwIndex      Index of item to lookup
//      IN OUT ppvContext   Context for speeding up lookup
//  Returns:
//      Value of item at index
//      NULL if index is out of ranges
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CQuickList::pvGetItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext)
{
    _ASSERT(ppvContext);
    PVOID pvReturn = NULL;
    BOOL  fSearchForwards = TRUE;
    DWORD dwForwardDist = 0;
    DWORD dwBackwardDist = 0;
    DWORD dwMaxStartingIndex = m_cItems & QUICK_LIST_INDEX_MASK;
    CQuickList *pqlstDirection = NULL;
    CQuickList *pqlstCurrent = (CQuickList *) *ppvContext;
    CQuickList *pqlstSentinal = NULL;
    DWORD cDbgItems = m_cItems;

    if (dwIndex >= m_cItems)
        return NULL;

    if (!pqlstCurrent)
        pqlstCurrent = this;

    pqlstSentinal = pqlstCurrent;

    //short circuit direction logic
    if (pqlstCurrent->fIsIndexOnThisPage(dwIndex))
    {
        pvReturn = pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK];
        *ppvContext = pqlstCurrent;
        _ASSERT((dwIndex < m_cItems) || (NULL == pvReturn));
        goto Exit;
    }

    //determine which direction to go in (we want to traverse the smallest # of pages
    //possible
    pqlstDirection = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, CQuickList, m_liListPages);
    if (dwIndex > pqlstDirection->m_dwCurrentIndexStart)
        dwForwardDist = dwIndex - pqlstDirection->m_dwCurrentIndexStart;
    else
        dwForwardDist = pqlstDirection->m_dwCurrentIndexStart - dwIndex;

    pqlstDirection = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Blink, CQuickList, m_liListPages);
    if (dwIndex > pqlstDirection->m_dwCurrentIndexStart)
        dwBackwardDist = dwIndex - pqlstDirection->m_dwCurrentIndexStart;
    else
        dwBackwardDist = pqlstDirection->m_dwCurrentIndexStart - dwIndex;

    //fix up distances to account for going through the 0th page
    //max distance is dwMaxStartingIndex/2
    if (dwBackwardDist > dwMaxStartingIndex/2)
        dwBackwardDist -= dwMaxStartingIndex;

    if (dwForwardDist > dwMaxStartingIndex/2)
        dwForwardDist -= dwMaxStartingIndex;

    if (dwForwardDist > dwBackwardDist)
        fSearchForwards = FALSE;

    //$$NOTE: current lookup time is O(lg base{QUICK_LIST_PAGE_BASE} (n))/2.
    //Consecutive lookups will be O(1) (because of the hints)
    do
    {
        if (fSearchForwards)
        {
            //going forward is quicker
            pqlstCurrent = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, CQuickList, m_liListPages);
        }
        else
        {
            //going backwards is quicker
            pqlstCurrent = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Blink, CQuickList, m_liListPages);
        }

        _ASSERT(QUICK_LIST_SIG == pqlstCurrent->m_dwSignature);
        if (pqlstCurrent->fIsIndexOnThisPage(dwIndex))
        {
            pvReturn = pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK];
            _ASSERT((dwIndex < m_cItems) || (NULL == pvReturn));
            break;
        }

    } while (pqlstSentinal != pqlstCurrent); //stop when we return to list head

    *ppvContext = pqlstCurrent;
    _ASSERT((cDbgItems == m_cItems) && "Non-threadsafe access to CQuickList");

  Exit:
    return pvReturn;
}

//---[ CQuickList::HrAppendItem ]-----------------------------------------------
//
//
//  Description:
//      Appends new data item to end of array
//  Parameters:
//      IN  pvData      - Data to insert
//      OUT pdwIndex    - Index data was inserted at
//  Returns:
//      E_OUTOFMEMORY if unable to allocate another page
//      E_INVALIDARG if pvData is NULL
//  History:
//      6/15/98 - MikeSwa Created
//      9/9/98 - MikeSwa - Added pdwIndex OUT param
//
//-----------------------------------------------------------------------------
HRESULT CQuickList::HrAppendItem(IN PVOID pvData, OUT DWORD *pdwIndex)
{
    HRESULT hr = S_OK;
    CQuickList *pqlstCurrent = NULL;

    _ASSERT(pvData && "Cannot insert NULL pointers");

    if (!pvData)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (m_cItems && !(m_cItems & ~QUICK_LIST_INDEX_MASK)) //on page boundary
    {
        //there is not room on the last page
        pqlstCurrent = new CQuickList(this);
        if (!pqlstCurrent)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else if (!(m_cItems & QUICK_LIST_INDEX_MASK))
    {
        pqlstCurrent = this;
    }
    else
    {
        pqlstCurrent = CONTAINING_RECORD(m_liListPages.Blink, CQuickList, m_liListPages);
    }

    _ASSERT(pqlstCurrent->fIsIndexOnThisPage(m_cItems));
    pqlstCurrent->m_rgpvData[m_cItems & ~QUICK_LIST_INDEX_MASK] = pvData;

    //Set OUT param to index (before we increment the count)
    if (pdwIndex)
        *pdwIndex = m_cItems;

    m_cItems++;
    _ASSERT(QUICK_LIST_LEAF_PAGE != m_cItems);

  Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\makecab\infutil2\main.cpp ===
//****************************************************************************
//* Author:   Aaron Lee
//* Purpose:  Create .DDF and .INF files for specified files
//******************************************************************************/
/*
; ------------------------------------------------------------------------------------
; Format for this file
;
; position 1 = nts_x86 flag
; position 2 = ntw_x86 flag
; position 3 = win95 flag
; position 4 = win98 flag
; position 5 = nts_alpha flag
; position 6 = ntw_alpha flag
; position 7 = other_os flag
;
; position 8 = cabfilename
; position 9 = inf section
; position 10 = filename (wildcards okay)
;
; position 11= .INF rename to
; position 12= .DDF exclude from cab flag
; position 13=  Do Not Produce Error if Empty
; position 14=  Do Not include this file if the cab is empty!
; ------------------------------------------------------------------------------------
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,setupapi.dll,,1
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,cfgmgr32.dll
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,ocmanage.dll
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,sysocmgr.exe
1,1,1,1,0,0,0,basic.cab,iis_core_files_sys,inetsrv\mdutil.exe
1,1,1,1,0,0,0,basic.cab,iis_core_files_sys,inetsrv\iismap.dll
1,1,1,1,0,0,0,basic.cab,iis_core_files_inetsrv,inetsrv\iscomlog.dll
*/
#include <direct.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <windows.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <iostream.h>
#include <fstream.h>
#include <winbase.h>
#include "filefind.h"
#include <iis64.h>

// Defines
#define delimiters      ",\t\n"
#define MAX_STRING      512
#define MAX_ARRAY_SIZE  10000
#define MAX_ARRAY_SMALL 1000
#define ALL_FILES       0xff

#define NTS_X86         "nts_x86"
#define NTW_X86         "ntw_x86"
#define WIN95           "win95"
#define WIN98           "win98"
#define NTS_ALPHA       "nts_alpha"
#define NTW_ALPHA       "ntw_alpha"
#define OTHER_OS        "other_os"

// Globals
int   g_bOutputDetails = TRUE;
int   g_bCabbing_Flag = TRUE;
int   g_bDisplayToScreen = FALSE;
char  g_szModuleFilename[_MAX_FNAME];
char  g_szDDFOutput[_MAX_PATH];
char  g_szINFOutput[_MAX_PATH];
char  g_szLSTOutput[_MAX_PATH];
char  g_szCATOutput[_MAX_PATH];
char  g_szNOTExistOutput[_MAX_PATH];

char  g_szinput_filename_full[_MAX_PATH];
char  g_szinput_platform[10];
char  g_szCurrentDir[_MAX_PATH];

char g_szFilenameTag[_MAX_FNAME] = "IIS";

#define USENEW


struct FileReadLine
{
    int  NTS_x86_flag;
    int  NTW_x86_flag;
    int  Win95_flag;
	int  Win98_flag;
    int  NTS_alpha_flag;
    int  NTW_alpha_flag;
	int  Other_os_flag;
    char CabFileName[50];
    char INF_Sections[100];
    char Filename_Full[_MAX_PATH];
    char Filename_Name[_MAX_FNAME];
    char Filename_Path[_MAX_PATH];
    char DDF_Renamed[_MAX_PATH];
    char INF_Rename_To[_MAX_FNAME];
    int  DDF_Exclude_From_Cab_Flag;
    int  Do_Not_Show_Error_Flag;
    int  Do_Not_Include_file_if_cabEmpty_Flag;
	// invisible stuff
	long FileName_Size;
	int  FileWasNotActuallyFoundToExist;

} Flat_GlobalArray_Main[MAX_ARRAY_SIZE];


struct CabSizeInfoStruct
{
	char CabFileName[50];
	int  TotalFiles;
	long TotalFileSize;
} Flat_GlobalArray_CabSizes[30];

char Flat_GlobalArray_Err[MAX_ARRAY_SIZE][255];

struct arrayrow
{
    long total;
    long nextuse;
} Flat_GlobalArrayIndex_Main, Flat_GlobalArrayIndex_Err, Flat_GlobalArrayIndex_CabSizes;


char Flat_GlobalUniqueDirList[300][_MAX_PATH];
int Flat_GlobalUniqueDirList_nextuse;
int Flat_GlobalUniqueDirList_total;

// used for files which should not be included in the cab.
FileReadLine g_non_cablist_temp[MAX_ARRAY_SMALL];
int g_non_cablist_temp_nextuse;
int g_non_cablist_temp_total;


// prototypes
int   __cdecl main(int ,char *argv[]);
void  ShowHelp(void);
void  MakeDirIfNeedTo(char []);
int   strltrim(LPSTR & thestring);
int   RemoveAllSpaces(LPSTR & thetempstring);
int   IsThisStringInHere(LPTSTR, char[]);
void  GetPath(char *input_filespec, char *path, char *fs);
int   DoesFileExist(char *input_filespec);
void  GetThisModuleName(void);
char* __cdecl strtok2(char *,const char *);

void  Flat_ProcessFile(void);
void  Flat_GlobalArray_Fill(char[]);
void  Flat_GlobalArray_ChkDups(void);
void  Flat_GlobalArray_Prepend_UniqueString(void);

void  Flat_GlobalArray_Sort_Cols1(void);
void  Flat_GlobalArray_Sort_Cols1a(BOOL bDescendFlag);
void  Flat_GlobalArray_Sort_Cols2(BOOL bDescendFlag);

int   Flat_GlobalArray_Add(FileReadLine);
void  Flat_GlobalArray_Add_Err(char[]);
int   Flat_GlobalArray_EntryExists(FileReadLine);
void  Flat_GlobalArray_Print(void);
void  Flat_GlobalArray_Print_Err(void);
int   Flat_IsFileNameDup(int);
void  Flat_Create_Output_DDF(void);
void  Flat_Create_Output_INF(void);
int   Flat_Create_Output_ERR(void);
int   Flat_DoWeIncludeThisFileCheck(int processeduptill);


void Global_TotalCabFileSize_Compute(void);
void Global_TotalCabFileSize_Print(void);

int ReturnDirLevelCount(char *DirectoryTree);
void FillGlobalUniqueDirList();
int GlobalUniqueDirChkIfAlreadyThere(char *TheStringToCheck);
int GlobalUniqueDirReturnMyIndexMatch(char *TheStringToCheck);

//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
    int argno;
    int nflags=0;
    char ini_filename_dir[_MAX_PATH];
    char ini_filename_only[_MAX_FNAME];
    char ini_filename_ext[_MAX_EXT];

    ini_filename_only[0]='\0';
    g_szinput_platform[0]='\0';

    GetThisModuleName();

    // Get current directory
    GetCurrentDirectory( _MAX_PATH, g_szCurrentDir);

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
            nflags++;
            switch (argv[argno][1])
                {
                case 'd':
				case 'D':
					g_bOutputDetails = FALSE;
                    break;
                case 'b':
                    break;
				case 'N':
                case 'n':
					g_bCabbing_Flag = FALSE;
                    break;
				case 'X':
                case 'x':
					g_bDisplayToScreen = TRUE;
                    break;
				case 'T':
				case 't':
					strncpy (g_szFilenameTag, &argv[argno][2], sizeof(g_szFilenameTag));
					break;
                case '?':
                    goto exit_with_help;
                    break;
                }
            } // if switch character found
        else
            {
            if ( *ini_filename_only == '\0' )
                {
                // if no arguments, then
                // get the ini_filename_dir and put it into
                strcpy(g_szinput_filename_full, argv[argno]);
                ini_filename_dir[0] = '\0';
                // split up this path
                _splitpath( g_szinput_filename_full, NULL, ini_filename_dir, ini_filename_only, ini_filename_ext);

                strcat(ini_filename_only, ini_filename_ext);
                // if we're missing dir, then get it.
                if (*ini_filename_dir == '\0')
                    {
                    // stick current dir into our variable
                    strcpy(ini_filename_dir, g_szCurrentDir);
                    strcpy(g_szinput_filename_full, g_szCurrentDir);
                    strcat(g_szinput_filename_full, "\\");
                    strcat(g_szinput_filename_full, ini_filename_only);
                    }
                }
            else
                {
                // Additional filenames (or arguments without a "-" or "/" preceding)
                //goto exit_with_help;
                // should be the section to execute.
                strcpy(g_szinput_platform, argv[argno]);
                }
            } // non-switch char found
        } // for all arguments

    
    // check if filename was specified
    // check if section name was specified
    if ( *ini_filename_only == '\0' || *g_szinput_platform == '\0')
        {
        printf("Too few arguments, argc=%d\n\n",argc);
        goto exit_with_help;
        }

    // Check if the file exists!
    if (FALSE == DoesFileExist(g_szinput_filename_full))
        {
        printf("INI file %s, does not exist!.\n", g_szinput_filename_full);
        goto exit_gracefully;
        }

    // Check if g_szinput_platform is one of the available options
    strcpy(g_szinput_platform, g_szinput_platform);

    if ( (_stricmp(g_szinput_platform, NTS_X86) != 0) && (_stricmp(g_szinput_platform, NTW_X86) != 0) && (_stricmp(g_szinput_platform, WIN95) != 0) && (_stricmp(g_szinput_platform, WIN98) != 0) && (_stricmp(g_szinput_platform, NTS_ALPHA) != 0) && (_stricmp(g_szinput_platform, NTW_ALPHA) != 0) && (_stricmp(g_szinput_platform, OTHER_OS) != 0))
        {
        printf("2nd parameter must be one of %s,%s,%s,%s,%s,%s or %s.\n", NTS_X86, NTW_X86, WIN95, WIN98, NTS_ALPHA, NTW_ALPHA, OTHER_OS);
        goto exit_gracefully;
        }

    // Fine, process the ini file.
    char    stempstring[100];
    sprintf(stempstring, "Start %s.\n", g_szModuleFilename);
    printf(stempstring);
    printf("---------------------------------------------------\n");

    // We have at least g_szinput_platform and g_szinput_filename_full defined

    // run the function to do everything
    Flat_ProcessFile();


exit_gracefully:
    printf("---------------------------------------------------\n");
    printf("Done.\n");
    return TRUE;

exit_with_help:
    ShowHelp();
    return FALSE;

}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_ProcessFile()
{
    ifstream inputfile;
    char fileinputbuffer[1000];

    char    stempstring[100];

    Flat_GlobalArrayIndex_Main.total=0;  Flat_GlobalArrayIndex_Main.nextuse=0;
    Flat_GlobalArrayIndex_Err.total=0;   Flat_GlobalArrayIndex_Err.nextuse=0;

    // Get output file names
    strcpy(g_szDDFOutput, g_szModuleFilename);
    strcat(g_szDDFOutput, ".DDF");
    strcpy(g_szINFOutput, g_szModuleFilename);
    strcat(g_szINFOutput, ".INF");

    strcpy(g_szLSTOutput, g_szModuleFilename);
    strcat(g_szLSTOutput, ".LST");

    strcpy(g_szCATOutput, g_szModuleFilename);
    strcat(g_szCATOutput, ".CAT");
	// Delete this file
	DeleteFile(g_szCATOutput);

    strcpy(g_szNOTExistOutput, g_szModuleFilename);
    strcat(g_szNOTExistOutput, ".NOT");
	// Delete this file
	DeleteFile(g_szNOTExistOutput);


	
    // Read flat file and put into huge array
    inputfile.open(g_szinput_filename_full, ios::in);
    inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer));
    do
    {
        // check for any comments, don't add these to the array.
        if (strchr(fileinputbuffer, ';') != NULL) {*(strrchr(fileinputbuffer, ';')) = '\0';}
        if (*fileinputbuffer)
        {
            // Remove spaces
            char *p;
            p = fileinputbuffer;
	    RemoveAllSpaces(p);

            // Take line, parse it and put it into our global file structure.
            // Do only for our platform!!!!
            Flat_GlobalArray_Fill(fileinputbuffer);
        }
    } while (inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer)));

	inputfile.close();

    // OK, all entries should be in the global_main array
    // and all the "extra" entries should be in there too..

	// add a "IIS" to the font of any filename
	Flat_GlobalArray_Prepend_UniqueString();

    // 1. loop thru the global array and mark any filenames for duplicates..
    Flat_GlobalArray_Sort_Cols2(TRUE);
    Flat_GlobalArray_ChkDups();

    // 2. sort on #1 cab file, then on #2 section
    Flat_GlobalArray_Sort_Cols2(FALSE);
	if (g_bOutputDetails == TRUE) {Flat_GlobalArray_Print();}
	
    //printf("\n\n sorted by cab and section...\n");

    // 3. loop thru the list and create .DDF file
    sprintf(stempstring, "Creating DDF file...%s\n",g_szDDFOutput);
    printf(stempstring);
	if (g_bCabbing_Flag) {Flat_Create_Output_DDF();}
	

    // Sort on sections
    Flat_GlobalArray_Sort_Cols1a(FALSE);
    //printf("\n\n sorted by section...\n");
	if (g_bDisplayToScreen) Flat_GlobalArray_Print();

    // 4. loop thru the list and create .INF file
    sprintf(stempstring, "Creating INF file...%s\n",g_szINFOutput);
    printf(stempstring);

	Flat_Create_Output_INF();

	printf("\nTotals:\n");
	Global_TotalCabFileSize_Compute();
	Global_TotalCabFileSize_Print();

    printf("\nErrors/Warnings:\n");
    Flat_GlobalArray_Print_Err();

    Flat_Create_Output_ERR();

    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Fill(char fileinputbuffer[])
{
    char *token;
    int  token_count;
    char thetempstring[MAX_STRING];
    char tempstring[255];
    char temperrorwords[255] = "";
    FileReadLine tempentry = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0};
    FileReadLine theentry = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0};

    strcpy(thetempstring, fileinputbuffer);

    // get the first token
    token = strtok2( thetempstring, delimiters );
    token_count = 0;

    // Add entry to Global Array, convert to all lowercase

    // parse out platforms
    if (token == NULL) {goto Exit_Flat_FillGlobalArray_Main;}
    strcpy(temperrorwords, "x86_NTS_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTS_x86_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}
    strcpy(temperrorwords, "x86_NTW_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTW_x86_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}

    strcpy(temperrorwords, "Win95_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Win95_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}

    strcpy(temperrorwords, "Win98_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Win98_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}

    strcpy(temperrorwords, "NTS_alpha_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTS_alpha_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}
    strcpy(temperrorwords, "NTW_alpha_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTW_alpha_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}

    strcpy(temperrorwords, "Other_os_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Other_os_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}


    // do only for our specified platform!
    if ( (tempentry.NTS_x86_flag==0) && (_stricmp(g_szinput_platform,NTS_X86) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.NTW_x86_flag==0) && (_stricmp(g_szinput_platform,NTW_X86) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}

    if ( (tempentry.Win95_flag==0) && (_stricmp(g_szinput_platform,WIN95) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.Win98_flag==0) && (_stricmp(g_szinput_platform,WIN98) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}


    if ( (tempentry.NTS_alpha_flag==0) && (_stricmp(g_szinput_platform,NTS_ALPHA) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.NTW_alpha_flag==0) && (_stricmp(g_szinput_platform,NTW_ALPHA) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}

    if ( (tempentry.Other_os_flag==0) && (_stricmp(g_szinput_platform,OTHER_OS) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
	
    strcpy(temperrorwords, "Cabfilename");
    strcpy(tempentry.CabFileName, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}
    strcpy(temperrorwords, "INF_Sections");
    strcpy(tempentry.INF_Sections, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}
    strcpy(temperrorwords, "Filename_Full");
    strcpy(tempentry.Filename_Full, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
    strcpy(temperrorwords, "INF_Rename_To");
    strcpy(tempentry.INF_Rename_To, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
    strcpy(temperrorwords, "DDF_Exclude_From_Cab_Flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.DDF_Exclude_From_Cab_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}

    strcpy(temperrorwords, "Do_Not_Show_Error_Flag");
	if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Do_Not_Show_Error_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}

    strcpy(temperrorwords, "Do_Not_Include_file_if_cabEmpty_Flag");
	if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Do_Not_Include_file_if_cabEmpty_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
	

    
MoveToGlobals:
    if (!(tempentry.Filename_Full)) {goto Exit_Flat_FillGlobalArray_Main;}
    // Check for wildcards in position array in filename position #2
    int   attr;
    char filename_dir[_MAX_PATH];
    char filename_only[_MAX_FNAME];

    // Get the filename portion
    _splitpath( tempentry.Filename_Full, NULL, filename_dir, filename_only, NULL);
    attr= 0;
    if (_stricmp(filename_only, "*.*") == 0)
        {attr=ALL_FILES;}

    // list thru the files
    long  hFile;
    finddata datareturn;

    InitStringTable(STRING_TABLE_SIZE);
    if ( FindFirst(tempentry.Filename_Full, attr, &hFile, &datareturn) )
        {
        // check if it's a sub dir
        if (!( datareturn.attrib & _A_SUBDIR))
            {
                // ok we found one.
                // let's add it to our list of stuff to add
                theentry = tempentry;

                char tempstring1[255];
                strcpy(tempstring1, filename_dir);
                strcat(tempstring1, datareturn.name);
                strcpy(theentry.Filename_Full, tempstring1);

                strcpy(tempstring1, datareturn.name);
                strcpy(theentry.Filename_Name, tempstring1);

                strcpy(tempstring1, filename_dir);
                strcpy(theentry.Filename_Path, tempstring1);

                strcpy(tempstring1, datareturn.name);
                strcpy(theentry.DDF_Renamed, tempstring1);

				theentry.FileName_Size = datareturn.size;

                // now take this entry and try to add it to the global array!!!
                Flat_GlobalArray_Add(theentry);
            }

        while(FindNext(attr, hFile, &datareturn))
            {
            // check if it's a sub dir
            if (!(datareturn.attrib & _A_SUBDIR))
                {
                // ok we found one.
                // let's add it to our list of stuff to add
                theentry = tempentry;

                char tempstring1[255];
                strcpy(tempstring1, filename_dir);
                strcat(tempstring1, datareturn.name);
                strcpy(theentry.Filename_Full, tempstring1);

                strcpy(tempstring1, datareturn.name);
                strcpy(theentry.Filename_Name, tempstring1);

                strcpy(tempstring1, filename_dir);
                strcpy(theentry.Filename_Path, tempstring1);

                strcpy(tempstring1, datareturn.name);
                strcpy(theentry.DDF_Renamed, tempstring1);

				theentry.FileName_Size = datareturn.size;

                // now take this entry and try to add it to the global array!!!
                Flat_GlobalArray_Add(theentry);
                }
            }

        }
    else
        // we didn't find the specified file.
        {
			// If this is a file which doesn't get into a cab, then
		    // let's add it to the .inf file section [SourceDisksFiles] later.
		    if (tempentry.DDF_Exclude_From_Cab_Flag)
			{
				    fstream f4;
					f4.open(g_szNOTExistOutput, ios::out | ios::app);

					char fullpath[_MAX_PATH];
					char * pmyfilename;
					char myPath[_MAX_PATH];
					pmyfilename = fullpath;

					// Resolve relative path to real path
					if (0 != GetFullPathName(tempentry.Filename_Full, _MAX_PATH, myPath, &pmyfilename))
					{
						// Take only the filename...

						// achg.htr=1,,1902
						strcpy(tempstring,pmyfilename);
						f4.write(tempstring, strlen(tempstring));
						strcpy(tempstring,"=0,,50000");
						f4.write(tempstring, strlen(tempstring));
						f4.write("\n", 1);

						// let's add it to our list of stuff to add
						theentry = tempentry;

						strcpy(theentry.Filename_Full, tempentry.Filename_Full);
						strcpy(theentry.Filename_Name, pmyfilename);

						_splitpath( tempentry.Filename_Full, NULL, theentry.Filename_Path, NULL, NULL);
						//strcpy(theentry.Filename_Path, myPath);
						strcpy(theentry.DDF_Renamed, pmyfilename);
						theentry.FileName_Size = 50000;

						printf(tempentry.Filename_Full);
						printf(".  FileWasNotActuallyFoundToExist1.\n");
						theentry.FileWasNotActuallyFoundToExist = TRUE;

						// now take this entry and try to add it to the global array!!!
						Flat_GlobalArray_Add(theentry);

					}
					f4.close();
			}
			else
			{
				// check if we're not supposed to show errors!
				if (tempentry.Do_Not_Show_Error_Flag == 0)
				{
					// add it to the error list.
					sprintf(tempstring, "ERROR: file not found--> %s --> %s", tempentry.Filename_Full, fileinputbuffer);
					Flat_GlobalArray_Add_Err(tempstring);
				}
			}
        }


    EndStringTable();


Exit_Flat_FillGlobalArray_Main:
        return;

InputParseError:
    sprintf(tempstring, "INFUTIL ERROR: %s should be numeric and is not--> %s", temperrorwords, fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;
InputParseError1:
    sprintf(tempstring, "INFUTIL ERROR: missing platform info--> %s", fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;
InputParseError2:
    sprintf(tempstring, "INFUTIL ERROR: missing %s--> %s", temperrorwords, fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;

}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_GlobalArray_Add(FileReadLine entrytoadd)
{
    FileReadLine Temp = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0};

    // check if this value already exists in the globalarary
    if (Flat_GlobalArray_EntryExists(entrytoadd)) return FALSE;
    
    // blankout the array values if any.
    Flat_GlobalArray_Main[Flat_GlobalArrayIndex_Main.nextuse] = Temp;

    // move info into global array
    Flat_GlobalArray_Main[Flat_GlobalArrayIndex_Main.nextuse] = entrytoadd;

    // increment counter to array
    // increment next use space
    ++Flat_GlobalArrayIndex_Main.total;
    ++Flat_GlobalArrayIndex_Main.nextuse;
    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_GlobalArray_EntryExists(FileReadLine theentry)
{
    int matchcount;

    // loop thru the whole list
    for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
    {
        // check if entries are the same.
        matchcount=0;
        if (_strnicmp(Flat_GlobalArray_Main[i0].CabFileName, theentry.CabFileName, lstrlen(theentry.CabFileName) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].INF_Sections, theentry.INF_Sections, lstrlen(theentry.INF_Sections) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].Filename_Full, theentry.Filename_Full, lstrlen(theentry.Filename_Full) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].Filename_Name, theentry.Filename_Name, lstrlen(theentry.Filename_Name) + 1) == 0 )
            {++matchcount;}
        if (matchcount == 4)
        {
            // we found a match!!! "WARNING: file already included"
            return TRUE;
        }
    }
    //. no matches... return FALSE.
    return FALSE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int IsThisStringInHere(LPTSTR  lpTemp, char szStringToCheck[])
{
    int     bFlag               = FALSE;

    // Lookup sections to see if they exists in ini file.
    if (*lpTemp != '\0')
        {
        // loop thru and process results
        bFlag = FALSE;
        while (*lpTemp)
            {
            // check if our section name is in there.
            if (_strnicmp(szStringToCheck, lpTemp, lstrlen(lpTemp) + 1) == 0 )
                {bFlag = TRUE;}
            lpTemp += (lstrlen(lpTemp) + 1);
            }

        // Check if our section was in there
        if (bFlag != TRUE)
            {return FALSE;}

        }

    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_DDFDoesThisFileCabAlreadyExists(int processeduptill)
{
    int i0;

    char CompareTo_cab[100];
    char CompareTo_fullfilename[100];

    strcpy(CompareTo_cab, Flat_GlobalArray_Main[processeduptill].CabFileName);
    strcpy(CompareTo_fullfilename, Flat_GlobalArray_Main[processeduptill].Filename_Full);

    for(i0=0;i0<processeduptill;i0++)
        {
        // check if global value has already been processed.
        // check if the cab is the same
        // check if the dir is the same
        // check if the filename is the same
        if (_stricmp(Flat_GlobalArray_Main[i0].CabFileName, CompareTo_cab) == 0)
            {
            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Full,CompareTo_fullfilename) == 0)
                {
                // if they both match, then shoot that means that we already printed this out.
                return TRUE;
                }
            }
        }

    return FALSE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void ShowHelp()
{
    printf("\n");
    printf("infutil - creates .ddf and .inf files from input file\n");
    printf("-----------------------------------------------------\n");
    printf("  Usage:\n");
    printf("       infutil /?DN <input file> <sectioname>\n\n");
	printf("  Params:\n");
    printf("       /? show this stuff\n");
	printf("       /D if set then don't show details\n");
	printf("       /N Produce INF File which will not require .ddf file (meaning no cabs)\n");
	printf("       /X Display output for debug\n");
	printf("       /Ttag Appends tag_ to the beginning of all filenames\n");
    printf("       <input filename> is a MSDOS file name.\n");
    printf("       <sectioname> is either %s,%s,%s,%s,%s,%s,%s.\n", NTS_X86, NTW_X86, WIN95, WIN98, NTS_ALPHA, NTW_ALPHA, OTHER_OS);
    printf("\n");
    printf("Example:\n");
    printf("       infutil.exe inifile.ini %s", NTS_X86);
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int DoesFileExist(char *input_filespec)
{
    if (GetFileAttributes(input_filespec) == -1)
    {
        return(FALSE);
    }
    return (TRUE);
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void GetPath(char * input_filespec, char * path, char * fs)
{
    char filespec[100];
    char * p;
    struct _stat s;

    strcpy(filespec, input_filespec);

        /* if filespec is a directory, interpret it to mean dir\*.* */
    if (_stat(filespec, &s) == 0 && s.st_mode & S_IFDIR)
        {
            /* root is special case */
        if ( (*filespec == '\\' && *(filespec+1) == '\0') ||
                 (*(filespec+1) == ':' && *(filespec+2) == '\\' && *(filespec+3)=='\0'))
            strcat(filespec, "*.*");
        else
            strcat(filespec, "\\*.*");
        }

        /* search string from end to beginning for back slash */
    p=filespec+strlen(filespec)-1;
    for(; p>filespec && *p != '\\' && *p != ':'; p--);
        /* is it a drive or path */
    if ( *p=='\\' || *p==':')
        {
        strncpy(path, filespec, DIFF(p-filespec)+1);
        path[p-filespec+1]='\0';
        strcpy(fs, p+1);
        }
    else /* no drive, path */
        {
            /* yep, no path */
        path[0]='\0';
        strcpy(fs, filespec);
        }

} /* GetPath */


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int strltrim(LPSTR & thestring)
{
    char * p = NULL;

    p = thestring;

    // check for spaces to the right
    if (*p ==' ')
        {
        while (*p == ' ')
            {p += (lstrlen((char*) *p) + 1);}

        thestring = p;
        printf("%s testing..", p);
        return TRUE;
        }
    return FALSE;
}



//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void MakeDirIfNeedTo(char thestring[])
{
    char tempstring[255];
    // Check the string to see if there are any "\"'s in the string
    // if there are then let's remove the filename and make the directory
    if (strchr(thestring, '\\') != NULL)
        {
        strcpy(tempstring, thestring);
        // remove the filename
        *(strrchr(tempstring, '\\')) = '\0';

        // ok now we have the path
        // let's create the directory
        _mkdir(tempstring);

        }
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void GetThisModuleName(void)
{
    char    szfilename_only[_MAX_FNAME];
    char    szPath[_MAX_PATH];
    // Get the path
    GetModuleFileName(NULL, szPath, _MAX_PATH);
    // split up this path and take filename only
    _splitpath( szPath, NULL, NULL, szfilename_only, NULL);

    // set global variable with it
    strcpy(g_szModuleFilename, szfilename_only);
    return;
}

void Flat_GlobalArray_Prepend_UniqueString(void)
{
    //char Filename_Full[_MAX_PATH];
    //char Filename_Name[_MAX_FNAME];
    //char Filename_Path[_MAX_PATH];
    //char DDF_Renamed[_MAX_PATH];
    //char INF_Rename_To[_MAX_FNAME];

    char filename_only[_MAX_FNAME];
    char filename_ext[_MAX_EXT];
	char NewFilename[_MAX_FNAME];

	int i0 =0;
	for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
	{
		if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 0)
		{
			// Tack on the IIS Tag.
			_splitpath( Flat_GlobalArray_Main[i0].Filename_Full, NULL, NULL, filename_only, filename_ext);
			if (filename_ext)
				{sprintf(NewFilename, "%s_%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s_%s", g_szFilenameTag, filename_only);}

			// re-create the full name
			//sprintf(Flat_GlobalArray_Main[i0].Filename_Full, "%s%s", Flat_GlobalArray_Main[i0].Filename_Path, NewFilename);
			// re-create the filename only
			//strcpy(Flat_GlobalArray_Main[i0].Filename_Name, NewFilename);

			_splitpath( Flat_GlobalArray_Main[i0].DDF_Renamed, NULL, NULL, filename_only, filename_ext);
			if (filename_ext)
				{sprintf(NewFilename, "%s_%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s_%s", g_szFilenameTag, filename_only);}

			// re-create the filename
			strcpy(Flat_GlobalArray_Main[i0].DDF_Renamed, NewFilename);

			/*
			_splitpath( Flat_GlobalArray_Main[i0].INF_Rename_To, NULL, NULL, filename_only, filename_ext);
			if (filename_only)
			{
			if (filename_ext)
				{sprintf(NewFilename, "%s_%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s_%s", g_szFilenameTag, filename_only);}
			// re-create the filename
			strcpy(Flat_GlobalArray_Main[i0].INF_Rename_To, NewFilename);
			}
			*/
		}
	}
}


//-------------------------------------------------------------------
//  purpose: check for duplicate filenames
//-------------------------------------------------------------------
void Flat_GlobalArray_ChkDups(void)
{
    int i0 =0;
    int i1 =0;
    int i3 = 0;
    char filetemp[255];
    char filetempwhole[255];
    int theflag = FALSE;
    char checkagainst[255];
    int foundtheflag2 = FALSE;
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        if (Flat_IsFileNameDup(i0))
            {
            printf (".");
            i1 = 0;
            // if the file exists outside a cab, then do not rename.
            // only rename files which exist in the cab.
            if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 0)
            {
                do
                {
                    theflag = FALSE;
                    // Give it a new name.
                    // then check if the name already exists.
                    i1++;
if (g_bCabbing_Flag != TRUE)
{
#ifdef USENEW
					if (i1 == 1)
					{
						// Count how many directory levels in There.
						int iDirLevelCount = 0;
						int z1 = 0;
						iDirLevelCount = ReturnDirLevelCount(Flat_GlobalArray_Main[i0].Filename_Full);

						strcpy(filetemp, Flat_GlobalArray_Main[i0].Filename_Path);
						if (iDirLevelCount >=1)
						{
							for( z1 = 0; z1 < iDirLevelCount;z1++)
								{strcat(filetemp, "..\\");}
						}
						
						/*

						strcpy(filetemp, "");
						if (iDirLevelCount >=1)
						{
							for( z1 = 0; z1 < iDirLevelCount;z1++)
								{strcat(filetemp, "..\\");}
						}
						strcat(filetemp, Flat_GlobalArray_Main[i0].Filename_Path);						
						*/

						// add the filename
						strcat(filetemp, Flat_GlobalArray_Main[i0].Filename_Name);
						
						strcpy(filetempwhole,filetemp);
					}
					else
					{
						sprintf(filetemp, "%s_%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Full, i1);
						strcpy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path);
						strcat(filetempwhole, filetemp);
					}
#else
                    sprintf(filetemp, "%s_%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Name, i1);
                    strcpy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path);
                    strcat(filetempwhole, filetemp);
#endif
}
else
{
                    sprintf(filetemp, "%s_%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Name, i1);
                    strcpy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path);
                    strcat(filetempwhole, filetemp);
}
                
                    // check if the file exists..

                    // check if it already exists in our list...
                    strcpy(checkagainst, filetempwhole);
                    foundtheflag2= FALSE;

                    for (i3=0;i3<Flat_GlobalArrayIndex_Main.total;i3++)
                        {
                        if (i3 != i0)
                            {
                            if (_stricmp(Flat_GlobalArray_Main[i3].Filename_Name, filetemp) == 0)
                                {foundtheflag2= TRUE;}
                            else
                                {
                                if (_stricmp(Flat_GlobalArray_Main[i3].DDF_Renamed, filetemp) == 0)
                                    {foundtheflag2= TRUE;}
                                }
                            }
                        }

                    if (foundtheflag2 == FALSE)
                    {

                    // check if it already exists in the filesystem...
                    int   attr = 0;
                    long  hFile = 0;
                    finddata datareturn;
                    InitStringTable(STRING_TABLE_SIZE);
                    if ( FindFirst(filetempwhole, attr, &hFile, &datareturn) )
                        {
                        // shoot that blows, it already exists
                        // do it again.
                        theflag = FALSE;
                        }
                    else
                        {
                            theflag = TRUE;
                        }

                    }

                } while (theflag == FALSE);
            // Add to the ddf renamedfile place
            strcpy(Flat_GlobalArray_Main[i0].DDF_Renamed, filetemp);
            }
            
            }
        }
    printf ("\n");
    return;
}


//-------------------------------------------------------------------
//  purpose: check for duplicate filenames in filename column
//-------------------------------------------------------------------
int Flat_IsFileNameDup(int indextocheck)
{
	int iReturn = FALSE;
    int i0;
    char checkagainst[255];
    char checkagainst2[255];

    // check for exact duplicate.
    // if it is then we can't have any of these
    // Return false, because we will remove this entry later
    // it should return false, because the files are identical and do not need to be renamed.
    strcpy(checkagainst, Flat_GlobalArray_Main[indextocheck].Filename_Full);
    strcpy(checkagainst2, Flat_GlobalArray_Main[indextocheck].Filename_Name);
//    for (i0=0;i0<Flat_GlobalArrayIndex_Main.total;i0++)
    for (i0=0;i0<indextocheck;i0++)
        {
		iReturn = FALSE;
        if (i0 != indextocheck)
            {
			/*
			if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst2) == 0)
			{
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, "global.asa") == 0)
				{
				printf(":");
				printf(Flat_GlobalArray_Main[i0].Filename_Full);
				printf("(");printf(Flat_GlobalArray_Main[i0].Filename_Name);printf(")");
				printf("[");printf(Flat_GlobalArray_Main[i0].DDF_Renamed);printf("]");

				printf(":");
				printf(Flat_GlobalArray_Main[indextocheck].Filename_Full);
				printf("(");printf(Flat_GlobalArray_Main[indextocheck].Filename_Name);printf(")");
				printf("[");printf(Flat_GlobalArray_Main[indextocheck].DDF_Renamed);printf("]");
				printf("\n");
				}
			}
			*/

            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Full, checkagainst) == 0)
                {
				// We have a duplicate which we will ignore!
				//printf(Flat_GlobalArray_Main[i0].Filename_Full);
				//printf(".  Duplicate.1.!!!!\n");
				_stricmp(Flat_GlobalArray_Main[indextocheck].DDF_Renamed, Flat_GlobalArray_Main[i0].DDF_Renamed);
				iReturn = FALSE;
				goto Flat_IsFileNameDup_Exit;
				}
            else
                {
                if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst2) == 0)
                    {
						// We have  a duplicate, check if this one has already been renamed though.
						if (_stricmp(Flat_GlobalArray_Main[i0].DDF_Renamed, checkagainst2) == 0)
						{
							//printf(".  Duplicate.2.!!!!\n");
							iReturn = TRUE;
							goto Flat_IsFileNameDup_Exit;
						}
						else
						{
							// check if what we are renaming indextocheck to, is the same as DDF_Renamed...
							if (_stricmp(Flat_GlobalArray_Main[i0].DDF_Renamed, Flat_GlobalArray_Main[indextocheck].DDF_Renamed) == 0)
							{
								//(".  Duplicate.3.!!!!\n");
								iReturn = TRUE;
								goto Flat_IsFileNameDup_Exit;
							}
						}

                    }

                }
            }

		// go on to the next one....
        }

    /*
    // Check for filename duplicate only
    strcpy(checkagainst, Flat_GlobalArray_Main[indextocheck].Filename_Name);
    for (i0=0;i0<Flat_GlobalArrayIndex_Main.total;i0++)
        {
        if (i0 != indextocheck)
            {
            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst) == 0)
                {return TRUE;}
            }
        }
        */
Flat_IsFileNameDup_Exit:
    return iReturn;
}


//-------------------------------------------------------------------
//  purpose: sort on CabFileName, then on Filename_Path
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols2(BOOL bDescendFlag)
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    int swapflag;

    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {
            swapflag = FALSE;
            result = _stricmp(Flat_GlobalArray_Main[i].CabFileName, Flat_GlobalArray_Main[j].CabFileName);

            if (bDescendFlag)
            {
                if (result < 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Path, Flat_GlobalArray_Main[j].Filename_Path);
                            if (result < 0)
								{swapflag = TRUE;}
							else
							{
								if (result ==0)
								result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
								if (result < 0)
									{swapflag = TRUE;}
							}
                        }
                    }
            }
            else
            {
                // check if larger
                if (result > 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Path, Flat_GlobalArray_Main[j].Filename_Path);
                            // check if larger
                            if (result > 0)
								{swapflag = TRUE;}
							else
							{
								if (result ==0)
								result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
								if (result > 0)
									{swapflag = TRUE;}
							}
                        }
                    }
            }


            if (swapflag == TRUE)
                {
                inorder = FALSE;

                // do the swap
                // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;
                }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}

//-------------------------------------------------------------------
//  purpose: sort on INF_Sections only
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols1()
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {

            result = _stricmp(Flat_GlobalArray_Main[i].INF_Sections, Flat_GlobalArray_Main[j].INF_Sections);
            if (result > 0)
            {
                inorder = FALSE;

                // do the swap
                 // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;

            }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}


//-------------------------------------------------------------------
//  purpose: sort on INF_Sections then on filename
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols1a(BOOL bDescendFlag)
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    int swapflag;

    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {
            swapflag = FALSE;
            result = _stricmp(Flat_GlobalArray_Main[i].INF_Sections, Flat_GlobalArray_Main[j].INF_Sections);

            if (bDescendFlag)
            {
                if (result < 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
                            if (result < 0){swapflag = TRUE;}
                        }
                    }
            }
            else
            {
                // check if larger
                if (result > 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
                            // check if larger
                            if (result > 0){swapflag = TRUE;}
                        }
                    }
            }


            if (swapflag == TRUE)
                {
                inorder = FALSE;

                // do the swap
                // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;
                }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}



//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Print(void)
{
    int  i0;
    int  total;
    char bigtemp[20];

    total = Flat_GlobalArrayIndex_Main.total;

    for( i0 = 0; i0 < total;i0++)
        {
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTS_x86_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTW_x86_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Win95_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Win98_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTS_alpha_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTW_alpha_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Other_os_flag);
        printf (bigtemp); printf(",");

        printf(Flat_GlobalArray_Main[i0].CabFileName);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].INF_Sections);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Full);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Name);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Path);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].DDF_Renamed);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].INF_Rename_To);
        printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag);
        printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Do_Not_Show_Error_Flag);
		printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Do_Not_Include_file_if_cabEmpty_Flag);
		printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].FileName_Size);
		printf (bigtemp);
		printf ("\n");
        }

    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_Create_Output_INF(void)
{
    int i0;
    fstream f;
	fstream f2;
    fstream f3;
    char last_section[255];
    char this_section[255];
    char tempstring[255];
    char fullpath[_MAX_PATH];

	f.open(g_szINFOutput, ios::out);
    f3.open(g_szCATOutput, ios::out);


if (g_bCabbing_Flag == TRUE)
{
	// Produce .inf file for use with .ddf file
	// for generating cabs!!!
	// ----------------------------------------
	
	// Produce the top half -- the sections
	// bottom half -- producted by diamond using.ddf file
	// ------------------------------------
    strcpy(last_section, " ");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        strcpy(this_section, Flat_GlobalArray_Main[i0].INF_Sections);

        // For each new section change.
        if (_stricmp(this_section, last_section) != 0)
            {
            // print out new section stuff
            f.write("\n", 1);
            sprintf(tempstring, "[%s]\n", this_section);
            f.write (tempstring, strlen(tempstring));

            strcpy(last_section, this_section);
            }

		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{
            // write it out to the .cat file
//            strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
//            // take out trailing spaces.
//            f3.write(tempstring, strlen(tempstring));

            TCHAR * pmyfilename;
            pmyfilename = fullpath;
            TCHAR myPath[_MAX_PATH];
            // Resolve relative path to real path
            if (0 != GetFullPathName(Flat_GlobalArray_Main[i0].Filename_Full, _MAX_PATH, myPath, &pmyfilename))
            {
            // should look like this
            // <HASH>d:\mydir\myfile=d:\mydir\myfile
            strcpy(tempstring,"<HASH>");
            f3.write(tempstring, strlen(tempstring));

            strcpy(tempstring,myPath);
            f3.write(tempstring, strlen(tempstring));

            strcpy(tempstring,"=");
            f3.write(tempstring, strlen(tempstring));

            strcpy(tempstring,myPath);
            f3.write(tempstring, strlen(tempstring));
            }

			// Check if this file has the rename stuff set and additional info there,
			// don't write the \n until past this part..
			if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				{
				// write out the filename!
				// print out the filename
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					{
					strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
					f.write (tempstring, strlen(tempstring));
                    // append on overwrite all the time
                   // notice the two commas!
                    //f.write (",,4",3);
					}
				else
					{
					// rename to:
					strcpy(tempstring, Flat_GlobalArray_Main[i0].Filename_Name);
					f.write (tempstring, strlen(tempstring));
					// rename from:
					strcpy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed);
					f.write (",",1);
					f.write (tempstring, strlen(tempstring));
                    // append on overwrite all the time
                    //f.write (",4",2);
					}
				}
			else
				{
				// the rename flag was set and the filename is in there.
				// format:  rename to, rename from

				// rename to:
				strcpy(tempstring, Flat_GlobalArray_Main[i0].INF_Rename_To);
				f.write (tempstring, strlen(tempstring));

				// rename from:
				strcpy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed);
				f.write (",",1);
				f.write (tempstring, strlen(tempstring));

                // append on overwrite all the time
                //f.write (",4",2);

				}
		}

        // ok, now it's kool to write this part.
        f.write("\n", 1);
        f3.write("\n", 1);
        }

	f.close();
    f3.close();

}
else
{
	// Produce .inf file for use without anything else!!!
	// no need corresponding .ddf file for these!!!
	// ----------------------------------------

	// Produce the top half -- the sections
	// ------------------------------------
    strcpy(last_section, " ");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        strcpy(this_section, Flat_GlobalArray_Main[i0].INF_Sections);

        // For each new section change.
        if (_stricmp(this_section, last_section) != 0)
            {
            // print out new section stuff
            f.write("\n", 1);
            sprintf(tempstring, "[%s]\n", this_section);
            f.write (tempstring, strlen(tempstring));

            strcpy(last_section, this_section);
            }

#ifdef USENEW
		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{
			// Check if this file has the rename stuff set and additional info there,
			// don't write the \n until past this part..
			if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				{
				// write out the filename!
				// print out the filename
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					{
					strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
					f.write (tempstring, strlen(tempstring));
                    // append on overwrite all the time
                   // notice the two commas!
                    //f.write (",,4",3);

					}
				else
					{
					// rename to:
					strcpy(tempstring, Flat_GlobalArray_Main[i0].Filename_Name);
					f.write (tempstring, strlen(tempstring));

					// rename from:
					strcpy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed);
					f.write (",",1);
					f.write (tempstring, strlen(tempstring));
                    // append on overwrite all the time
                    //f.write (",4",2);

					}
				}
			else
				{
				// the rename flag was set and the filename is in there.
				// format:  rename to, rename from

				// rename to:
				strcpy(tempstring, Flat_GlobalArray_Main[i0].INF_Rename_To);
				f.write (tempstring, strlen(tempstring));

				// rename from:
				strcpy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed);
				f.write (",",1);
				f.write (tempstring, strlen(tempstring));
                    // append on overwrite all the time
                    //f.write (",4",2);

				}
		}
#else
			// write out the filename!
			// like this: filename.txt, inetsrv\test\test\filename.txt
			strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
			f.write (tempstring, strlen(tempstring));
			strcpy(tempstring, ",");
			f.write(tempstring, strlen(tempstring));
            strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Full);
            f.write (tempstring, strlen(tempstring));
#endif
        
		f.write("\n", 1);
        }

	// Produce the bottom half -- the sections
	// ------------------------------------
	// use f2 for some other batch processing.
 	f2.open(g_szLSTOutput, ios::out);

	//[SourceDisksNames]
	//; file names and associated disks
	//; diskid = description,tagfile,unused,subdir
	//0="Setup Files","",0
	f.write("\n\n", 2);
	strcpy(tempstring, "[SourceDisksNames]\n");
    f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, ";Filenames and asociated disks\n");
	f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, ";diskid = description,tagfile,unused,subdir\n");
    f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	FillGlobalUniqueDirList();
	//0="Setup Files","",inetsrv
	//1="Setup Files","",inetsrv\help
	//2="Setup Files","",inetsrv\help\testing
int i9;
	for( i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	{
		// REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		char tempdir[_MAX_PATH];
		char *temppointer = NULL;
		strcpy(tempdir, Flat_GlobalUniqueDirList[i9]);
		temppointer = strrchr(tempdir, '\\');
		if (temppointer) { (*temppointer) = '\0';}

		sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		f.write(tempstring, strlen(tempstring));
	}
#else
	strcpy(tempstring, "0 = \"Setup Files\", \"\",0, \"\"\n");
    f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, "\n\n");
    f.write(tempstring, strlen(tempstring));
#endif

	//[SourceDisksNames.x86]
	//; file names and associated disks
	//; diskid = description,tagfile,unused,subdir
	//0="Setup Files","",0
	f.write("\n\n", 2);
	strcpy(tempstring, "[SourceDisksNames.x86]\n");
    f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, ";Filenames and asociated disks\n");
	f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, ";diskid = description,tagfile,unused,subdir\n");
    f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	FillGlobalUniqueDirList();
	//0="Setup Files","",inetsrv
	//1="Setup Files","",inetsrv\help
	//2="Setup Files","",inetsrv\help\testing
	for(i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	{
		// REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		char tempdir[_MAX_PATH];
		char *temppointer = NULL;
		strcpy(tempdir, Flat_GlobalUniqueDirList[i9]);
		temppointer = strrchr(tempdir, '\\');
		if (temppointer) { (*temppointer) = '\0';}

		sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		f.write(tempstring, strlen(tempstring));
	}
#else
	strcpy(tempstring, "0 = \"Setup Files\", \"\",0, \"\",\i386\n");
    f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, "\n\n");
    f.write(tempstring, strlen(tempstring));
#endif

	//[SourceDisksNames.Alpha]
	//; file names and associated disks
	//; diskid = description,tagfile,unused,subdir
	//0="Setup Files","",0
	f.write("\n\n", 2);
	strcpy(tempstring, "[SourceDisksNames.Alpha]\n");
    f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, ";Filenames and asociated disks\n");
	f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, ";diskid = description,tagfile,unused,subdir\n");
    f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	FillGlobalUniqueDirList();
	//0="Setup Files","",inetsrv
	//1="Setup Files","",inetsrv\help
	//2="Setup Files","",inetsrv\help\testing
	for(i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	{
		// REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		char tempdir[_MAX_PATH];
		char *temppointer = NULL;
		strcpy(tempdir, Flat_GlobalUniqueDirList[i9]);
		temppointer = strrchr(tempdir, '\\');
		if (temppointer) { (*temppointer) = '\0';}

		sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		f.write(tempstring, strlen(tempstring));
	}
#else
	strcpy(tempstring, "0 = \"Setup Files\", \"\",0, \"\",\Alpha\n");
    f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, "\n\n");
    f.write(tempstring, strlen(tempstring));
#endif




	//; filename_on_source = diskid,subdir,size,checksum,spare,spare
	//[SourceDisksFiles]
	//_default.pif = 1,,1024,,,,,1,3
	strcpy(tempstring, "; filename_on_source = diskid,subdir,size,checksum,spare,spare\n");
    f.write(tempstring, strlen(tempstring));
	strcpy(tempstring, "[SourceDisksFiles]\n");
    f.write(tempstring, strlen(tempstring));

    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
		// filename and directory
		// filename.txt = 0,subdirectory
		//sprintf(tempstring, "%s = 0\n", Flat_GlobalArray_Main[i0].Filename_Full);
#ifdef USENEW
		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{
			// Check if this file has the rename stuff set and additional info there,
			// don't write the \n until past this part..
			if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				{
				// write out the filename!
				// print out the filename

//[SourceDisksFiles]
//..\test1\cfw.pdb=2,,2
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					{
					int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
					sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].Filename_Name, indexmatch);
					f.write (tempstring, strlen(tempstring));
					}
				else
					{
					// rename from:
					int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
					sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].DDF_Renamed,indexmatch);
					f.write (tempstring, strlen(tempstring));
					}
				}
			else
				{
				// the rename flag was set and the filename is in there.
				// rename from:
				int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
				sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].DDF_Renamed,indexmatch);
				f.write (tempstring, strlen(tempstring));
				}
		}
		f.write("\n", 1);
#else
		sprintf(tempstring, "%s\n", Flat_GlobalArray_Main[i0].Filename_Full);
		f.write(tempstring, strlen(tempstring));
#endif
//if (strcmp(Flat_GlobalArray_Main[i0].Filename_Path, "") == 0)
//  {sprintf(tempstring, "%s;.\n", Flat_GlobalArray_Main[i0].Filename_Full);}
//else
//  {sprintf(tempstring, "%s;%s\n", Flat_GlobalArray_Main[i0].Filename_Full, Flat_GlobalArray_Main[i0].Filename_Path);}

		//sprintf(tempstring, "%s\\%s;%s\n", g_szCurrentDir,Flat_GlobalArray_Main[i0].Filename_Full,Flat_GlobalArray_Main[i0].Filename_Full);
		sprintf(tempstring, "%s\\%s\n", g_szCurrentDir,Flat_GlobalArray_Main[i0].Filename_Full);
		f2.write(tempstring, strlen(tempstring));
        }
	f2.close();
}

	f.close();
    return;
}


//-------------------------------------------------------------------
//  purpose: ok, loop thru the array and create the ddf details...
//-------------------------------------------------------------------
void Flat_Create_Output_DDF(void)
{
    fstream f;
    char thefilename[255];
    int i0;
    int i1;
    int i2;
    int i3;

    char last_cab[50];
    char last_sourcedir[255];
    char this_cab[50];
    char this_sourcedir[255];

    char tempstring[255];

    // used for list of all cab's
    char tempcablist[20][255];
    int tempcablist_nextuse;
    int tempcablist_total;
    int found;
    char temp_cab[50];

    // loop thru all globalarray stuff and get all the cab filenames and stick into the tempcablist.
    tempcablist_nextuse = 0;
    tempcablist_total = 0;
    for(i1=0;i1<Flat_GlobalArrayIndex_Main.total;i1++)
    {
        found=FALSE;
		if (Flat_DoWeIncludeThisFileCheck(i1) == TRUE)
		{
			strcpy(temp_cab, Flat_GlobalArray_Main[i1].CabFileName);
			// loop thru array to see if it's already there.
			for(i2=0;i2<tempcablist_total;i2++)
				{
				if (_stricmp(tempcablist[i2], temp_cab) == 0)
					{found=TRUE;}
				}
			if (found==FALSE)
				{
				// add it
				strcpy(tempcablist[tempcablist_nextuse],temp_cab);
				tempcablist_nextuse++;
				tempcablist_total++;
				}
		}
    }


    // ok, create our little output file...
    f.open(g_szDDFOutput, ios::out);
    strcpy(last_cab, "0");
    strcpy(last_sourcedir, "-");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        strcpy(this_cab, Flat_GlobalArray_Main[i0].CabFileName);
        strcpy(this_sourcedir, Flat_GlobalArray_Main[i0].INF_Sections);
        _splitpath( Flat_GlobalArray_Main[i0].Filename_Full, NULL, this_sourcedir, NULL, NULL);
        
		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{

        // For each Cab Type...
        if (_stricmp(this_cab, last_cab) != 0)
            {

            // Check if it is the first time!
            if (_stricmp(last_cab, "0") == 0)
                {
                strcpy(tempstring, "\n;***** LAYOUT SECTION (Generated) ***** \n");
                f.write (tempstring, strlen(tempstring));
                // print out all the cabinet names
                // loop thru the list of cabinet names and print them out.
                for(i2=0;i2<tempcablist_total;i2++)
                    {
                    sprintf(tempstring, "  .Set CabinetName%d=%s\n", i2+1, tempcablist[i2]);
                    f.write (tempstring, strlen(tempstring));
                    }
                f.write("\n", 1);

                // Set Generate INF=on!!!!
                strcpy(tempstring, ".Set GenerateInf=On\n");
                f.write (tempstring, strlen(tempstring));
                f.write("\n", 1);

                // Do files which don't get included into the cab files..
                strcpy(tempstring, ";*** Files not to include in Cab.\n");
                f.write (tempstring, strlen(tempstring));
                // Set source
                // list files.

                char last_filepath[255];
                char this_filepath[255];

				strcpy(g_non_cablist_temp[0].Filename_Name, "");
                g_non_cablist_temp_nextuse = 0;
                g_non_cablist_temp_total = 0;
                int itexists;

                for(i3=0;i3<Flat_GlobalArrayIndex_Main.total;i3++)
                    {
                    // check if this entry has the ddf_excludefromcab flag set.
                    if (Flat_GlobalArray_Main[i3].DDF_Exclude_From_Cab_Flag)
                        {
                        // add only if not already there...
                        itexists = FALSE;
                        for (int i6=0;i6<g_non_cablist_temp_total;i6++)
                            {
                            if (_stricmp(g_non_cablist_temp[i6].Filename_Name,Flat_GlobalArray_Main[i3].Filename_Name)==0)
                                {itexists = TRUE;}
                            }

                        if (itexists == FALSE)
                        {
                        // Add to our temporary array...
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTS_x86_flag = Flat_GlobalArray_Main[i3].NTS_x86_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTW_x86_flag = Flat_GlobalArray_Main[i3].NTW_x86_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].Win95_flag = Flat_GlobalArray_Main[i3].Win95_flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Win98_flag = Flat_GlobalArray_Main[i3].Win98_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTS_alpha_flag = Flat_GlobalArray_Main[i3].NTS_alpha_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTW_alpha_flag = Flat_GlobalArray_Main[i3].NTW_alpha_flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Other_os_flag = Flat_GlobalArray_Main[i3].Other_os_flag;
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].CabFileName,Flat_GlobalArray_Main[i3].CabFileName);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].INF_Sections,Flat_GlobalArray_Main[i3].INF_Sections);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Full,Flat_GlobalArray_Main[i3].Filename_Full);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Name,Flat_GlobalArray_Main[i3].Filename_Name);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Path,Flat_GlobalArray_Main[i3].Filename_Path);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].DDF_Renamed,Flat_GlobalArray_Main[i3].DDF_Renamed);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].INF_Rename_To,Flat_GlobalArray_Main[i3].INF_Rename_To);
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].DDF_Exclude_From_Cab_Flag = Flat_GlobalArray_Main[i3].DDF_Exclude_From_Cab_Flag;

                        g_non_cablist_temp[g_non_cablist_temp_nextuse].Do_Not_Show_Error_Flag = Flat_GlobalArray_Main[i3].Do_Not_Show_Error_Flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Do_Not_Include_file_if_cabEmpty_Flag = Flat_GlobalArray_Main[i3].Do_Not_Include_file_if_cabEmpty_Flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].FileName_Size = Flat_GlobalArray_Main[i3].FileName_Size;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].FileWasNotActuallyFoundToExist = Flat_GlobalArray_Main[i3].FileWasNotActuallyFoundToExist;

						/*
						if (Flat_GlobalArray_Main[i3].FileWasNotActuallyFoundToExist)
						{
						printf(Flat_GlobalArray_Main[i3].Filename_Full);
						printf(".  HEY..\n");
						}
						*/


                            g_non_cablist_temp_nextuse++;
                            g_non_cablist_temp_total++;
                            }
                        }
                    }


                // sort the array
                int offset, inorder, isort, jsort, niterate, resultsort; //, i0sort;
                //FileReadLine tempentrysort[MAX_ARRAY_SMALL];
				FileReadLine tempentrysort;
                niterate = g_non_cablist_temp_total;
                offset=niterate;
                do{
                    offset = (8 * offset) /11;
                    offset = (offset == 0) ? 1 : offset;
                    inorder = TRUE;
                    for (isort=0,jsort=offset;isort < (niterate - offset);isort++,jsort++)
                    {
                        resultsort = _stricmp(g_non_cablist_temp[isort].Filename_Path, g_non_cablist_temp[jsort].Filename_Path);
                        if (resultsort > 0)
                        {
                            inorder = FALSE;

                // do the swap
                // move into temp
                tempentrysort = g_non_cablist_temp[isort];

                // move into original
                g_non_cablist_temp[isort] = g_non_cablist_temp[jsort];

                // move temp into other
                g_non_cablist_temp[jsort] = tempentrysort;

				/* weird to stuff..
                            // do the swap
                             // move into temp
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
                                tempentrysort[i0sort] = g_non_cablist_temp[isort];
                                //strcpy(tempentrysort[i0sort].thestring,(g_non_cablist_temp[isort].thecol[i0sort].thestring));
                                }
                            // move into original
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
								// move into original
                                Flat_GlobalArray_Main[isort] = g_non_cablist_temp[jsort];
                                //strcpy( Flat_GlobalArray_Main[isort].thecol[i0sort].thestring, g_non_cablist_temp[jsort].thecol[i0sort].thestring);
                                }
                            // move temp into other
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
                                g_non_cablist_temp[jsort] = tempentrysort[i0sort];
                                //strcpy(g_non_cablist_temp[jsort].thecol[i0sort].thestring, tempentrysort[i0sort].thestring);
                                }
								*/
                        }
                    }
                } while (!(offset == 1 && inorder == TRUE));


                strcpy(tempstring, ".Set Compress=OFF\n");
                f.write (tempstring, strlen(tempstring));
                strcpy(tempstring, ".Set Cabinet=OFF\n");
                f.write (tempstring, strlen(tempstring));


                // loop thru our new array, and output stuff
                strcpy(last_filepath,"0");
                for (int i5=0;i5<g_non_cablist_temp_total;i5++)
                    {
                    strcpy(this_filepath, g_non_cablist_temp[i5].Filename_Path);

                    if (_stricmp(last_filepath, this_filepath) != 0)
                        {
                        // take the dir and write it out
                        f.write("\n", 1);
                        sprintf(tempstring, ".Set SourceDir=%s\n", this_filepath);
                        f.write (tempstring, strlen(tempstring));
                        strcpy(last_filepath, this_filepath);
                        }

					if (g_non_cablist_temp[i5].FileWasNotActuallyFoundToExist)
					{
						printf(g_non_cablist_temp[i5].Filename_Full);
						printf(".  FileWasNotActuallyFoundToExist.skip write to ddf..\n");
					}
					else
					{
						// print out the filename
						if (_stricmp(g_non_cablist_temp[i5].Filename_Name, g_non_cablist_temp[i5].DDF_Renamed) == 0)
							{strcpy(tempstring,g_non_cablist_temp[i5].Filename_Name);}
						else
							{
							strcpy(tempstring,g_non_cablist_temp[i5].Filename_Name);
							strcat(tempstring," ");
							strcat(tempstring,g_non_cablist_temp[i5].DDF_Renamed);
							}
						f.write (tempstring, strlen(tempstring));

						// files which are outside of the cab should have the unique flag set.
						// of cource, because they are all in the same place!!
						strcpy(tempstring, "\t/unique=yes");
						f.write (tempstring, strlen(tempstring));
						f.write("\n", 1);
					}
                    }



                f.write("\n", 1);

                // Files which do get included in the Cab
                strcpy(tempstring, ";*** Files to include in Cabs.\n");
                f.write (tempstring, strlen(tempstring));

                f.write(";\n", 2);
                sprintf(tempstring, ";  Cab File = %s\n", this_cab);
                f.write (tempstring, strlen(tempstring));
                f.write(";\n", 2);

                // Set cabinet on and compress on.
                strcpy(tempstring, ".Set Cabinet=on\n");
                f.write (tempstring, strlen(tempstring));
                strcpy(tempstring, ".Set Compress=on\n");
                f.write (tempstring, strlen(tempstring));

                }
            else
                {
                f.write("\n;\n", 3);
                sprintf(tempstring, ";  Cab File = %s\n", this_cab);
                f.write (tempstring, strlen(tempstring));
                f.write(";\n", 2);
                // Write new stuff for every new cabinet
                strcpy(tempstring, ".Set Cabinet=off\n");
                f.write (tempstring, strlen(tempstring));
                strcpy(tempstring, ".Set Cabinet=on\n");
                f.write (tempstring, strlen(tempstring));
                strcpy(tempstring, ".New Cabinet\n");
                f.write (tempstring, strlen(tempstring));
                }

            strcpy(last_cab, this_cab);
            }

        // Copy over the filename
        // don't copy over if the file should not be
        // included in the the cab file.
        //if (_stricmp(Flat_GlobalArray_Main[i0].thecol[COL_DDF_EXCLUDEFROMCAB].thestring,"true") != 0)
        if (!(Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag))
            {
            // don't copy over if the same file, in the same directory for the same cab file
            // exists already.  this could happen if they want the same file in different
            // sections....
            if (Flat_DDFDoesThisFileCabAlreadyExists(i0) == FALSE)
                {
				//if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE) {

					// For each new directory change
					if (_stricmp(this_sourcedir, last_sourcedir) != 0)
						{
						// print out new section stuff
						f.write("\n", 1);
						sprintf(tempstring, ".Set SourceDir=%s\n", this_sourcedir);
						f.write (tempstring, strlen(tempstring));

						strcpy(last_sourcedir, this_sourcedir);
						}

					// write out the filename!
					strcpy(thefilename, Flat_GlobalArray_Main[i0].Filename_Name);

					if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
						{
						// Check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].Filename_Name, ' ') != NULL)
							{
							strcpy(thefilename, "\"");
							strcat(thefilename,Flat_GlobalArray_Main[i0].Filename_Name);
							strcat(thefilename, "\"");
							}
						else
							{strcpy(thefilename,Flat_GlobalArray_Main[i0].Filename_Name);}
						}
					else
						{
						// Check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].Filename_Name, ' ') != NULL)
							{
							strcpy(thefilename, "\"");
							strcat(thefilename,Flat_GlobalArray_Main[i0].Filename_Name);
							strcat(thefilename, "\"");
							}
						else
							{
							strcpy(thefilename,Flat_GlobalArray_Main[i0].Filename_Name);
							}
						strcat(thefilename," ");

						// check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].DDF_Renamed, ' ') != NULL)
							{
							strcpy(thefilename, "\"");
							strcat(thefilename,Flat_GlobalArray_Main[i0].DDF_Renamed);
							strcat(thefilename, "\"");
							}
						else
							{
							strcat(thefilename,Flat_GlobalArray_Main[i0].DDF_Renamed);
							}
                    
						}

					f.write (thefilename, strlen(thefilename));

					// Check if this file has the unique flag set.
					// don't write the \n until past this part..
					/*if (_stricmp(Flat_GlobalArray_Main[i0].thecol[COL_DDF_UNIQUE].thestring,"true")) == 0)
						{
							strcpy(tempstring, "\t/unique=yes");
							f.write (tempstring, strlen(tempstring));
						}
						*/
					// ok, now it's kool to write this part.
					f.write ("\n", 1);
					//}
				}
            }
		}
	}
    f.close();
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_Create_Output_ERR(void)
{
    int i0;
    fstream f;
    char filename_only[255];
    char szPath[_MAX_PATH];
    char tempstring[MAX_STRING];

    // Get the path
    GetModuleFileName(NULL, szPath, _MAX_PATH);
    // split up this path
    _splitpath( szPath, NULL, NULL, filename_only, NULL);

    strcat(filename_only, ".ERR");

    // if there are any errors to report...
    if (Flat_GlobalArrayIndex_Err.total <= 0)
        {return FALSE;}

    // open the file
    f.open(filename_only, ios::out);

    // loop thru the errors and print out the errors
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Err.total;i0++)
        {
        strcpy(tempstring, (char*)Flat_GlobalArray_Err[i0]);
        f.write (tempstring, strlen(tempstring));
        f.write("\n", 1);
        }
        
    f.close();
    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Add_Err(char theentry[])
{
    // lets add it
    strcpy(Flat_GlobalArray_Err[Flat_GlobalArrayIndex_Err.nextuse], theentry);

    // increment counter to array
    // increment next use space
    ++Flat_GlobalArrayIndex_Err.total;
    ++Flat_GlobalArrayIndex_Err.nextuse;
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Print_Err(void)
{
    int  i0;
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Err.total;i0++)
        {
        printf (Flat_GlobalArray_Err[i0]);
        printf ("\n");
        }
    return;
}


//-------------------------------------------------------------------
// purpose:
//  the problem with regular strtok2 is that it will
//  skip stuff like ",,," and ignore all the blanks in
//  between to get to the next token.  this strtok2 function
//  was written to over come that.  so that strtok2 works like
//  you think it would.
//-------------------------------------------------------------------
char * __cdecl strtok2 (char * string,const char * control)
{
        //unsigned char *str;
        //const unsigned char *ctrl = control;
        //unsigned char map[32];
        char *str;
        const char *ctrl = control;
        char map[32];
        int count;

        static char *nextoken;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
            {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
            } while (*ctrl++);

        /* Initialize str. If string is NULL, set str to the saved
         * pointer (i.e., continue breaking tokens out of the string
         * from the last strtok2 call) */
        if (string)
                str = string;
        else
                str = nextoken;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets str to point to the terminal
         * null (*str == '\0') */
        /*
        while (
                (map[*str >> 3] & (1 << (*str & 7) ) )    && *str
                )
                str++;
                */

        string = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */
        nextoken = str;

        /* Determine if a token has been found. */
        if ( string == str )
                return NULL;
        else
                return string;
}





int RemoveAllSpaces(LPSTR & thetempstring)
{
	int iReturn = FALSE;
	int j = 0;
    char thevalue[1024];
    char tempstring2[1024];

    strcpy(tempstring2, thetempstring);
//	strset(thevalue, '\0');
    strcpy(thevalue, "");

	for (int i=0;i < (int) strlen(tempstring2);i++)
	{
		
		if (tempstring2[i] == ' ')
		{
			iReturn = TRUE;
		}
		else
		{
			thevalue[j] = tempstring2[i];
			thevalue[j+1] = '\0';
			j++;
		}
	}
	if (iReturn == TRUE)  {strcpy(thetempstring, thevalue);}

    return iReturn;
}


int Flat_DoWeIncludeThisFileCheck(int processeduptill)
{
	//return TRUE;
	int iReturn = FALSE;
    int i0 = 0;
	int TheCount = 0;

    char CompareTo_cab[100];

	if (Flat_GlobalArray_Main[processeduptill].Do_Not_Include_file_if_cabEmpty_Flag != 1) {return TRUE;}

	// Grab the cabfilename
	strcpy(CompareTo_cab, Flat_GlobalArray_Main[processeduptill].CabFileName);
	for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
		if (i0 != processeduptill)
			{
			if (Flat_GlobalArray_Main[i0].Do_Not_Include_file_if_cabEmpty_Flag != 1)
				{
				if (_stricmp(Flat_GlobalArray_Main[i0].CabFileName, CompareTo_cab) == 0)
					{
					++TheCount;
					break;
					}
				}
			}
        }

	if (TheCount > 0){iReturn = TRUE;}

    return iReturn;
}


void Global_TotalCabFileSize_Compute(void)
{
	char szTheCabFileName[50] = "";
	int MyFileSize = 0;
	int TheNextUse = 0;
	int iTheFlag = FALSE;
	int iIndexToUse = 0;

	// Go thru the whole list and add everything up
	for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
		{
			if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
			{
				if (!(Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag))
				{

					iIndexToUse = Flat_GlobalArrayIndex_CabSizes.nextuse;

					TheNextUse = 0;
					// lets add it if not already there.
					while (TheNextUse < Flat_GlobalArrayIndex_CabSizes.total)
					{
						if (_stricmp(Flat_GlobalArray_CabSizes[TheNextUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName) == 0)
						{
							iIndexToUse = TheNextUse;
							iTheFlag = TRUE;
							break;
						}
						TheNextUse++;
					}

					if (iTheFlag == TRUE)
					{
						// copy over the filename
						strcpy(Flat_GlobalArray_CabSizes[iIndexToUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName);

						// Get the size
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize = Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize + Flat_GlobalArray_Main[i0].FileName_Size;
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFiles++;
					}
					else
					{
						iIndexToUse = Flat_GlobalArrayIndex_CabSizes.nextuse;

						// copy over the filename
						strcpy(Flat_GlobalArray_CabSizes[iIndexToUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName);

						// Get the size
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize = Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize + Flat_GlobalArray_Main[i0].FileName_Size;
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFiles++;

						++Flat_GlobalArrayIndex_CabSizes.total;
						++Flat_GlobalArrayIndex_CabSizes.nextuse;
					}
				}
			}
		}
}


void Global_TotalCabFileSize_Print(void)
{
    int  i0;
	char stempstring[100];

    for( i0 = 0; i0 < Flat_GlobalArrayIndex_CabSizes.total;i0++)
        {
		sprintf(stempstring, "%s: Filecount=%d, Size=%d\n",Flat_GlobalArray_CabSizes[i0].CabFileName, Flat_GlobalArray_CabSizes[i0].TotalFiles, Flat_GlobalArray_CabSizes[i0].TotalFileSize);
        printf(stempstring);
        }
	printf("\n");
    return;
}


// Returns the count of the "\" characters in the string
//
int ReturnDirLevelCount(char *DirectoryTree)
{
	int TheCount = 0;
	char szTemp[_MAX_PATH];
	_tcscpy(szTemp, DirectoryTree);
	char *p = szTemp;
	while (*p) 
	{
		if (*p == '\\') 
			{TheCount++;}
		
		p = _tcsinc(p);
	}

	return TheCount;
}




void FillGlobalUniqueDirList()
{
    // used to keep a list of unique directory names.
	// loop thru the whole structure and pull out all the unique directory names.
    for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
    {
        // check if entries are the same.
		if (FALSE == GlobalUniqueDirChkIfAlreadyThere(Flat_GlobalArray_Main[i0].Filename_Path))
		{
			// Not there yet.  so let's add it
			strcpy(Flat_GlobalUniqueDirList[Flat_GlobalUniqueDirList_nextuse], Flat_GlobalArray_Main[i0].Filename_Path);

			// increment counter to array
			// increment next use space
			++Flat_GlobalUniqueDirList_total;
			++Flat_GlobalUniqueDirList_nextuse;
		}
    }
	return;
}


int GlobalUniqueDirChkIfAlreadyThere(char *TheStringToCheck)
{
	int iReturn = FALSE;

	for( int i0 = 0; i0 < Flat_GlobalUniqueDirList_total;i0++)
	{
		if (_stricmp(Flat_GlobalUniqueDirList[i0], TheStringToCheck) == 0)
		{
			iReturn = TRUE;
			goto isItAlreadyThere_Exit;
		}
	}

isItAlreadyThere_Exit:
	return iReturn;
}


int GlobalUniqueDirReturnMyIndexMatch(char *TheStringToCheck)
{
	int iReturn = 0;

	for( int i0 = 0; i0 < Flat_GlobalUniqueDirList_total;i0++)
	{
		if (_stricmp(Flat_GlobalUniqueDirList[i0], TheStringToCheck) == 0)
		{
			iReturn = i0;
			goto GlobalUniqueDirReturnMyIndexMatch_Exit;
		}
	}

GlobalUniqueDirReturnMyIndexMatch_Exit:
	return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfapii.h ===
#ifndef __PERFAPII_H__
#define __PERFAPII_H__

#include "perfapi.h"

/******************************************************************************\
*                              SYMBOLIC CONSTANTS
\******************************************************************************/

// This should be a reasonable length
#define MAX_TITLE_CHARS    				40
#define MAX_HELP_CHARS					200
#define	MAX_COUNTER_AND_HELP_ENTRIES	2000
#define MAX_COUNTER_ENTRIES				1000
#define MAX_HELP_ENTRIES				1000

// Counter Definition Mapped MemorySize, includes space for storing the counter
// names.
#define COUNTER_DEF_MM_SIZE             (MAX_COUNTERS * (sizeof(PERF_COUNTER_DEFINITION) + (MAX_TITLE_CHARS + 1) * sizeof(WCHAR)))

// Instance Definition Mapped MemorySize
#define INSTANCE_DEF_MM_SIZE            (MAX_INSTANCES_PER_OBJECT * (sizeof(PERF_INSTANCE_DEFINITION) + (MAX_TITLE_CHARS + 1) * sizeof(WCHAR)))

// !!! Assuming Counters are never > 8 bytes
#define MAX_COUNTER_SIZE                (sizeof(LARGE_INTEGER))

#define INSTANCE_COUNTER_DATA_SIZE		(MAX_COUNTERS * MAX_COUNTER_SIZE)

#define OBJECT_COUNTER_DATA_SIZE    	(MAX_INSTANCES_PER_OBJECT * INSTANCE_COUNTER_DATA_SIZE) 

#define OBJECT_TYPE                     0
#define INSTANCE_TYPE                   1

#define MAX_PERFMON_WAIT				5000


/******************************************************************************\
*                              FUNCTION PROTOTYPES
\******************************************************************************/


/* Performance APIs */
PM_OPEN_PROC 	AppPerfOpen;
PM_CLOSE_PROC	AppPerfClose;
PM_COLLECT_PROC	AppPerfCollect;


/* Structures */

// Was the original PERFINFO
// also added the object name, the help text goes into the registry directly
// added perfdata to store stuff like TitleIndex etc.
// !!! I guess we can fold some of the other stuff like NumCounters
// !!! etc into the perfdata member.
typedef struct tagOBJECT_PERFINFO {
    DWORD   dwParentType;
    PERF_OBJECT_TYPE perfdata;
    BOOL    bMapped;
    DWORD   index;
	DWORD	dwSequence;
	DWORD	dwNumProcesses;
    DWORD   dwNumCounters;
    DWORD   dwNumInstances;
    DWORD   dwMaxDataSize;
	DWORD	dwMaxCounterDataSize;
    DWORD   dwCounterDataSize;
	BOOL	bInstanceMap[MAX_INSTANCES_PER_OBJECT];
    WCHAR   szName[MAX_TITLE_CHARS + 1];
} OBJECT_PERFINFO, *POBJECT_PERFINFO;

// The memory maps are unique to each process, so these have to live
// in the applications dlls data segment.
// Note:: Also DATA in .def file is no longer declared to be SINGLE
typedef struct tagOBJECT_MMF_PTRS {
    HANDLE  hObjectDef;
    PBYTE   gpbCounterData;
    PBYTE   gpbCounterDefinitions;
    PBYTE   gpbInstanceDefinitions;
    BOOL    bMapped;
} OBJECT_MMF_PTRS ;

typedef struct tagGLOBAL_PERFINFO {
	BOOL	bRegistryChanges;
	DWORD	dwFirstCounterIndex;
	DWORD	dwFirstHelpIndex;
    DWORD   dwNumObjects;
	DWORD	dwAllProcesses;			// keeps track of the number of processes using the dll
	WCHAR	NameStrings[MAX_COUNTER_ENTRIES][MAX_TITLE_CHARS + 1];
	WCHAR	HelpStrings[MAX_HELP_ENTRIES][MAX_HELP_CHARS + 1];
} GLOBAL_PERFINFO ;

typedef struct tagCOUNTER_PERFINFO {
    DWORD           dwSize;
    DWORD           dwOffset;
} COUNTER_PERFINFO, *PCOUNTER_PERFINFO;

typedef struct tagINSTANCE_PERFINFO {
    DWORD           dwParentType;
    PVOID           lpInstanceStart;
    INSTANCE_ID     iID;
	BOOL			bCreatedByMe;
} INSTANCE_PERFINFO, *PINSTANCE_PERFINFO;


// Macros
// following macros used to operate on the one Global PERFINFO
// object. Now since there are muliple objects the PERFINFO has
// become OBJECT_PERFINFO and the macros operate on an Object
#define NumCounters(poi)       ((DWORD) poi->dwNumCounters)
#define HasInstances(poi)		(poi->dwParentType)
#define NumInstances(poi)      ((DWORD) poi->dwNumInstances)
#define DataSize(poi)          ((DWORD) poi->dwCounterDataSize)
#define GetCounterStart(poi)   ((PPERF_COUNTER_DEFINITION ) pommfs[poi->index].gpbCounterDefinitions)
#define GetInstanceStart(poi)  ((PPERF_INSTANCE_DEFINITION) pommfs[poi->index].gpbInstanceDefinitions )
#define GetDataStart(poi)      ((PBYTE) pommfs[poi->index].gpbCounterData )
#define GetInstance(poi,num)   ((PPERF_INSTANCE_DEFINITION) (pommfs[poi->index].gpbInstanceDefinitions + (num) * (sizeof(PERF_INSTANCE_DEFINITION) + (MAX_TITLE_CHARS + 1) * sizeof(WCHAR))));
#define ObjectID(poi)		   (poi - ((OBJECT_PERFINFO *) (pgi + 1)))
#define InvalidPoi(poi)		   ((ObjectID(poi) >= MAX_PERF_OBJECTS) || ((LPBYTE) poi < ((LPBYTE) (pgi + 1))))

// An INSTANCE_ID has 2 parts:
// 1. The low part is the real instance id within the object of the instance
// 2. The high part is the object id for the instance
#define ObjectInfo(iID)			( ((iID >> 16) < MAX_PERF_OBJECTS) ? ((POBJECT_PERFINFO) (((POBJECT_PERFINFO) (pgi + 1)) + (iID >> 16))) : NULL)
#define InstanceID(iID)			(iID & 0xFFFF)		

// following macro operates on the one and only one GLOBAL PERFINFO struct.
#define MappedMemoryInitialized() (pgi ? TRUE: FALSE)

#define BOOLEAN(expr)			((expr) ? TRUE : FALSE)

// Global Variable declarations
extern GLOBAL_PERFINFO * pgi ;
extern OBJECT_MMF_PTRS * pommfs ;
extern WCHAR szBuf[] ;

// security attributes while creating the shared stuff
extern SECURITY_ATTRIBUTES sa;
  
#endif // __PERFAPII_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfapi.c ===
/******************************************************************************\
*
*  MODULE:      PerfAPI.C
*
*  PURPOSE:     This is a DLL which obtains performance data.  It is called by the registry (invoked
*               by a performance monitor like perfmon.exe).  
*
*  FUNCTIONS:   DllMain() - DLL entry point
*               AppPerfOpen()  - Called when DLL is loaded by Registry (Perfmon.exe)
*               AppPerfCollect()  - Collects Performance data 
*               AppPerfClose()  - Called when DLL is unloaded by Registry (Perfmon.exe)
*
*

*
\******************************************************************************/

#define UNICODE 1
#define _UNICODE 1

#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <assert.h>
#include <winperf.h>    

#include "perfapiI.h"
#include "perfutil.h"
#include "perfmsg.h"
#include "perferr.h"
#include "perfreg.h"
#include "shmem.h"

// Global Variables
TCHAR szBuf[1024];
GLOBAL_PERFINFO * pgi = NULL ;
OBJECT_MMF_PTRS * pommfs = NULL ;
HANDLE hObjectMutex = NULL;
HANDLE hRegMutex = NULL;

extern TCHAR szRegistryPathToPerformanceKeys[];
extern DWORD dwNumOfObjectCreates[MAX_PERF_OBJECTS];
DWORD		 dwObjectSeq[MAX_PERF_OBJECTS];

SECURITY_ATTRIBUTES sa;

/******************************************************************************\
*
*  FUNCTION:    DllMain
*
*  INPUTS:      hDLL       - handle of DLL
*               dwReason   - indicates why DLL called
*               lpReserved - reserved
*
*  RETURNS:     TRUE (always, in this example.)
*
*               Note that the retuRn value is used only when
*               dwReason = DLL_PROCESS_ATTACH.
*
*               Normally the function would return TRUE if DLL initial-
*               ization succeeded, or FALSE it it failed.
*
*  GLOBAL VARS: ghMod - handle of DLL (initialized when PROCESS_ATTACHes)
*
*  COMMENTS:    The function will display a dialog box informing user of
*               each notification message & the name of the attaching/
*               detaching process/thread. For more information see
*               "DllMain" in the Win32 API reference.
*
\******************************************************************************/

BOOL WINAPI DllEntryPoint(HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{

  switch (dwReason)
  {
		DWORD i;

    case DLL_PROCESS_ATTACH:
    {
        //
        // DLL is attaching to the address space of the current process.
        //

		// Initialize a default Security attributes, giving world permissions,
		// this is basically prevent Semaphores and other named objects from
		// being created because of default acls given by winlogon when perfmon
		// is being used remotely.
		sa.bInheritHandle = FALSE;
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = malloc(sizeof(SECURITY_DESCRIPTOR));
		assert(sa.lpSecurityDescriptor);
		if ( !InitializeSecurityDescriptor(sa.lpSecurityDescriptor,SECURITY_DESCRIPTOR_REVISION) ) {
			assert(0);
		}
		
		// basis for the parameters to this API are we want to specify an "Empty ACL", this
		// we do by setting the 'fDaclPresent' to TRUE and setting 'pACL' to NULL,
		// by doing this we give world permissions, later on we should change this, to what ? don't know	
		// Lastly the 'fDaclDefaulted' is set to FALSE, to say that we as the user have
		// specified the Empty acl and it is not the system that has generated this.
		if ( !SetSecurityDescriptorDacl(sa.lpSecurityDescriptor,TRUE,NULL,FALSE) ) {
			assert(0);
		}

		// Open the semaphore
		hObjectMutex = CreateSemaphore (&sa, 1, 1, L"PERFAPI_OBJECT_MUTEX");
		assert(hObjectMutex) ;
		hRegMutex = CreateSemaphore (&sa, 1, 1, L"PERFAPI_REGISTRY_MUTEX");
		assert(hRegMutex);

		for (i = 0; i < MAX_PERF_OBJECTS; i++) {
			dwNumOfObjectCreates[i] = 0;
			dwObjectSeq[i] = 0;
		}

		// open Eventlog interface
    	hEventLog = MonOpenEventLog();

		// Now, make sure the registry and the global structures are setup
		WaitForSingleObject(hObjectMutex,INFINITE) ;
		if (! SetupAllSharedMemory ()) {
			ReleaseSemaphore (hObjectMutex, 1, NULL);
			CloseHandle (hObjectMutex);
			CloseHandle (hRegMutex);
	        return FALSE;
		}
		ReleaseSemaphore (hObjectMutex, 1, NULL);
			
		if (! SetupRegistry()) {
			CloseHandle (hObjectMutex);
			CloseHandle (hRegMutex);
			return FALSE;
		}

		WaitForSingleObject(hObjectMutex,INFINITE) ;
		pgi->dwAllProcesses++;
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		break;
    }
    case DLL_PROCESS_DETACH:
	{	// Got to unmap all views & free all the allocated memory
		OBJECT_PERFINFO *poi ;
		DWORD i ;

        //
        // The calling process is detaching the DLL from its address space.
        //
		free ((void *) sa.lpSecurityDescriptor);
		
		// First we have to a DestroyObject on all the objects that this
		// process has created, this we do by - interrupt - missed what I was thinking !!!!
		if ( pgi ) {
			for ( i = 0, poi = (OBJECT_PERFINFO *) (pgi + 1) ; i < MAX_PERF_OBJECTS; i++, poi++ ) {
				if ( pommfs[i].bMapped ) {
					if (dwNumOfObjectCreates[ObjectID(poi)] > 0) {
						dwNumOfObjectCreates[ObjectID(poi)] = 1;
						DestroyPerfObject(poi);
					}
					else {
						ReleaseObjectSharedMemory(poi);
					}
				}
			}
		
			if ( pommfs ) 
				free(pommfs) ;

			WaitForSingleObject(hObjectMutex,INFINITE) ;
			pgi->dwAllProcesses--;
			if (pgi->dwAllProcesses == 0) {
				ReleaseSemaphore (hObjectMutex, 1, NULL);
				RegistryCleanup();
			}
			else
				ReleaseSemaphore (hObjectMutex, 1, NULL);

			ReleaseGlobalDataMemory();
		}

		MonCloseEventLog();
		if ( hObjectMutex ) 
			CloseHandle(hObjectMutex);
		if ( hRegMutex ) 
			CloseHandle(hRegMutex);
	}
    break;
  }
  return TRUE;
}

BOOL	WINAPI
DllMain(	HANDLE	hInst,
			ULONG	dwReason,
			LPVOID	lpvReserve )	{

	return	DllEntryPoint( (HINSTANCE)hInst, dwReason, lpvReserve ) ;

}

/* Called by performance monitor when ... */
DWORD APIENTRY AppPerfOpen(LPWSTR lpDeviceNames)
{
	assert(!lpDeviceNames);

	REPORT_INFORMATION(PERFAPI_OPEN_CALLED, LOG_VERBOSE);

	WriteDescriptionsToRegistry();

	return ERROR_SUCCESS;
}




/*
	Returns the size required to store the data associated
	with an object
*/
DWORD PerfSize(OBJECT_PERFINFO *poi)
{
	DWORD i;
	PPERF_INSTANCE_DEFINITION pPerfInst;
	DWORD size = sizeof(PERF_OBJECT_TYPE) + NumCounters(poi) * sizeof (PERF_COUNTER_DEFINITION) ;

	if (HasInstances(poi)) {
		size += NumInstances(poi) * (DataSize(poi) + sizeof(PERF_COUNTER_BLOCK));
		for ( i = 0; i < MAX_INSTANCES_PER_OBJECT; i++ ) {
        	if (poi->bInstanceMap[i]) {
				pPerfInst = GetInstance (poi, i);
		        size += pPerfInst->ByteLength;
			}
		}
	}
	else 
		size += DataSize(poi) + sizeof(PERF_COUNTER_BLOCK) ;

	return size ;
}

DWORD CollectObjectPerfData(IN OBJECT_PERFINFO *poi, IN OUT  LPBYTE  *lppData)
/*++
Arguments:
   IN	OBJECT_PERFINFO *poi
   		A pointer to the Object information. The Perf data for this
		is written to the buffer passed in the next param.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

Return Value:

	Number of bytes taken up by this structure and its data.

Remarks:
	This function assumes there is enough buffer space to hold all the perfdata
	for this object.
--*/
{
	PPERF_OBJECT_TYPE pPerfObject ;
	PPERF_COUNTER_BLOCK pCounterBlock ;
	PPERF_INSTANCE_DEFINITION pPerfInst ;
	DWORD dwTmp, dwConst, dwInstanceOffset;
	LONG i ;
	LPBYTE lppDataSave = *lppData;

	REPORT_INFORMATION(PERFAPI_COLLECT_CALLED, LOG_VERBOSE);
		
	pPerfObject = (PPERF_OBJECT_TYPE) *lppData ;

	pPerfObject->NumCounters = NumCounters(poi) ;

	if (pPerfObject->NumCounters < 1)
		return 0 ;

	pPerfObject->ObjectNameTitleIndex = poi->perfdata.ObjectNameTitleIndex;
	pPerfObject->ObjectHelpTitleIndex = poi->perfdata.ObjectHelpTitleIndex;
	pPerfObject->ObjectNameTitle = pPerfObject->ObjectHelpTitle = 0;
	pPerfObject->DetailLevel = PERF_DETAIL_NOVICE ;
	pPerfObject->DefaultCounter = 0;
	pPerfObject->CodePage = 0;
		
	*lppData += sizeof (PERF_OBJECT_TYPE);
    pPerfObject->HeaderLength = sizeof(PERF_OBJECT_TYPE) ;

#if 0
   	//  Only need this if we're using high performance timer
	QueryPerformanceCounter(&pPerfObject->PerfTime);
	QueryPerformanceFrequency(&pPerfObject->PerfFreq);
#endif

	/* Append the counter definitions */
	dwTmp = NumCounters(poi) * sizeof(PERF_COUNTER_DEFINITION);
	memcpy ((void *) *lppData, (void *) GetCounterStart(poi), dwTmp);
	*lppData += dwTmp ;

	// End of defintion structures - Note this should just be HeaderLength+NumCounters*sizeof PCD struct
	pPerfObject->DefinitionLength = pPerfObject->TotalByteLength = sizeof(PERF_OBJECT_TYPE) + dwTmp ;
    	
	if (! HasInstances(poi)) {
		pPerfObject->NumInstances = PERF_NO_INSTANCES;
		// There is only one instance, and we copy the Counter block of data
		pCounterBlock = (PERF_COUNTER_BLOCK *) *lppData;
	    *lppData += sizeof(PERF_COUNTER_BLOCK);

        memcpy(*lppData, GetDataStart(poi), dwTmp = DataSize(poi));

		*lppData += dwTmp;  // Increment for all the data added for this instance

	    /* Add the entry for the PERF_COUNTER_BLOCK, note: we're putting thisbefore the data*/
	    pCounterBlock->ByteLength = dwTmp + sizeof (PERF_COUNTER_BLOCK);
		pPerfObject->TotalByteLength += pCounterBlock->ByteLength;
	}
    else {
		pPerfObject->NumInstances = NumInstances(poi);
		dwConst = poi->dwMaxDataSize / MAX_INSTANCES_PER_OBJECT;
	    //Now let's add the PERF_INSTANCE_DEFINITION structure, the Instance Name, The Counter Block, and the data
		for (i = 0, dwInstanceOffset = 0; i < MAX_INSTANCES_PER_OBJECT; i++, dwInstanceOffset += dwConst) {
			if (! poi->bInstanceMap[i]) {
				continue;
			}
			pPerfInst = GetInstance(poi,i);
        	if (! pPerfInst) {
				*lppData = lppDataSave;
            	return 0;          
        	}  
    
	    	// Now we copy a PERF_INSTANCE_DEFINITION and name
		    memcpy (*lppData, pPerfInst, pPerfInst->ByteLength); 
		    *lppData += pPerfInst->ByteLength;

	        /* Increment past the PERF_COUNTER_BLOCK size, we'll insert the data later when we know the size*/
		    pCounterBlock = (PERF_COUNTER_BLOCK *) *lppData;
	    	*lppData += sizeof(PERF_COUNTER_BLOCK);
			pPerfObject->TotalByteLength += pPerfInst->ByteLength + sizeof(PERF_COUNTER_BLOCK);

        	memcpy (*lppData, GetDataStart(poi) + dwInstanceOffset, dwTmp = DataSize(poi));

			*lppData += dwTmp;  // Increment for all the data added for this instance
        	pPerfObject->TotalByteLength += dwTmp;
			/* Add the entry for the PERF_COUNTER_BLOCK, note: we're putting this before the data*/
			pCounterBlock->ByteLength = dwTmp + sizeof (PERF_COUNTER_BLOCK);

		}
	}

    return pPerfObject->TotalByteLength ;

} // End of CollectObjectPerfData


DWORD APIENTRY AppPerfCollect(LPWSTR lpwszValue, LPVOID * lppDataParam, LPDWORD lpcbBytes, LPDWORD lpcObjectTypes)
{
	DWORD nBytesWritten, dwTmp, dwObjectBytes;
	DWORD absIndex, dwQueryType;
	OBJECT_PERFINFO *poi;

	dwQueryType = GetQueryType (lpwszValue);
	if (dwQueryType == QUERY_FOREIGN) {
		// The dll does not run on non-NT computers; this call is not for us
		*lpcbBytes = (DWORD) 0;
		*lpcObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}

	if (! WriteDescriptionsToRegistry()) {
	   	*lpcbBytes = (DWORD) 0;
		*lpcObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}

	// Do not want to stall PerfMon for ever, if some semaphore never gets released (because of a TerminateProcess/Thread).
	dwTmp = WaitForSingleObject(hObjectMutex, MAX_PERFMON_WAIT);
	if (WAIT_TIMEOUT == dwTmp) {
		*lpcbBytes = (DWORD) 0;
		*lpcObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;           
	}

	if ( ! pgi->dwNumObjects ) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
	    *lpcbBytes = (DWORD) 0;
		*lpcObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;           
	}

	// make sure we have sufficient buffer space
	nBytesWritten = 0 ;
	*lpcObjectTypes = 0 ;
	
	for ( poi = (OBJECT_PERFINFO *) (pgi + 1), absIndex = 0; absIndex < MAX_PERF_OBJECTS; absIndex++, poi++ ) {
		// is this object mapped, i.e is it alive
		if ( ! poi->bMapped ) {
			// if we have it mapped then unmap it
			if ( pommfs[absIndex].bMapped ) {
				ReleaseObjectSharedMemory(poi);
			}
		 	continue ;
		}

		if (dwQueryType == QUERY_ITEMS) {
			if (! IsNumberInUnicodeList (poi->perfdata.ObjectNameTitleIndex, lpwszValue))
				continue;
		}

		if (pommfs[absIndex].bMapped) {
			if (dwObjectSeq[absIndex] < poi->dwSequence) {
				// We currently have mapped an old object that has been deleted.  We need to update our structures 
				// with the new object in the same poi.
				ReleaseObjectSharedMemory(poi);
				SetupObjectSharedMemory(poi);
				dwObjectSeq[absIndex] = poi->dwSequence;
			}
		}
		else {
			SetupObjectSharedMemory(poi);
			dwObjectSeq[absIndex] = poi->dwSequence;
		}

		dwTmp = PerfSize(poi) ;
		if ( (nBytesWritten + dwTmp) < *lpcbBytes ) {
			dwObjectBytes = CollectObjectPerfData (poi, (LPBYTE *)lppDataParam) ;
			if (dwObjectBytes) {
				(*lpcObjectTypes)++ ;
				nBytesWritten += dwObjectBytes;
			}
		}
		else {
			*lpcbBytes = nBytesWritten ;
			ReleaseSemaphore (hObjectMutex, 1, NULL);
			return ERROR_MORE_DATA ;
		}
	}
	ReleaseSemaphore (hObjectMutex, 1, NULL);

	*lpcbBytes = nBytesWritten ;
	return ERROR_SUCCESS;
}

DWORD APIENTRY AppPerfClose()
{
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\appapi.c ===
/*
	File: appAPI.c

	Implements the APIs that the apps that want to expose counters call.
*/

#define UNICODE 1
#define _UNICODE 1


#include <stdlib.h>
#include <malloc.h>
#include <string.h>

#include <windows.h>
#include <tchar.h>
#include <assert.h>

#include <winperf.h>

#include "perfapii.h"

#include "shmem.h"
#include "perfmsg.h"
#include "perferr.h"
#include "perfreg.h"

extern HANDLE hObjectMutex;
extern DWORD  dwObjectSeq[MAX_PERF_OBJECTS];

DWORD dwNumOfObjectCreates[MAX_PERF_OBJECTS];		// Keeps track how many times each object was created by the current process

static OBJECT_PERFINFO *GetObjectDefinition(WCHAR *pObjectname) ;
static INSTANCE_ID GetObjectInstanceNumber(OBJECT_PERFINFO *poi,PWSTR pInstDesc);
static LONG GetCounterNameNumber(OBJECT_PERFINFO *poi,WCHAR * pTitle);
static OBJECT_PERFINFO *UpdateObjectDefinitions(PWSTR pTitle, PWSTR pHelp) ;
static BOOL UpdateCounterDefinitions(OBJECT_PERFINFO *poi,DWORD dwType, DWORD dwScale, DWORD dwSize, PWSTR pTitle, PWSTR pHelp, DWORD * pdwOffset);
static INSTANCE_ID UpdateInstanceDefinitions(OBJECT_PERFINFO *poi,PWSTR pInstDesc);


HANDLE _stdcall MakeAPerfObjectA(char *pTitle, char *pHelp, DWORD nSize, BOOL bHasInstances, PVOID *lppObjectStart)
{
	PWSTR pTStr;
    PWSTR pHStr;
	int nCount;
    PVOID pVoid;
	BOOL  bLong;
	char *pInStr;

	//assuming that we are called with ANSI, non-UNICODE string
    if (pTitle) {
		if (strlen (pTitle) > MAX_TITLE_CHARS) {
			bLong = TRUE;
			pInStr = (char *) malloc (MAX_TITLE_CHARS + 1);
			memcpy ((void *) pInStr, (const void *) pTitle, MAX_TITLE_CHARS);
			pInStr[MAX_TITLE_CHARS] = '\0';
		}
		else {
			bLong = FALSE;
			pInStr = pTitle;
		}
		nCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, NULL, 0);
		pTStr = (PTSTR) malloc( nCount * sizeof (WCHAR));
	    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, pTStr, nCount);
		if (bLong)
			free ((void *) pInStr);
    }
    else
		pTStr = NULL;

	if (pHelp) {
		if (strlen (pHelp) > MAX_HELP_CHARS) {
			bLong = TRUE;
			pInStr = (char *) malloc (MAX_HELP_CHARS + 1);
			memcpy ((void *) pInStr, (const void *) pHelp, MAX_HELP_CHARS);
			pInStr[MAX_HELP_CHARS] = '\0';
		}
		else {
			bLong = FALSE;
			pInStr = pHelp;
		}
	    nCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1,NULL, 0);
	    pHStr = (PTSTR) malloc( nCount * sizeof (WCHAR));
	    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, pHStr, nCount);
		if (bLong)
			free ((void *) pInStr);
    }
    else
		pHStr = NULL;

    pVoid = MakeAPerfObjectW(pTStr, pHStr, nSize, bHasInstances, lppObjectStart);

    if (pTStr)
		free(pTStr);
	if (pHStr)
		free(pHStr);

    return pVoid;
}

HANDLE _stdcall MakeAPerfObjectW(PWSTR pTitle, PWSTR pHelp, DWORD nSize, BOOL bHasInstances, PVOID *lppObjectStart)
{
	OBJECT_PERFINFO *pObjectDef;
	DWORD dwError;
	BOOL  bLongTitle = FALSE;
	BOOL  bLongHelp = FALSE;

	SetLastError (0);

	// go through the names to check if it is already present !!
	// if it is then we return the same handle.
	// !!! maybe we should fail this, like two apps adding the same object !?
	// !!! or we could extend the name of the object with the name of the app !?

	if (! pTitle) {
		REPORT_ERROR(PERFAPI_INVALID_TITLE, LOG_USER);
        SetLastError(PERFAPI_INVALID_TITLE);
	    return INVALID_HANDLE_VALUE;
    }
	else
		if (wcslen (pTitle) > MAX_TITLE_CHARS) {
				PWSTR	pTemp;
			bLongTitle = TRUE;
			pTemp = (PWSTR) malloc ((MAX_TITLE_CHARS + 1) * sizeof (WCHAR));
			memcpy ((void *) pTemp, (const void *) pTitle, MAX_TITLE_CHARS * sizeof (WCHAR));
			pTitle = pTemp;
			pTitle[MAX_TITLE_CHARS] = L'\0';
		}

	if (pHelp != NULL && wcslen (pHelp) > MAX_HELP_CHARS) {
			PWSTR	pTemp;
		bLongHelp = TRUE;
		pTemp = (PWSTR) malloc ((MAX_HELP_CHARS + 1) * sizeof (WCHAR));
		memcpy ((void *) pTemp, (const void *) pHelp, MAX_HELP_CHARS * sizeof (WCHAR));
		pHelp = pTemp;
		pHelp[MAX_TITLE_CHARS] = L'\0';
	}

	// lock the object area so that nobody else does the same
	WaitForSingleObject(hObjectMutex,INFINITE);

	if (pObjectDef = GetObjectDefinition(pTitle) ) {
		// The object has been created before, possibly by another process.
		// We will use the same object definition and ignore the (possibly) new
		// title, help, nSize and bHasInstances variable.
		if ((dwNumOfObjectCreates[ObjectID(pObjectDef)]++) == 0) {
			if (! SetupObjectSharedMemory (pObjectDef)) {
				ReleaseSemaphore (hObjectMutex, 1, NULL);
				dwError = GetLastError();
				REPORT_ERROR_DATA(PERFAPI_FAILED_TO_ALLOC_OBJECT_SHMEM, LOG_USER,
								  &dwError, sizeof(DWORD) ) ;
				SetLastError(PERFAPI_FAILED_TO_ALLOC_OBJECT_SHMEM);
				if (bLongTitle)
					free ((void *) pTitle);
				if (bLongHelp && pHelp)
					free ((void *) pHelp);
				return INVALID_HANDLE_VALUE;
			}
			pObjectDef->dwNumProcesses++;
			dwObjectSeq[pObjectDef->index] = pObjectDef->dwSequence;
		}
		REPORT_WARNING(PERFAPI_ALREADY_EXISTS, LOG_USER);
		SetLastError (ERROR_ALREADY_EXISTS);
	}
	else {
		// so we haven't found it, we create a new object
		if ( pObjectDef = UpdateObjectDefinitions (pTitle, pHelp) ) {
			// now set up the shared memory for this object
			// Note that the UpdateObjectDefinitions setups the object name
			// for use by the SetupObjectSharedMemory.
			// Should generate an appropriate assert to validate this.
			if ( nSize == 0 ) {
				// Set the default data size
				pObjectDef->dwMaxDataSize = (bHasInstances) ? OBJECT_COUNTER_DATA_SIZE : INSTANCE_COUNTER_DATA_SIZE;
				pObjectDef->dwMaxCounterDataSize = INSTANCE_COUNTER_DATA_SIZE;
			}
			else {
				pObjectDef->dwMaxDataSize = nSize * ((bHasInstances) ? MAX_INSTANCES_PER_OBJECT : 1);
				pObjectDef->dwMaxCounterDataSize = nSize;
			}
			pObjectDef->dwParentType = (bHasInstances) ? INSTANCE_TYPE : OBJECT_TYPE;
			dwObjectSeq[pObjectDef->index] = ++(pObjectDef->dwSequence);

			if (! SetupObjectSharedMemory (pObjectDef)) {
				ReleaseSemaphore (hObjectMutex, 1, NULL);
				dwError = GetLastError();
				REPORT_ERROR_DATA(PERFAPI_FAILED_TO_ALLOC_OBJECT_SHMEM, LOG_USER,
								  &dwError, sizeof(DWORD) ) ;
            	SetLastError(PERFAPI_FAILED_TO_ALLOC_OBJECT_SHMEM);
				if (bLongTitle)
					free ((void *) pTitle);
				if (bLongHelp && pHelp)
					free ((void *) pHelp);
	        	return INVALID_HANDLE_VALUE;
			}
			pObjectDef->bMapped = TRUE;
			pObjectDef->dwNumProcesses = 1;
			dwNumOfObjectCreates[ObjectID(pObjectDef)] = 1;
			pgi->dwNumObjects++;
			if (bHasInstances) {
				DWORD i;
				BOOL *b;
				for (i = 0, b = pObjectDef->bInstanceMap; i < MAX_INSTANCES_PER_OBJECT; i++)
					*b++ = FALSE;
			}
		}
		else {
			ReleaseSemaphore (hObjectMutex, 1, NULL);
			if (bLongTitle)
				free ((void *) pTitle);
			if (bLongHelp && pHelp)
				free ((void *) pHelp);
			return INVALID_HANDLE_VALUE;
		}
	}

	if ( lppObjectStart && ! HasInstances(pObjectDef) ) {
		*lppObjectStart = pommfs[pObjectDef->index].gpbCounterData;
    }	

	ReleaseSemaphore (hObjectMutex, 1, NULL);
	if (bLongTitle)
		free ((void *) pTitle);
	if (bLongHelp && pHelp)
		free ((void *) pHelp);
	return (HANDLE) pObjectDef ;

} // End MakeAPerfObjectW


BOOL _stdcall DestroyPerfObject(HANDLE pObjectInfo)
{
    OBJECT_PERFINFO *poi = (OBJECT_PERFINFO *)pObjectInfo;
	DWORD			 i;
	PPERF_COUNTER_DEFINITION pCounter;

	WaitForSingleObject(hObjectMutex,INFINITE);

	if ( ! poi || InvalidPoi(poi) || pObjectInfo == INVALID_HANDLE_VALUE) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return FALSE ;
	}

	if ( ! poi->bMapped ) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return FALSE ;
	}

	// Decrement the thread-safe local process reference count for the object
	if (-- (dwNumOfObjectCreates[ObjectID(poi)])) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		return TRUE;
	}

	// If we are the last process using the object, we have to delete
	// the registry info about the object, too.
	if (poi->dwNumProcesses == 1) {
		DeleteDescriptionForPerfMon (poi->perfdata.ObjectNameTitleIndex, poi->perfdata.ObjectHelpTitleIndex);
		for (pCounter = GetCounterStart(poi), i = 0; i < NumCounters(poi); i++, pCounter++)
			DeleteDescriptionForPerfMon (pCounter->CounterNameTitleIndex, pCounter->CounterHelpTitleIndex);
	}

	ReleaseObjectSharedMemory(poi);
	
	// Decrement the global object reference count.  The process has released the object.
	if (--(poi->dwNumProcesses)) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		return TRUE;
	}

	poi->bMapped = FALSE ;
	pgi->dwNumObjects-- ;
	ReleaseSemaphore (hObjectMutex, 1, NULL);
	return TRUE ;
} // End DestroyObject


DWORD _stdcall MakeAPerfCounterA(DWORD dwType, DWORD dwScale, DWORD dwSize,  HANDLE hObject, char * pTitle, char * pHelp)
{
    PWSTR pTStr;
    PWSTR pHStr;
	int nCount;
	DWORD offset;
	BOOL  bLong;
	char *pInStr;

	//assuming that we are called with ANSI, non-UNICODE string
    if (pTitle) {
		if (strlen (pTitle) > MAX_TITLE_CHARS) {
			bLong = TRUE;
			pInStr = (char *) malloc (MAX_TITLE_CHARS + 1);
			memcpy ((void *) pInStr, (const void *) pTitle, MAX_TITLE_CHARS);
			pInStr[MAX_TITLE_CHARS] = '\0';
		}
		else {
			bLong = FALSE;
			pInStr = pTitle;
		}
		nCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1,NULL, 0);
		pTStr = (PTSTR) malloc( nCount * sizeof (WCHAR));
	    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, pTStr, nCount);
		if (bLong)
			free ((void *) pInStr);
    }
    else
		pTStr = NULL;

	if (pHelp) {
		if (strlen (pHelp) > MAX_HELP_CHARS) {
			bLong = TRUE;
			pInStr = (char *) malloc (MAX_HELP_CHARS + 1);
			memcpy ((void *) pInStr, (const void *) pHelp, MAX_HELP_CHARS);
			pInStr[MAX_HELP_CHARS] = '\0';
		}
		else {
			bLong = FALSE;
			pInStr = pHelp;
		}
	    nCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1,NULL, 0);
	    pHStr = (PTSTR) malloc( nCount * sizeof (WCHAR));
	    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, pHStr, nCount);
		if (bLong)
			free ((void *) pInStr);
    }
    else
		pHStr = NULL;

    offset = MakeAPerfCounterW(dwType, dwScale, dwSize, hObject, pTStr, pHStr);

    if (pTStr)
		free(pTStr);
	if (pHStr)
		free(pHStr);

    return offset;
}

HANDLE _stdcall MakeAPerfCounterHandleA(DWORD dwType, DWORD dwScale, DWORD dwSize,  HANDLE hObject, char * pTitle, char * pHelp)
{
    COUNTER_PERFINFO    *pCounterPerfInfo;
    PWSTR pTStr;
    PWSTR pHStr;
	int nCount;
	BOOL  bLong;
	char *pInStr;

    pCounterPerfInfo = (COUNTER_PERFINFO *) malloc( sizeof (COUNTER_PERFINFO));
    if (!pCounterPerfInfo) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_COUNTER_HANDLE, LOG_USER);
        SetLastError(PERFAPI_FAILED_TO_CREATE_COUNTER_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

	//assuming that we are called with ANSI, non-UNICODE string
    if (pTitle) {
		if (strlen (pTitle) > MAX_TITLE_CHARS) {
			bLong = TRUE;
			pInStr = (char *) malloc (MAX_TITLE_CHARS + 1);
			memcpy ((void *) pInStr, (const void *) pTitle, MAX_TITLE_CHARS);
			pInStr[MAX_TITLE_CHARS] = '\0';
		}
		else {
			bLong = FALSE;
			pInStr = pTitle;
		}
		nCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, NULL, 0);
		pTStr = (PTSTR) malloc( nCount * sizeof (WCHAR));
	    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, pTStr, nCount);
		if (bLong)
			free ((void *) pInStr);
    }
    else
		pTStr = NULL;

	if (pHelp) {
		if (strlen (pHelp) > MAX_HELP_CHARS) {
			bLong = TRUE;
			pInStr = (char *) malloc (MAX_HELP_CHARS + 1);
			memcpy ((void *) pInStr, (const void *) pHelp, MAX_HELP_CHARS);
			pInStr[MAX_HELP_CHARS] = '\0';
		}
		else {
			bLong = FALSE;
			pInStr = pHelp;
		}
	    nCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, NULL, 0);
	    pHStr = (PTSTR) malloc( nCount * sizeof (WCHAR));
	    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, pHStr, nCount);
		if (bLong)
			free ((void *) pInStr);
    }
    else
		pHStr = NULL;

    pCounterPerfInfo->dwOffset = MakeAPerfCounterW(dwType, dwScale, dwSize, hObject,pTStr, pHStr);

    if (pTStr)
		free(pTStr);
	if (pHStr)
		free(pHStr);

    if (pCounterPerfInfo->dwOffset != (DWORD) -1) {	
		pCounterPerfInfo->dwSize = dwSize;
        return pCounterPerfInfo;
    }
    else {
        free(pCounterPerfInfo);
        return INVALID_HANDLE_VALUE;
    }
}

DWORD _stdcall MakeAPerfCounterW(DWORD dwType, DWORD dwScale, DWORD dwSize,  HANDLE hObject, PWSTR pTitle, PWSTR pHelp)
{
	//!!! just casting it, not checking if this is a valid value etc.
	OBJECT_PERFINFO *poi = (OBJECT_PERFINFO *)hObject ;
	DWORD dwCounterDataOffset;
    LONG dwCounterNumber;
	BOOL  bLongTitle = FALSE;
	BOOL  bLongHelp = FALSE;

	if (! pTitle || ! pHelp) {
		REPORT_ERROR(PERFAPI_INVALID_TITLE, LOG_USER);
        SetLastError(PERFAPI_INVALID_TITLE);
	    return (DWORD) -1;
    }
	else
		if (wcslen (pTitle) > MAX_TITLE_CHARS) {
				PWSTR	pTemp;
			bLongTitle = TRUE;
			pTemp = (PWSTR) malloc ((MAX_TITLE_CHARS + 1) * sizeof (WCHAR));
			memcpy ((void *) pTemp, (const void *) pTitle, MAX_TITLE_CHARS * sizeof (WCHAR));
			pTitle = pTemp;
			pTitle[MAX_TITLE_CHARS] = L'\0';
		}

	if (wcslen (pHelp) > MAX_HELP_CHARS) {
			PWSTR	pTemp;
		bLongHelp = TRUE;
		pTemp = (PWSTR) malloc ((MAX_HELP_CHARS + 1) * sizeof (WCHAR));
		memcpy ((void *) pTemp, (const void *) pHelp, MAX_HELP_CHARS * sizeof (WCHAR));
		pHelp = pTemp;
		pHelp[MAX_TITLE_CHARS] = L'\0';
	}

	SetLastError (0);
	WaitForSingleObject(hObjectMutex,INFINITE) ;

	// okay we don't find it we just give up, this could itself create
	// a new object, but we don't want to do that. The order is
	// create an object, create one or more counters and for each
	// instance of the object we duplicate the counters.
    if ( poi == NULL || InvalidPoi(poi) || hObject == INVALID_HANDLE_VALUE) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		REPORT_ERROR (PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return (DWORD) -1;
	}

    //New counter?
    if ( (dwCounterNumber = GetCounterNameNumber(poi,pTitle)) == (LONG) -1) {
		if (!UpdateCounterDefinitions(poi,dwType, dwScale, dwSize, pTitle, pHelp, &dwCounterDataOffset) ) {
			ReleaseSemaphore (hObjectMutex, 1, NULL);
			if (bLongTitle)
				free ((void *) pTitle);
			if (bLongHelp)
				free ((void *) pHelp);
			return (DWORD)-1 ;
		}
	}
    else {
		//This will be at the same offset, in it's correspongind Object/Instance counter block
		dwCounterDataOffset = (GetCounterStart(poi) + dwCounterNumber)->CounterOffset - sizeof(PERF_COUNTER_BLOCK);
		REPORT_WARNING(PERFAPI_ALREADY_EXISTS, LOG_USER);
		SetLastError (ERROR_ALREADY_EXISTS);
    }

    //return beginning of mapped memory + Instance Offset + Counter within that specific instance
	ReleaseSemaphore (hObjectMutex, 1, NULL);
	if (bLongTitle)
		free ((void *) pTitle);
	if (bLongHelp)
		free ((void *) pHelp);
	return dwCounterDataOffset;
}


HANDLE _stdcall MakeAPerfCounterHandleW(DWORD dwType, DWORD dwScale, DWORD dwSize,  HANDLE hObject, PWSTR pTitle, PWSTR pHelp)
{
    COUNTER_PERFINFO    *pCounterPerfInfo;

    pCounterPerfInfo = (COUNTER_PERFINFO *) malloc( sizeof (COUNTER_PERFINFO));
    if (!pCounterPerfInfo) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_COUNTER_HANDLE, LOG_USER);
        SetLastError(PERFAPI_FAILED_TO_CREATE_COUNTER_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

    pCounterPerfInfo->dwOffset = MakeAPerfCounterW(dwType, dwScale, dwSize, hObject, pTitle, pHelp);

    if (pCounterPerfInfo->dwOffset != (DWORD) -1) {
		pCounterPerfInfo->dwSize = dwSize;
        return pCounterPerfInfo;
    }
    else {
        free(pCounterPerfInfo);
        return INVALID_HANDLE_VALUE;
    }
}

BOOL _stdcall DestroyPerfCounterHandle(HANDLE pCounterInfo)
{
	if (! pCounterInfo || pCounterInfo == INVALID_HANDLE_VALUE)	{
		REPORT_ERROR(PERFAPI_INVALID_COUNTER_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_COUNTER_HANDLE);
		return FALSE;
	}

    free (pCounterInfo);
    return TRUE;
}

INSTANCE_ID _stdcall MakeAPerfInstanceA( HANDLE hObject, char *pInstName, PVOID *lppInstanceStart)
{
    PWSTR pIStr;
	int nCount;
    INSTANCE_ID id;
	BOOL  bLong;
	char *pInStr;

	if (pInstName) {
		if (strlen (pInstName) > MAX_TITLE_CHARS) {
			bLong = TRUE;
			pInStr = (char *) malloc (MAX_TITLE_CHARS + 1);
			memcpy ((void *) pInStr, (const void *) pInstName, MAX_TITLE_CHARS);
			pInStr[MAX_TITLE_CHARS] = '\0';
		}
		else {
			bLong = FALSE;
			pInStr = pInstName;
		}
	    nCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, NULL, 0);
	    pIStr = (PTSTR) malloc(nCount * sizeof (WCHAR));
	    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, pIStr, nCount);
		if (bLong)
			free ((void *) pInStr);
    }
    else
		pIStr = NULL;

    id = MakeAPerfInstanceW(hObject, pIStr, lppInstanceStart);
	if (pIStr)
		free(pIStr);

    return id;
}

HANDLE _stdcall MakeAPerfInstanceHandleA (HANDLE hObject, char *pInstName)
{
    PINSTANCE_PERFINFO  pInstanceInfo;
    PWSTR pIStr;
	int nCount;
	BOOL  bLong;
	char *pInStr;

    pInstanceInfo = (PINSTANCE_PERFINFO) malloc (sizeof (INSTANCE_PERFINFO));
    if (!pInstanceInfo) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_INSTANCE_HANDLE, LOG_USER);
        SetLastError(PERFAPI_FAILED_TO_CREATE_INSTANCE_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

	if (pInstName) {
		if (strlen (pInstName) > MAX_TITLE_CHARS) {
			bLong = TRUE;
			pInStr = (char *) malloc (MAX_TITLE_CHARS + 1);
			memcpy ((void *) pInStr, (const void *) pInstName, MAX_TITLE_CHARS);
			pInStr[MAX_TITLE_CHARS] = '\0';
		}
		else {
			bLong = FALSE;
			pInStr = pInstName;
		}
	    nCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, NULL, 0);
	    pIStr = (PTSTR) malloc(nCount * sizeof (WCHAR));
	    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pInStr, -1, pIStr, nCount );
		if (bLong)
			free ((void *) pInStr);
    }
    else
		pIStr = NULL;

    pInstanceInfo->iID = MakeAPerfInstanceW(hObject, pIStr, &(pInstanceInfo->lpInstanceStart));

	if (pIStr)
		free(pIStr);

    if (pInstanceInfo->iID == -1) {
        free (pInstanceInfo);
        return INVALID_HANDLE_VALUE;
    }
    else {
		pInstanceInfo->bCreatedByMe = BOOLEAN(GetLastError() != ERROR_ALREADY_EXISTS);
        pInstanceInfo->dwParentType = INSTANCE_TYPE;
        return pInstanceInfo;
    }
}

INSTANCE_ID _stdcall MakeAPerfInstanceW (HANDLE hObject, LPWSTR pInstName, PVOID *lppInstanceStart)
{
	OBJECT_PERFINFO *poi = (OBJECT_PERFINFO *)hObject ;
	INSTANCE_ID InstanceId = (INSTANCE_ID) -1 ;
	BOOL		bLongTitle = FALSE;

	if (! pInstName || !wcslen(pInstName)) {
		REPORT_ERROR(PERFAPI_INVALID_TITLE, LOG_USER);
        SetLastError(PERFAPI_INVALID_TITLE);
	    return (INSTANCE_ID) -1;
    }
	else
		if (wcslen (pInstName) > MAX_TITLE_CHARS) {
				PWSTR	pTemp;
			bLongTitle = TRUE;
			pTemp = (PWSTR) malloc ((MAX_TITLE_CHARS + 1) * sizeof (WCHAR));
			memcpy ((void *) pTemp, (const void *) pInstName, MAX_TITLE_CHARS * sizeof (WCHAR));
			pInstName = pTemp;
			pInstName[MAX_TITLE_CHARS] = L'\0';
		}

	WaitForSingleObject(hObjectMutex,INFINITE) ;

	if ( poi == NULL || InvalidPoi(poi) || hObject == INVALID_HANDLE_VALUE) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_OBJECT_HANDLE);
		return (INSTANCE_ID) -1 ;
	}

	if (! HasInstances(poi)) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_INSTANCE, LOG_USER);
		SetLastError(PERFAPI_FAILED_TO_CREATE_INSTANCE);
		return (INSTANCE_ID) -1;
	}	

	SetLastError (0);

    // So, is this a new instance
    if ( (InstanceId = GetObjectInstanceNumber(poi,pInstName)) == (INSTANCE_ID) -1 ) {
		if ( NumInstances(poi) >= MAX_INSTANCES_PER_OBJECT ) {
			ReleaseSemaphore (hObjectMutex, 1, NULL);
			REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_INSTANCE, LOG_USER);
			SetLastError(PERFAPI_FAILED_TO_CREATE_INSTANCE);
			if (bLongTitle)
				free ((void *) pInstName);
			return (INSTANCE_ID) -1;     // so we have a limit.
		}

		InstanceId = UpdateInstanceDefinitions(poi,pInstName);
		poi->dwNumInstances++ ;
	}
	// So, this is an existing instance
	else {
		REPORT_WARNING(PERFAPI_ALREADY_EXISTS, LOG_USER);
		SetLastError (ERROR_ALREADY_EXISTS);
	}

	if ( lppInstanceStart )
		*lppInstanceStart = pommfs[poi->index].gpbCounterData +
						InstanceId * (poi->dwMaxDataSize/MAX_INSTANCES_PER_OBJECT) ;
	InstanceId |= (poi - (POBJECT_PERFINFO) (pgi + 1)) << 16;
	ReleaseSemaphore (hObjectMutex, 1, NULL);

	if (bLongTitle)
		free ((void *) pInstName);
	return InstanceId ;
} // End of MakeAPerfInstanceW


HANDLE _stdcall MakeAPerfInstanceHandleW (HANDLE hObject, LPWSTR pInstName)
{
    PINSTANCE_PERFINFO  pInstanceInfo;

    pInstanceInfo = (PINSTANCE_PERFINFO) malloc( sizeof (INSTANCE_PERFINFO));
    if (!pInstanceInfo) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_INSTANCE_HANDLE, LOG_USER);
        SetLastError(PERFAPI_FAILED_TO_CREATE_INSTANCE_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

    pInstanceInfo->iID = MakeAPerfInstanceW(hObject, pInstName, &(pInstanceInfo->lpInstanceStart));

    if (pInstanceInfo->iID == -1) {
        free (pInstanceInfo);
        return INVALID_HANDLE_VALUE;
    }
    else {
		pInstanceInfo->bCreatedByMe = BOOLEAN(GetLastError() != ERROR_ALREADY_EXISTS);
		pInstanceInfo->dwParentType = INSTANCE_TYPE;
        return pInstanceInfo;
    }
}


BOOL _stdcall DestroyPerfInstance (INSTANCE_ID iD)
{
	OBJECT_PERFINFO *poi = ObjectInfo(iD);
	INSTANCE_ID iID = InstanceID(iD);

	WaitForSingleObject(hObjectMutex,INFINITE);

	if ( (iD == (INSTANCE_ID) -1) || (poi == NULL) || InvalidPoi(poi) || (! poi->bMapped) || (iID >= MAX_INSTANCES_PER_OBJECT) ) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_ID, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_ID);
		return FALSE;
	}

	if (! HasInstances(poi)) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_ID, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_ID);
		return FALSE;
	}

	if (! poi->bInstanceMap[iID]) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_ID, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_ID);
		return FALSE;
	}
	poi->bInstanceMap[iID] = FALSE;
	poi->dwNumInstances--;
	ReleaseSemaphore (hObjectMutex, 1, NULL);
	return TRUE;

}

BOOL _stdcall DestroyPerfInstanceHandle(HANDLE pInstanceInfo)
{
	BOOL bRetVal = TRUE;
	PINSTANCE_PERFINFO pInstance = (PINSTANCE_PERFINFO) pInstanceInfo;

	if (!pInstanceInfo || pInstanceInfo == INVALID_HANDLE_VALUE) {
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);		
		return FALSE;
	}

	if (pInstance->bCreatedByMe)
		bRetVal = DestroyPerfInstance (pInstance->iID);

    free ((void *) pInstance);
    return bRetVal;
}

static LONG GetCounterNameNumber(OBJECT_PERFINFO *poi,WCHAR *pTitle)
{
    PBYTE pbNameOffset = (PBYTE) GetCounterStart(poi) + MAX_COUNTERS * sizeof(PERF_COUNTER_DEFINITION);
    LONG i;

    for (i = 0; i < (LONG) NumCounters(poi); i++, pbNameOffset += (MAX_TITLE_CHARS + 1) * sizeof(WCHAR)) {
		if ( !wcscmp((WCHAR *) pbNameOffset, pTitle))
	 	   return i;
    }

    return -1;
}


static OBJECT_PERFINFO *GetObjectDefinition(WCHAR *pObjectName)
{
	DWORD i;
	OBJECT_PERFINFO *pObjectDef ;

	if ( !pObjectName)
		return NULL;

	for ( i = 0, pObjectDef = (OBJECT_PERFINFO *) ( pgi + 1); i < MAX_PERF_OBJECTS; i++, pObjectDef++ ) {
		if ( !pObjectDef->bMapped )
			continue ;
		if (!wcscmp((TCHAR *) ((PBYTE) pObjectDef->szName), pObjectName)) {
	    	return pObjectDef;
		}
	}

	return NULL ;
}

static INSTANCE_ID  GetObjectInstanceNumber(OBJECT_PERFINFO *poi,LPWSTR pInstName)
{
    INSTANCE_ID i = 0;
    PPERF_INSTANCE_DEFINITION pInstDef;

    if (! GetInstanceStart(poi))
	    return (INSTANCE_ID) -1 ;

    for ( ; i < MAX_INSTANCES_PER_OBJECT; i++) {
		if (! poi->bInstanceMap[i])
			continue;
		pInstDef = GetInstance(poi, i);
		if (!wcscmp((WCHAR *) ((PBYTE) pInstDef + pInstDef->NameOffset), pInstName))
	    	return i;
    }

    return (INSTANCE_ID) -1 ;
}

static OBJECT_PERFINFO *UpdateObjectDefinitions(PWSTR pTitle, PWSTR pHelp)
{
	OBJECT_PERFINFO *poi ;
    DWORD dwNameTitleIndex = 0;
	DWORD dwHelpTitleIndex = 0;
	DWORD i ;

	// can't help with this
	if ( pgi->dwNumObjects == MAX_PERF_OBJECTS ) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_OBJECT, LOG_USER);
		SetLastError (PERFAPI_FAILED_TO_CREATE_OBJECT);
		return NULL ;
	}

    if (!WriteDescriptionsForPerfMon(pTitle, pHelp, &dwNameTitleIndex, &dwHelpTitleIndex))
		return NULL;

	// find a slot that is not used
	for ( i=0,poi = (OBJECT_PERFINFO *)(pgi +1) ; poi->bMapped ; poi++,i++ ) ;

    poi->perfdata.ObjectNameTitleIndex = dwNameTitleIndex;
    poi->perfdata.ObjectHelpTitleIndex = dwHelpTitleIndex;

    poi->dwNumCounters = 0;
    poi->dwCounterDataSize = 0;
    poi->dwNumInstances = 0;

	poi->perfdata.ObjectNameTitle = 0;
    wcsncpy(poi->szName, pTitle, MAX_TITLE_CHARS + 1);

	return poi ;
} // End of UpdateObjectDefinitions

static BOOL  UpdateCounterDefinitions(OBJECT_PERFINFO *poi,DWORD dwType, DWORD dwScale, DWORD dwSize, PWSTR pTitle, PWSTR pHelp, DWORD * pdwOffset)
{

	PPERF_COUNTER_DEFINITION pNewCounter;
    DWORD dwNameTitleIndex = 0;
	DWORD dwHelpTitleIndex = 0;
	DWORD dwIndex = NumCounters(poi);
	PBYTE pbNameOffset;

	// can't help with this
	if ( dwIndex == MAX_COUNTERS ) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_COUNTER, LOG_USER);
		SetLastError (PERFAPI_FAILED_TO_CREATE_COUNTER);
		return FALSE;
	}

	// When the object is created, the programmer can declare the max space for the counters of the object.
	// If this max. has been exceeded, the counter can't be created.
	if (poi->dwCounterDataSize + dwSize > poi->dwMaxCounterDataSize) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_COUNTER, LOG_USER);
		SetLastError (PERFAPI_FAILED_TO_CREATE_COUNTER);
		return FALSE;
	}

	//Add new Counter Definition to the memory map
	pNewCounter = GetCounterStart(poi) + dwIndex;
	pNewCounter->ByteLength = sizeof (PERF_COUNTER_DEFINITION);

    if (! WriteDescriptionsForPerfMon(pTitle, pHelp, &dwNameTitleIndex, &dwHelpTitleIndex))
		return FALSE;

	// We set this so that the caller knows the offset at which this data starts.
    //Note this is relative to the END of PERF_COUNTER_BLOCK, not the start
	*pdwOffset = DataSize(poi);

    pNewCounter->CounterNameTitleIndex = dwNameTitleIndex;
    pNewCounter->CounterHelpTitleIndex = dwHelpTitleIndex;

	pNewCounter->CounterNameTitle = 0;
	pbNameOffset = (PBYTE) GetCounterStart(poi) + MAX_COUNTERS * sizeof(PERF_COUNTER_DEFINITION);
	pbNameOffset += dwIndex * (MAX_TITLE_CHARS + 1) * sizeof(WCHAR);
	wcsncpy((WCHAR *)pbNameOffset, pTitle, MAX_TITLE_CHARS + 1);

	pNewCounter->CounterHelpTitle = 0;

	pNewCounter->DefaultScale = dwScale;
	pNewCounter->DetailLevel = PERF_DETAIL_NOVICE;
	pNewCounter->CounterType = dwType;

	//need to do a switch here for size!!!
	pNewCounter->CounterSize = dwSize;
	// For multiple instances
	// we use this for when the same counter of another instance comes in,
	// we'll know the offset to add to the instance-counter-data base
    pNewCounter->CounterOffset = *pdwOffset + sizeof (PERF_COUNTER_BLOCK);

	poi->dwCounterDataSize += dwSize;
	poi->dwNumCounters++;

	return TRUE;
}

static INSTANCE_ID  UpdateInstanceDefinitions(OBJECT_PERFINFO *poi, PWSTR pInstDesc)
{

	PPERF_INSTANCE_DEFINITION pNewInstance;
    DWORD dwDescLen, dwNewInstanceSlot;

	//Add new Counter Definition to the memory map
	for (dwNewInstanceSlot = 0; dwNewInstanceSlot < MAX_INSTANCES_PER_OBJECT; dwNewInstanceSlot++)
		if (! poi->bInstanceMap[dwNewInstanceSlot]) {
			poi->bInstanceMap[dwNewInstanceSlot] = TRUE;
			break;
		}
	pNewInstance = GetInstance(poi, dwNewInstanceSlot);

	dwDescLen = (wcslen(pInstDesc) + 1) * sizeof (WCHAR);

	pNewInstance->ByteLength = sizeof (PERF_INSTANCE_DEFINITION) + dwDescLen;
	pNewInstance->ParentObjectTitleIndex = 0 ;
    pNewInstance->ParentObjectInstance = 0;
    pNewInstance->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
	pNewInstance->NameLength = dwDescLen;
	pNewInstance->UniqueID = PERF_NO_UNIQUE_ID;

    memcpy(pNewInstance+1, pInstDesc, dwDescLen);

	return dwNewInstanceSlot;
}

BOOL _stdcall SetCounterValueByHandle(HANDLE hCounter, HANDLE hParent, PBYTE pbNewValue)
{
    PCOUNTER_PERFINFO    pCounterPerfInfo = (PCOUNTER_PERFINFO) hCounter;
    PINSTANCE_PERFINFO   pInstancePerfInfo = (PINSTANCE_PERFINFO) hParent;
    POBJECT_PERFINFO     pObjectPerfInfo = (POBJECT_PERFINFO) hParent;

	// check for invalid handles
	if (! pCounterPerfInfo || pCounterPerfInfo == (PCOUNTER_PERFINFO) -1) {
		REPORT_ERROR(PERFAPI_INVALID_COUNTER_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_COUNTER_HANDLE);
		return FALSE;
	}
	if (! pInstancePerfInfo || pInstancePerfInfo == (PINSTANCE_PERFINFO) -1) {
		if (pInstancePerfInfo->dwParentType == INSTANCE_TYPE) {
			REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
			SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);
			return FALSE;
		}
		else {
			REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
			SetLastError(PERFAPI_INVALID_OBJECT_HANDLE);
			return FALSE;
		}
	}
			
    // Find if the parent is an object or instance.  Our start address
    // depends on that.
    if (pObjectPerfInfo->dwParentType == OBJECT_TYPE)
        memcpy( (BYTE *) pommfs[pObjectPerfInfo->index].gpbCounterData + pCounterPerfInfo->dwOffset,
                pbNewValue, pCounterPerfInfo->dwSize);
    else if (pInstancePerfInfo->dwParentType == INSTANCE_TYPE)
        memcpy( (BYTE *) pInstancePerfInfo->lpInstanceStart + pCounterPerfInfo->dwOffset,
                pbNewValue, pCounterPerfInfo->dwSize);
	else {
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);
		return FALSE;
	}

    return TRUE;
}

BOOL _stdcall GetCounterValueByHandle(HANDLE hCounter, HANDLE hParent, PBYTE pbCounterValue)
{
    PCOUNTER_PERFINFO    pCounterPerfInfo = (PCOUNTER_PERFINFO) hCounter;
    PINSTANCE_PERFINFO   pInstancePerfInfo = (PINSTANCE_PERFINFO) hParent;
    POBJECT_PERFINFO     pObjectPerfInfo = (POBJECT_PERFINFO) hParent;

	// check for invalid handles
	if (! pCounterPerfInfo || pCounterPerfInfo == (PCOUNTER_PERFINFO) -1) {
		REPORT_ERROR(PERFAPI_INVALID_COUNTER_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_COUNTER_HANDLE);
		return FALSE;
	}
	if (! pInstancePerfInfo || pInstancePerfInfo == (PINSTANCE_PERFINFO) -1) {
		if (pInstancePerfInfo->dwParentType == INSTANCE_TYPE) {
			REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
			SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);
			return FALSE;
		}
		else {
			REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
			SetLastError(PERFAPI_INVALID_OBJECT_HANDLE);
			return FALSE;
		}
	}

    // Find if the parent is an object or instance.  Our start address
    // depends on that.
    if (pObjectPerfInfo->dwParentType == OBJECT_TYPE)
        memcpy( pbCounterValue,	(BYTE *) pommfs[pObjectPerfInfo->index].gpbCounterData + pCounterPerfInfo->dwOffset,
                pCounterPerfInfo->dwSize);
    else if (pInstancePerfInfo->dwParentType == INSTANCE_TYPE)
        memcpy( pbCounterValue, (BYTE *) pInstancePerfInfo->lpInstanceStart + pCounterPerfInfo->dwOffset,
                pCounterPerfInfo->dwSize);
	else {
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);
		return FALSE;
	}

    return TRUE;
}

BOOL _stdcall IncrementCounterByHandle(HANDLE hCounter, HANDLE hParent, PBYTE pbIncrement)
{
    PCOUNTER_PERFINFO    pCounterPerfInfo = (PCOUNTER_PERFINFO) hCounter;
    PINSTANCE_PERFINFO   pInstancePerfInfo = (PINSTANCE_PERFINFO) hParent;
    POBJECT_PERFINFO     pObjectPerfInfo = (POBJECT_PERFINFO) hParent;
    DWORD                *pdwCurrentValue;
    LARGE_INTEGER        *pliCurrentValue;

	// check for invalid handles
	if (! pCounterPerfInfo || pCounterPerfInfo == (PCOUNTER_PERFINFO) -1) {
		REPORT_ERROR(PERFAPI_INVALID_COUNTER_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_COUNTER_HANDLE);
		return FALSE;
	}
	if (! pInstancePerfInfo || pInstancePerfInfo == (PINSTANCE_PERFINFO) -1) {
		if (pInstancePerfInfo->dwParentType == INSTANCE_TYPE) {
			REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
			SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);
			return FALSE;
		}
		else {
			REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
			SetLastError(PERFAPI_INVALID_OBJECT_HANDLE);
			return FALSE;
		}
	}

    // Find if the parent is an object or instance.  Our start address
    // depends on that.
    if (pObjectPerfInfo->dwParentType == OBJECT_TYPE)	{
        if ( pCounterPerfInfo->dwSize == sizeof (DWORD) ) {
            pdwCurrentValue = (DWORD *) ((BYTE *) pommfs[pObjectPerfInfo->index].gpbCounterData + pCounterPerfInfo->dwOffset);
            *pdwCurrentValue += (DWORD) *pbIncrement;
        }

        // use the native compiler's support for LARGEINT arithmetic
        if ( pCounterPerfInfo->dwSize == 2*sizeof (DWORD) ) {
            // this is a LARGE_INTEGER counter
            pliCurrentValue = (LARGE_INTEGER *) ((BYTE *) pommfs[pObjectPerfInfo->index].gpbCounterData + pCounterPerfInfo->dwOffset);
            pliCurrentValue->QuadPart = pliCurrentValue->QuadPart + ( (LARGE_INTEGER *) pbIncrement)->QuadPart;
        }

    }

    else if (pInstancePerfInfo->dwParentType == INSTANCE_TYPE) {

        if ( pCounterPerfInfo->dwSize == sizeof (DWORD) ) {
            pdwCurrentValue = (DWORD *) ((BYTE *) pInstancePerfInfo->lpInstanceStart + pCounterPerfInfo->dwOffset);
            *pdwCurrentValue += (DWORD) *pbIncrement;
        }

        // use the native compiler's support for LARGEINT arithmetic
        if ( pCounterPerfInfo->dwSize == 2*sizeof (DWORD) )	{
            // this is a LARGE_INTEGER counter
            pliCurrentValue = (LARGE_INTEGER *) ((BYTE *) pInstancePerfInfo->lpInstanceStart + pCounterPerfInfo->dwOffset);
            pliCurrentValue->QuadPart = pliCurrentValue->QuadPart + ( (LARGE_INTEGER *) pbIncrement)->QuadPart;
        }

    }
	else {
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);
		return FALSE;
	}

    return TRUE;
}

BOOL _stdcall DecrementCounterByHandle(HANDLE hCounter, HANDLE hParent, PBYTE pbDecrement)
{
    PCOUNTER_PERFINFO    pCounterPerfInfo = (PCOUNTER_PERFINFO) hCounter;
    PINSTANCE_PERFINFO   pInstancePerfInfo = (PINSTANCE_PERFINFO) hParent;
    POBJECT_PERFINFO     pObjectPerfInfo = (POBJECT_PERFINFO) hParent;
    DWORD                *pdwCurrentValue;
    LARGE_INTEGER        *pliCurrentValue;

	// check for invalid handles
	if (! pCounterPerfInfo || pCounterPerfInfo == (PCOUNTER_PERFINFO) -1) {
		REPORT_ERROR(PERFAPI_INVALID_COUNTER_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_COUNTER_HANDLE);
		return FALSE;
	}
	if (! pInstancePerfInfo || pInstancePerfInfo == (PINSTANCE_PERFINFO) -1) {
		if (pInstancePerfInfo->dwParentType == INSTANCE_TYPE) {
			REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
			SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);
			return FALSE;
		}
		else {
			REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
			SetLastError(PERFAPI_INVALID_OBJECT_HANDLE);
			return FALSE;
		}
	}

    // Find if the parent is an object or instance.  Our start address
    // depends on that.
    if (pObjectPerfInfo->dwParentType == OBJECT_TYPE)	{
        if ( pCounterPerfInfo->dwSize == sizeof (DWORD) ) {
            // this is a DWORD counter
            pdwCurrentValue = (DWORD *) ((BYTE *) pommfs[pObjectPerfInfo->index].gpbCounterData + pCounterPerfInfo->dwOffset);
            *pdwCurrentValue -= (DWORD) *pbDecrement;
        }


        // use the native compiler's support for LARGEINT arithmetic
        if ( pCounterPerfInfo->dwSize == 2*sizeof (DWORD) )	{
            // this is a LARGE_INTEGER counter
            pliCurrentValue = (LARGE_INTEGER *) ((BYTE *) pommfs[pObjectPerfInfo->index].gpbCounterData + pCounterPerfInfo->dwOffset);
            pliCurrentValue->QuadPart = pliCurrentValue->QuadPart - ((LARGE_INTEGER *) pbDecrement)->QuadPart;
        }
    }

    else if (pInstancePerfInfo->dwParentType == INSTANCE_TYPE) {

        if ( pCounterPerfInfo->dwSize == sizeof (DWORD) ) {
            pdwCurrentValue = (DWORD *) ((BYTE *) pInstancePerfInfo->lpInstanceStart + pCounterPerfInfo->dwOffset);
            *pdwCurrentValue -= (DWORD) *pbDecrement;
        }

        // use the native compiler's support for LARGEINT arithmetic
        if ( pCounterPerfInfo->dwSize == 2*sizeof (DWORD) ) {
            // this is a LARGE_INTEGER counter
            pliCurrentValue = (LARGE_INTEGER *) ((BYTE *) pInstancePerfInfo->lpInstanceStart + pCounterPerfInfo->dwOffset);
            pliCurrentValue->QuadPart = pliCurrentValue->QuadPart - ( (LARGE_INTEGER *) pbDecrement)->QuadPart;
        }
    }
	else {
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_HANDLE, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_HANDLE);
		return FALSE;
	}

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfmsg.h ===
/*++ 

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "PerfAPI"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

#if defined(__cplusplus)
extern "C"
{
#endif

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#if defined(__cplusplus)
}
#endif 

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfcls.cxx ===
#include <windows.h>
#include <winperf.h>
#include "perfapi.h"
#include "perferr.h"
#include "perfmsg.h"


/* Implementation of the CPerfObject class */

BOOL CPerfObject::Create (char *pTitle, BOOL bHasInstances, char *pHelp, DWORD nSize)
{
		DWORD i;

    if ( (hObject = MakeAPerfObjectA (pTitle, pHelp, nSize, bHasInstances, (PVOID *)lpInstanceAddr)) != INVALID_HANDLE_VALUE ) {
		bValid = TRUE;
		cCounters = 0;
		bWithInstances = bHasInstances;
		for (i = 0; i < MAX_INSTANCES_PER_OBJECT; i++)
			iidInstances[i] = (INSTANCE_ID) -1;
		for (i = 0; i <= MAX_COUNTERS / BITS_IN_DWORD; i++)
			bCounterSize[i] = 0;
    }
	return bValid;
}

BOOL CPerfObject::Create (WCHAR *pTitle, BOOL bHasInstances, WCHAR *pHelp, DWORD nSize)
{
		DWORD i;

	if ( (hObject = MakeAPerfObjectW ((PWSTR) pTitle, (PWSTR) pHelp, nSize, bHasInstances, (PVOID *)lpInstanceAddr)) != INVALID_HANDLE_VALUE ) {
		bValid = TRUE;
		cCounters = 0;
		bWithInstances = bHasInstances;
		for (i = 0; i < MAX_INSTANCES_PER_OBJECT; i++)
			iidInstances[i] = (INSTANCE_ID) -1;
		for (i = 0; i <= MAX_COUNTERS / BITS_IN_DWORD; i++)
			bCounterSize[i] = 0;
    }
	return bValid;
}

CPerfObject::~CPerfObject ()
{
		DWORD i;

    if (bValid && (hObject != INVALID_HANDLE_VALUE)) {
		// First, destroy the remaining instances
		if (bWithInstances) {
			for (i = 0; i < MAX_INSTANCES_PER_OBJECT; i++) {
				if ((iidInstances[i] != (INSTANCE_ID) -1) && bOriginal[i])
					DestroyInstance (i);
			}
		}
		// Now, destroy the object
		DestroyPerfObject (hObject);
	}
} 
   

COUNTER_ID CPerfObject::CreateCounter (char *pCounterName, DWORD dwType, DWORD dwScale, DWORD dwSize, char *pHelp)
{
	if (! bValid) {
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return ((COUNTER_ID) -1);
	}
	if (cCounters >= MAX_COUNTERS) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_COUNTER, LOG_USER);
		SetLastError (PERFAPI_FAILED_TO_CREATE_COUNTER);
		return ((COUNTER_ID) -1);
	}
	dwCounterOffsets[cCounters] = MakeAPerfCounterA (dwType, dwScale, dwSize, hObject, pCounterName, pHelp);
    if (dwCounterOffsets[cCounters] == (DWORD) -1)
		return ((COUNTER_ID) -1);
	if (dwSize == sizeof(LARGE_INTEGER))
		bCounterSize[cCounters / BITS_IN_DWORD] |= 0x1 << (cCounters % BITS_IN_DWORD);
	return ((COUNTER_ID) cCounters++);
}

COUNTER_ID CPerfObject::CreateCounter (WCHAR *pCounterName, DWORD dwType, DWORD dwScale, DWORD dwSize, WCHAR *pHelp)
{
	if (! bValid) {
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return ((COUNTER_ID) -1);
	}
	if (cCounters >= MAX_COUNTERS) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_COUNTER, LOG_USER);
		SetLastError (PERFAPI_FAILED_TO_CREATE_COUNTER);
		return ((COUNTER_ID) -1);
	}
	dwCounterOffsets[cCounters] = MakeAPerfCounterW (dwType, dwScale, dwSize, hObject, (PWSTR) pCounterName, (PWSTR) pHelp);
    if (dwCounterOffsets[cCounters] == (DWORD) -1)
		return ((COUNTER_ID) -1);
	if (dwSize == sizeof(LARGE_INTEGER))
		bCounterSize[cCounters / BITS_IN_DWORD] |= 0x1 << (cCounters % BITS_IN_DWORD);
	return ((COUNTER_ID) cCounters++);
}

INSTANCE_ID CPerfObject::CreateInstance (char *pInstanceName)
{
		DWORD newInstanceId;

	if (! bValid) {
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return ((INSTANCE_ID) -1);
	}
	// Find a place-holder for the new instance
	for (newInstanceId = 0; newInstanceId < MAX_INSTANCES_PER_OBJECT; newInstanceId++)
		if (iidInstances[newInstanceId] == (INSTANCE_ID) -1)
			break;

	// No space for a new instance
	if (newInstanceId >= MAX_INSTANCES_PER_OBJECT) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_INSTANCE, LOG_USER);
		SetLastError(PERFAPI_FAILED_TO_CREATE_INSTANCE);
		return (INSTANCE_ID) -1;
	}

	iidInstances[newInstanceId] = MakeAPerfInstanceA (hObject, pInstanceName, (PVOID *) (lpInstanceAddr + newInstanceId));
	if (iidInstances[newInstanceId] == (INSTANCE_ID) -1)
		return ((INSTANCE_ID) -1);

	// Find out if the instance had already existed
	bOriginal[newInstanceId] = (GetLastError() != ERROR_ALREADY_EXISTS) ? TRUE : FALSE;

	return ((INSTANCE_ID) newInstanceId);

}

INSTANCE_ID CPerfObject::CreateInstance (WCHAR *pInstanceName)
{
		DWORD newInstanceId;

	if (! bValid) {
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return ((INSTANCE_ID) -1);
	}
	// Find a place-holder for the new instance
	for (newInstanceId = 0; newInstanceId < MAX_INSTANCES_PER_OBJECT; newInstanceId++)
		if (iidInstances[newInstanceId] == (INSTANCE_ID) -1)
			break;

	// No space for a new instance
	if (newInstanceId >= MAX_INSTANCES_PER_OBJECT) {
		REPORT_ERROR(PERFAPI_FAILED_TO_CREATE_INSTANCE, LOG_USER);
		SetLastError(PERFAPI_FAILED_TO_CREATE_INSTANCE);
		return (INSTANCE_ID) -1;
	}

	iidInstances[newInstanceId] = MakeAPerfInstanceW (hObject, (PWSTR) pInstanceName, (PVOID *) (lpInstanceAddr + newInstanceId));
	if (iidInstances[newInstanceId] == (INSTANCE_ID) -1)
		return ((INSTANCE_ID) -1);

	// Find out if the instance had already existed
	bOriginal[newInstanceId] = (GetLastError() != ERROR_ALREADY_EXISTS) ? TRUE : FALSE;

	return ((INSTANCE_ID) newInstanceId);

}

BOOL CPerfObject::DestroyInstance (INSTANCE_ID iid)
{
		INSTANCE_ID	iidCopy;

	if (! bValid) {
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return ((INSTANCE_ID) -1);
	}
	// Check if the given instance id is invalid
	if (iid >= MAX_INSTANCES_PER_OBJECT) {
		REPORT_ERROR(PERFAPI_INVALID_INSTANCE_ID, LOG_USER);
		SetLastError(PERFAPI_INVALID_INSTANCE_ID);
		return FALSE;
	}

	// Check if the instance was an original instance
	if ((iidInstances[iid] != (INSTANCE_ID) -1) && (! bOriginal[iid])) {
		iidInstances[iid] = (INSTANCE_ID) -1;
		return TRUE;
	}

	iidCopy = iidInstances[iid];
	iidInstances[iid] = (INSTANCE_ID) -1;
	return (DestroyPerfInstance (iidCopy));

}


/* Implementation of the CPerfCounter class */

BOOL CPerfCounter::Create (CPerfObject &cpoObject, COUNTER_ID idCounter, INSTANCE_ID idInstance)
{
	if (! cpoObject.bValid) {
		REPORT_ERROR(PERFAPI_INVALID_OBJECT_HANDLE, LOG_USER);
		SetLastError (PERFAPI_INVALID_OBJECT_HANDLE);
		return FALSE;
	}
	if (idCounter >= cpoObject.cCounters) {
		REPORT_ERROR(PERFAPI_INVALID_COUNTER_ID, LOG_USER);
		SetLastError (PERFAPI_INVALID_COUNTER_ID);
		return FALSE;
	}
	if (cpoObject.bWithInstances) {	
		if (idInstance >= MAX_INSTANCES_PER_OBJECT || cpoObject.iidInstances[idInstance] == (INSTANCE_ID) -1) {
			REPORT_ERROR(PERFAPI_INVALID_INSTANCE_ID, LOG_USER);
			SetLastError (PERFAPI_INVALID_INSTANCE_ID);
			return FALSE;
		}
		pAddr = (LPDWORD) (cpoObject.lpInstanceAddr[idInstance] + cpoObject.dwCounterOffsets[idCounter]);
	}
	else {
		pAddr = (LPDWORD) (cpoObject.lpInstanceAddr[0] + cpoObject.dwCounterOffsets[idCounter]);
	}
	bDword = (cpoObject.bCounterSize[idCounter / BITS_IN_DWORD] & (0x1 << (idCounter % BITS_IN_DWORD))) ? FALSE : TRUE;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfcls.h ===
#include <windows.h>
#include <winperf.h>
#include "perfapii.h"  // Perf API header file

#define DllExport	__declspec( dllexport )

#define	BITS_IN_DWORD	(sizeof(DWORD) << 3)

/* NOTE: The member functions for all classes are in-line */

// CPerfObject Class
class DllExport CPerfObject {
private:
		HANDLE		hObject;							// Handle to Performance Object
		BOOL		bWithInstances;						// True, if object has instances
		DWORD		cCounters;						// # of created counters for the object
		DWORD		dwCounterOffsets[MAX_COUNTERS];		// The object's counter offsets
		DWORD		bCounterSize[MAX_COUNTERS / BITS_IN_DWORD + 1];	// bitmap of counter sizes. If bit is 0, counter is a DWORD, otherwise (bit is 1), it's a LARGE_INTEGER.
		INSTANCE_ID	iidInstances[MAX_INSTANCES_PER_OBJECT]; // The object's instance ids
		BOOL		bOriginal[MAX_INSTANCES_PER_OBJECT]; // True, if the instance is original. Then, it needs to be destroyed.
		PBYTE		lpInstanceAddr[MAX_INSTANCES_PER_OBJECT];	// The object's instances' start addresses. If the object has no instances, the 0-th address is the object counter data start 

		friend class CPerfCounter;
    
public:
		CPerfObject (char *pTitle, BOOL bHasInstances, char *pHelp, DWORD nSize);
		CPerfObject (WCHAR *pTitle, BOOL bHasInstances, WCHAR *pHelp, DWORD nSize);
		~CPerfObject ();
		COUNTER_ID CreateCounter (char *pCounterName, DWORD dwType, DWORD dwScale, DWORD dwSize, char *pHelp);
		COUNTER_ID CreateCounter (WCHAR *pCounterName, DWORD dwType, DWORD dwScale, DWORD dwSize, WCHAR *pHelp);
		INSTANCE_ID CreateInstance (char *pInstanceName);
		INSTANCE_ID CreateInstance (WCHAR *pInstanceName);
		BOOL DestroyInstance (INSTANCE_ID iid);

};

// CPerfCounter Class
class DllExport CPerfCounter {
private:
		LPDWORD	pAddr;		// Read address of the counter
		BOOL	bDword;		// If TRUE, the counter is a DWORD, otherwise, it's a LARGE_INTEGER

public:
		CPerfCounter (CPerfObject cpoObject, COUNTER_ID idCounter, INSTANCE_ID idInstance);
		~CPerfCounter (void) { };

		CPerfCounter & operator = (DWORD nNewValue)
		{
			*pAddr = nNewValue;
			return *this;
		};

		CPerfCounter & operator = (LARGE_INTEGER nNewValue)
		{
			((LARGE_INTEGER *) pAddr)->QuadPart = nNewValue.QuadPart;
			return *this;
		};

		CPerfCounter & operator = (const CPerfCounter &PerfCtr)
		{
			if (bDword != PerfCtr.bDword)
				return *this;
			if (bDword)
				*pAddr = *(PerfCtr.pAddr);
			else
				((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) PerfCtr.pAddr)->QuadPart;
			return *this;
		};

		CPerfCounter & operator += (DWORD nValue)
		{
			*pAddr += nValue;
			return *this;
		};

		CPerfCounter & operator += (LARGE_INTEGER nValue)
		{
			((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart + nValue.QuadPart;
			return *this;
		};

		CPerfCounter & operator += (const CPerfCounter &PerfCtr)
		{
			if (bDword != PerfCtr.bDword)
				return *this;
			if (bDword)
				*pAddr += *(PerfCtr.pAddr);
			else
				((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart + ((LARGE_INTEGER *) PerfCtr.pAddr)->QuadPart;
			return *this;
		};

		CPerfCounter & operator -= (DWORD nValue)
		{
			*pAddr -= nValue;
			return *this;
		};

		CPerfCounter & operator -= (LARGE_INTEGER nValue)
		{
			((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart - nValue.QuadPart;
			return *this;
		};

		CPerfCounter & operator -= (const CPerfCounter &PerfCtr)
		{
			if (bDword != PerfCtr.bDword)
				return *this;
			if (bDword)
				*pAddr -= *(PerfCtr.pAddr);
			else
				((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart - ((LARGE_INTEGER *) PerfCtr.pAddr)->QuadPart;
			return *this;
		};

		CPerfCounter & operator ++ (void)
		{
			if (bDword)
				(*pAddr)++;
			else
				((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart + 1;
			return *this;
		};

		CPerfCounter & operator -- (void)
		{
			if (bDword)
				(*pAddr)--;
			else
				((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart - 1;
			return *this;
		};

		operator DWORD ()
		{
			return (*pAddr);
		};

		operator LARGE_INTEGER ()
		{
			return (* (LARGE_INTEGER *) pAddr);
		};

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfreg.h ===
/*
	File: perfreg.h

	Function prototypes for the registry mangling functions for the perfdll.
*/

#ifndef __PERFREG_H__
#define __PERFREG_H__

DWORD 	SetupRegistry();
BOOL    WriteDescriptionsForPerfMon(PTSTR pName, PTSTR pHelp, PDWORD, PDWORD);
void	RegistryCleanup();
BOOL	WriteDescriptionsToRegistry(void);
void	DeleteDescriptionForPerfMon(DWORD dwNameId, DWORD dwHelpId);


#endif // __PERFREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfreg.c ===
/*
	File: perfreg.c

	Implementation of Registry mangling functions for the perf dll.
*/

#define UNICODE 1
#define _UNICODE 1


#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <winperf.h>

#include "perfapiI.h"
#include "perfreg.h"
#include "shmem.h"
#include "perferr.h"
#include "perfmsg.h"

#define  MAX_REGISTRY_NAME_SPACE	(MAX_COUNTER_ENTRIES * (MAX_TITLE_CHARS + 6) * sizeof (WCHAR))
#define  MAX_REGISTRY_HELP_SPACE	(MAX_HELP_ENTRIES * (MAX_HELP_CHARS + 6) * sizeof (WCHAR))

extern HANDLE hRegMutex;
extern HANDLE hObjectMutex;

static WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\PerfApiCounters\\Performance";  //Registry path
static WCHAR szRegistryPathToPerflibKeys[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";  //Registry path
static WCHAR szRegistryPathToPerflibEnglishKeys[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";  //Registry path
static WCHAR szPerflibSemaphore[] = L"Updating";
static WCHAR szDllName[] = L"PerfApiCounters";

// Reads the counter, adds the passed in value and writes the new value to
// the registry. Returns 0 on Failure
static DWORD ReadAddWriteCounter (HKEY, int, LPTSTR szKeyName);
static DWORD ComputeRegistryNameStrings (LPTSTR szString);
static DWORD ComputeRegistryHelpStrings (LPTSTR szString);
static DWORD EliminatePerflibEntries (LPTSTR szString, DWORD FirstIndex);

/*
Purpose of this function is to setup the registry and not require regini and lodctr.

Things to do are to register our selves as a service in the CurrentControlSet\Services,
setup the entry points for the open,collect,close functions. If the First, Last Counter
indexes are not setup, then set them up and reserve like a 2000 counter range. we should
never be running of this limit. if it does, then too bad....
*/
DWORD SetupRegistry()
{
    DWORD action;
    LONG  result;
	DWORD dwCounterSlot;
	DWORD dwHelpSlot;
	HKEY hPerfRegKey = NULL;
	HKEY hPerflibKey = NULL;
	WCHAR szCloseAPI[] = L"AppPerfClose";
	WCHAR szCollectAPI[] = L"AppPerfCollect";
	WCHAR szOpenAPI[] = L"AppPerfOpen";

	// We start modifying the registry and other params here, so
	// put the semaphore here
	WaitForSingleObject(hRegMutex,INFINITE);

	WaitForSingleObject(hObjectMutex,INFINITE);
	if (! pgi->dwAllProcesses) {
		ReleaseSemaphore (hObjectMutex, 1, NULL);
		// Open our Performance keys, if unsuccessful create them.
		if ( ERROR_SUCCESS != (result = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryPathToPerformanceKeys, 0, NULL,
    												   REG_OPTION_NON_VOLATILE,	KEY_ALL_ACCESS,	NULL, &hPerfRegKey, &action)) ) {
			ReleaseSemaphore (hRegMutex, 1, NULL);
			REPORT_ERROR_DATA(PERFAPI_UNABLE_OPEN_DRIVER_KEY, LOG_USER, &result, sizeof(LONG)) ;
			SetLastError(PERFAPI_UNABLE_OPEN_DRIVER_KEY);
			return 0;
		}

		if (action == REG_CREATED_NEW_KEY) {
    		// so this is the first time we are running, got to populate the registry
    		RegSetValueEx (hPerfRegKey, L"Close", 0, REG_SZ, (CONST BYTE *)szCloseAPI, (wcslen(szCloseAPI)+1)*sizeof(TCHAR) ) ;
    		RegSetValueEx (hPerfRegKey, L"Collect", 0, REG_SZ, (CONST BYTE *)szCollectAPI, (wcslen(szCollectAPI)+1)*sizeof(TCHAR) ) ;
    		RegSetValueEx (hPerfRegKey, L"Open", 0, REG_SZ, (CONST BYTE *)szOpenAPI, (wcslen(szOpenAPI)+1)*sizeof(TCHAR) );
		}

		result = (LONG) SearchPath(NULL, L"PerfApi",L".dll", 1024, szBuf, NULL);
		// we are searching for ourselves and we have to find it !!?
		// !!! dumb assert, have to actually handle the case of the buffer passed
		// in being not enough. but this is the size of the szBuf.
		if ( result && result < 1024 ) {
	   		RegSetValueEx(hPerfRegKey, L"Library", 0, REG_SZ, (CONST BYTE *)szBuf, (wcslen(szBuf)+1)*sizeof(TCHAR) ) ;
		}
		RegCloseKey (hPerfRegKey);

		if ( (result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,	szRegistryPathToPerflibKeys, 0, KEY_ALL_ACCESS, &hPerflibKey)) != ERROR_SUCCESS) {
			ReleaseSemaphore (hRegMutex, 1, NULL);
			REPORT_ERROR_DATA(PERFAPI_FAILED_TO_OPEN_REGISTRY, LOG_USER, &result, sizeof(LONG) );
    		SetLastError (result);
    		return 0;
    	}
		// now we read the first and last counters in the Perflib entries and
		// reserve about a million of them.
		dwCounterSlot = ReadAddWriteCounter (hPerflibKey, MAX_COUNTER_AND_HELP_ENTRIES, L"Last Counter");
		if (! dwCounterSlot) {
			ReleaseSemaphore (hRegMutex, 1, NULL);
			RegCloseKey (hPerflibKey);
			return 0;
		}
		dwHelpSlot = ReadAddWriteCounter (hPerflibKey, MAX_COUNTER_AND_HELP_ENTRIES, L"Last Help");
		if (! dwHelpSlot) {
			ReadAddWriteCounter (hPerflibKey, -MAX_COUNTER_AND_HELP_ENTRIES, L"Last Counter");
			ReleaseSemaphore (hRegMutex, 1, NULL);
			RegCloseKey (hPerflibKey);
			return 0;
		}

		pgi->dwFirstCounterIndex = (dwCounterSlot - MAX_COUNTER_AND_HELP_ENTRIES) + 2;
		pgi->dwFirstHelpIndex = (dwHelpSlot - MAX_COUNTER_AND_HELP_ENTRIES) + 2;
		RegCloseKey	(hPerflibKey);

		pgi->bRegistryChanges = FALSE;
	}
	else
		ReleaseSemaphore (hObjectMutex, 1, NULL);

	// make sure the registry is not half initialized etc.
	ReleaseSemaphore (hRegMutex, 1, NULL);
	return 1;
} // SetupRegistry


// The following function is now called only by PerfMon to update the registry, with every
// collection of data.

BOOL WriteDescriptionsToRegistry(void)
{
	DWORD dwNameTempSize, dwHelpTempSize;
	DWORD i;
	LONG  lStatus;
	HKEY  hPerflibKey = NULL;
	HKEY  hLangKey = NULL;
	LPTSTR szHelpText;
	LPTSTR szNameText;
	DWORD  dwHelpSize;
	DWORD  dwNameSize;

	// We start modifying the registry and other params here, so
	// put the semaphore here
	i = WaitForSingleObject(hRegMutex, MAX_PERFMON_WAIT);

	// Do not want to stall PerfMon for ever, if some semaphore never gets released (because of a TerminateProcess/Thread).
	if (WAIT_TIMEOUT == i) {
		if (! pgi->bRegistryChanges)
			return TRUE;
		else
			return FALSE;
	}

	if (! pgi->bRegistryChanges) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		return TRUE;
	}

	if ( (lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryPathToPerflibKeys, 0, KEY_ALL_ACCESS, &hPerflibKey)) != ERROR_SUCCESS) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		REPORT_ERROR_DATA(PERFAPI_FAILED_TO_OPEN_REGISTRY, LOG_USER, &lStatus, sizeof(LONG) ) ;
    	SetLastError (lStatus);
    	return FALSE;
    }
	lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryPathToPerflibEnglishKeys, 0, KEY_ALL_ACCESS, &hLangKey);
    if (lStatus != ERROR_SUCCESS) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		REPORT_ERROR_DATA(PERFAPI_FAILED_TO_OPEN_REGISTRY, LOG_USER, &lStatus, sizeof(LONG)) ;
        SetLastError (lStatus);
		RegCloseKey (hPerflibKey);
        return FALSE;
    }

	// Wait for the "Updating" value in the Perflib key, to be cleared. This is for synchronization
	// with lodctr.  Max wait time is 10sec.
	for (i = 0, lStatus = ERROR_SUCCESS; lStatus == ERROR_SUCCESS && i < 10; i++, Sleep(1000)) {
		dwNameTempSize = 1024;
		lStatus = RegQueryValueEx (hPerflibKey, szPerflibSemaphore, NULL, NULL, (LPBYTE) szBuf, &dwNameTempSize);
	}
	if (i == 10) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		return FALSE;
	}
	// Now, create the "Updating" value to prevent lodctr from changing the registry.
    RegSetValueEx (hPerflibKey, szPerflibSemaphore, 0, REG_SZ, (CONST BYTE *) szDllName,
    			   (lstrlen(szDllName) + 1) * sizeof(TCHAR));

	// get size of counter names
   	lStatus = RegQueryValueEx (hLangKey, L"Counter", NULL, NULL, NULL, &dwNameSize);
    if (lStatus != ERROR_SUCCESS) {
		RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		REPORT_ERROR_DATA(PERFAPI_UNABLE_READ_COUNTERS, LOG_USER, &lStatus, sizeof(LONG));
		return FALSE;
    }
	dwNameSize += 4096 + MAX_REGISTRY_NAME_SPACE;
	dwNameSize &= 0xFFFFF000;
	szNameText = (LPTSTR) malloc (dwNameSize);
	if (! szNameText) {
		RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		REPORT_ERROR_DATA(PERFAPI_UNABLE_READ_COUNTERS, LOG_USER, &lStatus, sizeof(LONG));
		return FALSE;
    }
	// get the help text size
   	lStatus = RegQueryValueEx (hLangKey, L"Help", NULL, NULL, NULL, &dwHelpSize);
    if (lStatus != ERROR_SUCCESS) {
		RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		free (szNameText);
		REPORT_ERROR_DATA(PERFAPI_UNABLE_READ_HELPTEXT, LOG_USER, &lStatus, sizeof(LONG));
		return FALSE;
    }
	dwHelpSize += 4096 + MAX_REGISTRY_HELP_SPACE;
	dwHelpSize &= 0xFFFFF000;
	szHelpText = (LPTSTR) malloc (dwHelpSize);
	if (! szHelpText) {
		RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		free (szNameText);
		REPORT_ERROR_DATA(PERFAPI_UNABLE_READ_HELPTEXT, LOG_USER, &lStatus, sizeof(LONG));
		return FALSE;
    }
  	// read the counter help text into buffer. Counter help text will be stored as
    // a MULTI_SZ string in the format of "###" "Help"
	for (lStatus = ERROR_MORE_DATA; lStatus == ERROR_MORE_DATA; ) {
		dwHelpTempSize = dwHelpSize;
    	lStatus = RegQueryValueEx (hLangKey, L"Help", NULL,	NULL, (LPBYTE) szHelpText, &dwHelpTempSize);
		switch (lStatus) {
		case ERROR_MORE_DATA: dwHelpSize = 4096 + dwHelpTempSize + MAX_REGISTRY_HELP_SPACE;
							  dwHelpSize &= 0xFFFFF000;
							  szHelpText = (LPTSTR) realloc ((void *) szHelpText, dwHelpSize);
							  break;
		case ERROR_SUCCESS:   if (dwHelpSize < dwHelpTempSize + MAX_REGISTRY_HELP_SPACE) {
								dwHelpSize += MAX_REGISTRY_HELP_SPACE + 0xFFF;
								dwHelpSize &= 0xFFFFF000;
								szHelpText = (LPTSTR) realloc ((void *) szHelpText, dwHelpSize);
							  }
							  break;
		default:			  REPORT_ERROR_DATA(PERFAPI_UNABLE_READ_HELPTEXT, LOG_USER, &lStatus, sizeof(LONG));
							  RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
							  ReleaseSemaphore (hRegMutex, 1, NULL);
							  RegCloseKey (hPerflibKey);
							  RegCloseKey (hLangKey);
							  free (szNameText);
							  free (szHelpText);
							  return FALSE;
		}
	}
	// read the counter text into buffer. Counter text will be stored as
    // a MULTI_SZ string in the format of "###" "Counter"
	for (lStatus = ERROR_MORE_DATA; lStatus == ERROR_MORE_DATA; ) {
		dwNameTempSize = dwNameSize;
    	lStatus = RegQueryValueEx (hLangKey, L"Counter", NULL, NULL, (LPBYTE) szNameText, &dwNameTempSize);
		switch (lStatus) {
		case ERROR_MORE_DATA: dwNameSize = 4096 + dwNameTempSize + MAX_REGISTRY_NAME_SPACE;
							  dwNameSize &= 0xFFFFF000;
							  szNameText = (LPTSTR) realloc ((void *) szNameText, dwNameSize);
							  break;
		case ERROR_SUCCESS:   if (dwNameSize < dwNameTempSize + MAX_REGISTRY_NAME_SPACE) {
								dwNameSize += MAX_REGISTRY_NAME_SPACE + 0xFFF;
								dwNameSize &= 0xFFFFF000;
								szNameText = (LPTSTR) realloc ((void *) szNameText, dwNameSize);
							  }
							  break;
		default:			  REPORT_ERROR_DATA(PERFAPI_UNABLE_READ_COUNTERS, LOG_USER, &lStatus, sizeof(LONG));
							  RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
							  ReleaseSemaphore (hRegMutex, 1, NULL);
							  RegCloseKey (hPerflibKey);
							  RegCloseKey (hLangKey);
							  free (szNameText);
							  free (szHelpText);
							  return FALSE;
		}
	}

	// Let's add the Dynamic registry entries
	dwNameTempSize = ComputeRegistryNameStrings (szNameText);
	dwHelpTempSize = ComputeRegistryHelpStrings (szHelpText);

    //OK, let's write it
    lStatus = RegSetValueEx(hLangKey, TEXT("Counter"), 0, REG_MULTI_SZ, (LPBYTE) szNameText, dwNameTempSize);
	if (lStatus != ERROR_SUCCESS) {
		REPORT_ERROR_DATA(PERFAPI_FAILED_TO_UPDATE_REGISTRY, LOG_USER, &lStatus, sizeof(LONG));
		RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		free (szNameText);
		free (szHelpText);
		return FALSE;
	}
	lStatus = RegSetValueEx(hLangKey, TEXT("Help"), 0, REG_MULTI_SZ, (LPBYTE) szHelpText, dwHelpTempSize);
	if (lStatus != ERROR_SUCCESS) {
		REPORT_ERROR_DATA(PERFAPI_FAILED_TO_UPDATE_REGISTRY, LOG_USER, &lStatus, sizeof(LONG));
		RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		free (szNameText);
		free (szHelpText);
		return FALSE;
	}

    // delete the Updating value from the Perflib key, to let lodctr access it, again
	RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);
	pgi->bRegistryChanges = FALSE;
	ReleaseSemaphore (hRegMutex, 1, NULL);
	RegFlushKey (hLangKey);
	RegCloseKey (hPerflibKey);
	RegCloseKey (hLangKey);
	free (szNameText);
	free (szHelpText);

    return TRUE; // the index for the counter name in the registry
}

// The following function computes the "Counters" strings that will be
// written to the registry by WriteDescriptionsToRegistry

static DWORD ComputeRegistryNameStrings (LPTSTR szString)
{
		LPTSTR szTemp;
		DWORD  i;
		int    j;

	if (! szString)
		return 0;

	// Eliminate the old registry strings which could be no longer valid.
	szTemp = (LPTSTR) (((PBYTE) szString + EliminatePerflibEntries (szString, pgi->dwFirstCounterIndex)) - sizeof (TCHAR));

	// Add the PerfAPI strings in the buffer
	for (i = 0; i < MAX_COUNTER_ENTRIES; i++) {
		if (pgi->NameStrings[i][0] != L'\0') {
			// this is a useful string that we need to add
			j = wsprintf (szTemp, L"%lu", pgi->dwFirstCounterIndex + (i << 1));
			szTemp = (LPTSTR) (((PBYTE) szTemp) + (j + 1) * sizeof(WCHAR));
			j = wsprintf (szTemp, L"%ls", pgi->NameStrings[i]);
			szTemp = (LPTSTR) (((PBYTE) szTemp) + (j + 1) * sizeof(WCHAR));
		}
	}
	*szTemp = L'\0';
	return (DWORD)((PBYTE) szTemp - (PBYTE) szString) + sizeof(TCHAR);
}


// The following function computes the "Help" strings that will be
// written to the registry by WriteDescriptionsToRegistry

static DWORD ComputeRegistryHelpStrings (LPTSTR szString)
{
		LPTSTR szTemp;
		DWORD  i;
		int    j;

	if (! szString)
		return 0;

	// Eliminate the old registry strings which could be no longer valid.
	szTemp = (LPTSTR) (((PBYTE) szString + EliminatePerflibEntries (szString, pgi->dwFirstHelpIndex)) - sizeof (TCHAR));

	// Add the PerfAPI strings in the buffer
	for (i = 0; i < MAX_HELP_ENTRIES; i++) {
		if (pgi->HelpStrings[i][0] != L'\0') {
			// this is a useful string that we need to add
			j = wsprintf (szTemp, L"%lu", pgi->dwFirstHelpIndex + (i << 1));
			szTemp = (LPTSTR) (((PBYTE) szTemp) + (j + 1) * sizeof(WCHAR));
			j = wsprintf (szTemp, L"%ls", pgi->HelpStrings[i]);
			szTemp = (LPTSTR) (((PBYTE) szTemp) + (j + 1) * sizeof(WCHAR));
		}
	}
	*szTemp = L'\0';
	return (DWORD)((PBYTE) szTemp - (PBYTE) szString) + sizeof(TCHAR);
}




// The following function eliminates from the MULTI_SZ string (which is assumed to be in the
// format "#### Text") all pairs where the #### is in the range [FirstIndex, LastIndex]

#define IndexInRange(sz)	((dwVal = (DWORD) _wtoi(sz)) >= FirstIndex && dwVal <= LastIndex)

static DWORD EliminatePerflibEntries (LPTSTR szString, DWORD FirstIndex)
{
	LPTSTR	szLook = szString, szStore, szTemp;
	DWORD dwVal, dwSize;
	DWORD LastIndex = (FirstIndex + MAX_COUNTER_AND_HELP_ENTRIES) - 2;

	if (! szLook)
		return 0;

	// find the first interesting index in the range
	while (*szLook) {
		if (IndexInRange(szLook))
			break;
		szLook += lstrlen(szLook) + 1;
		szLook += lstrlen(szLook) + 1;
	}
	// no changes needed!
	if (! *szLook)
		return (DWORD)((PBYTE) szLook - (PBYTE) szString) + sizeof(TCHAR);
	
	for (szStore = szLook, szLook += lstrlen(szLook) + 1, szLook += lstrlen(szLook) + 1;
		 *szLook; ) {
		if (! IndexInRange(szLook)) {
			szTemp = szLook + lstrlen(szLook) + 1;
			dwSize = lstrlen(szLook) + lstrlen(szTemp) + 2;
			memmove ((void *) szStore, (void *) szLook, dwSize * sizeof(TCHAR));
			szLook += dwSize;
			szStore += dwSize;
			continue;
		}
		szLook += lstrlen(szLook) + 1;
		szLook += lstrlen(szLook) + 1;
	}
	*szStore = L'\0';
	return (DWORD)((PBYTE) szStore - (PBYTE) szString) + sizeof(TCHAR);

}

// The following function finds the last counter/help id that is used in a given
// registry name/help string.

static DWORD GetLastId (LPTSTR szLook)
{
	DWORD dwLastId = 0;
	DWORD dwVal;

	if (! szLook)
		return 0;

	while (*szLook) {
		dwVal = (DWORD) _wtoi(szLook);
		if (dwVal > dwLastId)
			dwLastId = dwVal;
		szLook += lstrlen(szLook) + 1;
		szLook += lstrlen(szLook) + 1;
	}
	return dwLastId;

}



DWORD ReadAddWriteCounter(HKEY hRegKey, int addValue, LPTSTR szKeyName)
{
	DWORD size;
	LONG  status;
	DWORD dwCounterSlot;

    // obviously the reg key should already be open
    assert(hRegKey);

	size = sizeof (DWORD);
	status = RegQueryValueEx(hRegKey, szKeyName, NULL, NULL, (LPBYTE) &dwCounterSlot, &size);
	if (status != ERROR_SUCCESS) {
		REPORT_ERROR_DATA(PERFAPI_FAILED_TO_READ_REGISTRY, LOG_USER, &status, sizeof(LONG));
		SetLastError(status);
		return 0;
	}
	
	dwCounterSlot += addValue ;
	// set the value
	status = RegSetValueEx(hRegKey, szKeyName, 0, REG_DWORD, (CONST BYTE *) &dwCounterSlot, sizeof(DWORD));
	if (status != ERROR_SUCCESS) {
		REPORT_ERROR_DATA(PERFAPI_FAILED_TO_UPDATE_REGISTRY, LOG_USER, &status, sizeof(LONG));
		SetLastError(status);
		return 0;
	}

	return dwCounterSlot;
}	


void RegistryCleanup ()
{
	LONG  lStatus;
	DWORD i;
	HKEY  hPerflibKey = NULL;
	HKEY  hPerfRegKey = NULL;
	HKEY  hLangKey = NULL;
	LPTSTR szHelpText;
	LPTSTR szNameText;
	DWORD  dwHelpSize;
	DWORD  dwNameSize;

	lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryPathToPerflibKeys, 0, KEY_ALL_ACCESS, &hPerflibKey);
	if (lStatus != ERROR_SUCCESS)
		return;
	lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryPathToPerflibEnglishKeys, 0, KEY_ALL_ACCESS, &hLangKey);
	if (lStatus != ERROR_SUCCESS) {
		RegCloseKey (hPerflibKey);
		return;
	}

	WaitForSingleObject (hRegMutex, INFINITE);

	// Wait for the "Updating" value in the Perflib key, to be cleared. This is for synchronization
	// with lodctr.  Max wait time is 10sec.
	for (i = 0, lStatus = ERROR_SUCCESS; lStatus == ERROR_SUCCESS && i < 10; i++, Sleep(1000)) {
		dwNameSize = 1024;
		lStatus = RegQueryValueEx (hPerflibKey, szPerflibSemaphore, NULL, NULL, (LPBYTE) szBuf, &dwNameSize);
	}
		
	// Now, create the "Updating" value to prevent lodctr from changing the registry.
   	RegSetValueEx (hPerflibKey, szPerflibSemaphore, 0, REG_SZ, (CONST BYTE *) szDllName,
   				   (lstrlen(szDllName) + 1) * sizeof(TCHAR));

	lStatus = RegQueryValueEx (hLangKey, L"Counter", NULL, NULL, NULL, &dwNameSize);
	if (lStatus != ERROR_SUCCESS) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		return;
   	}
	szNameText = (LPTSTR) malloc (dwNameSize);
	if (! szNameText) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		return;
   	}
	lStatus = RegQueryValueEx (hLangKey, L"Help", NULL, NULL, NULL, &dwHelpSize);
   	if (lStatus != ERROR_SUCCESS) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		free (szNameText);
		return;
   	}
	szHelpText = (LPTSTR) malloc (dwHelpSize);
	if (! szHelpText) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		RegCloseKey (hPerflibKey);
		RegCloseKey (hLangKey);
		free (szNameText);
		return;
   	}
	// read the counter help text into buffer. Counter help text will be stored as
   	// a MULTI_SZ string in the format of "###" "Help"
	for (lStatus = ERROR_MORE_DATA; lStatus == ERROR_MORE_DATA; ) {
   		lStatus = RegQueryValueEx (hLangKey, L"Help", NULL,	NULL, (LPBYTE) szHelpText, &dwHelpSize);
		switch (lStatus) {
		case ERROR_MORE_DATA: szHelpText = (LPTSTR) realloc ((void *) szHelpText, dwHelpSize);
							  break;
		case ERROR_SUCCESS:   break;
		default:			  ReleaseSemaphore (hRegMutex, 1, NULL);
							  RegCloseKey (hPerflibKey);
							  RegCloseKey (hLangKey);
							  free (szNameText);
							  free (szHelpText);
							  return;
		}
	}
	// read the counter text into buffer. Counter text will be stored as
   	// a MULTI_SZ string in the format of "###" "Counter"
	for (lStatus = ERROR_MORE_DATA; lStatus == ERROR_MORE_DATA; ) {
   		lStatus = RegQueryValueEx (hLangKey, L"Counter", NULL, NULL, (LPBYTE) szNameText, &dwNameSize);
		switch (lStatus) {
		case ERROR_MORE_DATA: szNameText = (LPTSTR) realloc ((void *) szNameText, dwNameSize);
							  break;
		case ERROR_SUCCESS:   break;
		default:			  ReleaseSemaphore (hRegMutex, 1, NULL);
							  RegCloseKey (hPerflibKey);
							  RegCloseKey (hLangKey);
							  free (szNameText);
							  free (szHelpText);
							  return;
		}
	}

	RegDeleteKey (HKEY_LOCAL_MACHINE, szRegistryPathToPerformanceKeys);

	// Cleanup the Help and Counter Perflib values
	dwNameSize = EliminatePerflibEntries (szNameText, pgi->dwFirstCounterIndex);
	dwHelpSize = EliminatePerflibEntries (szHelpText, pgi->dwFirstHelpIndex);

	// Write the cleaned Perflib entries to the Registry
	if (dwNameSize)
		RegSetValueEx(hLangKey, TEXT("Counter"), 0, REG_MULTI_SZ, (LPBYTE) szNameText, dwNameSize);
	if (dwHelpSize)
		RegSetValueEx(hLangKey, TEXT("Help"), 0, REG_MULTI_SZ, (LPBYTE) szHelpText, dwHelpSize);
	RegCloseKey (hLangKey);

	i = GetLastId (szNameText);
	RegSetValueEx (hPerflibKey, L"Last Counter", 0, REG_DWORD, (CONST BYTE *) &i, sizeof(DWORD));
	i = GetLastId (szHelpText);
	RegSetValueEx (hPerflibKey, L"Last Help", 0, REG_DWORD, (CONST BYTE *) &i, sizeof(DWORD));

	// delete the Updating value from the Perflib key, to let lodctr access it, again
	RegDeleteValue (hPerflibKey, (LPTSTR) szPerflibSemaphore);

	ReleaseSemaphore (hRegMutex, 1, NULL);
	free (szNameText);
	free (szHelpText);
	RegCloseKey (hPerflibKey);

}


BOOL WriteDescriptionsForPerfMon (PTSTR pNameToAdd, PTSTR pHelpToAdd, PDWORD pdwCounterSlot, PDWORD pdwHelpSlot)
{
    DWORD dwNameToAddSize, dwHelpToAddSize;
	DWORD j;
	BOOL bSlotFound;

    if ((! pHelpToAdd) || (! lstrlen(pHelpToAdd)))
		pHelpToAdd = L"No explanation provided"; // We'll make help optional

    dwNameToAddSize = (lstrlen(pNameToAdd) + 1) * sizeof (WCHAR);
    dwHelpToAddSize = (lstrlen(pHelpToAdd) + 1) * sizeof (WCHAR);

	// We start modifying the registry and other params here, so
	// put the semaphore here
	WaitForSingleObject(hRegMutex,INFINITE);

	// Find out the registry indices for the Help and the Counter
	for (bSlotFound = FALSE, j = 0; j < MAX_COUNTER_ENTRIES; j++)
		if (pgi->NameStrings[j][0] == L'\0') {
			bSlotFound = TRUE;
			break;
		}
	if (! bSlotFound) {
		ReleaseSemaphore (hRegMutex, 1, NULL);
		REPORT_ERROR(PERFAPI_OUT_OF_REGISTRY_ENTRIES, LOG_USER);
		SetLastError(PERFAPI_OUT_OF_REGISTRY_ENTRIES);
		return FALSE;
	}
    *pdwCounterSlot = pgi->dwFirstCounterIndex + (j << 1);
    *pdwHelpSlot = pgi->dwFirstHelpIndex + (j << 1);

	// Add the new entries
	memcpy ((void *) (pgi->NameStrings[j]), (void *) pNameToAdd, dwNameToAddSize);
	memcpy ((void *) (pgi->HelpStrings[j]), (void *) pHelpToAdd, dwHelpToAddSize);

	pgi->bRegistryChanges = TRUE;

	ReleaseSemaphore (hRegMutex, 1, NULL);

	return TRUE;
}


void DeleteDescriptionForPerfMon (DWORD dwNameId, DWORD dwHelpId)
{

	// We start modifying the registry info here, so put the semaphore here
	WaitForSingleObject(hRegMutex,INFINITE);

	pgi->NameStrings[(dwNameId - pgi->dwFirstCounterIndex) >> 1][0] = L'\0';
	pgi->HelpStrings[(dwHelpId - pgi->dwFirstHelpIndex) >> 1][0] = L'\0';

	pgi->bRegistryChanges = TRUE;

	ReleaseSemaphore (hRegMutex, 1, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfutil.c ===
/*++ 

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

--*/
//
//  include files
//

#define UNICODE 1
#define _UNICODE 1

#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "perferr.h"	 // error message definition
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log
extern TCHAR szBuf[];

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = L"EventLogLevel";
	TCHAR EventLogRegistryPath[] = L"System\\CurrentControlSet\\Services\\EventLog\\Application\\PerfAPI";
    LONG lStatus;
    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;
	DWORD result;
	HKEY  hPerfEventLogKey;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
		lStatus = RegCreateKeyEx (HKEY_LOCAL_MACHINE, (LPCTSTR) EventLogRegistryPath, 0, NULL, 
    					 		 REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hPerfEventLogKey, &result);
		if (lStatus == ERROR_SUCCESS) {
			result = SearchPath(NULL, L"PerfApi", L".dll", 1024, szBuf, NULL);
			if ( result && result < 1024 ) {
		   		RegSetValueEx(hPerfEventLogKey, L"EventMessageFile", 0, REG_EXPAND_SZ, (CONST BYTE *)szBuf, (wcslen(szBuf)+1)*sizeof(TCHAR) ) ;
				result = 7;
				RegSetValueEx(hPerfEventLogKey, L"TypesSupported", 0, REG_DWORD, (CONST BYTE *) &result, sizeof(DWORD));
			}
		}
        hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            TEXT(APP_NAME));               // event log app name to find in registry

        if (hEventLog != NULL) {
           REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
        }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != L'\0') && (*pwcTypeChar != L'\0')) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != L'\0') && (*pwcTypeChar != L'\0')) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != L'\0') && (*pwcTypeChar != L'\0')) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == NULL) return FALSE;    // null pointer, # not found

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\shmem.h ===
/*
	File: shmem.h

	Function prototypes for the routines which create/maintain 
	the Shared Memory used by the perf dll.

	All of these are internal to the dll
*/

#ifndef __SHMEM_H__
#define __SHMEM_H__

BOOL     SetupGlobalDataMemory(void);
void	 ReleaseGlobalDataMemory(void);
BOOL     SetupAllSharedMemory(void);

BOOL 	 SetupObjectSharedMemory(OBJECT_PERFINFO *poi) ;
void 	 ReleaseObjectSharedMemory(OBJECT_PERFINFO *poi) ;

BOOL     SetupObjectDefinitionFiles (OBJECT_PERFINFO *poi);

#endif // __SHMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PerfAPI.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\shmem.c ===
/*
	File: shmem.c

	Contains routines which create/maintain the Shared Memory used by the perf dll.
*/

#define UNICODE 1
#define _UNICODE 1


#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <winperf.h>

#include "perfapiI.h"
#include "shmem.h"
#include "perferr.h"
#include "perfmsg.h"

static TCHAR szObjectDefinitionSharedMemory[] = TEXT("PerAPI Object Definitions ShMem");
static TCHAR szGlobalInfoSharedMemory[] = TEXT("PerfAPI Global Info ShMem");

static HANDLE hGlobalInfo = NULL;

/*++
  	SetupAllSharedMemory:: Used to setup all the memory, now sets up only the global
	memory. The global memory consists of the GLOBAL_PERFINF and the object definitions.
	The number of objects are defined by MAX_PERF_OBJECTS.

	The shared memory for each object is setup when the object is created by the
	MakeAPerfObject call, and it is destroyed by the DestroyObject call.
--*/
BOOL SetupAllSharedMemory(void)
{
	DWORD i = 0;

    if (!SetupGlobalDataMemory())
		return FALSE ;

	// Allocate the required memory
	if ( ! pommfs )	{
		pommfs = malloc(sizeof(OBJECT_MMF_PTRS) * MAX_PERF_OBJECTS) ;
		if (! pommfs) {
			REPORT_ERROR(PERFAPI_OUT_OF_MEMORY, LOG_USER);
			SetLastError(PERFAPI_OUT_OF_MEMORY);
			return FALSE;
		}
	}
	for (; i < MAX_PERF_OBJECTS; i++)
		pommfs[i].bMapped = FALSE;

    return TRUE ;
}

/*++
  	SetupGlobalDataMemory:: Called once per process (I guess) but more importantly
	should be run to completion only once for the whole system.

	Creates the memory map file where the global data is stored and the Object
	definitions are to be stored. The Maximum number of Objects that can be defined
	is a constant and is set in MAX_PERF_OBJECTS. The size of the Global Data memory
	is therefore the size of the single GLOBAL_PERFINFO + the size required for
	MAX_PERF_OBJECTS of OBJECT_PERFINFO.
--*/
BOOL SetupGlobalDataMemory(void)
{
	static DWORD sizeOfGlobalData = sizeof(GLOBAL_PERFINFO) + MAX_PERF_OBJECTS * sizeof(OBJECT_PERFINFO);
	DWORD i;
	POBJECT_PERFINFO poi;
	DWORD			 dwLastError;

    if (pgi)
        return TRUE;

    hGlobalInfo = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE | SEC_COMMIT,
                                    0, sizeOfGlobalData, szGlobalInfoSharedMemory);

    if ( !hGlobalInfo ) {
		REPORT_ERROR(PERFAPI_FAILED_TO_ALLOC_OBJECT_SHMEM, LOG_USER);
        return FALSE;
    }

	dwLastError = GetLastError();

	pgi = (GLOBAL_PERFINFO *) MapViewOfFile(hGlobalInfo, FILE_MAP_WRITE,  0,0,0);
	if (! pgi) {
		REPORT_ERROR(PERFAPI_FAILED_TO_ALLOC_OBJECT_SHMEM, LOG_USER);
        CloseHandle(hGlobalInfo);
        hGlobalInfo = NULL;
        return FALSE;
    }

	if (dwLastError != ERROR_ALREADY_EXISTS) {
		pgi->dwNumObjects = 0 ;
		pgi->dwAllProcesses = 0;
		for (i = 0; i < MAX_COUNTER_ENTRIES; i++)
			pgi->NameStrings[i][0] = L'\0';
		for (i = 0; i < MAX_HELP_ENTRIES; i++)
			pgi->HelpStrings[i][0] = L'\0';
		for (i = 0, poi = (POBJECT_PERFINFO) (pgi + 1); i < MAX_PERF_OBJECTS; i++, poi++) {
			poi->bMapped = FALSE;
			poi->index = i;
			poi->dwSequence = 0;
		}
	}

    return TRUE;
}

void ReleaseGlobalDataMemory()
{
    if ( !pgi )	{
	    UnmapViewOfFile(pgi) ;
        pgi = NULL;
    }

    if ( hGlobalInfo ) {
	    CloseHandle(hGlobalInfo);
        hGlobalInfo = NULL;
    }
}

/*++
	SetupObjectSharedMemory:: Setups shared memory for a new object being created.
	
	The original SetupAllDatamemory used to assume there was one object, since this
	is no longer true, everytime a new object is created this should be invoked to
	setup the memory for that object.

	The set of calls is a straight pull from the old SetupAllDataMemory, the params
	to the calls have adjusted to take in an object perfinfo ptr.
--*/
BOOL SetupObjectSharedMemory (POBJECT_PERFINFO poi)
{
    BOOL fSuccess = FALSE;
	OBJECT_MMF_PTRS *p = pommfs + poi->index;

    p->hObjectDef = NULL;
    p->gpbCounterDefinitions = NULL;
    p->gpbInstanceDefinitions = NULL;
    p->gpbCounterData = NULL;

	// The shared memory for an object should be setup only once, we check this
	// by looking at the name, as there has to be a name always, if the object
	// was initialized before.
	if (SetupObjectDefinitionFiles (poi))
        fSuccess = TRUE;

    if ( fSuccess )
	    p->bMapped = TRUE ;
    else
        ReleaseObjectSharedMemory(poi);

    return fSuccess;
}

/*++
	ReleaseObjectSharedMemory:: Unmaps the memory map files that were mapped.
	Hopefully the OS should free the memory once all the maps are unmapped
--*/
void ReleaseObjectSharedMemory(OBJECT_PERFINFO *poi)
{
	OBJECT_MMF_PTRS *p = pommfs + poi->index;

	if (p->gpbCounterDefinitions)
	    UnmapViewOfFile (p->gpbCounterDefinitions);

    if ( p->hObjectDef )
        CloseHandle(p->hObjectDef);

	p->bMapped = FALSE;
}

/*++
	SetupObjectDefinitionFiles: Sets up all the shared memory (counter defs, instance defs, and
	counter data) for an Object.

--*/
BOOL SetupObjectDefinitionFiles(OBJECT_PERFINFO *poi)
{
	OBJECT_MMF_PTRS *p = pommfs + poi->index;
	DWORD dwMemorySize = COUNTER_DEF_MM_SIZE + poi->dwMaxDataSize;
	WCHAR *r;
	WCHAR *q;

	if (HasInstances(poi))
		dwMemorySize += INSTANCE_DEF_MM_SIZE;

	wsprintf(szBuf,TEXT("%s_%s_%lu_%lu"),szObjectDefinitionSharedMemory, poi->szName, poi->index, poi->dwSequence);
	// Eliminate '\\'s
	for (r = q = szBuf; *r != L'\0'; r++)
		if (*r != L'\\')
			*q++ = *r;
	p->hObjectDef = CreateFileMapping (INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE | SEC_COMMIT, 0,
						               dwMemorySize, szBuf);
	if (! p->hObjectDef)
	    return FALSE;

    //I need to find a way to make sure we don't keep a mapping when we exit.!!!
    p->gpbCounterDefinitions =	(PBYTE) MapViewOfFile (p->hObjectDef, FILE_MAP_WRITE, 0, 0, dwMemorySize);

    if (! p->gpbCounterDefinitions) {
        CloseHandle(p->hObjectDef);
        p->hObjectDef = NULL;
		return FALSE;
	}

	if (HasInstances(poi)) {
		p->gpbInstanceDefinitions = p->gpbCounterDefinitions + COUNTER_DEF_MM_SIZE;
		p->gpbCounterData = p->gpbInstanceDefinitions + INSTANCE_DEF_MM_SIZE;
	}
	else {
		p->gpbCounterData = p->gpbCounterDefinitions + COUNTER_DEF_MM_SIZE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\perfapi\src\perfutil.h ===
/*++ 

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a
// performance data instance (PERF_INSTANCE_DEFINITION) as described in
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\pgthread.cpp ===
// pgthread.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "pgthread.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegThreadPage property page

IMPLEMENT_DYNCREATE(CRegThreadPage, CRegPropertyPage)

CRegThreadPage::CRegThreadPage() : CRegPropertyPage(CRegThreadPage::IDD)
{
	//{{AFX_DATA_INIT(CRegThreadPage)
	m_fAsyncTrace = TRUE;
	//}}AFX_DATA_INIT

	m_nThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
}

CRegThreadPage::~CRegThreadPage()
{
}

void CRegThreadPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegThreadPage)
	DDX_Control(pDX, IDC_ASYNC, m_AsyncTrace);
	DDX_Check(pDX, IDC_ASYNC, m_fAsyncTrace);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegThreadPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRegThreadPage)
	ON_BN_CLICKED(IDC_PRIORITY_ABOVE, OnPriorityClick)
	ON_BN_CLICKED(IDC_PRIORITY_BELOW, OnPriorityClick)
	ON_BN_CLICKED(IDC_PRIORITY_HIGHEST, OnPriorityClick)
	ON_BN_CLICKED(IDC_PRIORITY_IDLE, OnPriorityClick)
	ON_BN_CLICKED(IDC_PRIORITY_NORMAL, OnPriorityClick)
	ON_BN_CLICKED(IDC_ASYNC, OnAsync)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRegThreadPage::InitializePage() 
{
	if ( !App.GetTraceRegDword( "AsyncThreadPriority", (LPDWORD)&m_nThreadPriority ) )
	{
		m_nThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
		App.SetTraceRegDword( "AsyncThreadPriority", m_nThreadPriority );
	}

	if ( !App.GetTraceRegDword( "AsyncTraceFlag", (LPDWORD)&m_fAsyncTrace ) )
	{
		m_fAsyncTrace = TRUE;
		App.SetTraceRegDword( "AsyncTraceFlag", m_fAsyncTrace );
	}

	return	TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRegThreadPage message handlers

BOOL CRegThreadPage::OnInitDialog() 
{
	int	nID;

	CPropertyPage::OnInitDialog();

	switch( m_nThreadPriority )
	{
	case THREAD_PRIORITY_HIGHEST:		nID = IDC_PRIORITY_HIGHEST;	break;
	case THREAD_PRIORITY_ABOVE_NORMAL:	nID = IDC_PRIORITY_ABOVE;	break;
	case THREAD_PRIORITY_NORMAL:		nID = IDC_PRIORITY_NORMAL;	break;
	case THREAD_PRIORITY_BELOW_NORMAL:	nID = IDC_PRIORITY_BELOW;	break;
	case THREAD_PRIORITY_IDLE:			nID = IDC_PRIORITY_IDLE;	break;

	default:							nID = IDC_PRIORITY_BELOW;	break;
	}
	
	CheckRadioButton( IDC_PRIORITY_HIGHEST, IDC_PRIORITY_IDLE, nID );
	OnAsync();
	
	SetModified( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRegThreadPage::OnPriorityClick() 
{
	int	nSelectedID = GetCheckedRadioButton( IDC_PRIORITY_HIGHEST, IDC_PRIORITY_IDLE );
	
	switch( nSelectedID )
	{
	case IDC_PRIORITY_HIGHEST:	m_nThreadPriority = THREAD_PRIORITY_HIGHEST;		break;
	case IDC_PRIORITY_ABOVE:	m_nThreadPriority = THREAD_PRIORITY_ABOVE_NORMAL;	break;
	case IDC_PRIORITY_NORMAL:	m_nThreadPriority = THREAD_PRIORITY_NORMAL;			break;
	case IDC_PRIORITY_BELOW:	m_nThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;	break;
	case IDC_PRIORITY_IDLE:		m_nThreadPriority = THREAD_PRIORITY_IDLE;			break;

	default:				
		ASSERT( FALSE );
		break;
	}
	SetModified( TRUE );
}

void CRegThreadPage::OnAsync() 
{
	BOOL	m_fAsyncTrace = m_AsyncTrace.GetCheck() == 1;

	GetDlgItem( IDC_THREADGRP )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_HIGHEST )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_ABOVE )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_NORMAL )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_BELOW )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_IDLE )->EnableWindow( m_fAsyncTrace );

	SetModified( TRUE );
}

void CRegThreadPage::OnOK() 
{
	App.SetTraceRegDword( "AsyncThreadPriority", m_nThreadPriority );
	App.SetTraceRegDword( "AsyncTraceFlag", m_fAsyncTrace );

	SetModified( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\dlgconn.cpp ===
// dlgconn.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "dlgconn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectDlg dialog


CConnectDlg::CConnectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConnectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConnectDlg)
	m_szConnect = _T("");
	//}}AFX_DATA_INIT
}


void CConnectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectDlg)
	DDX_Text(pDX, IDC_CONNECT_TXT, m_szConnect);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectDlg, CDialog)
	//{{AFX_MSG_MAP(CConnectDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CConnectDlg message handlers

BOOL CConnectDlg::OnInitDialog() 
{
	CString	szFormat;
	
	szFormat.LoadString( IDS_CONNECT_FORMAT );
	m_szConnect.Format( (LPCTSTR)szFormat, App.GetRemoteServerName() );

	CDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\pgoutput.h ===
// pgoutput.h : header file
//

#ifndef	_OUTPUT_PAGE_H_
#define	_OUTPUT_PAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CRegOutputPage dialog

class CRegOutputPage : public CRegPropertyPage
{
	DECLARE_DYNCREATE(CRegOutputPage)

// Construction
public:
	CRegOutputPage();
	~CRegOutputPage();

// Dialog Data
	//{{AFX_DATA(CRegOutputPage)
	enum { IDD = IDD_OUTPUT };
	CEdit	m_FileName;
	CString	m_szFileName;
	DWORD	m_dwMaxTraceFileSize;
	//}}AFX_DATA

	virtual BOOL InitializePage();

	DWORD	m_dwOutputType;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegOutputPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegOutputPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnOutputClick();
	afx_msg void OnChangeFilename();
	afx_msg void OnChangeMaxTraceFileSize();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnOK();

};

#endif	// _OUTPUT_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\dlgconn.h ===
// dlgconn.h : header file
//
#ifndef	_CONNECT_DLG_H_
#define	_CONNECT_DLG_H_

/////////////////////////////////////////////////////////////////////////////
// CConnectDlg dialog

class CConnectDlg : public CDialog
{
// Construction
public:
	CConnectDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConnectDlg)
	enum { IDD = IDD_CONNECTING };
	CString	m_szConnect;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConnectDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif	//	_CONNECT_DLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\pgoutput.cpp ===
// pgoutput.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "pgoutput.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const DWORD MB = 1024 * 1024;
const DWORD dwMinFileSize = 5;		// in MB

/////////////////////////////////////////////////////////////////////////////
// CRegOutputPage property page

IMPLEMENT_DYNCREATE(CRegOutputPage, CRegPropertyPage)

CRegOutputPage::CRegOutputPage() : CRegPropertyPage(CRegOutputPage::IDD)
{
	//{{AFX_DATA_INIT(CRegOutputPage)
	m_szFileName = _T("");
	m_dwMaxTraceFileSize = 0;
	//}}AFX_DATA_INIT

	m_dwOutputType = TRACE_OUTPUT_DISABLED;
}

CRegOutputPage::~CRegOutputPage()
{
}

void CRegOutputPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegOutputPage)
	DDX_Control(pDX, IDC_FILENAME, m_FileName);
	DDX_Text(pDX, IDC_FILENAME, m_szFileName);
	DDX_Text(pDX, IDC_MAXTRACEFILESIZE, m_dwMaxTraceFileSize);
	DDV_MinMaxDWord(pDX, m_dwMaxTraceFileSize, dwMinFileSize, 999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegOutputPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRegOutputPage)
	ON_BN_CLICKED(IDC_DEBUGGER, OnOutputClick)
	ON_EN_CHANGE(IDC_FILENAME, OnChangeFilename)
	ON_BN_CLICKED(IDC_DISABLED, OnOutputClick)
	ON_BN_CLICKED(IDC_DISCARD, OnOutputClick)
	ON_BN_CLICKED(IDC_FILE, OnOutputClick)
	ON_EN_CHANGE(IDC_MAXTRACEFILESIZE, OnChangeMaxTraceFileSize)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL CRegOutputPage::InitializePage() 
{
	if ( !App.GetTraceRegDword( "OutputTraceType", &m_dwOutputType ) )
	{
		m_dwOutputType = TRACE_OUTPUT_FILE;
		App.SetTraceRegDword( "OutputTraceType", m_dwOutputType );
	}

	if ( App.GetTraceRegDword( "MaxTraceFileSize", &m_dwMaxTraceFileSize ) &&
		m_dwMaxTraceFileSize > dwMinFileSize*MB)
	{
		m_dwMaxTraceFileSize = (m_dwMaxTraceFileSize + MB - 1) / MB;
	} else {
		m_dwMaxTraceFileSize = dwMinFileSize;			// Default to 5mb
		App.SetTraceRegDword( "MaxTraceFileSize", m_dwMaxTraceFileSize * MB );
	}

	if ( !App.GetTraceRegString( "TraceFile", m_szFileName ) )
	{
		m_szFileName = "c:\\trace.atf";
		App.SetTraceRegString( "TraceFile", m_szFileName );
	}

	return	TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRegOutputPage message handlers

BOOL CRegOutputPage::OnInitDialog() 
{
	int	nID;

	CPropertyPage::OnInitDialog();
	
	switch( m_dwOutputType )
	{
	case TRACE_OUTPUT_DISABLED:		nID = IDC_DISABLED;	break;
	case TRACE_OUTPUT_FILE:			nID = IDC_FILE;		break;
	case TRACE_OUTPUT_DEBUG:		nID = IDC_DEBUGGER;	break;
	case TRACE_OUTPUT_DISCARD:		nID = IDC_DISCARD;	break;
	
	default:						nID = IDC_DISABLED;	break;
	}
	
	CheckRadioButton( IDC_DISABLED, IDC_DISCARD, nID );
	OnOutputClick();

	SetModified( FALSE );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRegOutputPage::OnOutputClick() 
{
	int	nSelectedID = GetCheckedRadioButton( IDC_DISABLED, IDC_DISCARD );

	switch( nSelectedID )
	{
	case IDC_DISABLED:		m_dwOutputType = TRACE_OUTPUT_DISABLED;	break;
	case IDC_FILE:			m_dwOutputType = TRACE_OUTPUT_FILE;		break;
	case IDC_DEBUGGER:		m_dwOutputType = TRACE_OUTPUT_DEBUG;	break;
	case IDC_DISCARD:		m_dwOutputType = TRACE_OUTPUT_DISCARD;	break;
	
	default:				
		ASSERT( FALSE );
		break;
	}

	m_FileName.EnableWindow( nSelectedID == IDC_FILE );

	SetModified( TRUE );
}

void CRegOutputPage::OnChangeFilename() 
{
	SetModified( TRUE );	
}


void CRegOutputPage::OnOK() 
{
	App.SetTraceRegDword( "OutputTraceType", m_dwOutputType );
	App.SetTraceRegDword( "MaxTraceFileSize", m_dwMaxTraceFileSize * MB);
	App.SetTraceRegString( "TraceFile", m_szFileName );

	SetModified( FALSE );
}

void CRegOutputPage::OnChangeMaxTraceFileSize() 
{
	SetModified( TRUE );	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\pgthread.h ===
// pgthread.h : header file
//

#ifndef	_THREAD_PAGE_H_
#define	_THREAD_PAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CRegThreadPage dialog

class CRegThreadPage : public CRegPropertyPage
{
	DECLARE_DYNCREATE(CRegThreadPage)

// Construction
public:
	CRegThreadPage();
	~CRegThreadPage();

// Dialog Data
	//{{AFX_DATA(CRegThreadPage)
	enum { IDD = IDD_THREAD };
	CButton	m_AsyncTrace;
	BOOL	m_fAsyncTrace;
	//}}AFX_DATA

	int		m_nThreadPriority;

	virtual BOOL InitializePage();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegThreadPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegThreadPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnPriorityClick();
	afx_msg void OnAsync();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnOK();

};
#endif	// _THREAD_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\pgtrace.h ===
// pgtrace.h : header file
//

#ifndef	_TRACE_PAGE_H_
#define	_TRACE_PAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CRegTracePage dialog

class CRegTracePage : public CRegPropertyPage
{
	DECLARE_DYNCREATE(CRegTracePage)

// Construction
public:
	CRegTracePage();
	~CRegTracePage();

// Dialog Data
	//{{AFX_DATA(CRegTracePage)
	enum { IDD = IDD_TRACES };
	BOOL	m_fErrorTrace;
	BOOL	m_fDebugTrace;
	BOOL	m_fFatalTrace;
	BOOL	m_fMsgTrace;
	BOOL	m_fStateTrace;
	BOOL	m_fFunctTrace;
	//}}AFX_DATA

	virtual BOOL InitializePage();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegTracePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegTracePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnClick();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnOK();

};

#endif	// _TRACE_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\pgtrace.cpp ===
// pgtrace.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegTracePage property page

IMPLEMENT_DYNCREATE(CRegTracePage, CRegPropertyPage)

CRegTracePage::CRegTracePage() : CRegPropertyPage(CRegTracePage::IDD)
{
	//{{AFX_DATA_INIT(CRegTracePage)
	m_fErrorTrace = FALSE;
	m_fDebugTrace = FALSE;
	m_fFatalTrace = FALSE;
	m_fMsgTrace = FALSE;
	m_fStateTrace = FALSE;
	m_fFunctTrace = FALSE;
	//}}AFX_DATA_INIT
}

CRegTracePage::~CRegTracePage()
{
}

void CRegTracePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegTracePage)
	DDX_Check(pDX, IDC_ERROR, m_fErrorTrace);
	DDX_Check(pDX, IDC_DEBUG, m_fDebugTrace);
	DDX_Check(pDX, IDC_FATAL, m_fFatalTrace);
	DDX_Check(pDX, IDC_MESSAGE, m_fMsgTrace);
	DDX_Check(pDX, IDC_STATE, m_fStateTrace);
	DDX_Check(pDX, IDC_FUNCTION, m_fFunctTrace);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegTracePage, CPropertyPage)
	//{{AFX_MSG_MAP(CRegTracePage)
	ON_BN_CLICKED(IDC_DEBUG, OnClick)
	ON_BN_CLICKED(IDC_ERROR, OnClick)
	ON_BN_CLICKED(IDC_FATAL, OnClick)
	ON_BN_CLICKED(IDC_FUNCTION, OnClick)
	ON_BN_CLICKED(IDC_MESSAGE, OnClick)
	ON_BN_CLICKED(IDC_STATE, OnClick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRegTracePage::InitializePage() 
{
	DWORD	dwEnabledTraces;

	if ( !App.GetTraceRegDword( "EnabledTraces", &dwEnabledTraces ) )
	{
		dwEnabledTraces = 0;
		App.SetTraceRegDword( "AsyncThreadPriority", dwEnabledTraces );
	}

	m_fDebugTrace = dwEnabledTraces & DEBUG_TRACE_MASK ? TRUE : FALSE ;	
	m_fFatalTrace = dwEnabledTraces & FATAL_TRACE_MASK ? TRUE : FALSE ;
	m_fErrorTrace = dwEnabledTraces & ERROR_TRACE_MASK ? TRUE : FALSE ;
	m_fStateTrace = dwEnabledTraces & STATE_TRACE_MASK ? TRUE : FALSE ;
	m_fFunctTrace = dwEnabledTraces & FUNCT_TRACE_MASK ? TRUE : FALSE ;
	m_fMsgTrace   = dwEnabledTraces & MESSAGE_TRACE_MASK ? TRUE : FALSE ;

	return	TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRegTracePage message handlers

BOOL CRegTracePage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	SetModified( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRegTracePage::OnClick() 
{
	SetModified( TRUE );
}


void CRegTracePage::OnOK() 
{
	DWORD	dwEnabledTraces = 0;

	dwEnabledTraces |= m_fDebugTrace ? DEBUG_TRACE_MASK : 0;
	dwEnabledTraces |= m_fFatalTrace ? FATAL_TRACE_MASK : 0;
	dwEnabledTraces |= m_fErrorTrace ? ERROR_TRACE_MASK : 0;
	dwEnabledTraces |= m_fStateTrace ? STATE_TRACE_MASK : 0;
	dwEnabledTraces |= m_fFunctTrace ? FUNCT_TRACE_MASK : 0;
	dwEnabledTraces |= m_fMsgTrace ? MESSAGE_TRACE_MASK : 0;

	App.SetTraceRegDword( "EnabledTraces", dwEnabledTraces );

	SetModified( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\regsheet.cpp ===
// regsheet.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "regsheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegPropertySheet

IMPLEMENT_DYNAMIC(CRegPropertySheet, CPropertySheet)

CRegPropertySheet::CRegPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CRegPropertySheet::CRegPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CRegPropertySheet::~CRegPropertySheet()
{
}

//
// Need to override the default MFC behaviour to achieve the Win'95 behaviour
//
void CRegPropertySheet::OnApplyNow()
{
	if ( GetActivePage()->OnKillActive() )
	{
		for ( int i=0; i<GetPageCount(); i++ )
		{
			CPropertyPage*	pPage = GetPage( i );

			ASSERT( pPage->IsKindOf( RUNTIME_CLASS(	CRegPropertyPage ) ) );

			if ( ((CRegPropertyPage *)pPage)->IsModified() )
			{
				pPage->OnOK();
			}
		}
	}
}


void CRegPropertySheet::OnOK()
{
	OnApplyNow();

	if (!m_bModeless)
	{
		EndDialog(IDOK);
	}
}


void CRegPropertySheet::OnCancel()
{
	int		i;

	for ( i=0; i<GetPageCount(); i++ )
	{
		GetPage( i )->OnCancel();
	}

	if (!m_bModeless)
	{
		EndDialog(IDCANCEL);
	}
}


BEGIN_MESSAGE_MAP(CRegPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CRegPropertySheet)
	ON_COMMAND(ID_APPLY_NOW, OnApplyNow)
	ON_COMMAND(IDOK, OnOK)
	ON_COMMAND(IDCANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRegPropertySheet message handlers
/////////////////////////////////////////////////////////////////////////////
// CRegPropertyPage property page

IMPLEMENT_DYNAMIC(CRegPropertyPage, CPropertyPage)

CRegPropertyPage::~CRegPropertyPage()
{
#if _MFC_VER >= 0x0400

      m_bChanged = FALSE;

#endif // _MFC_VER >= 0x0400
}

void CRegPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRegPropertyPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#if _MFC_VER >= 0x0400

//
// Keep private check on dirty state of the property page.
//
void
CRegPropertyPage::SetModified(
    BOOL bChanged
    )
{
    CPropertyPage::SetModified(bChanged);
    m_bChanged = bChanged;
}

#endif // _MFC_VER >= 0x0400

/////////////////////////////////////////////////////////////////////////////
// CRegPropertyPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\regtrdlg.cpp ===
// regtrdlg.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "regtrdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();
	
	// TODO: Add extra about dlg initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
// CRegTraceDlg dialog

CRegTraceDlg::CRegTraceDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRegTraceDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRegTraceDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CRegTraceDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegTraceDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRegTraceDlg, CDialog)
	//{{AFX_MSG_MAP(CRegTraceDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegTraceDlg message handlers

BOOL CRegTraceDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CRegTraceDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CRegTraceDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CRegTraceDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\regsheet.h ===
// regsheet.h : header file
//


#ifndef	_REG_SHEET_H_
#define	_REG_SHEET_H_

/////////////////////////////////////////////////////////////////////////////
// CRegPropertySheet

class CRegPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CRegPropertySheet)

// Construction
public:
	CRegPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CRegPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegPropertySheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CRegPropertySheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CRegPropertySheet)
	afx_msg void OnApplyNow();
	afx_msg void OnOK();
	afx_msg void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CRegPropertyPage dialog

class CRegPropertyPage : public CPropertyPage
{
	DECLARE_DYNAMIC(CRegPropertyPage)

// Construction
public:
	CRegPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0)	:
		CPropertyPage( nIDTemplate, nIDCaption ) {}

	CRegPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0) :
		CPropertyPage( lpszTemplateName, nIDCaption ) {}

	~CRegPropertyPage();

	virtual BOOL InitializePage() = 0;
	BOOL IsModified()	{ return	m_bChanged;	}


// Dialog Data
	//{{AFX_DATA(CRegPropertyPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

#if _MFC_VER >= 0x0400

    //
    // Keep private information on page dirty state, necessary for
    // SaveInfo() later.
    //

public:
    void SetModified( BOOL bChanged = TRUE );

protected:
    BOOL m_bChanged;

#endif // _MFC_VER >= 0x0400


// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegPropertyPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


#endif	// _REG_SHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\regtrace.h ===
// regtrace.h : main header file for the REGTRACE application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include "regsheet.h"
#include "pgtrace.h"
#include "pgoutput.h"
#include "pgthread.h"
#include "dbgtrace.h"
#include "dlgconn.h"

/////////////////////////////////////////////////////////////////////////////
// CRegTraceApp:
// See regtrace.cpp for the implementation of this class
//

class CRegTraceApp : public CWinApp
{
public:
	CRegTraceApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegTraceApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	LONG OpenTraceRegKey( void );
	BOOL CloseTraceRegKey( void );

	BOOL GetTraceRegDword( LPTSTR pszValue, LPDWORD pdw );
	BOOL GetTraceRegString( LPTSTR pszValue, CString& sz );

	BOOL SetTraceRegDword( LPTSTR pszValue, DWORD dwData );
	BOOL SetTraceRegString( LPTSTR pszValue, CString& sz );

	BOOL IsRemoteMsnServer( void )	{ return m_szCmdLineServer[0] != '\0'; }
	void SetRemoteRegKey( HKEY hKey )	{ m_hRegMachineKey = hKey; }
	LPSTR GetRemoteServerName( void )	{ return m_szCmdLineServer; }

protected:
	HKEY		m_hRegKey;
	HKEY		m_hRegMachineKey;
	static char	m_szDebugAsyncTrace[];
	char		m_szCmdLineServer[128];

	CConnectDlg	m_dlgConnect;


	//{{AFX_MSG(CRegTraceApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

#define	App	(*(CRegTraceApp *)AfxGetApp())
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\regtrdlg.h ===
// regtrdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRegTraceDlg dialog

class CRegTraceDlg : public CDialog
{
// Construction
public:
	CRegTraceDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CRegTraceDlg)
	enum { IDD = IDD_REGTRACE_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegTraceDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CRegTraceDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\regtrace.cpp ===
// regtrace.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "regtrace.h"
#include "regtrdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegTraceApp

BEGIN_MESSAGE_MAP(CRegTraceApp, CWinApp)
	//{{AFX_MSG_MAP(CRegTraceApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegTraceApp construction

CRegTraceApp::CRegTraceApp()
{
	m_hRegKey = NULL;
	m_hRegMachineKey = NULL;
	m_szCmdLineServer[0] = '\0';
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRegTraceApp object

CRegTraceApp theApp;

char	
CRegTraceApp::m_szDebugAsyncTrace[] = "SOFTWARE\\Microsoft\\MosTrace\\CurrentVersion\\DebugAsyncTrace";



/////////////////////////////////////////////////////////////////////////////
// CRegTraceApp initialization

BOOL CRegTraceApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();
	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	//
	// check for cmd line param for remote server
	//
	m_szCmdLineServer[0] = '\0';
	if ( m_lpCmdLine && m_lpCmdLine[0] == '\\' && m_lpCmdLine[1] == '\\' )
	{
		LPSTR	lpsz1, lpsz2;
		int		i;

		for (	i=0, lpsz1=m_lpCmdLine, lpsz2=m_szCmdLineServer;
			 	i<sizeof(m_szCmdLineServer) && *lpsz1 && *lpsz1 != ' ';
				i++, *lpsz2++ = *lpsz1++ ) ;

		*lpsz2 = '\0';
	}

	//
	// if the user specified the local machine; skip remote stuff
	//
	char	szLocalMachine[sizeof(m_szCmdLineServer)];
	DWORD	dwSize = sizeof(szLocalMachine);

	GetComputerName( szLocalMachine, &dwSize );
	//
	// skip the \\ prefix
	//
	if ( lstrcmpi( szLocalMachine, m_szCmdLineServer+2 ) == 0 )
	{
		m_szCmdLineServer[0] = '\0';
	}



	//
	// make usre this succeeds before calling Page constructors
	//
	LONG	lError = OpenTraceRegKey();

	if ( lError != ERROR_SUCCESS )
	{
		PVOID	lpsz;
		CString	szFormat;
		CString	szCaption;
		CString	szText;

		//
		// user aborted
		//
		if ( lError == -1 )
		{
			return	FALSE;
		}

		FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
						FORMAT_MESSAGE_FROM_SYSTEM,
						(LPCVOID)NULL,
						lError,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
						(LPTSTR)&lpsz,
						16,
						NULL );

		szCaption.LoadString( IDS_ERROR_CAPTION );

		szFormat.LoadString( IDS_ERROR_TEXT );
		szText.Format( (LPCTSTR)szFormat, lpsz, lError );
		LocalFree( lpsz );

		MessageBeep(0);
		MessageBox( NULL, szText, NULL, MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL );
		return FALSE;
	}

	CString	szCaption;

	if ( IsRemoteMsnServer() )
	{
		CString	szFormat;

		szFormat.LoadString( IDS_REMOTE_CAPTION );
		szCaption.Format( (LPCTSTR)szFormat, GetRemoteServerName() );
	}
	else
	{
		szCaption.LoadString( IDS_TRACE_CAPTION );
	}

	CRegPropertySheet	dlg( (LPCTSTR)szCaption );
	CRegTracePage		TracesPage;
	CRegOutputPage		OutputPage;
	CRegThreadPage		ThreadPage;

	if (TracesPage.InitializePage() &&
		OutputPage.InitializePage() &&
		ThreadPage.InitializePage() )
	{
		dlg.AddPage( &TracesPage );
		dlg.AddPage( &OutputPage );
		dlg.AddPage( &ThreadPage );

		dlg.DoModal();
	}
	CloseTraceRegKey();

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

DWORD ConnectThread( CConnectDlg *lpConnectDlg )
{
	LONG	lError;
	HKEY	hRegMachineKey;

	lError = RegConnectRegistry(App.GetRemoteServerName(),
								HKEY_LOCAL_MACHINE,
								&hRegMachineKey );

	App.SetRemoteRegKey( hRegMachineKey );

	lpConnectDlg->PostMessage( WM_COMMAND, IDOK, NULL );

	return	(DWORD)lError;
}


LONG CRegTraceApp::OpenTraceRegKey()
{
	DWORD	dwDisposition;
	LONG	lError;

	//
	// check for cache of the remote hkey value
	//
	if ( IsRemoteMsnServer() )
	{
		DWORD	dwThreadId;

		HANDLE	hThread = ::CreateThread(NULL,
										0,
										(LPTHREAD_START_ROUTINE)ConnectThread,
										(LPVOID)&m_dlgConnect,
										0,
										&dwThreadId );
		if ( hThread == NULL )
		{
			return	GetLastError();
		}

		if ( m_dlgConnect.DoModal() == IDCANCEL )
		{
			return	-1;
		}

		WaitForSingleObject( hThread, INFINITE );
		GetExitCodeThread( hThread, (LPDWORD)&lError );
		CloseHandle( hThread );

		if ( lError != ERROR_SUCCESS )
		{
			return	lError;
		}
	}

	HKEY	hRoot = IsRemoteMsnServer() ?
					m_hRegMachineKey :
					HKEY_LOCAL_MACHINE;

	return RegCreateKeyEx(	hRoot,
							m_szDebugAsyncTrace,
							0,
							NULL,
							REG_OPTION_NON_VOLATILE,
							KEY_READ|KEY_WRITE,
							NULL,
							&m_hRegKey,
							&dwDisposition );
}


BOOL CRegTraceApp::CloseTraceRegKey()
{
	BOOL bRC = RegCloseKey( m_hRegKey ) == ERROR_SUCCESS;

	if ( IsRemoteMsnServer() && m_hRegMachineKey != NULL )
	{
		bRC == RegCloseKey( m_hRegMachineKey ) == ERROR_SUCCESS && bRC;
	}
	return	bRC;
}



BOOL CRegTraceApp::GetTraceRegDword( LPTSTR pszValue, LPDWORD pdw )
{
	DWORD	cbData = sizeof( DWORD );
	DWORD	dwType = REG_DWORD;

	return	RegQueryValueEx(m_hRegKey,
							pszValue,
							NULL,
							&dwType,
							(LPBYTE)pdw,
							&cbData ) == ERROR_SUCCESS && dwType == REG_DWORD;
}



BOOL CRegTraceApp::GetTraceRegString( LPTSTR pszValue, CString& sz )
{
	DWORD	dwType = REG_DWORD;
	char	szTemp[MAX_PATH+1];
	DWORD	cbData = sizeof(szTemp);
	BOOL	bRC;

	bRC = RegQueryValueEx(	m_hRegKey,
							pszValue,
							NULL,
							&dwType,
							(LPBYTE)szTemp,
							&cbData ) == ERROR_SUCCESS && dwType == REG_SZ;

	if ( bRC )
	{
		sz = szTemp;
	}

	return	bRC;
}


BOOL CRegTraceApp::SetTraceRegDword( LPTSTR pszValue, DWORD dwData )
{
	return	RegSetValueEx(	m_hRegKey,
							pszValue,
							NULL,
							REG_DWORD,
							(LPBYTE)&dwData,
							sizeof( DWORD ) ) == ERROR_SUCCESS;
}

BOOL CRegTraceApp::SetTraceRegString( LPTSTR pszValue, CString& sz )
{
	return	RegSetValueEx(	m_hRegKey,
							pszValue,
							NULL,
							REG_SZ,
							(LPBYTE)(LPCTSTR)sz,
							sz.GetLength()+1 ) == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifdef _AFX_ENABLE_INLINES
	#undef _AFX_ENABLE_INLINES
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rw\src\rw.cpp ===
//
// This file contains test implmentations of reader and writer locks.
// These are intended to be used with the template class in rw.h so that
// different implementations can be plugged in and tested.
// 
// The semantics of the read/write classes should be as follows : 
//	Functions CAN NOT be recursively called,
//	Multiple Readers should be able to enter the lock 
//	Only a single writer may execute at a time.
//



#include	<windows.h>
#include	<limits.h>
#include	"rwex.h"

namespace	rwex	{

long	const	BlockValue = (-LONG_MAX) / 2; 
							// Large in magnitude, negative value.  Used to 
							// indicate a waiting writer in cReadLock


CShareLock::CShareLock( ) : 
		cReadLock( 0  ), 
		cOutRdrs( 0 ),
		hWaitingWriters( 0 ),
		hWaitingReaders( 0 )	{
/*++

Routine Description : 

	Initialize Thre CShareLock() 

Arguments : 

	None.

Return Value : 

	None.

--*/

	InitializeCriticalSection( &critWriters ) ;
	hWaitingWriters = CreateSemaphore( NULL, 0, 1, NULL ) ;
	hWaitingReaders = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
}

CShareLock::~CShareLock( ) {
/*++

Routine Description : 

	Destroy the CShareLock - release the handles we allocated !

Arguments : 

	None.

Return Value : 

	None.

--*/

	if( hWaitingWriters ) 
		CloseHandle( hWaitingWriters ) ;
	if( hWaitingReaders ) 
		CloseHandle( hWaitingReaders ) ;
	DeleteCriticalSection( &critWriters ) ;
}


BOOL
CShareLock::IsValid()	{
/*++

Routine Description : 

	Checks to see that the lock is valid !

Arguments : 

	None.

Return Value : 

	TRUE if it looks like we were successfully constructed - 
	FALSE otherwise !

--*/

	return	hWaitingWriters != 0 && hWaitingReaders != 0 ; 

}


void
CShareLock::ShareLock( ) {
/*++

Routine Description : 

	Acquire the lock for shared mode.
	
Arguments : 

	None.

Return Value : 

	None.

--*/
	long	sign = InterlockedIncrement( (long*)&cReadLock ) ;
	if( sign > 0 ) {
		return ;
	}	else 	{
		// There must be a writer in the lock.  Wait for him to leave.
		// The InterlockedIncrement recorded our presence so that the writer
		// can later release the correct number of threads.
		WaitForSingleObject( hWaitingReaders, INFINITE ) ;
	}
}

void
CShareLock::ShareUnlock( ) {
/*++

Routine Description : 

	Release the lock from shared mode.
	If a writer is waiting for the lock, determine if we're
	the last thread to release the lock, and if so wake the writer !

Arguments : 

	None.

Return Value : 

	None.

--*/
	//
	// Leave the lock.  The return value will be negative if there is a writer
	// waiting.
	BOOL fWriterWaiting = InterlockedDecrement( (long*)&cReadLock ) < 0 ;

	if( fWriterWaiting ) {
		//
		// The following increment occurs when there is writer waiting, but
		// readers own the lock.  So although cReadLock is temporarily inaccurate
		// about the number of readers waiting for the lock, it is not inaccurate 
		// when it matters in WriteUnlock (which assumes a writer owns the lock.)
		//
		long sign = InterlockedIncrement( (long*)&cReadLock ) ;	// restore the value in cReadLock, so that we
												// end up with an accurate count of readers waiting
												// for entry.  

		sign = InterlockedDecrement( (long*)&cOutRdrs ) ;	// Make sure we don't lose track of the 
												// number for readers who have left the lock.
		//
		// Are we the last reader out of the lock ?
		//
		if( sign == 0 ) {
			//
			// Definately the last reader out !
			//
			ReleaseSemaphore( hWaitingWriters, 1, &sign ) ;
		}
	}
}

void
CShareLock::ExclusiveLock( ) {
/*++

Routine Description : 

	Acquire the lock for Exclusive use !

	First acquire a critical section to make sure we're the only
	exclusive thread in here.  Then see if there are any reader threads
	in the lock, and if there are wait for them to wake us !

Arguments : 

	None.

Return Value : 

	None.

--*/
	// Only one writer allowed to try for the lock at a time.
	//
	EnterCriticalSection( &critWriters ) ;

	//
	// Need to track the number of readers who leave the lock while we 
	// are trying to grab it.
	//
	cOutRdrs = 0 ;
	// Grab the lock 
 	long	oldsign = InterlockedExchange( (long*)&cReadLock, BlockValue ) ;

	//
	//	Now, add the number of readers who used to be in the lock to 
	//	the number of readers who have left the lock.  If this comes out
	//	to be zero, there are no readers in the lock and we can go on !
	//
	long	value = InterlockedExchangeAdd( (long*)&cOutRdrs, oldsign ) + oldsign ;
	//
	// Do we own the lock ?  Only if there were no readers, or they have all left already.
	//
	if( value != 0 ) {
		// Wait for a reader to signal us.
		WaitForSingleObject( hWaitingWriters, INFINITE ) ;
	}
}



void
CShareLock::ExclusiveUnlock( ) 	{
/*++

Routine Description : 

	Release the lock from Exclusive Use.
	First, we see if readers are waiting and let a bunch of them in.
	Then we release the critical section to let other Exclusive threads in !

Arguments : 

	None.

Return Value : 

	None.

--*/


	//
	//	Get the number of readers waiting to enter the lock !
	//	This Addition automatically leaves m_cReadLock with the number
	//	of readers who had been waiting !
	//
	long cTotal = InterlockedExchangeAdd( (long*)&cReadLock, -BlockValue ) - BlockValue ;

	//
	//	Now release all the readers who had been waiting !
	//
	if( cTotal > 0 ) {
		ReleaseSemaphore( hWaitingReaders, cTotal, &cTotal) ;	// let all those readers go!
	}
	//
	// Let the next writer take his shot at the lock!
	//
	LeaveCriticalSection( &critWriters ) ;
}

void
CShareLock::ExclusiveToShared()	{
/*++

Routine Description : 

	Release our exclusive lock on the reader/writer lock, in exchange
	for a read lock.  This cannot fail !

Arguments : 
	
	None.

Return Value : 

	None.

--*/

	//
	//	Get the number of readers waiting to enter the lock !
	//	Note that we add one onto m_cReadLock for our hold on the reader lock, 
	//	but we don't add this to m_cOutCounter, as the number of readers waiting is one smaller !
	//
	long cTotal = InterlockedExchangeAdd( (long*)&cReadLock, 1-BlockValue ) -BlockValue ;

	if( cTotal > 0 ) {
		ReleaseSemaphore( hWaitingReaders, cTotal, &cTotal )  ;
	}
	LeaveCriticalSection( &critWriters ) ;
}

BOOL
CShareLock::SharedToExclusive()	{
/*++

Routine Description : 
	
	If there is only one reader in the lock, (and therefore we assume
	that reader is the calling thread), acquire the lock exclusive !!

Arguments :

	None.

Return Value : 

	TRUE if we acquired it exclusive
	If we return FALSE, we still have the lock shared !!


--*/

	//
	//	Try to get the critical section first !
	//
	if( TryEnterCriticalSection( &critWriters ) ) {

		//
		//	If there is only one reader in the lock we can get this exclusive !!
		//
		if( InterlockedCompareExchange( (long*)&cReadLock, BlockValue, 1 ) == 1 ) {
			return	TRUE ;

		}
		LeaveCriticalSection( &critWriters ) ;
	}
	return	FALSE ;
}

BOOL
CShareLock::TryShareLock()	{
/*++

Routine Description : 

	Get the lock shared if nobody else is in the lock
	Keep looping trying to add 1 to the number of readers
	as long as there are no writers waiting !!!

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	//
	//	get the initial number of readers in the lock !
	//
	long	temp = cReadLock ; 

	while( temp >= 0 ) {

		long	result = InterlockedCompareExchange( 
								(long*)&cReadLock, 
								(temp+1),	
								temp 
								) ;
		//
		//	Did we manage to add 1 ? 
		//
		if( result == temp ) {
			return	TRUE ;
		}
		temp = result ;
	}
	//
	//	Writer has or wants the lock - we should go away !
	//
	return	FALSE ;
}

BOOL
CShareLock::TryExclusiveLock()	{
/*++

Routine Description : 

	Get the lock exclusively if nobody else is in the lock

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	//
	//
	//

	if( TryEnterCriticalSection(&critWriters)	)	{

		if( InterlockedCompareExchange( (long*)&cReadLock, 
										BlockValue, 
										0 ) == 0 ) {
			return	TRUE ;
		}	
		LeaveCriticalSection(&critWriters) ;
	}
	return	FALSE ;
}


void
CShareLock::PartialLock()	{
/*++

Routine Description : 

	Grab a partial lock.  All other PartialLock() or ExclusiveLock()
	threads will block for as long as we hold the PartialLock().

Arguments : 

	None.

Return Value : 

	none

--*/

	//
	//	Only one writer in here at a time - grab this lock exclusively !
	//
	EnterCriticalSection( &critWriters ) ;
}


void
CShareLock::PartialUnlock()	{
/*++

Routine Description : 

	Releases the partial lock.  Anybody else can enter !

Arguments : 

	None.

Return Value : 

	none

--*/


	LeaveCriticalSection( &critWriters ) ;

}

void
CShareLock::FirstPartialToExclusive()	{
/*++

Routine Description : 

	Changes the partial lock to an Exclusive Lock.
	Basically, we complete the Exclusive Locking protocol
	that is found in Exclusive Lock.

Arguments : 

	None.

Return Value : 

	none

--*/

	//
	// Need to track the number of readers who leave the lock while we 
	// are trying to grab it.
	//
	cOutRdrs = 0 ;
	// Grab the lock 
 	long	oldsign = InterlockedExchange( (long*)&cReadLock, BlockValue ) ;

	//
	//	Now, add the number of readers who used to be in the lock to 
	//	the number of readers who have left the lock.  If this comes out
	//	to be zero, there are no readers in the lock and we can go on !
	//
	long	value = InterlockedExchangeAdd( (long*)&cOutRdrs, oldsign ) + oldsign ;
	//
	// Do we own the lock ?  Only if there were no readers, or they have all left already.
	//
	if( value != 0 ) {
		// Wait for a reader to signal us.
		WaitForSingleObject( hWaitingWriters, INFINITE ) ;
	}
}

BOOL
CShareLock::PartialToExclusive()	{
/*++

Routine Description : 

	Changes the partial lock to an Exclusive Lock.
	this is the same as FirstPartialToExclusive().

Arguments : 

	None.

Return Value : 

	TRUE always, because we always succeed !

--*/

	FirstPartialToExclusive() ;
	return	TRUE ;
}

void
CShareLock::ExclusiveToPartial()	{
/*++

Routine Description : 

	Changes the Exclusive Lock into a Partial Lock 
	Very similar to ExclusiveUnlock() - but don't release the crit sect !

Arguments : 

	None.

Return Value : 

	None.

--*/


	//
	//	Get the number of readers waiting to enter the lock !
	//	This Addition automatically leaves m_cReadLock with the number
	//	of readers who had been waiting !
	//
	long cTotal = InterlockedExchangeAdd( (long*)&cReadLock, -BlockValue ) - BlockValue ;

	//
	//	Now release all the readers who had been waiting !
	//
	if( cTotal > 0 ) {
		ReleaseSemaphore( hWaitingReaders, cTotal, &cTotal) ;	// let all those readers go!
	}

	//
	//	Don't release Critical Section !
	//
}



void
CShareLock::PartialToShared()	{
/*++

Routine Description : 

	Since we never really blocked readers from entering this 
	is pretty trivial - just add ourselves to the number of 
	readers in the lock and release the crit sect.

Arguments : 

	None.

Return Value : 

	None.

++*/

	long	l = InterlockedIncrement( (long*)&cReadLock ) ;

	//
	//	Now allow other Partial or Exclusive threads to try !
	//
	LeaveCriticalSection( &critWriters ) ;

}

BOOL
CShareLock::SharedToPartial()	{
/*++

Routine Description : 

	We don't care if other readers are already in the lock - 
	just go after the critical section !

Arguments : 

	None.

Return Value : 

	TRUE if we get a partial Lock !

++*/

	//
	//	Try to get the critical section first !
	//
	if( TryEnterCriticalSection(&critWriters)	)	{
		//
		//	Must decrement this so we don't track number of readers wrong !
		//
		long l = InterlockedDecrement( (long*)&cReadLock ) ;
		//_ASSERT( l >= 0 ) ;

		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CShareLock::TryPartialLock()	{
/*++

Routine Description : 

	We don't care if other readers are already in the lock - 
	just go after the critical section !

Arguments : 

	None.

Return Value : 

	TRUE if we manage to get a Partial Lock

++*/

	//
	//	Try to get the critical section first !
	//
	if( TryEnterCriticalSection(&critWriters)	)	{
		return	TRUE ;
	}
	return	FALSE ;
}


}	// namespace rwex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rwex\rwex.cpp ===
#include <windows.h>
#include "rwex.h"

using namespace rwex;
#include "rw.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rw\utest\rwutest.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	"dbgtrace.h"
#include	"rwex.h"


//
//	Array of DWORDs that is used to check for multiple threads entering the 
//	lock simultaneously !
//
long	rgbProtect[8192] ;

//
//	Array of DWORD's that is used by holders of PartialLock's - 
//	can be simultaneously accessed by readers !
//
long	rgdwPartial[8192] ;

//
//	Ini section used to get rwutest information 
//
char g_szDefaultSectionName[] = "rwutest";
char *g_szSectionName = g_szDefaultSectionName;

//
//	The number of threads used to check the symmetric lock !
//
DWORD	g_cNumSymThreads = 16 ;

//
//	Number of times each symmetric thread acquires the lock 
//
DWORD	g_cNumSymIterations = 10000 ;

///
//	Number of times each symmetric thread tests the protected range !
//
DWORD	g_cNumSymInternalLoops = 4 ;

//
//	Number of times the reader/writer tests go through their internal loops
//
int		g_cNumRWLoops = 16 ;

//
//	Number of times the reader/writer tests loop through their locks !
//
DWORD	g_cNumRWIterations = 100000 ;

//
//	Number of threads doing the reader/writer locks !
//
DWORD	g_cNumRWThreads = 16 ;


//
//	Number of times the test thread spins around looking for entries 
//	in the cache !
//
//DWORD	g_cNumThreadIterations = 10000 ;

//
//	String constants for retrieving values from .ini file !
//
#define INI_SECTIONNAME			"rwutest"
#define INI_NUMSYMTHREADS		"NumSymThreads"
#define	INI_NUMSYMITERATIONS	"NumSymIter"
#define	INI_NUMSYMLOOPS			"NumSymLoops"
#define	INI_NUMRWTHREADS		"NumRWThreads"
#define	INI_NUMRWLOOPS			"NumRWLoops"
#define	INI_NUMRWITERATIONS		"NumRWIter"

void usage(void) {
/*++

Routine Description : 

	Print Usage info to command line user !

Arguments : 

	None.

Return Value : 

	None.

--*/
	printf("usage: rwutest.exe [<ini file>] [<ini section name>]\n"
		"  INI file keys (in section [%s]):\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    This test for the async cache basically cache's dwords from\n"
		"    the specified data file.  Each thread computes some random offsets\n"
		"    into the data file and then makes an entry into the cache which is\n"
		"    keyed on the random offset and uses the data at the offset as the value\n"
		"    The Zap Threads periodically destroy the entire cache and check that \n"
		"    all the memory on the system is freed !\n",
		INI_SECTIONNAME,
		INI_NUMSYMTHREADS,
		g_cNumSymThreads, 
		INI_NUMSYMITERATIONS,
		g_cNumSymIterations,
		INI_NUMSYMLOOPS,
		g_cNumSymInternalLoops,
		INI_NUMRWTHREADS,
		g_cNumRWThreads,
		INI_NUMRWLOOPS,
		g_cNumRWLoops,
		INI_NUMRWITERATIONS,
		g_cNumRWIterations
		) ;
	exit(0);
}


int GetINIDword(
			char *szINIFile, 
			char *szKey, 
			DWORD dwDefault
			) {
/*++

Routine Description : 

	Helper function which retrieves values from .ini file !

Arguments : 

	szINIFile - name of the ini file
	szKey - name of the key
	dwDefault - default value for the parameter

Return Value : 

	The value retrieved from the .ini file or the default !

--*/
	char szBuf[MAX_PATH];

	GetPrivateProfileString(g_szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

void parsecommandline(
			int argc, 
			char **argv
			) {
/*++

Routine Description : 

	Get the name of the .ini file and 
	setup our test run !

Arguments : 

	Command line parameters

Return Value : 

	None - will exit() if the user has not
		properly configured the test !

--*/
	if (argc == 0) 
		usage();

	if (argc != 1 || _stricmp(argv[0], "/help") == 0) 
		usage(); 	// show help

	char *szINIFile = argv[0];

	if (argc == 2) char *g_szSectionName = argv[1];

	g_cNumSymThreads =	GetINIDword( szINIFile,
									INI_NUMSYMTHREADS,
									g_cNumSymThreads
									) ;

	g_cNumSymThreads = max( g_cNumSymThreads, 0 ) ;
	g_cNumSymThreads = min( g_cNumSymThreads, 64 ) ;
	//
	//	Make a multiple of 2 !
	//
	g_cNumSymThreads &= 0xFFFFFFFE ;

	g_cNumSymIterations =	GetINIDword( szINIFile,
									INI_NUMSYMITERATIONS,
									g_cNumSymIterations
									) ;

	g_cNumSymInternalLoops =	GetINIDword( szINIFile,
									INI_NUMSYMLOOPS,
									g_cNumSymInternalLoops
									) ;

	g_cNumRWThreads	=	GetINIDword( szINIFile,
									INI_NUMRWTHREADS,
									g_cNumRWThreads
									) ;

	g_cNumRWThreads = max( g_cNumRWThreads, 1 ) ;
	g_cNumRWThreads = min( g_cNumRWThreads, 64 ) ;

	g_cNumRWLoops	=	GetINIDword( szINIFile,
									INI_NUMRWLOOPS,
									g_cNumRWLoops
									) ;

	g_cNumRWIterations	=	GetINIDword( szINIFile,
									INI_NUMRWITERATIONS,
									g_cNumRWIterations
									) ;



}



DWORD	WINAPI	
TestThread2(	LPVOID	lpv	)	{
/*++

Routine Description : 

	This function grabs the symmetric lock as a member of Group2()
	and then runs through the memory that is being 'protected'
	setting everything to 2.
	If a Group1 thread is in there anywhere - he'll put a 1 in and
	we'll assert !

Arguments : 

	a pointer to the lock to grab

Return Value : 

	Nothing meaningfull !

--*/

	rwex::CSymLock*	plock = (rwex::CSymLock*)lpv ;

	for( DWORD i=0; i<g_cNumSymIterations; i++ ) {

		plock->Group2Lock() ;

		for( DWORD k=0; k<g_cNumSymInternalLoops; k++ ) {
			for( DWORD j=0; j < sizeof( rgbProtect ) / sizeof( rgbProtect[0] ); j++ ) {

				long	result = InterlockedCompareExchange( &rgbProtect[j], 2, 0 ) ;
				if( j%512 == 0 ) {
					//Sleep( 2 ) ;
				}
				_ASSERT( result == 0 || result == 2 ) ;
			}
		}

		//Sleep( 5 ) ;

		ZeroMemory( rgbProtect, sizeof( rgbProtect ) ) ;

		plock->Group2Unlock() ;
	}
	return	0 ;

}



DWORD	WINAPI	
TestThread1(	LPVOID	lpv	)	{
/*++

Routine Description : 

	This function grabs the symmetric lock as a member of Group1()
	and then runs through the memory that is being 'protected'
	setting everything to 1.
	If a Group2 thread is in there anywhere - he'll put a 2 in and
	we'll assert !

Arguments : 

	a pointer to the lock to grab

Return Value : 

	Nothing meaningfull !

--*/

	rwex::CSymLock*	plock = (rwex::CSymLock*)lpv ;


	for( DWORD i=0; i<g_cNumSymIterations; i++ ) {

		plock->Group1Lock() ;

		for( DWORD	k=0; k<g_cNumSymInternalLoops; k++ ) {
			for( int j=0; j < sizeof( rgbProtect ) / sizeof( rgbProtect[0] ); j++ ) {

				long	result = InterlockedCompareExchange( &rgbProtect[j], 1, 0 ) ;
				if( j%512 == 0 ) {
					//Sleep( 2 ) ;
				}
				_ASSERT( result == 0 || result == 1 ) ;
			}
		}

		//Sleep( 5 ) ;

		ZeroMemory( rgbProtect, sizeof( rgbProtect ) ) ;

		plock->Group1Unlock() ;
	}

	return	0 ;

}


long	rgdwRWProtect[8192] ;

rwex::CShareLock	g_lock ;

void
SharedLoop()	{
/*++

Routine Description : 

	This function executes while a read lock is held.
	We zoom through the array of protected longs, changing everything
	to 0x10101010.  We know that we must get either 0 or 0x10101010
	because ExclusiveLoop() resets to 0 when it exits, and other reader
	threads only set to 0x10101010.

Arguments : 

	None.

Return Value : 

	None.

--*/

	for( int	k=0; k<g_cNumRWLoops; k++ ) {
		for( int	j=0; j<sizeof(rgdwRWProtect)/sizeof(DWORD); j++ ) {
			long	result = InterlockedCompareExchange( 
												&rgdwRWProtect[j], 
												0x10101010, 
												0
												) ;

			_ASSERT( result == 0 || result == 0x10101010 ) ;
		}
	}
}

void
PartialLoop()	{
/*++

Routine Description : 

	This function executes while the Partial Lock is held !
	Do the shared lock protocol = and then do the Partial() protocol !

Arguments : 

	None.

Return Value : 

	None.

--*/

	long	l = GetCurrentThreadId() ;

	for( int	k=0; k<g_cNumRWLoops; k++ ) {
		for( int	j=0; j<sizeof(rgdwRWProtect)/sizeof(DWORD); j++ ) {
			long	result = InterlockedCompareExchange( 
												&rgdwRWProtect[j], 
												0x10101010, 
												0
												) ;

			_ASSERT( result == 0 || result == 0x10101010 ) ;
		}
		for( j=0; j<sizeof(rgdwPartial)/sizeof(long); j++ )	{
			//
			//	reset entries to 0 - thats what partial lock people do !
			//
			long	result = InterlockedCompareExchange(
												&rgdwPartial[j], 
												l, 
												0
												) ;
			_ASSERT( result == 0 || result == l ) ;
		}
	}
	ZeroMemory( rgdwPartial, sizeof( rgdwPartial ) ) ;
}



void
ExclusiveLoop()	{
/*++

Routine Description : 

	This function is executed while we have an exclusive lock.
	We make one pass through the array changing everything to 
	0x000000ff. We know the old value must be 0 or 0x10101010 because
	a reader thread may have been last in the lock.
	
	After this, we spin through the array incrementing things.

Arguments : 

	None.

Return Value : 

	None.

--*/

	for( DWORD j=0; j<sizeof(rgdwRWProtect)/sizeof(DWORD); j++ ) {
		long	result = InterlockedExchange( 
											&rgdwRWProtect[j], 
											0x000000ff 
											) ;

		_ASSERT( result == 0 || result == 0x10101010 ) ;
	}

	long	l = GetCurrentThreadId() ;

	for( j=0; j<sizeof(rgdwPartial)/sizeof(long); j++ )	{
		//
		//	reset entries to 0 - thats what partial lock people do !
		//
		long	result = InterlockedCompareExchange(
											&rgdwPartial[j], 
											l, 
											0
											) ;
		_ASSERT( result == 0 ) ;
	}


	for( int	k=0; k<g_cNumRWLoops; k++ ) {
		for( DWORD j=0; j<sizeof(rgdwRWProtect)/sizeof(DWORD); j++ ) {
			long	result = InterlockedIncrement( &rgdwRWProtect[j] ) ;
			_ASSERT( (0xff + k + 1) == result )  ;
		}
		for( j=0; j<sizeof(rgdwPartial)/sizeof(long); j++ )	{
			//
			//	reset entries to 0 - thats what partial lock people do !
			//
			long	result = InterlockedCompareExchange(
												&rgdwPartial[j], 
												l, 
												0
												) ;
			_ASSERT( result == l ) ;
		}

	}

	ZeroMemory( rgdwRWProtect, sizeof( rgdwRWProtect ) ) ;
	ZeroMemory( rgdwPartial, sizeof( rgdwPartial ) ) ;
}


DWORD	WINAPI	
RWTestThread(	LPVOID	lpv	)	{
/*++

Routine Description : 

	This thread tests the CShareLock several ways, by acquiring the locks
	in different ways and then performing various operations.

Arguments : 

	Nothing significant.

Return Value : 

	Nothing meaningfull.

--*/

	for( DWORD i=0; i<g_cNumRWIterations; i++ ) {
		//
		//	Attempt each of the different kinds of locks !
		//

		if( (i%256) == 0 ) {
			printf( "Loop iteration %d thread %x\n", i, GetCurrentThreadId() ) ;
		}

		g_lock.ShareLock() ;

		SharedLoop() ;

		if( g_lock.SharedToExclusive() ) {

			printf( "Converted SharedToExclusive !!!\n" ) ;

			//
			//	Change everything in the array to another value - 
			//	note we already made one pass so everything must contain 0x10101010 !
			//
			for( int k=0; k<g_cNumRWLoops; k++ ) {
				for( int	j=0; j<sizeof(rgdwRWProtect)/sizeof(DWORD); j++ ) {
					long	result = InterlockedIncrement( &rgdwRWProtect[j] ) ;
					_ASSERT( result == (0x10101010 + k + 1) ) ;
				}
			}
			ZeroMemory( &rgdwRWProtect, sizeof( rgdwRWProtect ) ) ;

			//
			//	Now convert the lock to shared again !
			// 

			g_lock.ExclusiveToShared() ;

			SharedLoop() ;

		}

		g_lock.ShareUnlock() ;

		if( g_lock.TryShareLock() ) {

			printf( "Successfully tried for a shared lock\n" ) ;

			SharedLoop() ;

			g_lock.ShareUnlock() ;

		}


		//
		//	Now lets try the Exclusive pass at the array !
		//

		if( g_lock.TryExclusiveLock() ) {

			printf( "Tried for Exclusive and won\n" ) ;

			ExclusiveLoop() ;

			g_lock.ExclusiveToShared() ;

			SharedLoop() ;

			g_lock.ShareUnlock() ;

		}

		if( g_lock.TryExclusiveLock() ) {

			printf( "Tried for Exclusive2 and won\n" ) ;

			ExclusiveLoop() ;
	
			g_lock.ExclusiveUnlock() ;

		}
			
		g_lock.ExclusiveLock() ;

		ExclusiveLoop() ;

		g_lock.ExclusiveToShared() ;

		SharedLoop() ;

		g_lock.ShareUnlock() ;

		g_lock.ExclusiveLock() ;

		ExclusiveLoop() ;

		g_lock.ExclusiveUnlock() ;	

		g_lock.PartialLock() ;
	
		PartialLoop() ;

		g_lock.PartialUnlock() ;

		if( g_lock.TryPartialLock() ) {
			PartialLoop() ;
			g_lock.PartialUnlock() ;
		}		

		g_lock.ExclusiveLock() ;

		ExclusiveLoop() ;

		g_lock.ExclusiveToPartial() ;

		PartialLoop() ;

		g_lock.PartialUnlock() ;

		g_lock.ExclusiveLock() ;

		ExclusiveLoop() ;

		g_lock.ExclusiveToPartial() ;

		PartialLoop() ;

		g_lock.FirstPartialToExclusive() ;

		ExclusiveLoop() ;

		g_lock.ExclusiveUnlock() ;

		g_lock.ShareLock() ;

		SharedLoop() ;

		if( g_lock.SharedToPartial() ) {
			PartialLoop() ;

			g_lock.FirstPartialToExclusive() ;
			ExclusiveLoop() ;
			g_lock.ExclusiveToPartial() ;
			PartialLoop() ;
			g_lock.PartialToShared() ;
			SharedLoop() ;
		}
		g_lock.ShareUnlock() ;
								
	}
	return	0 ;
}


int
__cdecl main( int argc, char* argv[] ) {

	parsecommandline( --argc, ++argv ) ;

	ZeroMemory( rgbProtect, sizeof( rgbProtect ) ) ;

	rwex::CSymLock	lock ;

	HANDLE	rgh[64] ;

	for( DWORD i=0; i<g_cNumSymThreads; i+=2 ) {

		DWORD	dwJunk ;
		rgh[i] = CreateThread(	0,
										0,
										TestThread2,
										(LPVOID)&lock,	
										0, 
										&dwJunk
										) ;					

		rgh[i+1] = CreateThread(	0,
										0,
										TestThread1,
										(LPVOID)&lock,	
										0, 
										&dwJunk
										) ;	
	}

	HANDLE	rghRW[64] ;

	for( DWORD k=0; k<g_cNumRWThreads; k++ ) {

		DWORD	dwJunk ;

		rghRW[k] = CreateThread(	0,
										0,
										RWTestThread,
										(LPVOID)0,	
										0, 
										&dwJunk
										) ;					

	}

	WaitForMultipleObjects( i, rgh, TRUE, INFINITE ) ;

	WaitForMultipleObjects( k, rghRW, TRUE, INFINITE ) ;

	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rw\src\asymlock.cpp ===
/*++

	asymlock.cpp

	This file implements a Symmetric lock.

	The lock allows multiple threads of a single type to enter the lock, 
	and excludes threads of the other type.  
	
	i.e. Group1Lock() allows any thread doing a 'Group1' operation to enter
		simultaneously with other Group1 threads.

		Group2Lock() allows any thread doing a 'Group2' operation to enter
	the lock and excludes threads calling Group1Lock().


	NOTE : 

	These locks cannot be re-entered after being acquired - 
	i.e. the call sequence : 

	Group1Lock() ;
	Group1Lock() ;
	Group1Unlock() ;
	Group1Unlock() ;
	
	Can cause a deadlock !

--*/


#include	<windows.h>
#include	"dbgtrace.h"
#include	"rwex.h"

namespace	rwex	{


CSymLock::CSymLock() : 
	m_lock( 0 ),
	m_Departures( 0 ), 
	m_left( 0 ), 
	m_hSema4Group1( 0 ),
	m_hSema4Group2( 0 )		{
/*++

Routine Description : 

	This function intiailizes a Symmetric Lock.
	We need to allocate to semaphores !

Arguments : 

	None.

Return Value : 

	None

--*/

	m_hSema4Group1 = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
	m_hSema4Group2 = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;

}	

CSymLock::~CSymLock()	{
/*++

Routine Description : 

	This function destroys a symmetric lock - release
	the semaphores we've been using !

Arguments : 

	None.

Return Value : 

	None

--*/

	if( m_hSema4Group1 ) 
		CloseHandle( m_hSema4Group1 ) ;

	if( m_hSema4Group2 ) 
		CloseHandle( m_hSema4Group2 ) ;

}

BOOL
CSymLock::IsValid()	{
/*++

Routine Description : 

	Checks to see that the lock is valid !

Arguments : 

	None.

Return Value : 

	TRUE if it looks like we were successfully constructed - 
	FALSE otherwise !

--*/

	return	m_hSema4Group1 != 0 && m_hSema4Group2 != 0 ; 

}

BOOL
CSymLock::Group1Departures(	long	bump	)	{
/*++

Routine Description : 

	Execute the departure protocol for Group1 Threads when Group2 threads
	are waiting for the lock !

Arguments : 

	bump - Occasionally a Group2 thread needs to participate in 
		the Group1Departure protocol because of the timing of the entrance into
		the lock.
		When this occurs bump should be 1 and is used to account for the fact
		that the calling thread is a Group2 thread that may be able to go 
		straight into the lock.

Return Value : 

	TRUE - if the departure protocol is completed and Group2 threads can enter the lock !

--*/

	_ASSERT(  bump == 1 || bump == 0 ) ;

	//
	//	Now - we may be the thread that is last to leave !
	//
	long	result = InterlockedIncrement( (long*)&m_left ) ;
	if( result == m_Departures ) { 
		//
		//	We own the lock - but we need to free our buddies !
		//	Must set these to 0 before we allow other threads into the lock !
		//
		m_Departures = 0 ;
		m_left = 0 ;

		//
		//	The actual number of threads that left the lock is : 
		//
		result -- ;

		//
		//	This may allow other Group1 threads through the lock !
		//	
		result = InterlockedExchangeAdd( (long*)&m_lock,  - result ) - result ;

		//
		//	Okay - we can now figure out how many of our buddy threads to set free - 
		//	and whether we need to count departing threads !
		//

		long	cGroup2 = result >> 16 ;
		result &= 0x0000FFFF ;

		//
		//	Are there Group1 threads already trying to get back into the lock ?
		//	If so then the first Group1 thread that tried to reclaim the lock 
		//	was blocked - and so we need to setup the departure for the departing
		//	Group2 threads that we are going to release !
		//
		if( result != 0 ) {
			m_Departures = cGroup2 + 1 ;
			long	temp = InterlockedIncrement( (long*)&m_left ) ;
			//
			//	This can't happen because there is at LEAST 1 thread who is not leaving the lock
			//	anytime soon !
			//
			_ASSERT( temp != m_Departures ) ;
		}

		//
		//	Check if we are the sole Group2 thread trying to enter the lock - 
		//	in which case ReleaseSemaphore isn't necessary !
		//
		long	dwJunk ;
		if( cGroup2 != bump ) 
			ReleaseSemaphore( m_hSema4Group2, cGroup2-bump, &dwJunk ) ;
		
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CSymLock::Group2Departures(	long	bump	)	{
/*++

Routine Description : 

	Execute the departure protocol for Group2 Threads when Group1 threads
	are waiting for the lock !

Arguments : 

	bump - Occasionally a Group1 thread needs to participate in 
		the Group2Departure protocol because of the timing of the entrance into
		the lock.
		When this occurs bump should be 1 and is used to account for the fact
		that the calling thread is a Group2 thread that may be able to go 
		straight into the lock.

Return Value : 

	TRUE - if the departure protocol is completed and Group2 threads can enter the lock !

--*/

	_ASSERT(  bump == 1 || bump == 0 ) ;


	//
	//	Now - we may be the thread that is last to leave !
	//
	long	result = InterlockedIncrement( (long*)&m_left ) ;
	if( result == m_Departures ) { 
		//
		//	We own the lock - but we need to free our buddies !
		//	Must set these to 0 before we allow other threads into the lock !
		//
		m_Departures = 0 ;
		m_left = 0 ;

		//
		//	The actual number of threads that left the lock is : 
		//
		result -- ;

		//
		//	This may allow other Group1 threads through the lock !
		//	
		result = InterlockedExchangeAdd( (long*)&m_lock,  -(result << 16) ) - (result<<16) ;

		//
		//	Okay - we can now figure out how many of our buddy threads to set free - 
		//	and whether we need to count departing threads !
		//

		long	cGroup1 = result & 0x0FFFF ;
		result >>= 16 ;

		//
		//	Are there Group2 threads already trying to get back into the lock ?
		//	If so then the first Group1 thread that tried to reclaim the lock 
		//	was blocked - and so we need to setup the departure for the departing
		//	Group1 threads that we are going to release !
		//
		if( result != 0 ) {
			m_Departures = cGroup1 + 1 ;
			long	temp = InterlockedIncrement( (long*)&m_left ) ;
			//
			//	This can't happen because there is at LEAST 1 thread who is not leaving the lock
			//	anytime soon !
			//
			_ASSERT( temp != m_Departures ) ;
		}

		//
		//	NOTE : we added 1 to the lock for ourself, so we don't need to be released !
		//
		long	dwJunk ;
		if( cGroup1 != bump ) 
			ReleaseSemaphore( m_hSema4Group1, cGroup1-bump, &dwJunk ) ;
		
		return	TRUE ;
	}
	return	FALSE ;
}



void
CSymLock::Group1Lock()	{
/*++

Routine Description : 
	
	Acquire the lock for a Group1 Thread.
	Group1 Threads are tracked in the low word of the lock value !

Arguments : 

	None

Return Value : 

	None - blocks until the lock is acquired !


--*/

	long	result = InterlockedExchangeAdd( (long*)&m_lock, 1 ) + 1 ;
	long	cGroup2 = (result >> 16) ;

	if( cGroup2 != 0 ) {

		//
		//	We must block - somebody else is in the lock !
		//

		if( (result & 0xFFFF) == 1 ) {
			//
			//	First group1 thread to try - lets setup to count departing threads !
			//
			m_Departures = cGroup2 + 1 ;

			//
			//	Now - do the departure protocol - if this returns TRUE then
			//	we were the last thread through the protocol and hence we can continue on !
			//
			if( Group2Departures( 1 ) ) {
				return	 ;
			}
		}
		WaitForSingleObject( m_hSema4Group1, INFINITE ) ;
	}
}


void
CSymLock::Group2Lock()	{
/*++

Routine Description : 
	
	Acquire the lock for a Group1 Thread.
	Group2 Threads are tracked in the high word of the lock value !

Arguments : 

	None

Return Value : 

	None - blocks until the lock is acquired !


--*/

	long	result = InterlockedExchangeAdd( (long*)&m_lock, 0x10000 ) + 0x10000 ;
	long	cGroup1 = result & 0x0FFFF ;

	if( cGroup1 != 0 ) {

		//
		//	We must block - somebody else is in the lock !
		//

		if( (result >> 16) == 1 ) {
			//
			//	First group2 thread to try - lets setup to count departing threads !
			//
			m_Departures = cGroup1 + 1 ;

			//
			//	Now - do the departure protocol - if this returns TRUE then
			//	we were the last thread through the protocol and hence we can continue on !
			//
			if( Group1Departures( 1 ) ) {
				return	 ;
			}
		}
		WaitForSingleObject( m_hSema4Group2, INFINITE ) ;
	}
}


BOOL
CSymLock::InterlockedDecWordAndMask(	volatile	long*	plong,	
							long	mask,	
							long	decrement 
							) {
/*++

Routine Description : 

	This function subtracts 'decrement' from *plong if and only if 
	*plong & mask is zero.
	This is used by both Group1Unlock and Group2Unlock to decrement
	the count of their respective threads in the lock, but to only
	do the decrement when no threads of the other type are waiting !

Arguments : 

	plong - pointer to the long we wish to subtract from !
	mask -  the mask used to check the opposite word for zero
	decrement - the amount to subtract !

Return Value : 

	TRUE if the plong is decremented
	FALSE if the *plong & mask is ever non-zero !

--*/

	//
	//	do an initial read from the plong !
	//
	long	temp = *plong ;

	while( (temp&mask) == 0 ) {

		//
		//	Try to subtract decrement 
		//
		long newvalue = InterlockedCompareExchange( (long*)plong, (temp-decrement), temp ) ;
		//
		//	If newvalue is the same as temp then the subtraction occurred !
		//
		if( temp == newvalue ) 
			return	TRUE ;
		temp = newvalue ;
	}
	//
	//	The mask indicates that the opposite word is set !
	//
	return	FALSE ;
}

void
CSymLock::Group1Unlock()	{
/*++

Routine Description : 

	Perform the Group1 Exit protocol on the lock.

	If no Group2 threads are trying to enter, just decrement the lock appropriately.
	If Group2 Threads are waiting we have to go through the more complicated
	Group1Departures() exit protocol which determines which Group1 Thread is the last
	to leave so that it can let Group2 threads into the lock.

Arguments : 

	None.

Return Value : 

	None.

--*/

	if( !InterlockedDecWordAndMask( &m_lock, 0xFFFF0000, 1 ) )	{
		Group1Departures( 0 ) ;
	}
}

void
CSymLock::Group2Unlock()	{
/*++

Routine Description : 

	Perform the Group2 Exit protocol on the lock.

	If no Group1 threads are trying to enter, just decrement the lock appropriately.
	If Group1 Threads are waiting we have to go through the more complicated
	Group2Departures() exit protocol which determines which Group2 Thread is the last
	to leave so that it can let Group1 threads into the lock.

Arguments : 

	None.

Return Value : 

	None.

--*/

	if( !InterlockedDecWordAndMask( &m_lock, 0xFFFF, 0x10000 ) )	{
		Group2Departures( 0 ) ;
	}
}

}	// namespace rwex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\regtrace\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by regtrace.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_REGTRACE_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_OUTPUT                      129
#define IDD_THREAD                      130
#define IDD_TRACES                      131
#define IDD_CONNECTING                  132
#define FULLLANG_ID                     0409
#define IDC_FILENAME                    1000
#define IDC_DISABLED                    1001
#define IDC_FILE                        1002
#define IDC_DEBUGGER                    1003
#define IDC_DISCARD                     1004
#define IDC_ASYNC                       1005
#define IDC_PRIORITY_HIGHEST            1006
#define IDC_PRIORITY_ABOVE              1007
#define IDC_PRIORITY_NORMAL             1008
#define IDC_PRIORITY_BELOW              1009
#define IDC_PRIORITY_IDLE               1010
#define IDC_ERROR                       1011
#define IDC_FATAL                       1012
#define IDC_DEBUG                       1013
#define IDC_STATE                       1014
#define IDC_THREADGRP                   1014
#define IDC_FUNCTION                    1015
#define IDC_CONNECT_TXT                 1015
#define IDC_MESSAGE                     1016
#define IDC_MAXTRACEFILESIZE            1016
#define IDS_ERROR_CAPTION               59142
#define IDS_ERROR_TEXT                  59143
#define IDS_CONNECT_FORMAT              59144
#define IDS_TRACE_CAPTION               59145
#define IDS_REMOTE_CAPTION              59146

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rwinst\rwinst.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: rwinst.cpp
//
//  Description:  Implementation of CShareLockInst library functions
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      5/24/99 - MikeSwa Created
//      8/6/99 - MikeSwa  created phatq version
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <rwinst.h>
#include <stdlib.h>
#include <dbgtrace.h>

//Static initialization
LIST_ENTRY      CShareLockInst::s_liLocks;
volatile DWORD  CShareLockInst::s_dwLock = 0;
DWORD           CShareLockInst::s_cLockSpins = 0;
DWORD           CShareLockInst::s_dwSignature = SHARE_LOCK_INST_SIG_FREE;

//---[ CThreadIdBlock::cIncThreadCount ]---------------------------------------
//
//
//  Description:
//      Increments the thread count for a given thread ID
//  Parameters:
//      dwThreadId      Thread to increment the thread count for
//  Returns:
//      New count value
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cIncThreadCount(DWORD dwThreadId)
{
    _ASSERT(THREAD_ID_BLOCK_UNUSED != dwThreadId);
    CThreadIdBlock *ptblkCurrent = this;
    CThreadIdBlock *ptblkOld = NULL;
    CThreadIdBlock *ptblkNew = NULL;

    while (ptblkCurrent)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblkCurrent->m_dwSignature);
        if (dwThreadId == ptblkCurrent->m_dwThreadId)
            return InterlockedIncrement((PLONG) &(ptblkCurrent->m_cThreadRecursionCount));

        ptblkOld = ptblkCurrent;
        ptblkCurrent = ptblkCurrent->m_ptblkNext;
    }

    _ASSERT(ptblkOld); //we should hit loop at least once

    //See if the current block has a thread ID associated with it
    if (THREAD_ID_BLOCK_UNUSED == ptblkOld->m_dwThreadId)
    {
        //This is actually the head block... use it to avoid an extra alloc
        if (THREAD_ID_BLOCK_UNUSED == InterlockedCompareExchange(
                    (PLONG) &ptblkOld->m_dwThreadId,
                    dwThreadId, THREAD_ID_BLOCK_UNUSED))
        {
            _ASSERT(dwThreadId == ptblkOld->m_dwThreadId);
            //Now this thread block is the current one
            return InterlockedIncrement((PLONG) &ptblkOld->m_cThreadRecursionCount);
        }
    }

    //We did not find it... we must create a new CThreadIdBlock
    ptblkNew = new CThreadIdBlock();

    //if we fail to alloc 32 bytes... I should see if we have spun out of
    //control
    _ASSERT(ptblkNew);
    if (!ptblkNew)
        return 1; //Fake success for our callers

    ptblkNew->m_dwThreadId = dwThreadId;
    ptblkNew->m_cThreadRecursionCount = 1;

    ptblkCurrent = (CThreadIdBlock *) InterlockedCompareExchangePointer(
                        (PVOID *) &ptblkOld->m_ptblkNext,
                        (PVOID) ptblkNew,
                        NULL);

    //If it is non-NULL, then our insert failed
    if (ptblkCurrent)
    {
        _ASSERT(ptblkCurrent != ptblkNew);
        //Whoops... another thread has added a block... time to try again
        //This time, start search from the block the just appeared
        delete ptblkNew;
        return ptblkCurrent->cIncThreadCount(dwThreadId);
    }

    //We inserted the block... inital count was 1
    return 1;
}

//---[ CThreadIdBlock::cDecThreadCount ]---------------------------------------
//
//
//  Description:
//      Decrements the thread count for a given thread ID
//  Parameters:
//      dwThreadId
//  Returns:
//      The resulting count
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cDecThreadCount(DWORD dwThreadId)
{
    _ASSERT(THREAD_ID_BLOCK_UNUSED != dwThreadId);
    CThreadIdBlock *ptblkCurrent = this;

    while (ptblkCurrent)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblkCurrent->m_dwSignature);
        if (dwThreadId == ptblkCurrent->m_dwThreadId)
            return InterlockedDecrement((PLONG) &(ptblkCurrent->m_cThreadRecursionCount));

        ptblkCurrent = ptblkCurrent->m_ptblkNext;
    }

    //We didn't find it... we would have asserted on insertion
    //Don't assert twice
    //$$TODO - Add global counts of these failures
    return 0;
}

//---[ CThreadIdBlock::cMatchesId ]--------------------------------------------
//
//
//  Description:
//      Checks if this thread block (or one in this thread blocks chain)
//      matches the given thread id.  Returns the count for this thread
//  Parameters:
//      dwThreadId - Thread Id to search for
//  Returns:
//      Thread count if the thread ID is found
//      0 if not found (or count is 0)
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cMatchesId(DWORD dwThreadId)
{
    CThreadIdBlock *ptblk = this;
    while (ptblk)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblk->m_dwSignature);
        if (ptblk->m_dwThreadId == dwThreadId)
            return ptblk->m_cThreadRecursionCount;

        ptblk = ptblk->m_ptblkNext;
    }
    return 0;
}

//---[ CShareLockInst::AcquireStaticSpinLock ]---------------------------------
//
//
//  Description:
//      Acquires static spin lock... from aqueue\cat\ldapstor
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Adapted from JStamerJ's code
//
//-----------------------------------------------------------------------------
void CShareLockInst::AcquireStaticSpinLock()
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (s_dwLock > 0)
        {
            Sleep(0);
            InterlockedIncrement((PLONG) &s_cLockSpins);
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement((PLONG) &s_dwLock) != 1 );

    //We have the lock... make sure that s_liLocks has been initialized
    if (s_dwSignature != SHARE_LOCK_INST_SIG)
    {
        InitializeListHead(&s_liLocks);
        s_dwSignature = SHARE_LOCK_INST_SIG;
    }
}

//---[ CShareLockInst::ReleaseStaticSpinLock ]---------------------------------
//
//
//  Description:
//      Releases previously acquired spinlock
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Adapted from JStamerJ's code
//
//-----------------------------------------------------------------------------
void CShareLockInst::ReleaseStaticSpinLock()
{
    _ASSERT(SHARE_LOCK_INST_SIG == s_dwSignature); //static init was done
    _ASSERT(s_dwLock > 0);
    InterlockedExchange((PLONG) &s_dwLock, 0 );
}

//---[ CShareLockInst::CShareLockInst ]----------------------------------------
//
//
//  Description:
//      Constructor for CShareLockInst
//  Parameters:
//      szDescription       Constant string passed in to describe lock
//      dwFlags             Flags describing what to track
//      cMaxTrackedSharedThreadIDs  Maximum # of threads to track
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CShareLockInst::CShareLockInst(LPCSTR szDescription,
                               DWORD dwFlags, DWORD cMaxTrackedSharedThreadIDs)
{
    DWORD cbArray = sizeof(DWORD) * cMaxTrackedSharedThreadIDs;
    m_dwSignature = SHARE_LOCK_INST_SIG;
    m_dwFlags = dwFlags;
    m_liLocks.Flink = NULL;
    m_liLocks.Blink = NULL;
    m_cShareAttempts = 0;
    m_cShareAttemptsBlocked = 0;
    m_cExclusiveAttempts = 0;
    m_cExclusiveAttemptsBlocked = 0;
    m_szDescription = szDescription;
    m_rgtblkSharedThreadIDs = NULL;
    m_dwExclusiveThread = NULL;
    m_cCurrentSharedThreads = 0;
    m_cMaxConcurrentSharedThreads = 0;
    m_cMaxTrackedSharedThreadIDs = cMaxTrackedSharedThreadIDs;

    if (SHARE_LOCK_INST_TRACK_NOTHING & m_dwFlags)
        m_dwFlags = 0;

    //Allocate memory to store thread IDs
    if (fTrackSharedThreads())
    {
        _ASSERT(cbArray);
        m_rgtblkSharedThreadIDs = new CThreadIdBlock[m_cMaxTrackedSharedThreadIDs];
        if (!m_rgtblkSharedThreadIDs)
            m_cMaxTrackedSharedThreadIDs = 0;
    }

    //Insert in list if we are tracking
    if (fTrackInGlobalList())
    {
        AcquireStaticSpinLock();
        InsertHeadList(&s_liLocks, &m_liLocks);
        ReleaseStaticSpinLock();
    }
};

//---[ CShareLockinst::~CShareLockinst ]---------------------------------------
//
//
//  Description:
//      CShareLockInst desctructor.  Will remove this lock from the
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CShareLockInst::~CShareLockInst()
{
    m_dwSignature = SHARE_LOCK_INST_SIG_FREE;
    if (m_rgtblkSharedThreadIDs)
    {
        delete [] m_rgtblkSharedThreadIDs;
        m_rgtblkSharedThreadIDs = NULL;
    }

    if (fTrackInGlobalList())
    {
        AcquireStaticSpinLock();
        RemoveEntryList(&m_liLocks);
        ReleaseStaticSpinLock();
    }

};


//---[ CShareLockInst::LogAcquireShareLock ]-----------------------------------
//
//
//  Description:
//      Does all the work of logging the appropriate information when a thread
//      acquires the lock shared.
//          - Updates max concurrent shared threads
//          - Updates current shared threads
//          - Updates lists of shared thread IDs
//          - Asserts when shared deadlocks are detected
//  Parameters:
//      BOOL    fTry - TRUE if this is for a try enter (deadlock cannot happen)
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::LogAcquireShareLock(BOOL fTry)
{

    if (fTrackSharedThreads())
    {
        DWORD   cCurrentSharedThreads = 0;
        DWORD   cMaxConcurrentSharedThreads = 0;
        DWORD   dwThreadID = GetCurrentThreadId();
        DWORD   dwThreadCount = 0;
        DWORD   dwThreadHash = 0;

        _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero
        cCurrentSharedThreads = InterlockedIncrement((PLONG) &m_cCurrentSharedThreads);

        //Update max concurrent threads if we have set a new record
        cMaxConcurrentSharedThreads = m_cMaxConcurrentSharedThreads;
        while (cCurrentSharedThreads > cMaxConcurrentSharedThreads)
        {
            InterlockedCompareExchange((PLONG) &m_cMaxConcurrentSharedThreads,
                                       (LONG) cCurrentSharedThreads,
                                       (LONG) cMaxConcurrentSharedThreads);

            cMaxConcurrentSharedThreads = m_cMaxConcurrentSharedThreads;
        }

        //if we have a place to store our thread ID...save it
        if (m_rgtblkSharedThreadIDs)
        {
            dwThreadHash = dwHashThreadId(dwThreadID,
                                          m_cMaxTrackedSharedThreadIDs);
            _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
            dwThreadCount = m_rgtblkSharedThreadIDs[dwThreadHash].cIncThreadCount(dwThreadID);

            if (!fTry && (dwThreadCount > 1))
            {
                //This thread already holds this lock... this is a
                //potential deadlock situation
                if (fAssertSharedDeadlocks())
                {
                    _ASSERT(0 && "Found potential share deadlock");
                }
            }
        }
    }
}

//---[ CShareLockInst::LogReleaseShareLock ]-----------------------------------
//
//
//  Description:
//      Called when a sharelock is released to cleanup the information stored
//      in LogAcquireShareLock.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::LogReleaseShareLock()
{
    if (fTrackSharedThreads())
    {
        DWORD dwThreadID = GetCurrentThreadId();
        DWORD dwThreadHash = 0;

        _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero

        //Search through list of thread IDs for
        if (m_rgtblkSharedThreadIDs)
        {
            dwThreadHash = dwHashThreadId(dwThreadID,
                                          m_cMaxTrackedSharedThreadIDs);
            _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
            m_rgtblkSharedThreadIDs[dwThreadHash].cDecThreadCount(dwThreadID);
        }
    }
}

//---[ CShareLockInst::ShareLock ]---------------------------------------------
//
//
//  Description:
//      Implements sharelock wrapper
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvShareLock()
{

    LogAcquireShareLock(FALSE);
    //If we are tracking contention, then we will try to enter the sharelock
    //and increment the contention count if that fails.
    if (fTrackContention())
    {
        InterlockedIncrement((PLONG) &m_cShareAttempts);
        if (!CShareLockInstBase::TryShareLock())
        {
            InterlockedIncrement((PLONG) &m_cShareAttemptsBlocked);
            CShareLockInstBase::ShareLock();
        }
    }
    else
    {
        CShareLockInstBase::ShareLock();
    }

};


//---[ CShareLockInst::ShareUnlock ]-------------------------------------------
//
//
//  Description:
//      Wrapper for ShareUnlock
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvShareUnlock()
{
    LogReleaseShareLock();
    CShareLockInstBase::ShareUnlock();
};

//---[ CShareLockInst::TryShareLock ]------------------------------------------
//
//
//  Description:
//      Implements TryShareLock wrapper.
//  Parameters:
//
//  Returns:
//      TRUE if the lock was acquired.
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CShareLockInst::PrvTryShareLock()
{
    BOOL fLocked = FALSE;

    fLocked = CShareLockInstBase::TryShareLock();

    if (fLocked)
        LogAcquireShareLock(TRUE);

    return fLocked;
};

//---[ CShareLockInst::ExclusiveLock ]-----------------------------------------
//
//
//  Description:
//      Implements ExclusiveLock wrapper
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvExclusiveLock()
{

    //If we are tracking contention, then we will try to enter the lock
    //and increment the contention count if that fails.
    if (fTrackContention())
    {
        InterlockedIncrement((PLONG) &m_cExclusiveAttempts);
        if (!CShareLockInstBase::TryExclusiveLock())
        {
            InterlockedIncrement((PLONG) &m_cExclusiveAttemptsBlocked);
            CShareLockInstBase::ExclusiveLock();
        }
    }
    else
    {
        CShareLockInstBase::ExclusiveLock();
    }

    if (fTrackExclusiveThreads())
    {
        //This should be the only thread accessing this now
        _ASSERT(!m_dwExclusiveThread);
        m_dwExclusiveThread = GetCurrentThreadId();
    }

};


//---[ CShareLockInst::ExclusiveUnlock ]---------------------------------------
//
//
//  Description:
//      Wrapper for ExclusiveUnlock
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvExclusiveUnlock()
{
    if (fTrackExclusiveThreads())
    {
        _ASSERT(GetCurrentThreadId() == m_dwExclusiveThread);
        m_dwExclusiveThread = 0;
    }
    CShareLockInstBase::ExclusiveUnlock();
};

//---[ CShareLockInst::TryExclusiveLock ]--------------------------------------
//
//
//  Description:
//      Implements TryExclusiveLock wrapper.
//  Parameters:
//
//  Returns:
//      TRUE if the lock was acquired.
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CShareLockInst::PrvTryExclusiveLock()
{
    BOOL fLocked = FALSE;

    fLocked = CShareLockInstBase::TryExclusiveLock();

    if (fLocked && fTrackExclusiveThreads())
    {
        //This should be the only thread accessing this now
        _ASSERT(!m_dwExclusiveThread);
        m_dwExclusiveThread = GetCurrentThreadId();
    }
    return fLocked;
};

//---[ CShareLockInst::PrvAssertIsLocked ]-------------------------------------
//
//
//  Description:
//      Asserts if this threads ID is not recorded as one that acquired this
//      lock.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/24/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvAssertIsLocked()
{
    DWORD dwThreadID = GetCurrentThreadId();
    DWORD dwThreadHash = 0;
    BOOL  fFoundThreadID = FALSE;

    _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero

    //Bail out if we are not configured to track this things.
    if (!fTrackSharedThreads() || !fTrackExclusiveThreads() || !m_rgtblkSharedThreadIDs)
        return;

    if (dwThreadID == m_dwExclusiveThread)
    {
        fFoundThreadID = TRUE;
    }
    else
    {
        dwThreadHash = dwHashThreadId(dwThreadID,
                                      m_cMaxTrackedSharedThreadIDs);
        _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
        fFoundThreadID = (0 < m_rgtblkSharedThreadIDs[dwThreadHash].cMatchesId(dwThreadID));

    }

    if (!fFoundThreadID)
        _ASSERT(0 && "Lock is not held by this thread!!!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rwnh\utest\rwnhdll.h ===
/*++

	rwnhdll.h

	This file defines the API's exported from the rwnh unit test DLL.


--*/

#ifndef	_RWNHDLL_H_
#define	_RWNHDLL_H_

#ifdef	_RWNH_IMP_
#define	_RWNHDLL_INTERFACE_ __declspec( dllexport ) 
#else
#define	_RWNHDLL_INTERFACE_	__declspec( dllimport ) 
#endif

extern	"C"	{

_RWNHDLL_INTERFACE_	
DWORD	
RWTestThread(	DWORD	i	) ;

_RWNHDLL_INTERFACE_	
void
TestInit(	int	cNumRWLoops, 
			DWORD	cNumRWIterations
			) ;

} 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rwnh\src\rwintrnl.cpp ===
/*++

	rwintrnl.cpp

	This file contains classes and methods only for use within 
	the reader/writer locks defined in rw.h

--*/

#include	<windows.h>
#include	<stdio.h>
#include	"rwnew.h"


HANDLE	CWaitingThread::g_rghHandlePool[ POOL_HANDLES ] ;
CRITICAL_SECTION	DebugCrit ;

CHandleInfo	CHandleInfo::s_Head ;
CRITICAL_SECTION	CHandleInfo::s_InUseList ;
CHandleInfo	CHandleInfo::s_FreeHead ;
DWORD	CHandleInfo::s_cFreeList = 0 ;


void	
CHandleInfo::InsertAtHead( CHandleInfo*	pHead	)		{

	CHandleInfo*	pNext = pHead->m_pNext ;
	m_pNext = pNext ;
	m_pPrev = pHead ;
	pNext->m_pPrev = this ;
	pHead->m_pNext = this ;
}

CHandleInfo*
CHandleInfo::RemoveList( ) {
	CHandleInfo*	pNext = m_pNext ;
	CHandleInfo*	pPrev = m_pPrev ;
	pNext->m_pPrev = pPrev ;
	pPrev->m_pNext = pNext ;
	m_pNext = 0 ;
	m_pPrev = 0 ;
	return	this ;
}


void*
CHandleInfo::operator	new(	size_t size ) {
/*++

Routine Description : 

	Allocate memory for a CHandleInfo structure from the system heap !

Arguments : 

	Size of the object, should always be sizeof( CHandleInfo ) !

Return Value : 

	Pointer to allocated memory !

--*/



	_ASSERT( size == sizeof( CHandleInfo ) ) ;
	return	HeapAlloc( GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, size ) ;
}

void
CHandleInfo::operator	delete( void*	pv ) {
/*++

Routine Description : 

	Release memory for a CHandleInfo structure to the system heap !

Arguments : 

	Memory to be freed

Return Value : 

	Nothing !

--*/


	HeapFree( GetProcessHeap(), 0, pv ) ;
}

CHandleInfo::CHandleInfo() : 	
	m_dwSignature( SIGNATURE ), 
	m_pNext( 0 ),
	m_pPrev( 0 ), 
	m_hSemaphore( 0 )
	{
/*++

Routine Description : 

	Construct a CHandleInfo object !

Arguments : 

	Memory to be freed

Return Value : 

	Nothing !

--*/

	m_hSemaphore= CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;
    m_hEvent = CreateEvent( 0, FALSE, FALSE, 0 ) ;

}

CHandleInfo::~CHandleInfo() {
/*++

Routine Description : 

	Release memory for a CHandleInfo structure to the system heap !

Arguments : 

	Memory to be freed

Return Value : 

	Nothing !

--*/

	_ASSERT( m_dwSignature == SIGNATURE ) ;
	m_dwSignature = 0 ;

	_ASSERT( m_pNext == 0 || (this == &s_Head || this == &s_FreeHead)) ;
	_ASSERT( m_pPrev == 0 || (this == &s_Head || this == &s_FreeHead)) ;

	if( m_hSemaphore != 0 ) {

		CloseHandle( m_hSemaphore) ;
	}
	m_hSemaphore = 0 ;
    if( m_hEvent != 0 ) 
        CloseHandle( m_hEvent ) ;
    m_hEvent = 0 ;
}


BOOL
CHandleInfo::InitClass()	{
/*++

Routine Description : 

	Initialize our handle tracking data structures.

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	s_Head.m_pPrev = s_Head.m_pNext = &s_Head ;
	s_FreeHead.m_pPrev = s_FreeHead.m_pNext = &s_FreeHead ;

	InitializeCriticalSection( &s_InUseList ) ;

	EnterCriticalSection( &s_InUseList ) ;

	for( DWORD i=0; i < INITIAL_FREE; i++ ) {

		CHandleInfo*	p = new CHandleInfo() ;
		if( !p ) {
			break ;
		}	else	{
			p->InsertAtHead( &s_FreeHead ) ;
			s_cFreeList ++ ;
		}
	}
	LeaveCriticalSection( &s_InUseList ) ;
	return	i == INITIAL_FREE ;
}

void
CHandleInfo::TermClass()	{
/*++

Routine Description : 

	Destroy our handle tracking structures and release all handles !

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	DeleteCriticalSection( &s_InUseList ) ;

	while( 	s_FreeHead.m_pNext != &s_FreeHead ) {
		CHandleInfo*	p = s_FreeHead.m_pNext->RemoveList() ;
		delete	p ;
	}
	while( 	s_Head.m_pNext != &s_Head ) {
		CHandleInfo*	p = s_Head.m_pNext->RemoveList() ;
		delete	p ;
	}
}

CHandleInfo*
CHandleInfo::AllocHandleInfo()	{
/*++

Routine Description : 

	Allocate an object to hold Handle Information !

Arguments : 

	None.

Return Value : 

	Pointer to a CHandleInfo structure !

--*/

	EnterCriticalSection( &s_InUseList ) ;

	CHandleInfo* p = s_FreeHead.m_pNext ;
	if( p != &s_FreeHead ) {
		p->RemoveList() ;
		p->InsertAtHead( &s_Head ) ;
		s_cFreeList -- ;
	}	else	{
		p = new CHandleInfo() ;
		if (!p)
		{
			LeaveCriticalSection( &s_InUseList ) ;
			return NULL;
		}
		p->InsertAtHead( &s_Head ) ;
	}
	LeaveCriticalSection( &s_InUseList ) ;

	if( p->m_hSemaphore == 0 ) {
		p->m_hSemaphore = CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

	}
    if( p->m_hEvent == 0 ) {
        p->m_hEvent = CreateEvent( 0, FALSE, FALSE, 0 ) ;
    }
	return	p ;
}

void
CHandleInfo::ReleaseHandleInfo( CHandleInfo* p ) {
/*++

Routine Description : 

	Allocate an object to hold Handle Information !

Arguments : 

	None.

Return Value : 

	Pointer to a CHandleInfo structure !

--*/

	EnterCriticalSection( &s_InUseList ) ;

	p->RemoveList() ;
	if( s_cFreeList < MAX_FREE ) {
		p->InsertAtHead( &s_FreeHead ) ;
		s_cFreeList ++ ;
		p = 0 ;
	}	
	LeaveCriticalSection( &s_InUseList ) ;

	if( p )	{
		delete	p ;
	}
}


BOOL	WINAPI
DllEntryPoint( 
			HINSTANCE	hinstDll,	
			DWORD		dwReason,	
			LPVOID		lpvReserved ) {

	BOOL	fRtn = TRUE ;

	switch( dwReason ) {

		case	DLL_PROCESS_ATTACH :

//DebugBreak() ;

			InitializeCriticalSection( &DebugCrit ) ;

			fRtn &= CHandleInfo::InitClass() ;
			fRtn &= CWaitingThread::InitClass() ;
			CWaitingThread::ThreadEnter() ;

			return	fRtn ;
			break ;


		case	DLL_THREAD_ATTACH : 
			CWaitingThread::ThreadEnter() ;
			break ;

		case	DLL_THREAD_DETACH : 
			CWaitingThread::ThreadExit() ;
			break ;

		case	DLL_PROCESS_DETACH : 

			CWaitingThread::TermClass() ;
			CHandleInfo::TermClass() ;
			break ;

	}
	return	TRUE ;
}


BOOL	WINAPI
DllMain(	HANDLE	hInst,
			ULONG	dwReason,
			LPVOID	lpvReserve )	{

	return	DllEntryPoint( (HINSTANCE)hInst, dwReason, lpvReserve ) ;

}
	


DWORD	CWaitingThread::g_dwThreadHandle = 0 ;

BOOL
CWaitingThread::InitClass()	{

	g_dwThreadHandle = TlsAlloc() ;

	ZeroMemory( g_rghHandlePool, sizeof( g_rghHandlePool ) ) ;

	for( int i=0; i< (sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] )) / 2; i++ )	{
		g_rghHandlePool[i] = 			CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

	}

	return	g_dwThreadHandle != 0xFFFFFFFF ;
}

BOOL
CWaitingThread::TermClass()	{

	for( int i=0; i< (sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] )); i++ )	{

		CloseHandle( g_rghHandlePool[i] ) ;
	}


	return	TlsFree( g_dwThreadHandle ) ;

}

void
CWaitingThread::ThreadEnter()	{

	CHandleInfo*	pInfo = CHandleInfo::AllocHandleInfo() ;
	_ASSERT( pInfo != 0 ) ;
	_ASSERT( pInfo->m_hSemaphore != 0 ) ;
	_ASSERT( pInfo->IsValid() ) ;
	TlsSetValue( g_dwThreadHandle, (LPVOID)pInfo ) ;

}

void
CWaitingThread::ThreadExit()	{

	CHandleInfo*	pInfo = (CHandleInfo*)	TlsGetValue( g_dwThreadHandle ) ;
	if( pInfo ) {
	    _ASSERT( pInfo->IsValid() ) ;
	    CHandleInfo::ReleaseHandleInfo( pInfo ) ;
	}

	TlsSetValue( g_dwThreadHandle, (LPVOID)0 ) ;
}

CWaitingThread::CWaitingThread() :
		m_pInfo( (CHandleInfo*)TlsGetValue( g_dwThreadHandle ) ), 
		m_dwError( 0 ) {
	
	if( m_pInfo == 0 ) {
		m_pInfo = CHandleInfo::AllocHandleInfo() ;
		TlsSetValue( g_dwThreadHandle, (LPVOID)m_pInfo ) ;
	}
	if( m_pInfo->m_hSemaphore == 0 ) {
		for( int i=0; 
				m_pInfo->m_hSemaphore == 0 && 
				i < sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] );
				i++ ) {
			m_pInfo->m_hSemaphore = (HANDLE)InterlockedExchangePointer( (void**)&g_rghHandlePool[i], 0 ) ;
		}

		if( m_pInfo->m_hSemaphore == 0 )	{
			m_pInfo->m_hSemaphore = 
				CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

		}
	}

#ifdef	DEBUG
	m_dwThreadId = GetCurrentThreadId() ;


	long	lPrev = 0 ;
	ReleaseSemaphore( m_pInfo->m_hSemaphore, 1, &lPrev ) ;
	_ASSERT( lPrev == 0 ) ;
	DWORD	dw = WaitForSingleObject( m_pInfo->m_hSemaphore, 0 ) ;
	_ASSERT( dw == WAIT_OBJECT_0 ) ;
#endif

}




CEventQueue::CEventQueue( long	cInitial ) : 
	m_WaitingThreads( cInitial > 0 ), 
	m_ReleaseCount( cInitial  )	{
}

BOOL
CEventQueue::ResumeThreads(	CWaitingThread*	pMyself	)	{

	BOOL	fRtn = FALSE ;
	CWaitingThread*	pThread = m_WaitingThreads.RemoveAndRelease() ;
	long	sign = 1 ;

	while( pThread ) {

		sign = InterlockedDecrement( &m_ReleaseCount ) ;

		if( pThread != pMyself ) {
			_VERIFY( pThread->Release() ) ;
		}	else	{
			fRtn = TRUE ;
		}

		if( sign <= 0 ) {
			break ;
		}

		pThread = m_WaitingThreads.RemoveAndRelease() ;

	}
	return	fRtn ;
}

void
CEventQueue::Release(	long	ReleaseCount )	{

	InterlockedExchangeAdd( &m_ReleaseCount, ReleaseCount ) ;

	ResumeThreads( 0 ) ;

}

void
CEventQueue::Reset()	{

	m_WaitingThreads.Reset() ;

}


void
CEventQueue::WaitForIt(	CWaitingThread&	myself ) {

	if( m_WaitingThreads.Append( &myself ) ) {

		if( !ResumeThreads( &myself ) ) {

			_VERIFY( myself.Wait() ) ;
		}

	}	else	{

		_VERIFY( myself.Wait() ) ;

	}
}

void
CEventQueue::WaitForIt()	{

	CWaitingThread	myself ;

	WaitForIt( myself ) ;
}

CEventQueue::~CEventQueue()	{
}





CSingleReleaseQueue::CSingleReleaseQueue( 
		BOOL	IsSignalled 
		) : 
	m_Waiting( IsSignalled )	{
}

void
CSingleReleaseQueue::WaitForIt(
		CWaitingThread&	myself 
		)	{

	if(	m_Waiting.Append( &myself ) ) {
		CWaitingThread*	pThread = m_Waiting.RemoveAndRelease() ;
		if( !pThread ) {
			_VERIFY( myself.Wait() ) ;
		}	else	if( pThread != &myself ) {

			_VERIFY( pThread->Release() ) ;
			_VERIFY( myself.Wait() ) ;
	
		}
	}	else	{

		_VERIFY( myself.Wait() ) ;

	}
}

void
CSingleReleaseQueue::WaitForIt()	{

	CWaitingThread	myself ;

	WaitForIt( myself ) ;
}

void
CSingleReleaseQueue::Release( ) {

	CWaitingThread*	pThread = m_Waiting.RemoveAndRelease() ;
	if( pThread ) {

#ifdef	DEBUG
		m_ThreadIdNext = pThread->m_dwThreadId ;
#endif

		_VERIFY( pThread->Release() ) ;

	}	else	{

		pThread = (CWaitingThread*)0 ;

	}
}


void	
CCritSection::Enter(	CWaitingThread&	myself )	{
/*++

Routine Description : 

	Acquire the critical section

Arguments : 

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value : 

	None - returns when lock is acquired !

--*/
	
	if( m_hOwner == myself.GetThreadHandle() ) {
		m_RecursionCount ++ ;
	}	else	{

		if( InterlockedIncrement( &m_lock ) == 0 ) {

		}	else	{
			m_queue.WaitForIt(	myself ) ;
		}
		m_hOwner = myself.GetThreadHandle() ;
		m_RecursionCount = 1 ;

#ifdef	DEBUG
		m_dwThreadOwner = GetCurrentThreadId() ;
#endif

		//	_ASSERT( m_RecursionCount == 0 ) ;
	}
}

BOOL
CCritSection::TryEnter(	CWaitingThread&	myself )	{
/*++

Routine Description : 

	Attempt to acquire the critical section, don't wait
	if somebody else is in the lock !

Arguments : 

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value : 

	None - returns when lock is acquired !

--*/
	
	if( m_hOwner == myself.GetThreadHandle() ) {
		m_RecursionCount ++ ;
	}	else	{

		if( InterlockedCompareExchangePointer( (void**)&m_lock, 0, (void*)-1 ) != (void*)-1 ) {
			return	FALSE ;
		}
		m_hOwner = myself.GetThreadHandle() ;
		m_RecursionCount = 1 ;

#ifdef	DEBUG
		m_dwThreadOwner = GetCurrentThreadId() ;
#endif
		//	_ASSERT( m_RecursionCount == 0 ) ;
	}
	return	TRUE ;
}



void	
CCritSection::Enter( )	{
/*++

Routine Description : 

	Acquire the critical section

Arguments : 

	none.
	
Return Value : 

	None - returns when lock is acquired !

--*/

	CWaitingThread	myself ;

	Enter( myself ) ;
}


void	
CCritSection::Leave()		{
/*++

Routine Description : 

	Release the critical section !

Arguments : 

	none.
	
Return Value : 

	None - returns when lock is acquired !

--*/

#ifdef	DEBUG
	_ASSERT( m_dwThreadOwner == GetCurrentThreadId() ) ;
	CWaitingThread	myself ;
	_ASSERT( myself.GetThreadHandle() == m_hOwner ) ;
#endif

	m_RecursionCount -- ;
	if( m_RecursionCount == 0 ) {

		m_hOwner = INVALID_HANDLE_VALUE ;

		if( InterlockedDecrement( &m_lock ) >= 0 ) {
			m_queue.Release() ;
		}
	}
}


void	
CSimpleCritSection::Enter(	CWaitingThread&	myself )	{
/*++

Routine Description : 

	Acquire the critical section

Arguments : 

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value : 

	None - returns when lock is acquired !

--*/
	
	if( InterlockedIncrement( &m_lock ) != 0 ) {
		m_queue.WaitForIt(	myself ) ;
	}
#ifdef	DEBUG
	m_dwThreadOwner = GetCurrentThreadId() ;
#endif
}

BOOL
CSimpleCritSection::TryEnter(	CWaitingThread&	myself )	{
/*++

Routine Description : 

	Attempt to acquire the critical section, don't wait
	if somebody else is in the lock !

Arguments : 

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value : 

	None - returns when lock is acquired !

--*/
	
	if( InterlockedCompareExchangePointer( (void**)&m_lock, 0, (void*)-1 ) != (void*)-1 ) {
		return	FALSE ;
	}
#ifdef	DEBUG
	m_dwThreadOwner = GetCurrentThreadId() ;
#endif
	return	TRUE ;
}



void	
CSimpleCritSection::Enter( )	{
/*++

Routine Description : 

	Acquire the critical section

Arguments : 

	none.
	
Return Value : 

	None - returns when lock is acquired !

--*/

	CWaitingThread	myself ;

	Enter( myself ) ;
}


void	
CSimpleCritSection::Leave()		{
/*++

Routine Description : 

	Release the critical section !

Arguments : 

	none.
	
Return Value : 

	None - returns when lock is acquired !

--*/

	if( InterlockedDecrement( &m_lock ) >= 0 ) {
		m_queue.Release() ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rwnh\src\rwv3.cpp ===
/*++

	rwv3.cpp

	This file defines another version of reader/writer locks that
	attempt to use no handles !


--*/


#include	<windows.h>
#include	"dbgtrace.h"
#include	"rwnew.h"
#include	"rwexport.h"

long	const	BlockValue = (-LONG_MAX) / 2;


CShareLockNH::CShareLockNH()	:
	m_cReadLock( 0 ),
	m_cOutReaders( 0 ),
	m_cOutAcquiringReaders( 0 ),
	m_cExclusiveRefs( 0 ),
	m_hWaitingReaders( 0 ),
	m_hWaitingWriters( 0 )	{

}

#ifdef	DEBUG
extern	CRITICAL_SECTION	DebugCrit ;
#endif


void
CShareLockNH::ShareLock()	{
	if( InterlockedIncrement( (long*)&m_cReadLock ) < 0 ) {
		ShareLockInternal() ;
	}
}

void
CShareLockNH::ShareUnlock()	{
	if( InterlockedDecrement( (long*)&m_cReadLock ) < 0 ) {
		ShareUnlockInternal() ;
	}
}


void
CShareLockNH::ShareLockInternal()	{
/*++

Routine Description :

	Acquire the lock in shared mode.
	If there is a writer trying to enter the lock, then we will
	have to wait, in which case we have to block on a semaphore handle
	that we or another reader provide.
	In the writer waiting case, we also have to carefully track which
	waiting reader thread is the LAST to be wakened up and return to
	the caller so we can properly manage the HANDLE used by all the
	reader threads.

Arguments :
	
	None.

Return Value :

	None.


--*/


	TraceFunctEnter("CShareLockNH::ShareLockInternal") ;

#if 0
	//
	//	This part of the logic is implemented by ShareLock() -
	//	which is an inline function !!
	//
	if( InterlockedIncrement( &m_cReadLock ) < 0 ) {
#endif

		//
		//	There is a writer who either owns the lock or is waiting
		//	to acquire the lock - either way he gets to go first and
		//	this thread should be blocked !
		//
		CWaitingThread	myself ;

		//
		//	Get the handle we've saved for this thread !
		//
		HANDLE	h = myself.GetThreadHandle() ;

		//
		//	If we are the first reader here, this function will return
		//	0, otherwise we'll get the handle of the first reader to
		//	save his handle !
		//
		HANDLE	hBlockOn = InterlockedCompareExchangePointer( (void**)&m_hWaitingReaders, (void*)h, 0 ) ;

		if( hBlockOn == 0 ) {
			hBlockOn= h;
		}

		DebugTrace( (DWORD_PTR)this, "hBlock - %x", hBlockOn ) ;

		//
		//	Wait for the writer to release the lock !
		//
		WaitForSingleObject( hBlockOn, INFINITE ) ;


		//
		//	We need to figure out whether we should do anything about
		//	the m_hWaitingReaders value - it needs to be set to 0 before
		//	another reader comes through this path !
		//

		long	l = InterlockedDecrement( (long*)&m_cOutAcquiringReaders ) ;
		_ASSERT( l>=0 ) ;

		DebugTrace( (DWORD_PTR)this, "l - %x", l ) ;

		if( l == 0 ) {


			//
			//	We are the last reader who was waiting !
			//	we can safely manipulate m_hWaitingReaders with no consequences !
			//	If it's our handle, then we'll do nothing with it,
			//	if it's not our handle we'll return it to the pool of handles !
			//

			m_hWaitingReaders = 0 ;

			if( hBlockOn != h ) {
				myself.PoolHandle( hBlockOn ) ;
			}

			//
			//	A Writer held the lock, and then relinquished it to us readers,
			//	but he didn't release the Exclusive Lock that let him keep other writers
			//	out.  We do that for him !!!
			//

			if( (l=InterlockedDecrement( (long*)&m_cExclusiveRefs )) == 0 )
				m_lock.Leave() ;

			DebugTrace( (DWORD_PTR)this, "Leave l - %x", l ) ;

		}	else	{
		
			//
			//	Our handle was left in the lock, we need to get rid of our
			//	reference to it, the last reader will return to the pool !
			//
			if( hBlockOn == h ) {

				myself.ClearHandle( h ) ;
			}
		}
#if 0
	}
#endif
}

void
CShareLockNH::ShareUnlockInternal()	{
/*++

Routine Description :

	Release the lock from shared mode.
	If a writer is waiting we need to figure out if we're
	the last reader to leave, in which case we wake the writer !

Arguments :
	
	None.

Return Value :

	None.


--*/

	TraceFunctEnter("CShareLockNH::ShareLockInternal") ;

#if 0
	//
	//	This portion of the function is moved into an inline function !
	//
	if( InterlockedDecrement( &m_cReadLock ) < 0 ) {
#endif

		//
		//	There is a writer waiting to enter the lock,
		//	(we assume he's waiting because the thread calling
		//	this presumably had a readlock !)
		//

		//
		//	Restore the count of the number of readers who are
		//	waiting for the writer to leave !
		//
		long	result = InterlockedIncrement( (long*)&m_cReadLock ) ;

		DebugTrace( (DWORD_PTR)this, "result - %x", result ) ;

		//
		//	Are we the last reader to leave the lock ?
		//
		if( (result = InterlockedDecrement( (long*)&m_cOutReaders )) == 0 ) {

			//
			//	Yes, we were the last reader - signal the writer !
			//
			long	junk ;
			ReleaseSemaphore( m_hWaitingWriters, 1, &junk ) ;

			DebugTrace( (DWORD_PTR)this, "ReleaseSemaphore - result %x junk %x", result, junk ) ;

		}
#if 0
	}
#endif
}

void
CShareLockNH::ExclusiveLock( )	{
/*++

Routine Description :

	Acquire the reader/writer lock exclusively.
	Note that we must set up the handle we are to block on if readers
	are in the lock, and clear it up when we leave !

Arguments :
	
	None.

Return Value :

	None.

--*/


	TraceFunctEnter("CShareLockNH::ExclusiveLock") ;

	CWaitingThread	myself ;

	//
	//	Only one writer in here at a time - grab this lock exclusively !
	//
	m_lock.Enter( myself ) ;

	//
	//	Number of references to the Exclusive Lock !
	//	This needs to get decremented down to 0 before m_lock.Leave() is called !
	//
	m_cExclusiveRefs = 1 ;

	//
	//	Everytime m_cOutCounter is used, by the time anybody is done with
	//	it, it should be back to zero !
	//
	_ASSERT( m_cOutReaders == 0 ) ;

	//
	//	Set this handle before we do anything to signal readers
	//	that we are waiting
	//
	m_hWaitingWriters = myself.GetThreadHandle() ;

	long	oldsign = InterlockedExchange( (long*)&m_cReadLock, BlockValue ) ;

	//
	//	oldsign now contains the number of readers who have entered the
	//	lock and have not yet left it !
	//

	//
	//	Do this as an add, to determine how many readers are still left !
	//

	long	value = InterlockedExchangeAdd( (long*)&m_cOutReaders, oldsign ) + oldsign ;
	_ASSERT( value >= 0 ) ;

	DebugTrace( (DWORD_PTR)this, "oldsign %x value %x", oldsign, value ) ;

	//
	//	If value is 0, either there was no readers in the lock when we
	//	exchanged with m_cReadLock, or they all left (and decremented m_cOutCounter)
	//	before we managed to call InterlockedExchangeAdd !!
	//
	if( value != 0 ) {
		//
		//	A reader will have to signal us !
		//
		WaitForSingleObject( m_hWaitingWriters, INFINITE ) ;
	}
	
	//
	//	There are no longer any writers waiting so no need for this handle !
	//
	m_hWaitingWriters = 0 ;
}


void	inline
CShareLockNH::WakeReaders()		{
/*++

Routine Description :

	This function awakens the readers who may have been waiting for the
	lock when a writer left the lock.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CShareLockNH::WakeReaders" ) ;

	DebugTrace( (DWORD_PTR)this, "m_cOutAcquiringReaders %x", m_cOutAcquiringReaders ) ;

	long	result;
	//
	//	If there were any readers waiting we need to wake them up !
	//
	if( m_cOutAcquiringReaders > 0 ) {

		//
		//	There are readers in the lock, but they may not have setup their
		//	blocking handle yet, so we take part in that !!!
		//
		CWaitingThread	myself ;

		//
		//	Get the handle we've saved for this thread !
		//
		HANDLE	h = myself.GetThreadHandle() ;

		//
		//	If we are the first thread to set the m_hWaitingReaders value we'll get
		//	a 0 back !
		//
		HANDLE	hBlockOn = InterlockedCompareExchangePointer( (void**)&m_hWaitingReaders, (void*)h, 0 ) ;

		if( hBlockOn == 0 ) {
			hBlockOn= h;
		}

		//
		//	Release those readers from the lock
		//
		ReleaseSemaphore( hBlockOn, m_cOutAcquiringReaders, &result ) ;

		//
		//	Our handle was left in the lock, we need to get rid of our
		//	reference to it, the last reader will return to the pool !
		//
		if( hBlockOn == h ) {
			myself.ClearHandle( h ) ;
		}

		//
		//	NOTE : All those readers we just woke up should decrement
		//	m_cOutCounter to 0 !!
		//
	}	else	{

		//
		//	we should decrement m_cExclusiveRefs back down to 0 before releasing !
		//
		if( (result = InterlockedDecrement( (long*)&m_cExclusiveRefs )) == 0 )
			m_lock.Leave() ;

		DebugTrace( (DWORD_PTR)this, "result %x", result ) ;

	}

}


void
CShareLockNH::ExclusiveUnlock()	{
/*++

Routine Description :

	Release our exclusive lock on the reader/writer lock.
	Note that we must get an accurate count of waiting readers
	so that the readers we awaken can manage the m_hWaitingReaders value.

Arguments :
	
	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CShareLockNH::ExclusiveUnlock" ) ;


	//
	//	Get the number of readers waiting to enter the lock !
	//	This Addition automatically leaves m_cReadLock with the number
	//	of readers who had been waiting !
	//
	m_cOutAcquiringReaders = InterlockedExchangeAdd( (long*)&m_cReadLock, -BlockValue ) - BlockValue ;

	DebugTrace( (DWORD_PTR)this, "m_cOutAcquiringReaders %x", m_cOutAcquiringReaders ) ;

	WakeReaders() ;

	//
	//	Let other writers have a shot !!
	//
	//m_lock.Leave() ;
}

void
CShareLockNH::ExclusiveToShared()	{
/*++

Routine Description :

	Release our exclusive lock on the reader/writer lock, in exchange
	for a read lock.  This cannot fail !

Arguments :
	
	None.

Return Value :

	None.

--*/

	TraceFunctEnter("CShareLockNH::ExclusiveToShared" ) ;

	//
	//	Get the number of readers waiting to enter the lock !
	//	Note that we add one onto m_cReadLock for our hold on the reader lock,
	//	but we don't add this to m_cOutCounter, as the number of readers waiting is one smaller !
	//
	m_cOutAcquiringReaders = InterlockedExchangeAdd( (long*)&m_cReadLock, 1-BlockValue ) -BlockValue ;

	DebugTrace( (DWORD_PTR)this, "m_cOutAcquiringReaders %x", m_cOutAcquiringReaders ) ;

	WakeReaders() ;
	
}

BOOL
CShareLockNH::SharedToExclusive()	{
/*++

Routine Description :
	
	If there is only one reader in the lock, (and therefore we assume
	that reader is the calling thread), acquire the lock exclusive !!

Arguments :

	None.

Return Value :

	TRUE if we acquired it exclusive
	If we return FALSE, we still have the lock shared !!


--*/

	TraceFunctEnter("CShareLockNH::SharedToExclusive" ) ;

	//
	//	Try to get the critical section first !
	//
	if( m_lock.TryEnter() ) {

		//
		//	If there is only one reader in the lock we can get this exclusive !!
		//
		if( InterlockedCompareExchange( (long*)&m_cReadLock, BlockValue, 1 ) == 1 ) {
			//
			//	Since we got the lock must set this to 1
			//
			m_cExclusiveRefs = 1 ;

			DebugTrace( (DWORD_PTR)this, "m_cExclusiveRefs 1" ) ;
			
			return	TRUE ;
		}
		m_lock.Leave() ;

	}
	return	FALSE ;
}

BOOL
CShareLockNH::TryShareLock()	{
/*++

Routine Description :

	Get the lock shared if nobody else is in the lock

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter("CShareLockNH::TryShareLock") ;

	//
	//	get the initial number of readers in the lock !
	//
	long	temp = m_cReadLock ;

	while( temp >= 0 ) {

		long	result = InterlockedCompareExchange(
								(long*)&m_cReadLock,
								(temp+1),	
								temp
								) ;

		DebugTrace( (DWORD_PTR)this, "result - %x", result ) ;
		//
		//	Did we manage to add 1 ?
		//
		if( result == temp ) {
			return	TRUE ;
		}
		temp = result ;
	}
	//
	//	Writer has or wants the lock - we should go away !
	//
	return	FALSE ;
}

BOOL
CShareLockNH::TryExclusiveLock()	{
/*++

Routine Description :

	Get the lock exclusively if nobody else is in the lock

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter("CShareLockNH::TryExclusiveLock") ;

	//
	//
	//

	if( m_lock.TryEnter()	)	{

		if( InterlockedCompareExchange( (long*)&m_cReadLock,
										BlockValue,
										0 ) == 0 ) {
			//
			//	Since we got the lock must set this to 1
			//
			DebugTrace( (DWORD_PTR)this, "m_cExlusiveRefs - 1" ) ;

			m_cExclusiveRefs = 1 ;
			return	TRUE;
		}
		m_lock.Leave() ;
	}
	return	FALSE ;
}

void
CShareLockNH::PartialLock()	{
/*++

Routine Description :

	Grab a partial lock.  All other PartialLock() or ExclusiveLock()
	threads will block for as long as we hold the PartialLock().

Arguments :

	None.

Return Value :

	none

--*/

	TraceFunctEnter("CShareLockNH::PartialLock") ;


	CWaitingThread	myself ;

	//
	//	Only one writer in here at a time - grab this lock exclusively !
	//
	m_lock.Enter( myself ) ;

	//
	//	This needs to decrement down to 0 before releasing m_lock !
	//
	m_cExclusiveRefs = 1 ;

	DebugTrace( (DWORD_PTR)this, "m_cExlusiveRefs - 1" ) ;

}


void
CShareLockNH::PartialUnlock()	{
/*++

Routine Description :

	Releases the partial lock.  Anybody else can enter !

Arguments :

	None.

Return Value :

	none

--*/

	TraceFunctEnter("CShareLockNH::PartialUnlock") ;

	//
	//	we should decrement m_cExclusiveRefs back down to 0 before releasing !
	//
	long	result ;
	if( (result = InterlockedDecrement( (long*)&m_cExclusiveRefs )) == 0 )
		m_lock.Leave() ;

	DebugTrace( (DWORD_PTR)this,"result - %x", result ) ;
}

void
CShareLockNH::FirstPartialToExclusive()	{
/*++

Routine Description :

	Changes the partial lock to an Exclusive Lock.
	Basically, we complete the Exclusive Locking protocol
	that is found in Exclusive Lock.

Arguments :

	None.

Return Value :

	none

--*/

	TraceFunctEnter("CShareLockNH::FirstPartialToExclusive") ;

	CWaitingThread	myself ;

	//
	//	Everytime m_cOutCounter is used, by the time anybody is done with
	//	it, it should be back to zero !
	//
	_ASSERT( m_cOutReaders == 0 ) ;

	//
	//	Set this handle before we do anything to signal readers
	//	that we are waiting
	//
	m_hWaitingWriters = myself.GetThreadHandle() ;

	long	oldsign = InterlockedExchange( (long*)&m_cReadLock, BlockValue ) ;

	//
	//	oldsign now contains the number of readers who have entered the
	//	lock and have not yet left it !
	//

	//
	//	Do this as an add, to determine how many readers are still left !
	//

	long	value = InterlockedExchangeAdd( (long*)&m_cOutReaders, oldsign ) + oldsign ;
	_ASSERT( value >= 0 ) ;

	DebugTrace( (DWORD_PTR)this,"oldsign %x value %x", oldsign, value ) ;

	//
	//	If value is 0, either there was no readers in the lock when we
	//	exchanged with m_cReadLock, or they all left (and decremented m_cOutCounter)
	//	before we managed to call InterlockedExchangeAdd !!
	//
	if( value != 0 ) {
		//
		//	A reader will have to signal us !
		//
		WaitForSingleObject( m_hWaitingWriters, INFINITE ) ;
	}
	
	//
	//	There are no longer any writers waiting so no need for this handle !
	//
	m_hWaitingWriters = 0 ;
}

BOOL
CShareLockNH::PartialToExclusive()	{
/*++

Routine Description :

	Changes the partial lock to an Exclusive Lock.
	Basically, we would like to complete the Exclusive Locking protocol
	that is found in Exclusive Lock, however its more complicated
	than that because if we convert between Partial and Exclusive Locks
	several times we have windows where reader threads are going after
	the m_hWaitingReaders semaphore that could get messed up..

Arguments :

	None.

Return Value :

	FALSE always, becase we are NYI

--*/

	return	FALSE ;
}

void
CShareLockNH::ExclusiveToPartial()	{
/*++

Routine Description :

	Changes the lock from being held Exclusively to being
	held Partially.

	Now this is complicated - because the ExclusiveUnlock() protocol
	which we want to execute needs to have Reader's releasing the
	CritSection used to hold Exclusive and Partial locks.

Arguments :

	None.

Return Value :

	FALSE always, becase we are NYI

--*/

	TraceFunctEnter("CShareLockNH::ExclusiveToPartial") ;

	long result = InterlockedIncrement( (long*)&m_cExclusiveRefs ) ;

	//
	//	Get the number of readers waiting to enter the lock !
	//	Note that we add one onto m_cReadLock for our hold on the reader lock,
	//	but we don't add this to m_cOutCounter, as the number of readers waiting is one smaller !
	//
	m_cOutAcquiringReaders = InterlockedExchangeAdd( (long*)&m_cReadLock, -BlockValue ) -BlockValue ;

	DebugTrace( (DWORD_PTR)this, "result %x m_cOutAcquiringReaders %x", result, m_cOutAcquiringReaders ) ;

	WakeReaders() ;

}

void
CShareLockNH::PartialToShared()	{
/*++

Routine Description :

	Since we never really blocked readers from entering this
	is pretty trivial - just add ourselves to the number of
	readers in the lock and release the crit sect.

Arguments :

	None.

Return Value :

	None.

++*/

	TraceFunctEnter("CShareLockNH::PartialToShared") ;

	long	l = InterlockedIncrement( (long*)&m_cReadLock ) ;
	_ASSERT( l>= 0 ) ;

	//
	//	we should decrement m_cExclusiveRefs back down to 0 before releasing !
	//
	long	result ;
	if( (result = InterlockedDecrement( (long*)&m_cExclusiveRefs )) == 0 )
		m_lock.Leave() ;

	DebugTrace( (DWORD_PTR)this, "l %x result %x", l, result ) ;

}

BOOL
CShareLockNH::SharedToPartial()	{
/*++

Routine Description :

	We don't care if other readers are already in the lock -
	just go after the critical section !

Arguments :

	None.

Return Value :

	TRUE if we get a partial Lock !

++*/

	TraceFunctEnter("CShareLockNH::SharedToPartial") ;

	//
	//	Try to get the critical section first !
	//
	if( m_lock.TryEnter() ) {
		//
		//	One less reader - note there are no writers waiting some number
		//	must come back positive !
		//
		long l = InterlockedDecrement( (long*)&m_cReadLock ) ;
		_ASSERT( l>= 0 ) ;

		//
		//	This needs to decrement down to 0 before releasing m_lock !
		//
		long result = InterlockedIncrement( (long*)&m_cExclusiveRefs ) ;
		DebugTrace( (DWORD_PTR)this, "l %x result %x", l, result ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CShareLockNH::TryPartialLock()	{
/*++

Routine Description :

	We don't care if other readers are already in the lock -
	just go after the critical section !

Arguments :

	None.

Return Value :

	TRUE if we manage to get a Partial Lock

++*/

	TraceFunctEnter("CShareLockNH::TryPartialLock") ;

	if( m_lock.TryEnter() ) {
		//
		//	This needs to decrement down to 0 before releasing m_lock !
		//
		m_cExclusiveRefs = 1 ;
		DebugTrace( (DWORD_PTR)this, "m_cExlusiveRefs %x", m_cExclusiveRefs ) ;
		return	TRUE ;
	}
	return	FALSE ;
}


void*
operator	new( size_t size,	DWORD*	pdw )	{
	return	LPVOID(pdw) ;
}


CShareLockExport::CShareLockExport()	{
	m_dwSignature = SIGNATURE ;
	new( m_dwReserved )	CShareLockNH() ;
}

CShareLockExport::~CShareLockExport()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->CShareLockNH::~CShareLockNH() ;
}

void
CShareLockExport::ShareLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ShareLock() ;
}

void
CShareLockExport::ShareUnlock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ShareUnlock() ;
}

void
CShareLockExport::ExclusiveLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveLock() ;
}

void
CShareLockExport::ExclusiveUnlock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveUnlock() ;
}

void
CShareLockExport::ExclusiveToShared()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveToShared() ;
}

BOOL
CShareLockExport::SharedToExclusive()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->SharedToExclusive() ;
}

BOOL
CShareLockExport::TryShareLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->TryShareLock() ;
}

BOOL
CShareLockExport::TryExclusiveLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->TryExclusiveLock() ;
}
	

HANDLE
GetPerThreadEvent() {

    CWaitingThread  myself ;

    return  myself.GetThreadEvent() ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rwnh\utest\exe\rwnhtest.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	"dbgtrace.h"
#include	"rwex.h"
#include	"rwnhdll.h"


//
//	Array of DWORDs that is used to check for multiple threads entering the
//	lock simultaneously !
//
long	rgbProtect[8192] ;

//
//	Ini section used to get rwutest information
//
char g_szDefaultSectionName[] = "rwexe";
char *g_szSectionName = g_szDefaultSectionName;

//
//	Number of times the reader/writer tests go through their internal loops
//
int		g_cNumRWLoops = 16 ;

//
//	Number of times the reader/writer tests loop through their locks !
//
DWORD	g_cNumRWIterations = 100000 ;

//
//	Number of threads doing the reader/writer locks !
//
DWORD	g_cNumRWThreads = 16 ;

//
//	Number of seconds before unloading and reloading the DLL !
//
DWORD	g_cZapSeconds = 15 ;

//
//	Number of seconds between creating batches of extra test threads !
//
DWORD	g_cSpuriousSeconds = 10 ;

//
//	Number of Spurious Threads to create -
//
DWORD	g_cSpuriousThreads = 16 ;

//
//	Number of iterations to do in the spurious threads !
//
DWORD	g_cSpuriousIterations = 5 ;


//
//	Number of times the test thread spins around looking for entries
//	in the cache !
//
//DWORD	g_cNumThreadIterations = 10000 ;

//
//	String constants for retrieving values from .ini file !
//
#define INI_SECTIONNAME			"rwexe"
#define	INI_NUMRWTHREADS		"NumRWThreads"
#define	INI_NUMRWLOOPS			"NumRWLoops"
#define	INI_NUMRWITERATIONS		"NumRWIter"
#define	INI_ZAPSECONDS			"ZapSeconds"
#define	INI_SPURIOUSSECONDS		"SpuriousSeconds"
#define	INI_SPURIOUSTHREADS		"SpuriousThreads"
#define	INI_SPURIOUSITERATIONS	"SpuriousIter"

void usage(void) {
/*++

Routine Description :

	Print Usage info to command line user !

Arguments :

	None.

Return Value :

	None.

--*/
	printf("usage: rwexe.exe [<ini file>] [<ini section name>]\n"
		"  INI file keys (in section [%s]):\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    %s (default=%d)\n"
		"    This test basically executes several threads which will \n"
		"	 attempt all combinations of locks using a CShareLockNH structure\n",
		g_szSectionName,
		INI_NUMRWTHREADS,
		g_cNumRWThreads,
		INI_NUMRWLOOPS,
		g_cNumRWLoops,
		INI_NUMRWITERATIONS,
		g_cNumRWIterations,
		INI_ZAPSECONDS,
		g_cZapSeconds,
		INI_SPURIOUSSECONDS,
		g_cSpuriousSeconds,
		INI_SPURIOUSTHREADS,
		g_cSpuriousThreads,
		INI_SPURIOUSITERATIONS,
		g_cSpuriousIterations
		) ;
	exit(0);
}


int GetINIDword(
			char *szINIFile,
			char *szKey,
			DWORD dwDefault
			) {
/*++

Routine Description :

	Helper function which retrieves values from .ini file !

Arguments :

	szINIFile - name of the ini file
	szKey - name of the key
	dwDefault - default value for the parameter

Return Value :

	The value retrieved from the .ini file or the default !

--*/
	char szBuf[MAX_PATH];

	GetPrivateProfileString(g_szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

void parsecommandline(
			int argc,
			char **argv
			) {
/*++

Routine Description :

	Get the name of the .ini file and
	setup our test run !

Arguments :

	Command line parameters

Return Value :

	None - will exit() if the user has not
		properly configured the test !

--*/
	if (argc == 0)
		usage();

	if (argc != 1 || _stricmp(argv[0], "/help") == 0)
		usage(); 	// show help

	char *szINIFile = argv[0];

	if (argc == 2) char *g_szSectionName = argv[1];

	g_cNumRWThreads	=	GetINIDword( szINIFile,
									INI_NUMRWTHREADS,
									g_cNumRWThreads
									) ;

	g_cNumRWThreads = max( g_cNumRWThreads, 1 ) ;
	g_cNumRWThreads = min( g_cNumRWThreads, 64 ) ;

	g_cNumRWLoops	=	GetINIDword( szINIFile,
									INI_NUMRWLOOPS,
									g_cNumRWLoops
									) ;

	g_cNumRWIterations	=	GetINIDword( szINIFile,
									INI_NUMRWITERATIONS,
									g_cNumRWIterations
									) ;


	g_cZapSeconds	=	GetINIDword( szINIFile,
									INI_ZAPSECONDS,
									g_cZapSeconds
									) ;


	g_cSpuriousSeconds	=	GetINIDword( szINIFile,
									INI_SPURIOUSSECONDS,
									g_cSpuriousSeconds
									) ;


	g_cSpuriousThreads =	GetINIDword( szINIFile,
									INI_SPURIOUSTHREADS,
									g_cSpuriousThreads
									) ;

	g_cSpuriousThreads = min( g_cSpuriousThreads, 64 ) ;
	g_cSpuriousThreads = max( g_cSpuriousThreads, 1 ) ;

	g_cSpuriousIterations	=	GetINIDword( szINIFile,
									INI_SPURIOUSITERATIONS,
									g_cSpuriousIterations
									) ;

}


rwex::CShareLock	g_lock ;

HINSTANCE	g_hRwnhDLL = 0 ;
HANDLE	g_hShutdown = 0 ;

typedef	void	(*PINIT)( int, DWORD ) ;
typedef	DWORD	(*PTEST)( DWORD ) ;


PINIT	g_TestInit ;

PTEST	g_RWTestThread ;

void
InitFunctions()	{

	g_hRwnhDLL = LoadLibrary( "rwnhdll.dll" ) ;
	g_TestInit = (PINIT)GetProcAddress( g_hRwnhDLL, "_TestInit@8" ) ;
	g_RWTestThread = (PTEST)GetProcAddress( g_hRwnhDLL, "_RWTestThread@4" ) ;

	g_TestInit( g_cNumRWLoops,
				2
				) ;

}



DWORD	WINAPI
ZapThread(	LPVOID	lpv	)	{
/*++

Routine Description :

	This function periodically unloads the DLL.
	We do this to test Process Attach and Detach code in rwnh.dll.

Arguments :

	a pointer to the lock to grab

Return Value :

	Nothing meaningfull !

--*/


	for( ; ; ) {

		DWORD	dwWait = WaitForSingleObject( g_hShutdown, g_cZapSeconds * 1000 ) ;

		if( dwWait == WAIT_OBJECT_0 ) {
			break ;
		}


		g_lock.ExclusiveLock() ;

		FreeLibrary( g_hRwnhDLL ) ;

		Sleep( 1500 ) ;

		InitFunctions() ;

		g_lock.ExclusiveUnlock() ;

	}
	return	0 ;
}



DWORD	WINAPI
RWNHTestThread(	LPVOID	lpv	)	{
/*++

Routine Description :

	This thread tests the CShareLock several ways, by acquiring the locks
	in different ways and then performing various operations.

Arguments :

	Nothing significant.

Return Value :

	Nothing meaningfull.

--*/

	DWORD	cNumRWIterations = (DWORD)((DWORD_PTR)lpv);

	for( DWORD i=0; i<cNumRWIterations; i++ ) {

		g_lock.ShareLock() ;

		g_RWTestThread( i ) ;

		g_lock.ShareUnlock() ;

	}
	return	0 ;
}


DWORD	WINAPI
SpuriousThread(	LPVOID	lpv	)	{
/*++

Routine Description :

	This function periodically spawns a bunch of extra threads which
	do a bunch of operations and then go away.

	This tests the ThreadAttach, Detach code paths.

Arguments :

	a pointer to the lock to grab

Return Value :

	Nothing meaningfull !

--*/


	for( ; ; ) {

		DWORD	dwWait = WaitForSingleObject( g_hShutdown, g_cSpuriousSeconds * 1000 ) ;

		if( dwWait == WAIT_OBJECT_0 ) {
			break ;
		}

		DWORD	dwJunk ;
		HANDLE	rgh[64] ;
		for( DWORD i=0; i < g_cSpuriousThreads; i++ ) {
			rgh[i] = CreateThread(	0,
											0,
											RWNHTestThread,
											(LPVOID)(SIZE_T)g_cSpuriousIterations,
											0,
											&dwJunk
											) ;
			if( rgh[i] == 0 )
				break ;
		}
		WaitForMultipleObjects( i, rgh, TRUE, INFINITE ) ;

		for( ; (int)i >= 0; i-- ) {
			CloseHandle( rgh[i] ) ;
		}
	}
	return	0 ;
}




int	__cdecl
main( int argc, char* argv[] ) {

	InitAsyncTrace() ;

	parsecommandline( --argc, ++argv ) ;

	char	szBogus[100] ;
	wsprintf( szBogus, "Force User32.dll to be loaded to prevent it from leaking\n" ) ;


	DWORD	dwJunk ;

	g_hShutdown = CreateEvent( 0, FALSE, FALSE, 0 ) ;

	InitFunctions() ;

	HANDLE	rgh[64] ;
	for( DWORD i=0; i<g_cNumRWThreads; i++ ) {

		rgh[i] = CreateThread(	0,
										0,
										RWNHTestThread,
										(LPVOID)(SIZE_T)g_cNumRWIterations,
										0,
										&dwJunk
										) ;

	}
#if 0
	HANDLE	hZap = CreateThread(	0,
									0,
									ZapThread,
									0,
									0,
									&dwJunk ) ;


	HANDLE	hSpurious  = CreateThread(	0,
									0,
									SpuriousThread,
									0,
									0,
									&dwJunk ) ;


#endif
	WaitForMultipleObjects( i, rgh, TRUE, INFINITE ) ;

	SetEvent( g_hShutdown ) ;

#if 0
	WaitForSingleObject( hZap, INFINITE ) ;
	WaitForSingleObject( hSpurious, INFINITE ) ;
#endif

	TermAsyncTrace() ;

	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\hack.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\dispatch.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	dispatch.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Dispatcher service.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	11/26/96	created

--*/


#include "stdafx.h"
#include "seo.h"
#include "dispatch.h"


class CDictItemNameList {
	public:
		CDictItemNameList(ISEODictionary *piFrom);
		~CDictItemNameList();
	public:
		DWORD m_dwCount;
		CComVariant *m_aNames;
};


static HRESULT ReallocCComVariant(CComVariant **ppBase,
								  DWORD dwBaseCnt,
								  DWORD dwNewBaseCnt) {
	CComVariant *pNew = NULL;

	if (dwBaseCnt == dwNewBaseCnt) {
		return (S_OK);
	}
	if (!dwNewBaseCnt) {
		delete[] *ppBase;
		*ppBase = NULL;
		return (S_OK);
	}
	ATLTRY(pNew = new CComVariant[dwNewBaseCnt];)
	_ASSERTE(pNew);
	if (!pNew) {
		return (E_OUTOFMEMORY);
	}
	for (DWORD dwIdx=0;(dwIdx<dwBaseCnt)&&(dwIdx<dwNewBaseCnt);dwIdx++) {
		pNew[dwIdx].Attach(&(*ppBase)[dwIdx]);
	}
	delete[] *ppBase;
	*ppBase = pNew;
	return (S_OK);
}


static HRESULT ReallocCComVariant(CComVariant **ppBase,
								  DWORD dwBaseCnt,
								  CComVariant *pAdd,
								  DWORD dwAddCnt) {
	HRESULT hrRes;

	hrRes = ReallocCComVariant(ppBase,dwBaseCnt,dwBaseCnt+dwAddCnt);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (DWORD dwIdx=0;dwIdx<dwAddCnt;dwIdx++) {
		(*ppBase)[dwIdx+dwBaseCnt].Attach(&pAdd[dwIdx]);
	}
	return (S_OK);
}


CDictItemNameList::CDictItemNameList(ISEODictionary *piFrom) {
	HRESULT hrRes;

	m_dwCount = 0;
	m_aNames = NULL;
	if (piFrom) {
		CComPtr<IUnknown> pUnkEnum;

		hrRes = piFrom->get__NewEnum(&pUnkEnum);
		if (SUCCEEDED(hrRes)) {
			CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pevEnum(pUnkEnum);

			if (pevEnum) {
				while (1) {
					CComVariant aNew[20];
					DWORD dwCnt;

					hrRes = pevEnum->Next(sizeof(aNew)/sizeof(aNew[0]),aNew,&dwCnt);
					if (!SUCCEEDED(hrRes)) {
						break;
					}
					if (!dwCnt) {
						break;
					}
					hrRes = ReallocCComVariant(&m_aNames,m_dwCount,aNew,dwCnt);
					if (!SUCCEEDED(hrRes)) {
						break;
					}
					for (DWORD dwIdx=0;dwIdx<dwCnt;dwIdx++) {
						hrRes = m_aNames[dwIdx+m_dwCount].ChangeType(VT_BSTR);
						_ASSERTE(SUCCEEDED(hrRes));
						if (!SUCCEEDED(hrRes)) {
							// Ack!  Ok - just drop this name off the list by moving the last name
							// on the list to this position, and fiddling the indexes so that we
							// attemp to convert this position again.
							if (dwIdx<dwCnt-1) {
								m_aNames[dwIdx+m_dwCount].Attach(&m_aNames[dwCnt+m_dwCount-1]);
							}
							dwIdx--;
							dwCnt--;
						}
					}
					m_dwCount += dwCnt;
				}
			}
		}
	}
}


CDictItemNameList::~CDictItemNameList() {

	delete[] m_aNames;
	m_dwCount = 0;
	m_aNames = NULL;
}


CSEOBaseDispatcher::CSEOBaseDispatcher() {

	m_apbBindings = NULL;
	m_dwBindingsCount = 0;
}


CSEOBaseDispatcher::~CSEOBaseDispatcher() {

	while (m_dwBindingsCount) {
		delete m_apbBindings[--m_dwBindingsCount];
	}
	delete[] m_apbBindings;
	m_apbBindings = NULL;
}


HRESULT STDMETHODCALLTYPE CSEOBaseDispatcher::SetContext(ISEORouter *piRouter, ISEODictionary *pdictBP) {
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictBindings;

	_ASSERT(!m_dwBindingsCount&&!m_apbBindings);
	hrRes = pdictBP->GetInterfaceA(BD_BINDINGS,IID_ISEODictionary,(IUnknown **) &pdictBindings);
	if (SUCCEEDED(hrRes)) {
		CDictItemNameList dinlBindings(pdictBindings);

		if (dinlBindings.m_dwCount) {
			m_apbBindings = new CBinding *[dinlBindings.m_dwCount];
			if (!m_apbBindings) {
				return (E_OUTOFMEMORY);
			}
			memset(m_apbBindings,0,sizeof(CBinding *)*dinlBindings.m_dwCount);
			for (m_dwBindingsCount=0;m_dwBindingsCount<dinlBindings.m_dwCount;m_dwBindingsCount++) {
				CComPtr<ISEODictionary> pdictBinding;

				pdictBinding.Release();
				hrRes = pdictBindings->GetInterfaceW(dinlBindings.m_aNames[m_dwBindingsCount].bstrVal,
													 IID_ISEODictionary,
													 (IUnknown **) &pdictBinding);
				_ASSERT(SUCCEEDED(hrRes));
				if (SUCCEEDED(hrRes)) {
					hrRes = AllocBinding(pdictBinding,&m_apbBindings[m_dwBindingsCount]);
					_ASSERT(SUCCEEDED(hrRes));
				}
			}
			qsort(m_apbBindings,m_dwBindingsCount,sizeof(m_apbBindings[0]),comp_binding);
		}
	}
	if (SUCCEEDED(hrRes)) {
		m_piRouter = piRouter;
		m_pdictBP = pdictBP;
	}
	return (hrRes);
}


static HRESULT GetCLSIDFromBinding(LPCSTR pszCLSID,
								   LPCSTR pszProgID,
								   ISEODictionary *piBinding,
								   CLSID *pclsid) {
	HRESULT hrRes;
	CComVariant varTmp;

	if (!piBinding) {
		return (E_POINTER);
	}
	if (pszCLSID) {
		hrRes = piBinding->GetVariantA(pszCLSID,&varTmp);
		if (SUCCEEDED(hrRes)) {
			hrRes = varTmp.ChangeType(VT_BSTR);
			if (SUCCEEDED(hrRes)) {
				hrRes = CLSIDFromString(varTmp.bstrVal,pclsid);
				if (SUCCEEDED(hrRes)) {
					return (hrRes);
				}
			}
		}
		varTmp.Clear();
	}
	if (!pszProgID) {
		return (E_FAIL);	// tbd - come up with a better error code
	}
	hrRes = piBinding->GetVariantA(pszProgID,&varTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = varTmp.ChangeType(VT_BSTR);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CLSIDFromProgID(varTmp.bstrVal,pclsid);
	return (hrRes);
}


HRESULT CSEOBaseDispatcher::CBinding::Init(ISEODictionary *piBinding) {
	HRESULT hrRes;
	CComVariant varTmp;
	CLSID clsidTmp;

	if (!piBinding) {
		return (E_POINTER);
	}
	// Try to get the CLSID of the object - if an error occurs,
	// this binding is invalid.
	hrRes = GetCLSIDFromBinding(BD_OBJECT,BD_PROGID,piBinding,&m_clsidObject);
	if (!SUCCEEDED(hrRes)) {
		return (S_FALSE);
	}
	// From this point on, all errors are silently ignored - we
	// use default values if we can't get something from the binding
	// database.
	hrRes = piBinding->GetVariantA(BD_PRIORITY,&varTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = varTmp.ChangeType(VT_I4);
		if (SUCCEEDED(hrRes)) {
			m_dwPriority = (DWORD) varTmp.lVal;
		}
	}
	if (!SUCCEEDED(hrRes)) {
		// If the priority isn't set, default to "last".
		m_dwPriority = (DWORD) -1;
	}
	varTmp.Clear();
	m_piBinding = piBinding;
	// Try to get an instance of the rule engine.
	hrRes = GetCLSIDFromBinding(BD_RULEENGINE,NULL,piBinding,&clsidTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateInstance(clsidTmp,
								 NULL,
								 CLSCTX_ALL,
								 IID_ISEOBindingRuleEngine,
								 (LPVOID *) &m_piRuleEngine);
	}
	// See if the 'exclusive' flag has been set.
	m_bExclusive = FALSE;
	hrRes = piBinding->GetVariantA(BD_EXCLUSIVE,&varTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = varTmp.ChangeType(VT_BOOL);
		if (SUCCEEDED(hrRes)) {
			if (varTmp.boolVal) {
				m_bExclusive = TRUE;
			}
		} else {
			hrRes = varTmp.ChangeType(VT_I4);
			if (SUCCEEDED(hrRes)) {
				if (varTmp.lVal) {
					m_bExclusive = TRUE;
				}
			}
		}
	}
	varTmp.Clear();
	m_bValid = TRUE;
	return (S_OK);
}


int CSEOBaseDispatcher::CBinding::Compare(const CBinding& b) const {

	if (m_dwPriority == b.m_dwPriority) {
		return (0);
	} else {
		return ((m_dwPriority>b.m_dwPriority)?1:-1);
	}
}


HRESULT CSEOBaseDispatcher::AllocBinding(ISEODictionary *pdictBinding, CBinding **ppbBinding) {
	HRESULT hrRes;

	if (!ppbBinding) {
		return (E_POINTER);
	}
	*ppbBinding = new CBinding;
	if (!*ppbBinding) {
		return (E_OUTOFMEMORY);
	}
	hrRes = (*ppbBinding)->Init(pdictBinding);
	if (!SUCCEEDED(hrRes)) {
		delete *ppbBinding;
		*ppbBinding = NULL;
	}
	return (hrRes);
}


static int _cdecl comp_binding(const void *pv1, const void *pv2) {
	const CSEOBaseDispatcher::CBinding **ppb1 = (const CSEOBaseDispatcher::CBinding **) pv1;
	const CSEOBaseDispatcher::CBinding **ppb2 = (const CSEOBaseDispatcher::CBinding **) pv2;

	return ((*ppb1)->Compare(**ppb2));
}


HRESULT CSEOBaseDispatcher::Dispatch(CEventParams *pEventParams) {
	BOOL bObjectCalled = FALSE;
	HRESULT hrRes;

	for (DWORD dwIdx=0;dwIdx<m_dwBindingsCount;dwIdx++) {
		if (!m_apbBindings[dwIdx]->m_bValid) {
			continue;
		}
		if (m_apbBindings[dwIdx]->m_bExclusive && bObjectCalled) {
			continue;
		}
		hrRes = pEventParams->CheckRule(*m_apbBindings[dwIdx]);
		if (hrRes == S_OK) {
			hrRes = pEventParams->CallObject(*m_apbBindings[dwIdx]);
			if ((hrRes == SEO_S_DONEPROCESSING) || m_apbBindings[dwIdx]->m_bExclusive) {
				break;
			}
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\rwnh\utest\rwnhdll\rwnhdll.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	"dbgtrace.h"
#include	"rwnew.h"
#include	"rwexport.h"
#include	"rwnhdll.h"


struct	TestObject	{
	long			m_rgdwRWProtect[8129] ;
	long			m_rgdwPartial[8128] ;
	CShareLockNH	m_lock ;
} ;
	

//
//	Number of times the reader/writer tests go through their internal loops
//
int		g_cNumRWLoops = 16 ;

//
//	Number of times the reader/writer tests loop through their locks !
//
DWORD	g_cNumRWIterations = 100000 ;

//
//	Number of threads doing the reader/writer locks !
//
DWORD	g_cNumRWThreads = 16 ;

TestObject	g_rgTestObject[16] ;


void
TestEventFunction() {
    HANDLE  hEvent = GetPerThreadEvent() ;
    _ASSERT( hEvent != 0 ) ;
    SetEvent( hEvent ) ;
    DWORD dw= WaitForSingleObject( hEvent, 0 ) ;
    _ASSERT( dw == WAIT_OBJECT_0 ) ;
}


void
SharedLoop(	TestObject*	pTestObject	)	{
/*++

Routine Description : 

	This function executes while a read lock is held.
	We zoom through the array of protected longs, changing everything
	to 0x10101010.  We know that we must get either 0 or 0x10101010
	because ExclusiveLoop() resets to 0 when it exits, and other reader
	threads only set to 0x10101010.

Arguments : 

	None.

Return Value : 

	None.

--*/

	for( int	k=0; k<g_cNumRWLoops; k++ ) {
		for( int	j=0; j<sizeof(pTestObject->m_rgdwRWProtect)/sizeof(DWORD); j++ ) {
			long	result = InterlockedCompareExchange( 
												&pTestObject->m_rgdwRWProtect[j], 
												0x10101010, 
												0
												) ;

			_ASSERT( result == 0 || result == 0x10101010 ) ;
		}
	}
}


void
PartialLoop( TestObject*	pTestObject	)	{
/*++

Routine Description : 

	This function executes while the Partial Lock is held !
	Do the shared lock protocol = and then do the Partial() protocol !

Arguments : 

	None.

Return Value : 

	None.

--*/

	long	l = GetCurrentThreadId() ;

	for( int	k=0; k<g_cNumRWLoops; k++ ) {
		for( int	j=0; j<sizeof(pTestObject->m_rgdwRWProtect)/sizeof(DWORD); j++ ) {
			long	result = InterlockedCompareExchange( 
												&pTestObject->m_rgdwRWProtect[j], 
												0x10101010, 
												0
												) ;

			_ASSERT( result == 0 || result == 0x10101010 ) ;
		}
		for( j=0; j<sizeof(pTestObject->m_rgdwPartial)/sizeof(long); j++ )	{
			//
			//	reset entries to 0 - thats what partial lock people do !
			//
			long	result = InterlockedCompareExchange(
												&pTestObject->m_rgdwPartial[j], 
												l, 
												0
												) ;
			_ASSERT( result == 0 || result == l ) ;
		}
	}
	ZeroMemory( pTestObject->m_rgdwPartial, sizeof( pTestObject->m_rgdwPartial ) ) ;
}




void
ExclusiveLoop(	TestObject*	pTestObject	)	{
/*++

Routine Description : 

	This function is executed while we have an exclusive lock.
	We make one pass through the array changing everything to 
	0x000000ff. We know the old value must be 0 or 0x10101010 because
	a reader thread may have been last in the lock.
	
	After this, we spin through the array incrementing things.

Arguments : 

	None.

Return Value : 

	None.

--*/

	for( DWORD j=0; j<sizeof(pTestObject->m_rgdwRWProtect)/sizeof(DWORD); j++ ) {
		long	result = InterlockedExchange( 
											&pTestObject->m_rgdwRWProtect[j], 
											0x000000ff 
											) ;

		_ASSERT( result == 0 || result == 0x10101010 ) ;
	}

	long	l = GetCurrentThreadId() ;

	for( j=0; j<sizeof(pTestObject->m_rgdwPartial)/sizeof(long); j++ )	{
		//
		//	reset entries to 0 - thats what partial lock people do !
		//
		long	result = InterlockedCompareExchange(
											&pTestObject->m_rgdwPartial[j], 
											l, 
											0
											) ;
		_ASSERT( result == 0 ) ;
	}

	for( int	k=0; k<g_cNumRWLoops; k++ ) {
		for( DWORD j=0; j<sizeof(pTestObject->m_rgdwRWProtect)/sizeof(DWORD); j++ ) {
			long	result = InterlockedIncrement( &pTestObject->m_rgdwRWProtect[j] ) ;
			_ASSERT( (0xff + k + 1) == result )  ;
		}
		for( j=0; j<sizeof(pTestObject->m_rgdwPartial)/sizeof(long); j++ )	{
			//
			//	reset entries to 0 - thats what partial lock people do !
			//
			long	result = InterlockedCompareExchange(
												&pTestObject->m_rgdwPartial[j], 
												l, 
												0
												) ;
			_ASSERT( result == l ) ;
		}
	}

	ZeroMemory( pTestObject->m_rgdwRWProtect, sizeof( pTestObject->m_rgdwRWProtect ) ) ;
	ZeroMemory( pTestObject->m_rgdwPartial, sizeof( pTestObject->m_rgdwPartial ) ) ;
}


_RWNHDLL_INTERFACE_	
DWORD	
RWTestThread(	DWORD	iTestObject  )	{
/*++

Routine Description : 

	This thread tests the CShareLock several ways, by acquiring the locks
	in different ways and then performing various operations.

Arguments : 

	Nothing significant.

Return Value : 

	Nothing meaningfull.

--*/

	TestObject*	pTestObject = &g_rgTestObject[ iTestObject % 16 ] ;

	for( DWORD i=0; i<g_cNumRWIterations; i++ ) {

        TestEventFunction() ;

		//
		//	Attempt each of the different kinds of locks !
		//

		pTestObject->m_lock.ShareLock() ;

		SharedLoop( pTestObject ) ;

		if( pTestObject->m_lock.SharedToExclusive() ) {

			//printf( "Converted SharedToExclusive !!!\n" ) ;

			//
			//	Change everything in the array to another value - 
			//	note we already made one pass so everything must contain 0x10101010 !
			//
			for( int k=0; k<g_cNumRWLoops; k++ ) {
				for( int	j=0; j<sizeof(pTestObject->m_rgdwRWProtect)/sizeof(DWORD); j++ ) {
					long	result = InterlockedIncrement( &pTestObject->m_rgdwRWProtect[j] ) ;
					_ASSERT( result == (0x10101010 + k + 1) ) ;
				}
			}
			ZeroMemory( &pTestObject->m_rgdwRWProtect, sizeof( pTestObject->m_rgdwRWProtect ) ) ;

			//
			//	Now convert the lock to shared again !
			// 

			pTestObject->m_lock.ExclusiveToShared() ;

			SharedLoop( pTestObject ) ;

		}

		pTestObject->m_lock.ShareUnlock() ;

		if( pTestObject->m_lock.TryShareLock() ) {

			//printf( "Successfully tried for a shared lock\n" ) ;

			SharedLoop( pTestObject ) ;

			pTestObject->m_lock.ShareUnlock() ;

		}


		//
		//	Now lets try the Exclusive pass at the array !
		//

		if( pTestObject->m_lock.TryExclusiveLock() ) {

			//printf( "Tried for Exclusive and won\n" ) ;

			ExclusiveLoop(pTestObject ) ;

			pTestObject->m_lock.ExclusiveToShared() ;

			SharedLoop(pTestObject ) ;

			pTestObject->m_lock.ShareUnlock() ;

		}

		if( pTestObject->m_lock.TryExclusiveLock() ) {

			//printf( "Tried for Exclusive2 and won\n" ) ;

			ExclusiveLoop(pTestObject ) ;
	
			pTestObject->m_lock.ExclusiveUnlock() ;

		}
			
		pTestObject->m_lock.ExclusiveLock() ;

		ExclusiveLoop(pTestObject ) ;

		pTestObject->m_lock.ExclusiveToShared() ;

		SharedLoop(pTestObject ) ;

		pTestObject->m_lock.ShareUnlock() ;

		pTestObject->m_lock.ExclusiveLock() ;

		ExclusiveLoop(pTestObject ) ;

		pTestObject->m_lock.ExclusiveUnlock() ;			

		printf( "THREAD %x - PartialLock\n", GetCurrentThreadId() ) ;

		pTestObject->m_lock.PartialLock() ;
	
		PartialLoop( pTestObject ) ;

		pTestObject->m_lock.PartialUnlock() ;

		printf( "THREAD %x - TryPartialLock\n", GetCurrentThreadId() ) ;

		if( pTestObject->m_lock.TryPartialLock() ) {
			PartialLoop( pTestObject ) ;
			pTestObject->m_lock.PartialUnlock() ;
		}		

		pTestObject->m_lock.ExclusiveLock() ;

		ExclusiveLoop(pTestObject ) ;

		printf( "THREAD %x - ExclusiveToPartial\n", GetCurrentThreadId() ) ;

		pTestObject->m_lock.ExclusiveToPartial() ;

		PartialLoop(pTestObject ) ;

		pTestObject->m_lock.PartialUnlock() ;

		pTestObject->m_lock.PartialLock() ;

		PartialLoop(pTestObject ) ;

		printf( "THREAD %x - FirstPartialToExclusive - 1\n", GetCurrentThreadId() ) ;

		pTestObject->m_lock.FirstPartialToExclusive() ;

		ExclusiveLoop(pTestObject ) ;

		pTestObject->m_lock.ExclusiveUnlock() ;

		pTestObject->m_lock.PartialLock() ;

		PartialLoop(pTestObject ) ;

		printf( "THREAD %x - FirstPartialToExclusive - 2\n", GetCurrentThreadId() ) ;

		pTestObject->m_lock.FirstPartialToExclusive() ;

		ExclusiveLoop(pTestObject ) ;

		pTestObject->m_lock.ExclusiveToPartial() ;

		PartialLoop( pTestObject ) ;

		pTestObject->m_lock.PartialUnlock() ;

		pTestObject->m_lock.ShareLock() ;

		SharedLoop(pTestObject ) ;

		if( pTestObject->m_lock.SharedToPartial() ) {
			PartialLoop(pTestObject ) ;

			pTestObject->m_lock.FirstPartialToExclusive() ;
			ExclusiveLoop(pTestObject ) ;
			pTestObject->m_lock.ExclusiveToPartial() ;
			PartialLoop(pTestObject) ;
			pTestObject->m_lock.PartialToShared() ;
			SharedLoop(pTestObject ) ;
		}
		pTestObject->m_lock.ShareUnlock() ;
								

#if 0 
		pTestObject->m_lock.PartialLock() ;

		PartialLoop(pTestObject ) ;

		printf( "THREAD %x - FirstPartialToExclusive - 3\n", GetCurrentThreadId() ) ;

		pTestObject->m_lock.FirstPartialToExclusive() ;

		ExclusiveLoop(pTestObject ) ;

		pTestObject->m_lock.ExclusiveToPartial() ;

		PartialLoop( pTestObject ) ;

		pTestObject->m_lock.PartialToShared() ;

		SharedLoop(pTestObject ) ;

		if( pTestObject->m_lock.SharedToPartial() ) {
			PartialLoop(pTestObject ) ;

			pTestObject->m_lock.FirstPartialToExclusive() ;
			ExclusiveLoop(pTestObject ) ;
			pTestObject->m_lock.PartialToShared() ;
			SharedLoop(pTestObject ) ;
		}
		pTestObject->m_lock.ShareUnlock() ;
#endif
						
	}
	return	0 ;
}

_RWNHDLL_INTERFACE_	
void
TestInit(	int	cNumRWLoops, 
			DWORD	cNumRWIterations
			)	{

	for( int i=0; i<16; i++ ) {
		ZeroMemory( g_rgTestObject[i].m_rgdwRWProtect, sizeof( g_rgTestObject[i].m_rgdwRWProtect ) ) ;
		ZeroMemory( g_rgTestObject[i].m_rgdwPartial, sizeof( g_rgTestObject[i].m_rgdwPartial ) ) ;
	}

	g_cNumRWLoops = cNumRWLoops ;
	g_cNumRWIterations = cNumRWIterations ;

}


BOOL	WINAPI
DllEntryPoint( 
			HINSTANCE	hinstDll,	
			DWORD		dwReason,	
			LPVOID		lpvReserved ) {

	return	TRUE ;

}


BOOL	WINAPI
DllMain(	HANDLE	hInst,
			ULONG	dwReason,
			LPVOID	lpvReserve )	{

	return	DllEntryPoint( (HINSTANCE)hInst, dwReason, lpvReserve ) ;

}
	


#if 0 
int
main( int argc, char* argv[] ) {

	parsecommandline( --argc, ++argv ) ;

	ZeroMemory( rgbProtect, sizeof( rgbProtect ) ) ;

	rwex::CSymLock	lock ;

	HANDLE	rgh[64] ;

	for( DWORD i=0; i<g_cNumSymThreads; i+=2 ) {

		DWORD	dwJunk ;
		rgh[i] = CreateThread(	0,
										0,
										TestThread2,
										(LPVOID)&lock,	
										0, 
										&dwJunk
										) ;					

		rgh[i+1] = CreateThread(	0,
										0,
										TestThread1,
										(LPVOID)&lock,	
										0, 
										&dwJunk
										) ;	
	}

	HANDLE	rghRW[64] ;

	for( DWORD k=0; k<g_cNumRWThreads; k++ ) {

		DWORD	dwJunk ;

		rgh[i] = CreateThread(	0,
										0,
										RWTestThread,
										(LPVOID)0,	
										0, 
										&dwJunk
										) ;					

	}

	WaitForMultipleObjects( i, rgh, TRUE, INFINITE ) ;

	WaitForMultipleObjects( k, rghRW, TRUE, INFINITE ) ;

	return	0 ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\dispatch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	dispatch.h

Abstract:

	This module contains the class definition for the Server
	Extension Object Dispatcher service.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	12/04/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's
	dondu	03/14/97	Major rewrite
	dondu	03/31/97	Updated for ISEODispatcher::SetContext

--*/


/*
	Typical usage...

	class CMyDispatcher :
		public CSEOBaseDispatcher,
		public IMyDispatcher,
		public CComObjectRoot,
		public CCoClass<CMyDispatcher,CLSID_CCMyDispatcher> {

		DECLARE_PROTECT_FINAL_CONSTRUCT();

		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
									   L"MyDispatcher Class",
									   L"My.MyDispatcher.1",
									   L"My.MyDispatcher");

		DECLARE_GET_CONTROLLING_UNKNOWN();

		BEGIN_COM_MAP(CSEORouter)
			COM_INTERFACE_ENTRY(ISEODispatcher)
			COM_INTERFACE_ENTRY(IMyDispatcher)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)	// if free-threaded
		END_COM_MAP()

		// You implement this if you need to do something during init...
		HRESULT FinalConstruct() {
			// If you are free-threaded, you must at least do this.
			return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p));
		}

		// You implement this if you need to do something during term...
		void FinalRelease();

		// Private stuff
		class CMyEventParams : CEventParams {
			virtual HRESULT CheckRule(CBinding& bBinding);	// you have to implement this ...
			virtual HRESULT CallObject(CBinding& bBinding);	// ... and this too
			DWORD m_dwWhatever;			// these are your parameters which ...
			IUnknown *pUnkWhatever;		// ... you are going to pass to the sink
		};

		// You have to implement this.
		HRESULT CMyEventParams::CheckRule(CBinding& bBinding) {
			if (bBinding.m_piRuleEngine) {
				// call the external rule engine
			} else {
				// do internal rule evaluation
			}
			// return values are either S_OK to call the object, or anything else (usually
			// S_FALSE for no error) if not to call the object
			return (S_OK);
		}

		// And you have to implement this.
		HRESULT CMyEventParams::CallObject(CBinding& bBinding) {
			// use bBinding.clsidObject to create the object
			// QI for the interface you want
			// call the object
			return (S_OK);
		}

		// IMyDispatcher - this is your server-specific dispatcher interface
		// Do something like this...
		HRESULT STDMETHODCALLTYPE OnEvent(DWORD dwWhatever, IUnknown *pUnkWhatever) {
			CMyEventParams epParams;

			epParams.m_dwWhatever = dwWhatever;
			epParams.m_dwUnkWhatever = pUnkWhatever;
			return (Dispatch(&epParams));
		}

		// If you want to add stuff to the CBinding object, you can override
		// CSEOBaseDispatcher::AllocBinding, and use that function to allocate,
		// initialize, and return an object which is derived from CBinding.
		class CMyBinding : public CBinding {
			DWORD m_dwSomeNewProperty;
			HRESULT Init(ISEODictionary *piBinding) {
				// some custom init code
				return (S_OK);
			}
		};
		HRESULT AllocBinding(ISEODictionary *piBinding, CBinding **ppbBinding) {
			*ppbBinding = new CMyBinding;
			if (!*ppbBinding) {
				return (E_OUTOFMEMORY);
			}
			hrRes = ((CMyBinding *) (*ppbBinding))->Init(piBinding);
			if (!SUCCEEDED(hrRes)) {
				delete *ppbBinding;
				*ppbBinding = NULL;
			}
			return (hrRes);
		}

	};

*/


class CSEOBaseDispatcher : public ISEODispatcher {

	public:
		CSEOBaseDispatcher();
		virtual ~CSEOBaseDispatcher();
		class CBinding {
			public:
				CBinding() { m_bValid = FALSE; };
				virtual ~CBinding() {};
				HRESULT Init(ISEODictionary *piBinding);
				virtual int Compare(const CBinding& b) const;
			public:
				DWORD m_dwPriority;
				CComPtr<ISEODictionary> m_piBinding;
				CComPtr<ISEOBindingRuleEngine> m_piRuleEngine;
				BOOL m_bExclusive;
				CLSID m_clsidObject;
				BOOL m_bValid;
		};
		class CEventParams {
			public:
				virtual HRESULT CheckRule(CBinding& bBinding) = 0;
				virtual HRESULT CallObject(CBinding& bBinding) = 0;
		};
		virtual HRESULT Dispatch(CEventParams *pEventParams);

	public:
		// ISEODispatcher
		HRESULT STDMETHODCALLTYPE SetContext(ISEORouter *piRouter, ISEODictionary *pdictBP);

	protected:
		virtual HRESULT AllocBinding(ISEODictionary *pdictBinding, CBinding **ppbBinding);
		CComPtr<ISEORouter> m_piRouter;
		CComPtr<ISEODictionary> m_pdictBP;

	private:
		friend static int _cdecl comp_binding(const void *pv1, const void *pv2);
		CBinding **m_apbBindings;
		DWORD m_dwBindingsCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\events.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	events.h

Abstract:

	This module contains the definition for the Server
	Extension Objects Server Events classes.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	04/04/97	created

--*/


// events.h : Declaration of the Server Events classes

/////////////////////////////////////////////////////////////////////////////
// CEventDatabasePlugin
class ATL_NO_VTABLE CEventDatabasePlugin :
	public IEventDatabasePlugin
{
	// IEventDatabasePlugin
	public:
		HRESULT STDMETHODCALLTYPE get_Database(IEventPropertyBag **ppDatabase);
		HRESULT STDMETHODCALLTYPE put_Database(IEventPropertyBag *pDatabase);
		HRESULT STDMETHODCALLTYPE putref_Database(IEventPropertyBag **ppDatabase);
		HRESULT STDMETHODCALLTYPE get_Name(BSTR *pstrName);
		HRESULT STDMETHODCALLTYPE put_Name(BSTR strName);
		HRESULT STDMETHODCALLTYPE putref_Name(BSTR *pstrName);
		HRESULT STDMETHODCALLTYPE get_Parent(IEventPropertyBag **ppParent);
		HRESULT STDMETHODCALLTYPE put_Parent(IEventPropertyBag *pParent);
		HRESULT STDMETHODCALLTYPE putref_Parent(IEventPropertyBag **ppParent);

	protected:
		CComPtr<IEventPropertyBag> m_pDatabase;
		CComBSTR m_strName;
		CComPtr<IEventPropertyBag> m_pParent;
};


/////////////////////////////////////////////////////////////////////////////
// CEventManager
class ATL_NO_VTABLE CEventManager :
	public CComObjectRoot,
	public CComCoClass<CEventManager, &CLSID_CEventManager>,
	public IDispatchImpl<IEventManager, &IID_IEventManager, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventManager)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventManager Class",
								   L"Event.Manager.1",
								   L"Event.Manager");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventManager)
		COM_INTERFACE_ENTRY(IEventManager)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventManager)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventManager
	public:
		HRESULT STDMETHODCALLTYPE get_SourceTypes(IEventSourceTypes **ppSourceTypes);
		HRESULT STDMETHODCALLTYPE CreateSink(IEventBinding *pBinding,
											 IEventDeliveryOptions *pDeliveryOptions,
											 IUnknown **ppUnkSink);

	private:
		CComPtr<IEventLock> m_pLock;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventBindingManager
class ATL_NO_VTABLE CEventBindingManager :
	public CComObjectRoot,
	public CComCoClass<CEventBindingManager, &CLSID_CEventBindingManager>,
	public IDispatchImpl<IEventBindingManager, &IID_IEventBindingManager, &LIBID_SEOLib>,
	public CEventDatabasePlugin,
	public ISEOInitObject,
	public IConnectionPointContainerImpl<CEventBindingManager>,
	public CSEOConnectionPointImpl<CEventBindingManager, &IID_IEventNotifyBindingChange>,
	public CSEOConnectionPointImpl<CEventBindingManager, &IID_IEventNotifyBindingChangeDisp>,
	public IEventNotifyBindingChange,
	public IProvideClassInfo2Impl<&CLSID_CEventBindingManager,&IID_IEventNotifyBindingChangeDisp,&LIBID_SEOLib>,
	public IDispatchImpl<IEventBindingManagerCopier, &IID_IEventBindingManagerCopier, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventBindingManager)

	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventBindingManager Class",
								   L"Event.BindingManager.1",
								   L"Event.BindingManager");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventBindingManager)
		COM_INTERFACE_ENTRY(IEventBindingManager)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventBindingManager)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY(ISEOInitObject)
		COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
		COM_INTERFACE_ENTRY(IEventNotifyBindingChange)
		COM_INTERFACE_ENTRY(IProvideClassInfo2)
		COM_INTERFACE_ENTRY(IEventBindingManagerCopier)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	BEGIN_CONNECTION_POINT_MAP(CEventBindingManager)
		CONNECTION_POINT_ENTRY(IID_IEventNotifyBindingChange)
		CONNECTION_POINT_ENTRY(IID_IEventNotifyBindingChangeDisp)
	END_CONNECTION_POINT_MAP()

	// IEventBindingManager
	public:
		HRESULT STDMETHODCALLTYPE get_Bindings(BSTR pszEventType, IEventBindings **ppBindings);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	// ISEOInitObject (IPersistPropertyBag)
	public:
		HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);
		HRESULT STDMETHODCALLTYPE InitNew(void);
		HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog);
		HRESULT STDMETHODCALLTYPE Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

	// IEventNotifyBindingChange
	public:
		HRESULT STDMETHODCALLTYPE OnChange();

	// IEventBindingManagerCopier
	public:
		HRESULT STDMETHODCALLTYPE Copy(long lTimeout, IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE EmptyCopy(IEventBindingManager **ppBindingManager);

	// CSEOConnectionPointImpl<>
	public:
		void AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount);
		void UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount);

	private:
		typedef CSEOConnectionPointImpl<CEventBindingManager, &IID_IEventNotifyBindingChange> CP_ENBC;
		typedef CSEOConnectionPointImpl<CEventBindingManager, &IID_IEventNotifyBindingChangeDisp> CP_ENBCD;
		DWORD m_dwCPCookie;
		CComPtr<IConnectionPoint> m_pCP;
		CComBSTR m_strDatabaseManager;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventMetabaseDatabaseManager
class ATL_NO_VTABLE CEventMetabaseDatabaseManager :
	public CComObjectRoot,
	public CComCoClass<CEventMetabaseDatabaseManager, &CLSID_CEventMetabaseDatabaseManager>,
	public IDispatchImpl<IEventDatabaseManager, &IID_IEventDatabaseManager, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventMetabaseDatabaseManager)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventMetabaseDatabaseManager Class",
								   L"Event.MetabaseDatabaseManager.1",
								   L"Event.MetabaseDatabaseManager");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventMetabaseDatabaseManager)
		COM_INTERFACE_ENTRY(IEventDatabaseManager)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventDatabaseManager)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventDatabaseManager
	public:
		HRESULT STDMETHODCALLTYPE CreateDatabase(BSTR strPath, IUnknown **ppMonDatabase);
		HRESULT STDMETHODCALLTYPE EraseDatabase(BSTR strPath);
		HRESULT STDMETHODCALLTYPE MakeVServerPath(BSTR strService, long lInstance, BSTR *pstrPath);
		HRESULT STDMETHODCALLTYPE MakeVRootPath(BSTR strService, long lInstance, BSTR strRoot, BSTR *pstrPath);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventUtil
class ATL_NO_VTABLE CEventUtil :
	public CComObjectRoot,
	public CComCoClass<CEventUtil, &CLSID_CEventUtil>,
	public IDispatchImpl<IEventUtil, &IID_IEventUtil, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventUtil)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventUtil Class",
								   L"Event.Util.1",
								   L"Event.Util");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventUtil)
		COM_INTERFACE_ENTRY(IEventUtil)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventUtil)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventUtil
	public:
		HRESULT STDMETHODCALLTYPE DisplayNameFromMoniker(IUnknown *pUnkMoniker, BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE MonikerFromDisplayName(BSTR strDisplayName, IUnknown **ppUnkMoniker);
		HRESULT STDMETHODCALLTYPE ObjectFromMoniker(IUnknown *pUnkMoniker, IUnknown **ppUnkObject);
		HRESULT STDMETHODCALLTYPE GetNewGUID(BSTR *pstrGUID);
		HRESULT STDMETHODCALLTYPE CopyPropertyBag(IUnknown *pUnkInput, IUnknown **ppUnkOutput);
		HRESULT STDMETHODCALLTYPE CopyPropertyBagShallow(IUnknown *pUnkInput, IUnknown **ppUnkOutput);
		HRESULT STDMETHODCALLTYPE DispatchFromObject(IUnknown *pUnkObject, IDispatch **ppDispOutput);
		HRESULT STDMETHODCALLTYPE GetIndexedGUID(BSTR strGUID, long lIndex, BSTR *pstrResult);
		HRESULT STDMETHODCALLTYPE RegisterSource(BSTR strSourceType,
												 BSTR strSource,
												 long lInstance,
												 BSTR strService,
												 BSTR strVRoot,
												 BSTR strDatabaseManager,
												 BSTR strDisplayName,
												 IEventBindingManager **ppBindingManager);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventComCat
class ATL_NO_VTABLE CEventComCat :
	public CComObjectRoot,
	public CComCoClass<CEventComCat, &CLSID_CEventComCat>,
	public IDispatchImpl<IEventComCat, &IID_IEventComCat, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventComCat)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventComCat Class",
								   L"Event.ComCat.1",
								   L"Event.ComCat");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventComCat)
		COM_INTERFACE_ENTRY(IEventComCat)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventComCat)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventComCat
	public:
		HRESULT STDMETHODCALLTYPE RegisterCategory(BSTR pszCategory, BSTR pszDescription, long lcidLanguage);
		HRESULT STDMETHODCALLTYPE UnRegisterCategory(BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE RegisterClassImplementsCategory(BSTR pszClass, BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE UnRegisterClassImplementsCategory(BSTR pszClass, BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE RegisterClassRequiresCategory(BSTR pszClass, BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE UnRegisterClassRequiresCategory(BSTR pszClass, BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE GetCategories(SAFEARRAY **ppsaCategories);
		HRESULT STDMETHODCALLTYPE GetCategoryDescription(BSTR strCategory, long lcidLanguage, BSTR *pstrDescription);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventRouter
class ATL_NO_VTABLE CEventRouter :
	public CComObjectRoot,
	public CComCoClass<CEventRouter, &CLSID_CEventRouter>,
	public IEventRouter
{
	DEBUG_OBJECT_DEF(CEventRouter)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventRouter Class",
								   L"Event.Router.1",
								   L"Event.Router");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventRouter)
		COM_INTERFACE_ENTRY(IEventRouter)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventRouter
	public:
		HRESULT STDMETHODCALLTYPE get_Database(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE put_Database(IEventBindingManager *pBindingManager);
		HRESULT STDMETHODCALLTYPE putref_Database(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE GetDispatcher(REFIID iidEvent,
												REFIID iidDesired,
												IUnknown **ppUnkResult);
		HRESULT STDMETHODCALLTYPE GetDispatcherByCLSID(REFCLSID clsidDispatcher,
													   REFIID iidEvent,
													   REFIID iidDesired,
													   IUnknown **ppUnkResult);

		HRESULT STDMETHODCALLTYPE GetDispatcherByClassFactory(REFCLSID clsidDispatcher,
															  IClassFactory *piClassFactory,
															  REFIID iidEvent,
															  REFIID iidDesired,
															  IUnknown **ppUnkResult);

	private:
		CComPtr<IEventRouter> m_pRouter;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


EXTERN_C const CLSID CLSID_CEventServiceObject;


/////////////////////////////////////////////////////////////////////////////
// CEventServiceObject
class ATL_NO_VTABLE CEventServiceObject :
	public CComObjectRoot,
	public CComCoClass<CEventServiceObject, &CLSID_CEventServiceObject>,
	public IUnknown
{
	DEBUG_OBJECT_DEF(CEventServiceObject)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventServiceObject Class",
								   L"Event.ServiceObject.1",
								   L"Event.ServiceObject");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventServiceObject)
		COM_INTERFACE_ENTRY(IUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventNotifyBindingChange
	public:
		HRESULT STDMETHODCALLTYPE OnChange();

	private:
		CComQIPtr<IConnectionPointContainer,&IID_IConnectionPointContainer> m_pCPC;
		DWORD m_dwCookie;
		CComPtr<IUnknown> m_pSubObject;
		CComPtr<IUnknown> m_pUnkMetabase;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\events.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	events.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Objects Server Events classes.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	04/04/97	created

--*/


// events.cpp : Implementation of Server Events classes
#include "stdafx.h"
#include <new.h>
#include "seodefs.h"
#include "events.h"
#include "comcat.h"
#include "urlmon.h"
#include "seolib.h"


#include <initguid.h>
// {1EF08720-1E76-11d1-AA29-00AA006BC80B}
DEFINE_GUID(IID_ICreateSinkInfo, 0x1ef08720, 0x1e76, 0x11d1, 0xaa, 0x29, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);
class CCreateSinkInfo : public IUnknown {
	public:
		BOOL m_bInit;
		BOOL m_bEnabled;
		CComBSTR m_strSinkClass;
		CComPtr<IUnknown> m_pSink;
		CComPtr<IEventPropertyBag> m_pSinkProperties;
};


#define BD_DISPLAYNAME				L"DisplayName"
#define BD_BINDINGMANAGERMONIKER	L"BindingManagerMoniker"
#define BD_SOURCETYPES				L"SourceTypes"
#define BD_SOURCES					L"Sources"
#define BD_EVENTTYPES				L"EventTypes"
//#define BD_BINDINGS					L"Bindings"
#define BD_SINKCLASS				L"SinkClass"
#define BD_SINKPROPERTIES			L"SinkProperties"
#define BD_SOURCEPROPERTIES			L"SourceProperties"
#define BD_ENABLED					L"Enabled"
#define BD_EXPIRATION				L"Expiration"
#define BD_MAXFIRINGS				L"MaxFirings"


#define LOCK_TIMEOUT		15000
#define LOCK_TIMEOUT_SHORT	1000


class CLocker {
	public:
		CLocker(int iTimeout=LOCK_TIMEOUT) {
			m_hrRes = S_OK;
			m_iTimeout = iTimeout;
		};
		~CLocker() {
			Unlock();
		};
		HRESULT Lock(BOOL bWrite, IEventLock *pLock) {
			Unlock();
			m_bWrite = bWrite;
			m_pLock = pLock;
			if (m_pLock) {
				m_hrRes = m_bWrite ? m_pLock->LockWrite(m_iTimeout) : m_pLock->LockRead(m_iTimeout);
				if (!SUCCEEDED(m_hrRes)) {
					m_pLock.Release();
				}
			}
			return (m_hrRes);
		};
		HRESULT Lock(BOOL bWrite, IUnknown *pUnk) {
			CComQIPtr<IEventLock,&IID_IEventLock> pLock;

			if (pUnk) {
				pLock = pUnk;
			}
			return (Lock(bWrite,pLock));
		};
		HRESULT Unlock() {
			m_hrRes = S_OK;
			if (m_pLock) {
				m_hrRes = m_bWrite ? m_pLock->UnlockWrite() : m_pLock->UnlockRead();
				_ASSERTE(SUCCEEDED(m_hrRes));
			}
			m_pLock.Release();
			return (m_hrRes);
		}
		HRESULT LockWrite(IUnknown *pUnk) {
			return (Lock(TRUE,pUnk));
		};
		HRESULT LockRead(IUnknown *pUnk) {
			return (Lock(FALSE,pUnk));
		};
		HRESULT LockWrite(IEventLock *pLock) {
			return (Lock(TRUE,pLock));
		};
		HRESULT LockRead(IEventLock *pLock) {
			return (Lock(FALSE,pLock));
		};
		operator HRESULT() {
			return (m_hrRes);
		};
		
	private:
		CComPtr<IEventLock> m_pLock;
		BOOL m_bWrite;
		HRESULT m_hrRes;
		int m_iTimeout;
};


typedef HRESULT (*CreatorFunc)(LPVOID,REFIID,LPVOID *);


static HRESULT AddImpl1(BSTR pszName, CStringGUID& objGuid, CComVariant *pvarName) {

	if (!pvarName) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (pszName && *pszName) {
		objGuid = pszName;
		if (!objGuid) {
			return (E_INVALIDARG);
		}
	}
	if (!pszName || !*pszName || ((GUID&) objGuid == GUID_NULL)) {
		objGuid.CalcNew();
		if (!objGuid) {
			return (E_FAIL);
		}
	}
	*pvarName = (LPCOLESTR) objGuid;
	return (S_OK);
}


static HRESULT AddImpl2(IEventPropertyBag *pDatabase,
						CreatorFunc pfnCreator,
						REFIID iidDesired,
						CComVariant *pvarName,
						IUnknown **ppResult) {
	HRESULT hrRes;
	CComPtr<IEventDatabasePlugin> pPlugIn;
	CComPtr<IEventPropertyBag> pNewDatabase;

	if (ppResult) {
		*ppResult = NULL;
	}
	if (!pDatabase || !pfnCreator || !pvarName || (pvarName->vt != VT_BSTR)) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!ppResult) {
		return (E_POINTER);
	}
	hrRes = pfnCreator(NULL,IID_IEventDatabasePlugin,(LPVOID *) &pPlugIn);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pPlugIn);
	hrRes = pPlugIn->put_Name(pvarName->bstrVal);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pPlugIn->put_Parent(pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pNewDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewDatabase);
	hrRes = pPlugIn->put_Database(pNewDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pPlugIn->QueryInterface(iidDesired,(LPVOID *) ppResult);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppResult);
	return (hrRes);
}


static HRESULT CreateSubPropertyBag(IEventPropertyBag *pBase,
									VARIANT *pvarName,
									IEventPropertyBag **ppResult,
									BOOL bCreate) {
	HRESULT hrRes;
	CComVariant varValue;
	BOOL bTmpCreate = bCreate;

	if (ppResult) {
		*ppResult = NULL;
	}
	if (!ppResult || !pBase || !pvarName) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if ((pvarName->vt == VT_EMPTY) || ((pvarName->vt == VT_BSTR) && (SysStringLen(pvarName->bstrVal) == 0))) {
		*ppResult = pBase;
		(*ppResult)->AddRef();
		return (S_OK);
	}
again:
	hrRes = pBase->Item(pvarName,&varValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if ((hrRes == S_FALSE) && !bTmpCreate) {
		if (bCreate) {
			_ASSERTE(FALSE);
			return (E_FAIL);
		}
		return (S_FALSE);
	}
	hrRes = varValue.ChangeType(VT_UNKNOWN);
	if (!SUCCEEDED(hrRes)) {
		if (!bTmpCreate || (pvarName->vt != VT_BSTR)) {
			return (hrRes);
		}
		bTmpCreate = FALSE;
		varValue.Clear();
		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &varValue.punkVal);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (hrRes);
		}
		_ASSERTE(varValue.punkVal);
		varValue.vt = VT_UNKNOWN;
		hrRes = pBase->Add(pvarName->bstrVal,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		goto again;
	}
	hrRes = varValue.punkVal->QueryInterface(IID_IEventPropertyBag,(LPVOID *) ppResult);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppResult);
	return (hrRes);
}


static HRESULT SetName(IEventPropertyBag *pBase, VARIANT *pvarSubKey, IEventDatabasePlugin *pObject) {
	HRESULT hrRes;
	VARIANT varTmp;
	long lIndex;

	if (!pBase || !pvarSubKey || !pObject) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (pvarSubKey->vt == VT_BSTR) {
		if (!pvarSubKey->bstrVal || !*pvarSubKey->bstrVal) {
			return (E_INVALIDARG);
		}
		return (pObject->put_Name(pvarSubKey->bstrVal));
	}
	VariantInit(&varTmp);
	hrRes = VariantChangeType(&varTmp,pvarSubKey,0,VT_I4);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	lIndex = varTmp.lVal;
	VariantClear(&varTmp);
	hrRes = pBase->Name(lIndex,&varTmp.bstrVal);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	varTmp.vt = VT_BSTR;
	hrRes = pObject->put_Name(varTmp.bstrVal);
	VariantClear(&varTmp);
	return (hrRes);
}


static HRESULT CreatePluggedInObject(CreatorFunc pfnCreator,
									 IEventPropertyBag *pBase,
									 VARIANT *pvarSubKey,
									 REFIID iidDesired,
									 IUnknown **ppUnkResult,
									 BOOL bCreate) {
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pDatabase;
	CComPtr<IEventDatabasePlugin> pinitResult;

	if (ppUnkResult) {
		*ppUnkResult = NULL;
	}
	if (!ppUnkResult) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!pfnCreator || !pBase || !pvarSubKey) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CreateSubPropertyBag(pBase,pvarSubKey,&pDatabase,bCreate);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if ((hrRes == S_FALSE) && !bCreate) {
		return (S_FALSE);
	}
	hrRes = pfnCreator(NULL,IID_IEventDatabasePlugin,(LPVOID *) &pinitResult);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pinitResult);
	hrRes = pinitResult->put_Database(pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = SetName(pBase,pvarSubKey,pinitResult);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pinitResult->QueryInterface(iidDesired,(LPVOID *) ppUnkResult);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkResult);
	return (hrRes);
}


static HRESULT CopyPropertyBagShallow(IEventPropertyBag *pIn, IEventPropertyBag **ppOut, BOOL bLock=TRUE) {
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkEnum;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;
	CComPtr<IEventPropertyBag> pTmp;
	CLocker lckRead;
	CLocker lckWrite;

	if (!pIn || !ppOut) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!*ppOut) {
		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &pTmp);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (hrRes);
		}
		_ASSERTE(pTmp);
	} else {
		pTmp = *ppOut;
	}
	if (bLock) {
		if (!SUCCEEDED(lckRead.LockRead(pIn))) {
			if ((HRESULT) lckRead == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
				if (!*ppOut) {
					*ppOut = pTmp;
					(*ppOut)->AddRef();
				}
				return (S_OK);
			}
			return ((HRESULT) lckRead);
		}
		if (*ppOut && !SUCCEEDED(lckWrite.LockWrite(pTmp))) {
			return ((HRESULT) lckWrite);
		}
	}
	hrRes = pIn->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pUnkEnum);
	pEnum = pUnkEnum;
	if (!pEnum) {
		_ASSERTE(FALSE);
		return (E_NOINTERFACE);
	}
	while (1) {
		CComVariant varName;
		CComVariant varValue;

		varName.Clear();
		hrRes = pEnum->Next(1,&varName,NULL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varName.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERTE(varName.bstrVal);
		varValue.Clear();
		hrRes = pIn->Item(&varName,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERT(hrRes!=S_FALSE);
		hrRes = pTmp->Add(varName.bstrVal,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (!*ppOut) {
		*ppOut = pTmp;
		(*ppOut)->AddRef();
	}
	return (S_OK);
}


static HRESULT CopyPropertyBag(IEventPropertyBag *pIn, IEventPropertyBag **ppOut, BOOL bLock=TRUE, int iTimeout=LOCK_TIMEOUT) {
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkEnum;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;
	CComPtr<IEventPropertyBag> pTmp;
	CLocker lckRead(iTimeout);
	CLocker lckWrite(iTimeout);

	if (!pIn || !ppOut) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!*ppOut) {
		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &pTmp);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (hrRes);
		}
		_ASSERTE(pTmp);
	} else {
		pTmp = *ppOut;
	}
	if (bLock) {
		if (!SUCCEEDED(lckRead.LockRead(pIn))) {
			if ((HRESULT) lckRead == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
				if (!*ppOut) {
					*ppOut = pTmp;
					(*ppOut)->AddRef();
				}
				return (S_OK);
			}
			return ((HRESULT) lckRead);
		}
		if (*ppOut && !SUCCEEDED(lckWrite.LockWrite(pTmp))) {
			return ((HRESULT) lckWrite);
		}
	}
	hrRes = pIn->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pUnkEnum);
	pEnum = pUnkEnum;
	if (!pEnum) {
		_ASSERTE(FALSE);
		return (E_NOINTERFACE);
	}
	while (1) {
		CComVariant varName;
		CComVariant varValue;

		varName.Clear();
		hrRes = pEnum->Next(1,&varName,NULL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varName.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERTE(varName.bstrVal);
		varValue.Clear();
		hrRes = pIn->Item(&varName,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERT(hrRes!=S_FALSE);
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (SUCCEEDED(hrRes)) {
			CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pValue;

			pValue = varValue.punkVal;
			if (pValue) {
				varValue.Clear();
				varValue.punkVal = NULL;
				hrRes = CopyPropertyBag(pValue,(IEventPropertyBag **) &varValue.punkVal,FALSE);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				varValue.vt = VT_UNKNOWN;
			}
		}
		hrRes = pTmp->Add(varName.bstrVal,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (!*ppOut) {
		*ppOut = pTmp;
		(*ppOut)->AddRef();
	}
	return (S_OK);
}


static HRESULT SaveImpl(BSTR strName, CComPtr<IEventPropertyBag>& pDatabase, CComPtr<IEventPropertyBag>& pTmpDatabase, CComPtr<IEventPropertyBag>& pParent) {
	HRESULT hrRes;

	if (!strName) {
		return (E_POINTER);
	}
	if (!pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (pParent) {
		CComVariant varValue;

		if (!pTmpDatabase) {
			return (EVENTS_E_BADDATA);
		}
		varValue = pTmpDatabase;
		hrRes = pParent->Add(strName,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		pTmpDatabase.Release();
		pDatabase.Release();
		varValue.Clear();
		hrRes = pParent->Item(&CComVariant(strName),&varValue);
		pParent.Release();
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			return (E_FAIL);
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = varValue.punkVal->QueryInterface(IID_IEventPropertyBag,(LPVOID *) &pDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		return (S_OK);
	}
	if (!pTmpDatabase) {
		return (S_OK);
	}
	hrRes = CopyPropertyBagShallow(pTmpDatabase,&pDatabase.p);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pTmpDatabase.Release();
	return (S_OK);
}


static HRESULT NextOfUnknown(IUnknown *pUnkEnum,
							 IEventPropertyBag *pCollection,
							 IUnknown **apunkElt,
							 BSTR *astrNames,
							 ULONG celt,
							 ULONG *pceltFetched,
							 REFIID riidDesired) {
	CComQIPtr<IEnumString,&IID_IEnumString> pEnumString;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnumVARIANT;
	DWORD dwIdx;
	VARIANT *pvarTmp;
	DWORD dwTmpStored;
	HRESULT hrRes;

	if (pceltFetched) {
		*pceltFetched = 0;
	}
	if (apunkElt) {
		memset(apunkElt,0,sizeof(IUnknown *)*celt);
	}
	if (astrNames) {
		memset(astrNames,0,sizeof(BSTR)*celt);
	}
	if (!apunkElt || !astrNames) {
		_ASSERTE(FALSE);
		return (E_OUTOFMEMORY);
	}
	if (!pUnkEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!celt) {
		return (S_OK);
	}
	dwTmpStored = 0;
	pEnumString = pUnkEnum;
	if (!pEnumString) {
		pEnumVARIANT = pUnkEnum;
		if (!pEnumVARIANT) {
			return (E_NOINTERFACE);
		}
		pvarTmp = (VARIANT *) _alloca(sizeof(VARIANT)*celt);
		if (!pvarTmp) {
			return (E_OUTOFMEMORY);
		}
		memset(pvarTmp,0,sizeof(pvarTmp[0])*celt);
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			VariantInit(&pvarTmp[dwIdx]);
		}
	}
	while (dwTmpStored < celt) {
		DWORD dwTmpFetched;
		DWORD dwInnerTmpStored;
		HRESULT hrInnerRes;

		if (pEnumString) {
			hrRes = pEnumString->Next(celt-dwTmpStored,(LPWSTR *) &astrNames[dwTmpStored],&dwTmpFetched);
			if (SUCCEEDED(hrRes)) {
				for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
					BSTR strTmp;

					strTmp = SysAllocString(astrNames[dwIdx]);
					if (astrNames[dwIdx] && !strTmp) {
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(astrNames[dwIdx]);
					astrNames[dwIdx] = strTmp;
				}
			}
		} else {
			hrRes = pEnumVARIANT->Next(celt-dwTmpStored,&pvarTmp[dwTmpStored],&dwTmpFetched);
			if (SUCCEEDED(hrRes)) {
				for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
					hrInnerRes = VariantChangeType(&pvarTmp[dwTmpStored+dwIdx],
												   &pvarTmp[dwTmpStored+dwIdx],
												   0,
												   VT_BSTR);
					if (!SUCCEEDED(hrInnerRes)) {
						hrRes = hrInnerRes;
						break;
					}
					_ASSERTE(pvarTmp[dwTmpStored+dwIdx].bstrVal);
					astrNames[dwTmpStored+dwIdx] = pvarTmp[dwTmpStored+dwIdx].bstrVal;
					VariantInit(&pvarTmp[dwTmpStored+dwIdx]);
				}
				for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
					VariantClear(&pvarTmp[dwIdx]);
				}
			}
		}
		if (!SUCCEEDED(hrRes) || !dwTmpFetched) {
			break;
		}
		dwInnerTmpStored = 0;
		for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
			CComVariant varTmp;

			varTmp.Clear();
			hrRes = pCollection->Item(&CComVariant(astrNames[dwTmpStored+dwIdx]),&varTmp);
			if (!SUCCEEDED(hrRes)) {
				break;
			}
			hrInnerRes = varTmp.ChangeType(VT_UNKNOWN);
			if (SUCCEEDED(hrInnerRes)) {
				_ASSERTE(varTmp.punkVal);
				hrInnerRes = varTmp.punkVal->QueryInterface(riidDesired,
															(LPVOID *) &apunkElt[dwTmpStored+dwInnerTmpStored]);
			}
			_ASSERTE(!SUCCEEDED(hrInnerRes)||apunkElt[dwTmpStored+dwInnerTmpStored]);
			if (!SUCCEEDED(hrInnerRes)) {
				SysFreeString(astrNames[dwTmpStored+dwIdx]);
				memcpy(&astrNames[dwTmpStored+dwIdx],
					   &astrNames[dwTmpStored+dwIdx+1],
					   (dwTmpFetched-dwIdx-1)*sizeof(BSTR));
				memset(astrNames[dwTmpStored+dwTmpFetched-1],0,sizeof(BSTR));
				dwTmpFetched--;
				dwIdx--;
				dwInnerTmpStored--;
			}
			dwInnerTmpStored++;
		}
		dwTmpStored += dwInnerTmpStored;
	}
	if (!SUCCEEDED(hrRes)) {
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			SysFreeString(astrNames[dwIdx]);
			if (apunkElt[dwIdx]) {
				apunkElt[dwIdx]->Release();
				apunkElt[dwIdx] = NULL;
			}
		}
		return (hrRes);
	}
	if (pceltFetched) {
		*pceltFetched = dwTmpStored;
	}
	return ((dwTmpStored==celt)?S_OK:S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// IEventEnumBase
class ATL_NO_VTABLE IEventEnumBase
{
	public:
		virtual HRESULT SetEnum(IUnknown *punkEnum, IEventPropertyBag *pCollection) = 0;
		virtual IUnknown *GetEnum() = 0;
		virtual IEventPropertyBag *GetCollection() = 0;
		virtual HRESULT MakeNewObject(REFIID iidDesired, LPVOID *ppvObject) = 0;
		HRESULT BaseSkip(ULONG celt);
		HRESULT BaseReset();
};


HRESULT IEventEnumBase::BaseSkip(ULONG celt) {
	CComQIPtr<IEnumUnknown,&IID_IEnumUnknown> pEnumUnknown;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnumVARIANT;

	pEnumUnknown = GetEnum();
	if (pEnumUnknown) {
		return (pEnumUnknown->Skip(celt));
	}
	pEnumVARIANT = GetEnum();
	if (!pEnumVARIANT) {
		return (pEnumVARIANT->Skip(celt));
	}
	_ASSERTE(FALSE);
	return (E_NOINTERFACE);
}


HRESULT IEventEnumBase::BaseReset() {
	CComQIPtr<IEnumUnknown,&IID_IEnumUnknown> pEnumUnknown;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnumVARIANT;

	pEnumUnknown = GetEnum();
	if (pEnumUnknown) {
		return (pEnumUnknown->Reset());
	}
	pEnumVARIANT = GetEnum();
	if (!pEnumVARIANT) {
		return (pEnumVARIANT->Reset());
	}
	_ASSERTE(FALSE);
	return (E_NOINTERFACE);
}


/////////////////////////////////////////////////////////////////////////////
// CEventEnumUnknownBase
class ATL_NO_VTABLE CEventEnumUnknownBase :
	public IEventEnumBase,
	public IEnumUnknown
{
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, IUnknown **apunkElt, ULONG *pceltFetched);
		HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
		HRESULT STDMETHODCALLTYPE Reset();
		HRESULT STDMETHODCALLTYPE Clone(IEnumUnknown **ppEnum);
	protected:
		virtual HRESULT MakeNewEnumUnknown(IUnknown *pContained,
										   IEventPropertyBag *pCollection,
										   IEnumUnknown **ppNewEnum) = 0;
};


/////////////////////////////////////////////////////////////////////////////
// CEventEnumUnknownBase


HRESULT STDMETHODCALLTYPE CEventEnumUnknownBase::Next(ULONG celt, IUnknown **apunkElt, ULONG *pceltFetched) {
	HRESULT hrRes;
	IEventPropertyBag **ppTmp;
	BSTR *pstrTmp;
	DWORD dwTmpFetched;
	DWORD dwIdx;

	if (pceltFetched) {
		*pceltFetched = 0;
	}
	if (apunkElt) {
		memset(apunkElt,0,sizeof(IUnknown *)*celt);
	}
	if (!apunkElt) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!celt) {
		return (S_OK);
	}
	ppTmp = (IEventPropertyBag **) _alloca(sizeof(IEventPropertyBag *)*celt);
	pstrTmp = (BSTR *) _alloca(sizeof(BSTR)*celt);
	hrRes = NextOfUnknown(GetEnum(),
						  GetCollection(),
						  (IUnknown **) ppTmp,
						  pstrTmp,
						  celt,
						  &dwTmpFetched,
						  IID_IEventPropertyBag);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
		hrRes = MakeNewObject(IID_IEventDatabasePlugin,(LPVOID *) &apunkElt[dwIdx]);
		if (SUCCEEDED(hrRes)) {
			_ASSERTE(apunkElt[dwIdx]);
			hrRes = ((IEventDatabasePlugin *) apunkElt[dwIdx])->put_Database(ppTmp[dwIdx]);
			if (SUCCEEDED(hrRes)) {
				hrRes = ((IEventDatabasePlugin *) apunkElt[dwIdx])->put_Name(pstrTmp[dwIdx]);
			}
		}
		if (!SUCCEEDED(hrRes)) {
			for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
				if (apunkElt[dwIdx]) {
					apunkElt[dwIdx]->Release();
					apunkElt[dwIdx] = NULL;
				}
			}
			break;
		}
	}
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		SysFreeString(pstrTmp[dwIdx]);
		if (ppTmp[dwIdx]) {
			ppTmp[dwIdx]->Release();
		}
	}
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pceltFetched) {
		*pceltFetched = dwTmpFetched;
	}
	return ((dwTmpFetched<celt)?S_FALSE:S_OK);
}


HRESULT STDMETHODCALLTYPE CEventEnumUnknownBase::Skip(ULONG celt) {

	return (BaseSkip(celt));
}


HRESULT STDMETHODCALLTYPE CEventEnumUnknownBase::Reset() {

	return (BaseReset());
}


HRESULT STDMETHODCALLTYPE CEventEnumUnknownBase::Clone(IEnumUnknown **ppEnum) {
	HRESULT hrRes;
	CComQIPtr<IEnumUnknown,&IID_IEnumUnknown> pThisEnumUnknown;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pThisEnumVARIANT;
	CComPtr<IUnknown> pClone;

	if (ppEnum) {
		*ppEnum = NULL;
	}
	if (!ppEnum) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	pThisEnumUnknown = GetEnum();
	if (pThisEnumUnknown) {
		hrRes = pThisEnumUnknown->Clone((IEnumUnknown **) &pClone);
	} else {
		pThisEnumVARIANT = GetEnum();
		if (pThisEnumVARIANT) {
			hrRes = pThisEnumVARIANT->Clone((IEnumVARIANT **) &pClone);
		} else {
			_ASSERTE(FALSE);
			hrRes = E_NOINTERFACE;
		}
	}
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pClone);
	hrRes = MakeNewEnumUnknown(pClone,GetCollection(),ppEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventEnumUnknownBaseImpl
template <class ObjectClass, class EnumClass>
class ATL_NO_VTABLE CEventEnumUnknownBaseImpl :
	public CEventEnumUnknownBase
{
	protected:
		virtual HRESULT MakeNewObject(REFIID iidDesired, LPVOID *ppvObject) {

			return (CComObject<ObjectClass>::_CreatorClass::CreateInstance(NULL,iidDesired,ppvObject));
		}
		virtual HRESULT MakeNewEnumUnknown(IUnknown *pContained,
										   IEventPropertyBag *pCollection,
										   IEnumUnknown **ppNewEnum) {
			HRESULT hrRes;
			CComObject<EnumClass> *pTmp;

			if (ppNewEnum) {
				*ppNewEnum = NULL;
			}
			if (!ppNewEnum || !pContained || !pCollection) {
				_ASSERTE(FALSE);
				return (E_POINTER);
			}
			hrRes = CComObject<EnumClass>::CreateInstance(&pTmp);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			_ASSERTE(pTmp);
			pTmp->AddRef();
			hrRes = pTmp->SetEnum(pContained,pCollection);
			if (SUCCEEDED(hrRes)) {
				hrRes = pTmp->QueryInterface(IID_IEnumUnknown,(LPVOID *) ppNewEnum);
				_ASSERTE(!SUCCEEDED(hrRes)||*ppNewEnum);
			}
			pTmp->Release();
			return (hrRes);
		};
};


/////////////////////////////////////////////////////////////////////////////
// CEventEnumVARIANTBase
class ATL_NO_VTABLE CEventEnumVARIANTBase :
	public IEventEnumBase,
	public IEnumVARIANT
{
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, VARIANT *avarElt, ULONG *pceltFetched);
		HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
		HRESULT STDMETHODCALLTYPE Reset();
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **ppEnum);
	protected:
		virtual HRESULT MakeNewEnumVARIANT(IUnknown *pContained,
										   IEventPropertyBag *pCollection,
										   IEnumVARIANT **ppNewEnum) = 0;
};


/////////////////////////////////////////////////////////////////////////////
// CEventEnumVARIANTBase


HRESULT STDMETHODCALLTYPE CEventEnumVARIANTBase::Next(ULONG celt, VARIANT *avarElt, ULONG *pceltFetched) {
	HRESULT hrRes;
	IEventPropertyBag **ppTmp;
	BSTR *pstrTmp;
	DWORD dwTmpFetched;
	DWORD dwIdx;

	if (pceltFetched) {
		*pceltFetched = 0;
	}
	if (avarElt) {
		memset(avarElt,0,sizeof(avarElt[0])*celt);
	}
	if (!avarElt) {
		return (E_POINTER);
	}
#if 0
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		VariantInit(&avarElt[dwIdx]);
	}
#endif
	if (!celt) {
		return (S_OK);
	}
	ppTmp = (IEventPropertyBag **) _alloca(sizeof(IEventPropertyBag *)*celt);
	pstrTmp = (BSTR *) _alloca(sizeof(BSTR)*celt);
	hrRes = NextOfUnknown(GetEnum(),
						  GetCollection(),
						  (IUnknown **) ppTmp,
						  pstrTmp,
						  celt,
						  &dwTmpFetched,
						  IID_IEventPropertyBag);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
		hrRes = MakeNewObject(IID_IEventDatabasePlugin,(LPVOID *) &avarElt[dwIdx].punkVal);
		if (SUCCEEDED(hrRes)) {
			_ASSERTE(avarElt[dwIdx].punkVal);
			avarElt[dwIdx].vt = VT_UNKNOWN;
			hrRes = ((IEventDatabasePlugin *) avarElt[dwIdx].punkVal)->put_Database(ppTmp[dwIdx]);
			if (SUCCEEDED(hrRes)) {
				hrRes = ((IEventDatabasePlugin *) avarElt[dwIdx].punkVal)->put_Name(pstrTmp[dwIdx]);
			}
		}
		if (!SUCCEEDED(hrRes)) {
			for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
				VariantClear(&avarElt[dwIdx]);
			}
			break;
		}
		if (SUCCEEDED(hrRes)) {
			hrRes = VariantChangeType(&avarElt[dwIdx],&avarElt[dwIdx],0,VT_DISPATCH);
			_ASSERTE(SUCCEEDED(hrRes));
		}
	}
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		SysFreeString(pstrTmp[dwIdx]);
		if (ppTmp[dwIdx]) {
			ppTmp[dwIdx]->Release();
		}
	}
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pceltFetched) {
		*pceltFetched = dwTmpFetched;
	}
	return ((dwTmpFetched<celt)?S_FALSE:S_OK);
}


HRESULT STDMETHODCALLTYPE CEventEnumVARIANTBase::Skip(ULONG celt) {

	return (BaseSkip(celt));
}


HRESULT STDMETHODCALLTYPE CEventEnumVARIANTBase::Reset() {

	return (BaseReset());
}


HRESULT STDMETHODCALLTYPE CEventEnumVARIANTBase::Clone(IEnumVARIANT **ppEnum) {
	HRESULT hrRes;
	CComQIPtr<IEnumUnknown,&IID_IEnumUnknown> pThisEnumUnknown;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pThisEnumVARIANT;
	CComPtr<IUnknown> pClone;

	if (ppEnum) {
		*ppEnum = NULL;
	}
	if (!ppEnum) {
		return (E_POINTER);
	}
	pThisEnumUnknown = GetEnum();
	if (pThisEnumUnknown) {
		hrRes = pThisEnumUnknown->Clone((IEnumUnknown **) &pClone);
	} else {
		pThisEnumVARIANT = GetEnum();
		if (pThisEnumVARIANT) {
			hrRes = pThisEnumVARIANT->Clone((IEnumVARIANT **) &pClone);
		} else {
			_ASSERTE(FALSE);
			hrRes = E_NOINTERFACE;
		}
	}
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pClone);
	hrRes = MakeNewEnumVARIANT(pClone,GetCollection(),ppEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventEnumVARIANTBaseImpl
template <class ObjectClass, class EnumClass>
class ATL_NO_VTABLE CEventEnumVARIANTBaseImpl :
	public CEventEnumVARIANTBase
{
	protected:
		virtual HRESULT MakeNewObject(REFIID iidDesired, LPVOID *ppvObject) {

			return (CComObject<ObjectClass>::_CreatorClass::CreateInstance(NULL,iidDesired,ppvObject));
		}
		virtual HRESULT MakeNewEnumVARIANT(IUnknown *pContained,
										   IEventPropertyBag *pCollection,
										   IEnumVARIANT **ppNewEnum) {
			HRESULT hrRes;
			CComObject<EnumClass> *pTmp;

			if (ppNewEnum) {
				*ppNewEnum = NULL;
			}
			if (!ppNewEnum || !pContained || !pCollection) {
				_ASSERTE(FALSE);
				return (E_POINTER);
			}
			hrRes = CComObject<EnumClass>::CreateInstance(&pTmp);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			_ASSERTE(pTmp);
			pTmp->AddRef();
			hrRes = pTmp->SetEnum(pContained,pCollection);
			if (SUCCEEDED(hrRes)) {
				hrRes = pTmp->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppNewEnum);
				_ASSERTE(!SUCCEEDED(hrRes)||*ppNewEnum);
			}
			pTmp->Release();
			return (hrRes);
		};
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypeSinksEnum
class ATL_NO_VTABLE CEventTypeSinksEnum :
	public CComObjectRoot,
	public IEnumVARIANT,
	public IEnumString
{
	DEBUG_OBJECT_DEF(CEventTypeSinksEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT Load(IEventTypeSinks *pSinks, DWORD dwIdx);
		static HRESULT Create(IEventTypeSinks *pSinks,
							  DWORD dwIdx,
							  REFIID iidDesired,
							  LPVOID *ppvResult);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventTypeSinksEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventTypeSinksEnum Class",
//								   L"Event.TypeSinksEnum.1",
//								   L"Event.TypeSinksEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventTypeSinksEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumString)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEnumXXXX
	public:
		HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
		HRESULT STDMETHODCALLTYPE Reset();

	// IEnumVARIANT
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, VARIANT *avarElt, ULONG *pceltFetched);
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **ppEnum);

	// IEnumString
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, LPWSTR *apszElt, ULONG *pceltFetched);
		HRESULT STDMETHODCALLTYPE Clone(IEnumString **ppEnum);

	private:
		DWORD m_dwIdx;
		CComPtr<IEventTypeSinks> m_pSinks;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypeSinksEnum


HRESULT CEventTypeSinksEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypeSinksEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventTypeSinksEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventTypeSinksEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypeSinksEnum::FinalRelease");

	m_pSinks.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventTypeSinksEnum::Load(IEventTypeSinks *pSinks, DWORD dwIdx) {
	DEBUG_OBJECT_CHECK

	if (!pSinks) {
		return (E_POINTER);
	}
	m_pSinks = pSinks;
	m_dwIdx = dwIdx;
	return (S_OK);
}


HRESULT CEventTypeSinksEnum::Create(IEventTypeSinks *pSinks,
									DWORD dwIdx,
									REFIID iidDesired,
									LPVOID *ppvResult) {
	HRESULT hrRes;
	CComObject<CEventTypeSinksEnum> *pEnum;

	if (ppvResult) {
		*ppvResult = NULL;
	}
	if (!pSinks) {
		return (E_FAIL);
	}
	if (!ppvResult) {
		return (E_POINTER);
	}
	hrRes = CComObject<CEventTypeSinksEnum>::CreateInstance(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pEnum->AddRef();
	hrRes = pEnum->Load(pSinks,dwIdx);
	if (SUCCEEDED(hrRes)) {
		hrRes = pEnum->QueryInterface(IID_IEnumVARIANT,ppvResult);
	}
	pEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Skip(ULONG celt) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	long lCount;

	_ASSERTE(m_pSinks);
	if (!m_pSinks) {
		return (E_FAIL);
	}
	hrRes = m_pSinks->get_Count(&lCount);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(lCount>=0);
	if (lCount < 0) {
		return (E_FAIL);
	}
	m_dwIdx += celt;
	if (m_dwIdx > (DWORD) lCount) {
		m_dwIdx = lCount;
		return (S_FALSE);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Reset() {
	DEBUG_OBJECT_CHECK

	_ASSERTE(m_pSinks);
	if (!m_pSinks) {
		return (E_FAIL);
	}
	m_dwIdx = 0;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Next(ULONG celt, VARIANT *avarElt, ULONG *pceltFetched) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	DWORD dwIdx;

	if (avarElt) {
		memset(avarElt,0,sizeof(avarElt[0])*celt);
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			VariantInit(&avarElt[dwIdx]);
		}
	}
	if (pceltFetched) {
		*pceltFetched = 0;
	}
	_ASSERTE(m_pSinks);
	if (!m_pSinks) {
		return (E_FAIL);
	}
	if (!avarElt) {
		return (E_POINTER);
	}
	if (!celt) {
		return (S_OK);
	}
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		hrRes = m_pSinks->Item(m_dwIdx+dwIdx+1,&avarElt[dwIdx].bstrVal);
		if (!SUCCEEDED(hrRes)) {
			break;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		avarElt[dwIdx].vt = VT_BSTR;
	}
	if (!SUCCEEDED(hrRes)) {
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			VariantClear(&avarElt[dwIdx]);
		}
		return (hrRes);
	}
	m_dwIdx += dwIdx;
	if (pceltFetched) {
		*pceltFetched = dwIdx;
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Clone(IEnumVARIANT **ppEnum) {
	DEBUG_OBJECT_CHECK

	return (Create(m_pSinks,m_dwIdx,IID_IEnumVARIANT,(LPVOID *) ppEnum));
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Next(ULONG celt, LPWSTR *apszElt, ULONG *pceltFetched) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	DWORD dwIdx;

	if (apszElt) {
		memset(apszElt,0,sizeof(*apszElt)*celt);
	}
	if (pceltFetched) {
		*pceltFetched = 0;
	}
	_ASSERTE(m_pSinks);
	if (!m_pSinks) {
		return (E_FAIL);
	}
	if (!apszElt) {
		return (E_POINTER);
	}
	if (!celt) {
		return (S_OK);
	}
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		CComBSTR bstrVal;

		bstrVal.Empty();
		hrRes = m_pSinks->Item(m_dwIdx+dwIdx+1,&bstrVal);
		if (!SUCCEEDED(hrRes)) {
			break;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		apszElt[dwIdx] = (LPWSTR) CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(bstrVal)+1));
		if (!apszElt[dwIdx]) {
			hrRes = E_OUTOFMEMORY;
			break;
		}
		wcscpy(apszElt[dwIdx],bstrVal);
	}
	if (!SUCCEEDED(hrRes)) {
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			CoTaskMemFree(apszElt[dwIdx]);
			apszElt[dwIdx] = NULL;
		}
		return (hrRes);
	}
	m_dwIdx += dwIdx;
	if (pceltFetched) {
		*pceltFetched = dwIdx;
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Clone(IEnumString **ppEnum) {
	DEBUG_OBJECT_CHECK

	return (Create(m_pSinks,m_dwIdx,IID_IEnumString,(LPVOID *) ppEnum));
}


/////////////////////////////////////////////////////////////////////////////
// CEventTypeSinks
class ATL_NO_VTABLE CEventTypeSinks :
	public CComObjectRoot,
//	public CComCoClass<CEventTypeSinks, &CLSID_CEventTypeSinks>,
	public IDispatchImpl<IEventTypeSinks, &IID_IEventTypeSinks, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventTypeSinks)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT Load(CATID catid);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventTypeSinks);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventTypeSinks Class",
//								   L"Event.TypeSinks.1",
//								   L"Event.TypeSinks");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventTypeSinks)
		COM_INTERFACE_ENTRY(IEventTypeSinks)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventTypeSinks)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventTypeSinks
	public:
		HRESULT STDMETHODCALLTYPE Item(long lIndex, BSTR *pstrTypeSink);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszTypeSink);
		HRESULT STDMETHODCALLTYPE Remove(BSTR pszTypeSink);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CATID m_catid;
		DWORD m_dwProgID;
		CComBSTR *m_astrProgID;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypeSinks


HRESULT CEventTypeSinks::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypeSinks::FinalConstruct");
	HRESULT hrRes = S_OK;

	m_dwProgID = 0;
	m_astrProgID = NULL;
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventTypeSinks")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventTypeSinks::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypeSinks::FinalRelease");

	_ASSERTE((!m_dwProgID&&!m_astrProgID)||(m_dwProgID&&m_astrProgID));
	delete[] m_astrProgID;
	m_dwProgID = 0;
	m_astrProgID = NULL;
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventTypeSinks::Load(CATID catid) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatInformation> pCatInfo;
	CComPtr<IEnumCLSID> pEnum;
	DWORD dwAlloc = 0;
	CLSID *pclsid = NULL;
	DWORD dwTmp;

	m_catid = GUID_NULL;
	delete[] m_astrProgID;
	m_dwProgID = 0;
	m_astrProgID = NULL;
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &pCatInfo);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatInfo->EnumClassesOfCategories(1,(GUID *) &catid,-1,NULL,&pEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = S_FALSE;
	while (1) {

		dwTmp = (hrRes==S_FALSE) ? 1 : dwAlloc;
		if (!MyReallocInPlace(&pclsid,sizeof(*pclsid)*(dwAlloc+dwTmp))) {
			MyFree(pclsid);
			return (E_OUTOFMEMORY);
		}
		hrRes = pEnum->Next(dwTmp,&pclsid[dwAlloc],&dwTmp);
		// Do not alter hrRes between here and the bottom of the loop!  The first statement
		// in the loop relies on hrRes having the result from this call to IEnumCLSID::Next.
		if (!SUCCEEDED(hrRes)) {
			MyFree(pclsid);
			return (hrRes);
		}
		if (!dwTmp) {
			break;
		}
		dwAlloc += dwTmp;
	}
	m_astrProgID = new CComBSTR[dwAlloc];
	if (!m_astrProgID) {
		MyFree(pclsid);
		return (E_OUTOFMEMORY);
	}
	for (dwTmp=0,m_dwProgID=0;dwTmp<dwAlloc;dwTmp++) {
		LPOLESTR pszTmp;

		hrRes = ProgIDFromCLSID(pclsid[dwTmp],&pszTmp);
		if (SUCCEEDED(hrRes)) {
			m_astrProgID[m_dwProgID] = pszTmp;
			CoTaskMemFree(pszTmp);
			m_dwProgID++;
		}
	}
	MyFree(pclsid);
	m_catid = catid;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::Item(long lIndex, BSTR *pstrTypeSink) {
	DEBUG_OBJECT_CHECK

	if (pstrTypeSink) {
		*pstrTypeSink = NULL;
	}
	if (!pstrTypeSink) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	if (lIndex < 1) {
		return (E_INVALIDARG);
	}
	if ((DWORD) lIndex > m_dwProgID) {
		return (S_FALSE);
	}
	*pstrTypeSink = SysAllocString(m_astrProgID[lIndex]);
	if (!pstrTypeSink) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::Add(BSTR pszTypeSink) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CStringGUID objGuid;
	CComPtr<ICatRegister> pCatReg;

	if (!pszTypeSink) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	objGuid.CalcFromProgID(pszTypeSink);
	if (!objGuid) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->RegisterClassImplCategories(objGuid,1,&m_catid);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = Load(m_catid);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::Remove(BSTR pszTypeSink) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CStringGUID objGuid;
	CComPtr<ICatRegister> pCatReg;

	if (!pszTypeSink) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	objGuid.CalcFromProgID(pszTypeSink);
	if (!objGuid) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->UnRegisterClassImplCategories(objGuid,1,&m_catid);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = Load(m_catid);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	*plCount = m_dwProgID;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	return (CEventTypeSinksEnum::Create(this,0,IID_IEnumVARIANT,(LPVOID *) ppUnkEnum));
}


/////////////////////////////////////////////////////////////////////////////
// CEventType
class ATL_NO_VTABLE CEventType :
	public CComObjectRoot,
//	public CComCoClass<CEventType, &CLSID_CEventType>,
	public IDispatchImpl<IEventType, &IID_IEventType, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventType)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventType);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventType Class",
//								   L"Event.Type.1",
//								   L"Event.Type");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventType)
		COM_INTERFACE_ENTRY(IEventType)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventType)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventType
	public:
		HRESULT STDMETHODCALLTYPE get_ID(BSTR *pstrID);
		HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE get_Sinks(IEventTypeSinks **ppTypeSinks);

	private:
		CComPtr<ICatInformation> m_pCatInfo;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventType


HRESULT CEventType::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventType::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &m_pCatInfo);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pCatInfo);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	ADD_DEBUG_OBJECT("CEventType")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventType::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventType::FinalRelease");

	m_pCatInfo.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventType::get_ID(BSTR *pstrID) {
	DEBUG_OBJECT_CHECK

	_ASSERTE(m_strName);
	if (!pstrID) {
		return (E_POINTER);
	}
	*pstrID = SysAllocString(m_strName);
	if (!*pstrID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventType::get_DisplayName(BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	LPOLESTR pszDesc;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pstrDisplayName) {
		return (E_POINTER);
	}
	hrRes = m_pCatInfo->GetCategoryDesc(CStringGUID(m_strName),LOCALE_USER_DEFAULT,&pszDesc);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*pstrDisplayName = SysAllocString(pszDesc);
	CoTaskMemFree(pszDesc);
	if (!pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventType::get_Sinks(IEventTypeSinks **ppTypeSinks) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComObject<CEventTypeSinks> *pSinks;

	if (ppTypeSinks) {
		*ppTypeSinks = NULL;
	}
	if (!ppTypeSinks) {
		return (E_POINTER);
	}
	hrRes = CComObject<CEventTypeSinks>::CreateInstance(&pSinks);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pSinks->AddRef();
	hrRes = pSinks->Load(CStringGUID(m_strName));
	if (SUCCEEDED(hrRes)) {
		hrRes = pSinks->QueryInterface(IID_IEventTypeSinks,(LPVOID *) ppTypeSinks);
	}
	pSinks->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventTypesEnum
class ATL_NO_VTABLE CEventTypesEnum :
	public CComObjectRoot,
//	public CComCoClass<CEventTypesEnum, &CLSID_CEventTypesEnum>,
	public CEventEnumVARIANTBaseImpl<CEventType,CEventTypesEnum>,
	public CEventEnumUnknownBaseImpl<CEventType,CEventTypesEnum>
{
	DEBUG_OBJECT_DEF(CEventTypesEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventTypesEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventTypesEnum Class",
//								   L"Event.EventTypesEnum.1",
//								   L"Event.EventTypesEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventTypesEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventEnumBase
	public:
		virtual HRESULT SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection);
		virtual IUnknown *GetEnum() { _ASSERTE(m_pEnum); return (m_pEnum); };
		virtual IEventPropertyBag *GetCollection() { _ASSERTE(m_pCollection); return (m_pCollection); };

	private:
		CComPtr<IUnknown> m_pEnum;
		CComPtr<IEventPropertyBag> m_pCollection;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypesEnum


HRESULT CEventTypesEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypesEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventTypesEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventTypesEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypesEnum::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventTypesEnum::SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection) {
	DEBUG_OBJECT_CHECK

	if (!pEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	m_pEnum = pEnum;
	m_pCollection = pCollection;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventTypes
class ATL_NO_VTABLE CEventTypes :
	public CComObjectRoot,
//	public CComCoClass<CEventTypes, &CLSID_CEventTypes>,
	public IDispatchImpl<IEventTypes, &IID_IEventTypes, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventTypes)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventTypes);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventTypes Class",
//								   L"Event.EventTypes.1",
//								   L"Event.EventTypes");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventTypes)
		COM_INTERFACE_ENTRY(IEventTypes)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventTypes)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventTypes
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarDesired, IEventType **ppEventType);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszEventType);
		HRESULT STDMETHODCALLTYPE Remove(BSTR pszEventType);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CComPtr<ICatInformation> m_pCatInfo;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypes


HRESULT CEventTypes::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypes::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &m_pCatInfo);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pCatInfo);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	ADD_DEBUG_OBJECT("CEventTypes")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventTypes::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypes::FinalRelease");

	m_pCatInfo.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventTypes::Item(VARIANT *pvarDesired, IEventType **ppEventType) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventType>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  pvarDesired,
								  IID_IEventType,
								  (IUnknown **) ppEventType,
								  FALSE));
}


HRESULT STDMETHODCALLTYPE CEventTypes::Add(BSTR pszEventType) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CStringGUID objGuid;
	LPOLESTR pszDesc;
	CComPtr<IEventPropertyBag> pdictTmp;

	if (!m_pCatInfo) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!pszEventType) {
		return (E_POINTER);
	}
	objGuid = pszEventType;
	if (!objGuid) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = m_pCatInfo->GetCategoryDesc(objGuid,LOCALE_USER_DEFAULT,&pszDesc);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	CoTaskMemFree(pszDesc);
	hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = m_pDatabase->Add((LPOLESTR) ((LPCOLESTR) objGuid),&CComVariant(pdictTmp));
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypes::Remove(BSTR pszEventType) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->Remove(&CComVariant(pszEventType)));
}


HRESULT STDMETHODCALLTYPE CEventTypes::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->get_Count(plCount));
}


HRESULT STDMETHODCALLTYPE CEventTypes::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkTmp;
	CComObject<CEventTypesEnum> *pNewEnum;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = m_pDatabase->get__NewEnum(&pUnkTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pUnkTmp);
	hrRes = CComObject<CEventTypesEnum>::CreateInstance(&pNewEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewEnum);
	pNewEnum->AddRef();
	hrRes = pNewEnum->SetEnum(pUnkTmp,m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		pNewEnum->Release();
		return (hrRes);
	}
	hrRes = pNewEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppUnkEnum);
	pNewEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppUnkEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventSource
class ATL_NO_VTABLE CEventSource :
	public CComObjectRoot,
//	public CComCoClass<CEventSource, &CLSID_CEventSource>,
	public IDispatchImpl<IEventSource, &IID_IEventSource, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventSource)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSource);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSource Class",
//								   L"Event.Source.1",
//								   L"Event.Source");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSource)
		COM_INTERFACE_ENTRY(IEventSource)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventSource)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventSource
	public:
		HRESULT STDMETHODCALLTYPE get_ID(BSTR *pstrID);
		HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE put_DisplayName(BSTR pszDisplayName);
		HRESULT STDMETHODCALLTYPE putref_DisplayName(BSTR *ppszDisplayName);
		HRESULT STDMETHODCALLTYPE get_BindingManagerMoniker(IUnknown **ppUnkMoniker);
		HRESULT STDMETHODCALLTYPE put_BindingManagerMoniker(IUnknown *pUnkMoniker);
		HRESULT STDMETHODCALLTYPE putref_BindingManagerMoniker(IUnknown **ppUnkMoniker);
		HRESULT STDMETHODCALLTYPE GetBindingManager(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE get_Properties(IEventPropertyBag **ppProperties);
		HRESULT STDMETHODCALLTYPE Save();

	private:
		CComPtr<IEventPropertyBag> m_pTmpDatabase;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSource


HRESULT CEventSource::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSource::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSource")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSource::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSource::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventSource::get_ID(BSTR *pstrID) {
	DEBUG_OBJECT_CHECK

	_ASSERTE(m_strName);
	if (!pstrID) {
		return (E_POINTER);
	}
	*pstrID = SysAllocString(m_strName);
	if (!*pstrID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSource::get_DisplayName(BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pstrDisplayName) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_DISPLAYNAME),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		*pstrDisplayName = SysAllocString(L"");
	} else {
		hrRes = varPropValue.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pstrDisplayName = SysAllocString(varPropValue.bstrVal);
	}
	if (!*pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSource::put_DisplayName(BSTR pszDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (pszDisplayName) {
		varPropValue = pszDisplayName;
	}
	hrRes = m_pTmpDatabase->Add(BD_DISPLAYNAME,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSource::putref_DisplayName(BSTR *ppszDisplayName) {
	DEBUG_OBJECT_CHECK

	if (!ppszDisplayName) {
		return (E_POINTER);
	}
	return (put_DisplayName(*ppszDisplayName));
}


HRESULT STDMETHODCALLTYPE CEventSource::get_BindingManagerMoniker(IUnknown **ppUnkMoniker) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;
	CComPtr<IBindCtx> pBindCtx;
	DWORD dwEaten;

	if (ppUnkMoniker) {
		*ppUnkMoniker = NULL;
	}
	if (!ppUnkMoniker) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_BINDINGMANAGERMONIKER),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (EVENTS_E_BADDATA);
	}
	hrRes = varPropValue.ChangeType(VT_BSTR);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CreateBindCtx(0,&pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = MkParseDisplayName(pBindCtx,varPropValue.bstrVal,&dwEaten,(IMoniker **) ppUnkMoniker);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSource::put_BindingManagerMoniker(IUnknown *pUnkMoniker) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropName;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (pUnkMoniker) {
		CComBSTR strString;
		CComPtr<IBindCtx> pBindCtx;
		CComQIPtr<IMoniker,&IID_IMoniker> pMoniker = pUnkMoniker;
		LPOLESTR pszDisplayName;

		if (!pMoniker) {
			return (E_NOINTERFACE);
		}
		hrRes = CreateBindCtx(0,&pBindCtx);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pMoniker->GetDisplayName(pBindCtx,NULL,&pszDisplayName);
		if (!SUCCEEDED(hrRes)) {
			CoTaskMemFree(pszDisplayName);
			return (hrRes);
		}
		varPropValue = pszDisplayName;
		CoTaskMemFree(pszDisplayName);
	} else {
		varPropValue = L"";
	}
	varPropName = BD_BINDINGMANAGERMONIKER;
	hrRes = m_pTmpDatabase->Add(BD_BINDINGMANAGERMONIKER,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSource::putref_BindingManagerMoniker(IUnknown **ppUnkMoniker) {
	DEBUG_OBJECT_CHECK

	if (!ppUnkMoniker) {
		return (E_POINTER);
	}
	return (put_BindingManagerMoniker(*ppUnkMoniker));
}


HRESULT STDMETHODCALLTYPE CEventSource::GetBindingManager(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkMon;
	CComQIPtr<IMoniker,&IID_IMoniker> pMon;
	CComPtr<IBindCtx> pBindCtx;

	if (ppBindingManager) {
		*ppBindingManager = NULL;
	}
	if (!ppBindingManager) {
		return (E_POINTER);
	}
	hrRes = get_BindingManagerMoniker(&pUnkMon);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pMon = pUnkMon;
	if (!pMon) {
		return (E_NOINTERFACE);
	}
	hrRes = CreateBindCtx(0,&pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pMon->BindToObject(pBindCtx,NULL,IID_IEventBindingManager,(LPVOID *) ppBindingManager);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSource::get_Properties(IEventPropertyBag **ppProperties) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (ppProperties) {
		*ppProperties = NULL;
	}
	if (!ppProperties) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	*ppProperties = m_pTmpDatabase;
	(*ppProperties)->AddRef();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSource::Save() {
	DEBUG_OBJECT_CHECK

	return (SaveImpl(m_strName,m_pDatabase,m_pTmpDatabase,m_pParent));
}


/////////////////////////////////////////////////////////////////////////////
// CEventSourcesEnum
class ATL_NO_VTABLE CEventSourcesEnum :
	public CComObjectRoot,
//	public CComCoClass<CEventSourcesEnum, &CLSID_CEventSourcesEnum>,
	public CEventEnumVARIANTBaseImpl<CEventSource,CEventSourcesEnum>,
	public CEventEnumUnknownBaseImpl<CEventSource,CEventSourcesEnum>
{
	DEBUG_OBJECT_DEF(CEventSourcesEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSourcesEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSourcesEnum Class",
//								   L"Event.SourcesEnum.1",
//								   L"Event.SourcesEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSourcesEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventEnumBase
	public:
		virtual HRESULT SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection);
		virtual IUnknown *GetEnum() { _ASSERTE(m_pEnum); return (m_pEnum); };
		virtual IEventPropertyBag *GetCollection() { _ASSERTE(m_pCollection); return (m_pCollection); };

	private:
		CComPtr<IUnknown> m_pEnum;
		CComPtr<IEventPropertyBag> m_pCollection;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSourcesEnum


HRESULT CEventSourcesEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourcesEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSourcesEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSourcesEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourcesEnum::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventSourcesEnum::SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection) {
	DEBUG_OBJECT_CHECK

	if (!pEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	m_pEnum = pEnum;
	m_pCollection = pCollection;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventSources
class ATL_NO_VTABLE CEventSources :
	public CComObjectRoot,
//	public CComCoClass<CEventSources, &CLSID_CEventSources>,
	public IDispatchImpl<IEventSources, &IID_IEventSources, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventSources)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSources);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSources Class",
//								   L"Event.Sources.1",
//								   L"Event.Sources");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSources)
		COM_INTERFACE_ENTRY(IEventSources)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventSources)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventSources
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarDesired, IEventSource **ppSource);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszSource, IEventSource **ppSource);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSources


HRESULT CEventSources::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSources::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSources")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSources::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSources::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventSources::Item(VARIANT *pvarDesired, IEventSource **ppSource) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventSource>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  pvarDesired,
								  IID_IEventSource,
								  (IUnknown **) ppSource,
								  FALSE));
}


HRESULT STDMETHODCALLTYPE CEventSources::Add(BSTR pszSource, IEventSource **ppSource) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varName;
	CStringGUID objGuid;

	if (ppSource) {
		*ppSource = NULL;
	}
	hrRes = AddImpl1(pszSource,objGuid,&varName);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(varName.vt==VT_BSTR);
	hrRes = Item(&varName,ppSource);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		return (S_FALSE);
	}
	hrRes = AddImpl2(m_pDatabase,
					 CComObject<CEventSource>::_CreatorClass::CreateInstance,
					 IID_IEventSource,
					 &varName,
					 (IUnknown **) ppSource);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppSource);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSources::Remove(VARIANT *pvarDesired) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->Remove(pvarDesired));
}


HRESULT STDMETHODCALLTYPE CEventSources::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->get_Count(plCount));
}


HRESULT STDMETHODCALLTYPE CEventSources::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkTmp;
	CComObject<CEventSourcesEnum> *pNewEnum;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = m_pDatabase->get__NewEnum(&pUnkTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pUnkTmp);
	hrRes = CComObject<CEventSourcesEnum>::CreateInstance(&pNewEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewEnum);
	pNewEnum->AddRef();
	hrRes = pNewEnum->SetEnum(pUnkTmp,m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		pNewEnum->Release();
		return (hrRes);
	}
	hrRes = pNewEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppUnkEnum);
	pNewEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppUnkEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventSourceType
class ATL_NO_VTABLE CEventSourceType :
	public CComObjectRoot,
//	public CComCoClass<CEventSourceType, &CLSID_CEventSourceType>,
	public IDispatchImpl<IEventSourceType, &IID_IEventSourceType, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventSourceType)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSourceType);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSourceType Class",
//								   L"Event.Source.1",
//								   L"Event.Source");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSourceType)
		COM_INTERFACE_ENTRY(IEventSourceType)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventSourceType)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventSourceType
	public:
		HRESULT STDMETHODCALLTYPE get_ID(BSTR *pstrID);
		HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE put_DisplayName(BSTR pszDisplayName);
		HRESULT STDMETHODCALLTYPE putref_DisplayName(BSTR *ppszDisplayName);
		HRESULT STDMETHODCALLTYPE get_EventTypes(IEventTypes **ppEventTypes);
		HRESULT STDMETHODCALLTYPE get_Sources(IEventSources **ppSources);
		HRESULT STDMETHODCALLTYPE Save();

	private:
		CComPtr<IEventPropertyBag> m_pTmpDatabase;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSourceType


HRESULT CEventSourceType::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceType::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSourceType")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSourceType::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceType::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventSourceType::get_ID(BSTR *pstrID) {
	DEBUG_OBJECT_CHECK

	_ASSERTE(m_strName);
	if (!pstrID) {
		return (E_POINTER);
	}
	*pstrID = SysAllocString(m_strName);
	if (!*pstrID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSourceType::get_DisplayName(BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pstrDisplayName) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_DISPLAYNAME),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		*pstrDisplayName = SysAllocString(L"");
	} else {
		hrRes = varPropValue.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pstrDisplayName = SysAllocString(varPropValue.bstrVal);
	}
	if (!*pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSourceType::put_DisplayName(BSTR pszDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERTE(m_pTmpDatabase);
	}
	if (pszDisplayName) {
		varPropValue = pszDisplayName;
	} else {
		varPropValue = L"";
	}
	hrRes = m_pTmpDatabase->Add(BD_DISPLAYNAME,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSourceType::putref_DisplayName(BSTR *ppszDisplayName) {
	DEBUG_OBJECT_CHECK

	if (!ppszDisplayName) {
		return (E_POINTER);
	}
	return (put_DisplayName(*ppszDisplayName));
}


HRESULT STDMETHODCALLTYPE CEventSourceType::get_EventTypes(IEventTypes **ppEventTypes) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (CreatePluggedInObject(CComObject<CEventTypes>::_CreatorClass::CreateInstance,
								  m_pTmpDatabase?m_pTmpDatabase:m_pDatabase,
								  &CComVariant(BD_EVENTTYPES),
								  IID_IEventTypes,
								  (IUnknown **) ppEventTypes,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventSourceType::get_Sources(IEventSources **ppSources) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (CreatePluggedInObject(CComObject<CEventSources>::_CreatorClass::CreateInstance,
								  m_pTmpDatabase?m_pTmpDatabase:m_pDatabase,
								  &CComVariant(BD_SOURCES),
								  IID_IEventSources,
								  (IUnknown **) ppSources,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventSourceType::Save() {
	DEBUG_OBJECT_CHECK

	return (SaveImpl(m_strName,m_pDatabase,m_pTmpDatabase,m_pParent));
}


/////////////////////////////////////////////////////////////////////////////
// CEventSourceTypesEnum
class ATL_NO_VTABLE CEventSourceTypesEnum :
	public CComObjectRoot,
//	public CComCoClass<CEventSourceTypesEnum, &CLSID_CEventSourceTypesEnum>,
	public CEventEnumVARIANTBaseImpl<CEventSourceType,CEventSourceTypesEnum>,
	public CEventEnumUnknownBaseImpl<CEventSourceType,CEventSourceTypesEnum>
{
	DEBUG_OBJECT_DEF(CEventSourceTypesEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSourceTypesEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSourceTypesEnum Class",
//								   L"Event.SourcesEnum.1",
//								   L"Event.SourcesEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSourceTypesEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventEnumBase
	public:
		virtual HRESULT SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection);
		virtual IUnknown *GetEnum() { _ASSERTE(m_pEnum); return (m_pEnum); };
		virtual IEventPropertyBag *GetCollection() { _ASSERTE(m_pCollection); return (m_pCollection); };

	private:
		CComPtr<IUnknown> m_pEnum;
		CComPtr<IEventPropertyBag> m_pCollection;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSourceTypesEnum


HRESULT CEventSourceTypesEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceTypesEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSourceTypesEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSourceTypesEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceTypesEnum::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventSourceTypesEnum::SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection) {
	DEBUG_OBJECT_CHECK

	if (!pEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	m_pEnum = pEnum;
	m_pCollection = pCollection;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventSourceTypes
class ATL_NO_VTABLE CEventSourceTypes :
	public CComObjectRoot,
//	public CComCoClass<CEventSourceTypes, &CLSID_CEventSourceTypes>,
	public IDispatchImpl<IEventSourceTypes, &IID_IEventSourceTypes, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventSourceTypes)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSourceTypes);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSourceTypes Class",
//								   L"Event.SourceTypes.1",
//								   L"Event.SourceTypes");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSourceTypes)
		COM_INTERFACE_ENTRY(IEventSourceTypes)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventSourceTypes)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventSourceTypes
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarDesired, IEventSourceType **ppSourceType);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszSourceType, IEventSourceType **ppSourceType);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSourceTypes


HRESULT CEventSourceTypes::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceTypes::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSourceTypes")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSourceTypes::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceTypes::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::Item(VARIANT *pvarDesired, IEventSourceType **ppSourceType) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventSourceType>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  pvarDesired,
								  IID_IEventSourceType,
								  (IUnknown **) ppSourceType,
								  FALSE));
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::Add(BSTR pszSourceType, IEventSourceType **ppSourceType) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varName;
	CStringGUID objGuid;

	if (ppSourceType) {
		*ppSourceType = NULL;
	}
	hrRes = AddImpl1(pszSourceType,objGuid,&varName);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(varName.vt==VT_BSTR);
	hrRes = Item(&varName,ppSourceType);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		return (S_FALSE);
	}
	hrRes = AddImpl2(m_pDatabase,
					 CComObject<CEventSourceType>::_CreatorClass::CreateInstance,
					 IID_IEventSourceType,
					 &varName,
					 (IUnknown **) ppSourceType);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppSourceType);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::Remove(VARIANT *pvarDesired) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->Remove(pvarDesired));
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->get_Count(plCount));
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkTmp;
	CComObject<CEventSourceTypesEnum> *pNewEnum;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = m_pDatabase->get__NewEnum(&pUnkTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CComObject<CEventSourceTypesEnum>::CreateInstance(&pNewEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewEnum);
	pNewEnum->AddRef();
	hrRes = pNewEnum->SetEnum(pUnkTmp,m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		pNewEnum->Release();
		return (hrRes);
	}
	hrRes = pNewEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppUnkEnum);
	pNewEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppUnkEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventManager


HRESULT CEventManager::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventManager::FinalConstruct");
	HRESULT hrRes = S_OK;
	CComPtr<IEventPropertyBag> pDatabaseRoot;
	CComPtr<IEventPropertyBag> pDatabase;

	ADD_DEBUG_OBJECT("CEventManager")
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	_ASSERTE(m_pUnkMarshaler);
	hrRes = CoCreateInstance(CLSID_CSEOMetaDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pDatabaseRoot);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	_ASSERTE(pDatabaseRoot);
	hrRes = CreateSubPropertyBag(pDatabaseRoot,&CComVariant(L"LM/EventManager"),&pDatabase,TRUE);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	_ASSERTE(pDatabase);
	hrRes = put_Database(pDatabase);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = CoCreateInstance(CLSID_CEventLock,NULL,CLSCTX_ALL,IID_IEventLock,(LPVOID *) &m_pLock);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventManager::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventManager::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventManager::get_SourceTypes(IEventSourceTypes **ppSourceTypes) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventSourceTypes>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  &CComVariant(BD_SOURCETYPES),
								  IID_IEventSourceTypes,
								  (IUnknown **) ppSourceTypes,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventManager::CreateSink(IEventBinding *pEventBinding,
								   	 				IEventDeliveryOptions *pDeliveryOptions,
													IUnknown **ppUnkSink) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComBSTR strSinkClass;
	CComPtr<IEventPropertyBag> pSinkProperties;
	CComQIPtr<CCreateSinkInfo,&IID_ICreateSinkInfo> pInfo;
	CLocker lck(LOCK_TIMEOUT);
	CComPtr<IUnknown> pSink;
	CComQIPtr<IEventIsCacheable,&IID_IEventIsCacheable> pCache;
	VARIANT varSinkClass;
	VARIANT_BOOL bEnabled;

	if (ppUnkSink) {
		*ppUnkSink = NULL;
	}
	_ASSERTE(m_pLock);
	if (!ppUnkSink || !pEventBinding) {
		return (E_POINTER);
	}
	hrRes = lck.LockRead(m_pLock);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pInfo = pEventBinding;
	if (pInfo && pInfo->m_bInit) {
again:
		lck.Unlock();
		if (!pInfo->m_bEnabled) {
			return (EVENTS_E_DISABLED);
		}
		if (pInfo->m_pSink) {
			*ppUnkSink = pInfo->m_pSink;
			(*ppUnkSink)->AddRef();
			return (S_OK);
		}
		if (pSink) {
			*ppUnkSink = pSink;
			(*ppUnkSink)->AddRef();
			return (S_OK);
		}
		varSinkClass.vt = VT_BYREF|VT_BSTR;
		varSinkClass.pbstrVal = &pInfo->m_strSinkClass;
		hrRes = SEOCreateObjectEx(&varSinkClass,
								  pEventBinding,
								  pInfo->m_pSinkProperties,
								  IID_IUnknown,
								  pDeliveryOptions,
								  ppUnkSink);
		return (hrRes);
	}
	lck.Unlock();
	hrRes = pEventBinding->get_SinkProperties(&pSinkProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pEventBinding->get_SinkClass(&strSinkClass);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pEventBinding->get_Enabled(&bEnabled);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (bEnabled) {
		varSinkClass.vt = VT_BYREF|VT_BSTR;
		varSinkClass.pbstrVal = &strSinkClass;
		hrRes = SEOCreateObjectEx(&varSinkClass,
								  pEventBinding,
								  pSinkProperties,
								  IID_IUnknown,
								  pDeliveryOptions,
								  &pSink);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (!pInfo) {
		if (!bEnabled) {
			return (EVENTS_E_DISABLED);
		}
		*ppUnkSink = pSink;
		(*ppUnkSink)->AddRef();
		return (hrRes);
	}
	hrRes = lck.LockWrite(m_pLock);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pInfo->m_bInit) {
		pSink.Release();
		goto again;
	}
	pInfo->m_bInit = TRUE;
	pInfo->m_strSinkClass.Attach(strSinkClass.Detach());
	pInfo->m_bEnabled = bEnabled ? TRUE : FALSE;
	if (pInfo->m_bEnabled) {
		pCache = pSink;
		if (pCache && (pCache->IsCacheable() == S_OK)) {
			pInfo->m_pSink = pSink;
		}
	}
	pInfo->m_pSinkProperties = pSinkProperties;
	goto again;
}


#if 0

HRESULT STDMETHODCALLTYPE CEventManager::CreateSink(IEventBinding *pEventBinding,
								   	 				IEventDeliveryOptions *pDeliveryOptions,
													IUnknown **ppUnkSink) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComBSTR strProgID;
	CComPtr<IEventPropertyBag> pProperties;

	if (ppUnkSink) {
		*ppUnkSink = NULL;
	}
	if (!ppUnkSink || !pEventBinding) {
		return (E_POINTER);
	}
	hrRes = pEventBinding->get_SinkProperties(&pProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pEventBinding->get_SinkClass(&strProgID);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = SEOCreateObject(&CComVariant(strProgID),pEventBinding,pProperties,IID_IUnknown,ppUnkSink);
	return (hrRes);
}

#endif


/////////////////////////////////////////////////////////////////////////////
// CEventBinding
class ATL_NO_VTABLE CEventBinding :
	public CComObjectRoot,
//	public CComCoClass<CEventBinding, &CLSID_CEventBinding>,
	public IDispatchImpl<IEventBinding, &IID_IEventBinding, &LIBID_SEOLib>,
	public CEventDatabasePlugin,
	public CCreateSinkInfo
{
	DEBUG_OBJECT_DEF(CEventBinding)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT GetProperties(LPCOLESTR pszPropName, IEventPropertyBag **ppProperties);
		HRESULT CopyForWrite();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventBinding);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventBinding Class",
//								   L"Event.Binding.1",
//								   L"Event.Binding");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventBinding)
		COM_INTERFACE_ENTRY(IEventBinding)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventBinding)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_IID(IID_ICreateSinkInfo, CCreateSinkInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventBinding
	public:
		HRESULT STDMETHODCALLTYPE get_ID(BSTR *pstrID);
		HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE put_DisplayName(BSTR pszDisplayName);
		HRESULT STDMETHODCALLTYPE putref_DisplayName(BSTR *ppszDisplayName);
		HRESULT STDMETHODCALLTYPE get_SinkClass(BSTR *pstrSinkClass);
		HRESULT STDMETHODCALLTYPE put_SinkClass(BSTR pszSinkClass);
		HRESULT STDMETHODCALLTYPE putref_SinkClass(BSTR *ppszSinkClass);
		HRESULT STDMETHODCALLTYPE get_SinkProperties(IEventPropertyBag **ppSinkProperties);
		HRESULT STDMETHODCALLTYPE get_SourceProperties(IEventPropertyBag **ppSourceProperties);
		HRESULT STDMETHODCALLTYPE get_EventBindingProperties(IEventPropertyBag **ppBindingProperties);
		HRESULT STDMETHODCALLTYPE get_Enabled(VARIANT_BOOL *pbEnabled);
		HRESULT STDMETHODCALLTYPE put_Enabled(VARIANT_BOOL bEnabled);
		HRESULT STDMETHODCALLTYPE putref_Enabled(VARIANT_BOOL *pbEnabled);
		HRESULT STDMETHODCALLTYPE get_Expiration(DATE *pdateExpiration);
		HRESULT STDMETHODCALLTYPE put_Expiration(DATE dateExpiration);
		HRESULT STDMETHODCALLTYPE putref_Expiration(DATE *pdateExpiration);
		HRESULT STDMETHODCALLTYPE get_MaxFirings(long *plMaxFirings);
		HRESULT STDMETHODCALLTYPE put_MaxFirings(long lMaxFirings);
		HRESULT STDMETHODCALLTYPE putref_MaxFirings(long *plMaxFirings);
		HRESULT STDMETHODCALLTYPE Save();

	private:
		CComPtr<IEventPropertyBag> m_pTmpDatabase;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventBinding


HRESULT CEventBinding::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBinding::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	m_bInit = FALSE;
	ADD_DEBUG_OBJECT("CEventBinding")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventBinding::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBinding::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_ID(BSTR *pstrID) {
	DEBUG_OBJECT_CHECK

	if (pstrID) {
		*pstrID = NULL;
	}
	if (!pstrID) {
		return (E_POINTER);
	}
	*pstrID = SysAllocString(m_strName);
	if (!*pstrID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_DisplayName(BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pstrDisplayName) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_DISPLAYNAME),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		*pstrDisplayName = SysAllocString(L"");
	} else {
		hrRes = varPropValue.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pstrDisplayName = SysAllocString(varPropValue.bstrVal);
	}
	if (!*pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT CEventBinding::CopyForWrite() {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_DisplayName(BSTR pszDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pszDisplayName) {
		varPropValue = pszDisplayName;
	}
	hrRes = m_pTmpDatabase->Add(BD_DISPLAYNAME,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_DisplayName(BSTR *ppszDisplayName) {
	DEBUG_OBJECT_CHECK

	if (!ppszDisplayName) {
		return (E_POINTER);
	}
	return (put_DisplayName(*ppszDisplayName));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_SinkClass(BSTR *pstrSinkClass) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pstrSinkClass) {
		*pstrSinkClass = NULL;
	}
	if (!pstrSinkClass) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_SINKCLASS),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		*pstrSinkClass = SysAllocString(L"");
	} else {
		hrRes = varPropValue.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pstrSinkClass = SysAllocString(varPropValue.bstrVal);
	}
	if (!*pstrSinkClass) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_SinkClass(BSTR pszSinkClass) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pszSinkClass) {
		varPropValue = pszSinkClass;
	}
	hrRes = m_pTmpDatabase->Add(BD_SINKCLASS,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_SinkClass(BSTR *ppszSinkClass) {
	DEBUG_OBJECT_CHECK

	if (!ppszSinkClass) {
		return (E_POINTER);
	}
	return (put_SinkClass(*ppszSinkClass));
}


HRESULT CEventBinding::GetProperties(LPCOLESTR pszPropName, IEventPropertyBag **ppProperties) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (ppProperties) {
		*ppProperties = NULL;
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!ppProperties) {
		return (E_POINTER);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = m_pTmpDatabase->Item(&CComVariant(pszPropName),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		hrRes = varPropValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			varPropValue.Clear();
			hrRes = S_FALSE;
		} else {
			CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pBag;
			CComPtr<IEventPropertyBag> pTmp;

			pBag = varPropValue.punkVal;
			if (!pBag) {
				varPropValue.Clear();
				hrRes = S_FALSE;
			}
		}
	}
	if (hrRes == S_FALSE) {
		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &varPropValue.punkVal);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		varPropValue.vt = VT_UNKNOWN;
		hrRes = m_pTmpDatabase->Add((LPOLESTR) pszPropName,&varPropValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	hrRes = varPropValue.punkVal->QueryInterface(IID_IEventPropertyBag,(LPVOID *) ppProperties);
	_ASSERTE(SUCCEEDED(hrRes));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_SinkProperties(IEventPropertyBag **ppSinkProperties) {
	DEBUG_OBJECT_CHECK

	return (GetProperties(BD_SINKPROPERTIES,ppSinkProperties));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_SourceProperties(IEventPropertyBag **ppSourceProperties) {
	DEBUG_OBJECT_CHECK

	return (GetProperties(BD_SOURCEPROPERTIES,ppSourceProperties));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_EventBindingProperties(IEventPropertyBag **ppBindingProperties) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!ppBindingProperties) {
		return (E_POINTER);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBagShallow(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	*ppBindingProperties = m_pTmpDatabase;
	(*ppBindingProperties)->AddRef();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_Enabled(VARIANT_BOOL *pbEnabled) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pbEnabled) {
		*pbEnabled = VARIANT_TRUE;
	}
	if (!pbEnabled) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_ENABLED),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		hrRes = varPropValue.ChangeType(VT_BOOL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pbEnabled = varPropValue.boolVal;
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_Enabled(VARIANT_BOOL bEnabled) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	varPropValue = bEnabled;
	hrRes = m_pTmpDatabase->Add(BD_ENABLED,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_Enabled(VARIANT_BOOL *pbEnabled) {
	DEBUG_OBJECT_CHECK

	if (!pbEnabled) {
		return (E_POINTER);
	}
	return (put_Enabled(*pbEnabled));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_Expiration(DATE *pdateExpiration) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pdateExpiration) {
		*pdateExpiration = 0.0;
	}
	if (!pdateExpiration) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_EXPIRATION),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	hrRes = varPropValue.ChangeType(VT_DATE);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*pdateExpiration = varPropValue.date;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_Expiration(DATE dateExpiration) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (dateExpiration != 0.0) {
		varPropValue = dateExpiration;
	}
	hrRes = m_pTmpDatabase->Add(BD_EXPIRATION,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_Expiration(DATE *pdateExpiration) {
	DEBUG_OBJECT_CHECK

	if (!pdateExpiration) {
		return (E_POINTER);
	}
	return (put_Expiration(*pdateExpiration));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_MaxFirings(long *plMaxFirings) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (plMaxFirings) {
		*plMaxFirings = 0;
	}
	if (!plMaxFirings) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_MAXFIRINGS),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	hrRes = varPropValue.ChangeType(VT_I4);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*plMaxFirings = varPropValue.lVal;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_MaxFirings(long lMaxFirings) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (lMaxFirings != -1) {
		varPropValue = lMaxFirings;
	}
	hrRes = m_pTmpDatabase->Add(BD_MAXFIRINGS,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_MaxFirings(long *plMaxFirings) {
	DEBUG_OBJECT_CHECK

	if (!plMaxFirings) {
		return (E_POINTER);
	}
	return (put_MaxFirings(*plMaxFirings));
}


HRESULT STDMETHODCALLTYPE CEventBinding::Save() {
	DEBUG_OBJECT_CHECK

	return (SaveImpl(m_strName,m_pDatabase,m_pTmpDatabase,m_pParent));
}


/////////////////////////////////////////////////////////////////////////////
// CEventBindingsEnum
class ATL_NO_VTABLE CEventBindingsEnum :
	public CComObjectRoot,
//	public CComCoClass<CEventBindingsEnum, &CLSID_CEventBindingsEnum>,
	public CEventEnumVARIANTBaseImpl<CEventBinding,CEventBindingsEnum>,
	public CEventEnumUnknownBaseImpl<CEventBinding,CEventBindingsEnum>
{
	DEBUG_OBJECT_DEF(CEventBindingsEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventBindingsEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventBindingsEnum Class",
//								   L"Event.BindingsEnum.1",
//								   L"Event.BindingsEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventBindingsEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventEnumBase
	public:
		virtual HRESULT SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection);
		virtual IUnknown *GetEnum() { _ASSERTE(m_pEnum); return (m_pEnum); };
		virtual IEventPropertyBag *GetCollection() { _ASSERTE(m_pCollection); return (m_pCollection); };

	private:
		CComPtr<IUnknown> m_pEnum;
		CComPtr<IEventPropertyBag> m_pCollection;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventBindingsEnum


HRESULT CEventBindingsEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindingsEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventBindingsEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventBindingsEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindingsEnum::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventBindingsEnum::SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection) {
	DEBUG_OBJECT_CHECK

	if (!pEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	m_pEnum = pEnum;
	m_pCollection = pCollection;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventBindings
class ATL_NO_VTABLE CEventBindings :
	public CComObjectRoot,
//	public CComCoClass<CEventBindings, &CLSID_CEventBindings>,
	public IDispatchImpl<IEventBindings, &IID_IEventBindings, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventBindings)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventBindings);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventBindings Class",
//								   L"Event.Bindings.1",
//								   L"Event.Bindings");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventBindings)
		COM_INTERFACE_ENTRY(IEventBindings)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventBindings)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventBindings
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarDesired, IEventBinding **ppBinding);
		HRESULT STDMETHODCALLTYPE Add(BSTR strBinding, IEventBinding **ppBinding);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventBindings


HRESULT CEventBindings::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindings::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventBindings")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventBindings::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindings::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventBindings::Item(VARIANT *pvarDesired, IEventBinding **ppBinding) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventBinding>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  pvarDesired,
								  IID_IEventBinding,
								  (IUnknown **) ppBinding,
								  FALSE));
}


HRESULT STDMETHODCALLTYPE CEventBindings::Add(BSTR strBinding, IEventBinding **ppBinding) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varName;
	CStringGUID objGuid;

	if (ppBinding) {
		*ppBinding = NULL;
	}
	hrRes = AddImpl1(strBinding,objGuid,&varName);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(varName.vt==VT_BSTR);
	hrRes = Item(&varName,ppBinding);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		return (S_FALSE);
	}
	hrRes = AddImpl2(m_pDatabase,
					 CComObject<CEventBinding>::_CreatorClass::CreateInstance,
					 IID_IEventBinding,
					 &varName,
					 (IUnknown **) ppBinding);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppBinding);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBindings::Remove(VARIANT *pvarDesired) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->Remove(pvarDesired));
}


HRESULT STDMETHODCALLTYPE CEventBindings::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->get_Count(plCount));
}


HRESULT STDMETHODCALLTYPE CEventBindings::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkTmp;
	CComObject<CEventBindingsEnum> *pNewEnum;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = m_pDatabase->get__NewEnum(&pUnkTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CComObject<CEventBindingsEnum>::CreateInstance(&pNewEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewEnum);
	pNewEnum->AddRef();
	hrRes = pNewEnum->SetEnum(pUnkTmp,m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		pNewEnum->Release();
		return (hrRes);
	}
	hrRes = pNewEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppUnkEnum);
	pNewEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppUnkEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventBindingManager


HRESULT CEventBindingManager::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindingManager::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventBindingManager")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventBindingManager::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindingManager::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::get_Bindings(BSTR pszEventType, IEventBindings **ppBindings) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComBSTR strTmp;
	CComPtr<IEventPropertyBag> pEventTypes;
	CComPtr<IEventPropertyBag> pEventType;

	if (ppBindings) {
		*ppBindings = NULL;
	}
	if (!pszEventType || !ppBindings) {
		return (E_POINTER);
	}
	// tbd - verify that pszEventType is a valid event type
	hrRes = CreateSubPropertyBag(m_pDatabase,&CComVariant(BD_EVENTTYPES),&pEventTypes,TRUE);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CreateSubPropertyBag(pEventTypes,&CComVariant(pszEventType),&pEventType,TRUE);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CreatePluggedInObject(CComObject<CEventBindings>::_CreatorClass::CreateInstance,
								  pEventType,
								  &CComVariant(BD_BINDINGS),
								  IID_IEventBindings,
								  (IUnknown **) ppBindings,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pSubKey;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		return (E_FAIL);
	}
	hrRes = CreateSubPropertyBag(m_pDatabase,&CComVariant(BD_EVENTTYPES),&pSubKey,TRUE);
	_ASSERTE(!SUCCEEDED(hrRes)||pSubKey);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (pSubKey->get__NewEnum(ppUnkEnum));
}


#if 0
HRESULT STDMETHODCALLTYPE CEventBindingManager::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varValue;
	CLocker lck;
	CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pSubKey;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		return (E_FAIL);
	}
	hrRes = lck.LockRead(m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = m_pDatabase->Item(&CComVariant(BD_EVENTTYPES),&varValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		lck.Unlock();
		hrRes = lck.LockWrite(m_pDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = m_pDatabase->Item(&CComVariant(BD_EVENTTYPES),&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
									 NULL,
									 CLSCTX_ALL,
									 IID_IUnknown,
									 (LPVOID *) &varValue.punkVal);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			varValue.vt = VT_UNKNOWN;
			hrRes = m_pDatabase->Add(BD_EVENTTYPES,&varValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			varValue.Clear();
			hrRes = m_pDatabase->Item(&CComVariant(BD_EVENTTYPES),&varValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			_ASSERTE(hrRes!=S_FALSE);
			if (hrRes == S_FALSE) {
				return (E_FAIL);
			}
		}
	}
	lck.Unlock();
	pSubKey = varValue.punkVal;
	if (!pSubKey) {
		return (E_NOINTERFACE);
	}
	return (pSubKey->get__NewEnum(ppUnkEnum));
}
#endif


HRESULT STDMETHODCALLTYPE CEventBindingManager::GetClassID(CLSID *pClassID) {
	DEBUG_OBJECT_CHECK

	if (!pClassID) {
		return (E_POINTER);
	}
	*pClassID = CLSID_CEventBindingManager;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::InitNew(void) {
	DEBUG_OBJECT_CHECK

	m_strDatabaseManager.Empty();
	m_pDatabase.Release();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varDictionary;
	CStringGUID objGuid;
	CComPtr<ISEOInitObject> pInit;
	CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pTmp;
	EXCEPINFO ei = {0,0,L"Event.BindingManager",NULL,NULL,0,NULL,NULL,0};

	if (!pPropBag) {
		return (E_POINTER);
	}
	hrRes = pPropBag->Read(L"DatabaseManager",&varDictionary,pErrorLog);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = varDictionary.ChangeType(VT_BSTR);
	if (!SUCCEEDED(hrRes)) {
		if (pErrorLog) {
			ei.scode = hrRes;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (hrRes);
	}
	objGuid.CalcFromProgID(varDictionary.bstrVal);
	if (!objGuid) {
		objGuid = varDictionary.bstrVal;
	}
	if (!objGuid) {
		if (pErrorLog) {
			ei.scode = CO_E_CLASSSTRING;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(objGuid,NULL,CLSCTX_ALL,IID_ISEOInitObject,(LPVOID *) &pInit);
	_ASSERTE(!SUCCEEDED(hrRes)||pInit);
	if (!SUCCEEDED(hrRes)) {
		if (pErrorLog) {
			ei.scode = hrRes;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (hrRes);
	}
	pTmp = pInit;
	if (!pTmp) {
		if (pErrorLog) {
			ei.scode = hrRes;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (E_NOINTERFACE);
	}
	hrRes = pInit->Load(pPropBag,pErrorLog);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = put_Database(pTmp);
	if (!SUCCEEDED(hrRes)) {
		if (pErrorLog) {
			ei.scode = hrRes;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (hrRes);
	}
	m_strDatabaseManager = varDictionary.bstrVal;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::Save(IPropertyBag *pPropBag,
													 BOOL fClearDirty,
													 BOOL fSaveAllProperties) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComQIPtr<ISEOInitObject,&IID_ISEOInitObject> pInit;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!pPropBag) {
		return (E_POINTER);
	}
	pInit = m_pDatabase;
	if (!pInit) {
		return (E_NOINTERFACE);
	}
	hrRes = pInit->Save(pPropBag,fClearDirty,fSaveAllProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pPropBag->Write(L"DatabaseManager",&CComVariant(m_strDatabaseManager));
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::OnChange() {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IConnectionPoint> pCP;
	CComPtr<IEnumConnections> pEnum;

	hrRes = FindConnectionPoint(IID_IEventNotifyBindingChange,&pCP);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	hrRes = pCP->EnumConnections(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	while (1) {
		CONNECTDATA cdNotify;

		hrRes = pEnum->Next(1,&cdNotify,NULL);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (S_OK);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		_ASSERTE(cdNotify.pUnk);
		hrRes = ((IEventNotifyBindingChange *) cdNotify.pUnk)->OnChange();
		_ASSERTE(SUCCEEDED(hrRes));
		cdNotify.pUnk->Release();
	}
	pCP.Release();
	pEnum.Release();
	hrRes = FindConnectionPoint(IID_IEventNotifyBindingChangeDisp,&pCP);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	hrRes = pCP->EnumConnections(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	while (1) {
		CONNECTDATA cdNotify;
		static DISPPARAMS dpArgs = {NULL,NULL,0,0};

		hrRes = pEnum->Next(1,&cdNotify,NULL);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (S_OK);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		_ASSERTE(cdNotify.pUnk);
		hrRes = ((IEventNotifyBindingChangeDisp *) cdNotify.pUnk)->Invoke(1,
																		  IID_NULL,
																		  GetUserDefaultLCID(),
																		  DISPATCH_METHOD,
																		  &dpArgs,
																		  NULL,
																		  NULL,
																		  NULL);
		_ASSERTE(SUCCEEDED(hrRes));
		cdNotify.pUnk->Release();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::Copy(long lTimeout, IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pCopy;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyPropertyBag(m_pDatabase,&pCopy,TRUE,lTimeout);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CreatePluggedInObject(CComObject<CEventBindingManager>::_CreatorClass::CreateInstance,
								  pCopy,
								  &CComVariant(),
								  IID_IEventBindingManager,
								  (IUnknown **) ppBindingManager,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::EmptyCopy(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pCopy;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pCopy);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CreatePluggedInObject(CComObject<CEventBindingManager>::_CreatorClass::CreateInstance,
								  pCopy,
								  &CComVariant(),
								  IID_IEventBindingManager,
								  (IUnknown **) ppBindingManager,
								  TRUE));
}


void CEventBindingManager::AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IConnectionPointContainer> pCPC;

	if (dwCount == 1) {
		if (!m_pDatabase) {
			_ASSERTE(FALSE);
			return;
		}
		if (((CP_ENBC *) this)->GetCount() + ((CP_ENBCD *) this)->GetCount() != 1) {
			return;
		}
		hrRes = m_pDatabase->QueryInterface(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
		if (!SUCCEEDED(hrRes)) {
			return;
		}
		hrRes = pCPC->FindConnectionPoint(IID_IEventNotifyBindingChange,&m_pCP);
		if (!SUCCEEDED(hrRes)) {
			return;
		}
		hrRes = m_pCP->Advise(GetControllingUnknown(),&m_dwCPCookie);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			m_pCP.Release();
			return;
		}
	}
}


void CEventBindingManager::UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (dwCount == 0) {
		if (!m_pDatabase) {
			_ASSERTE(FALSE);
			return;
		}
		if (!m_pCP) {
			return;
		}
		if (((CP_ENBC *) this)->GetCount() + ((CP_ENBCD *) this)->GetCount() != 0) {
			return;
		}
		hrRes = m_pCP->Unadvise(m_dwCPCookie);
		_ASSERTE(SUCCEEDED(hrRes));
		m_pCP.Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CEventDatabasePlugin


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::get_Database(IEventPropertyBag **ppDatabase) {

	if (!ppDatabase) {
		return (E_POINTER);
	}
	*ppDatabase = m_pDatabase;
	if (*ppDatabase) {
		(*ppDatabase)->AddRef();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::put_Database(IEventPropertyBag *pDatabase) {

	m_pDatabase = pDatabase;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::putref_Database(IEventPropertyBag **ppDatabase) {

	if (!ppDatabase) {
		return (E_POINTER);
	}
	return (put_Database(*ppDatabase));
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::get_Name(BSTR *pstrName) {

	if (!pstrName) {
		return (E_POINTER);
	}
	*pstrName = SysAllocString(m_strName);
	if (!*pstrName && m_strName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::put_Name(BSTR strName) {

	m_strName = strName;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::putref_Name(BSTR *pstrName) {

	if (!pstrName) {
		return (E_POINTER);
	}
	return (put_Name(*pstrName));
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::get_Parent(IEventPropertyBag **ppParent) {

	if (!ppParent) {
		return (E_POINTER);
	}
	*ppParent = m_pParent;
	if (*ppParent) {
		(*ppParent)->AddRef();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::put_Parent(IEventPropertyBag *pParent) {

	m_pParent = pParent;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::putref_Parent(IEventPropertyBag **ppParent) {

	if (!ppParent) {
		return (E_POINTER);
	}
	return (put_Parent(*ppParent));
}


/////////////////////////////////////////////////////////////////////////////
// CEventMetabaseDatabaseManager


HRESULT CEventMetabaseDatabaseManager::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventMetabaseDatabaseManager::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventMetabaseDatabaseManager")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventMetabaseDatabaseManager::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventMetabaseDatabaseManager::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventMetabaseDatabaseManager::CreateDatabase(BSTR strPath, IUnknown **ppMonDatabase) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComBSTR strTmp;
	CComPtr<IBindCtx> pBindCtx;
	DWORD dwEaten;
	CComPtr<IEventPropertyBag> pDatabase;
	CComVariant varDatabase;
	BOOL bExisted = FALSE;

	if (ppMonDatabase) {
		*ppMonDatabase = NULL;
	}
	if (!ppMonDatabase) {
		return (E_POINTER);
	}
	hrRes = CoCreateInstance(CLSID_CSEOMetaDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pDatabase->Item(&CComVariant(strPath),&varDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		CComVariant varTmp;

		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &varTmp.punkVal);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		varTmp.vt = VT_UNKNOWN;
		hrRes = pDatabase->Add(strPath,&varTmp);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	} else {
		bExisted = TRUE;
	}
	strTmp = L"@SEO.SEOGenericMoniker: MonikerType=Event.BindingManager DatabaseManager=SEO.SEOMetaDictionary MetabasePath=";
	strTmp.Append(strPath);
	hrRes = CreateBindCtx(0,&pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = MkParseDisplayName(pBindCtx,strTmp,&dwEaten,(IMoniker **) ppMonDatabase);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppMonDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (bExisted?S_FALSE:S_OK);
}


HRESULT STDMETHODCALLTYPE CEventMetabaseDatabaseManager::EraseDatabase(BSTR strPath) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pDatabase;

	hrRes = CoCreateInstance(CLSID_CSEOMetaDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pDatabase->Remove(&CComVariant(strPath));
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


#define DW2W(x) _itow(x,(LPWSTR) _alloca(11*sizeof(WCHAR)),10)


HRESULT STDMETHODCALLTYPE CEventMetabaseDatabaseManager::MakeVServerPath(BSTR strService, long lInstance, BSTR *pstrPath) {
	DEBUG_OBJECT_CHECK
	CComBSTR strTmp;

	if (pstrPath) {
		*pstrPath = NULL;
	}
	if (!pstrPath) {
		return (E_POINTER);
	}
	if (!strService || !*strService || (lInstance < 0)) {
		return (E_INVALIDARG);
	}
	strTmp = L"LM/";
	strTmp.Append(strService);
	strTmp.Append(L"/");
	strTmp.Append(DW2W(lInstance));
	strTmp.Append(L"/EventManager");
	*pstrPath = strTmp.Detach();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventMetabaseDatabaseManager::MakeVRootPath(BSTR strService, long lInstance, BSTR strRoot, BSTR *pstrPath) {
	DEBUG_OBJECT_CHECK
	CComBSTR strTmp;

	if (pstrPath) {
		*pstrPath = NULL;
	}
	if (!pstrPath) {
		return (E_POINTER);
	}
	if (!strService || !*strService || (lInstance < 0) || !strRoot || !*strRoot) {
		return (E_INVALIDARG);
	}
	strTmp = L"LM/";
	strTmp.Append(strService);
	strTmp.Append(L"/");
	strTmp.Append(DW2W(lInstance));
	strTmp.Append(L"/root/");
	strTmp.Append(strRoot);
	strTmp.Append(L"/EventManager");
	*pstrPath = strTmp.Detach();
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventUtil


HRESULT CEventUtil::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventUtil::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventUtil")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventUtil::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventUtil::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventUtil::DisplayNameFromMoniker(IUnknown *pUnkMoniker,	
															 BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IMoniker> pMoniker;
	CComPtr<IBindCtx> pBindCtx;
	LPWSTR pszDisplayName;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pUnkMoniker || !pstrDisplayName) {
		return (E_POINTER);
	}
	hrRes = pUnkMoniker->QueryInterface(IID_IMoniker,(LPVOID *) &pMoniker);
	_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CreateBindCtx(0,&pBindCtx);
	_ASSERTE(!SUCCEEDED(hrRes)||pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pMoniker->GetDisplayName(pBindCtx,NULL,&pszDisplayName);
	_ASSERTE(!SUCCEEDED(hrRes)||pszDisplayName);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*pstrDisplayName = SysAllocString(pszDisplayName);
	CoTaskMemFree(pszDisplayName);
	if (!pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::MonikerFromDisplayName(BSTR strDisplayName,
															 IUnknown **ppUnkMoniker) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IBindCtx> pBindCtx;
	DWORD dwEaten;

	if (ppUnkMoniker) {
		*ppUnkMoniker = NULL;
	}
	if (!strDisplayName || !ppUnkMoniker) {
		return (E_POINTER);
	}
#if 0
	hrRes = CreateBindCtx(0,&pBindCtx);
	_ASSERTE(!SUCCEEDED(hrRes)||pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = MkParseDisplayNameEx(pBindCtx,strDisplayName,&dwEaten,(IMoniker **) ppUnkMoniker);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkMoniker);
	if (SUCCEEDED(hrRes)) {
		_ASSERTE(!*ppUnkMoniker);
		return (S_OK);
	}
	pBindCtx.Release();
#endif
	hrRes = CreateBindCtx(0,&pBindCtx);
	_ASSERTE(!SUCCEEDED(hrRes)||pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = MkParseDisplayName(pBindCtx,strDisplayName,&dwEaten,(IMoniker **) ppUnkMoniker);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkMoniker);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(!*ppUnkMoniker);
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::ObjectFromMoniker(IUnknown *pUnkMoniker, IUnknown **ppUnkObject) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IMoniker> pMoniker;
	CComPtr<IBindCtx> pBindCtx;

	if (ppUnkObject) {
		*ppUnkObject = NULL;
	}
	if (!pUnkMoniker || !ppUnkObject) {
		return (E_POINTER);
	}
	hrRes = pUnkMoniker->QueryInterface(IID_IMoniker,(LPVOID *) &pMoniker);
	_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CreateBindCtx(0,&pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pMoniker->BindToObject(pBindCtx,NULL,IID_IUnknown,(LPVOID *) ppUnkObject);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkObject);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(!*ppUnkObject);
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::GetNewGUID(BSTR *pstrGUID) {
	DEBUG_OBJECT_CHECK
	CStringGUID objGuid;

	if (pstrGUID) {
		*pstrGUID = NULL;
	}
	if (!pstrGUID) {
		return (E_POINTER);
	}
	objGuid.CalcNew();
	if (!objGuid) {
		return (E_OUTOFMEMORY);
	}
	*pstrGUID = SysAllocString(objGuid);
	if (!*pstrGUID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::CopyPropertyBag(IUnknown *pUnkInput, IUnknown **ppUnkOutput) {
	DEBUG_OBJECT_CHECK
	CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pInput;

	if (ppUnkOutput) {
		*ppUnkOutput = NULL;
	}
	if (!pUnkInput || !ppUnkOutput) {
		return (E_POINTER);
	}
	pInput = pUnkInput;
	if (!pInput) {
		return (E_NOINTERFACE);
	}
	return (::CopyPropertyBag(pInput,(IEventPropertyBag **) ppUnkOutput));
}


HRESULT STDMETHODCALLTYPE CEventUtil::CopyPropertyBagShallow(IUnknown *pUnkInput, IUnknown **ppUnkOutput) {
	DEBUG_OBJECT_CHECK
	CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pInput;

	if (ppUnkOutput) {
		*ppUnkOutput = NULL;
	}
	if (!pUnkInput || !ppUnkOutput) {
		return (E_POINTER);
	}
	pInput = pUnkInput;
	if (!pInput) {
		return (E_NOINTERFACE);
	}
	return (::CopyPropertyBagShallow(pInput,(IEventPropertyBag **) ppUnkOutput));
}


HRESULT STDMETHODCALLTYPE CEventUtil::DispatchFromObject(IUnknown *pUnkObject, IDispatch **ppDispOutput) {
	DEBUG_OBJECT_CHECK

	if (ppDispOutput) {
		*ppDispOutput = NULL;
	}
	if (!pUnkObject || !ppDispOutput) {
		return (E_POINTER);
	}
	return (pUnkObject->QueryInterface(IID_IDispatch,(LPVOID *) ppDispOutput));
}


HRESULT STDMETHODCALLTYPE CEventUtil::GetIndexedGUID(BSTR strGUID, long lIndex, BSTR *pstrResult) {
	DEBUG_OBJECT_CHECK
	CStringGUID guidGUID;
	CStringGUID guidNew;

	if (pstrResult) {
		*pstrResult = NULL;
	}
	if (!strGUID || !pstrResult) {
		return (E_POINTER);
	}
	guidGUID.Assign(strGUID);
	if (!guidGUID) {
		return (E_INVALIDARG);
	}
	guidNew.Assign(guidGUID,(DWORD) lIndex);
	if (!guidNew) {
		return (E_FAIL);
	}
	*pstrResult = SysAllocString(guidNew);
	if (!*pstrResult) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::RegisterSource(BSTR strSourceType,
													 BSTR strSource,
													 long lInstance,
													 BSTR strService,
													 BSTR strVRoot,
													 BSTR strDatabaseManager,
													 BSTR strDisplayName,
													 IEventBindingManager **ppBindingManager) {
	HRESULT hrRes;
	CStringGUID guidSource;
	CComPtr<IEventManager> pEventManager;
	CComPtr<IEventSourceTypes> pSourceTypes;
	CComPtr<IEventSourceType> pSourceType;
	CComPtr<IEventSources> pSources;
	CComPtr<IEventSource> pSource;
	CComPtr<IEventDatabaseManager> pDatabaseManager;

	if (ppBindingManager) {
		*ppBindingManager = NULL;
	}
	if (!strSourceType || !strSource || !strService || !strDatabaseManager || !ppBindingManager) {
		return (E_POINTER);
	}
	if (lInstance == -1) {
		guidSource = strSource;
	} else {
		CStringGUID guidTmp;

		guidTmp = strSource;
		if (!guidTmp) {
			return (E_INVALIDARG);
		}
		guidSource.Assign(guidTmp,lInstance);
	}
	if (!guidSource) {
		return (E_INVALIDARG);
	}
	hrRes = CoCreateInstance(CLSID_CEventManager,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventManager,
							 (LPVOID *) &pEventManager);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pEventManager->get_SourceTypes(&pSourceTypes);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pSourceTypes->Item(&CComVariant(strSourceType),&pSourceType);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (SEO_E_NOTPRESENT);
	}
	hrRes = pSourceType->get_Sources(&pSources);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pSources->Add(CComBSTR((LPCWSTR) guidSource),&pSource);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_OK) {
		VARIANT varDatabaseManager;
		CComBSTR strPath;
		CComPtr<IUnknown> pPath;

		varDatabaseManager.vt = VT_BSTR | VT_BYREF;
		varDatabaseManager.pbstrVal = &strDatabaseManager;
		hrRes = SEOCreateObject(&varDatabaseManager,
								NULL,
								NULL,
								IID_IEventDatabaseManager,
								(IUnknown **) &pDatabaseManager);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (strVRoot && strVRoot[0]) {
			hrRes = pDatabaseManager->MakeVRootPath(strService,lInstance,strVRoot,&strPath);
		} else {
			hrRes = pDatabaseManager->MakeVServerPath(strService,lInstance,&strPath);
		}
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pDatabaseManager->CreateDatabase(strPath,&pPath);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pSource->put_BindingManagerMoniker(pPath);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (strDisplayName) {
			hrRes = pSource->put_DisplayName(strDisplayName);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		hrRes = pSource->Save();
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	hrRes = pSource->GetBindingManager(ppBindingManager);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventComCat


HRESULT CEventComCat::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventComCat::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventComCat")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventComCat::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventComCat::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventComCat::RegisterCategory(BSTR pszCategory, BSTR pszDescription, long lcidLanguage) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CATEGORYINFO ci;
	CStringGUID objCat;

	if (!pszCategory || !pszDescription) {
		return (E_POINTER);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	if (wcslen(pszDescription) > sizeof(ci.szDescription)/sizeof(ci.szDescription[0])-1) {
		return (E_INVALIDARG);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	memset(&ci,0,sizeof(ci));
	ci.catid = objCat;
	ci.lcid = lcidLanguage;
	wcscpy(ci.szDescription,pszDescription);
	hrRes = pCatReg->RegisterCategories(1,&ci);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::UnRegisterCategory(BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objCat;

	if (!pszCategory) {
		return (E_POINTER);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->UnRegisterCategories(1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::RegisterClassImplementsCategory(BSTR pszClass, BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objClass;
	CStringGUID objCat;

	if (!pszClass || !pszCategory) {
		return (E_POINTER);
	}
	objClass = pszClass;
	if (!objClass) {
		return (CO_E_CLASSSTRING);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->RegisterClassImplCategories(objClass,1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::UnRegisterClassImplementsCategory(BSTR pszClass, BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objClass;
	CStringGUID objCat;

	if (!pszClass || !pszCategory) {
		return (E_POINTER);
	}
	objClass = pszClass;
	if (!objClass) {
		return (CO_E_CLASSSTRING);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->UnRegisterClassImplCategories(objClass,1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::RegisterClassRequiresCategory(BSTR pszClass, BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objClass;
	CStringGUID objCat;

	if (!pszClass || !pszCategory) {
		return (E_POINTER);
	}
	objClass = pszClass;
	if (!objClass) {
		return (CO_E_CLASSSTRING);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->RegisterClassReqCategories(objClass,1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::UnRegisterClassRequiresCategory(BSTR pszClass, BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objClass;
	CStringGUID objCat;

	if (!pszClass || !pszCategory) {
		return (E_POINTER);
	}
	objClass = pszClass;
	if (!objClass) {
		return (CO_E_CLASSSTRING);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->UnRegisterClassReqCategories(objClass,1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::GetCategories(SAFEARRAY **ppsaCategories) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatInformation> pCatInfo;
	CComPtr<IEnumCATEGORYINFO> pEnum;
	DWORD dwTmp;
	DWORD dwAlloc = 0;
	CATEGORYINFO *pci = NULL;

	if (ppsaCategories) {
		*ppsaCategories = NULL;
	}
	if (!ppsaCategories) {
		return (E_POINTER);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &pCatInfo);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatInfo);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatInfo->EnumCategories(LOCALE_NEUTRAL,&pEnum);
	_ASSERTE(!SUCCEEDED(hrRes)||pEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = S_FALSE;
	while (1) {
		dwTmp = (hrRes==S_FALSE) ? 1 : dwAlloc;
		if (!MyReallocInPlace(&pci,sizeof(*pci)*(dwAlloc+dwTmp))) {
			MyFree(pci);
			return (E_OUTOFMEMORY);
		}
		hrRes = pEnum->Next(dwTmp,&pci[dwAlloc],&dwTmp);
		// Do not alter hrRes between here and the bottom of the loop!  The first statement
		// in the loop relies on hrRes having the result from this call to IEnumCLSID::Next.
		if (!SUCCEEDED(hrRes)) {
			MyFree(pci);
			return (hrRes);
		}
		if (!dwTmp) {
			break;
		}
		dwAlloc += dwTmp;
	}
	*ppsaCategories = SafeArrayCreateVector(VT_VARIANT,1,dwAlloc);
	if (!*ppsaCategories) {
		MyFree(pci);
		return (E_OUTOFMEMORY);
	}
	_ASSERTE(SafeArrayGetDim(*ppsaCategories)==1);
	_ASSERTE(SafeArrayGetElemsize(*ppsaCategories)==sizeof(VARIANT));
	hrRes = SafeArrayLock(*ppsaCategories);
	_ASSERTE(SUCCEEDED(hrRes));
	if (SUCCEEDED(hrRes)) {
		HRESULT hrResTmp;

		for (dwTmp=1;dwTmp<=dwAlloc;dwTmp++) {
			CStringGUID objGuid;
			VARIANT *pvarElt;

			objGuid = pci[dwTmp-1].catid;
			if (!objGuid) {
				hrRes = E_OUTOFMEMORY;
				break;
			}
			pvarElt = NULL;
			hrRes = SafeArrayPtrOfIndex(*ppsaCategories,(long *) &dwTmp,(LPVOID *) &pvarElt);
			_ASSERTE(!SUCCEEDED(hrRes)||pvarElt);
			if (!SUCCEEDED(hrRes)) {
				break;
			}
			pvarElt->bstrVal = SysAllocString(objGuid);
			if (!pvarElt->bstrVal) {
				hrRes = E_OUTOFMEMORY;
				break;
			}
			pvarElt->vt = VT_BSTR;
		}
		hrResTmp = SafeArrayUnlock(*ppsaCategories);
		_ASSERTE(SUCCEEDED(hrResTmp));
		if (!SUCCEEDED(hrResTmp) && SUCCEEDED(hrRes)) {
			hrRes = hrResTmp;
		}
	}
	MyFree(pci);
	if (!SUCCEEDED(hrRes)) {
		SafeArrayDestroy(*ppsaCategories);
		*ppsaCategories = NULL;
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventComCat::GetCategoryDescription(BSTR pszCategory,
															   long lcidLanguage,
															   BSTR *pstrDescription) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatInformation> pCatInfo;
	CStringGUID objCat;
	LPWSTR pszDesc;

	if (pstrDescription) {
		*pstrDescription = NULL;
	}
	if (!pszCategory || !pstrDescription) {
		return (E_POINTER);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &pCatInfo);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatInfo);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pszDesc = NULL;
	hrRes = pCatInfo->GetCategoryDesc(objCat,lcidLanguage,&pszDesc);
	_ASSERTE(!SUCCEEDED(hrRes)||pszDesc);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(!pszDesc);
		return (hrRes);
	}
	*pstrDescription = SysAllocString(pszDesc);
	CoTaskMemFree(pszDesc);
	if (!*pstrDescription) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventRouterInternal
class ATL_NO_VTABLE CEventRouterInternal :
	public CComObjectRoot,
//	public CComCoClass<CEventRouterInternal, &CLSID_CEventRouterInternal>,
	public IEventRouter,
	public IEventNotifyBindingChange
{
	DEBUG_OBJECT_DEF(CEventRouterInternal)
	private:
		class CDispatcher {
			DEBUG_OBJECT_DEF2(CDispatcher,"CEventRouterInternal::CDispatcher",CEventRouterInternal__CDispatcher)
			public:
				CDispatcher();
				virtual ~CDispatcher();
				HRESULT Init(REFCLSID clsidDispatcher, IClassFactory *pClassFactory);
				BOOL HasEventType(REFIID iidEventType);
				HRESULT AddEventType(REFIID iidEventType, IEventRouter *piRouter, IEventBindingManager *piManager);
				HRESULT GetDispatcher(REFIID iidDesired, LPVOID *ppvDispatcher);
				REFCLSID GetCLSID() { return (m_clsidDispatcher); };
				void SetPreload(IEnumGUID *pEnumPreload) {
					m_pEnumPreload = pEnumPreload;
				};
			private:
				CLSID m_clsidDispatcher;
				DWORD m_dwEventTypes;
				IID *m_aiidEventTypes;
				CComQIPtr<IEventDispatcher,&IID_IEventDispatcher> m_pDispatcher;
				CComPtr<IUnknown> m_pUnkDispatcher;
				CComPtr<IEnumGUID> m_pEnumPreload;
		};

	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		BOOL FindDispatcher(REFCLSID clsidDispatcher, REFIID iidEventType, CDispatcher **ppDispatcher);
		HRESULT AddDispatcher(REFCLSID clsidDispatcher, IClassFactory *pClassFactory, REFIID iidEventType, CDispatcher **ppDispatcher);
		void PutDatabaseImpl(IEventBindingManager *pBindingManager, int iTimeout);
		void MakeBindingManagerCopy(int iTimeout, BOOL bRequired);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventRouterInternal);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventRouterInternal Class",
//								   L"Event.RouterInternal.1",
//								   L"Event.RouterInternal");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventRouterInternal)
		COM_INTERFACE_ENTRY(IEventRouter)
		COM_INTERFACE_ENTRY(IEventNotifyBindingChange)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IEventLock, m_pLock.p)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventRouter
	public:
		HRESULT STDMETHODCALLTYPE get_Database(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE put_Database(IEventBindingManager *pBindingManager);
		HRESULT STDMETHODCALLTYPE putref_Database(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE GetDispatcher(REFIID iidEvent,
												REFIID iidDesired,
												IUnknown **ppUnkResult);
		HRESULT STDMETHODCALLTYPE GetDispatcherByCLSID(REFCLSID clsidDispatcher,
													   REFIID iidEvent,
													   REFIID iidDesired,
													   IUnknown **ppUnkResult);
		HRESULT STDMETHODCALLTYPE GetDispatcherByClassFactory(REFCLSID clsidDispatcher,
															  IClassFactory *piClassFactory,
															  REFIID iidEvent,
															  REFIID iidDesired,
															  IUnknown **ppUnkResult);

	// IEventNotifyBindingChange
	public:
		HRESULT STDMETHODCALLTYPE OnChange();

	private:
		class CDispatchers : public CSEOGrowableList<CDispatcher> {
			// tbd - override various members
		};
		CDispatchers m_Dispatchers;
		CComPtr<IEventBindingManager> m_pBindingManager;
		CComPtr<IEventBindingManager> m_pBindingManagerCopy;
		BOOL m_bMakeNewCopy;
		CComPtr<IEventLock> m_pLock;
		CComPtr<IUnknown> m_pUnkMarshaler;
		CComPtr<IConnectionPoint> m_pCP;
		DWORD m_dwCookie;
};


HRESULT CEventRouterInternal::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventRouterInternal::FinalConstruct");
	HRESULT hrRes = S_OK;

	m_bMakeNewCopy = TRUE;
	hrRes = CoCreateInstance(CLSID_CEventLock,NULL,CLSCTX_ALL,IID_IEventLock,(LPVOID *) &m_pLock);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	ADD_DEBUG_OBJECT("CEventRouterInternal")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventRouterInternal::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventRouterInternal::FinalRelease");

	put_Database(NULL);
	m_pBindingManager.Release();
	m_pBindingManagerCopy.Release();
	m_pLock.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


BOOL CEventRouterInternal::FindDispatcher(REFCLSID clsidDispatcher, REFIID iidEventType, CDispatcher **ppDispatcher) {
	DEBUG_OBJECT_CHECK

	if (ppDispatcher) {
		*ppDispatcher = NULL;
	}
	if (!ppDispatcher) {
		return (E_POINTER);
	}
	for (DWORD dwIdx=0;dwIdx<m_Dispatchers.Count();dwIdx++) {
		if (m_Dispatchers[dwIdx].GetCLSID() == clsidDispatcher) {
			if (m_Dispatchers[dwIdx].HasEventType(iidEventType)) {
				*ppDispatcher = m_Dispatchers.Index(dwIdx);
				return (TRUE);
			}
			return (FALSE);
		}
	}
	return (FALSE);
}


HRESULT CEventRouterInternal::AddDispatcher(REFCLSID clsidDispatcher, IClassFactory *pClassFactory, REFIID iidEventType, CDispatcher **ppDispatcher) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CDispatcher *pTmp;

	if (ppDispatcher) {
		*ppDispatcher = NULL;
	}
	if (!ppDispatcher) {
		return (E_POINTER);
	}
	MakeBindingManagerCopy(LOCK_TIMEOUT,TRUE);
	for (DWORD dwIdx=0;dwIdx<m_Dispatchers.Count();dwIdx++) {
		if (m_Dispatchers[dwIdx].GetCLSID() == clsidDispatcher) {
			hrRes = m_Dispatchers[dwIdx].AddEventType(iidEventType,this,m_pBindingManagerCopy);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			*ppDispatcher = m_Dispatchers.Index(dwIdx);
			return (S_OK);
		}
	}
	pTmp = new CDispatcher;
	if (!pTmp) {
		return (E_OUTOFMEMORY);
	}
	hrRes = pTmp->Init(clsidDispatcher,pClassFactory);
	if (!SUCCEEDED(hrRes)) {
		delete pTmp;
		return (hrRes);
	}
	hrRes = m_Dispatchers.Add(pTmp);
	if (!SUCCEEDED(hrRes)) {
		delete pTmp;
		return (hrRes);
	}
	hrRes = pTmp->AddEventType(iidEventType,this,m_pBindingManagerCopy);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppDispatcher = pTmp;
	return (S_OK);
}


void CEventRouterInternal::PutDatabaseImpl(IEventBindingManager *pBindingManager, int iTimeout) {
	DEBUG_OBJECT_CHECK
	BOOL bDoAdvise = FALSE;
	HRESULT hrRes;

	m_bMakeNewCopy = TRUE;
	if (m_pBindingManager != pBindingManager) {
		bDoAdvise = TRUE;
	}
	if (pBindingManager) {
		pBindingManager->AddRef();
	}
	if (m_pBindingManager) {
		m_Dispatchers.RemoveAll();
		if (bDoAdvise) {
			if (m_pCP) {
				hrRes = m_pCP->Unadvise(m_dwCookie);
				_ASSERTE(SUCCEEDED(hrRes));
				m_pCP.Release();
			}
		}
	}
	if (bDoAdvise) {
		m_pBindingManagerCopy.Release();
	}
	m_pBindingManager = pBindingManager;
	if (m_pBindingManager) {
		if (bDoAdvise) {
			CComQIPtr<IConnectionPointContainer,&IID_IConnectionPointContainer> pCPC;
			
			pCPC = m_pBindingManager;
			if (pCPC) {
				hrRes = pCPC->FindConnectionPoint(IID_IEventNotifyBindingChange,&m_pCP);
				if (SUCCEEDED(hrRes)) {
					hrRes = m_pCP->Advise(GetControllingUnknown(),&m_dwCookie);
					_ASSERTE(SUCCEEDED(hrRes));
					if (!SUCCEEDED(hrRes)) {
						m_pCP.Release();
					}
				}
			}
		}
		MakeBindingManagerCopy(iTimeout,FALSE);
	}
	if (pBindingManager) {
		pBindingManager->Release();
	}
}


void CEventRouterInternal::MakeBindingManagerCopy(int iTimeout, BOOL bRequired) {
	HRESULT hrRes;
	CComQIPtr<IEventBindingManagerCopier, &IID_IEventBindingManagerCopier> pCopier;
	CComPtr<IEventBindingManager> pNewCopy;

	_ASSERTE(m_pBindingManager);
	if (!m_bMakeNewCopy) {
		return;
	}
	pCopier = m_pBindingManager;
	_ASSERTE(pCopier);
	if (!pCopier) {
		// We couldn't QI' for IEventBindingManagerCopier, so just use the
		// current event binding manager without attempting to make a copy.
		m_pBindingManagerCopy = m_pBindingManager;
		goto done;
	}
	hrRes = pCopier->Copy(iTimeout,&pNewCopy);
	_ASSERTE(SUCCEEDED(hrRes)||(hrRes==SEO_E_TIMEOUT));
	if (SUCCEEDED(hrRes)) {
		// We successfully made a copy of the binding event manager.
		m_pBindingManagerCopy = pNewCopy;
		goto done;
	}
	if (!bRequired) {
		// We don't actually an event binding manager yet, so just exit while
		// leaving m_bMakeNewCopy==TRUE.
		return;
	}
	if (m_pBindingManagerCopy) {
		// Since we must have an event binding manager, and since we already have
		// an old copy, just continue using the old copy and forget about making
		// a new copy.
		goto done;
	}
	// Ok - we must have an event binding manager.  And we don't have an old copy
	// we can use.  So, just create a completely empty copy.
	m_pBindingManagerCopy.Release();
	hrRes = pCopier->EmptyCopy(&m_pBindingManagerCopy);
	_ASSERTE(SUCCEEDED(hrRes));
	if (!SUCCEEDED(hrRes)) {
		// Arrgg!  We even failed to make the empty copy.  We are really in trouble.
		// So just use the event binding manager directly, without making a copy.
		m_pBindingManagerCopy = m_pBindingManager;
	}
done:
	// The only case where we don't want to reset this flag is where we failed
	// to make a copy, but we weren't required to make a copy either - in that
	// case, we took an early return from the method.  In all other case, we
	// want to reset this flag to prevent any further attempts at making a
	// copy.
	m_bMakeNewCopy = FALSE;
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::get_Database(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (ppBindingManager) {
		*ppBindingManager = NULL;
	}
	if (!ppBindingManager) {
		return (E_POINTER);
	}
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppBindingManager = m_pBindingManager;
	if (!ppBindingManager) {
		(*ppBindingManager)->AddRef();
	}
	m_pLock->UnlockRead();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::put_Database(IEventBindingManager *pBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	hrRes = m_pLock->LockWrite(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	PutDatabaseImpl(pBindingManager,LOCK_TIMEOUT);
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::putref_Database(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK

	if (!ppBindingManager) {
		return (E_POINTER);
	}
	return (put_Database(*ppBindingManager));
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::GetDispatcher(REFIID iidEventType,
															  REFIID iidDesired,
															  IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	return (GetDispatcherByCLSID(iidEventType,iidEventType,iidDesired,ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::GetDispatcherByCLSID(REFCLSID clsidDispatcher,
																	 REFIID iidEventType,
																	 REFIID iidDesired,
																	 IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	return (GetDispatcherByClassFactory(clsidDispatcher,
										NULL,
										iidEventType,
										iidDesired,
										ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::GetDispatcherByClassFactory(REFCLSID clsidDispatcher,
																			IClassFactory *pClassFactory,
																			REFIID iidEventType,
																			REFIID iidDesired,
																			IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CDispatcher *pDispatcher;
	CLocker cLock;

	if (ppUnkResult) {
		*ppUnkResult = NULL;
	}
	if (!ppUnkResult) {
		return (E_POINTER);
	}
	hrRes = cLock.LockRead(m_pLock);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (FindDispatcher(clsidDispatcher,iidEventType,&pDispatcher)) {
		hrRes = pDispatcher->GetDispatcher(iidDesired,(LPVOID *) ppUnkResult);
		return (hrRes);
	}
	cLock.Unlock();
	hrRes = cLock.LockWrite(m_pLock);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = AddDispatcher(clsidDispatcher,pClassFactory,iidEventType,&pDispatcher);
	if (SUCCEEDED(hrRes)) {
		hrRes = pDispatcher->GetDispatcher(iidDesired,(LPVOID *) ppUnkResult);
	}
	return (hrRes);
}


class CDispSave {
	private:
		CDispSave(IClassFactory *pCF, REFCLSID rclsid) {

			if (pCF) {
				m_pCF = pCF;
				m_clsid = rclsid;
			} else {
				m_clsid = GUID_NULL;
			}
		};
		~CDispSave() {
			// nothing
		};
	public:
		static void Init(CDispSave *pNew, IClassFactory *pCF, REFCLSID rclsid) {
			new(pNew) CDispSave(pCF,rclsid);
		};
		static void Term(CDispSave *pDisp) {
			pDisp->~CDispSave();
		};
	public:
		CComPtr<IClassFactory> m_pCF;
		GUID m_clsid;
};


HRESULT STDMETHODCALLTYPE CEventRouterInternal::OnChange() {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes = S_OK;
	CDispSave *pSave = NULL;
	DWORD dwSaveCount;
	DWORD dwIdx;

	hrRes = m_pLock->LockWrite(LOCK_TIMEOUT_SHORT);
	_ASSERTE(SUCCEEDED(hrRes));
	if (!SUCCEEDED(hrRes)) {
		return (S_OK);
	}
	// First, let's go through and make a copy of (some of) the dispatcher info that's
	// in this router.  We do this by allocating an array of objects on the stack...
	dwSaveCount = m_Dispatchers.Count();
	pSave = (CDispSave *) _alloca(sizeof(CDispSave)*dwSaveCount);
	if (pSave) {
		// Now we initialize each of the objects.
		for (dwIdx=0;dwIdx<dwSaveCount;dwIdx++) {
			CComPtr<IClassFactory> pCF;

			// The Init() routine wants either an IClassFactory or a NULL value.
			hrRes = m_Dispatchers[dwIdx].GetDispatcher(IID_IClassFactory,(LPVOID *) &pCF);
			CDispSave::Init(&pSave[dwIdx],pCF,m_Dispatchers[dwIdx].GetCLSID());
			pCF.Release();
		}
	}
	PutDatabaseImpl(m_pBindingManager,LOCK_TIMEOUT_SHORT);
	if (pSave) {
		// Now we do the pre-loading...
		for (dwIdx=0;dwIdx<dwSaveCount;dwIdx++) {
			// If the previous dispatcher implements IClassFactory...
			if (pSave[dwIdx].m_pCF) {
				CDispatcher *pDisp;
				CComPtr<IEventDispatcherChain> pChain;
				CComPtr<IUnknown> pUnkEnum;
				CComQIPtr<IEnumGUID,&IID_IEnumGUID> pEnum;
				IID iidEventType;

				// ...then use the previous dispatcher to create a new dispatcher.
				hrRes = AddDispatcher(pSave[dwIdx].m_clsid,pSave[dwIdx].m_pCF,GUID_NULL,&pDisp);
				_ASSERTE(SUCCEEDED(hrRes));
				if (SUCCEEDED(hrRes)) {
					// Now, if the new dispatcher implements IEventDispatcherChain...
					hrRes = pDisp->GetDispatcher(IID_IEventDispatcherChain,(LPVOID *) &pChain);
				}
				if (pChain) {
					// ... then call the new dispatcher's IEventDispatcherChain::SetPrevious method.
					hrRes = pChain->SetPrevious(pSave[dwIdx].m_pCF,&pUnkEnum);
				}
				if (pUnkEnum) {
					// If the IEventDispatcherChain::SetPrevious method returned an object...
					pEnum = pUnkEnum;
				}
				if (pEnum) {
					// ... and if that object implements IEnumGUID...
					if (!m_bMakeNewCopy) {
						// ... and if we have a binding manager copy now...
						while (pEnum->Next(1,&iidEventType,NULL) == S_OK) {
							// ... then we loop through the GUID's and add each of them as an
							// event type (which causes the new dispatcher's IEventDispatcher::SetContext
							// method to be called).
							hrRes = pDisp->AddEventType(iidEventType,this,m_pBindingManagerCopy);
							_ASSERTE(SUCCEEDED(hrRes));
						}
					} else {
						// If we don't have a binding manager copy, then set it up so
						// that we'll do the event type pre-loading on the first
						// event fired to the new dispatcher.
						pDisp->SetPreload(pEnum);
					}
				}
				pChain.Release();
				pUnkEnum.Release();
				pEnum.Release();
			}
		}
	}
	if (pSave) {
		for (dwIdx=0;dwIdx<dwSaveCount;dwIdx++) {
			// Be sure to clean-up the array of objects on the stack - if we
			// don't do this explicitly, then we would leak ref-counts on the
			// old dispatcher(s).
			CDispSave::Term(&pSave[dwIdx]);
		}
	}
	m_pLock->UnlockWrite();
	return (S_OK);
}


CEventRouterInternal::CDispatcher::CDispatcher() {
	DEBUG_OBJECT_CHECK

	m_dwEventTypes = 0;
	m_aiidEventTypes = NULL;
}


CEventRouterInternal::CDispatcher::~CDispatcher() {
	DEBUG_OBJECT_CHECK

	if (m_aiidEventTypes) {
		delete[] m_aiidEventTypes;
		m_aiidEventTypes = NULL;
	}
}


HRESULT CEventRouterInternal::CDispatcher::Init(REFCLSID clsidDispatcher, IClassFactory *pClassFactory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	m_clsidDispatcher = clsidDispatcher;
	if (pClassFactory) {
		hrRes = pClassFactory->CreateInstance(NULL,IID_IUnknown,(LPVOID *) &m_pUnkDispatcher);
	} else {
		hrRes = CoCreateInstance(clsidDispatcher,
								 NULL,
								 CLSCTX_ALL,
								 IID_IUnknown,
								 (LPVOID *) &m_pUnkDispatcher);
	}
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkDispatcher);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_pDispatcher = m_pUnkDispatcher;
	return (S_OK);
}


BOOL CEventRouterInternal::CDispatcher::HasEventType(REFIID iidEventType) {
	DEBUG_OBJECT_CHECK

	for (DWORD dwIdx=0;dwIdx<m_dwEventTypes;dwIdx++) {
		if (m_aiidEventTypes[dwIdx] == iidEventType) {
			return (TRUE);
		}
	}
	return (FALSE);
}


HRESULT CEventRouterInternal::CDispatcher::AddEventType(REFIID iidEventType, IEventRouter *piRouter, IEventBindingManager *piManager) {
	DEBUG_OBJECT_CHECK
	IID *aiidTmp;
	HRESULT hrRes;

	if (iidEventType == GUID_NULL) {
		return (S_FALSE);
	}
	if (HasEventType(iidEventType)) {
		return (S_FALSE);
	}
	if (m_pEnumPreload) {
		// If we were set-up to pre-load some event types...
		CComPtr<IEnumGUID> pEnum;
		IID iidPreload;

		pEnum = m_pEnumPreload;
		m_pEnumPreload.Release();  // Prevent infinite recusion
		while (pEnum->Next(1,&iidPreload,NULL) == S_OK) {
			// Add each event type returned by the enumerator.
			hrRes = AddEventType(iidPreload,piRouter,piManager);
			_ASSERTE(SUCCEEDED(hrRes));
		}
	}
	if (m_pDispatcher) {
		CComPtr<IEventBindings> pBindings;

		hrRes = piManager->get_Bindings((LPOLESTR) ((LPCOLESTR) CStringGUID(iidEventType)),&pBindings);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = m_pDispatcher->SetContext(iidEventType,piRouter,pBindings);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	aiidTmp = new IID[m_dwEventTypes+1];
	if (!aiidTmp) {
		return (E_OUTOFMEMORY);
	}
	memcpy(aiidTmp,m_aiidEventTypes,sizeof(m_aiidEventTypes[0])*m_dwEventTypes);
	delete[] m_aiidEventTypes;
	m_aiidEventTypes = aiidTmp;
	aiidTmp[m_dwEventTypes++] = iidEventType;
	return (S_OK);
}


HRESULT CEventRouterInternal::CDispatcher::GetDispatcher(REFIID iidDesired, LPVOID *ppvDispatcher) {
	DEBUG_OBJECT_CHECK

	if (ppvDispatcher) {
		*ppvDispatcher = NULL;
	}
	if (!ppvDispatcher) {
		return (E_POINTER);
	}
	if (!m_pUnkDispatcher) {
		return (E_FAIL);
	}
	return (m_pUnkDispatcher->QueryInterface(iidDesired,ppvDispatcher));
}


/////////////////////////////////////////////////////////////////////////////
// CEventRouter


HRESULT CEventRouter::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventRouter::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CComObject<CEventRouterInternal>::_CreatorClass::CreateInstance(NULL,
																			IID_IEventRouter,
																			(LPVOID *) &m_pRouter);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	ADD_DEBUG_OBJECT("CEventRouter")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventRouter::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventRouter::FinalRelease");

	if (m_pRouter) {
		m_pRouter->put_Database(NULL);
	}
	m_pRouter.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventRouter::get_Database(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->get_Database(ppBindingManager));
}


HRESULT STDMETHODCALLTYPE CEventRouter::put_Database(IEventBindingManager *pBindingManager) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->put_Database(pBindingManager));
}


HRESULT STDMETHODCALLTYPE CEventRouter::putref_Database(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->putref_Database(ppBindingManager));
}


HRESULT STDMETHODCALLTYPE CEventRouter::GetDispatcher(REFIID iidEventType,
													  REFIID iidDesired,
													  IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->GetDispatcher(iidEventType,iidDesired,ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CEventRouter::GetDispatcherByCLSID(REFCLSID clsidDispatcher,
															 REFIID iidEventType,
															 REFIID iidDesired,
															 IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->GetDispatcherByCLSID(clsidDispatcher,
											iidEventType,
											iidDesired,
											ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CEventRouter::GetDispatcherByClassFactory(REFCLSID clsidDispatcher,
																	IClassFactory *pClassFactory,
																	REFIID iidEventType,
																	REFIID iidDesired,
																	IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->GetDispatcherByClassFactory(clsidDispatcher,
												   pClassFactory,
												   iidEventType,
												   iidDesired,
												   ppUnkResult));
}


/////////////////////////////////////////////////////////////////////////////
// CEventServiceSubObject
class ATL_NO_VTABLE CEventServiceSubObject :
	public CComObjectRoot,
//	public CComCoClass<CEventRouterInternal, &CLSID_CEventRouterInternal>,
	public IEventNotifyBindingChange
{
	DEBUG_OBJECT_DEF(CEventServiceSubObject)

	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventServiceSubObject);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventServiceSubObject Class",
//								   L"Event.ServiceSubObject.1",
//								   L"Event.ServiceSubObject");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventServiceSubObject)
		COM_INTERFACE_ENTRY(IEventNotifyBindingChange)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventNotifyBindingChange
	public:
		HRESULT STDMETHODCALLTYPE OnChange();

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


HRESULT CEventServiceSubObject::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventServiceSubObject::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventServiceObject")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventServiceSubObject::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventServiceSubObject::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventServiceSubObject::OnChange() {

	// nothing
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventServiceObject


HRESULT CEventServiceObject::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventServiceObject::FinalConstruct");
	HRESULT hrRes = S_OK;
	CComPtr<IConnectionPoint> pCP;

	hrRes = CoCreateInstance(CLSID_CSEOMetaDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IUnknown,
							 (LPVOID *) &m_pUnkMetabase);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	if (SUCCEEDED(hrRes)) {
		m_pCPC = m_pUnkMetabase;
		_ASSERTE(m_pCPC);
		if (!m_pCPC) {
			hrRes = E_NOINTERFACE;
		}
	}
	if (SUCCEEDED(hrRes)) {
		hrRes = m_pCPC->FindConnectionPoint(IID_IEventNotifyBindingChange,&pCP);
		_ASSERTE(SUCCEEDED(hrRes));
		if (!SUCCEEDED(hrRes)) {
			m_pCPC.Release();
		}
	}
	if (SUCCEEDED(hrRes)) {
		hrRes = CComObject<CEventServiceSubObject>::_CreatorClass::CreateInstance(NULL,
																				  IID_IUnknown,
																				  (LPVOID *) &m_pSubObject);
		_ASSERTE(SUCCEEDED(hrRes));
		if (SUCCEEDED(hrRes)) {
			hrRes = pCP->Advise(m_pSubObject,&m_dwCookie);
			_ASSERTE(SUCCEEDED(hrRes));
		}
		if (!SUCCEEDED(hrRes)) {
			m_pCPC.Release();
		}
	}
	ADD_DEBUG_OBJECT("CEventServiceObject")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventServiceObject::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventServiceObject::FinalRelease");

	if (m_pCPC) {
		CComPtr<IConnectionPoint> pCP;
		HRESULT hrRes;

		hrRes = m_pCPC->FindConnectionPoint(IID_IEventNotifyBindingChange,&pCP);
		_ASSERTE(SUCCEEDED(hrRes));
		if (SUCCEEDED(hrRes)) {
			hrRes = pCP->Unadvise(m_dwCookie);
			_ASSERTE(SUCCEEDED(hrRes));
		}
		m_pCPC.Release();
	}
	m_pSubObject.Release();
	m_pUnkMetabase.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\gmoniker.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	gmoniker.cpp

Abstract:

	This module contains the implementation of the
	CSEOGenericMoniker object.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   04/11/97        created

--*/

// GMONIKER.cpp : Implementation of CSEOGenericMoniker

#include "stdafx.h"
#include "seodefs.h"

#include "GMONIKER.h"

#ifndef CSTR_EQUAL
	#define CSTR_EQUAL	(2)
#endif

LPCOLESTR szObjectType = OLESTR("MonikerType");

const WCHAR QUOTE_CHAR = L'\\';
const WCHAR NAME_SEP = L'=';
const WCHAR ENTRY_SEP = L' ';
const WCHAR PROGID_PREFIX = L'@';
const WCHAR PROGID_POSTFIX = L':';


IsPrefix(LPCOLESTR psPrefix, LPCOLESTR psString, int iLen) {
	return (CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
	                                     psPrefix, iLen, psString, iLen));
}


/////////////////////////////////////////////////////////////////////////////
// CSEOGenericMoniker


// IPersist Members
HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::GetClassID(/* [out] */ CLSID __RPC_FAR *pClassID) {
	if(!pClassID) return E_POINTER;
	memcpy(pClassID, &CLSID_CSEOGenericMoniker, sizeof(CLSID));
	_ASSERT(IsEqualCLSID(*pClassID, CLSID_CSEOGenericMoniker));
	return S_OK;
}

// IPersistStream Members
HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::IsDirty(void) {
	return S_FALSE; // Shallow binding representation hasn't changed
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Load( 
	/* [unique][in] */ IStream __RPC_FAR *pStm) {
	return m_bstrMoniker.ReadFromStream(pStm);
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Save( 
	/* [unique][in] */ IStream __RPC_FAR *pStm,
	/* [in] */ BOOL fClearDirty) {
	return m_bstrMoniker.WriteToStream(pStm);
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::GetSizeMax( 
	/* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize) {
	if(!pcbSize) return E_POINTER;
	// Conservitive size estimate of bytes needed to save object
	pcbSize->QuadPart = m_bstrMoniker.Length() * sizeof(WCHAR) * 2;
	return S_OK;
}


// IMoniker Members
/* [local] */ HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::BindToObject( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [in] */ REFIID riidResult,
	/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult) {

	if(!pbc || !ppvResult) return E_POINTER;
	*ppvResult = NULL;

	// First, get the Running Object Table
	BOOL bFoundInTable = TRUE;
	CComPtr<IRunningObjectTable> pROT;
	CComPtr<IUnknown> punkObject;
	HRESULT hRes = pbc->GetRunningObjectTable(&pROT);
	if(FAILED(hRes)) return hRes;
	_ASSERT(!!pROT); // operator!() is defined, so use !! to test for existance.
	if(!pROT) return E_UNEXPECTED; // GetRunningObjectTable() didn't work

	// Try to find in Running Object Table
	hRes = pROT->GetObject((IMoniker *) this, &punkObject);

	// If not currently running then create it
	if(FAILED(hRes) || !punkObject) {
		bFoundInTable = FALSE;
		CComPtr<IPropertyBag> pBag;
		hRes = CoCreateInstance(CLSID_CSEOMemDictionary, NULL, CLSCTX_ALL,
		                        IID_IPropertyBag, (LPVOID *) &pBag);
		if(FAILED(hRes)) return hRes;
		_ASSERT(!!pBag); // operator!() is defined, so use !! to test for existance.
		SetPropertyBag(pBag);
		CComPtr<ISEOInitObject> pInitObject;

		hRes = CreateBoundObject(pBag, &pInitObject);
		if(FAILED(hRes)) return hRes;
		_ASSERT(!!pInitObject); // operator!() is defined, so use !! to test for existance.
		if(!pInitObject) return E_UNEXPECTED; // CreateBoundObject returned S_OK, but didn't Create an object

		hRes = pInitObject->Load(pBag, NULL);
		punkObject = pInitObject; // Save copy of pointer

/* TBD: Register with the Running Object Table
		DWORD dwRegister;
		if(SUCCEEDED(hRes)) pROT->Register(0, pInitObject, (IMoniker *) this, &dwRegister);
*/
	}

	// punkObject should have been set by one of the code paths before this
	_ASSERT(!!punkObject); // operator!() is defined, so use !! to test for existance.
	if(!punkObject) return E_UNEXPECTED;
	return punkObject->QueryInterface(riidResult, ppvResult);
}

/* [local] */ HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::BindToStorage( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [in] */ REFIID riid,
	/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObj) {
	return MK_E_NOSTORAGE; // The object identified by this moniker does not have its own storage.
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Reduce( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [in] */ DWORD dwReduceHowFar,
	/* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced) {
	if(!ppmkReduced) return E_POINTER;
	*ppmkReduced = (IMoniker *) this;
	_ASSERT(!!*ppmkReduced);  // operator!() is defined, so use !! to test for existance.
	if(!*ppmkReduced) return E_UNEXPECTED; // "this" not set...
	HRESULT hRes = (*ppmkReduced)->AddRef(); // Do this for self (the object being returned)
	if(SUCCEEDED(hRes)) hRes = MK_S_REDUCED_TO_SELF; // This moniker could not be reduced any further, so ppmkReduced indicates this moniker. 
	return hRes;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::ComposeWith( 
	/* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
	/* [in] */ BOOL fOnlyIfNotGeneric,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite) {
	ATLTRACENOTIMPL(_T("CSEOGenericMoniker::ComposeWith"));
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Enum( 
	/* [in] */ BOOL fForward,
	/* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker) {
	if(!ppenumMoniker) return E_POINTER;
	*ppenumMoniker = NULL;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::IsEqual( 
	/* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker) {
	ATLTRACENOTIMPL(_T("CSEOGenericMoniker::IsEqual"));
	// Return S_OK vs. S_FALSE
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Hash( 
	/* [out] */ DWORD __RPC_FAR *pdwHash) {
	if(!pdwHash) return E_POINTER;
	*pdwHash = 0; // ATLTRACENOTIMPL(_T("CSEOGenericMoniker::Hash"));
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::IsRunning( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning) {
	HRESULT hRes = E_UNEXPECTED; // hRes not set to something else

	if(pmkToLeft) { // If something on the left, pass it to them
		hRes = pmkToLeft->IsRunning(pbc, NULL, pmkNewlyRunning);
	} else if(pbc) { // No Moniker to left, but have a BindCtx
		CComPtr<IRunningObjectTable> pROT;
		hRes = pbc->GetRunningObjectTable(&pROT);
		if(FAILED(hRes)) return hRes;

		if(pROT) { // Try to find in Running Object Table
			hRes = pROT->IsRunning((IMoniker *) this);
		}
	} else {
		hRes = E_POINTER; // No BindCtx
	}

	return hRes;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::GetTimeOfLastChange( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [out] */ FILETIME __RPC_FAR *pFileTime) {
	return MK_E_UNAVAILABLE;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Inverse( 
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk) {
	return MK_E_NOINVERSE;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::CommonPrefixWith( 
	/* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix) {
	return MK_E_NOPREFIX;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::RelativePathTo( 
	/* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath) {
	ATLTRACENOTIMPL(_T("CSEOGenericMoniker::RelativePathTo"));
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::GetDisplayName( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName) {
	if(!ppszDisplayName) return E_POINTER;
	*ppszDisplayName = NULL;
	CComPtr<IMalloc> pMalloc;
	HRESULT hRes = CoGetMalloc(1, &pMalloc);

	if(SUCCEEDED(hRes)) {
		_ASSERT(!!pMalloc); // operator!() is defined, so use !! to test for existance.
		hRes = E_OUTOFMEMORY;
		int iSize = 5 + m_bstrMoniker.Length() + lstrlenW(GENERIC_MONIKER_VERPROGID);
		*ppszDisplayName = (LPOLESTR) pMalloc->Alloc(iSize * sizeof(WCHAR));

		if(*ppszDisplayName) {
			**ppszDisplayName = 0; // Terminate string
			lstrcatW(*ppszDisplayName, L"@");
			lstrcatW(*ppszDisplayName, GENERIC_MONIKER_VERPROGID); // Build the display name
			lstrcatW(*ppszDisplayName, L": ");
			lstrcatW(*ppszDisplayName, m_bstrMoniker);
			hRes = S_OK;
		}
	}

	return hRes;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::ParseDisplayName( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [in] */ LPOLESTR pszDisplayName,
	/* [out] */ ULONG __RPC_FAR *pchEaten,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut) {
	// Deligate!!!
	return ParseDisplayName(pbc, pszDisplayName, pchEaten, ppmkOut);
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::IsSystemMoniker( 
	/* [out] */ DWORD __RPC_FAR *pdwMksys) {
	if(!pdwMksys) return E_POINTER;
	*pdwMksys = MKSYS_NONE;
	return S_FALSE; // Not a system moniker
}
        

// IParseDisplayName Members
HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::ParseDisplayName( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [in] */ LPOLESTR pszDisplayName,
	/* [out] */ ULONG __RPC_FAR *pchEaten,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut) {
	if(!pszDisplayName || !pchEaten || !ppmkOut) return E_POINTER;
	*pchEaten = 0; // Nothing parsed so far
	CComBSTR bstrMoniker;
	CComBSTR bstrProgID(GENERIC_MONIKER_PROGID);
	CComBSTR bstrVerProgID(GENERIC_MONIKER_VERPROGID);

	// The Ver string should completely contain the non-Ver string
	_ASSERT(bstrProgID.Length() > 0);  // Something should be there
	_ASSERT(bstrProgID.Length() <= bstrVerProgID.Length());
	_ASSERT(IsPrefix(bstrProgID, bstrVerProgID, bstrProgID.Length()));

	if(PROGID_PREFIX == pszDisplayName[*pchEaten]) {
		++(*pchEaten);
	}

	if(IsPrefix(bstrProgID, pszDisplayName + *pchEaten, bstrProgID.Length())) {
		if(IsPrefix(bstrVerProgID, pszDisplayName + *pchEaten, bstrVerProgID.Length())) {
			*pchEaten += bstrVerProgID.Length();
		} else { // Non-version string matched
			*pchEaten += bstrProgID.Length();
		}

		if(pszDisplayName[*pchEaten] &&
		   (PROGID_POSTFIX == pszDisplayName[*pchEaten])) {
			++(*pchEaten);
		}

		while(pszDisplayName[*pchEaten] &&
		      (pszDisplayName[*pchEaten] == ENTRY_SEP)) {
			++(*pchEaten);
		}

		if(pszDisplayName[*pchEaten]) { // If still something left
			bstrMoniker = &pszDisplayName[*pchEaten];
			*pchEaten += bstrMoniker.Length();
		}
	}

	CComObject<CSEOGenericMoniker> *pMoniker;
	HRESULT hRes = CComObject<CSEOGenericMoniker>::CreateInstance(&pMoniker);
	if(FAILED(hRes)) return hRes;
	_ASSERT(!!pMoniker); // operator!() is defined, so use !! to test for existance.
	if(!pMoniker) return E_UNEXPECTED; // CreateInstance failed (but returned S_OK)

	pMoniker->SetMonikerString(bstrMoniker);
	*ppmkOut = (IMoniker *) pMoniker;
	return pMoniker->AddRef();
}


HRESULT CSEOGenericMoniker::FinalConstruct() {
	HRESULT hrRes;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOGenericMoniker::FinalRelease() {
	m_pUnkMarshaler.Release();
}

void CSEOGenericMoniker::SetPropertyBag(IPropertyBag *pBag) {
	if(!pBag) return;

	int iStringLength = m_bstrMoniker.Length();
	int iCurrentPos = 0;

	while(iCurrentPos < iStringLength) {
		CComBSTR bstrName;
		CComBSTR bstrValue;

		// Eat up multiple spaces for entry separators
		while((iCurrentPos < iStringLength) &&
		      (m_bstrMoniker.m_str[iCurrentPos] == ENTRY_SEP)) {
			++iCurrentPos;
		}

		// Read in the Name
		while((iCurrentPos < iStringLength) &&
		      (m_bstrMoniker.m_str[iCurrentPos] != NAME_SEP)) {
			if((iCurrentPos < iStringLength - 1) &&
			   (m_bstrMoniker.m_str[iCurrentPos] == QUOTE_CHAR)) {
				++iCurrentPos;
			}

			bstrName.Append(&m_bstrMoniker.m_str[iCurrentPos], 1);
			++iCurrentPos;
		}

		BOOL bFoundSep = FALSE;
		if((iCurrentPos < iStringLength) &&
		   (m_bstrMoniker.m_str[iCurrentPos] == NAME_SEP)) {
			bFoundSep = TRUE;
			++iCurrentPos;
		}

		// Read in the value
		while((iCurrentPos < iStringLength) &&
		      (m_bstrMoniker.m_str[iCurrentPos] != ENTRY_SEP)) {
			if((iCurrentPos < iStringLength - 1) &&
			   (m_bstrMoniker.m_str[iCurrentPos] == QUOTE_CHAR)) {
				++iCurrentPos;
			}

			bstrValue.Append(&m_bstrMoniker.m_str[iCurrentPos], 1);
			++iCurrentPos;
		}

		if(bFoundSep) { // If it's a real entry
			CComVariant varValue = bstrValue; // Convert BSTR to Variant
			pBag->Write(bstrName, &varValue);
			// Even if error occurs in Write(), continue processing
		}

		// Eat up multiple spaces for entry separators
		while((iCurrentPos < iStringLength) &&
		      (m_bstrMoniker.m_str[iCurrentPos] == ENTRY_SEP)) {
			++iCurrentPos;
		}
	}
}

HRESULT CSEOGenericMoniker::CreateBoundObject(IPropertyBag *pBag, ISEOInitObject **ppResult) {
	_ASSERT(ppResult);
	*ppResult = NULL;
	if(!pBag) return E_POINTER;

	CComVariant varPROGID;
	CLSID clsid;

	varPROGID.vt = VT_BSTR; // Request type from Read()
	varPROGID.bstrVal = NULL;
	HRESULT hRes = pBag->Read(szObjectType, &varPROGID, NULL);

	if(SUCCEEDED(hRes))	{
		_ASSERT(varPROGID.vt == VT_BSTR);
		hRes = CLSIDFromProgID(varPROGID.bstrVal, &clsid);
	}

	if(SUCCEEDED(hRes))	{
		hRes = CoCreateInstance(clsid, NULL, CLSCTX_ALL,
		                        IID_ISEOInitObject, (LPVOID *) ppResult);
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\item.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	item.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Item class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	02/18/97	created

--*/


// item.cpp : Implementation of CSEODictionaryItem
#include "stdafx.h"
#include "seodefs.h"
#include "item.h"


static HRESULT VarToIndex(DWORD *pdwIndex, VARIANT *pvarFrom, DWORD dwCount, BOOL bBoundsError=TRUE) {
	TraceFunctEnter("VarToIndex");
	VARIANT varIndex;
	HRESULT hr;

	if (!pvarFrom || (pvarFrom->vt == VT_ERROR)) {
		if (bBoundsError && !dwCount) {
			TraceFunctLeave();
			return (SEO_E_NOTPRESENT);
		}
		*pdwIndex = 0;
		TraceFunctLeave();
		return (S_OK);
	}
	if (!dwCount) {
		TraceFunctLeave();
		return (SEO_E_NOTPRESENT);
	}
	VariantInit(&varIndex);
	if (pvarFrom->vt != VT_I4) {
		hr = VariantChangeTypeEx(&varIndex,pvarFrom,LOCALE_NEUTRAL,0,VT_I4);
		if (!SUCCEEDED(hr)) {
			VariantClear(&varIndex);
			TraceFunctLeave();
			return (hr);
		}
	} else {
		varIndex.vt = VT_I4;
		varIndex.lVal = pvarFrom->lVal;
	}
	if ((varIndex.iVal < 0) || (bBoundsError && ((DWORD) varIndex.iVal >= dwCount))) {
		TraceFunctLeave();
		return (SEO_E_NOTPRESENT);
	}
	*pdwIndex = min(dwCount,(DWORD) varIndex.iVal);
	TraceFunctLeave();
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CSEODictionaryItem


HRESULT CSEODictionaryItem::FinalConstruct() {
	HRESULT hrRes;
	TraceFunctEnter("CSEODictionaryItem::FinalConstruct");

	m_dwCount = 0;
	m_pvcValues = NULL;
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEODictionaryItem::FinalRelease() {
	TraceFunctEnter("CSEODictionaryItem::FinalRelease");

	if (m_pvcValues) {
		DWORD dwIdx;

		for (dwIdx=0;dwIdx<m_dwCount;dwIdx++) {
			m_pvcValues[dwIdx].~ValueClass();
		}
		CoTaskMemFree(m_pvcValues);
		m_pvcValues = NULL;
	}
	m_dwCount = 0;
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::get_Value(VARIANT *pvarIndex, VARIANT *pvarResult) {
	TraceFunctEnter("CSEODictionaryItem::get_Value");
	DWORD dwIndex;
	HRESULT hr;

	if (!pvarResult) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	VariantInit(pvarResult);
	hr = VarToIndex(&dwIndex,pvarIndex,m_dwCount);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	TraceFunctLeave();
	return (m_pvcValues[dwIndex].AsVariant(pvarResult));
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::AddValue(VARIANT *pvarIndex, VARIANT *pvarValue) {
	TraceFunctEnter("CSEODictionaryItem::AddValue");
	DWORD dwIndex;
	HRESULT hr;
	ValueClass *pvcValue;

	if (!pvarValue) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	hr = VarToIndex(&dwIndex,pvarIndex,m_dwCount,FALSE);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	hr = AddSlot(&dwIndex,&pvcValue);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	hr = m_pvcValues[dwIndex].Assign(pvarValue);
	if (!SUCCEEDED(hr)) {
		VARIANT varIndex;

		VariantInit(&varIndex);
		varIndex.vt = VT_I4;
		varIndex.lVal = dwIndex;
		DeleteValue(&varIndex);
		TraceFunctLeave();
		return (hr);
	}
	TraceFunctLeave();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::DeleteValue(VARIANT *pvarIndex) {
	TraceFunctEnter("CSEODictionaryItem::DeleteValue");
	DWORD dwIndex;
	HRESULT hr;

	if (!pvarIndex) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	hr = VarToIndex(&dwIndex,pvarIndex,m_dwCount);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	m_pvcValues[dwIndex].~ValueClass();
	m_dwCount--;
	memcpy(&m_pvcValues[dwIndex-1],&m_pvcValues[dwIndex],sizeof(m_pvcValues[0])*(m_dwCount-dwIndex));
	TraceFunctLeave();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::get_Count(VARIANT *pvarResult) {
	TraceFunctEnter("CSEODictionaryItem::get_Count");

	if (!pvarResult) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	VariantInit(pvarResult);
	pvarResult->vt = VT_I4;
	pvarResult->lVal = (LONG) m_dwCount;
	TraceFunctLeave();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::GetStringA(DWORD dwIndex, DWORD *pchCount, LPSTR pszResult) {
	TraceFunctEnter("CSEODictionaryItem::GetStringA");

	if (dwIndex >= m_dwCount) {
		TraceFunctLeave();
		return (SEO_E_NOTPRESENT);
	}
	TraceFunctLeave();
	return (m_pvcValues[dwIndex].AsStringA(pchCount,pszResult));
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::GetStringW(DWORD dwIndex, DWORD *pchCount, LPWSTR pszResult) {
	TraceFunctEnter("CSEODictionaryItem::GetStringW");

	if (dwIndex >= m_dwCount) {
		TraceFunctLeave();
		return (SEO_E_NOTPRESENT);
	}
	TraceFunctLeave();
	return (m_pvcValues[dwIndex].AsStringW(pchCount,pszResult));
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::AddStringA(DWORD dwIndex, LPCSTR pszValue) {
	TraceFunctEnter("CSEODictionaryItem::AddStringA");
	HRESULT hr;
	ValueClass *pvcValue;

	if (!pszValue) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	hr = AddSlot(&dwIndex,&pvcValue);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	hr = m_pvcValues[dwIndex].Assign(pszValue);
	if (!SUCCEEDED(hr)) {
		VARIANT varIndex;

		VariantInit(&varIndex);
		varIndex.vt = VT_I4;
		varIndex.lVal = dwIndex;
		DeleteValue(&varIndex);
		TraceFunctLeave();
		return (hr);
	}
	TraceFunctLeave();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::AddStringW(DWORD dwIndex, LPCWSTR pszValue) {
	TraceFunctEnter("CSEODictionaryItem::AddStringW");
	HRESULT hr;
	ValueClass *pvcValue;

	if (!pszValue) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	hr = AddSlot(&dwIndex,&pvcValue);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	hr = m_pvcValues[dwIndex].Assign(pszValue);
	if (!SUCCEEDED(hr)) {
		VARIANT varIndex;

		VariantInit(&varIndex);
		varIndex.vt = VT_I4;
		varIndex.lVal = dwIndex;
		DeleteValue(&varIndex);
		TraceFunctLeave();
		return (hr);
	}
	TraceFunctLeave();
	return (S_OK);
}


HRESULT CSEODictionaryItem::AddSlot(DWORD *pdwIndex, ValueClass **ppvcResult) {
	TraceFunctEnter("CSEODictionaryItem::AddSlot");
	LPVOID pvRes;

	if (*pdwIndex > m_dwCount) {
		*pdwIndex = m_dwCount;
	}
	pvRes = CoTaskMemRealloc(m_pvcValues,sizeof(m_pvcValues[0])*(m_dwCount+1));
	if (!pvRes) {
		TraceFunctLeave();
		return (E_OUTOFMEMORY);
	}
	m_pvcValues = (ValueClass *) pvRes;
	memcpy(&m_pvcValues[*pdwIndex+1],&m_pvcValues[*pdwIndex],sizeof(m_pvcValues[0])*(m_dwCount-*pdwIndex));
	new(&m_pvcValues[*pdwIndex]) ValueClass();
	m_dwCount++;
	*ppvcResult = &m_pvcValues[*pdwIndex];
	TraceFunctLeave();
	return (S_OK);
}


CSEODictionaryItem::ValueClass::ValueClass() {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::ValueClass");

	Init();
	TraceFunctLeave();
}


CSEODictionaryItem::ValueClass::ValueClass(ValueClass& vcFrom) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::ValueClass");

	Init();
	Assign(vcFrom);
	TraceFunctLeave();
}


CSEODictionaryItem::ValueClass::~ValueClass() {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::~ValueClass");

	Clear();
	TraceFunctLeave();
}


void CSEODictionaryItem::ValueClass::Init() {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Init");

	m_vtValue.veType = veNone;
	m_vtValue.pszStringA = NULL;
	VariantInit(&m_vtValue.varVARIANT);
	TraceFunctLeave();
}


void CSEODictionaryItem::ValueClass::Clear() {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Clear");

	m_vtValue.veType = veNone;
	if (m_vtValue.pszStringA) {
		CoTaskMemFree(m_vtValue.pszStringA);
		m_vtValue.pszStringA = NULL;
	}
	VariantClear(&m_vtValue.varVARIANT);
	TraceFunctLeave();
}


HRESULT CSEODictionaryItem::ValueClass::Assign(ValueClass& vcFrom) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Assign");

	if (&vcFrom != this) {
		switch (m_vtValue.veType) {

			case veStringA:
				TraceFunctLeave();
				return (Assign(vcFrom.m_vtValue.pszStringA));

			case veVARIANT:
				TraceFunctLeave();
				return (Assign(&vcFrom.m_vtValue.varVARIANT));
		}
	}
	TraceFunctLeave();
	return (E_UNEXPECTED);
}


HRESULT CSEODictionaryItem::ValueClass::Assign(LPCSTR pszFromA) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Assign");

	if (!pszFromA) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	Clear();
	m_vtValue.pszStringA = (LPSTR) CoTaskMemAlloc(strlen(pszFromA)+1);
	if (!m_vtValue.pszStringA) {
		TraceFunctLeave();
		return (E_OUTOFMEMORY);
	}
	m_vtValue.veType = veStringA;
	strcpy(m_vtValue.pszStringA,pszFromA);
	TraceFunctLeave();
	return (S_OK);
}


HRESULT CSEODictionaryItem::ValueClass::Assign(VARIANT *pvarFrom) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Assign");
	HRESULT hr;

	if (!pvarFrom) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	Clear();
	hr = VariantCopy(&m_vtValue.varVARIANT,pvarFrom);
	if (SUCCEEDED(hr)) {
		m_vtValue.veType = veVARIANT;
	}
	TraceFunctLeave();
	return (hr);
}


HRESULT CSEODictionaryItem::ValueClass::Assign(LPCWSTR pszFromW) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Assign");

	if (!pszFromW) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	Clear();
	m_vtValue.varVARIANT.bstrVal = SysAllocString(pszFromW);
	if (!m_vtValue.varVARIANT.bstrVal) {
		TraceFunctLeave();
		return (E_OUTOFMEMORY);
	}
	m_vtValue.varVARIANT.vt = VT_BSTR;
	m_vtValue.veType = veVARIANT;
	TraceFunctLeave();
	return (S_OK);
}


HRESULT CSEODictionaryItem::ValueClass::AsVariant(VARIANT *pvarResult) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::AsVariant");

	if (!pvarResult) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	VariantInit(pvarResult);
	switch (m_vtValue.veType) {

		case veStringA: {
			DWORD dwLen = strlen(m_vtValue.pszStringA);

			pvarResult->bstrVal = SysAllocStringLen(NULL,dwLen);
			if (!pvarResult->bstrVal) {
				TraceFunctLeave();
				return (E_OUTOFMEMORY);
			}
			ATLA2WHELPER(pvarResult->bstrVal,m_vtValue.pszStringA,dwLen);
			pvarResult->vt = VT_BSTR;
			TraceFunctLeave();
			return (S_OK);
		}

		case veVARIANT:
			TraceFunctLeave();
			return (VariantCopy(pvarResult,&m_vtValue.varVARIANT));
	}
	TraceFunctLeave();
	return (E_UNEXPECTED);
}


HRESULT CSEODictionaryItem::ValueClass::AsStringA(DWORD *pchCount, LPSTR pszResult) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::AsStringA");

	if (!pchCount) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	switch (m_vtValue.veType) {

		case veStringA:
			if (pszResult) {
				DWORD dwLen = strlen(m_vtValue.pszStringA);
				DWORD dwCopy = min(*pchCount,dwLen+1);
				BOOL bMoreData = FALSE;

				memcpy(pszResult,m_vtValue.pszStringA,dwCopy);
				if (dwCopy == *pchCount) {
					pszResult[dwCopy-1] = 0;
					bMoreData = TRUE;
				}
				*pchCount = dwCopy;
				TraceFunctLeave();
				return (bMoreData?SEO_S_MOREDATA:S_OK);
			} else {
				*pchCount = strlen(m_vtValue.pszStringA) + 1;
				TraceFunctLeave();
				return (S_OK);
			}

		case veVARIANT: {
			VARIANT varValue;
			LPCWSTR pszValue;
			HRESULT hr;

			VariantInit(&varValue);
			if (m_vtValue.varVARIANT.vt != VT_BSTR) {
				hr = VariantChangeTypeEx(&varValue,&m_vtValue.varVARIANT,LOCALE_NEUTRAL,0,VT_BSTR);
				if (!SUCCEEDED(hr)) {
					VariantClear(&varValue);
					TraceFunctLeave();
					return (hr);
				}
				pszValue = varValue.bstrVal;
			} else {
				pszValue = m_vtValue.varVARIANT.bstrVal;
			}
			if (pszResult) {
				DWORD dwLen = wcslen(pszValue);
				DWORD dwCopy = min(*pchCount,dwLen+1);
				BOOL bMoreData = FALSE;

				ATLW2AHELPER(pszResult,pszValue,dwCopy);
				VariantClear(&varValue);
				if (dwCopy == *pchCount) {
					bMoreData = TRUE;
				}
				*pchCount = dwCopy;
				TraceFunctLeave();
				return (bMoreData?SEO_S_MOREDATA:S_OK);
			} else {
				*pchCount = wcslen(pszValue) + 1;
				VariantClear(&varValue);
				TraceFunctLeave();
				return (S_OK);
			}
		}
	}
	TraceFunctLeave();
	return (E_UNEXPECTED);
}


HRESULT CSEODictionaryItem::ValueClass::AsStringW(DWORD *pchCount, LPWSTR pszResult) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::AsStringW");

	if (!pchCount) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	switch (m_vtValue.veType) {

		case veStringA:
			if (pszResult) {
				DWORD dwLen = strlen(m_vtValue.pszStringA);
				DWORD dwCopy = min(*pchCount,dwLen+1);
				BOOL bMoreData = FALSE;

				ATLA2WHELPER(pszResult,m_vtValue.pszStringA,dwCopy);
				if (dwCopy == *pchCount) {
					bMoreData = TRUE;
				}
				*pchCount = dwCopy;
				TraceFunctLeave();
				return (bMoreData?SEO_S_MOREDATA:S_OK);
			} else {
				*pchCount = strlen(m_vtValue.pszStringA) + 1;
				TraceFunctLeave();
				return (S_OK);
			}

		case veVARIANT: {
			VARIANT varValue;
			LPCWSTR pszValue;
			HRESULT hr;

			VariantInit(&varValue);
			if (m_vtValue.varVARIANT.vt != VT_BSTR) {
				hr = VariantChangeTypeEx(&varValue,&m_vtValue.varVARIANT,LOCALE_NEUTRAL,0,VT_BSTR);
				if (!SUCCEEDED(hr)) {
					VariantClear(&varValue);
					TraceFunctLeave();
					return (hr);
				}
				pszValue = varValue.bstrVal;
			} else {
				pszValue = m_vtValue.varVARIANT.bstrVal;
			}
			if (pszResult) {
				DWORD dwLen = wcslen(pszValue);
				DWORD dwCopy = min(*pchCount,dwLen+1);
				BOOL bMoreData = FALSE;

				memcpy(pszResult,pszValue,dwCopy);
				VariantClear(&varValue);
				if (dwCopy == *pchCount) {
					pszResult[dwCopy-1] = 0;
					bMoreData = TRUE;
				}
				*pchCount = dwCopy;
				TraceFunctLeave();
				return (bMoreData?SEO_S_MOREDATA:S_OK);
			} else {
				*pchCount = wcslen(pszValue) + 1;
				VariantClear(&varValue);
				TraceFunctLeave();
				return (S_OK);
			}
		}
	}
	TraceFunctLeave();
	return (E_UNEXPECTED);
}


void *CSEODictionaryItem::ValueClass::operator new(size_t cbSize, CSEODictionaryItem::ValueClass *pvcInPlace) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::operator new");

	TraceFunctLeave();
	return (pvcInPlace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\gmoniker.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	gmoniker.h

Abstract:

	This module contains the definition for the
	CSEOGenericMoniker object.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   04/11/97        created

--*/

// GMONIKER.H : Declaration of the CSEOGenericMoniker

#define GENERIC_MONIKER_PROGID L"SEO.SEOGenericMoniker"
#define GENERIC_MONIKER_VERPROGID GENERIC_MONIKER_PROGID L".1"


/////////////////////////////////////////////////////////////////////////////
// CSEOGenericMoniker

class ATL_NO_VTABLE CSEOGenericMoniker : 
	public CComObjectRoot,
	public CComCoClass<CSEOGenericMoniker, &CLSID_CSEOGenericMoniker>,
	public IParseDisplayName,
	public IDispatchImpl<IMoniker, &IID_IMoniker, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOGenericMoniker Class",
								   GENERIC_MONIKER_VERPROGID,
								   GENERIC_MONIKER_PROGID);

	BEGIN_COM_MAP(CSEOGenericMoniker)
		COM_INTERFACE_ENTRY(IMoniker)
		COM_INTERFACE_ENTRY(IParseDisplayName)
		COM_INTERFACE_ENTRY(IPersistStream) // Needed for OleLoadFromStream support
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IPersist
	public:
		HRESULT STDMETHODCALLTYPE GetClassID( 
			/* [out] */ CLSID __RPC_FAR *pClassID);
        

	// IPersistStream
	public:
		HRESULT STDMETHODCALLTYPE IsDirty(void);
        
		HRESULT STDMETHODCALLTYPE Load( 
			/* [unique][in] */ IStream __RPC_FAR *pStm);
        
		HRESULT STDMETHODCALLTYPE Save( 
			/* [unique][in] */ IStream __RPC_FAR *pStm,
			/* [in] */ BOOL fClearDirty);
        
		HRESULT STDMETHODCALLTYPE GetSizeMax( 
			/* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
        

	// IMoniker
	public:
		/* [local] */ HRESULT STDMETHODCALLTYPE BindToObject( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [in] */ REFIID riidResult,
			/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult);
        
		/* [local] */ HRESULT STDMETHODCALLTYPE BindToStorage( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
		HRESULT STDMETHODCALLTYPE Reduce( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [in] */ DWORD dwReduceHowFar,
			/* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced);
        
		HRESULT STDMETHODCALLTYPE ComposeWith( 
			/* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
			/* [in] */ BOOL fOnlyIfNotGeneric,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite);
        
		HRESULT STDMETHODCALLTYPE Enum( 
			/* [in] */ BOOL fForward,
			/* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker);
        
		HRESULT STDMETHODCALLTYPE IsEqual( 
			/* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker);
        
		HRESULT STDMETHODCALLTYPE Hash( 
			/* [out] */ DWORD __RPC_FAR *pdwHash);
        
		HRESULT STDMETHODCALLTYPE IsRunning( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning);
        
		HRESULT STDMETHODCALLTYPE GetTimeOfLastChange( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [out] */ FILETIME __RPC_FAR *pFileTime);
        
		HRESULT STDMETHODCALLTYPE Inverse( 
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);
        
		HRESULT STDMETHODCALLTYPE CommonPrefixWith( 
			/* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix);
        
		HRESULT STDMETHODCALLTYPE RelativePathTo( 
			/* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath);
        
		HRESULT STDMETHODCALLTYPE GetDisplayName( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName);
        
		HRESULT STDMETHODCALLTYPE ParseDisplayName( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [in] */ LPOLESTR pszDisplayName,
			/* [out] */ ULONG __RPC_FAR *pchEaten,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);
        
		HRESULT STDMETHODCALLTYPE IsSystemMoniker( 
			/* [out] */ DWORD __RPC_FAR *pdwMksys);
        

	// IParseDisplayName
	public:
		HRESULT STDMETHODCALLTYPE ParseDisplayName( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [in] */ LPOLESTR pszDisplayName,
			/* [out] */ ULONG __RPC_FAR *pchEaten,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);

	DECLARE_GET_CONTROLLING_UNKNOWN();

	protected:
		HRESULT CreateBoundObject(IPropertyBag *pBag, ISEOInitObject **ppResult);
		void SetPropertyBag(IPropertyBag *pBag);
		void SetMonikerString(LPCOLESTR psString) {
			m_bstrMoniker = psString;
		}

	private: // Private data
		CComBSTR m_bstrMoniker;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\item.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	item.h

Abstract:

	This module contains the definition for the Server
	Extension Object Item class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	02/18/97	created

--*/


// item.h : Declaration of the CSEODictionaryItem

/////////////////////////////////////////////////////////////////////////////
// CSEODictionaryItem
class ATL_NO_VTABLE CSEODictionaryItem :
	public CComObjectRoot,
	public CComCoClass<CSEODictionaryItem, &CLSID_CSEODictionaryItem>,
	public IDispatchImpl<ISEODictionaryItem, &IID_ISEODictionaryItem, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEODictionaryItem Class",
								   L"SEO.SEODictionaryItem.1",
								   L"SEO.SEODictionaryItem");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEODictionaryItem)
		COM_INTERFACE_ENTRY(ISEODictionaryItem)
		COM_INTERFACE_ENTRY(IDispatch)
//		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEODictionaryItem
	public:
		HRESULT STDMETHODCALLTYPE get_Value(VARIANT *pvarIndex, VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE AddValue(VARIANT *pvarIndex, VARIANT *pvarValue);
		HRESULT STDMETHODCALLTYPE DeleteValue(VARIANT *pvarIndex);
		HRESULT STDMETHODCALLTYPE get_Count(VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE GetStringA(DWORD dwIndex, DWORD *pchCount, LPSTR pszResult);
		HRESULT STDMETHODCALLTYPE GetStringW(DWORD dwIndex, DWORD *pchCount, LPWSTR pszResult);
		HRESULT STDMETHODCALLTYPE AddStringA(DWORD dwIndex, LPCSTR pszValue);
		HRESULT STDMETHODCALLTYPE AddStringW(DWORD dwIndex, LPCWSTR pszValue);

	private:
		class ValueClass {
			public:
				ValueClass();
				ValueClass(ValueClass& vcFrom);
				~ValueClass();
				void Init();
				void Clear();
				HRESULT Assign(ValueClass& vcFrom);
				HRESULT Assign(LPCSTR pszFromA);
				HRESULT Assign(VARIANT *pvarFrom);
				HRESULT Assign(LPCWSTR pszFromW);
				HRESULT AsVariant(VARIANT *pvarResult);
				HRESULT AsStringA(DWORD *pchCount, LPSTR pszResult);
				HRESULT AsStringW(DWORD *pchCount, LPWSTR pszResult);
				void *operator new(size_t cbSize, ValueClass *pvcInPlace);
                void operator delete(void * p) {}

#if _MSC_VER >= 1200
                void operator delete(void * p, ValueClass *pvcInPlace) {}
#endif

			private:
				typedef enum tagValueEnum {
					veNone,
					veStringA,
					veVARIANT
				} ValueEnum;
				typedef struct tagValueType {
					ValueEnum veType;
					union {
						LPSTR pszStringA;
						VARIANT varVARIANT;
					};
				} ValueType;
				ValueType m_vtValue;
		};
		HRESULT AddSlot(DWORD *pdwIndex,ValueClass **ppvcResult);
		DWORD m_dwCount;
		ValueClass *m_pvcValues;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\membag.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	membag.h

Abstract:

	This module contains the definition for the
	ISEODictionary object in memory.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   02/10/97        created
	andyj   02/12/97        Converted PropertyBag's to Dictonary's

--*/

// MEMBAG.h : Declaration of the CSEOMemDictionary

// This pragma helps cl v11.00.6281 handle templates
#pragma warning(disable:4786)

#include "tfdlist.h"
#include "rwnew.h"


enum DataType {Empty, DWord, String, Interface};
class DataItem {
	public:

    typedef     DLIST_ENTRY*    (*PFNDLIST)( class  DataItem*);

		DataItem() {
            m_pszKey = NULL;
            eType = Empty;
        };
		DataItem(DWORD d) {
            eType = DWord;
            dword = d;
        };
		DataItem(LPCSTR s, int iSize = -1) {
			eType = String;
			iStringSize = ((iSize >= 0) ? iSize : (lstrlen(s) + 1));
			pStr = (LPSTR) MyMalloc(iStringSize);
			if (pStr) {
				strncpy(pStr, s, iStringSize);
			}
            m_pszKey = NULL;
		};
		DataItem(LPCWSTR s, int iSize = -1) {
			eType = String;
			iStringSize = sizeof(WCHAR) * ((iSize >= 0) ? iSize : (wcslen(s) + 1));
			pStr = (LPSTR) MyMalloc(iStringSize);
			if (pStr) {
				ATLW2AHELPER(pStr, s, iStringSize);
			}
            m_pszKey = NULL;
		};
		DataItem(IUnknown *p) {
            eType = Interface;
            pUnk = p;
            if(pUnk) pUnk->AddRef();
            m_pszKey = NULL;
        }
		DataItem(const DataItem &diItem) {
			eType = diItem.eType;
			if(eType == DWord) dword = diItem.dword;
			else if(eType == String) {
				iStringSize = diItem.iStringSize;
				pStr = (LPSTR) MyMalloc(iStringSize);
				if (pStr) {
					strncpy(pStr, diItem.pStr, iStringSize);
				}
			} else if(eType == Interface) {
				pUnk = diItem.pUnk;
				if(pUnk) pUnk->AddRef();
			}
            if (diItem.m_pszKey) {
                m_pszKey = (LPSTR) MyMalloc(lstrlen(diItem.m_pszKey) + 1);
                if (m_pszKey) {
                    strcpy(m_pszKey, diItem.m_pszKey);
                }
            } else {
                m_pszKey = NULL;
            }
		};
		DataItem &operator=(const DataItem &diItem) {
			eType = diItem.eType;
			if(eType == DWord) dword = diItem.dword;
			else if(eType == String) {iStringSize = diItem.iStringSize;
						  pStr = (LPSTR) MyMalloc(iStringSize);
						  if (pStr) {
							  strncpy(pStr, diItem.pStr, iStringSize);}
						  }
			else if(eType == Interface) {pUnk = diItem.pUnk;
						     if(pUnk) pUnk->AddRef();}
            if (diItem.m_pszKey) {
                m_pszKey = (LPSTR) MyMalloc(lstrlen(diItem.m_pszKey) + 1);
                if (m_pszKey) {
                    strcpy(m_pszKey, diItem.m_pszKey);
                }
            } else {
                m_pszKey = NULL;
            }
			return *this;
		};
		DataItem(VARIANT *pVar);
		~DataItem() {
			if(eType == String) MyFree(pStr);
			else if((eType == Interface) && pUnk) pUnk->Release();
			eType = Empty;
            if (m_pszKey) {
                MyFree(m_pszKey);
                m_pszKey = NULL;
            }
		};

        BOOL SetKey(LPCSTR pszKey) {
            if (m_pszKey) {
                MyFree(m_pszKey);
                m_pszKey = NULL;
            }
            m_pszKey = (LPSTR) MyMalloc(lstrlen(pszKey) + 1);
            if (!m_pszKey) return FALSE;

            strcpy(m_pszKey, pszKey);
            return TRUE;
        }

		BOOL IsEmpty() const {return (eType == Empty);};
		BOOL IsDWORD() const {return (eType == DWord);};
		BOOL IsString() const {return (eType == String);};
		BOOL IsInterface() const {return (eType == Interface);};

		operator DWORD() const {return (const) (IsDWORD() ? dword : 0);};
		operator LPCSTR() const {return (IsString() ? pStr : NULL);};
		LPCSTR GetString() const {return (IsString() ? pStr : NULL);};
		operator LPUNKNOWN() const {return (IsInterface() ? pUnk : NULL);};
		HRESULT AsVARIANT(VARIANT *pVar) const;
		int StringSize() const {return iStringSize;};

         static DLIST_ENTRY *GetListEntry(DataItem *p) {
            return &p->m_listentry;
        }

        LPCSTR GetKey() {
            return m_pszKey;
        }

	private:
		DataType eType;
		int iStringSize;
		union {
			DWORD dword;
			LPSTR pStr;
			LPUNKNOWN pUnk;
		};
        DLIST_ENTRY m_listentry;
        LPSTR m_pszKey;
};

class ComparableString {
	public:
		ComparableString(LPCSTR p = NULL) : m_ptr(0), m_bAlloc(TRUE) {
			if(!p) return;
			m_ptr = (LPSTR) MyMalloc(lstrlen(p) + 1);
			if (m_ptr) {
				lstrcpy(m_ptr, p);
			}
		};
		ComparableString(const ComparableString &csOther) : m_ptr(0) {
			LPCSTR p = csOther.m_ptr;
			m_ptr = (LPSTR) MyMalloc(lstrlen(p) + 1);
			if (m_ptr) {
				lstrcpy(m_ptr, p);
			}
		};
		~ComparableString() {if(m_bAlloc&&m_ptr) MyFree(m_ptr);};
		LPCSTR Data() const {return m_ptr;};
		bool operator<(const ComparableString &csOther) const {
			if (!m_ptr || !csOther.m_ptr) {
				if (csOther.m_ptr) {
					return (true);
				}
				return (false);
			}
			return (lstrcmpi(m_ptr, csOther.m_ptr) < 0);};

	protected:
		LPSTR m_ptr;
		BOOL m_bAlloc;
};

class ComparableStringRef : public ComparableString {
	public:
		ComparableStringRef(LPCSTR p) {
			m_ptr = (LPSTR) p;
			m_bAlloc = FALSE;
		};
};

// typedef std::SEOmap<ComparableString, DataItem> OurMap;

/* The following will compile in 40 (in place of the template definition of OurMap)
   It isn't funcitonal, but it will compile.  You may also have to comment out the
   include lines for HACK.H, STRING and MAP.
class OurMap {
	public:
	class iterator {
		public:
		LPCSTR first;
		DataItem second;
		void operator++() {};
		int operator!=(const iterator &i) {return 0;};
		iterator operator*() {return *this;};
	};
	class iterator2 {
		public:
		BOOL second;
	};
	iterator2 insert(DWORD) {return m_i2;};
	iterator begin() {return m_i;};
	iterator end() {return m_i;};
	iterator find(LPCSTR) {return m_i;};
	static DWORD value_type(LPCSTR pszName, DataItem diItem) {return 0;};
	iterator m_i;
	iterator2 m_i2;
};
*/

typedef TDListHead<DataItem, &DataItem::GetListEntry> OurList;

class OurMap {
    public:
        class iterator : public TDListIterator<OurList> {
            public:
                iterator(OurList *pHead)
                    : TDListIterator<OurList>(pHead)
                {
                    m_fFound = FALSE;
                }

                // get the key for the current item
                LPCSTR GetKey() {
                    return Current()->GetKey();
                }

                // get the data for the current item
                DataItem *GetData() {
                    return Current();
                }

		        void operator++() {
                    Next();
                }

		        DataItem *operator*() {
                    return Current();
                }

                void SetList(OurMap *pMap) {
                    ReBind(&(pMap->m_list));
                }

                // point the iterator to a specific item in the list
                // arguments:
                //   pszKey - key to find
                //   iMatchType - -1 == point at first item with smaller key
                //                0 == point at item with key
                //                1 == point at first item with larger key
                // returns:
                //   TRUE if a match was found, FALSE otherwise
                BOOL find(LPCSTR pszKey, DWORD iMatchType = 0) {
                    if (strncmp(pszKey, "-1", 2) == 0) DebugBreak();
                    // reset the iterator
                    Front();

                    // walk until we match the key
                    while (!AtEnd()) {
                        const char *pszCurrentKey = Current()->GetKey();
                        if (lstrcmpi(pszCurrentKey, pszKey) == iMatchType) {
                            m_fFound = TRUE;
                            return TRUE;
                        }
                        Next();
                    }
                    m_fFound = FALSE;
                    return FALSE;
                };

                // did the last search succeed?
                BOOL Found() {
                    return m_fFound;
                }
            private:
                BOOL m_fFound;
        };

        friend iterator;

        OurMap() {
            m_cList = 0;
        }

        ~OurMap() {
            // remove all items from the list
            while (m_cList) {
                delete m_list.PopFront();
                m_cList--;
            }
            _ASSERT(m_list.IsEmpty());
        }

        void erase(iterator i) {
            m_cList--;
            delete i.RemoveItem();
        }

        BOOL insert(LPCSTR pszKey, DataItem di) {
            char buf[255];

            OurMap::iterator it(&m_list);

            DataItem *pDI = new DataItem();
            if (pDI == NULL) return FALSE;

            // copy the data item to the one that we will insert into
            // our list
            *pDI = di;
            if (!pDI->SetKey(pszKey)) {
                delete pDI;
                return FALSE;
            }

            // find the first item with a larger key.  if no such item was
            // found then insert at head of list
            if (it.find(pszKey, 1)) {
                it.InsertBefore(pDI);
            } else {
                m_list.PushFront(pDI);
            }
            m_cList++;

            return TRUE;
        }


        iterator find(LPCSTR pszKey) {
            OurMap::iterator it(&m_list);

            it.find(pszKey);

            return it;
        }

        iterator begin() {
            OurMap::iterator it(&m_list);

            return it;
        }

        long size() {
            return m_cList;
        }

    private:
        OurList m_list;
        long m_cList;
};

/////////////////////////////////////////////////////////////////////////////
// CSEOMemDictionary

class ATL_NO_VTABLE CSEOMemDictionary :
	public CComObjectRoot,
	public CComCoClass<CSEOMemDictionary, &CLSID_CSEOMemDictionary>,
	public IDispatchImpl<ISEODictionary, &IID_ISEODictionary, &LIBID_SEOLib>,
	public IPropertyBag,
	public IDispatchImpl<IEventPropertyBag, &IID_IEventPropertyBag, &LIBID_SEOLib>
{
	friend class CSEOMemDictionaryEnum; // Helper class

	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOMemDictionary Class",
								   L"SEO.SEOMemDictionary.1",
								   L"SEO.SEOMemDictionary");

	BEGIN_COM_MAP(CSEOMemDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
		COM_INTERFACE_ENTRY(IPropertyBag)
		COM_INTERFACE_ENTRY(IEventPropertyBag)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventPropertyBag)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEODictionary
	public:
	virtual /* [id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Item(
	    /* [in] */ VARIANT __RPC_FAR *pvarName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Item(
	    /* [in] */ VARIANT __RPC_FAR *pvarName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [hidden][id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
	    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantA(
	    /* [in] */ LPCSTR pszName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantW(
	    /* [in] */ LPCWSTR pszName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringA(
	    /* [in] */ LPCSTR pszName,
	    /* [out][in] */ DWORD __RPC_FAR *pchCount,
	    /* [retval][size_is][out] */ LPSTR pszResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringW(
	    /* [in] */ LPCWSTR pszName,
	    /* [out][in] */ DWORD __RPC_FAR *pchCount,
	    /* [retval][size_is][out] */ LPWSTR pszResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ DWORD chCount,
	    /* [size_is][in] */ LPCSTR pszValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ DWORD chCount,
	    /* [size_is][in] */ LPCWSTR pszValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordA(
	    /* [in] */ LPCSTR pszName,
	    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordW(
	    /* [in] */ LPCWSTR pszName,
	    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ DWORD dwValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ DWORD dwValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ REFIID iidDesired,
	    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ REFIID iidDesired,
	    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ IUnknown __RPC_FAR *punkValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ IUnknown __RPC_FAR *punkValue);

		DECLARE_GET_CONTROLLING_UNKNOWN();

	// IPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
		HRESULT STDMETHODCALLTYPE Write(LPCOLESTR pszPropName, VARIANT *pVar);

	// IEventPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarPropDesired, VARIANT *pvarPropValue);
		HRESULT STDMETHODCALLTYPE Name(long lPropIndex, BSTR *pbstrPropName);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszPropName, VARIANT *pvarPropValue);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarPropDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		/*	Just use the get__NewEnum from ISEODictionary
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);	*/

	protected:
		HRESULT Insert(LPCSTR pszName, const DataItem &diItem);

	private: // Private data
		OurMap m_mData;
        CShareLockNH m_lock;

		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\membag.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	membag.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Memory Property Bag.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   02/10/97        created
	andyj   02/12/97        Converted PropertyBag's to Dictonary's

--*/

#pragma warning(disable:4786)

// MEMBAG.cpp : Implementation of CSEOMemDictionary
#include "stdafx.h"
#include "seodefs.h"
#include "hack.h"
#include "SEOmap.h"
#include "String"
#include "MEMBAG.h"


HRESULT ResolveVariant(IEventPropertyBag *pBag, VARIANT *pvarPropDesired, CComVariant &varResult) {
	if (!pvarPropDesired) {
		return (E_POINTER);
	}

	varResult.Clear();
	HRESULT hrRes = S_OK;
	CComVariant varIndex; // Hold the I4 type


	switch (pvarPropDesired->vt & VT_TYPEMASK) {
		case VT_I1:  case VT_I2:  case VT_I4:  case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
		case VT_R4:  case VT_R8:
		case VT_INT: case VT_UINT: // Any type of number
			hrRes = VariantChangeType(&varIndex, pvarPropDesired, 0, VT_I4);
			varResult.vt = VT_BSTR;
			varResult.bstrVal = NULL;
			if (SUCCEEDED(hrRes)) {
				hrRes = pBag->Name(varIndex.lVal, &varResult.bstrVal);
			}
			break;

		default: // Otherwise, convert to a string
			hrRes = VariantChangeType(&varResult, pvarPropDesired, 0, VT_BSTR);
			break;
	}

	return (hrRes);
}



HRESULT DataItem::AsVARIANT(VARIANT *pvarResult) const {
	if(!pvarResult) return E_POINTER;
	CComVariant varResult;

	if(IsDWORD()) varResult = (long) dword;
	else if(IsString()) varResult = pStr;
	else if(IsInterface()) varResult = pUnk;
	else varResult.Clear();

	return varResult.Detach(pvarResult);
}

DataItem::DataItem(VARIANT *pVar) {
	eType = Empty;
	if(!pVar) return;

	switch (pVar->vt) {
		case VT_EMPTY:
			// Already set to Empty
			break;

		case VT_I4:
			eType = DWord;
			dword = pVar->lVal;
			break;

		case VT_UNKNOWN:
		case VT_DISPATCH:
			eType = Interface;
			pUnk = pVar->punkVal;
			if(pUnk) pUnk->AddRef();
			break;

		default:
			eType = String;
			CComVariant vNew;
			vNew.ChangeType(VT_BSTR, pVar);
			iStringSize = SysStringLen(vNew.bstrVal) + 1;
			pStr = (LPSTR) MyMalloc(iStringSize * sizeof(WCHAR));
			if (pStr) {
				ATLW2AHELPER(pStr, vNew.bstrVal, iStringSize * sizeof(WCHAR));
			}
			break;
	}

    m_pszKey = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSEOMemDictionaryEnum

class CSEOMemDictionaryEnum :
	public CComObjectRoot,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_SEOLib>
{
	public:
        CSEOMemDictionaryEnum() : m_iIterator(&m_dummylist) {}
		HRESULT FinalConstruct();
		void FinalRelease();

		HRESULT STDMETHODCALLTYPE Next(DWORD, LPVARIANT, LPDWORD);
		HRESULT STDMETHODCALLTYPE Skip(DWORD);
		HRESULT STDMETHODCALLTYPE Reset(void);
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **);

		// Not Exported
		HRESULT STDMETHODCALLTYPE Init(CSEOMemDictionary *, OurMap::iterator * = NULL);

	BEGIN_COM_MAP(CSEOMemDictionaryEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
	END_COM_MAP()

	private: // Data members
		OurMap::iterator m_iIterator;
        OurList m_dummylist;
		CSEOMemDictionary *m_dictionary;
        CShareLockNH *m_pLock;
};

HRESULT CSEOMemDictionaryEnum::FinalConstruct() {
	m_dictionary = NULL;
	return S_OK;
}

void CSEOMemDictionaryEnum::FinalRelease() {
	if(m_dictionary) {
        m_dictionary->m_lock.ShareUnlock();
        m_dictionary->GetControllingUnknown()->Release();
    }
	m_dictionary = NULL;
}

STDMETHODIMP CSEOMemDictionaryEnum::Init(CSEOMemDictionary *pDict, OurMap::iterator *omi) {
	if(m_dictionary) {
        m_dictionary->m_lock.ShareUnlock();
        m_dictionary->GetControllingUnknown()->Release();
    }

	m_dictionary = pDict;

	if(m_dictionary) {
		m_dictionary->GetControllingUnknown()->AddRef();
        m_dictionary->m_lock.ShareLock();
        if (omi) {
            m_iIterator = *omi;
        } else {
		    m_iIterator.SetList(&(m_dictionary->m_mData));
        }
	}

	return S_OK;
}

STDMETHODIMP CSEOMemDictionaryEnum::Next(DWORD dwCount, LPVARIANT varDest,
					 LPDWORD pdwResultParam) {
	if(!m_dictionary) return E_FAIL; // Hasn't been properly initialized
	if(!varDest) return E_POINTER;
	DWORD dwDummy = 0;
	LPDWORD pdwResult = (pdwResultParam ? pdwResultParam : &dwDummy);
	*pdwResult = 0; // Nothing done so far
	HRESULT hrRes = S_OK; // So far, so good

    _ASSERT(m_iIterator.GetHead() != &m_dummylist);

	while(SUCCEEDED(hrRes) && (*pdwResult < dwCount) &&
	      (!(m_iIterator.AtEnd()))) {
		// Must have succeeded to get here, so OK to overwrite hrRes
		CComVariant varResult(m_iIterator.GetKey());
		if (varResult.vt == VT_ERROR) {
			if (hrRes == S_OK) hrRes = varResult.scode;
			while (*pdwResult) {
				--(*pdwResult);
				VariantClear(&varDest[*pdwResult]);
			}
			break;
		}
		VariantInit(&varDest[*pdwResult]);
		hrRes = varResult.Detach(&varDest[*pdwResult]);
		++(*pdwResult); // Increment successful count for caller
		++m_iIterator; // Point to the next one
	}

	return (FAILED(hrRes) ? hrRes : ((*pdwResult < dwCount) ? S_FALSE : S_OK));
}

STDMETHODIMP CSEOMemDictionaryEnum::Skip(DWORD dwCount) {
    _ASSERT(m_iIterator.GetHead() != &m_dummylist);
	for(DWORD i = 0; i < dwCount; ++i) ++m_iIterator;
	return ((!(m_iIterator.AtEnd())) ? S_OK : S_FALSE);
}

STDMETHODIMP CSEOMemDictionaryEnum::Reset(void) {
    _ASSERT(m_iIterator.GetHead() != &m_dummylist);
	m_iIterator.Front();
	return S_OK;
}

STDMETHODIMP CSEOMemDictionaryEnum::Clone(IEnumVARIANT **ppunkResult) {
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComPtr<CComObject<CSEOMemDictionaryEnum> > p;
	HRESULT hrRes = CComObject<CSEOMemDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	p->AddRef(); // Do this for CComPtr counting
	hrRes = p->Init(m_dictionary, &m_iIterator);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
	return hrRes;
}


/////////////////////////////////////////////////////////////////////////////
// CSEOMemDictionary


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::get_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarName || !pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	CComVariant vNew;
	HRESULT hrRes = E_INVALIDARG;

	if(SUCCEEDED(vNew.ChangeType(VT_BSTR, pvarName))) {
		hrRes = GetVariantA(W2A(vNew.bstrVal), pvarResult);

		// Convert SEO_E_NOTPRESENT to VT_EMPTY
		if(hrRes == SEO_E_NOTPRESENT) {
			VariantClear(pvarResult);
			hrRes = S_OK;
		}
	}

	return hrRes;
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::put_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarName || !pvarValue) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	CComVariant vNew;

	if(SUCCEEDED(vNew.ChangeType(VT_BSTR, pvarName))) {
		return SetVariantA(W2A(vNew.bstrVal), pvarValue);
	} else {
		return E_INVALIDARG;
	}
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::get__NewEnum(
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComPtr<CComObject<CSEOMemDictionaryEnum> > p;
	HRESULT hrRes = CComObject<CSEOMemDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	p->AddRef(); // Do this for CComPtr counting
	hrRes = p->Init(this);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
	return hrRes;
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarResult) return E_POINTER;
	OurMap::iterator theIterator = m_mData.find(pszName);

	VariantInit(pvarResult);
	if(theIterator.Found()) { // Found
		return (*theIterator)->AsVARIANT(pvarResult);
	} else {
		return SEO_E_NOTPRESENT; // Didn't find it
	}
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetVariantA(W2A(pszName), pvarResult);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarValue) return E_POINTER;
	DataItem diItem(pvarValue);
	return Insert(pszName, diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarValue) return E_POINTER;
	USES_CONVERSION; // Needed for W2A(), etc.
	DataItem diItem(pvarValue);
	return Insert(W2A(pszName), diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetStringA(
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPSTR pszResult)
{
	if(!pszResult) return E_POINTER;
	OurMap::iterator theIterator = m_mData.find(pszName);

	if(theIterator.Found()) { // Found
		if((*theIterator)->IsString()) {
			strncpy(pszResult, *(theIterator.GetData()), *pchCount);
			return (*pchCount >= (DWORD) (*theIterator)->StringSize()) ?
			       S_OK : SEO_S_MOREDATA;
		}
	}

	return SEO_E_NOTPRESENT; // Didn't find it
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPWSTR pszResult)
{
	if(!pszResult) return E_POINTER;
	USES_CONVERSION;
	OurMap::iterator theIterator = m_mData.find(W2A(pszName));

	if(theIterator.Found()) { // Found
		if((*theIterator)->IsString()) {
			int iSize = min((int) *pchCount, (*theIterator)->StringSize());
			ATLA2WHELPER(pszResult, *(theIterator.GetData()), iSize);
			return (*pchCount >= (DWORD) (*theIterator)->StringSize()) ?
			       S_OK : SEO_S_MOREDATA;
		}
	}

	return SEO_E_NOTPRESENT; // Didn't find it
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetStringA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCSTR pszValue)
{
	if(!pszValue) return E_POINTER;
	DataItem diItem(pszValue, chCount);
	return Insert(pszName, diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCWSTR pszValue)
{
	if(!pszValue) return E_POINTER;
	USES_CONVERSION;
	DataItem diItem(pszValue, chCount);
	return Insert(W2A(pszName), diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	if(!pdwResult) return E_POINTER;
	OurMap::iterator theIterator = m_mData.find(pszName);

	if(theIterator.Found()) { // Found
		if((*theIterator)->IsDWORD()) {
			*pdwResult = *(*theIterator);
			return S_OK;
		}
	}

	return SEO_E_NOTPRESENT; // Didn't find it
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetDWordA(W2A(pszName), pdwResult);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwValue)
{
	DataItem diItem(dwValue);
	return Insert(pszName, diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwValue)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	DataItem diItem(dwValue);
	return Insert(W2A(pszName), diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	if(!ppunkResult) return E_POINTER;
	OurMap::iterator theIterator = m_mData.find(pszName);

	if(theIterator.Found()) { // Found
		if((*theIterator)->IsInterface()) {
			LPUNKNOWN pObj = *(*theIterator);
			return pObj->QueryInterface(iidDesired, (LPVOID *) ppunkResult);
		}
	}

	return SEO_E_NOTPRESENT; // Didn't find it
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetInterfaceA(W2A(pszName), iidDesired, ppunkResult);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	DataItem diItem(punkValue);
	return Insert(pszName, diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	DataItem diItem(punkValue);
	return Insert(W2A(pszName), diItem);
}


HRESULT CSEOMemDictionary::FinalConstruct() {
	HRESULT hrRes;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOMemDictionary::FinalRelease() {
	m_pUnkMarshaler.Release();
}

// Four cases: (exists/not) x (Good/Empty item)
HRESULT CSEOMemDictionary::Insert(LPCSTR pszName, const DataItem &diItem) {
	HRESULT hrRes = S_OK;

    m_lock.ExclusiveLock();

    OurMap::iterator iThisItem = m_mData.find(pszName);
    // If the item was found, remove it
    if(iThisItem.Found()) m_mData.erase(iThisItem);

	// If not an empty item, try to insert it
	if(!diItem.IsEmpty() &&
	   !m_mData.insert(pszName, diItem)) {
		hrRes = E_FAIL;
	}

    m_lock.ExclusiveUnlock();

	return hrRes;
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
	HRESULT hrRes;
	VARTYPE vtType;

	if (!pszPropName || !pVar) {
		return (E_POINTER);
	}

    m_lock.ShareLock();

	vtType = pVar->vt;
//	VariantClear(pVar);
	hrRes = GetVariantW(pszPropName,pVar);
	if (SUCCEEDED(hrRes) && (vtType != VT_EMPTY)) {
		hrRes = VariantChangeType(pVar,pVar,0,vtType);
	}
	if (!SUCCEEDED(hrRes)) {
		VariantClear(pVar);
	}

    m_lock.ShareUnlock();

	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Write(LPCOLESTR pszPropName, VARIANT *pVar) {
	return (SetVariantW(pszPropName,pVar));
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Item(VARIANT *pvarPropDesired, VARIANT *pvarPropValue) {
	if (!pvarPropValue) {
		return (E_POINTER);
	}
	VariantInit(pvarPropValue);
	if (!pvarPropDesired) {
		return (E_POINTER);
	}

	CComVariant varResolved;
	HRESULT hrRes = ResolveVariant(this, pvarPropDesired, varResolved);

	if (S_OK != hrRes) { // Don't continue if S_FALSE, of FAILED(), etc.
		return (hrRes);
	}

    m_lock.ShareLock();

	hrRes = GetVariantW(varResolved.bstrVal, pvarPropValue);
	if (hrRes == SEO_E_NOTPRESENT) {
	    m_lock.ShareUnlock();
		return (S_FALSE);
	}
	if (SUCCEEDED(hrRes)) {
		VariantChangeType(pvarPropValue,pvarPropValue,0,VT_DISPATCH);
		_ASSERTE(pvarPropValue->vt!=VT_UNKNOWN);
	}

    m_lock.ShareUnlock();

	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Name(long lPropIndex, BSTR *pbstrPropName) {
    m_lock.ShareLock();

	OurMap::iterator iIterator = m_mData.begin();
	CComBSTR bstrName;

	if (!pbstrPropName) {
        m_lock.ShareUnlock();
		return (E_POINTER);
	}

	*pbstrPropName = NULL;
	if (lPropIndex < 1) {
        m_lock.ShareUnlock();
		return (S_FALSE);
	}
	while ((--lPropIndex > 0) && (!iIterator.AtEnd())) {
        ++iIterator;
	}
	if (iIterator.AtEnd()) {
        m_lock.ShareUnlock();
		return (S_FALSE);
	}
	bstrName = iIterator.GetKey();
	*pbstrPropName = bstrName.Detach();

    m_lock.ShareUnlock();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Add(BSTR pszPropName, VARIANT *pvarPropValue) {
	return (SetVariantW(pszPropName,pvarPropValue));
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Remove(VARIANT *pvarPropDesired) {
	CComVariant varResolved;

	HRESULT hrRes = ResolveVariant(this, pvarPropDesired, varResolved);

	if (S_OK != hrRes) { // Don't continue if S_FALSE, of FAILED(), etc.
		return (hrRes);
	}

    m_lock.ExclusiveLock();

	USES_CONVERSION;
	OurMap::iterator iThisItem = m_mData.find(W2A(varResolved.bstrVal));

	// If the item was found, remove it
	if(iThisItem.Found()) {
		m_mData.erase(iThisItem);
	} else {
//		_ASSERT(FALSE); // ResolveVariant should have returned something for find() to find
		hrRes = S_FALSE; // Not found
	}

    m_lock.ExclusiveUnlock();

	return hrRes;
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::get_Count(long *plCount) {

	if (!plCount) {
		return (E_POINTER);
	}
    m_lock.ShareLock();
	*plCount = m_mData.size();
    m_lock.ShareUnlock();
	return (S_OK);
}


/*	Just use get__NewEnum from ISEODictionary
HRESULT STDMETHODCALLTYPE CSEOMemDictionary::get__NewEnum(IUnknown **ppUnkEnum) {

	return (E_NOTIMPL);
}	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\metabag.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	metabag.h

Abstract:

	This module contains the definition for the
	ISEODictionary object on the Metabase.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   03/11/97        created

--*/

// METABAG.h : Declaration of the CSEOMetaDictionary

// This pragma helps cl v11.00.6281 handle templates
#pragma warning(disable:4786)


//#define TIMEOUT		15000
#define ALWAYS_LOCK	0


#define SafeStrlen(x)	((x)?wcslen(x):0)


class CGlobalInterfaceImpl {
	public:
		void Init() {
			m_pUnkObject = NULL;
			m_piGIT = NULL;
		};
		void Term() {
			if (m_pUnkObject) {
				m_pUnkObject->Release();
				m_pUnkObject = NULL;
			}
			if (m_piGIT) {
				HRESULT hrRes = m_piGIT->RevokeInterfaceFromGlobal(m_dwCookie);
				_ASSERTE(SUCCEEDED(hrRes));
				m_piGIT->Release();
				m_piGIT = NULL;
			}
		};
		bool operator!() {
			return (!m_pUnkObject&&!m_piGIT);
		};
		operator bool() {
			return (m_pUnkObject||m_piGIT);
		};
	protected:
		HRESULT Load(REFCLSID rclsid, REFIID riid) {
			return (LoadImpl(rclsid,riid,NULL));
		};
		HRESULT Load(REFIID riid, IUnknown *pUnkObject) {
			if (!pUnkObject) {
				return (E_POINTER);
			}
			return (LoadImpl(GUID_NULL,riid,pUnkObject));
		};
		HRESULT GetInterface(REFIID riid, IUnknown **ppUnkObject) {

			if (ppUnkObject) {
				*ppUnkObject = NULL;
			}
			if (!ppUnkObject) {
				return (E_POINTER);
			}
			_ASSERTE(m_pUnkObject||m_piGIT);	// Not loaded.
			_ASSERTE(!m_pUnkObject||!m_piGIT);	// Internal error.
			if (m_pUnkObject) {
				*ppUnkObject = m_pUnkObject;
				(*ppUnkObject)->AddRef();
				return (S_OK);
			}
			if (m_piGIT) {
				return (m_piGIT->GetInterfaceFromGlobal(m_dwCookie,riid,(LPVOID *) ppUnkObject));
			}
			return (E_FAIL);
		};
		HRESULT GetInterfaceQI(REFIID riid, REFIID riidDesired, LPVOID *ppvObject) {
			CComPtr<IUnknown> pUnkObject;
			HRESULT hrRes;
			
			if (ppvObject) {
				*ppvObject = NULL;
			}
			if (!ppvObject) {
				return (E_POINTER);
			}
			hrRes = GetInterface(riid,&pUnkObject);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			return (pUnkObject->QueryInterface(riidDesired,ppvObject));
		};
	private:
		HRESULT LoadImpl(REFCLSID rclsid, REFIID riid, IUnknown *pUnkObject) {
			HRESULT hrRes;

			hrRes = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
									 NULL,
									 CLSCTX_ALL,
									 IID_IGlobalInterfaceTable,
									 (LPVOID *) &m_piGIT);
			_ASSERTE(SUCCEEDED(hrRes));	// Should always succeed on NT4 SP3 and later.
			if (!SUCCEEDED(hrRes) && (hrRes != REGDB_E_CLASSNOTREG)) {
				return (hrRes);
			}
			if (!pUnkObject) {
				hrRes = CoCreateInstance(rclsid,NULL,CLSCTX_ALL,riid,(LPVOID *) &m_pUnkObject);
				if (!SUCCEEDED(hrRes)) {
					if (m_piGIT) {
						m_piGIT->Release();
						m_piGIT = NULL;
					}
					return (hrRes);
				}
			} else {
				m_pUnkObject = pUnkObject;
				m_pUnkObject->AddRef();
			}
			if (m_piGIT) {
				hrRes = m_piGIT->RegisterInterfaceInGlobal(m_pUnkObject,riid,&m_dwCookie);
				m_pUnkObject->Release();
				m_pUnkObject = NULL;
				if (!SUCCEEDED(hrRes)) {
					m_piGIT->Release();
					m_piGIT = NULL;
					return (hrRes);
				}
			}
			return (S_OK);
		};
		IUnknown *m_pUnkObject;
		DWORD m_dwCookie;
		IGlobalInterfaceTable *m_piGIT;
};


template<class T, const IID *pIID>
class CGlobalInterface : public CGlobalInterfaceImpl {
	public:
		HRESULT Load(REFCLSID rclsid) {
			return (CGlobalInterfaceImpl::Load(rclsid,*pIID));
		};
		HRESULT Load(T *pT) {
			if (!pT) {
				return (E_POINTER);
			}
			return (CGlobalInterfaceImpl::Load(*pIID,(IUnknown *) pT));
		};
		HRESULT GetInterface(T **ppT) {
			return (CGlobalInterfaceImpl::GetInterface(*pIID,(IUnknown **) ppT));
		};
		HRESULT GetInterfaceQI(REFIID riidDesired,LPVOID *ppv) {
			return (CGlobalInterfaceImpl::GetInterfaceQI(*pIID,riidDesired,ppv));
		};
};


struct IMSAdminBaseW;
class CSEOMetabaseLock;

enum LockStatus {Closed, Read, Write, Error, DontCare, InitError};


class CSEOMetabase { // Wrapper for Metabase funcitons
	public:
		CSEOMetabase() {
			m_mhHandle = METADATA_MASTER_ROOT_HANDLE;
			m_eStatus = Closed; // Closed until we delegate
			m_pszPath = (LPWSTR) MyMalloc(sizeof(*m_pszPath));
			*m_pszPath = 0;
			m_pmbDefer = NULL;
			m_hrInitRes = InitializeMetabase();

			if(!SUCCEEDED(m_hrInitRes)) {
				m_eStatus = InitError;
			}
		};
		~CSEOMetabase() {
			if(!m_pmbDefer) SetStatus(Closed); // Close self on cleanup
			if (SUCCEEDED(m_hrInitRes)) {
				TerminateMetabase();
			}
			if(m_pszPath) MyFree(m_pszPath);
			m_pszPath = NULL;
			m_pmbDefer = NULL;
		};

		void operator=(const CSEOMetabase &mbMetabase) {
			SetPath(mbMetabase.m_pszPath);
		};
		HRESULT InitShare(CSEOMetabase *pmbOther, LPCWSTR pszPath, LPUNKNOWN punkOwner = NULL) {
			LPWSTR pszTmp = NULL;

			m_punkDeferOwner = punkOwner;
			m_pmbDefer = pmbOther;
			if (pszPath) {
				pszTmp = (LPWSTR) MyMalloc(sizeof(*pszPath)*(SafeStrlen(pszPath) + 1));
				if(!pszTmp) return E_OUTOFMEMORY;
				wcscpy(pszTmp, pszPath);
			}
			if(m_pszPath) MyFree(m_pszPath);
			m_pszPath = pszTmp;
			return S_OK;
		};

		LockStatus Status() const {
			return (m_pmbDefer ? m_pmbDefer->Status() : m_eStatus);
		};
		HRESULT SetStatus(LockStatus ls, long lTimeout=15000);
		HRESULT EnumKeys(LPCWSTR pszPath, DWORD dwNum, LPWSTR pszName);
		HRESULT AddKey(LPCWSTR pszPathBuf);
		HRESULT DeleteKey(LPCWSTR pszPathBuf);
		HRESULT GetData(LPCWSTR path, DWORD &dwType, DWORD &dwLen, PBYTE pbData);
		HRESULT SetData(LPCWSTR path, DWORD dwType, DWORD dwLen, PBYTE pbData);
		HRESULT SetDWord(LPCWSTR path, DWORD dwData) {
			return SetData(path, DWORD_METADATA, sizeof(DWORD), (PBYTE) &dwData);
		};
		HRESULT SetString(LPCWSTR path, LPCWSTR psData, int iLen = -1) {
			if(iLen < 0) iLen = sizeof(*psData) * (SafeStrlen(psData) + 1);
			return SetData(path, STRING_METADATA, iLen, (PBYTE) psData);
		};
		METADATA_HANDLE GetHandle() {
			if(m_pmbDefer) {
				return m_pmbDefer->GetHandle();
			} else {
				return m_mhHandle; // Not defering, so use our handle
			}
		};

		int GetPathLength() {
			int iRet = SafeStrlen(m_pszPath);
			if(m_pmbDefer) {
				iRet += (3 + m_pmbDefer->GetPathLength());
			}
			return iRet;
		};
		LPCWSTR GetRelPath(LPWSTR psRet) { // Get the Relative Path from the original deferer
			if(!psRet) return psRet;
			if(m_pmbDefer) {
				LPWSTR psBuf = (LPWSTR) alloca(sizeof(*psBuf)*(m_pmbDefer->GetPathLength() + 1));
				m_pmbDefer->GetRelPath(psBuf);
				ConcatinatePaths(psRet,psBuf,m_pszPath);
			} else {
				*psRet = 0; // Empty string
			}
			return psRet;
		};
		LPCWSTR GetPath(LPWSTR psRet) {
			if(!psRet) return psRet;
			if(m_pmbDefer) {
				LPWSTR psBuf = (LPWSTR) alloca(sizeof(*psBuf)*(m_pmbDefer->GetPathLength() + 1));
				m_pmbDefer->GetPath(psBuf);
				ConcatinatePaths(psRet, psBuf,m_pszPath);
			} else {
				wcscpy(psRet,m_pszPath);
			}
			return psRet;
		};
		void AppendPath(LPCWSTR pszPathParam) {
			LPWSTR pszPath = (LPWSTR) alloca(sizeof(*pszPath)*(SafeStrlen(m_pszPath)+SafeStrlen(pszPathParam)+3));
			ConcatinatePaths(pszPath,m_pszPath,pszPathParam);
			SetPath(pszPath);
		};
		void SetPath(LPCWSTR pszPath) {
			LPWSTR pszTmp = NULL;
			SetStatus(Closed); // Make sure we're closed
			if (pszPath) {
				pszTmp = (LPWSTR) MyMalloc((sizeof(*pszTmp))*(SafeStrlen(pszPath)+3));
				ConcatinatePaths(pszTmp,pszPath,NULL);
			}
			if(m_pszPath) MyFree(m_pszPath);
			m_pszPath = pszTmp;
		};

		static HRESULT InitializeMetabase();
		static HRESULT TerminateMetabase();

	protected:
		void ConcatinatePaths(LPWSTR pszResult, LPCWSTR pszP1, LPCWSTR pszP2);
		HRESULT OpenPath(CSEOMetabaseLock &mbLocker, LPCWSTR pszPath,
		                 LPWSTR pszPathBuf, DWORD &dwId, LockStatus lsOpen = Read);

	private:
		LPWSTR m_pszPath;
		METADATA_HANDLE m_mhHandle;
		LockStatus m_eStatus;
		CSEOMetabase *m_pmbDefer; // Defer to this object if set
		CComPtr<IUnknown> m_punkDeferOwner; // Keep reference count
		HRESULT m_hrInitRes;

		static CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> m_MetabaseHandle;
		static CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> m_MetabaseChangeHandle;
		static int m_iCount; // Number of calls to InitializeMetabase()
};

class CSEOMetabaseLock {
	public:
		CSEOMetabaseLock(CSEOMetabase *piObject, LockStatus ls = DontCare) {
			m_bChanged = FALSE;
			m_piObject = piObject;
			if(DontCare != ls) SetStatus(ls);
		};
		~CSEOMetabaseLock() {
			if(m_bChanged) SetStatus(m_lsPrevious);
		};

		HRESULT SetStatus(LockStatus ls) {
			if(!m_piObject) return E_FAIL; // Not initialized
			m_lsPrevious = m_piObject->Status();
			HRESULT hRes = m_piObject->SetStatus(ls);
			LockStatus lsNewStatus = m_piObject->Status();
			if((lsNewStatus != m_lsPrevious) && (hRes != S_FALSE)) m_bChanged = TRUE;
			if(lsNewStatus == Closed) m_bChanged = FALSE;
			return hRes;
		};

	private:
		CSEOMetabase *m_piObject;
		BOOL m_bChanged; // True if we are responsible for restoring in our destructor
		LockStatus m_lsPrevious;
};

// The following macro may be inserted in a method to support
// reading/writing from just that method if handle not already opened.
// The object will take care of closing the handle if needed, etc.
#define METABASE_HELPER(x,y) CSEOMetabaseLock mbHelper(x, y)



/////////////////////////////////////////////////////////////////////////////
// CSEOMetaDictionary

class ATL_NO_VTABLE CSEOMetaDictionary : 
	public CComObjectRoot,
	public CComCoClass<CSEOMetaDictionary, &CLSID_CSEOMetaDictionary>,
	public ISEOInitObject,
	public IDispatchImpl<ISEODictionary, &IID_ISEODictionary, &LIBID_SEOLib>,
	public IPropertyBag,
	public IDispatchImpl<IEventPropertyBag, &IID_IEventPropertyBag, &LIBID_SEOLib>,
	public IDispatchImpl<IEventLock, &IID_IEventLock, &LIBID_SEOLib>,
	public IConnectionPointContainerImpl<CSEOMetaDictionary>,
//	public IConnectionPointImpl<CSEOMetaDictionary, &IID_IEventNotifyBindingChange>
	public CSEOConnectionPointImpl<CSEOMetaDictionary, &IID_IEventNotifyBindingChange>
{
	friend class CSEOMetaDictionaryEnum; // Helper class

	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT OnChange(LPCWSTR *apszPath);
		HRESULT GetVariantA(LPCSTR pszName, VARIANT *pvarResult, BOOL bCreate);
		HRESULT GetVariantW(LPCWSTR pszName, VARIANT *pvarResult, BOOL bCreate);

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOMetaDictionary Class",
								   L"SEO.SEOMetaDictionary.1",
								   L"SEO.SEOMetaDictionary");

	BEGIN_COM_MAP(CSEOMetaDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
		COM_INTERFACE_ENTRY(ISEOInitObject)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		COM_INTERFACE_ENTRY(IPropertyBag)
		COM_INTERFACE_ENTRY(IEventPropertyBag)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventPropertyBag)
		COM_INTERFACE_ENTRY(IEventLock)
		COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	END_COM_MAP()

	BEGIN_CONNECTION_POINT_MAP(CSEOMetaDictionary)
		CONNECTION_POINT_ENTRY(IID_IEventNotifyBindingChange)
	END_CONNECTION_POINT_MAP()

	// CSEOConnectionPointImp<>
	public:
		void AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount);
		void UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount);

	// ISEODictionary
	public:
	virtual /* [id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Item( 
	    /* [in] */ VARIANT __RPC_FAR *pvarName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
	
	virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Item( 
	    /* [in] */ VARIANT __RPC_FAR *pvarName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);
	
	virtual /* [hidden][id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
	    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantA( 
	    /* [in] */ LPCSTR pszName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantW( 
	    /* [in] */ LPCWSTR pszName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantA( 
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantW( 
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringA( 
	    /* [in] */ LPCSTR pszName,
	    /* [out][in] */ DWORD __RPC_FAR *pchCount,
	    /* [retval][size_is][out] */ LPSTR pszResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringW( 
	    /* [in] */ LPCWSTR pszName,
	    /* [out][in] */ DWORD __RPC_FAR *pchCount,
	    /* [retval][size_is][out] */ LPWSTR pszResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringA( 
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ DWORD chCount,
	    /* [size_is][in] */ LPCSTR pszValue);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringW( 
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ DWORD chCount,
	    /* [size_is][in] */ LPCWSTR pszValue);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordA( 
	    /* [in] */ LPCSTR pszName,
	    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordW( 
	    /* [in] */ LPCWSTR pszName,
	    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordA( 
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ DWORD dwValue);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordW( 
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ DWORD dwValue);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceA( 
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ REFIID iidDesired,
	    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceW( 
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ REFIID iidDesired,
	    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceA( 
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ IUnknown __RPC_FAR *punkValue);
	
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceW( 
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ IUnknown __RPC_FAR *punkValue);


	// ISEOInitObject (IPersistPropertyBag)
	public:
		virtual HRESULT STDMETHODCALLTYPE GetClassID(/* [out] */ CLSID __RPC_FAR *pClassID);

		virtual HRESULT STDMETHODCALLTYPE InitNew(void);
        
		virtual HRESULT STDMETHODCALLTYPE Load( 
			/* [in] */ IPropertyBag __RPC_FAR *pPropBag,
			/* [in] */ IErrorLog __RPC_FAR *pErrorLog);
        
		virtual HRESULT STDMETHODCALLTYPE Save( 
			/* [in] */ IPropertyBag __RPC_FAR *pPropBag,
			/* [in] */ BOOL fClearDirty,
			/* [in] */ BOOL fSaveAllProperties);

	// IPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
		HRESULT STDMETHODCALLTYPE Write(LPCOLESTR pszPropName, VARIANT *pVar);

	// IEventPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarPropDesired, VARIANT *pvarPropValue);
		HRESULT STDMETHODCALLTYPE Name(long lPropIndex, BSTR *pbstrPropName);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszPropName, VARIANT *pvarPropValue);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarPropDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		/*	Just use the get__NewEnum from ISEODictionary
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);	*/

		DECLARE_GET_CONTROLLING_UNKNOWN();

	// IEventLock
	public:
		HRESULT STDMETHODCALLTYPE LockRead(int iTimeoutMS);
		HRESULT STDMETHODCALLTYPE UnlockRead();
		HRESULT STDMETHODCALLTYPE LockWrite(int iTimeoutMS);
		HRESULT STDMETHODCALLTYPE UnlockWrite();

	protected:
		HRESULT CopyDictionary(LPCWSTR pszName, ISEODictionary *pBag);
		HRESULT Init(const CSEOMetabase &pmbOther, LPCWSTR pszPath) {
			m_mbHelper = pmbOther;
			m_mbHelper.AppendPath(pszPath);
			return S_OK;
		};
		HRESULT InitShare(CSEOMetabase &pmbOther, LPCWSTR pszPath) {
			return m_mbHelper.InitShare(&pmbOther, pszPath,
				this->GetControllingUnknown());
		};

	private: // Private data
		CSEOMetabase m_mbHelper; // The master helper
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\mimebag.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	mimebag.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Registry Property Bag.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   01/28/97	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


// MIMEBAG.cpp : Implementation of CSEOMimeDictionary
#include "stdafx.h"
#include "seodefs.h"
#include "mimeole.h"
#include "MIMEBAG.h"


inline void AnsiToBstr(BSTR &bstr, LPCSTR lpcstr) {
	if(bstr) SysFreeString(bstr);
	bstr = A2BSTR(lpcstr);
/*
	int iSize = lstrlen(lpcstr); // Number of characters to copy
	bstr = SysAllocStringLen(NULL, iSize);
	MultiByteToWideChar(CP_ACP, 0, lpcstr, -1, bstr, iSize);
*/
}

/////////////////////////////////////////////////////////////////////////////
// CSEOMimeDictionary


HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::get_Item( 
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::get_Item"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::put_Item( 
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::put_Item"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::get__NewEnum( 
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::get__NewEnum"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetVariantA( 
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetVariantA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetVariantW( 
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetVariantW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetVariantA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetVariantA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetVariantW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetVariantW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetStringA( 
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPSTR pszResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetStringA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetStringW( 
    /* [in] */ LPCWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPWSTR pszResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetStringW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetStringA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCSTR pszValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetStringA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetStringW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCWSTR pszValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetStringW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetDWordA( 
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetDWordA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetDWordW( 
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetDWordW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetDWordA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetDWordA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetDWordW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetDWordW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetInterfaceA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetInterfaceA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetInterfaceW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetInterfaceW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetInterfaceA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetInterfaceA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetInterfaceW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetInterfaceW"));
}

/*
STDMETHODIMP CSEOMimePropertyBagEx::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
	if (!pszPropName || !pVar) return (E_POINTER);

	LONG dwIdx;
	VARTYPE vtVar = pVar->vt; // Requested type
	VariantClear(pVar);
	ReadHeader();

/*
	if(vtVar == VT_UNKNOWN) || (vtVar == VT_EMPTY)) {
		// Look for a matching key
		for (dwIdx=0;dwIdx<m_dwKeyCnt;dwIdx++) {
			if (_wcsicmp(pszPropName, m_paKey[dwIdx].strName) == 0) {
				if(!m_paKey[dwIdx].pKey) { // If object doesn't already exists
					HRESULT hrRes = CComObject<CSEORegPropertyBagEx>::CreateInstance(&(m_paKey[dwIdx].pKey));
					if (!SUCCEEDED(hrRes)) return (hrRes);

					BSTR strTemp = SysAllocStringLen(m_strSubKey, wcslen(m_strSubKey) +
						       wcslen(m_paKey[dwIdx].strName) + wcslen(PATH_SEP));
					if (!strTemp) {
						RELEASE_AND_SHREAD_POINTER(m_paKey[dwIdx].pKey);
						return (E_OUTOFMEMORY);
					}

					if(wcslen(strTemp) > 0) wcscat(strTemp, PATH_SEP); // Add separator if needed
					wcscat(strTemp,m_paKey[dwIdx].strName);
					hrRes = m_paKey[dwIdx].pKey->Load(m_strMachine,(SEO_HKEY) (DWORD) m_hkBaseKey,strTemp,pErrorLog);
					SysFreeString(strTemp);

					if (!SUCCEEDED(hrRes)) {
						RELEASE_AND_SHREAD_POINTER(m_paKey[dwIdx].pKey);
						return (hrRes);
					}
				}

				pVar->vt = VT_UNKNOWN;
				pVar->punkVal = m_paKey[dwIdx].pKey;
				pVar->punkVal->AddRef(); // Increment for the copy we are about to return

				return (S_OK);
			}
		}

		if (vtVar != VT_EMPTY) return (E_INVALIDARG); // Didn't find right type to return
	}
* /
	// Look for a matching value
	for (dwIdx = 0; dwIdx < m_dwValueCnt; ++dwIdx) {
		if (_wcsicmp(pszPropName, m_paValue[dwIdx].strName) == 0) {
			HRESULT hrRes;
			VARIANT varResult;

			VariantInit(&varResult);
			varResult.vt = VT_BSTR; // | VT_BYREF;
			varResult.bstrVal = SysAllocString(m_paValue[dwIdx].strData);
			if (vtVar == VT_EMPTY) vtVar = varResult.vt;
			hrRes = VariantChangeType(pVar, &varResult, 0, vtVar);
			VariantClear(&varResult); // Not needed anymore

			if (FAILED(hrRes)) {
				VariantClear(pVar);
				if (pErrorLog) {
					// tbd
				}
				return (hrRes);
			}
			return (S_OK);
		}
	}
	return (E_INVALIDARG);
}


STDMETHODIMP CSEOMimePropertyBagEx::get_Count(LONG *plResult) {
	if(!plResult) return (E_POINTER);
	ReadHeader();
	*plResult = m_dwValueCnt;
	return (S_OK);
}


STDMETHODIMP CSEOMimePropertyBagEx::get_Name(LONG lIndex, BSTR *pstrResult) {
	if(!pstrResult) return (E_POINTER);
	ReadHeader();
	if(lIndex >= m_dwValueCnt) return (E_POINTER);
	SysFreeString(*pstrResult); // Free any existing string
	*pstrResult = SysAllocString(m_paValue[lIndex].strName);
	return (S_OK);
}


STDMETHODIMP CSEOMimePropertyBagEx::get_Type(LONG lIndex, VARTYPE *pvtResult) {
	if(!pvtResult) return (E_POINTER);
	*pvtResult = VT_BSTR;
	return (S_OK);
}


STDMETHODIMP CSEOMimePropertyBagEx::Lock() {
	m_csCritSec.Lock();
	return (S_OK);
}


STDMETHODIMP CSEOMimePropertyBagEx::Unlock() {
	m_csCritSec.Unlock();
	return (S_OK);
}
*/

HRESULT CSEOMimeDictionary::FinalConstruct() {
	m_dwValueCnt = 0;
	m_paValue = NULL;
	m_csCritSec.Init();
	m_pMessageTree = NULL; // Our copy of aggregated object
	m_pMalloc = NULL;
	HRESULT hr = E_FAIL;

	m_pMessageTree = NULL;
	// tbd: Combine these using CoCreateInstanceEx()
	hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_ALL,
	     IID_IMimeOleMalloc, (LPVOID *) &m_pMalloc);

	IUnknown *pUnkOuter = this;
	hr = CoCreateInstance(CLSID_MIMEOLE, pUnkOuter, CLSCTX_INPROC_SERVER, IID_IMimeMessageTree, (LPVOID *)&m_pMessageTree);
//	hr = CoCreateInstance(CLSID_MIMEOLE, this, CLSCTX_ALL,
//	     IID_IMimeMessageTree, (LPVOID *) &m_pMessageTree);

	if (SUCCEEDED(hr)) {
		hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	}
	return (hr);
}


void CSEOMimeDictionary::FinalRelease() {
//	Flush(NULL);

	for (LONG dwIdx = 0; dwIdx < m_dwValueCnt; ++dwIdx) {
		MySysFreeStringInPlace(&m_paValue[dwIdx].strName);
		MySysFreeStringInPlace(&m_paValue[dwIdx].strData);
	}

	m_dwValueCnt = 0;
	MyFreeInPlace(&m_paValue);

	RELEASE_AND_SHREAD_POINTER(m_pMessageTree);
	RELEASE_AND_SHREAD_POINTER(m_pMalloc);

	m_csCritSec.Term();
	m_pUnkMarshaler.Release();
}

void CSEOMimeDictionary::ReadHeader() {
	if(m_paValue) return; // Already read it

	IMimeHeader *pHeader = NULL;
	IMimeEnumHeaderLines *pEnum = NULL;
	HBODY hBody = 0;
	HEADERLINE rgLine[1];
	ULONG cLines = 0;
	LONG iEntries = 0; // Number of Header lines
	HRESULT hr = E_FAIL;

	// tbd: Error checking
	hr = m_pMessageTree->GetBody(IBL_ROOT, NULL, &hBody);
	hr = m_pMessageTree->BindToObject(hBody, IID_IMimeHeader, (LPVOID *) &pHeader);
	hr = pHeader->EnumHeaderLines(NULL, &pEnum);

	while(SUCCEEDED(hr = pEnum->Next(1, rgLine, &cLines))) {
		if(hr == S_FALSE) break;
		++iEntries;
		// Use rgLine->pszHeader and rgLine->pszLine
		m_pMalloc->FreeHeaderLineArray(cLines, rgLine, FALSE);
	}

	RELEASE_AND_SHREAD_POINTER(pEnum);
	m_dwValueCnt = iEntries;
	m_paValue = (ValueEntry *) MyMalloc(sizeof(ValueEntry) * m_dwValueCnt);
	//if (!m_paValue) return E_FAIL; // Unable to allocate memory
	hr = pHeader->EnumHeaderLines(NULL, &pEnum);
	iEntries = 0; // Start again

	while(SUCCEEDED(hr = pEnum->Next(1, rgLine, &cLines))) {
		if(hr == S_FALSE) break;
		AnsiToBstr(m_paValue[iEntries].strName, rgLine->pszHeader);
		AnsiToBstr(m_paValue[iEntries].strData, rgLine->pszLine);
		++iEntries;
		m_pMalloc->FreeHeaderLineArray(cLines, rgLine, FALSE);
	}

	RELEASE_AND_SHREAD_POINTER(pEnum);
	RELEASE_AND_SHREAD_POINTER(pHeader);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the Server
	Extension Object resources.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	11/26/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\mimebag.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	mimebag.h

Abstract:

	This module contains the definition for the
	object that wraps MimeOle with a Property Bag.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	01/28/97	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


// MIMEBAG.h : Declaration of the CSEOMimeDictionary

/////////////////////////////////////////////////////////////////////////////
// CSEOMimeDictionary
class ATL_NO_VTABLE CSEOMimeDictionary : 
	public CComObjectRoot,
	public CComCoClass<CSEOMimeDictionary, &CLSID_CSEOMimeDictionary>,
	public IDispatchImpl<ISEODictionary, &IID_ISEODictionary, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOMimeDictionary Class",
								   L"SEO.SEOMimeDictionary.1",
								   L"SEO.SEOMimeDictionary");

	BEGIN_COM_MAP(CSEOMimeDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
//		COM_INTERFACE_ENTRY(IDispatch)
//		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMimeMessageTree, m_pMessageTree)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMimeOleMalloc, m_pMalloc)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEODictionary
	public:
        virtual /* [id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT __RPC_FAR *pvarName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT __RPC_FAR *pvarName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [hidden][id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantA( 
            /* [in] */ LPCSTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantW( 
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringA( 
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pchCount,
            /* [retval][size_is][out] */ LPSTR pszResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringW( 
            /* [in] */ LPCWSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pchCount,
            /* [retval][size_is][out] */ LPWSTR pszResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD chCount,
            /* [size_is][in] */ LPCSTR pszValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD chCount,
            /* [size_is][in] */ LPCWSTR pszValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordA( 
            /* [in] */ LPCSTR pszName,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordW( 
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD dwValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ REFIID iidDesired,
            /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ REFIID iidDesired,
            /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ IUnknown __RPC_FAR *punkValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ IUnknown __RPC_FAR *punkValue);

		DECLARE_GET_CONTROLLING_UNKNOWN();

	private: // Implementation member functions
		void ReadHeader();

	private: // Private data
		IMimeMessageTree *m_pMessageTree; // Our copy of aggregated object
		IMimeOleMalloc *m_pMalloc;
		LONG m_dwValueCnt;
		struct ValueEntry {
			BSTR strName;
			//DWORD dwType;
			BSTR strData;
			//BOOL bDirty;
		} *m_paValue;
		CComObjectThreadModel::CriticalSection m_csCritSec;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\metabag.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	metabag.cpp

Abstract:

	This module contains the implementation for an ISEODicitonary
	Object on the Metabase.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   03/11/97        created

--*/

#pragma warning(disable:4786)

// METABAG.cpp : Implementation of CSEOMetaDictionary

#include "stdafx.h"
#include "seodefs.h"
//#include "IISCNFG.H"
//#include "initguid.h"         // Don't do this here - this is done by seo.cpp
#include "IADMW.H"
#include "METABAG.h"
#include <stdarg.h>
#include <stdio.h>


#ifdef DEBUG
	#define MY_OUTPUT_DEBUG_STRING(x)	OutputDebugString("SEO.DLL: " x);
	#define MY_OUTPUT_DEBUG_STRING_HR(hr,x)	if (FAILED(hr)) { MY_OUTPUT_DEBUG_STRING(x) }
#else
	#define MY_OUTPUT_DEBUG_STRING(x)
	#define MY_OUTPUT_DEBUG_STRING_HR(hr,x)
#endif

#if 1
	#define MY_ASSERTE(x)				_ASSERTE(x)
	#define MY_ASSERTE_CHK_HR(hr,chk)	MY_ASSERTE(chk(hr))
#else
	#ifdef DEBUG
		inline BOOL __assert_output(LPCSTR pszFile, DWORD dwLine, LPCSTR pszFmt, ...) {
			CHAR szOutput[512];
			LPSTR pszOutput;
			DWORD dwLen;

			_snprintf(szOutput,510,"ASSERT: %s(%u): \r\n",pszFile,dwLine);
			dwLen = lstrlen(szOutput);
			if (dwLen < 508) {
				va_list valArgs;

				va_start(valArgs,pszFmt);
				pszOutput = szOutput + dwLen - 2;
				_vsnprintf(pszOutput,508-dwLen,pszFmt,valArgs);
				lstrcat(szOutput,"\r\n");
				va_end(valArgs);
			}
			OutputDebugString(szOutput);
			DebugBreak();
			return (FALSE);
		}
		#define MY_ASSERTE(x)				((x)?1:__assert_output(__FILE__,__LINE__,#x))
		#define MY_ASSERTE_CHK_HR(hr,chk)	(chk(hr)?1:__assert_output(__FILE__,__LINE__,"hr=0x%x",(hr)))
	#else
		#define MY_ASSERTE(X)
		#define MY_ASSERTE_CHK_HR(hr,chk)
	#endif
#endif
#define MY_ASSERTE_HR(hr)		MY_ASSERTE_CHK_HR(hr,SUCCEEDED)
#define MY_CHK_RPC_HR(hr)		(SUCCEEDED(hr) || \
								 (HRESULT_FACILITY(hr)==FACILITY_RPC) || \
								 ((hr)==HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE)) || \
								 ((hr)==HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE)))
#define MY_ASSERTE_RPC_HR(hr)	MY_ASSERTE_CHK_HR(hr,MY_CHK_RPC_HR)


/////////////////////////////////////////////////////////////////////////////
// CChangeNotify
class ATL_NO_VTABLE CChangeNotify :
	public CComObjectRoot,
//	public CComCoClass<CChangeNotify, &CLSID_CChangeNotify>,
	public IMSAdminBaseSinkW
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT Advise(CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> *pMetabaseHandle);
		HRESULT Unadvise();
		HRESULT AddNotify(CSEOMetaDictionary *pNotify);
		HRESULT RemoveNotify(CSEOMetaDictionary *pNotify);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CChangeNotify);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"ChangeNotify Class",
//								   L"Metabag.ChangeNotify.1",
//								   L"Metabag.ChangeNotify");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CChangeNotify)
		COM_INTERFACE_ENTRY_IID(IID_IMSAdminBaseSink_W, IMSAdminBaseSinkW)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IMSAdminBaseSinkW
	public:
		HRESULT STDMETHODCALLTYPE SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]);
		HRESULT STDMETHODCALLTYPE ShutdownNotify(void);

	private:
		CComPtr<IEventLock> m_pLock;
		DWORD m_dwNotifyCount;
		CSEOMetaDictionary **m_apNotify;
		DWORD m_dwCookie;
        CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> *m_pMetabaseHandle;
		BOOL m_bConnected;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CChangeNotify


HRESULT CChangeNotify::FinalConstruct() {
	TraceFunctEnter("CChangeNotify::FinalConstruct");
	HRESULT hrRes = S_OK;

	m_dwNotifyCount = 0;
	m_apNotify = NULL;
    m_pMetabaseHandle = NULL;
	m_bConnected = FALSE;
	hrRes = CoCreateInstance(CLSID_CEventLock,NULL,CLSCTX_ALL,IID_IEventLock,(LPVOID *) &m_pLock);
	MY_OUTPUT_DEBUG_STRING_HR(hrRes,"CChangeNotify::FinalConstruct - CoCreateInstance failed.\n")
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		MY_OUTPUT_DEBUG_STRING_HR(hrRes,"CChangeNotify::FinalConstruct - CoCreateFreeThreadedMarshaler failed.\n")
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CChangeNotify::FinalRelease() {
	TraceFunctEnter("CChangeNotify::FinalRelease");

	_ASSERTE(!m_apNotify);
	_ASSERTE(!m_pMetabaseHandle);
	_ASSERTE(!m_bConnected);
	m_pLock.Release();
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CChangeNotify::Advise(CGlobalInterface<IMSAdminBase,&IID_IMSAdminBase_W> *pMetabaseHandle) {
	HRESULT hrRes;
    CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	CComQIPtr<IMSAdminBaseSinkW,&IID_IMSAdminBaseSink_W> pThis = this;

	_ASSERTE(pThis);
	hrRes = m_pLock->LockWrite(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(!m_apNotify);
	_ASSERTE(!m_pMetabaseHandle);
	if (!pMetabaseHandle) {
		m_pLock->UnlockWrite();
		return (E_POINTER);
	}
	m_pMetabaseHandle = pMetabaseHandle;
    hrRes = m_pMetabaseHandle->GetInterfaceQI(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
    if (!SUCCEEDED(hrRes)) {
        m_pMetabaseHandle = NULL;
		m_pLock->UnlockWrite();
		MY_ASSERTE_RPC_HR(hrRes);	// expected metabase to implement IConnectionPointContainer
		return (S_OK);
    }
	hrRes = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
	_ASSERTE(!SUCCEEDED(hrRes)||pCP);
	if (!SUCCEEDED(hrRes)) {
        m_pMetabaseHandle = NULL;
		m_pLock->UnlockWrite();
		MY_ASSERTE_RPC_HR(hrRes);	// expected metabase to source IMSAdminBaseSink_W
		return (S_OK);
	}
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT CChangeNotify::Unadvise() {
	HRESULT hrRes;
    CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;

    if (!m_pMetabaseHandle) {
        return (S_OK);
    }
	hrRes = m_pLock->LockWrite(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (m_apNotify) {
		CoTaskMemFree(m_apNotify);
		m_apNotify = NULL;
	}
    hrRes = m_pMetabaseHandle->GetInterfaceQI(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
    if (!SUCCEEDED(hrRes)) {
        m_pMetabaseHandle = NULL;
		m_pLock->UnlockWrite();
		MY_ASSERTE_RPC_HR(hrRes);	// expected metabase to implement IConnectionPointContainer
		return (hrRes);
    }
	hrRes = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
	_ASSERTE(!SUCCEEDED(hrRes)||pCP);
	if (!SUCCEEDED(hrRes)) {
        m_pMetabaseHandle = NULL;
		m_pLock->UnlockWrite();
		MY_ASSERTE_RPC_HR(hrRes);	// expected metabase to source IMSAdminBaseSink_W
		return (hrRes);
	}
	if (m_dwNotifyCount) {
		_ASSERTE(FALSE);	// Object leak detected!
		hrRes = pCP->Unadvise(m_dwCookie);
		MY_ASSERTE_RPC_HR(hrRes);
	}
    m_pMetabaseHandle = NULL;
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT CChangeNotify::AddNotify(CSEOMetaDictionary *pNotify) {
	HRESULT hrRes;
	CSEOMetaDictionary **apNotify;

	if (!pNotify) {
		return (E_POINTER);
	}
    if (!m_pMetabaseHandle) {
        return (S_OK);
    }
	hrRes = m_pLock->LockWrite(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	apNotify = (CSEOMetaDictionary **) CoTaskMemRealloc(m_apNotify,sizeof(CSEOMetaDictionary *)*(m_dwNotifyCount+1));
	if (!apNotify) {
		m_pLock->UnlockWrite();
		return (E_OUTOFMEMORY);
	}
	m_apNotify = apNotify;
	m_apNotify[m_dwNotifyCount] = pNotify;
	m_dwNotifyCount++;
	if (!m_bConnected) {
        CComPtr<IConnectionPointContainer> pCPC;
		CComPtr<IConnectionPoint> pCP;
		CComQIPtr<IMSAdminBaseSinkW,&IID_IMSAdminBaseSink_W> pThis = this;

		_ASSERTE(m_dwNotifyCount==1);
		m_bConnected = TRUE;
		m_pLock->UnlockWrite();
		_ASSERTE(pThis);
        hrRes = m_pMetabaseHandle->GetInterfaceQI(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
        if (SUCCEEDED(hrRes)) {
    		hrRes = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
			MY_ASSERTE_RPC_HR(hrRes);
    		if (SUCCEEDED(hrRes)) {
    			hrRes = pCP->Advise(pThis,&m_dwCookie);
    			_ASSERTE(SUCCEEDED(hrRes));
    		}
        }
	} else {
		m_pLock->UnlockWrite();
	}
	return (S_OK);
}


HRESULT CChangeNotify::RemoveNotify(CSEOMetaDictionary *pNotify) {
	HRESULT hrRes;
	DWORD dwIdx;

	if (!pNotify) {
		return (E_POINTER);
	}
    if (!m_pMetabaseHandle) {
        return (S_OK);
    }
	hrRes = m_pLock->LockWrite(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (!m_apNotify) {
		m_pLock->UnlockWrite();
		return (S_FALSE);
	}
	for (dwIdx=0;dwIdx<m_dwNotifyCount;dwIdx++) {
		if (m_apNotify[dwIdx] == pNotify) {
			break;
		}
	}
	if (dwIdx == m_dwNotifyCount) {
		m_pLock->UnlockWrite();
		return (S_FALSE);
	}
	m_apNotify[dwIdx] = m_apNotify[m_dwNotifyCount-1];
	m_apNotify[m_dwNotifyCount-1] = NULL;
	m_dwNotifyCount--;
	if (!m_dwNotifyCount) {
        CComPtr<IConnectionPointContainer> pCPC;
		CComPtr<IConnectionPoint> pCP;
		DWORD dwCookie = m_dwCookie;

		_ASSERTE(m_bConnected);
		m_bConnected = FALSE;
		m_pLock->UnlockWrite();
        hrRes = m_pMetabaseHandle->GetInterfaceQI(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
		MY_ASSERTE_RPC_HR(hrRes);
        if (SUCCEEDED(hrRes)) {
    		hrRes = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
			MY_ASSERTE_RPC_HR(hrRes);
    		if (SUCCEEDED(hrRes)) {
    			hrRes = pCP->Unadvise(dwCookie);
				MY_ASSERTE_RPC_HR(hrRes);
    		}
        }
	} else {
		m_pLock->UnlockWrite();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CChangeNotify::SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]) {
	HRESULT hrRes;
	CComPtr<IEventLock> pLock = m_pLock;
	CSEOMetaDictionary **apNotify;
	DWORD dwIdx;
	LPCWSTR *apszChange;

	_ASSERTE(dwMDNumElements&&pcoChangeList);
	if (!pcoChangeList) {
		return (E_POINTER);
	}
	if (!dwMDNumElements) {
		return (S_OK);
	}
	hrRes = pLock->LockRead(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (!m_apNotify || !m_dwNotifyCount) {
		pLock->UnlockRead();
		return (S_OK);
	}
	apNotify = (CSEOMetaDictionary **) _alloca(sizeof(CSEOMetaDictionary *)*(m_dwNotifyCount+1));
	if (!apNotify) {
		_ASSERTE(FALSE);
		pLock->UnlockRead();
		return (E_OUTOFMEMORY);
	}
	apszChange = (LPCWSTR *) _alloca(sizeof(LPWSTR)*(dwMDNumElements+1));
	if (!apszChange) {
		_ASSERTE(FALSE);
		pLock->UnlockRead();
		return (E_OUTOFMEMORY);
	}
	memcpy(apNotify,m_apNotify,sizeof(CSEOMetaDictionary *)*m_dwNotifyCount);
	apNotify[m_dwNotifyCount] = NULL;
	for (dwIdx=0;apNotify[dwIdx];dwIdx++) {
		apNotify[dwIdx]->GetControllingUnknown()->AddRef();
	}
	pLock->UnlockRead();
	pLock.Release();
	for (dwIdx=0;dwIdx<dwMDNumElements;dwIdx++) {
		apszChange[dwIdx] = pcoChangeList[dwIdx].pszMDPath;
	}
	apszChange[dwMDNumElements] = NULL;
	for (dwIdx=0;apNotify[dwIdx];dwIdx++) {
		hrRes = apNotify[dwIdx]->OnChange(apszChange);
		_ASSERTE(SUCCEEDED(hrRes));
		apNotify[dwIdx]->GetControllingUnknown()->Release();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CChangeNotify::ShutdownNotify(void) {

	// tbd
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////


LPCWSTR szSeparator = L"/";
LPCOLESTR szSaveKey = OLESTR("MetabasePath");

static CComObject<CChangeNotify> *g_pChangeNotify;

HRESULT ResolveVariant(IEventPropertyBag *pBag, VARIANT *pvarPropDesired, CComVariant &varResult);


// Static member variables
CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> CSEOMetabase::m_MetabaseHandle;
CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> CSEOMetabase::m_MetabaseChangeHandle;
int CSEOMetabase::m_iCount = 0;

HRESULT CSEOMetabase::InitializeMetabase() {
	EnterCriticalSection(&_Module.m_csWindowCreate);
	if (m_iCount++) {
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return S_OK;    // Already initialized
	}
    m_MetabaseHandle.Init();
	m_MetabaseChangeHandle.Init();
    HRESULT hRes = m_MetabaseHandle.Load(CLSID_MSAdminBase_W);
    if (FAILED(hRes)) {
		MY_OUTPUT_DEBUG_STRING("CSEOMetabase::InitializeMetabase - m_MetabaseHandle.Load failed.\n")
		TerminateMetabase();
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return hRes;
    }
	hRes = m_MetabaseChangeHandle.Load(CLSID_MSAdminBase_W);
    if (FAILED(hRes)) {
		MY_OUTPUT_DEBUG_STRING("CSEOMetabase::InitializeMetabase - m_MetabaseChangeHandle.Load failed.\n")
		TerminateMetabase();
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return hRes;
    }
	hRes = CComObject<CChangeNotify>::CreateInstance(&g_pChangeNotify);
	if (!SUCCEEDED(hRes)) {
		MY_OUTPUT_DEBUG_STRING("CSEOMetabase::InitializeMetabase - CComObject<CChangeNotify>::CreateInstance failed.\n")
		TerminateMetabase();
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return (hRes);
	}
	g_pChangeNotify->GetControllingUnknown()->AddRef();
	hRes = g_pChangeNotify->Advise(&m_MetabaseChangeHandle);
	if (!SUCCEEDED(hRes)) {
		MY_OUTPUT_DEBUG_STRING("CSEOMetabase::InitializeMetabase - g_pChangeNotify->Advise failed.\n")
		TerminateMetabase();
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return (hRes);
	}

	LeaveCriticalSection(&_Module.m_csWindowCreate);
	return hRes;
}

HRESULT CSEOMetabase::TerminateMetabase()
{
	EnterCriticalSection(&_Module.m_csWindowCreate);
	--m_iCount;
	if(m_iCount > 0) {
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return S_OK; // More copies still using it
	}

	if (g_pChangeNotify) {
		g_pChangeNotify->Unadvise();
		g_pChangeNotify->GetControllingUnknown()->Release();
		g_pChangeNotify = NULL;
	}
	if(m_MetabaseHandle) {
        m_MetabaseHandle.Term();
	}
	if(m_MetabaseChangeHandle) {
        m_MetabaseChangeHandle.Term();
	}

	LeaveCriticalSection(&_Module.m_csWindowCreate);
	return S_OK;
}

HRESULT CSEOMetabase::SetStatus(LockStatus ls, long lTimeout) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
	if(m_pmbDefer) {
		return m_pmbDefer->SetStatus(ls, lTimeout);
	}

	if(!m_MetabaseHandle) return E_FAIL;
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	// tbd: Do we need to count open requests, and wait for same number of close requests?
	if(m_eStatus == Error) return E_FAIL;
	if(m_eStatus == ls) return S_OK; // Already in desired state

	hRes = E_FAIL;
	if(m_eStatus == Closed) {
		if((ls == Read) || (ls == Write)) {
			DWORD dwAccess = ((ls == Write) ? METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ :
							  METADATA_PERMISSION_READ);
			hRes = piMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
					      m_pszPath, dwAccess, lTimeout, &m_mhHandle);

			// If it failed, and we're trying to write, try to create it
			if(FAILED(hRes) && (ls == Write)) {
				METADATA_HANDLE mhTemp;
				hRes = piMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
									  NULL, dwAccess, lTimeout, &mhTemp);
				if(SUCCEEDED(hRes)) {
					piMetabase->AddKey(mhTemp, m_pszPath); // Create Path
					piMetabase->CloseKey(mhTemp); // Close the temp handle
					// And try one more time
					hRes = piMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
										  m_pszPath, dwAccess, lTimeout, &m_mhHandle);
				}
			}

			if(SUCCEEDED(hRes)) {
				m_eStatus = ls;
			}
		} // Else unknown request
	} else if(ls == Closed) {
//		if(m_eStatus == Write) piMetabase->SaveData(); // I'm not sure if CloseKey() does this
		hRes = piMetabase->CloseKey(m_mhHandle);
		m_eStatus = Closed;
		m_mhHandle = METADATA_MASTER_ROOT_HANDLE;
	} else if ((ls == Read) && (m_eStatus == Write)) {
		hRes = S_FALSE;
	} // Else trying to change state while already opened

	return hRes;
}

// Opens the specified path and returns a new string to use as the path
HRESULT CSEOMetabase::OpenPath(CSEOMetabaseLock &mbLocker, LPCWSTR pszPath,
			    LPWSTR pszPathBuf, DWORD &dwId, LockStatus lsOpen) {
	HRESULT hRes = S_OK;

	if (InitError == m_hrInitRes) {
		return (m_hrInitRes);
	}
	if(m_pmbDefer) { // If we're defering
		hRes = mbLocker.SetStatus(lsOpen); // Open the master
		LPWSTR pszPathTmp = (LPWSTR) GetRelPath((LPWSTR) alloca(sizeof(*pszPath)*(GetPathLength() + 1)));
		ConcatinatePaths(pszPathBuf,pszPathTmp,pszPath);
	} else {
		hRes = mbLocker.SetStatus(lsOpen);
		if(pszPath) { // If there's something to copy
			wcscpy(pszPathBuf,pszPath);
		} else {
			pszPathBuf[0] = 0; // Treat null string like an empty string
		}
	}

	// Future: parse path for //# to indicate a specific entry for dwId
	dwId = 0;

	return hRes;
}

HRESULT CSEOMetabase::EnumKeys(LPCWSTR pszPath, DWORD dwNum, LPWSTR pszName) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
	if(Error == Status()) {
		return MD_ERROR_NOT_INITIALIZED; // or E_FAIL;
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	CSEOMetabaseLock mbLocker(this);
	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	DWORD dwDummyId = 0; // Not used in Enum
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, dwDummyId);
	if(FAILED(hRes)) return hRes;

	return piMetabase->EnumKeys(GetHandle(), pszPathBuf, pszName, dwNum);
}

HRESULT CSEOMetabase::GetData(LPCWSTR pszPath, DWORD &dwType, DWORD &dwLen, PBYTE pbData) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
	if(Error == Status()) {
		return MD_ERROR_NOT_INITIALIZED; // or E_FAIL;
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	METADATA_RECORD mdrData;
	DWORD dwRequiredDataLen = 0;
	CSEOMetabaseLock mbLocker(this);
	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, mdrData.dwMDIdentifier);
	if(FAILED(hRes)) return hRes;

	// Initialize data
	mdrData.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrData.dwMDUserType = 0;
	mdrData.dwMDDataType = 0;
	mdrData.dwMDDataLen = dwLen;
	mdrData.pbMDData = (PBYTE) alloca(dwLen);
	mdrData.dwMDDataTag = 0;

	hRes = piMetabase->GetData(GetHandle(), pszPathBuf,
					             &mdrData, &dwRequiredDataLen);

	// Set values for return
	dwType = mdrData.dwMDDataType;

	if(dwType == EXPANDSZ_METADATA) { // It needs environment string substitutions
		// Save the new size in mdrData.dwMDDataLen
		mdrData.dwMDDataLen = ExpandEnvironmentStringsW((LPCWSTR) mdrData.pbMDData, (LPWSTR) pbData, dwLen);
		dwType = STRING_METADATA; // Don't need to expand anymore
		if(!mdrData.dwMDDataLen && *pbData) hRes = E_FAIL;
	} else {
		memcpy(pbData, mdrData.pbMDData, min(dwLen, mdrData.dwMDDataLen));
	}

//      if(mdrData.dwMDDataTag) m_piMetabase->ReleaseReferenceData(mdrData.dwMDDataTag); - No longer needed
	dwLen = ((HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hRes) ? dwRequiredDataLen : mdrData.dwMDDataLen);

	switch (hRes) { // Translate return code
		case ERROR_PATH_NOT_FOUND:
		case MD_ERROR_DATA_NOT_FOUND:
			hRes = SEO_E_NOTPRESENT;
			break;

		case HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
			hRes = SEO_S_MOREDATA;
			break;

		case ERROR_SUCCESS:
			hRes = S_OK;
			break;
	}

	return hRes;
}

// Add path if it doesn't exist already
HRESULT CSEOMetabase::AddKey(LPCWSTR pszPath) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	CSEOMetabaseLock mbLocker(this);
	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	DWORD dwDummyId = 0; // Not needed for AddKey()
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, dwDummyId, Write);
	if(FAILED(hRes)) return hRes;
	if(Status() != Write) return E_FAIL; // Couldn't open for Writing

	hRes = piMetabase->AddKey(GetHandle(), pszPathBuf); // Make sure path exists
	if (hRes == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) {
		hRes = S_OK;
	}
	return (hRes);
}

HRESULT CSEOMetabase::DeleteKey(LPCWSTR pszPath) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	CSEOMetabaseLock mbLocker(this);
	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	DWORD dwDummyId = 0; // Not needed for DeleyeKey()
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, dwDummyId, Write);
	if(FAILED(hRes)) return hRes;
	if(Status() != Write) return E_FAIL; // Couldn't open for Writing

	hRes = piMetabase->DeleteKey(GetHandle(), pszPathBuf); // Make sure path does not exist
	if (hRes == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
		hRes = S_OK;
	}
	return (hRes);
}


HRESULT CSEOMetabase::SetData(LPCWSTR pszPath, DWORD dwType, DWORD dwLen, PBYTE pbData) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	METADATA_RECORD mdrData;
	DWORD dwRequiredDataLen = 0;
	CSEOMetabaseLock mbLocker(this);

	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, mdrData.dwMDIdentifier, Write);
	if(FAILED(hRes)) return hRes;
	if(Status() != Write) return E_FAIL; // Couldn't open for Writing

	// Initialize data
	mdrData.dwMDAttributes = 0;
	mdrData.dwMDUserType = 0;
	mdrData.dwMDDataType = dwType;
	mdrData.dwMDDataLen = dwLen;
	mdrData.pbMDData = pbData;
	mdrData.dwMDDataTag = 0;

	if(pbData) { // If it's a non-NULL pointer
		PBYTE pbTemp = (PBYTE) alloca(dwLen + 1); // Make sure string is null-terminated

		if((dwType == STRING_METADATA) && // If it's a string
		   ((dwLen < 1) || pbData[dwLen - 1])) { // And it's not null-terminated
			memcpy(pbTemp, pbData, dwLen);
			pbTemp[dwLen] = 0; // Terminate new string
			++dwLen; // Include null terminator in length
			mdrData.dwMDDataLen = dwLen; // New Length
			mdrData.pbMDData = pbTemp; // Point to new string
		}

		piMetabase->AddKey(GetHandle(), pszPathBuf); // Make sure path exists
		return piMetabase->SetData(GetHandle(), pszPathBuf, &mdrData);
	} else { // NULL pointer, so delete it
		// m_piMetabase->DeleteData(GetHandle(), pbPathBuf, 0, ALL_METADATA);
		return piMetabase->DeleteKey(GetHandle(), pszPathBuf);
	}
}

void CSEOMetabase::ConcatinatePaths(LPWSTR pszResult, LPCWSTR pszP1, LPCWSTR pszP2) {
	pszResult[0] = 0;
	if(pszP1 && *pszP1) {
		//if(szSeparator[0] != pszP1[0]) lstrcat(pszResult, szSeparator);
		wcscat(pszResult, pszP1);
	}

	if(pszP2) { // && *pszP2) {
		if(szSeparator[0] != pszResult[wcslen(pszResult) - 1]) wcscat(pszResult, szSeparator);
		if(!*pszP2) {
			wcscat(pszResult, szSeparator);
		} else {
			//lstrcat(pszResult, pszP2 + ((szSeparator[0] != pszP2[0]) ? 0 : lstrlen(szSeparator)));
			wcscat(pszResult, pszP2);
		}
	}

	//int iLast = lstrlen(pszResult) - 1;
	//if((iLast >= 0) && (szSeparator[0] == pszResult[iLast])) pszResult[iLast] = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CSEOMetaDictionaryEnum

class CSEOMetaDictionaryEnum : 
	public CComObjectRoot,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

		HRESULT STDMETHODCALLTYPE Next(DWORD, LPVARIANT, LPDWORD);
		HRESULT STDMETHODCALLTYPE Skip(DWORD);
		HRESULT STDMETHODCALLTYPE Reset(void);
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **);

		// Not Exported
		HRESULT STDMETHODCALLTYPE Init(CSEOMetaDictionary *, DWORD dwIndex = 0);

	BEGIN_COM_MAP(CSEOMetaDictionaryEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
	END_COM_MAP()

	private: // Data members
		CSEOMetaDictionary *m_dictionary;
		DWORD m_dwIndex;
};

HRESULT CSEOMetaDictionaryEnum::FinalConstruct() {
	m_dictionary = NULL;
	m_dwIndex = 0;
	return S_OK;
}

void CSEOMetaDictionaryEnum::FinalRelease() {
	if(m_dictionary) m_dictionary->GetControllingUnknown()->Release();
	m_dictionary = NULL;
}

STDMETHODIMP CSEOMetaDictionaryEnum::Init(CSEOMetaDictionary *pDict, DWORD dwIndex) {
	if(m_dictionary) m_dictionary->GetControllingUnknown()->Release();
	m_dictionary = pDict;
	m_dwIndex = dwIndex;

	if(m_dictionary) {
		m_dictionary->GetControllingUnknown()->AddRef();
	}

	return S_OK;
}

STDMETHODIMP CSEOMetaDictionaryEnum::Next(DWORD dwCount, LPVARIANT varDest,
					 LPDWORD pdwResultParam) {
	if(!m_dictionary) return E_FAIL; // Hasn't been properly initialized
	if(!varDest) return E_POINTER;
	WCHAR szName[METADATA_MAX_NAME_LEN];
	DWORD dwDummy = 0;
	LPDWORD pdwResult = (pdwResultParam ? pdwResultParam : &dwDummy);
	*pdwResult = 0; // Nothing done so far
	HRESULT hrRes = S_OK; // So far, so good

	while((S_OK == hrRes) && (*pdwResult < dwCount)) {
		// Must have succeeded to get here, so OK to overwrite hrRes
		hrRes = m_dictionary->m_mbHelper.EnumKeys(NULL, m_dwIndex, szName);

		if(SUCCEEDED(hrRes)) {
			CComVariant varResult(szName);
			VariantInit(&varDest[*pdwResult]);
			hrRes = varResult.Detach(&varDest[*pdwResult]);
			++(*pdwResult); // Increment successful count for caller
			++m_dwIndex; // Point to the next one
		}
	}

	if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hrRes) hrRes = S_FALSE;
	if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hrRes) hrRes = S_FALSE;
	return (FAILED(hrRes) ? hrRes : ((*pdwResult < dwCount) ? S_FALSE : hrRes));
}

STDMETHODIMP CSEOMetaDictionaryEnum::Skip(DWORD dwCount) {
	m_dwIndex += dwCount;
	return S_OK;
}

STDMETHODIMP CSEOMetaDictionaryEnum::Reset(void) {
	m_dwIndex = 0;
	return S_OK;
}

STDMETHODIMP CSEOMetaDictionaryEnum::Clone(IEnumVARIANT **ppunkResult) {
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComPtr<CComObject<CSEOMetaDictionaryEnum> > p;
	HRESULT hrRes = CComObject<CSEOMetaDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	p->AddRef(); // Do this for CComPtr counting
	hrRes = p->Init(m_dictionary, m_dwIndex);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
	return hrRes;
}


/////////////////////////////////////////////////////////////////////////////
// CSEOMetaDictionary


// The following macro may be inserted in a method to support
// reading/writing from just that method if handle not already opened.
// The object will take care of close the handle if needed, etc.
#define METABASE_READ  METABASE_HELPER(m_mbHelper, Read)
#define METABASE_WRITE METABASE_HELPER(m_mbHelper, Write)


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::get_Item( 
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarName || !pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	CComVariant vNew;
	HRESULT hrRes = E_INVALIDARG;

	if(SUCCEEDED(vNew.ChangeType(VT_BSTR, pvarName))) {
		hrRes = GetVariantA(W2A(vNew.bstrVal), pvarResult);

		// Convert SEO_E_NOTPRESENT to VT_EMPTY
		if(SEO_E_NOTPRESENT == hrRes) {
			VariantClear(pvarResult);
			hrRes = S_OK;
		}
	}

	return hrRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::put_Item( 
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarName || !pvarValue) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	CComVariant vNew;

	if(SUCCEEDED(vNew.ChangeType(VT_BSTR, pvarName))) {
		return SetVariantA(W2A(vNew.bstrVal), pvarValue);
	} else {
		return E_INVALIDARG;
	}
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::get__NewEnum( 
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComPtr<CComObject<CSEOMetaDictionaryEnum> > p;
	HRESULT hrRes = CComObject<CSEOMetaDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	p->AddRef(); // Do this for CComPtr counting
	hrRes = p->Init(this);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
	return hrRes;
}


HRESULT CSEOMetaDictionary::GetVariantW(LPCWSTR pszName, VARIANT __RPC_FAR *pvarResult, BOOL bCreate) {

	if(!pvarResult) return E_POINTER;
	CComVariant varResult;
	HRESULT hRes = E_FAIL;
	VariantInit(pvarResult);
	if(*pszName && (szSeparator[0] != pszName[wcslen(pszName) - 1])) {
		DWORD dwType = 0;
		DWORD dwCount = METADATA_MAX_NAME_LEN; // Initial buffer size
		PBYTE pbBuf = NULL;
		hRes = SEO_S_MOREDATA;
		while(SEO_S_MOREDATA == hRes) {
			pbBuf = (PBYTE) alloca(dwCount);
			hRes = m_mbHelper.GetData(pszName, dwType, dwCount, pbBuf);
		}
		if(SUCCEEDED(hRes)) {
			if(DWORD_METADATA == dwType) varResult = *((long *) pbBuf);
			else varResult = (LPCWSTR) pbBuf;
		}
	}

	if(varResult.vt == VT_EMPTY) { // nothing found so far, so read as subkey
		if (!bCreate) {
			WCHAR szName[METADATA_MAX_NAME_LEN];

			hRes = m_mbHelper.EnumKeys(pszName,0,szName);
			if (hRes == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
				return (SEO_E_NOTPRESENT);
			}
		}
		CComPtr<IUnknown> pRef;
		hRes = GetInterfaceW(pszName, IID_ISEODictionary, &pRef);
		varResult = pRef;
	}

	if(SUCCEEDED(hRes)) hRes = varResult.Detach(pvarResult);
	return hRes;
}


HRESULT CSEOMetaDictionary::GetVariantA(LPCSTR pszName, VARIANT __RPC_FAR *pvarResult, BOOL bCreate) {

	if(!pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetVariantW(A2W(pszName),pvarResult,bCreate);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetVariantW( 
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	return (GetVariantW(pszName,pvarResult,TRUE));
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetVariantA( 
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetVariantW(A2W(pszName),pvarResult,TRUE);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetVariantW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarValue) return E_POINTER;
	HRESULT hRes = S_OK;

	if(pvarValue->vt == VT_I4) {
		hRes = m_mbHelper.SetDWord(pszName, pvarValue->lVal);
	} else if((pvarValue->vt == VT_UNKNOWN) || (pvarValue->vt == VT_DISPATCH)) {
		CComQIPtr<ISEODictionary, &IID_ISEODictionary> piDict = pvarValue->punkVal;
		if(piDict) hRes = CopyDictionary(pszName, piDict);
	} else if(pvarValue->vt == VT_EMPTY) { // Delete it
		hRes = m_mbHelper.SetData(pszName, 0, 0, NULL);
	} else if(pvarValue->vt == VT_BSTR) { // It's a string
		hRes = m_mbHelper.SetString(pszName, pvarValue->bstrVal);
	} else { // Try to convert it to a string
		CComVariant pvarTemp = *pvarValue;
		hRes = pvarTemp.ChangeType(VT_BSTR);
		if(SUCCEEDED(hRes)) {
			hRes = m_mbHelper.SetString(pszName, pvarTemp.bstrVal);
		} // Else, return the ChangeType error
	}
	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetVariantA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarValue) return E_POINTER;
	USES_CONVERSION; // Needed for W2A(), etc.
	return SetVariantW(A2W(pszName), pvarValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetStringW( 
    /* [in] */ LPCWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPWSTR pszResult)
{
	if(!pszResult) return E_POINTER;

	DWORD dwType = 0;
	DWORD dwCountTmp = sizeof(*pszResult) * (*pchCount);
	HRESULT hRes = m_mbHelper.GetData(pszName, dwType, dwCountTmp, (PBYTE) pszResult);
	*pchCount = dwCountTmp / sizeof(*pszResult);
	if(SUCCEEDED(hRes) && (DWORD_METADATA == dwType)) hRes = SEO_E_NOTPRESENT;
	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetStringA( 
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPSTR pszResult)
{
	if(!pszResult) return E_POINTER;
	USES_CONVERSION;
	DWORD dwType = 0;
	DWORD dwByteCount = *pchCount * sizeof(*pszResult);
	PBYTE pbBuf = (PBYTE) alloca(dwByteCount);
	HRESULT hRes = m_mbHelper.GetData(A2W(pszName), dwType, dwByteCount, pbBuf);
	if(SUCCEEDED(hRes) && (DWORD_METADATA == dwType)) hRes = SEO_E_NOTPRESENT;

	// Now, convert back to ANSI chars
	if(SUCCEEDED(hRes) && (BINARY_METADATA == dwType)) {
		memcpy(pszResult, pbBuf, dwByteCount);
		*pchCount = dwByteCount / sizeof(*pszResult);
	} else {
		ATLW2AHELPER(pszResult, (LPCWSTR) pbBuf, sizeof(*pszResult) * min(*pchCount, dwByteCount));
		*pchCount = dwByteCount; // Same number of characters
	}

	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetStringW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCWSTR pszValue)
{
	if(!pszValue) return E_POINTER;
	return m_mbHelper.SetData(pszName, STRING_METADATA,
				  chCount*sizeof(*pszValue), (PBYTE) pszValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetStringA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCSTR pszValue)
{
	if(!pszValue) return E_POINTER;
	USES_CONVERSION;
	return m_mbHelper.SetData(A2W(pszName), STRING_METADATA,
				  chCount, (PBYTE) A2W(pszValue));
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetDWordW( 
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	if(!pdwResult) return E_POINTER;

	DWORD dwType = 0;
	DWORD dwCount = sizeof(DWORD);
	HRESULT hRes = m_mbHelper.GetData(pszName, dwType, dwCount, (PBYTE) pdwResult);
	if(SUCCEEDED(hRes) && (DWORD_METADATA != dwType)) hRes = SEO_E_NOTPRESENT;
	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetDWordA( 
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetDWordW(A2W(pszName), pdwResult);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetDWordW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwValue)
{
	return m_mbHelper.SetDWord(pszName, dwValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetDWordA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwValue)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return m_mbHelper.SetDWord(A2W(pszName), dwValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetInterfaceW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	if(!ppunkResult) return E_POINTER;
	CComObject<CSEOMetaDictionary> *pKey;
	HRESULT hrRes = CComObject<CSEOMetaDictionary>::CreateInstance(&pKey);
	if (FAILED(hrRes)) return (hrRes);
	CComPtr<ISEODictionary> pAutomaticCleanup = pKey;
	hrRes = pKey->Init(m_mbHelper, pszName);

	if (SUCCEEDED(hrRes)) {
		hrRes = pKey->QueryInterface(iidDesired, (LPVOID *) ppunkResult);
	}

	return (hrRes);
//      tbd: return SEO_E_NOTPRESENT; // Didn't find it
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetInterfaceA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetInterfaceW(A2W(pszName), iidDesired, ppunkResult);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetInterfaceW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	CComQIPtr<ISEODictionary, &IID_ISEODictionary> piDict = punkValue;
	return (piDict ? CopyDictionary(pszName, piDict) : E_INVALIDARG);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetInterfaceA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return SetInterfaceW(A2W(pszName), punkValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetClassID(/* [out] */ CLSID __RPC_FAR *pClassID) {
	memcpy(pClassID, &CLSID_CSEOMetaDictionary, sizeof(CLSID));
	_ASSERT(IsEqualCLSID(*pClassID, CLSID_CSEOMetaDictionary));
	return S_OK;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::InitNew(void) {
	return S_OK;
}
	

HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Load( 
			/* [in] */ IPropertyBag __RPC_FAR *pPropBag,
			/* [in] */ IErrorLog __RPC_FAR * /*pErrorLog*/) {
	if(!pPropBag) return E_POINTER;
	CComVariant varPath;

	varPath.vt = VT_BSTR; // Request type from Read()
	varPath.bstrVal = NULL;
	HRESULT hRes = pPropBag->Read(szSaveKey, &varPath, NULL);
	if(SUCCEEDED(hRes)) m_mbHelper.SetPath(varPath.bstrVal);

	return hRes;
}
	

HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Save( 
			/* [in] */ IPropertyBag __RPC_FAR *pPropBag,
			/* [in] */ BOOL /*fClearDirty*/,
			/* [in] */ BOOL /*fSaveAllProperties*/) {
	if(!pPropBag) return E_POINTER;
	LPWSTR pszBuf = (LPWSTR) alloca(sizeof(*pszBuf)*(m_mbHelper.GetPathLength() + 1)); // Temporary buffer to hold path
	CComVariant varPath = m_mbHelper.GetPath(pszBuf);
	return pPropBag->Write(szSaveKey, &varPath);
}


HRESULT CSEOMetaDictionary::FinalConstruct() {
	HRESULT hrRes;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOMetaDictionary::FinalRelease() {
	m_pUnkMarshaler.Release();
}


HRESULT CSEOMetaDictionary::OnChange(LPCWSTR *apszPath) {
	HRESULT hrRes;
	CComPtr<IConnectionPoint> pCP;
	CComPtr<IEnumConnections> pEnum;
	CONNECTDATA cd;
	BOOL bDoNotify = FALSE;
	CSEOConnectionPointImpl<CSEOMetaDictionary,&IID_IEventNotifyBindingChange> *pCPImpl;
	LPWSTR pszThisPath = NULL;
	DWORD dwThisPathLen;

	if (!apszPath) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!apszPath[0]) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	Lock();
	pCPImpl = (CSEOConnectionPointImpl<CSEOMetaDictionary,&IID_IEventNotifyBindingChange> *) this;
	if (!pCPImpl->GetCount()) {
		Unlock();
		return (S_OK);
	}
	Unlock();
	hrRes = FindConnectionPoint(IID_IEventNotifyBindingChange,&pCP);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	hrRes = pCP->EnumConnections(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	while (1) {
		hrRes = pEnum->Next(1,&cd,NULL);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (S_OK);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		if (!bDoNotify) {
			if (!pszThisPath) {
				pszThisPath = (LPWSTR) _alloca(sizeof(*pszThisPath)*(m_mbHelper.GetPathLength()+1));
				if (!pszThisPath) {
					_ASSERTE(FALSE);
					return (S_OK);
				}
				m_mbHelper.GetPath(pszThisPath);
				dwThisPathLen = wcslen(pszThisPath);
				if (dwThisPathLen && (pszThisPath[dwThisPathLen-1] == szSeparator[0])) {
					dwThisPathLen--;
				}
				if (dwThisPathLen && (pszThisPath[0] == szSeparator[0])) {
					pszThisPath++;
					dwThisPathLen--;
				}
			}
			for (DWORD dwIdx=0;apszPath[dwIdx];dwIdx++) {
				DWORD dwPathLen;
				LPCWSTR pszPath;

				pszPath = apszPath[dwIdx];
				dwPathLen = wcslen(pszPath);
				if (dwPathLen && (pszPath[dwPathLen-1] == szSeparator[0])) {
					dwPathLen--;
				}
				if (dwPathLen && (pszPath[0] == szSeparator[0])) {
					pszPath++;
					dwPathLen--;
				}
				if ((dwThisPathLen > dwPathLen) ||
					(memicmp(pszThisPath,pszPath,dwThisPathLen*sizeof(pszPath[0])) != 0)) {
					continue;
				}
				if (!dwThisPathLen ||
					(dwThisPathLen == dwPathLen) ||
					(pszPath[dwThisPathLen] == szSeparator[0])) {
					bDoNotify = TRUE;
					break;
				}
			}
		}
		if (bDoNotify) {
			hrRes = ((IEventNotifyBindingChange *) cd.pUnk)->OnChange();
			_ASSERTE(SUCCEEDED(hrRes));
		}
		cd.pUnk->Release();
		if (!bDoNotify) {
			break;
		}
	}
	return (S_OK);
}


void CSEOMetaDictionary::AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount) {
	HRESULT hrRes;

	if (dwCount == 1) {
		if (!g_pChangeNotify) {
			return;
		}
		hrRes = g_pChangeNotify->AddNotify(this);
		_ASSERTE(SUCCEEDED(hrRes));
	}
}


void CSEOMetaDictionary::UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount) {
	HRESULT hrRes;

	if (dwCount == 0) {
		if (!g_pChangeNotify) {
			return;
		}
		hrRes = g_pChangeNotify->RemoveNotify(this);
		_ASSERTE(SUCCEEDED(hrRes));
	}
}


HRESULT CSEOMetaDictionary::CopyDictionary(LPCWSTR pszName, ISEODictionary *pBag) {
	if(!pBag) return S_OK; // Nothing to copy

	// If not already open for writing, make it so
	CSEOMetabaseLock mbLocker(&m_mbHelper);
	if(::Write != m_mbHelper.Status()) {
		mbLocker.SetStatus(::Write);
	}
	CComObject<CSEOMetaDictionary> *pKey; // New Subkey
	HRESULT hrRes = CComObject<CSEOMetaDictionary>::CreateInstance(&pKey);
	if (FAILED(hrRes)) return (hrRes);
	CComPtr<ISEODictionary> pAutomaticCleanup = pKey;
	hrRes = m_mbHelper.DeleteKey(pszName); // Empty Metabase path
	if (FAILED(hrRes)) return (hrRes);
	hrRes = m_mbHelper.AddKey(pszName); // Create Metabase path
	if (FAILED(hrRes)) return (hrRes);
	hrRes = pKey->InitShare(m_mbHelper, pszName);
	if (FAILED(hrRes)) return (hrRes);

	CComPtr<IUnknown> piUnk;
	HRESULT hr = pBag->get__NewEnum(&piUnk);
	if(FAILED(hr) || !piUnk) return hr;
	CComQIPtr<IEnumVARIANT, &IID_IEnumVARIANT> pieEnum = piUnk;
	piUnk.Release(); // Done with piUnk - use pieEnum now
	if(!pieEnum) return E_INVALIDARG;

	CComVariant varName; // Hold the current property name

	// Read in and copy all of the properties
	while(S_OK == pieEnum->Next(1, &varName, NULL)) {
		CComVariant varDest; // Hold the current result
		if(SUCCEEDED(pBag->get_Item(&varName, &varDest))) {
			varName.ChangeType(VT_BSTR); // Try to get a string
			pKey->SetVariantW(varName.bstrVal, &varDest);
		}
	}

	return S_OK;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
	HRESULT hrRes;
	VARTYPE vtType;

	if (!pszPropName || !pVar) {
		return (E_POINTER);
	}
	vtType = pVar->vt;
//	VariantClear(pVar);
	hrRes = GetVariantW(pszPropName,pVar);
	if (SUCCEEDED(hrRes) && (vtType != VT_EMPTY)) {
		hrRes = VariantChangeType(pVar,pVar,0,vtType);
	}
	if (!SUCCEEDED(hrRes)) {
		VariantClear(pVar);
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Write(LPCOLESTR pszPropName, VARIANT *pVar) {

	return (SetVariantW(pszPropName,pVar));
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Item(VARIANT *pvarPropDesired, VARIANT *pvarPropValue) {
	if (!pvarPropValue) {
		return (E_POINTER);
	}
//	VariantClear(pvarPropValue); // Might have been initialized by caller (?)

	CComVariant varResult;
	HRESULT hrRes = ResolveVariant(this, pvarPropDesired, varResult);
	if (S_OK != hrRes) { // Don't just check for SUCCEEDED in case it's S_FALSE
		return (hrRes);
	}

	hrRes = GetVariantW(varResult.bstrVal,pvarPropValue,FALSE);
	if (hrRes == SEO_E_NOTPRESENT) {
		return (S_FALSE);
	}
#if 0
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	{
		CComVariant varTmp(*pvarPropValue);
		HRESULT hrRes;  // hide outer hrRes
		CComQIPtr<ISEODictionary,&IID_ISEODictionary> pdictTmp;
		CComPtr<IUnknown> punkEnum;
		CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;

		hrRes = varTmp.ChangeType(VT_UNKNOWN); // Make it an Unknown (if possible)
		if (SUCCEEDED(hrRes)) {
			pdictTmp = varTmp.punkVal;
			if (!pdictTmp) {
				VariantClear(pvarPropValue);
				return (E_NOINTERFACE);
			}
			hrRes = pdictTmp->get__NewEnum(&punkEnum); // Get it's Enum object
			if (!SUCCEEDED(hrRes)) {
				VariantClear(pvarPropValue);
				return (hrRes);
			}
			pEnum = punkEnum;
			if (!pEnum) {
				VariantClear(pvarPropValue);
				return (E_NOINTERFACE);
			}
			varTmp.Clear();
			hrRes = pEnum->Next(1,&varTmp,NULL); // Ask Enum for first object
			if (hrRes == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
				VariantClear(pvarPropValue);
				return (S_FALSE);
			}
			if (!SUCCEEDED(hrRes)) {
				VariantClear(pvarPropValue);
				return (hrRes);
			}
		}
	}
#endif
	if (SUCCEEDED(hrRes)) {
		VariantChangeType(pvarPropValue,pvarPropValue,0,VT_DISPATCH);
		_ASSERTE(pvarPropValue->vt!=VT_UNKNOWN);
	}
#if 0
	{
		HRESULT hrRes;
		CComVariant varTmp(*pvarPropValue);

		hrRes = varTmp.ChangeType(VT_UNKNOWN);
		if (SUCCEEDED(hrRes)) {
			hrRes = varTmp.ChangeType(VT_DISPATCH);
			_ASSERTE(SUCCEEDED(hrRes));
			if (SUCCEEDED(hrRes)) {
				VariantClear(pvarPropValue);
				pvarPropValue->vt = VT_DISPATCH;
				pvarPropValue->pdispVal = varTmp.pdispVal;
				pvarPropValue->pdispVal->AddRef();
			}
			hrRes = varTmp.ChangeType(VT_UNKNOWN);
			_ASSERTE(SUCCEEDED(hrRes));
		}

	}
#endif
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Name(long lPropIndex, BSTR *pbstrPropName) {
	if(!pbstrPropName) {
		return E_POINTER;
	}
	if (lPropIndex < 1) {
		return (S_FALSE);
	}
	*pbstrPropName = NULL;
	WCHAR szName[METADATA_MAX_NAME_LEN];

	HRESULT hrRes = m_mbHelper.EnumKeys(NULL, lPropIndex - 1, szName);

	if(SUCCEEDED(hrRes)) {
		*pbstrPropName = SysAllocString(szName);
		if(!*pbstrPropName) hrRes = E_OUTOFMEMORY;
	}

	if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hrRes) hrRes = S_FALSE;
	return hrRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Add(BSTR pszPropName, VARIANT *pvarPropValue) {

	return (SetVariantW(pszPropName,pvarPropValue));
}

HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Remove(VARIANT *pvarPropDesired) {
	CComVariant varCopy;
	HRESULT hrRes = ResolveVariant(this, pvarPropDesired, varCopy);
	if (S_OK != hrRes) { // Don't just check for SUCCEEDED in case it's S_FALSE
		return (hrRes);
	}

	hrRes = m_mbHelper.SetData(varCopy.bstrVal, 0, 0, NULL);
	if (hrRes == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
		return (S_FALSE);
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::get_Count(long *plCount) {
	if(!plCount) return E_POINTER;
	*plCount = 0; // Nothing done so far

	WCHAR szName[METADATA_MAX_NAME_LEN];
	HRESULT hrRes = S_OK; // So far, so good

	while(S_OK == hrRes) {
		// Must have succeeded to get here, so OK to overwrite hrRes
		hrRes = m_mbHelper.EnumKeys(NULL, *plCount, szName);

		if(SUCCEEDED(hrRes)) {
			++(*plCount); // Increment successful count for caller
		}
	}

	if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hrRes) hrRes = S_OK;
	return hrRes;
}


/*      Just use get__NewEnum from ISEODictionary
HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::get__NewEnum(IUnknown **ppUnkEnum) {

	return (E_NOTIMPL);
}       */


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::LockRead(int iTimeoutMS) {
	HRESULT hrRes;

	hrRes = m_mbHelper.SetStatus(::Read,iTimeoutMS);
	if (!SUCCEEDED(hrRes)) {
		if (hrRes == HRESULT_FROM_WIN32(ERROR_PATH_BUSY)) {
			return (EVENTS_E_TIMEOUT);
		}
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::UnlockRead() {
	HRESULT hrRes;

	hrRes = m_mbHelper.SetStatus(::Closed);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::LockWrite(int iTimeoutMS) {
	HRESULT hrRes;

	hrRes = m_mbHelper.SetStatus(::Write,iTimeoutMS);
	if (!SUCCEEDED(hrRes)) {
		if (hrRes == HRESULT_FROM_WIN32(ERROR_PATH_BUSY)) {
			return (EVENTS_E_TIMEOUT);
		}
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::UnlockWrite() {
	HRESULT hrRes;

	hrRes = m_mbHelper.SetStatus(::Closed);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\router.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	router.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Router class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/04/97	created

--*/


// router.cpp : Implementation of CSEORouter
#include "stdafx.h"

#define SEODLLDEF	// identifiers get exported through the .DEF file
#include "seodefs.h"
#include "fhash.h"
#include "router.h"


#define LOCK_TIMEOUT	INFINITE


static DWORD HashGuidToDword(const GUID& guid) {
	DWORD dwRes = 0;
	DWORD *pdwTmp = (DWORD *) &guid;
	DWORD dwRemain = sizeof(guid);

	while (dwRemain > sizeof(*pdwTmp)) {
		dwRes += *pdwTmp;
		*pdwTmp++;
		dwRemain -= sizeof(*pdwTmp);
	}
	return (dwRes);
}


static HRESULT VariantQI(VARIANT *pvar, REFIID iid, IUnknown **ppunkResult) {
	HRESULT hrRes;

	if (!pvar || !ppunkResult) {
		return (E_POINTER);
	}
	hrRes = VariantChangeType(pvar,pvar,0,VT_UNKNOWN);
	if (!SUCCEEDED(hrRes)) {
		VariantClear(pvar);
		return (hrRes);
	}
	hrRes = pvar->punkVal->QueryInterface(iid,(void **) ppunkResult);
	VariantClear(pvar);
	return (hrRes);
}


static HRESULT GetNextSubDict(ISEODictionary *pdictBase, IEnumVARIANT *pevEnum, VARIANT *pvarName, ISEODictionary **ppdictSub) {
	HRESULT hrRes;
	VARIANT varSub;

	if (!pdictBase || !pevEnum || !pvarName || !ppdictSub) {
		return (E_POINTER);
	}
	VariantInit(pvarName);
	*ppdictSub = NULL;
	hrRes = pevEnum->Next(1,pvarName,NULL);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (SEO_E_NOTPRESENT);
	}
	VariantInit(&varSub);
	hrRes = pdictBase->get_Item(pvarName,&varSub);
	if (!SUCCEEDED(hrRes) || (varSub.vt == VT_EMPTY)) {
		VariantClear(pvarName);
		return (hrRes);
	}
	hrRes = VariantQI(&varSub,IID_ISEODictionary,(IUnknown **) ppdictSub);
	VariantClear(&varSub);
	if (!SUCCEEDED(hrRes)) {
		VariantClear(pvarName);
	}
	return (hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// CBP
class CBP {
	public:
		CBP();
		CBP(CBP& bpFrom);
		~CBP();
		const CBP& operator =(const CBP& cbpFrom);
		CLSID& GetKey();
		int MatchKey(CLSID& clsid);
		HRESULT Init(REFCLSID clsidBP, ISEODictionary *pdictIn);
		CLSID m_clsidBP;
		CLSID m_clsidDispatcher;
		CComPtr<ISEODictionary> m_pdictBP;
		CComPtr<IUnknown> m_punkDispatcher;
};


inline const CBP& CBP::operator =(const CBP& cbpFrom) {

	m_clsidBP = cbpFrom.m_clsidBP;
	m_clsidDispatcher = cbpFrom.m_clsidDispatcher;
	m_pdictBP = cbpFrom.m_pdictBP;
	m_punkDispatcher = cbpFrom.m_punkDispatcher;
	return (*this);
}


/////////////////////////////////////////////////////////////////////////////
// CSEORouterInternal
class ATL_NO_VTABLE CSEORouterInternal :
	public CComObjectRoot,
//	public CComCoClass<CSEORouter, &CLSID_CSEORouter>,
	public ISEORouter
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_AGGREGATABLE(CSEORouterInternal);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"SEORouter Class",
//								   L"SEO.SEORouter.1",
//								   L"SEO.SEORouter");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEORouterInternal)
		COM_INTERFACE_ENTRY(ISEORouter)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IEventLock, m_pUnkLock.p)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEORouter
	public:
		HRESULT STDMETHODCALLTYPE get_Database(ISEODictionary **ppdictResult);
		HRESULT STDMETHODCALLTYPE put_Database(ISEODictionary *pdictDatabase);
		HRESULT STDMETHODCALLTYPE get_Server(ISEODictionary **ppdictResult);
		HRESULT STDMETHODCALLTYPE put_Server(ISEODictionary *pdictServer);
		HRESULT STDMETHODCALLTYPE get_Applications(ISEODictionary **ppdictResult);
		HRESULT STDMETHODCALLTYPE GetDispatcher(REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult);
		HRESULT STDMETHODCALLTYPE GetDispatcherByCLSID(REFCLSID clsidDispatcher, REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult);

	private:
		typedef TFHash<CBP,CLSID> CBPHash;
		CBPHash m_hashBP;
		CComPtr<ISEODictionary> m_pdictDatabase;
		CComPtr<ISEODictionary> m_pdictServer;
		CComPtr<ISEODictionary> m_pdictApplications;
		CComPtr<IUnknown> m_pUnkLock;
		CComPtr<IUnknown> m_pUnkMarshaler;
		IEventLock *m_pLock;
};


CBP::CBP() {

	m_clsidBP = GUID_NULL;
	m_clsidDispatcher = GUID_NULL;
}


CBP::CBP(CBP& cbpFrom) {

	m_clsidBP = cbpFrom.m_clsidBP;
	m_clsidDispatcher = cbpFrom.m_clsidDispatcher;
	m_pdictBP = cbpFrom.m_pdictBP;
	m_punkDispatcher = cbpFrom.m_punkDispatcher;
}


CBP::~CBP() {

	m_clsidBP = GUID_NULL;
	m_clsidDispatcher = GUID_NULL;
	m_pdictBP.Release();
	m_punkDispatcher.Release();
}


CLSID& CBP::GetKey() {

	return (m_clsidBP);
}


int CBP::MatchKey(CLSID& clsid) {

	return (memcmp(&m_clsidBP,&clsid,sizeof(clsid))==0);
}


HRESULT CBP::Init(REFCLSID clsidBP, ISEODictionary *pdictIn) {
	HRESULT hrRes;
	VARIANT varTmp;
	CComPtr<ISEODictionary> pdictTmp;

	if (!pdictIn) {
		return (E_POINTER);
	}
	m_clsidBP = clsidBP;
	VariantInit(&varTmp);
	hrRes = pdictIn->GetVariantA(BD_DISPATCHER,&varTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = VariantChangeType(&varTmp,&varTmp,0,VT_BSTR);
	}
	if (SUCCEEDED(hrRes)) {
		hrRes = CLSIDFromString(varTmp.bstrVal,&m_clsidDispatcher);
	}
	if (!SUCCEEDED(hrRes)) {
		m_clsidDispatcher = GUID_NULL;
	}
	VariantClear(&varTmp);
	hrRes = SEOCopyDictionary(pdictIn,&m_pdictBP);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT CSEORouterInternal::FinalConstruct() {
	TraceFunctEnter("CSEORouterInternal::FinalConstruct");
	HRESULT hrRes;

	if (!m_hashBP.Init(4,4,HashGuidToDword)) {
		return (E_OUTOFMEMORY);
	}
	hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_ISEODictionary,
							 (LPVOID *) &m_pdictApplications);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = CoCreateInstance(CLSID_CEventLock,
							 GetControllingUnknown(),
							 CLSCTX_ALL,
							 IID_IUnknown,
							 (LPVOID *) &m_pUnkLock);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = m_pUnkLock->QueryInterface(IID_IEventLock,(LPVOID *) &m_pLock);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	GetControllingUnknown()->Release();	// decrement reference count to prevent circular reference
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEORouterInternal::FinalRelease() {
	TraceFunctEnter("CSEORouterInternal::FinalRelease");

	GetControllingUnknown()->AddRef();
	m_pdictDatabase.Release();
	m_pdictServer.Release();
	m_pdictApplications.Release();
	m_pLock->Release();
	m_pUnkLock.Release();
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CSEORouterInternal::get_Database(ISEODictionary **ppdictResult) {
	HRESULT hrRes;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppdictResult = m_pdictDatabase;
	if (*ppdictResult) {
		(*ppdictResult)->AddRef();
	}
	m_pLock->UnlockRead();
	return (S_OK);
}


HRESULT CSEORouterInternal::put_Database(ISEODictionary *pdictDatabase) {
	HRESULT hrRes;

	hrRes = m_pLock->LockWrite(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_pdictDatabase = pdictDatabase;
	m_hashBP.Clear();
	if (!m_hashBP.Init(4,4,HashGuidToDword)) {
		return (E_OUTOFMEMORY);
	}
	if (m_pdictDatabase) {
		CComPtr<ISEODictionary> pdictBindingPoints;

		hrRes = m_pdictDatabase->GetInterfaceA(BD_BINDINGPOINTS,
											   IID_ISEODictionary,
											   (IUnknown **) &pdictBindingPoints);
		if (SUCCEEDED(hrRes)) {
			CComPtr<IUnknown> pUnkEnum;

			hrRes = pdictBindingPoints->get__NewEnum(&pUnkEnum);
			if (SUCCEEDED(hrRes)) {
				CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pevEnum(pUnkEnum);

				if (pevEnum) {
					while (1) {
						VARIANT varBP;
						CComPtr<ISEODictionary> pdictBP;
						CLSID clsidBP;
						CBP cbpBP;

						VariantInit(&varBP);
						pdictBP = NULL;
						hrRes = GetNextSubDict(pdictBindingPoints,pevEnum,&varBP,&pdictBP);
						if (!SUCCEEDED(hrRes)) {
							break;
						}
						if (hrRes == S_FALSE) {
							continue;
						}
						hrRes = CLSIDFromString(varBP.bstrVal,&clsidBP);
						VariantClear(&varBP);
						if (!SUCCEEDED(hrRes)) {
							continue;
						}
						hrRes = cbpBP.Init(clsidBP,pdictBP);
						if (!SUCCEEDED(hrRes)) {
							continue;
						}
						m_hashBP.Insert(cbpBP);
					}
				}
			}
		}
	}
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT CSEORouterInternal::get_Server(ISEODictionary **ppdictResult) {
	HRESULT hrRes;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppdictResult = m_pdictServer;
	if (*ppdictResult) {
		(*ppdictResult)->AddRef();
	}
	m_pLock->UnlockRead();
	return (S_OK);
}


HRESULT CSEORouterInternal::put_Server(ISEODictionary *pdictServer) {
	HRESULT hrRes;

	hrRes = m_pLock->LockWrite(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_pdictServer = pdictServer;
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT CSEORouterInternal::get_Applications(ISEODictionary **ppdictResult) {
	HRESULT hrRes;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppdictResult = m_pdictApplications;
	if (*ppdictResult) {
		(*ppdictResult)->AddRef();
	}
	m_pLock->UnlockRead();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEORouterInternal::GetDispatcher(REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult) {

	return (GetDispatcherByCLSID(iidEvent,iidEvent,iidDesired,ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CSEORouterInternal::GetDispatcherByCLSID(REFCLSID clsidDispatcher, REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult) {
	HRESULT hrRes;
	CBP *pcbpBP;
	CComPtr<IUnknown> punkDispatcher;

	if (!ppUnkResult) {
		return (E_POINTER);
	}
	*ppUnkResult = NULL;
	// First, get a read-lock across the entire set of binding points.
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	// Next, look for this particular binding point in the hash table.
	if (!(pcbpBP=m_hashBP.SearchKey((GUID&) iidEvent))) {
		// If it's not there - that's fine.  It means we don't have to dispatch to anyone.
		m_pLock->UnlockRead();
		return (S_FALSE);
	}
	// Next, look to see if we have already loaded the dispatcher for this binding point.
	if (!pcbpBP->m_punkDispatcher) {
		// Make copies of the data we'll need from the hash table entry.
		CLSID clsidTmpDispatcher = pcbpBP->m_clsidDispatcher;
		CComQIPtr<ISEODispatcher,&IID_ISEODispatcher> pdispDispatcher;
		CComQIPtr<ISEORouter,&IID_ISEORouter> prouterThis(GetControllingUnknown());
		CComPtr<ISEODictionary> pdictBP = pcbpBP->m_pdictBP;

		// If the CLSID for the dispatcher specified in the binding point is GUID_NULL, then use the
		// CLSID from the clsidDispatcher parameter.
		if (clsidTmpDispatcher == GUID_NULL) {
			clsidTmpDispatcher = clsidDispatcher;
		}
		// If we haven't already loaded the dispatcher, we need to release the read-lock, and create
		// the dispatcher object.
		m_pLock->UnlockRead();
		hrRes = CoCreateInstance(clsidTmpDispatcher,
								 NULL,
								 CLSCTX_ALL,
								 IID_IUnknown,
								 (LPVOID *) &punkDispatcher);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		// If the dispatcher supports ISEODispatcher, we want to initialize it through that interface.
		pdispDispatcher = punkDispatcher;
		if (pdispDispatcher) {
			hrRes = pdispDispatcher->SetContext(prouterThis,pdictBP);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		// Now get a write-lock across the entire set of binding points.
		hrRes = m_pLock->LockWrite(LOCK_TIMEOUT);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		// While we were creating the dispatcher, someone else may have updated the binding database
		// and removed this binding point entirely - so search for it again.
		if (!(pcbpBP=m_hashBP.SearchKey((GUID&) iidEvent))) {
			// The binding point went away while we were unlocked - which is not a problem, since it
			// means that someone changed the binding database during that window.  So just assume
			// everything is cool.
			m_pLock->UnlockWrite();
			return (S_FALSE);
		}
		// Also while we were creating the dispatcher, someone else may have been doing the exact same
		// thing - so check to make sure that there still isn't a dispatcher in the hash table.
		if (!pcbpBP->m_punkDispatcher) {
			// There isn't, so store the one we created there.
			pcbpBP->m_punkDispatcher = punkDispatcher;
		} else {
			// Make copy of the interface we need from the hash table entry.
			punkDispatcher = pcbpBP->m_punkDispatcher;
		}
		m_pLock->UnlockWrite();
	} else {
		// Make copies of the interface we need from the hash table entry.
		punkDispatcher = pcbpBP->m_punkDispatcher;
		m_pLock->UnlockRead();
	}
	// Get the interface which the client actually wants.
	hrRes = punkDispatcher->QueryInterface(iidDesired,(LPVOID *) ppUnkResult);
	return (hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// CSEORouter


HRESULT CSEORouter::FinalConstruct() {
	HRESULT hrRes;

	hrRes = CComObject<CSEORouterInternal>::_CreatorClass::CreateInstance(NULL,
																		  IID_ISEORouter,
																		  (LPVOID *) &m_pRouter);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_pLock = m_pRouter;
	m_pMarshal = m_pRouter;
	if (!m_pLock || !m_pMarshal) {
		return (E_NOINTERFACE);
	}
	return (S_OK);
}


void CSEORouter::FinalRelease() {

	if (m_pRouter) {
		m_pRouter->put_Database(NULL);
	}
	m_pRouter.Release();
	m_pLock.Release();
	m_pMarshal.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\regprop.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	regprop.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Registry Property Bag.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   11/26/96        created
	andyj   01/14/97        made usable for reading
	andyj   02/12/97        Converted PropertyBag's to Dictonary's

--*/


// REGPROP.cpp : Implementation of CSEORegDictionary
#include "stdafx.h"
#include "seodefs.h"
//#include "hack.h"
//#include "String"
#include "REGPROP.h"


// Registry Path Separator
#define PATH_SEP        "\\"


void Data2Variant(DWORD dwType, LPCSTR pData, CComVariant &varResult) {
	varResult.Clear();

	switch (dwType) { // Depending on the Registry type
		case REG_DWORD:
			varResult = *((long *) pData);
			break;

		case REG_DWORD_BIG_ENDIAN:
			varResult = MAKELONG(HIWORD(*((ULONG *) pData)),
					     LOWORD(*((ULONG *) pData)));
			break;

		case REG_EXPAND_SZ:
			{
				int iSize = ExpandEnvironmentStringsA(pData, NULL, 0);
				LPSTR szTemp = (LPSTR) _alloca(iSize);

				if(ExpandEnvironmentStringsA(pData, szTemp, iSize)) {
					varResult = szTemp;
				}
			}
			break;

		case REG_LINK:
		case REG_RESOURCE_LIST:
		case REG_MULTI_SZ:
		case REG_SZ:
		case REG_BINARY:
		case REG_NONE:
		default:
			varResult = pData;
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSEORegDictionaryEnum

class CSEORegDictionaryEnum :
	public CComObjectRoot,
//      public CComCoClass<CSEORegDictionaryEnum, &CLSID_CSEORegDictionary>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

		HRESULT STDMETHODCALLTYPE Next(DWORD, LPVARIANT, LPDWORD);
		HRESULT STDMETHODCALLTYPE Skip(DWORD);
		HRESULT STDMETHODCALLTYPE Reset(void);
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **);

		// Not Exported
		HRESULT STDMETHODCALLTYPE Init(CSEORegDictionary *);

	BEGIN_COM_MAP(CSEORegDictionaryEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
	END_COM_MAP()

	private: // Data members
		DWORD m_index;
		CSEORegDictionary *m_dictionary;
};

HRESULT CSEORegDictionaryEnum::FinalConstruct() {
	m_index = 0;
	m_dictionary = NULL;
	return S_OK;
}

void CSEORegDictionaryEnum::FinalRelease() {
	if(m_dictionary) m_dictionary->Release();
	m_dictionary = NULL;
}

STDMETHODIMP CSEORegDictionaryEnum::Init(CSEORegDictionary *pDict) {
	if(m_dictionary) m_dictionary->Release();
	m_dictionary = pDict;
	if(m_dictionary) m_dictionary->AddRef();
	return S_OK;
}

STDMETHODIMP CSEORegDictionaryEnum::Next(DWORD dwCount, LPVARIANT varDest,
					 LPDWORD pdwResult) {
	if(!m_dictionary) return E_FAIL; // Hasn't been properly initialized
	*pdwResult = 0; // Nothing done so far
	int iSize = max(m_dictionary->m_dwcMaxNameLen + 1,
			        m_dictionary->m_dwcMaxValueData);
	LPSTR pData = (LPSTR) _alloca(iSize); // Temp Buffer
	while(*pdwResult < dwCount) {
		DWORD retCode = ERROR_SUCCESS;  // Initialize
		CComVariant varResult;

		if(m_index < m_dictionary->m_dwValueCount) { // Still doing Values
			DWORD dwcNameSize = m_dictionary->m_dwcMaxNameLen + 1;
			DWORD dwcValueSize = m_dictionary->m_dwcMaxValueData;
			DWORD dwType = 0;
			LPSTR psName = (LPSTR) _alloca(dwcNameSize); // Temporary buffer for the name
			retCode = RegEnumValueA (m_dictionary->m_hkThisKey, m_index, psName, &dwcNameSize, NULL,
						 &dwType, (LPBYTE) pData, &dwcValueSize);
			if (retCode != ERROR_SUCCESS) return E_FAIL;
			// tbd: perhaps race condition that longer entry was added after RegQueryInfoKey call
			Data2Variant(dwType, pData, varResult);
		} else if(m_index < (m_dictionary->m_dwValueCount + m_dictionary->m_dwKeyCount)) { // Now do Keys
			CComPtr<CComObject<CSEORegDictionary> > pKey;
			retCode = RegEnumKeyA(m_dictionary->m_hkThisKey,
			          m_index - m_dictionary->m_dwValueCount, pData, iSize);
			if (retCode != ERROR_SUCCESS) return E_FAIL;
			CAndyString strTemp = m_dictionary->m_strSubKey;
			if(strTemp.length() > 0) strTemp += PATH_SEP; // Add separator if needed
			strTemp += pData;
			HRESULT hrRes = CComObject<CSEORegDictionary>::CreateInstance(&pKey);
			if(FAILED(hrRes)) return hrRes;
			if(!pKey) return E_FAIL;
			pKey->AddRef(); // Do this for CComPtr counting
			hrRes = pKey->Load(m_dictionary->m_strMachine.data(), (SEO_HKEY) (DWORD_PTR) m_dictionary->m_hkBaseKey, strTemp.data());
			if (FAILED(hrRes)) return hrRes;
			LPUNKNOWN punkResult = NULL;
			hrRes = pKey->QueryInterface(IID_ISEODictionary, (LPVOID *) &punkResult);
			if (FAILED(hrRes)) return hrRes;
			varResult = punkResult;
		} else {
			return S_OK; // No more data
		}

		varResult.Detach(&varDest[*pdwResult]);
		++m_index; // Point to the next one
		++(*pdwResult); // Increment successful count for caller
	}
	return S_OK;
}

STDMETHODIMP CSEORegDictionaryEnum::Skip(DWORD dwCount) {
	m_index += dwCount;
	return S_OK;
}

STDMETHODIMP CSEORegDictionaryEnum::Reset(void) {
	m_index = 0;
	return S_OK;
}

STDMETHODIMP CSEORegDictionaryEnum::Clone(IEnumVARIANT **ppunkResult) {
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComPtr<CComObject<CSEORegDictionaryEnum> > p;
	HRESULT hrRes = CComObject<CSEORegDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	p->AddRef(); // Do this for CComPtr counting
	hrRes = p->Init(m_dictionary);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
	return hrRes;
}


/////////////////////////////////////////////////////////////////////////////
// CSEORegDictionary


HRESULT STDMETHODCALLTYPE CSEORegDictionary::get_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return (pvarName->vt != VT_BSTR) ? E_INVALIDARG :
	       GetVariantA(W2A(pvarName->bstrVal), pvarResult);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::put_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::put_Item"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::get__NewEnum(
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComPtr<CComObject<CSEORegDictionaryEnum> > p;
	HRESULT hrRes = CComObject<CSEORegDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	p->AddRef(); // Do this for CComPtr counting
	hrRes = p->Init(this);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
	return hrRes;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	CComVariant varResult;
	DWORD dwType = 0;
	LPSTR pData = (LPSTR) _alloca(m_dwcMaxValueData);
	HRESULT hr = LoadItemA(pszName, dwType, (LPBYTE) pData);

	if(FAILED(hr)) { // Not a value, perhaps a key
		CComPtr<IUnknown> pRef;
		hr = GetInterfaceA(pszName, IID_ISEORegDictionary, &pRef);
		varResult = pRef;
		if(SUCCEEDED(hr)) hr = varResult.Detach(pvarResult);
		return hr;
	}

	Data2Variant(dwType, pData, varResult);
	if(SUCCEEDED(hr)) hr = varResult.Detach(pvarResult);
	return hr;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetVariantA(W2A(pszName), pvarResult);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetVariantA"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetVariantW"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetStringA(
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPSTR pszResult)
{
	DWORD dwType = 0;
	LPSTR pData = (LPSTR) _alloca(*pchCount);
	HRESULT hr = LoadItemA(pszName, dwType, (LPBYTE) pData, pchCount);
	if(FAILED(hr)) return hr;

	if(dwType == REG_EXPAND_SZ) { // It needs environment string substitutions
		DWORD dwSize = ExpandEnvironmentStringsA(pData, pszResult, *pchCount);
		if(!dwSize && *pData) hr = E_FAIL;
	} else {
		memcpy(pszResult, pData, *pchCount);
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPWSTR pszResult)
{
	USES_CONVERSION; // Needed for A2W(), etc.
	DWORD dwType = 0;
	DWORD dwBytes = *pchCount * sizeof(WCHAR);
	LPWSTR pData = (LPWSTR) _alloca(dwBytes);
	HRESULT hr = LoadItemW(pszName, dwType, (LPBYTE) pData, &dwBytes);
	if(FAILED(hr)) return hr;

	if(dwType == REG_EXPAND_SZ) { // It needs environment string substitutions
		*pchCount = ExpandEnvironmentStringsW(pData, pszResult, *pchCount);
	} else {
		memcpy(pszResult, pData, dwBytes);
		*pchCount = dwBytes / sizeof(WCHAR);
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetStringA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCSTR pszValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetStringA"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCWSTR pszValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetStringW"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	DWORD dwType = 0;
	LPBYTE pData = (LPBYTE) _alloca(m_dwcMaxValueData);
	HRESULT hr = LoadItemA(pszName, dwType, pData);
	if(FAILED(hr)) return hr;
	*pdwResult = *((DWORD *) pData);
	return hr;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetDWordA(W2A(pszName), pdwResult);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetDWordA"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetDWordW"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	CComPtr<CComObject<CSEORegDictionary> > pKey;
	HRESULT hrRes = CComObject<CSEORegDictionary>::CreateInstance(&pKey);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	pKey->AddRef(); // Do this for CComPtr counting

	CAndyString strTemp = m_strSubKey;
	if(strTemp.length() > 0) strTemp += PATH_SEP; // Add separator if needed
	strTemp += pszName;
	hrRes = pKey->Load(m_strMachine.data(), (SEO_HKEY) (DWORD_PTR) m_hkBaseKey, strTemp.data());

	if (SUCCEEDED(hrRes)) {
		hrRes = pKey->QueryInterface(iidDesired, (LPVOID *) ppunkResult);
	}

	return (hrRes);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetInterfaceA(W2A(pszName), iidDesired, ppunkResult);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetInterfaceA"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetInterfaceW"));
}

/*

STDMETHODIMP CSEORegPropertyBagEx::Write(LPCOLESTR pszPropName, VARIANT *pVar) {
	DWORD dwIdx;

	if (!pszPropName) {
		return (E_POINTER);
	}
	if (pVar && ((pVar->vt & VT_TYPEMASK) == VT_UNKNOWN)) {
		IUnknown *pTmp;
		ISEORegPropertyBagEx *pKey;
		HRESULT hrRes;
		BSTR strTmp;

		pTmp = (pVar->vt & VT_BYREF) ? (pVar->ppunkVal ? *pVar->ppunkVal : NULL) : pVar->punkVal;
		if (!pTmp) {
			return (E_INVALIDARG);
		}
		hrRes = pTmp->QueryInterface(IID_ISEORegPropertyBagEx,(LPVOID *) &pKey);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		strTmp = SysAllocStringLen(m_strSubKey,wcslen(m_strSubKey)+wcslen(pszPropName)+1);
		wcscat(strTmp, PATH_SEP);
		wcscat(strTmp,pszPropName);
		hrRes = pKey->Load(m_strMachine.data(),(SEO_HKEY) (DWORD) m_hkBaseKey,strTmp,NULL);
		SysFreeString(strTmp);
		pKey->Release();
		// tbd
		return (hrRes);
	} else {
		for (dwIdx=0;dwIdx<m_dwValueCnt;dwIdx++) {
			if (_wcsicmp(pszPropName,m_paValue[dwIdx].strName) == 0) {
				break;
			}
		}
		if ((dwIdx==m_dwValueCnt) && (!pVar || (pVar->vt==VT_EMPTY))) {
			return (S_OK);
		}
		if (dwIdx < m_dwValueCnt) {
			MySysFreeStringInPlace(&m_paValue[dwIdx].strData);
		} else if (!MyReallocInPlace(&m_paValue,sizeof(m_paValue[0])*(m_dwValueCnt+1))) {
			return (E_OUTOFMEMORY);
		} else {
			m_dwValueCnt++;
		}
		// tbd
	}
	return (S_OK);
}


STDMETHODIMP CSEORegPropertyBagEx::CreateSubKey(LPCOLESTR pszPropName, ISEOPropertyBagEx **ppSubKey) {
	CComObject<CSEORegPropertyBagEx> *pKey;
	VARIANT varTmp;
	HRESULT hrRes;

	hrRes = CComObject<CSEORegPropertyBagEx>::CreateInstance(&pKey);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	VariantInit(&varTmp);
	varTmp.vt = VT_UNKNOWN | VT_BYREF;
	hrRes = pKey->QueryInterface(IID_IUnknown,(LPVOID *) varTmp.ppunkVal);
	if (!SUCCEEDED(hrRes)) {
		pKey->Release();
		return (hrRes);
	}
	hrRes = pKey->QueryInterface(IID_ISEOPropertyBagEx,(LPVOID *) ppSubKey);
	if (!SUCCEEDED(hrRes)) {
		pKey->Release();
		return (hrRes);
	}
	hrRes = Write(pszPropName,&varTmp);
	if (!SUCCEEDED(hrRes)) {
		pKey->Release();
		return (hrRes);
	}
	return (hrRes);
}

// The following is based on the MONKEY sample app in MSDN
STDMETHODIMP CSEORegDictionary::ReLoad() {
	USES_CONVERSION; // Needed for A2W(), etc.
	HKEY     hKey;
	DWORD retCode = ERROR_SUCCESS; // Initialize

	DWORD dwcMaxValueName = 0;      // Longest Value name.
	DWORD dwcMaxValueData = 0;      // Longest Value data size.
	retCode = RegQueryInfoKey(hKey, NULL, NULL, NULL, &m_dwKeyCnt, NULL, NULL,
				  &m_dwValueCnt, &dwcMaxValueName, &dwcMaxValueData, 0, 0);
	if (retCode != ERROR_SUCCESS) return E_FAIL; // Unable to get data for key

	// Allocate memory
	if(m_dwKeyCnt) {
		m_paKey   = (KeyEntry *)   MyMalloc(sizeof(KeyEntry)   * m_dwKeyCnt);
		if (!m_paKey) return E_FAIL; // Unable to allocate memory
	}
	if(m_dwValueCnt) {
		m_paValue = (ValueEntry *) MyMalloc(sizeof(ValueEntry) * m_dwValueCnt);
		if (!m_paValue) return E_FAIL; // Unable to allocate memory
	}

	retCode = ERROR_SUCCESS; // Initialize for the loop
	for (DWORD i = 0; (i < m_dwKeyCnt) && (retCode == ERROR_SUCCESS); i++) {
		m_paKey[i].pKey = NULL; // No object for it, yet
		m_paKey[i].strName = SysAllocStringLen(NULL, MAX_PATH + 1);
		if (!m_paKey[i].strName) return E_FAIL;

		retCode = RegEnumKeyW(hKey, i, m_paKey[i].strName, MAX_PATH + 1);
		if (retCode != ERROR_SUCCESS) return E_FAIL;
	}

	retCode = ERROR_SUCCESS; // Initialize for the loop
	for (i = 0; (i < m_dwValueCnt) && (retCode == ERROR_SUCCESS); i++) {
		m_paValue[i].bDirty = FALSE; // Not dirty
		m_paValue[i].strName = SysAllocStringLen(NULL, dwcMaxValueName);
		m_paValue[i].strData = SysAllocStringLen(NULL, dwcMaxValueData);
		if (!m_paValue[i].strName || !m_paValue[i].strData) return E_FAIL;

		DWORD dwcNameLen = dwcMaxValueName + 1;
		DWORD dwcValueSize = dwcMaxValueData;
		retCode = RegEnumValueW (hKey, i, m_paValue[i].strName, &dwcNameLen,
					 NULL, &m_paValue[i].dwType, (LPBYTE) m_paValue[i].strData,
					 &dwcValueSize);
		if (retCode != ERROR_SUCCESS) return E_FAIL;
		// tbd: perhaps race condition that longer entry was added after RegQueryInfoKey call
	}

	RegCloseKey (hKey);   // Close the key handle.
	return S_OK;
}

STDMETHODIMP CSEORegDictionary::FreeBase() {
	m_hkBaseKey = NULL;
	return (S_OK);
}


STDMETHODIMP CSEORegDictionary::FreeData() {
	DWORD dwIdx;

	for (dwIdx=0;dwIdx<m_dwValueCnt;dwIdx++) {
		MySysFreeStringInPlace(&m_paValue[dwIdx].strName);
		MySysFreeStringInPlace(&m_paValue[dwIdx].strData);
	}
	m_dwValueCnt = 0;
	MyFreeInPlace(&m_paValue);
	for (dwIdx=0;dwIdx<m_dwKeyCnt;dwIdx++) {
		MySysFreeStringInPlace(&m_paKey[dwIdx].strName);
		if (m_paKey[dwIdx].pKey) {
			RELEASE_AND_SHREAD_POINTER(m_paKey[dwIdx].pKey);
		}
	}
	MyFreeInPlace(&m_paKey);
	return (S_OK);
}

DATA (Member variables):
		DWORD m_dwValueCnt;
		struct ValueEntry {
			BSTR strName;
			DWORD dwType;
			BSTR strData;
			BOOL bDirty;
		} *m_paValue;
		DWORD m_dwKeyCnt;
		struct KeyEntry {
			BSTR strName;
			CComObject<CSEORegDictionary> *pKey;
		} *m_paKey;
*/

STDMETHODIMP CSEORegDictionary::Load(LPCOLESTR pszMachine,
									 SEO_HKEY skBaseKey,
									 LPCOLESTR pszSubKey,
									 IErrorLog *) {
	USES_CONVERSION; // Needed for OLE2A(), etc.
	return Load(OLE2A(pszMachine), skBaseKey, OLE2A(pszSubKey));
}

STDMETHODIMP CSEORegDictionary::Load(LPCSTR pszMachine,
				     SEO_HKEY skBaseKey,
				     LPCSTR pszSubKey) {
	HRESULT hrRes;

	if (!skBaseKey) return (E_INVALIDARG);

	if (!m_strMachine.empty() || m_hkBaseKey || !m_strSubKey.empty()) {
		CloseKey();
	}

	m_strMachine = pszMachine;
	m_strSubKey = pszSubKey;
	DWORD dwLastPos = m_strSubKey.length() - 1;
	if(m_strSubKey[dwLastPos] == *PATH_SEP) m_strSubKey.erase(dwLastPos, 1);
	m_hkBaseKey = (HKEY) skBaseKey;
	if (!m_strMachine.data() || !m_strSubKey.data()) return (E_OUTOFMEMORY);
	hrRes = OpenKey();
	return (hrRes);
}

HRESULT CSEORegDictionary::FinalConstruct() {
	HRESULT hrRes;

	m_hkBaseKey = NULL;
	m_hkThisKey = NULL;
	m_dwValueCount = 0;
	m_dwKeyCount = 0;
	m_dwcMaxValueData = 0; // Longest Value data size
	m_dwcMaxNameLen = 0; // Longest Key name size
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}

void CSEORegDictionary::FinalRelease() {
	CloseKey();
	m_pUnkMarshaler.Release();
}

STDMETHODIMP CSEORegDictionary::OpenKey() {
	// tbd: Verify that the A version of RegOpenKeyEx is compatible with the
	//      W version of RegQueryValueEx, etc.
	DWORD retCode = RegOpenKeyExA (m_hkBaseKey, m_strSubKey.data(),
				       0, KEY_READ, &m_hkThisKey);

	if (retCode != ERROR_SUCCESS) {
		m_hkThisKey = NULL; // Ensure this wasn't set
		return E_FAIL; // Unable to open key
	}

	DWORD dwKeyNameLen = 0;
	DWORD dwValueNameLen = 0;
	retCode = RegQueryInfoKey(m_hkThisKey, NULL, NULL, NULL, &m_dwKeyCount,
				  &dwKeyNameLen, NULL, &m_dwValueCount,
				  &dwValueNameLen, &m_dwcMaxValueData, NULL, NULL);
	if (retCode != ERROR_SUCCESS) return E_FAIL; // Unable to get data for key
	m_dwcMaxNameLen = max(dwKeyNameLen, dwValueNameLen);
	return S_OK;
}

STDMETHODIMP CSEORegDictionary::CloseKey() {
	if(m_hkThisKey) RegCloseKey (m_hkThisKey); // Close the key handle.
	return S_OK;
}

STDMETHODIMP CSEORegDictionary::LoadItemA(LPCSTR lpValueName,
					  DWORD  &dType,
					  LPBYTE lpData,
					  LPDWORD lpcbDataParam) {
	if (!m_hkThisKey) return E_FAIL; // Wasn't opened
	DWORD dwDummy = m_dwcMaxValueData;
	if(!lpcbDataParam) lpcbDataParam = &dwDummy;
	DWORD retCode = RegQueryValueExA(m_hkThisKey, lpValueName, NULL, &dType,
					 lpData, lpcbDataParam);
	if (retCode != ERROR_SUCCESS) return E_FAIL; // Error reading data
	return S_OK;
}

STDMETHODIMP CSEORegDictionary::LoadItemW(LPCWSTR lpValueName,
					  DWORD  &dType,
					  LPBYTE lpData,
					  LPDWORD lpcbDataParam) {
	if (!m_hkThisKey) return E_FAIL; // Wasn't opened
	DWORD dwDummy = m_dwcMaxValueData;
	if(!lpcbDataParam) lpcbDataParam = &dwDummy;
	DWORD retCode = RegQueryValueExW(m_hkThisKey, lpValueName, NULL, &dType,
					 lpData, lpcbDataParam);
	if (retCode != ERROR_SUCCESS) return E_FAIL; // Error reading data
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\seolock.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolock.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object CEventLock class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/06/97	created
	dondu	04/07/97	changed to IEventLock and CEventLock

--*/


// seolock.cpp : Implementation of CEventLock
#include "stdafx.h"
#include "seodefs.h"
#include "rwnew.h"
#include "seolock.h"


HRESULT CEventLock::FinalConstruct() {
	HRESULT hrRes;
	TraceFunctEnter("CEventLock::FinalConstruct");

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventLock::FinalRelease() {
	TraceFunctEnter("CEventLock::FinalRelease");

	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CEventLock::LockRead(int iTimeoutMS) {

	m_lock.ShareLock();
	// tbd - implement timeouts
	return (S_OK);
}


HRESULT CEventLock::UnlockRead() {

	m_lock.ShareUnlock();
	return (S_OK);
}


HRESULT CEventLock::LockWrite(int iTimeoutMS) {

	m_lock.ExclusiveLock();
	return (S_OK);
}


HRESULT CEventLock::UnlockWrite() {

	m_lock.ExclusiveUnlock();
	// tbd - implement timeouts
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\regprop.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	regprop.h

Abstract:

	This module contains the definition for the Server
	Extension Object Registry Property Bag.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	11/26/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


// REGPROP.h : Declaration of the CSEORegDictionary

class CAndyString { // Temporary until we get std::string to work
	public:
		CAndyString() {m_string[0] = 0;}
		CAndyString(CAndyString &as) {strcpy(m_string, as.m_string);};

		LPCSTR data() {return m_string;};
		BOOL empty() {return (length() < 1);};
		int length() {return strlen(m_string);};
		void erase(int pos, int len = 1) {m_string[pos] = 0;};

		CAndyString &operator=(LPCSTR s) {strcpy(m_string, s); return *this;};
		CAndyString &operator+=(LPCSTR s) {strcat(m_string, s); return *this;};
		char operator[](int i) {return m_string[i];};

	private:
		char m_string[MAX_PATH + 1];
};

/////////////////////////////////////////////////////////////////////////////
// CSEORegDictionary
class ATL_NO_VTABLE CSEORegDictionary : 
	public CComObjectRoot,
	public CComCoClass<CSEORegDictionary, &CLSID_CSEORegDictionary>,
	public IDispatchImpl<ISEORegDictionary, &IID_ISEORegDictionary, &LIBID_SEOLib>
{
	friend class CSEORegDictionaryEnum; // Helper class

	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEORegDictionary Class",
								   L"SEO.SEORegDictionary.1",
								   L"SEO.SEORegDictionary");

	BEGIN_COM_MAP(CSEORegDictionary)
		COM_INTERFACE_ENTRY(ISEORegDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
//		COM_INTERFACE_ENTRY(IDispatch)
//		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEORegDictionary
	public:
        virtual /* [id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT __RPC_FAR *pvarName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT __RPC_FAR *pvarName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [hidden][id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantA( 
            /* [in] */ LPCSTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantW( 
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringA( 
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pchCount,
            /* [retval][size_is][out] */ LPSTR pszResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringW( 
            /* [in] */ LPCWSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pchCount,
            /* [retval][size_is][out] */ LPWSTR pszResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD chCount,
            /* [size_is][in] */ LPCSTR pszValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD chCount,
            /* [size_is][in] */ LPCWSTR pszValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordA( 
            /* [in] */ LPCSTR pszName,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordW( 
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD dwValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ REFIID iidDesired,
            /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ REFIID iidDesired,
            /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ IUnknown __RPC_FAR *punkValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ IUnknown __RPC_FAR *punkValue);

		HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pszMachine, SEO_HKEY skBaseKey, LPCOLESTR pszSubKey, IErrorLog *pErrorLog);
		HRESULT STDMETHODCALLTYPE Load(LPCSTR pszMachine, SEO_HKEY skBaseKey, LPCSTR pszSubKey);

		DECLARE_GET_CONTROLLING_UNKNOWN();

	private: // Methods
		STDMETHODIMP OpenKey();
		STDMETHODIMP CloseKey();
		STDMETHODIMP LoadItemA(LPCSTR lpValueName,
                              DWORD  &lpType,
                              LPBYTE lpData,
                              LPDWORD lpcbDataParam = NULL);
		STDMETHODIMP LoadItemW(LPCWSTR lpValueName,
                              DWORD  &lpType,
                              LPBYTE lpData,
                              LPDWORD lpcbDataParam = NULL);

	private: // Data
		CAndyString m_strMachine; //std::string m_strMachine;
		CAndyString m_strSubKey; //std::string m_strSubKey;
		HKEY m_hkBaseKey;
		HKEY m_hkThisKey;
		DWORD m_dwValueCount;
		DWORD m_dwKeyCount;
		DWORD m_dwcMaxValueData; // Longest Value data size.
		DWORD m_dwcMaxNameLen; // Longest Name length
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\router.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	router.h

Abstract:

	This module contains the definition for the Server
	Extension Object Router class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/04/97	created

--*/


// router.h : Declaration of the CSEORouter

/////////////////////////////////////////////////////////////////////////////
// CSEORouter
class ATL_NO_VTABLE CSEORouter : 
	public CComObjectRoot,
	public CComCoClass<CSEORouter, &CLSID_CSEORouter>,
	public ISEORouter,
	public IDispatchImpl<IEventLock, &IID_IEventLock, &LIBID_SEOLib>,
	public IMarshal
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEORouter Class",
								   L"SEO.SEORouter.1",
								   L"SEO.SEORouter");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEORouter)
		COM_INTERFACE_ENTRY(ISEORouter)
		COM_INTERFACE_ENTRY(IEventLock)
		COM_INTERFACE_ENTRY(IMarshal)
	END_COM_MAP()

	// ISEORouter
	public:
		HRESULT STDMETHODCALLTYPE get_Database(ISEODictionary **ppdictResult) {
			return (m_pRouter->get_Database(ppdictResult)); };
		HRESULT STDMETHODCALLTYPE put_Database(ISEODictionary *pdictDatabase) {
			return (m_pRouter->put_Database(pdictDatabase)); }
		HRESULT STDMETHODCALLTYPE get_Server(ISEODictionary **ppdictResult) {
			return (m_pRouter->get_Server(ppdictResult)); };
		HRESULT STDMETHODCALLTYPE put_Server(ISEODictionary *pdictServer) {
			return (m_pRouter->put_Server(pdictServer)); };
		HRESULT STDMETHODCALLTYPE get_Applications(ISEODictionary **ppdictResult) {
			return (m_pRouter->get_Applications(ppdictResult)); };
		HRESULT STDMETHODCALLTYPE GetDispatcher(REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult) {
			return (m_pRouter->GetDispatcher(iidEvent,iidDesired,ppUnkResult)); };
		HRESULT STDMETHODCALLTYPE GetDispatcherByCLSID(REFCLSID clsidDispatcher, REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult) {
			return (m_pRouter->GetDispatcherByCLSID(clsidDispatcher,iidEvent,iidDesired,ppUnkResult)); };

	// IEventLock
	public:
		HRESULT STDMETHODCALLTYPE LockRead(int iTimeoutMS) {
			return (m_pLock->LockRead(iTimeoutMS)); };
		HRESULT STDMETHODCALLTYPE UnlockRead() {
			return (m_pLock->UnlockRead()); };
		HRESULT STDMETHODCALLTYPE LockWrite(int iTimeoutMS) {
			return (m_pLock->LockWrite(iTimeoutMS)); };
		HRESULT STDMETHODCALLTYPE UnlockWrite() {
			return (m_pLock->UnlockWrite()); };

	// IMarshal
	public:
		HRESULT STDMETHODCALLTYPE GetUnmarshalClass(REFIID iid,
												    void *pv,
												    DWORD dwDestContext,
												    void *pvDestContext,
												    DWORD mshlflags,
												    CLSID *pCid) {
			return (m_pMarshal->GetUnmarshalClass(iid,pv,dwDestContext,pvDestContext,mshlflags,pCid)); };
		HRESULT STDMETHODCALLTYPE GetMarshalSizeMax(REFIID riid,
													void *pv,
													DWORD dwDestContext,
													void *pvDestContext,
													DWORD mshlflags,
													ULONG *pSize) {
			return (m_pMarshal->GetMarshalSizeMax(riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)); };
		HRESULT STDMETHODCALLTYPE MarshalInterface(IStream *pStm,
												   REFIID riid,
												   void *pv,
												   DWORD dwDestContext,
												   void *pvDestContext,
												   DWORD mshlflags) {
			return (m_pMarshal->MarshalInterface(pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)); };
		HRESULT STDMETHODCALLTYPE UnmarshalInterface(IStream *pStm,REFIID riid,void **ppv) {
			return (m_pMarshal->UnmarshalInterface(pStm,riid,ppv)); };
		HRESULT STDMETHODCALLTYPE ReleaseMarshalData(IStream *pStm) {
			return (m_pMarshal->ReleaseMarshalData(pStm)); };
		HRESULT STDMETHODCALLTYPE DisconnectObject(DWORD dwReserved) {
			return (m_pMarshal->DisconnectObject(dwReserved)); };

	private:
		CComPtr<ISEORouter> m_pRouter;
		CComQIPtr<IEventLock,&IID_IEventLock> m_pLock;
		CComQIPtr<IMarshal,&IID_IMarshal> m_pMarshal;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\seolock.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolock.h

Abstract:

	This module contains the definition for the Server
	Extension Object CEventLock class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/06/97	created
	dondu	04/07/97	changed to IEventLock and CEventLock

--*/


// seolock.h : Declaration of the CEventLock

/////////////////////////////////////////////////////////////////////////////
// CSEORouter
class ATL_NO_VTABLE CEventLock : 
	public CComObjectRoot,
	public CComCoClass<CEventLock, &CLSID_CEventLock>,
	public IDispatchImpl<IEventLock, &IID_IEventLock, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventLock Class",
								   L"Event.Lock.1",
								   L"Event.Lock");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventLock)
		COM_INTERFACE_ENTRY(IEventLock)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventLock
	public:
		HRESULT STDMETHODCALLTYPE LockRead(int iTimeoutMS);
		HRESULT STDMETHODCALLTYPE UnlockRead();
		HRESULT STDMETHODCALLTYPE LockWrite(int iTimeoutMS);
		HRESULT STDMETHODCALLTYPE UnlockWrite();

	private:
		CShareLockNH m_lock;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\seodefs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    seodefs.h

Abstract:

    This module contains the definitions for all of the internal
    pieces of SEO.DLL.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	10/24/96	created

--*/


#ifndef _SEODEFS_INC
#define _SEODEFS_INC


#include <limits.h>
#include "resource.h"
#include "seo.h"
#if 1
#include "dbgtrace.h"
#else
	#define TraceFunctEnter(x)
	inline void _DummyFunctTrace(int a, ...) {}
	#define FunctTrace			_DummyFunctTrace
	inline void _DummyTraceFunctLeave() {}
	#define TraceFunctLeave		_DummyTraceFunctLeave
#endif


#ifdef DEBUG
	class CDebugModule {
		public:
			void Init() {
				InitializeCriticalSection(&m_csLock);
				m_dwData = 0;
				m_pData = NULL;
			};
			void Term() {
				if (m_pData) {
					for (DWORD dwIdx=0;dwIdx<m_dwData;dwIdx++) {
						_ASSERTE(!m_pData[dwIdx].pszObject);
					}
					delete[] m_pData;
					m_pData = NULL;
					m_dwData = 0;
				}
				DeleteCriticalSection(&m_csLock);
			};
			void AddObject(LPVOID pvObject, LPCSTR pszObject) {
				EnterCriticalSection(&m_csLock);
				for (DWORD dwIdx=0;dwIdx<m_dwData;dwIdx++) {
					if (!m_pData[dwIdx].pvObject) {
						m_pData[dwIdx].pvObject = pvObject;
						m_pData[dwIdx].pszObject = pszObject;
						LeaveCriticalSection(&m_csLock);
						return;
					}
				}
				Data *pData = new Data[m_dwData+8];
				if (!pData) {
					LeaveCriticalSection(&m_csLock);
					return;
				}
				memcpy(pData,m_pData,sizeof(*pData)*m_dwData);
				memset(&pData[m_dwData],0,sizeof(*pData)*8);
				delete[] m_pData;
				m_pData = pData;
				pData[m_dwData].pvObject = pvObject;
				pData[m_dwData].pszObject = pszObject;
				m_dwData += 8;
				LeaveCriticalSection(&m_csLock);
			};
			void RemoveObject(LPVOID pvObject) {
				EnterCriticalSection(&m_csLock);
				for (DWORD dwIdx=0;dwIdx<m_dwData;dwIdx++) {
					if (m_pData[dwIdx].pvObject == pvObject) {
						m_pData[dwIdx].pvObject = NULL;
						m_pData[dwIdx].pszObject = NULL;
						break;
					}
				}
				LeaveCriticalSection(&m_csLock);
				_ASSERTE(dwIdx!=m_dwData);
			}
		private:
			typedef struct tagData {
				LPVOID pvObject;
				LPCSTR pszObject;
			} Data;
			CRITICAL_SECTION m_csLock;
			DWORD m_dwData;
			Data *m_pData;
	};
	#ifndef MODULE_DEBUG
		#define	MODULE_DEBUG		_ModuleDebug
	#endif
	#define DEFINE_DEBUG_MODULE		extern CDebugModule MODULE_DEBUG;
	#define ALLOC_DEBUG_MODULE		CDebugModule MODULE_DEBUG;
	#define INIT_DEBUG_MODULE		MODULE_DEBUG.Init();
	#define TERM_DEBUG_MODULE		MODULE_DEBUG.Term();
	#define ADD_DEBUG_OBJECT(x)		MODULE_DEBUG.AddObject(this,x);
	#define REMOVE_DEBUG_OBJECT		MODULE_DEBUG.RemoveObject(this);
#else
	#define DEFINE_DEBUG_MODULE
	#define ALLOC_DEBUG_MODULE
	#define INIT_DEBUG_MODULE
	#define TERM_DEBUG_MODULE
	#define ADD_DEBUG_OBJECT(x)
	#define REMOVE_DEBUG_OBJECT
#endif


#ifdef DEBUG
	template<class T>
	class CDebugObject {
		public:
			CDebugObject() { m_pszName = T::DebugObjectGetInitName(); };
			~CDebugObject() { m_pszName = T::DebugObjectGetTermName(); };
			BOOL Check() { return (((m_pszName==T::DebugObjectGetInitName())||(strcmp(m_pszName,T::DebugObjectGetInitName())==0))?TRUE:FALSE); };
		private:
			LPCSTR m_pszName;
	};
	#define DEBUG_OBJECT_DEF2(_class,_string,_suffix)	\
		public:	\
			static inline LPCSTR DebugObjectGetInitName() { return (_string); };	\
			static inline LPCSTR DebugObjectGetTermName() { return (_string " *** DELETED ***" ); };	\
			CDebugObject<_class> m_DebugObject##_suffix;	\
			inline BOOL DebugObjectCheck() { return (m_DebugObject##_suffix.Check()); };
	#define DEBUG_OBJECT_DEF(x)	DEBUG_OBJECT_DEF2(x,#x,x)
	#define DEBUG_OBJECT_CHECK 	_ASSERTE(DebugObjectCheck());
#else
	#define DEBUG_OBJECT_DEF2(_class,_string,_suffix)
	#define DEBUG_OBJECT_DEF(x)
	#define DEBUG_OBJECT_CHECK
#endif


DEFINE_DEBUG_MODULE


void MyMallocTerm();
BOOL MyMallocInit();
LPVOID MyMalloc(size_t cbBytes);
LPVOID MyRealloc(LPVOID pvBlock, size_t cbBytes);
BOOL MyReallocInPlace(LPVOID pvPtrToPtrToBlock, size_t cbBytes);
void MyFree(LPVOID pvBlock);
void MyFreeInPlace(LPVOID pvPtrToPtrToBlock);
void MySysFreeStringInPlace(BSTR *pstrBlock);


// SHREAD_POINTER destroys a pointer so it can't be used again.
// Not really necissary, so only included in DEBUG builds
#ifdef DEBUG
	#define SHREAD_POINTER(ptr) ptr = 0
#else // DEBUG
	#define SHREAD_POINTER(ptr)
#endif // DEBUG

#define RELEASE_AND_SHREAD_POINTER(ptr) if(ptr) ptr->Release(); SHREAD_POINTER(ptr)

// Compare two BSTR's.  Return true if they're equal
inline BOOL EqualBSTR(BSTR a, BSTR b) {
	return (CompareStringW(LOCALE_SYSTEM_DEFAULT, 0, a, -1, b, -1) == 2);
}

// Coerce a Variant into the desired type in-place
void VariantCoerce(VARIANTARG &var, VARTYPE varType);

// Turn the IUnknown parameter into an ISEODictionary
ISEODictionary *GetDictionary(IUnknown *piUnk);

// Read a subkey from an ISEODictionary and return it as another ISEODictionary
ISEODictionary *ReadSubBag(ISEODictionary *bag, LPCSTR str);

// Read a string from the Dictionary.
HRESULT ReadString(ISEODictionary *bag, LPCOLESTR property,
                   LPSTR psBuf, LPDWORD dwCount);

// Given a CLSID as a string, create an object of that CLSID
void *CreateFromString(LPCOLESTR str, REFIID iface);


template<class T, const IID *piid, class CDV = CComDynamicUnkArray>
class ATL_NO_VTABLE CSEOConnectionPointImpl : public IConnectionPointImpl<T,piid,CDV> {
	public:
		CSEOConnectionPointImpl() {
			m_dwCount = 0; };
		virtual void AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount) {
			/* nothing */ };
		virtual void UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount) {
			/* nothing */ };
		DWORD GetCount() {
			return (m_dwCount); };
	public:
		HRESULT STDMETHODCALLTYPE Advise(IUnknown *pUnk, DWORD *pdwCookie) {
			HRESULT hrRes;
			T *pT = (T *) this;

			pT->Lock();
			hrRes = IConnectionPointImpl<T,piid,CDV>::Advise(pUnk,pdwCookie);
			if (SUCCEEDED(hrRes)) {
				m_dwCount++;
				AdviseCalled(pUnk,pdwCookie,*piid,m_dwCount);
			}
			pT->Unlock();
			return (hrRes);
		}
		HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwCookie) {
			HRESULT hrRes;
			T *pT = (T *) this;

			pT->Lock();
			hrRes = IConnectionPointImpl<T,piid,CDV>::Unadvise(dwCookie);
			if (SUCCEEDED(hrRes)) {
				m_dwCount--;
				UnadviseCalled(dwCookie,*piid,m_dwCount);
			}
			pT->Unlock();
			return (hrRes);
		}
	private:
		DWORD m_dwCount;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\seo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seo.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object service.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	10/11/96	created
	dondu	11/26/96	major rewrite
	andyj	02/03/97	Added CSEOMimeDictionary support
	andyj	02/12/97	Converted PropertyBag's to Dictonary's
	andyj	04/11/97	Added CSEOGenericMoniker

--*/


// SEO.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 or higher in order to build
// this project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		<<TBD>>.

#include "stdafx.h"

//#define IID_DEFINED
#include "initguid.h"

#define SEODLLDEF	// identifiers get exported through the .DEF file
#include "seodefs.h"

#include "mimeole.h"

#include "hack.h"
#include "SEOmap.h"
#include "String"
#include "MEMBAG.h"

#include "IADMW.H" // Needed by METABAG.H
#include "METABAG.H"

#include "SEO_i.c"
#include "regprop.h"
//#include "mimebag.h"
#include "item.h"
#include "fhash.h"
#include "router.h"
#include "rwnew.h"
#include "seolock.h"
#include "subdict.h"
#include "stream.h"
#include "events.h"
#include "gmoniker.h"
#include "seolib.h"


CSEOComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CSEORegDictionary, CSEORegDictionary)
//	OBJECT_ENTRY(CLSID_CSEOMimeDictionary, CSEOMimeDictionary)
	OBJECT_ENTRY(CLSID_CSEOMemDictionary, CSEOMemDictionary)
	OBJECT_ENTRY(CLSID_CSEOMetaDictionary, CSEOMetaDictionary)
	OBJECT_ENTRY(CLSID_CSEODictionaryItem, CSEODictionaryItem)
	OBJECT_ENTRY(CLSID_CSEORouter, CSEORouter)
	OBJECT_ENTRY(CLSID_CEventLock, CEventLock)
	OBJECT_ENTRY(CLSID_CSEOStream, CSEOStream)
	OBJECT_ENTRY(CLSID_CEventManager, CEventManager)
	OBJECT_ENTRY(CLSID_CSEOGenericMoniker, CSEOGenericMoniker)
	OBJECT_ENTRY(CLSID_CEventMetabaseDatabaseManager, CEventMetabaseDatabaseManager)
	OBJECT_ENTRY(CLSID_CEventBindingManager, CEventBindingManager)
	OBJECT_ENTRY(CLSID_CEventUtil, CEventUtil)
	OBJECT_ENTRY(CLSID_CEventComCat, CEventComCat)
	OBJECT_ENTRY(CLSID_CEventRouter, CEventRouter)
	OBJECT_ENTRY(CLSID_CEventServiceObject, CEventServiceObject)
END_OBJECT_MAP()

ALLOC_DEBUG_MODULE


/////////////////////////////////////////////////////////////////////////////
// CSEOComModule

static GUID g_appidSEO = { /* 064b2506-630b-11d2-a028-00c04fa37348 */
    0x064b2506,
    0x630b,
    0x11d2,
    {0xa0, 0x28, 0x00, 0xc0, 0x4f, 0xa3, 0x73, 0x48}
};

const GUID *CSEOComModule::GetAPPID() {

	return (&g_appidSEO);
}


HRESULT CSEOComModule::WriteAPPID() {
	CStringGUID guid;
	LPSTR pszKey;
	CRegKey rk;
	LONG lRes;
	HRESULT hrRes = S_OK;

	guid = *GetAPPID();
	if (!guid) {
		return (CO_E_CLASSSTRING);
	}
	pszKey = (LPSTR) alloca(strlen("AppID\\")+strlen(guid)+1);
	if (!pszKey) {
		return (E_OUTOFMEMORY);
	}
	strcpy(pszKey,"AppID\\");
	strcat(pszKey,guid);
	lRes = rk.Create(HKEY_CLASSES_ROOT,pszKey);
	if (lRes != ERROR_SUCCESS) {
		return (HRESULT_FROM_WIN32(lRes));
	}
	lRes = rk.SetValue("Server Extension Objects");
	if (lRes != ERROR_SUCCESS) {
		hrRes = HRESULT_FROM_WIN32(lRes);
		goto exit;
	}
	lRes = rk.SetValue("","DllSurrogate");
	if (lRes != ERROR_SUCCESS) {
		hrRes = HRESULT_FROM_WIN32(lRes);
		goto exit;
	}
exit:
	rk.Close();
	if (!SUCCEEDED(hrRes)) {
		EraseAPPID();
	}
	return (hrRes);
}


HRESULT CSEOComModule::EraseAPPID() {
	CStringGUID guid;
	LPSTR pszKey;
	CRegKey rk;
	LONG lRes;
	HRESULT hrRes = S_OK;

	guid = *GetAPPID();
	if (!guid) {
		return (CO_E_CLASSSTRING);
	}
	pszKey = (LPSTR) alloca(strlen(guid)+strlen("AppID\\")+1);
	if (!pszKey) {
		return (E_OUTOFMEMORY);
	}
	strcpy(pszKey,"AppID\\");
	strcat(pszKey,guid);
	lRes = rk.Open(HKEY_CLASSES_ROOT,"");
	if (lRes != ERROR_SUCCESS) {
		return (HRESULT_FROM_WIN32(lRes));
	}
	lRes = rk.RecurseDeleteKey(pszKey);
	if (lRes != ERROR_SUCCESS) {
		hrRes = HRESULT_FROM_WIN32(lRes);
		goto exit;
	}
exit:
	rk.Close();
	return (hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		_Module.Init(ObjectMap,hInstance);
		INIT_DEBUG_MODULE
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
		TERM_DEBUG_MODULE
		_Module.Term();
		if (!lpvReserved) {
			// lpvReserved is NULL when called because of FreeLibrary, and
			// non-NULL when called during normal process termination.  We
			// only want to perform this operation during FreeLibrary,
			// because we are calling into another .DLL and we only want to
			// do that if we are sure that the other .DLL hasn't already
			// terminated.
			MyMallocTerm();
		}
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {

	TraceFunctEnter("DllCanUnloadNow");
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	DebugTrace(0,"Returns %s.",(hRes==S_OK)?"S_OK":"S_FALSE");
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {

	TraceFunctEnter("DllGetClassObject");
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {

	TraceFunctEnter("DllRegisterServer");
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.WriteAPPID();
	if (SUCCEEDED(hRes)) {
		hRes = _Module.RegisterServer(TRUE);
		if (!SUCCEEDED(hRes)) {
			_Module.UnregisterServer();
			_Module.EraseAPPID();
		}
	}
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {

	TraceFunctEnter("DllUnregisterServer");
	_Module.UnregisterServer();
	_Module.EraseAPPID();
	DebugTrace(0,"Returns S_OK");
	TraceFunctLeave();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE MCISInitSEOA(LPCSTR pszService, DWORD dwVirtualServer, ISEORouter **ppshHandle) {
	TraceFunctEnter("MCISInitSEOA");
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictTmp;
	CComPtr<ISEORouter> prouterResult;

	if (!ppshHandle) {
		return (E_POINTER);
	}
	*ppshHandle = NULL;
	hrRes = MCISGetBindingInMetabaseA(pszService,dwVirtualServer,GUID_NULL,NULL,TRUE,FALSE,&pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = CComObject<CSEORouter>::_CreatorClass::CreateInstance(NULL,
																  IID_ISEORouter,
																  (LPVOID *) &prouterResult);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = prouterResult->put_Database(pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	*ppshHandle = prouterResult;
	(*ppshHandle)->AddRef();
	TraceFunctLeave();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE MCISInitSEOW(LPCWSTR pszService, DWORD dwVirtualServer, ISEORouter **ppshHandle) {
	TraceFunctEnter("MCISInitSEOW");
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictTmp;
	CComPtr<ISEORouter> prouterResult;

	if (!ppshHandle) {
		return (E_POINTER);
	}
	*ppshHandle = NULL;
	hrRes = MCISGetBindingInMetabaseW(pszService,dwVirtualServer,GUID_NULL,NULL,TRUE,FALSE,&pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = CComObject<CSEORouter>::_CreatorClass::CreateInstance(NULL,
																  IID_ISEORouter,
																  (LPVOID *) &prouterResult);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = prouterResult->put_Database(pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	*ppshHandle = prouterResult;
	(*ppshHandle)->AddRef();
	TraceFunctLeave();
	return (S_OK);
}


static HRESULT GetSubDictA(ISEODictionary *pdictBase,
						   LPCSTR pszName,
						   LPCSTR *ppszSubName,
						   ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	LPSTR pszNameCopy = (LPSTR) _alloca((strlen(pszName)+1)*sizeof(CHAR));
	LPSTR pszNameCurr;
	CComPtr<ISEODictionary> pdictCurr = pdictBase;
	LPSTR pszSlash;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!pdictBase || !pszName || !ppszSubName) {
		return (E_POINTER);
	}
	strcpy(pszNameCopy,pszName);
	pszNameCurr = pszNameCopy;
	while ((pszSlash=strchr(pszNameCurr,'\\'))!=NULL) {
		CComPtr<ISEODictionary> pdictSub;

		*pszSlash = 0;
		pdictSub.Release();
		hrRes = pdictCurr->GetInterfaceA(pszNameCurr,IID_ISEODictionary,(IUnknown **) &pdictSub);
		if (!SUCCEEDED(hrRes) && (hrRes != SEO_E_NOTPRESENT)) {
			return (hrRes);
		}
		if (!SUCCEEDED(hrRes)) {
			hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																				 IID_ISEODictionary,
																				 (LPVOID *) &pdictSub);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			hrRes = pdictCurr->SetInterfaceA(pszNameCurr,pdictSub);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		pdictCurr = pdictSub;
		pszNameCurr = pszSlash + 1;
	}
	*ppszSubName = pszName + (pszNameCurr - pszNameCopy);
	*ppdictResult = pdictCurr;
	(*ppdictResult)->AddRef();
	return (S_OK);
}


static HRESULT GetSubDictW(ISEODictionary *pdictBase,
						   LPCWSTR pszName,
						   LPCWSTR *ppszSubName,
						   ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	LPWSTR pszNameCopy = (LPWSTR) _alloca((wcslen(pszName)+1)*sizeof(WCHAR));
	LPWSTR pszNameCurr;
	CComPtr<ISEODictionary> pdictCurr = pdictBase;
	LPWSTR pszSlash;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!pdictBase || !pszName || !ppszSubName) {
		return (E_POINTER);
	}
	wcscpy(pszNameCopy,pszName);
	pszNameCurr = pszNameCopy;
	while ((pszSlash=wcschr(pszNameCurr,'\\'))!=NULL) {
		CComPtr<ISEODictionary> pdictSub;

		*pszSlash = 0;
		pdictSub.Release();
		hrRes = pdictCurr->GetInterfaceW(pszNameCurr,IID_ISEODictionary,(IUnknown **) &pdictSub);
		if (!SUCCEEDED(hrRes) && (hrRes != SEO_E_NOTPRESENT)) {
			return (hrRes);
		}
		if (!SUCCEEDED(hrRes)) {
			hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																				 IID_ISEODictionary,
																				 (LPVOID *) &pdictSub);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			hrRes = pdictCurr->SetInterfaceW(pszNameCurr,pdictSub);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		pdictCurr = pdictSub;
		pszNameCurr = pszSlash + 1;
	}
	*ppszSubName = pszName + (pszNameCurr - pszNameCopy);
	*ppdictResult = pdictCurr;
	(*ppdictResult)->AddRef();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateDictionaryFromMultiSzA(	DWORD dwCount,
														LPCSTR *ppszNames,
														LPCSTR *ppszValues,
														BOOL bCopy,
														BOOL bReadOnly,
														ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	DWORD dwIdx;
	CComPtr<ISEODictionary> pdictTmp;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!ppszNames || !ppszValues) {
		return (E_POINTER);
	}
	hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																		 IID_ISEODictionary,
																		 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwCount;dwIdx++) {
		if (!ppszNames[dwIdx] || !ppszNames[dwIdx][0]) {
			return (E_POINTER);
		}
		LPCSTR pszSubString;
		CComPtr<ISEODictionary> pdictSub;
		LPCSTR pszSubName;

		pdictSub.Release();
		hrRes = GetSubDictA(pdictTmp,ppszNames[dwIdx],&pszSubName,&pdictSub);
		pszSubString = ppszValues[dwIdx];
		if (pszSubString[strlen(pszSubString)+1]) {
			CComPtr<ISEODictionaryItem> pitemValue;

			hrRes = CComObject<CSEODictionaryItem>::_CreatorClass::CreateInstance(NULL,
																				  IID_ISEODictionaryItem,
																				  (LPVOID *) &pitemValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			while (*pszSubString) {
				hrRes = pitemValue->AddStringA((DWORD) -1,pszSubString);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				pszSubString += strlen(pszSubString) + 1;
			}
			hrRes = pdictSub->SetInterfaceA(pszSubName,pitemValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		} else {
			hrRes = pdictSub->SetStringA(pszSubName,(strlen(pszSubString)+1)*sizeof(CHAR),pszSubString);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
	}
	*ppdictResult = pdictTmp;
	(*ppdictResult)->AddRef();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateDictionaryFromMultiSzW(	DWORD dwCount,
														LPCWSTR *ppszNames,
														LPCWSTR *ppszValues,
														BOOL bCopy,
														BOOL bReadOnly,
														ISEODictionary **ppdictResult) {

	HRESULT hrRes;
	DWORD dwIdx;
	CComPtr<ISEODictionary> pdictTmp;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!ppszNames || !ppszValues) {
		return (E_POINTER);
	}
	hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																		 IID_ISEODictionary,
																		 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwCount;dwIdx++) {
		if (!ppszNames[dwIdx] || !ppszNames[dwIdx][0]) {
			return (E_POINTER);
		}
		LPCWSTR pszSubString;
		CComPtr<ISEODictionary> pdictSub;
		LPCWSTR pszSubName;

		pdictSub.Release();
		hrRes = GetSubDictW(pdictTmp,ppszNames[dwIdx],&pszSubName,&pdictSub);
		pszSubString = ppszValues[dwIdx];
		if (pszSubString[wcslen(pszSubString)+1]) {
			CComPtr<ISEODictionaryItem> pitemValue;

			hrRes = CComObject<CSEODictionaryItem>::_CreatorClass::CreateInstance(NULL,
																				  IID_ISEODictionaryItem,
																				  (LPVOID *) &pitemValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			while (*pszSubString) {
				hrRes = pitemValue->AddStringW((DWORD) -1,pszSubString);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				pszSubString += wcslen(pszSubString) + 1;
			}
			hrRes = pdictSub->SetInterfaceW(pszSubName,pitemValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		} else {
			hrRes = pdictSub->SetStringW(pszSubName,(wcslen(pszSubString)+1)*sizeof(CHAR),pszSubString);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
	}
	*ppdictResult = pdictTmp;
	(*ppdictResult)->AddRef();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateMultiSzFromDictionaryA(	ISEODictionary *pdictDictionary,
														DWORD *pdwCount,
														LPSTR **pppszNames,
														LPSTR **pppszValues) {

	return (E_NOTIMPL);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateMultiSzFromDictionaryW(	ISEODictionary *pdictDictionary,
														DWORD *pdwCount,
														LPWSTR **pppszNames,
														LPWSTR **pppszValues) {

	return (E_NOTIMPL);
}


#define DW2W(x) _itow(x,(LPWSTR) _alloca(11*sizeof(WCHAR)),10)


SEODLLDEF HRESULT STDAPICALLTYPE MCISGetBindingInMetabaseA(	LPCSTR pszService,
												DWORD dwVirtualServer,
												REFGUID guidEventSource,
												LPCSTR pszBinding,
												BOOL bCreate,
												BOOL fLock,
												ISEODictionary **ppdictResult) {
	USES_CONVERSION;

	return (MCISGetBindingInMetabaseW(pszService?A2W(pszService):NULL,
									  dwVirtualServer,
									  guidEventSource,
									  pszBinding?A2W(pszBinding):NULL,
									  bCreate,
									  fLock,
									  ppdictResult));
}

SEODLLDEF HRESULT STDAPICALLTYPE MCISGetBindingInMetabaseW(	LPCWSTR pszService,
												DWORD dwVirtualServer,
												REFGUID guidEventSource,
												LPCWSTR pszBinding,
												BOOL bCreate,
												BOOL fLock,
												ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	CComPtr<ISEOInitObject> pinitRoot;
	CComPtr<ISEODictionary> pdictTmp;
	CComQIPtr<IPropertyBag,&IID_IPropertyBag> ppropTmp;
	CComQIPtr<ISEODictionary,&IID_ISEODictionary> pdictRoot;
	CComBSTR bstrPath;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!pszService) {
		return (E_POINTER);
	}
	if ((guidEventSource != GUID_NULL) && !pszBinding && !bCreate) {
		return (E_INVALIDARG);
	}
	hrRes = CComObject<CSEOMetaDictionary>::_CreatorClass::CreateInstance(NULL,
																		  IID_ISEOInitObject,
																		  (LPVOID *) &pinitRoot);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																		 IID_ISEODictionary,
																		 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pdictTmp->SetStringW(L"MetabasePath",1,L"");
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	ppropTmp = pdictTmp;
	if (!ppropTmp) {
		return (E_NOINTERFACE);
	}
	hrRes = pinitRoot->Load(ppropTmp,NULL);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pdictRoot = pinitRoot;
	if (!pdictRoot) {
		return (E_NOINTERFACE);
	}
	bstrPath = "LM/";
	bstrPath.Append(pszService);
	bstrPath.Append("/");
	bstrPath.Append(DW2W(dwVirtualServer));
	bstrPath.Append("/SEO");
	if (guidEventSource != GUID_NULL) {
		CStringGUID objGuid;

		bstrPath.Append("/BindingPoints/");
		objGuid = guidEventSource;
		if (!objGuid) {
			return (E_INVALIDARG);
		}
		bstrPath.Append((LPCOLESTR) objGuid);
		bstrPath.Append("/Bindings/");
		if (pszBinding) {
			bstrPath.Append(pszBinding);
		} else {
			if (!objGuid.CalcNew()) {
				return (E_FAIL);
			}
			bstrPath.Append((LPCOLESTR) objGuid);
		}
	}
again:
	hrRes = pdictRoot->GetInterfaceW(bstrPath,IID_ISEODictionary,(IUnknown **) ppdictResult);
	if (SUCCEEDED(hrRes) || (hrRes != SEO_E_NOTPRESENT) || !bCreate) {
		return (hrRes);
	}
	// We got an SEO_E_NOTPRESENT error, and the caller specified bCreate==TRUE, so we need
	// to create the sub-key.  We do this by writing an empty dictionary to the sub-key - we'll
	// empty the dictionary we used to initialize the root, and write that to the sub-key.
	CComVariant varEmpty;
	hrRes = pdictTmp->SetVariantW(L"MetabasePath",&varEmpty);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pdictRoot->SetInterfaceW(bstrPath,pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	bCreate = FALSE;
	goto again;
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOListenForEvent(	ISEORouter *piRouter,
										HANDLE hEvent,
									  	ISEOEventSink *psinkEventSink,
										BOOL bOnce,
									  	DWORD *pdwListenHandle) {

	return (E_NOTIMPL);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCancelListenForEvent(	DWORD dwHandle) {

	return (E_NOTIMPL);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateIStreamFromFileA(	HANDLE hFile,
												LPCSTR pszFile,
												IStream **ppstreamResult) {
	HRESULT hrRes;
	CComObject<CSEOStream> *pStream;
	ULARGE_INTEGER libOffset;

	if (!ppstreamResult) {
		return (E_POINTER);
	}
	*ppstreamResult = NULL;
	hrRes = CComObject<CSEOStream>::CreateInstance(&pStream);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pStream->AddRef();
	libOffset.QuadPart = 0;
	hrRes = pStream->Init(hFile,pszFile,libOffset,NULL);
	if (SUCCEEDED(hrRes)) {
		hrRes = pStream->QueryInterface(IID_IStream,(LPVOID *) ppstreamResult);
	}
	pStream->Release();
	return (hrRes);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateIStreamFromFileW(	HANDLE hFile,
												LPCWSTR pszFile,
												IStream **ppstreamResult) {
	HRESULT hrRes;
	CComObject<CSEOStream> *pStream;
	ULARGE_INTEGER libOffset;

	if (!ppstreamResult) {
		return (E_POINTER);
	}
	*ppstreamResult = NULL;
	hrRes = CComObject<CSEOStream>::CreateInstance(&pStream);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pStream->AddRef();
	libOffset.QuadPart = 0;
	hrRes = pStream->Init(hFile,pszFile,libOffset,NULL);
	if (SUCCEEDED(hrRes)) {
		hrRes = pStream->QueryInterface(IID_IStream,(LPVOID *) ppstreamResult);
	}
	pStream->Release();
	return (hrRes);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCopyDictionary(ISEODictionary *pdictIn, ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictTmp;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																		 IID_ISEODictionary,
																		 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pdictIn) {
		CComPtr<IUnknown> punkEnum;

		hrRes = pdictIn->get__NewEnum(&punkEnum);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pevEnum(punkEnum);
		if (!pevEnum) {
			return (E_NOINTERFACE);
		}
		VARIANT varName;
		VariantInit(&varName);
		while ((hrRes=pevEnum->Next(1,&varName,NULL))==S_OK) {
			VARIANT varValue;

			VariantInit(&varValue);
			hrRes = pdictIn->get_Item(&varName,&varValue);
			if (!SUCCEEDED(hrRes) || (varValue.vt == VT_EMPTY)) {
				VariantClear(&varName);
				return (hrRes);
			}
			hrRes = VariantChangeType(&varValue,&varValue,0,VT_UNKNOWN);
			if (SUCCEEDED(hrRes)) {
				CComQIPtr<ISEODictionary,&IID_ISEODictionary> pdictSub(varValue.punkVal);

				if (pdictSub) {
					CComPtr<ISEODictionary> pdictSubCopy;

					hrRes = SEOCopyDictionary(pdictSub,&pdictSubCopy);
					if (!SUCCEEDED(hrRes)) {
						VariantClear(&varName);
						return (hrRes);
					}
					varValue.punkVal->Release();
					varValue.punkVal = pdictSubCopy;
					varValue.punkVal->AddRef();
				}
			}
			hrRes = pdictTmp->put_Item(&varName,&varValue);
			VariantClear(&varName);
			VariantClear(&varValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		if (hrRes == S_FALSE) {
			hrRes = S_OK;
		}
	}
	*ppdictResult = pdictTmp;
	(*ppdictResult)->AddRef();
	return (hrRes);
}


static HRESULT ReadLineFromStream(IStream *pstreamIn, LPSTR *ppszLine) {
	HRESULT hrRes;
	const int c_iAllocSize = 512;
	LPSTR pszTmp = NULL;
	LPSTR pszCurr = NULL;
	LPSTR pszEnd = NULL;
	BOOL bInEscape = FALSE;
	BOOL bEOF = FALSE;

	if (!pstreamIn || !ppszLine) {
		return (E_POINTER);
	}
	CoTaskMemFree(*ppszLine);
	*ppszLine = NULL;
	while (1) {
		if (pszCurr == pszEnd) {
			LPSTR pszNew = (LPSTR) CoTaskMemRealloc(pszTmp,((pszCurr-pszTmp)+c_iAllocSize)*sizeof(*pszTmp));

			if (!pszNew) {
				CoTaskMemFree(pszTmp);
				return (E_OUTOFMEMORY);
			}
			pszCurr = pszNew + (pszCurr-pszTmp);
			pszEnd = pszCurr + c_iAllocSize;
			pszTmp = pszNew;
		}
		hrRes = pstreamIn->Read(pszCurr,sizeof(*pszCurr),NULL);
		if (!SUCCEEDED(hrRes)) {
			CoTaskMemFree(pszTmp);
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			// end-of-file - pretend like non-escaped '\n'
			bInEscape = FALSE;
			*pszCurr = '\n';
			bEOF = TRUE;
		}
		if (*pszCurr == '\r') {
			// always eat carriage returns - even escaped ones
			continue;
		}
		if (bInEscape) {
			switch (*pszCurr) {

				case 'n':
					// escape-n becomes linefeed
					*pszCurr = '\n';
					break;

				case 'r':
					// escape-r becomes carriage return
					*pszCurr = '\r';
					break;

				case '\n':
					// escaped-linefeed means line continuation
					pszCurr--;
					break;

// for now, don't allow embedded NULLs - this is because we return a NULL-terminated string
//				case '0':
//					// escape-0 means embedded NULL
//					*pszCurr = 0;
//					break;

				case 0:
					// escape-NULL - just eat
					pszCurr--;
					break;

				default:
					// escape-(anything else) is just passed through
					break;
			}
			bInEscape = FALSE;
		} else {
			BOOL bFinished = FALSE;

			switch (*pszCurr) {

				case '\\':
					// first character of escape sequence
					pszCurr--;
					bInEscape = TRUE;
					break;

				case '\n':
					// end-of-line
					bFinished = TRUE;
					break;

				case 0:
					// non-escaped NULL - just eat
					pszCurr--;
					break;
			}
			if (bFinished) {
				break;
			}
		}
		pszCurr++;
	}
	*pszCurr = 0;
	*ppszLine = pszTmp;
	return (bEOF?S_FALSE:S_OK);
}


static HRESULT SEOCreateMultiSzFromIStreamA(IStream *pstreamIn,
											DWORD *pdwCount,
											LPSTR **pppszNames,
											LPSTR **pppszValues) {
	HRESULT hrRes;
	LPSTR *ppszLines = NULL;
	DWORD dwLines = NULL;

	if (!pstreamIn || !pdwCount || !pppszNames || !pppszValues) {
		return (E_POINTER);
	}
	*pdwCount = 0;
	*pppszNames = NULL;
	*pppszValues = NULL;
	while (1) {
		LPSTR *ppszNew = (LPSTR *) CoTaskMemRealloc(ppszLines,sizeof(*ppszLines)*(dwLines+1));

		if (!ppszNew) {
			hrRes = E_OUTOFMEMORY;
			break;
		}
		ppszLines = ppszNew;
		ppszLines[dwLines] = NULL;
		hrRes = ReadLineFromStream(pstreamIn,&ppszLines[dwLines]);
		if (!SUCCEEDED(hrRes)) {
			break;
		}
		if (!ppszLines[dwLines][0] ||
			(ppszLines[dwLines][0] == '#') ||
			!strchr(ppszLines[dwLines],'=')) {
			if (hrRes == S_FALSE) {
				break;
			}
			CoTaskMemFree(ppszLines[dwLines]);
			continue;
		}
		dwLines++;
	}
	if (SUCCEEDED(hrRes)) {
		DWORD dwIdx;
		LPSTR pszNameCurr = NULL;
		LPSTR pszValueCurr = NULL;

		hrRes = S_OK;
		while (1) {
			for (dwIdx=0;dwIdx<dwLines;dwIdx++) {
				LPSTR pszEquals = strchr(ppszLines[dwIdx],'=');

				if (*pppszNames) {
					(*pppszNames)[dwIdx] = pszNameCurr;
					memcpy(pszNameCurr,
						   ppszLines[dwIdx],
						   (pszEquals-ppszLines[dwIdx])*sizeof(*pszNameCurr));
					(*pppszValues)[dwIdx] = pszValueCurr;
					strcpy(pszValueCurr,pszEquals+1);
				}
				pszNameCurr += pszEquals - ppszLines[dwIdx] + 1;
				pszValueCurr += strlen(pszEquals+1) + 1 + 1;	// multi-sz, so is double-NULL terminated
			}
			if (*pppszNames) {
				*pdwCount = dwLines;
				break;
			}
			if (!*pppszNames) {
				DWORD dwNameBytes = dwLines * sizeof(*pppszNames) + ((LPBYTE) pszNameCurr - (LPBYTE) NULL);
				DWORD dwValueBytes = dwLines * sizeof(*pppszValues) + ((LPBYTE) pszValueCurr - (LPBYTE) NULL);

				*pppszNames = (LPSTR *) CoTaskMemAlloc(dwNameBytes);
				*pppszValues = (LPSTR *) CoTaskMemAlloc(dwValueBytes);
				if (!*pppszNames || !*pppszValues) {
					hrRes = E_OUTOFMEMORY;
					break;
				}
				memset(*pppszNames,0,dwNameBytes);
				memset(*pppszValues,0,dwValueBytes);
				pszNameCurr = (LPSTR) ((LPBYTE) *pppszNames + dwLines * sizeof(*pppszNames));
				pszValueCurr = (LPSTR) ((LPBYTE) *pppszValues + dwLines * sizeof(*pppszValues));
			}
		}
	}
	if (!SUCCEEDED(hrRes)) {
		*pdwCount = 0;
		CoTaskMemFree(*pppszNames);
		CoTaskMemFree(*pppszValues);
	}
	for (DWORD dwIdx=0;dwIdx<dwLines;dwIdx++) {
		CoTaskMemFree(ppszLines[dwIdx]);
	}
	CoTaskMemFree(ppszLines);
	return (hrRes);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateDictionaryFromIStream(IStream *pstreamIn, ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	DWORD dwCount;
	LPSTR *ppszNames;
	LPSTR *ppszValues;
	
	if (!ppdictResult) {
		return (E_POINTER);
	}
	hrRes = SEOCreateMultiSzFromIStreamA(pstreamIn,&dwCount,&ppszNames,&ppszValues);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = SEOCreateDictionaryFromMultiSzA(dwCount,
											(LPCSTR *) ppszNames,
											(LPCSTR *) ppszValues,
											TRUE,
											FALSE,
											ppdictResult);
	CoTaskMemFree(ppszNames);
	CoTaskMemFree(ppszValues);
	return (hrRes);
}


static HRESULT SEOWriteMultiSzToIStreamA(DWORD dwCount, LPCSTR *ppszNames, LPCSTR *ppszValues, IStream *pstreamOut) {

	return (E_NOTIMPL);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOWriteDictionaryToIStream(ISEODictionary *pdictIn, IStream *pstreamOut) {
	HRESULT hrRes;
	DWORD dwCount;
	LPSTR *ppszNames;
	LPSTR *ppszValues;

	if (!pstreamOut) {
		return (E_POINTER);
	}
	hrRes = SEOCreateMultiSzFromDictionaryA(pdictIn,&dwCount,&ppszNames,&ppszValues);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = SEOWriteMultiSzToIStreamA(dwCount,(LPCSTR *) ppszNames,(LPCSTR *) ppszValues,pstreamOut);
	CoTaskMemFree(ppszNames);
	CoTaskMemFree(ppszValues);
	return (hrRes);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\seoutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    seoutil.cpp

Abstract:

    This module contains the implementation for various utility
    functions.

Author:

    Don Dumitru (dondu@microsoft.com)

Revision History:

    dondu   10/24/96    created

--*/


#include "stdafx.h"
#include "seodefs.h"


static IMalloc *g_piMalloc;


void MyMallocTerm() {

    if (g_piMalloc) {
        g_piMalloc->Release();
        g_piMalloc = NULL;
    }
}


BOOL MyMallocInit() {
    HRESULT hrRes;
    IMalloc *piMalloc;

    if (!g_piMalloc) {
        hrRes = CoGetMalloc(1,&piMalloc);
        if (SUCCEEDED(hrRes)) {
            if (InterlockedCompareExchangePointer((void**)&g_piMalloc,piMalloc,NULL) != NULL) {
                piMalloc->Release();
            }
        }
    }
    return (g_piMalloc?TRUE:FALSE);
}


LPVOID MyMalloc(size_t cbBytes) {
    LPVOID pvRes;

    if (!MyMallocInit()) {
        return (NULL);
    }
    pvRes = g_piMalloc->Alloc(cbBytes);
    if (pvRes) {
        ZeroMemory(pvRes,g_piMalloc->GetSize(pvRes));
    }
    return (pvRes);
}


LPVOID MyRealloc(LPVOID pvBlock, size_t cbBytes) {
    size_t ulPrevSize = 0;
    size_t ulNewSize = 0;
    LPVOID pvRes;

    if (!MyMallocInit()) {
        return (NULL);
    }
    if (pvBlock) {
        ulPrevSize = g_piMalloc->GetSize(pvBlock);
        if (ulPrevSize == (size_t) -1) {
            ulPrevSize = 0;
        }
    }
    pvRes = g_piMalloc->Realloc(pvBlock,cbBytes);
    if (pvRes) {
        ulNewSize = g_piMalloc->GetSize(pvRes);
        if (ulNewSize == (size_t) -1) {
            ulNewSize = 0;
        }
        if (ulNewSize > ulPrevSize) {
            ZeroMemory(((LPBYTE) pvRes)+ulPrevSize,ulNewSize-ulPrevSize);
        }
    }
    return (pvRes);
}


BOOL MyReallocInPlace(LPVOID pvPtrToPtrToBlock, size_t cbBytes) {
    LPVOID pvRes;

    pvRes = MyRealloc(*((LPVOID *) pvPtrToPtrToBlock),cbBytes);
    if (pvRes || (*((LPVOID *) pvPtrToPtrToBlock) && !cbBytes)) {
        *((LPVOID *) pvPtrToPtrToBlock) = pvRes;
        return (TRUE);
    }
    return (FALSE);
}


void MyFree(LPVOID pvBlock) {

    if (!g_piMalloc ) {
        return;
    }
    FillMemory(pvBlock,g_piMalloc->GetSize(pvBlock),0xe4);
    g_piMalloc->Free(pvBlock);
}


void MyFreeInPlace(LPVOID pvPtrToPtrToBlock) {
    if(*((LPVOID *) pvPtrToPtrToBlock)) { // If there's something to free
        MyFree(*((LPVOID *) pvPtrToPtrToBlock));
        *((LPVOID *) pvPtrToPtrToBlock) = NULL;
    }
}


void MySysFreeStringInPlace(BSTR *pstrBlock) {

    if (*pstrBlock) {
        FillMemory(*pstrBlock,SysStringByteLen(*pstrBlock),0xe4);
    }
    SysFreeString(*pstrBlock);
    *pstrBlock = NULL;
}


// Coerce a Variant into the desired type in-place
void VariantCoerce(VARIANTARG &var, VARTYPE varType) {
    if(var.vt != varType) { // Only if not already right type
        HRESULT hr = VariantChangeType(&var, &var, 0, varType);
        if(FAILED(hr)) VariantClear(&var);
    }
}


// Turn the IUnknown parameter into an ISEODictionary
ISEODictionary *GetDictionary(IUnknown *piUnk) {
    if(!piUnk) return 0; // Nothing to query

    ISEODictionary *newBag = 0;
    HRESULT hr = piUnk->QueryInterface(IID_ISEODictionary, (void **) &newBag);

    if(FAILED(hr)) {
        _ASSERT(!newBag); // QI failed, so shouldn't have touched the pointer
        newBag = 0; // But make sure
    } else {
        _ASSERT(newBag); // Should be set, since function succeeded
    }

    return newBag;
}


// Read a subkey from an ISEODictionary and return it as another ISEODictionary
ISEODictionary *ReadSubBag(ISEODictionary *bag, LPCSTR str) {
    if(!bag) return 0;

    TraceFunctEnter("ReadSubBag");
    ISEODictionary *pNewBag = 0;

    HRESULT hr = bag->GetInterfaceA(str, IID_ISEODictionary, (IUnknown **) &pNewBag);
    if(FAILED(hr)) FunctTrace(0, "No entry for %s found", str);

    TraceFunctLeave();
    return pNewBag;
}


// Read a string from the Dictionary.
HRESULT ReadString(ISEODictionary *bag, LPCSTR property,
                   LPSTR psBuf, LPDWORD dwCount) {
    if(!bag) return 0;
    TraceFunctEnter("ReadString");

    HRESULT hr = bag->GetStringA(property, dwCount, psBuf);
    if(FAILED(hr)) FunctTrace(0, "No %s specified", property);

    TraceFunctLeave();
    return hr;
}


// Given a CLSID as a string, create an object of that CLSID
void *CreateFromString(LPCOLESTR str, REFIID iface) {
    TraceFunctEnter("CreateFromString");
    void *object = 0;
    CLSID thisCLSID;

    HRESULT hr = CLSIDFromString((LPOLESTR) str, &thisCLSID);

    if(SUCCEEDED(hr)) {
        hr = CoCreateInstance(thisCLSID, 0, CLSCTX_ALL, iface, &object);

        if(FAILED(hr)) {
            FunctTrace(0, "CoCreateInstance failed for CLSID: %s", str);
            _ASSERT(!object); // CoCreateInstance shouldn't have changed this
            object = 0; // Just to make sure
        }
    } else {
        FunctTrace(0, "Could not convert string to CLSID, for: %s", str);
    }

    TraceFunctLeave();
    return object;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CSEOComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.
	LPOLESTR pszAPPID = NULL;	// The APPID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID and APPID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
			if (!*pparmeResult) {
				// If this is the first time through, see if an APPID is provided by the
				// module.
				const GUID *pappid = pmodule->GetAPPID();

				if (pappid) {
					// If there is an APPID, convert it to a string.
					HRESULT hrRes;

					hrRes = StringFromCLSID(*pappid,&pszAPPID);
					if (!SUCCEEDED(hrRes)) {
						// We failed to convert the APPID to a string.
						CoTaskMemFree(pszCLSID);
						return (hrRes);
					}
				}
			}
			if (pszAPPID) {
				// If the module provides an APPID, we need to add it to the map.
				if (*pparmeResult) {
					// If this isn't the first time through, then we already have the APPID as a string,
					// so we just need to put it in the map.
					(*pparmeResult)[dwCnt].szKey = L"APPID";
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszAPPID);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the APPID string and the fact that we have a APPID in the map.
				pbAdd += (wcslen(pszAPPID)+1) * sizeof(OLECHAR);
				dwCnt++;
				if (*pparmeResult) {
					// If this is not the first time through, make sure we clean up after ourselves.
					CoTaskMemFree(pszAPPID);
					pszAPPID = NULL;
				}
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (DWORD)(pbAdd-(LPBYTE) NULL);

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				CoTaskMemFree(pszAPPID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\stream.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stream.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object CSEOStream class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/29	created

--*/


// stream.cpp : Implementation of CSEOStream
#include "stdafx.h"
#include "seodefs.h"
#include "stream.h"


/////////////////////////////////////////////////////////////////////////////
// CSEOStream


HRESULT CSEOStream::FinalConstruct() {
	HRESULT hrRes;
	TraceFunctEnter("CSEOStream::FinalConstruct");

	m_hFile = NULL;
	m_pszFile = NULL;
	m_hEvent = NULL;
	m_pSubStream = NULL;
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOStream::FinalRelease() {
	TraceFunctEnter("CSEOStream::FinalRelease");

	Cleanup();
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


void CSEOStream::Cleanup() {

	if (m_hFile) {
		CloseHandle(m_hFile);
		m_hFile = NULL;
	}
	if (m_pszFile) {
		CoTaskMemFree(m_pszFile);
		m_pszFile = NULL;
	}
	if (m_hEvent) {
		CloseHandle(m_hEvent);
		m_hEvent = NULL;
	}
	if (m_pSubStream) {
		m_pSubStream->Release();
		m_pSubStream = NULL;
	}
}


HRESULT CSEOStream::Init(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream) {

	Cleanup();
	if (pSubStream) {
		m_pSubStream = pSubStream;
		m_pSubStream->AddRef();
	} else {
		if (hFile) {
			if (!DuplicateHandle(GetCurrentProcess(),
								 hFile,
								 GetCurrentProcess(),
								 &m_hFile,
								 0,
								 FALSE,
								 DUPLICATE_SAME_ACCESS)) {
				HRESULT hrRes = HRESULT_FROM_WIN32(GetLastError());

				Cleanup();
				return (hrRes);
			}
		}
		if (pszFile) {
			DWORD dwLen;

			dwLen = GetFullPathName(pszFile,0,NULL,NULL);
			if (!dwLen) {
				HRESULT hrRes = HRESULT_FROM_WIN32(GetLastError());

				Cleanup();
				return (hrRes);
			}
			m_pszFile = (LPSTR) CoTaskMemAlloc((dwLen+1)*sizeof(*m_pszFile));
			if (!m_pszFile) {
				Cleanup();
				return (E_OUTOFMEMORY);
			}
			dwLen = GetFullPathName(pszFile,dwLen+1,m_pszFile,NULL);
			if (!dwLen) {
				HRESULT hrRes = HRESULT_FROM_WIN32(GetLastError());

				Cleanup();
				return (hrRes);
			}
		}
	}
	m_libOffset = libOffset;
	return (S_OK);
}


HRESULT CSEOStream::Init(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream) {
	USES_CONVERSION;

	return (Init(hFile,W2A(pszFile),libOffset,pSubStream));
}


HRESULT CSEOStream::Open() {

	if ((m_hFile && m_hEvent) || m_pSubStream) {
		return (S_OK);
	}
	if (!m_hEvent) {
		m_hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
		if (!m_hEvent) {
			return (HRESULT_FROM_WIN32(GetLastError()));
		}
		if (m_hFile) {
			return (S_OK);
		}
	}
	if (!m_pszFile) {
		return (OLE_E_BLANK);
	}
	m_hFile = CreateFile(m_pszFile,
						 GENERIC_READ|GENERIC_WRITE,
						 0,
						 NULL,
						 OPEN_ALWAYS,
						 FILE_ATTRIBUTE_NORMAL,
						 NULL);
	if (m_hFile == INVALID_HANDLE_VALUE) {
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	return (S_OK);
}


HRESULT CSEOStream::ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset) {
	HRESULT hrRes;
	BOOL bRes;
	DWORD cbRead;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	if (m_pSubStream) {
		return (m_pSubStream->ReadOffset(pv,cb,pcbRead,plibOffset));
	}
	OVERLAPPED ov = {0,0,plibOffset->LowPart,plibOffset->HighPart,m_hEvent};
	bRes = ReadFile(m_hFile,pv,cb,&cbRead,&ov);
	if (!bRes) {

		switch (GetLastError()) {

			case ERROR_HANDLE_EOF:
				cbRead = 0;
				break;

			case ERROR_IO_PENDING:
				if (!GetOverlappedResult(m_hFile,&ov,&cbRead,TRUE)) {
					return (HRESULT_FROM_WIN32(GetLastError()));
				}
				break;

			default:
				return (HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	plibOffset->QuadPart += cbRead;
	if (pcbRead) {
		*pcbRead = cbRead;
	}
	return (cbRead?S_OK:S_FALSE);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Read(void *pv, ULONG cb, ULONG *pcbRead) {

	return (ReadOffset(pv,cb,pcbRead,&m_libOffset));
}


HRESULT CSEOStream::WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset) {
	HRESULT hrRes;
	BOOL bRes;
	DWORD cbWritten;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	if (m_pSubStream) {
		return (m_pSubStream->WriteOffset(pv,cb,pcbWritten,plibOffset));
	}
	OVERLAPPED ov = {0,0,plibOffset->LowPart,plibOffset->HighPart,m_hEvent};
	bRes = WriteFile(m_hFile,pv,cb,&cbWritten,&ov);
	if (!bRes) {

		switch (GetLastError()) {

			case ERROR_HANDLE_EOF:
				cbWritten = 0;
				break;

			case ERROR_IO_PENDING:
				if (!GetOverlappedResult(m_hFile,&ov,&cbWritten,TRUE)) {
					return (HRESULT_FROM_WIN32(GetLastError()));
				}
				break;

			default:
				return (HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	plibOffset->QuadPart += cbWritten;
	if (pcbWritten) {
		*pcbWritten = cbWritten;
	}
	return ((cbWritten==cb)?S_OK:STG_E_MEDIUMFULL);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Write(void const* pv, ULONG cb, ULONG *pcbWritten) {

	return (WriteOffset(pv,cb,pcbWritten,&m_libOffset));
}


HRESULT CSEOStream::GetSize(ULARGE_INTEGER *plibSize) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	if (m_pSubStream) {
		return (m_pSubStream->GetSize(plibSize));
	}
	if (!plibSize) {
		return (E_POINTER);
	}
	plibSize->LowPart = GetFileSize(m_hFile,&plibSize->HighPart);
	if ((plibSize->LowPart == 0xffffffff) && (GetLastError() != NO_ERROR)) {
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	hrRes = S_OK;
	switch (dwOrigin) {

		case STREAM_SEEK_SET:
			if (dlibMove.QuadPart < 0) {
				hrRes = E_INVALIDARG;
				break;
			}
			m_libOffset.QuadPart = (DWORDLONG) dlibMove.QuadPart;
			break;

		case STREAM_SEEK_CUR:
			if ((dlibMove.QuadPart < 0) && ((DWORDLONG) -dlibMove.QuadPart > m_libOffset.QuadPart)) {
				hrRes = E_INVALIDARG;
				break;
			}
			m_libOffset.QuadPart = (DWORDLONG) ((LONGLONG) m_libOffset.QuadPart + dlibMove.QuadPart);
			break;

		case STREAM_SEEK_END:
			ULARGE_INTEGER libSize;

			hrRes = GetSize(&libSize);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			if ((dlibMove.QuadPart < 0) && ((DWORDLONG) -dlibMove.QuadPart > libSize.QuadPart)) {
				hrRes = E_INVALIDARG;
				break;
			}
			m_libOffset.QuadPart = (DWORDLONG) ((LONGLONG) libSize.QuadPart + dlibMove.QuadPart);
			break;

		default:
			hrRes = STG_E_INVALIDFUNCTION;
			break;
	}
	if (pdlibNewPosition) {
		*pdlibNewPosition = m_libOffset;
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOStream::SetSize(ULARGE_INTEGER libNewSize) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	if (m_pSubStream) {
		return (m_pSubStream->SetSize(libNewSize));
	}
	if ((SetFilePointer(m_hFile,libNewSize.LowPart,(LONG *) &libNewSize.HighPart,FILE_BEGIN) == 0xffff) &&
		(GetLastError() != NO_ERROR)) {
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	if (!SetEndOfFile(m_hFile)) {
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	return (S_OK);
}


HRESULT CSEOStream::CopyToOffset(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten, ULARGE_INTEGER *plibOffset) {
	HRESULT hrRes;
	LPVOID pv;
	ULARGE_INTEGER cbRead;
	ULARGE_INTEGER cbWritten;

	if (!pstm) {
		return (E_POINTER);
	}
	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	pv = alloca((DWORD) min(cb.QuadPart,4096));
	if (!pv) {
		return (E_OUTOFMEMORY);
	}
	cbRead.QuadPart = 0;
	cbWritten.QuadPart = 0;
	while (1) {
		DWORD cbTmpRead;
		DWORD cbTmpWrite;

		if (!cb.QuadPart) {
			hrRes = S_OK;
			break;
		}
		cbTmpRead = 0;
		hrRes = ReadOffset(pv,(DWORD) min(cb.QuadPart,4096),&cbTmpRead,plibOffset);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (cbTmpRead == 0) {
			hrRes = S_FALSE;
			break;
		}
		cbRead.QuadPart += cbTmpRead;
		cbTmpWrite = 0;
		hrRes = pstm->Write(pv,cbTmpRead,&cbTmpWrite);
		if (!SUCCEEDED(hrRes)) {
			if (hrRes == STG_E_MEDIUMFULL) {
				cbWritten.QuadPart += cbTmpWrite;
			}
			break;
		}
		cbWritten.QuadPart += cbTmpWrite;
		cb.QuadPart -= cbTmpRead;
	}
	if (pcbRead) {
		*pcbRead = cbRead;
	}
	if (pcbWritten) {
		*pcbWritten = cbWritten;
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten) {

	return (CopyToOffset(pstm,cb,pcbRead,pcbWritten,&m_libOffset));
}


HRESULT STDMETHODCALLTYPE CSEOStream::Commit(DWORD grfCommitFlags) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Revert(void) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSEOStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Stat(STATSTG * pstatstg, DWORD grfStatFlag) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (E_NOTIMPL);
}


HRESULT CSEOStream::CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Clone(IStream **pstm) {

	return (CloneOffset(pstm,m_libOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\seomap.h ===
// SEOmap standard header
#ifndef _SEOMAP_
#define _SEOMAP_
#include <functional>
#include <SEOxtree.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN
		// TEMPLATE CLASS SEOmap
template<class _K, class _Ty, class _Pr = less<_K>,
	class _A = allocator<_Ty> >
	class SEOmap {
public:
	typedef SEOmap<_K, _Ty, _Pr, _A> _Myt;
	typedef pair<_K, _Ty> value_type;
	struct _Kfn : public unary_function<value_type, _K> {
		const _K& operator()(const value_type& _X) const
		{return (_X.first); }
		};
	class value_compare
		: public binary_function<value_type, value_type, bool> {
		friend class SEOmap<_K, _Ty, _Pr, _A>;
	public:
		bool operator()(const value_type& _X,
			const value_type& _Y) const
			{return (comp(_X.first, _Y.first)); }
	_PROTECTED:
		value_compare(_Pr _Pred)
			: comp(_Pred) {}
		_Pr comp;
		};
	typedef _K key_type;
	typedef _Ty referent_type;
	typedef _Pr key_compare;
	typedef _A allocator_type;
	typedef _A::reference _Tref;
	typedef _SEOTree<_K, value_type, _Kfn, _Pr, _A> _Imp;
	typedef _Imp::size_type size_type;
	typedef _Imp::difference_type difference_type;
	typedef _Imp::reference reference;
	typedef _Imp::const_reference const_reference;
	typedef _Imp::iterator iterator;
	typedef _Imp::const_iterator const_iterator;
	typedef _Imp::reverse_iterator reverse_iterator;
	typedef _Imp::const_reverse_iterator const_reverse_iterator;
	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;
	explicit SEOmap(const _Pr& _Pred = _Pr(), const _A& _Al = _A())
		: _Tr(_Pred, false, _Al) {}
	typedef const value_type *_It;
	SEOmap(_It _F, _It _L, const _Pr& _Pred = _Pr(),
		const _A& _Al = _A())
		: _Tr(_Pred, false, _Al)
		{for (; _F != _L; ++_F)
			_Tr.insert(*_F); }
	iterator begin()
		{return (_Tr.begin()); }
	const_iterator begin() const
		{return (_Tr.begin()); }
	iterator end()
		{return (_Tr.end()); }
	const_iterator end() const
		{return (_Tr.end()); }
	reverse_iterator rbegin()
		{return (_Tr.rbegin()); }
	const_reverse_iterator rbegin() const
		{return (_Tr.rbegin()); }
	reverse_iterator rend()
		{return (_Tr.rend()); }
	const_reverse_iterator rend() const
		{return (_Tr.rend()); }
	size_type size() const
		{return (_Tr.size()); }
	size_type max_size() const
		{return (_Tr.max_size()); }
	bool empty() const
		{return (_Tr.empty()); }
	_A get_allocator() const
		{return (_Tr.get_allocator()); }
	_Tref operator[](const key_type& _Kv)
		{iterator _P = insert(value_type(_Kv, _Ty())).first;
		return ((*_P).second); }
	_Pairib insert(const value_type& _X)
		{_Imp::_Pairib _Ans = _Tr.insert(_X);
		return (_Pairib(_Ans.first, _Ans.second)); }
	iterator insert(iterator _P, const value_type& _X)
		{return (_Tr.insert((_Imp::iterator&)_P, _X)); }
	void insert(_It _F, _It _L)
		{for (; _F != _L; ++_F)
			_Tr.insert(*_F); }
	iterator erase(iterator _P)
		{return (_Tr.erase((_Imp::iterator&)_P)); }
	iterator erase(iterator _F, iterator _L)
		{return (_Tr.erase((_Imp::iterator&)_F,
			(_Imp::iterator&)_L)); }
	size_type erase(const _K& _Kv)
		{return (_Tr.erase(_Kv)); }
	void clear()
		{_Tr.clear(); }
	void swap(_Myt& _X)
		{std::swap(_Tr, _X._Tr); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	key_compare key_comp() const
		{return (_Tr.key_comp()); }
	value_compare value_comp() const
		{return (value_compare(_Tr.key_comp())); }
	iterator find(const _K& _Kv)
		{return (_Tr.find(_Kv)); }
	const_iterator find(const _K& _Kv) const
		{return (_Tr.find(_Kv)); }
	size_type count(const _K& _Kv) const
		{return (_Tr.count(_Kv)); }
	iterator lower_bound(const _K& _Kv)
		{return (_Tr.lower_bound(_Kv)); }
	const_iterator lower_bound(const _K& _Kv) const
		{return (_Tr.lower_bound(_Kv)); }
	iterator upper_bound(const _K& _Kv)
		{return (_Tr.upper_bound(_Kv)); }
	const_iterator upper_bound(const _K& _Kv) const
		{return (_Tr.upper_bound(_Kv)); }
	_Pairii equal_range(const _K& _Kv)
		{return (_Tr.equal_range(_Kv)); }
	_Paircc equal_range(const _K& _Kv) const
		{return (_Tr.equal_range(_Kv)); }
protected:
	_Imp _Tr;
	};
		// SEOmap TEMPLATE OPERATORS
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator==(const SEOmap<_K, _Ty, _Pr, _A>& _X,
		const SEOmap<_K, _Ty, _Pr, _A>& _Y)
	{return (_X.size() == _Y.size()
		&& equal(_X.begin(), _X.end(), _Y.begin())); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator!=(const SEOmap<_K, _Ty, _Pr, _A>& _X,
		const SEOmap<_K, _Ty, _Pr, _A>& _Y)
	{return (!(_X == _Y)); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator<(const SEOmap<_K, _Ty, _Pr, _A>& _X,
		const SEOmap<_K, _Ty, _Pr, _A>& _Y)
	{return (lexicographical_compare(_X.begin(), _X.end(),
		_Y.begin(), _Y.end())); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator>(const SEOmap<_K, _Ty, _Pr, _A>& _X,
		const SEOmap<_K, _Ty, _Pr, _A>& _Y)
	{return (_Y < _X); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator<=(const SEOmap<_K, _Ty, _Pr, _A>& _X,
		const SEOmap<_K, _Ty, _Pr, _A>& _Y)
	{return (!(_Y < _X)); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator>=(const SEOmap<_K, _Ty, _Pr, _A>& _X,
		const SEOmap<_K, _Ty, _Pr, _A>& _Y)
	{return (!(_X < _Y)); }
		// TEMPLATE CLASS SEOmultimap
template<class _K, class _Ty, class _Pr = less<_K>,
	class _A = allocator<_Ty> >
	class SEOmultimap {
public:
	typedef SEOmultimap<_K, _Ty, _Pr, _A> _Myt;
	typedef pair<const _K, _Ty> value_type;
	struct _Kfn : public unary_function<value_type, _K> {
		const _K& operator()(const value_type& _X) const
		{return (_X.first); }
		};
	class value_compare
		: public binary_function<value_type, value_type, bool> {
		friend class SEOmap<_K, _Ty, _Pr, _A>;
	public:
		bool operator()(const value_type& _X,
			const value_type& _Y) const
			{return (comp(_X.first, _Y.first)); }
	_PROTECTED:
		value_compare(_Pr _Pred)
			: comp(_Pred) {}
		_Pr comp;
		};
	typedef _K key_type;
	typedef _Ty referent_type;
	typedef _Pr key_compare;
	typedef _A allocator_type;
	typedef _SEOTree<_K, value_type, _Kfn, _Pr, _A> _Imp;
	typedef _Imp::size_type size_type;
	typedef _Imp::difference_type difference_type;
	typedef _Imp::reference reference;
	typedef _Imp::const_reference const_reference;
	typedef _Imp::iterator iterator;
	typedef _Imp::const_iterator const_iterator;
	typedef _Imp::reverse_iterator reverse_iterator;
	typedef _Imp::const_reverse_iterator const_reverse_iterator;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;
	explicit SEOmultimap(const _Pr& _Pred = _Pr(),
		const _A& _Al = _A())
		: _Tr(_Pred, true, _Al) {}
	typedef const value_type *_It;
	SEOmultimap(_It _F, _It _L, const _Pr& _Pred = _Pr(),
			const _A& _Al = _A())
		: _Tr(_Pred, true, _Al)
		{for (; _F != _L; ++_F)
			_Tr.insert(*_F); }
	iterator begin()
		{return (_Tr.begin()); }
	const_iterator begin() const
		{return (_Tr.begin()); }
	iterator end()
		{return (_Tr.end()); }
	const_iterator end() const
		{return (_Tr.end()); }
	reverse_iterator rbegin()
		{return (_Tr.rbegin()); }
	const_reverse_iterator rbegin() const
		{return (_Tr.rbegin()); }
	reverse_iterator rend()
		{return (_Tr.rend()); }
	const_reverse_iterator rend() const
		{return (_Tr.rend()); }
	size_type size() const
		{return (_Tr.size()); }
	size_type max_size() const
		{return (_Tr.max_size()); }
	bool empty() const
		{return (_Tr.empty()); }
	_A get_allocator() const
		{return (_Tr.get_allocator()); }
	iterator insert(const value_type& _X)
		{return (_Tr.insert(_X).first); }
	iterator insert(iterator _P, const value_type& _X)
		{return (_Tr.insert((_Imp::iterator&)_P, _X)); }
	void insert(_It _F, _It _L)
		{for (; _F != _L; ++_F)
			_Tr.insert(*_F); }
	iterator erase(iterator _P)
		{return (_Tr.erase((_Imp::iterator&)_P)); }
	iterator erase(iterator _F, iterator _L)
		{return (_Tr.erase((_Imp::iterator&)_F,
			(_Imp::iterator&)_L)); }
	size_type erase(const _K& _Kv = _K())
		{return (_Tr.erase(_Kv)); }
	void clear()
		{_Tr.clear(); }
	void swap(_Myt& _X)
		{std::swap(_Tr, _X._Tr); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	key_compare key_comp() const
		{return (_Tr.key_comp()); }
	value_compare value_comp() const
		{return (value_compare(_Tr.key_comp())); }
	iterator find(const _K& _Kv)
		{return (_Tr.find(_Kv)); }
	const_iterator find(const _K& _Kv) const
		{return (_Tr.find(_Kv)); }
	size_type count(const _K& _Kv) const
		{return (_Tr.count(_Kv)); }
	iterator lower_bound(const _K& _Kv)
		{return (_Tr.lower_bound(_Kv)); }
	const_iterator lower_bound(const _K& _Kv) const
		{return (_Tr.lower_bound(_Kv)); }
	iterator upper_bound(const _K& _Kv)
		{return (_Tr.upper_bound(_Kv)); }
	const_iterator upper_bound(const _K& _Kv) const
		{return (_Tr.upper_bound(_Kv)); }
	_Pairii equal_range(const _K& _Kv)
		{return (_Tr.equal_range(_Kv)); }
	_Paircc equal_range(const _K& _Kv) const
		{return (_Tr.equal_range(_Kv)); }
protected:
	_Imp _Tr;
	};
		// SEOmultimap TEMPLATE OPERATORS
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator==(const SEOmultimap<_K, _Ty, _Pr, _A>& _X,
		const SEOmultimap<_K, _Ty, _Pr, _A>& _Y)
	{return (_X.size() == _Y.size()
		&& equal(_X.begin(), _X.end(), _Y.begin())); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator!=(const SEOmultimap<_K, _Ty, _Pr, _A>& _X,
		const SEOmultimap<_K, _Ty, _Pr, _A>& _Y)
	{return (!(_X == _Y)); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator<(const SEOmultimap<_K, _Ty, _Pr, _A>& _X,
		const SEOmultimap<_K, _Ty, _Pr, _A>& _Y)
	{return (lexicographical_compare(_X.begin(), _X.end(),
		_Y.begin(), _Y.end())); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator>(const SEOmultimap<_K, _Ty, _Pr, _A>& _X,
		const SEOmultimap<_K, _Ty, _Pr, _A>& _Y)
	{return (_Y < _X); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator<=(const SEOmultimap<_K, _Ty, _Pr, _A>& _X,
		const SEOmultimap<_K, _Ty, _Pr, _A>& _Y)
	{return (!(_Y < _X)); }
template<class _K, class _Ty, class _Pr, class _A> inline
	bool operator>=(const SEOmultimap<_K, _Ty, _Pr, _A>& _X,
		const SEOmultimap<_K, _Ty, _Pr, _A>& _Y)
	{return (!(_X < _Y)); }
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _SEOMAP_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\stream.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stream.h

Abstract:

	This module contains the definition for the Server
	Extension Object Stream class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/29/97	created

--*/


// stream.h : Declaration of the CSEOStream

/////////////////////////////////////////////////////////////////////////////
// CStream
class ATL_NO_VTABLE CSEOStream : 
	public IStream,
	public CComObjectRoot,
	public CComCoClass<CSEOStream, &CLSID_CSEOStream>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		void Cleanup();
		HRESULT Init(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Init(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Open();
		HRESULT ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset);
		HRESULT WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset);
		HRESULT GetSize(ULARGE_INTEGER *plibSize);
		HRESULT CopyToOffset(IStream *pstm, ULARGE_INTEGER libOffset, ULARGE_INTEGER *plibRead, ULARGE_INTEGER *plibWritten, ULARGE_INTEGER *plibOffset);
		HRESULT CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset);

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOStream Class",
								   L"SEO.Stream.1",
								   L"SEO.Stream");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOStream)
		COM_INTERFACE_ENTRY(IStream)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IStream
	public:
		HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);
		HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG *pcbWritten);
		HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition);
		HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize);
		HRESULT STDMETHODCALLTYPE CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
		HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags);
		HRESULT STDMETHODCALLTYPE Revert(void);
		HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE Stat(STATSTG * pstatstg, DWORD grfStatFlag);
		HRESULT STDMETHODCALLTYPE Clone(IStream **pstm);
 
	private:
		HANDLE m_hFile;
		LPSTR m_pszFile;
		ULARGE_INTEGER m_libOffset;
		HANDLE m_hEvent;
		CSEOStream *m_pSubStream;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\seoxtree.h ===
// tree internal header
#ifndef _SEOTREE_
#define _SEOTREE_
#include <cstddef>
#include <iterator>
#include <memory>
#include <xutility>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */
_STD_BEGIN
                // TEMPLATE CLASS _SEOTree
template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
        class _SEOTree {
protected:
        typedef _POINTER_X(void, _A) _Genptr;
        enum _Redbl {_Red, _Black};
        struct _Node;
        friend struct _Node;
        struct _Node {
                _Genptr _Left, _Parent, _Right;
                _Ty _Value;
                _Redbl _Color;
                };
        typedef _POINTER_X(_Node, _A) _Nodeptr;
        typedef _REFERENCE_X(_Nodeptr, _A) _Nodepref;
        typedef _REFERENCE_X(const _K, _A) _Keyref;
        typedef _REFERENCE_X(_Redbl, _A) _Rbref;
        typedef _REFERENCE_X(_Ty, _A) _Vref;
        static _Rbref _Color(_Nodeptr _P)
                {return ((_Rbref)(*_P)._Color); }
        static _Keyref _Key(_Nodeptr _P)
                {return (_Kfn()(_Value(_P))); }
        static _Nodepref _Left(_Nodeptr _P)
                {return ((_Nodepref)(*_P)._Left); }
        static _Nodepref _Parent(_Nodeptr _P)
                {return ((_Nodepref)(*_P)._Parent); }
        static _Nodepref _Right(_Nodeptr _P)
                {return ((_Nodepref)(*_P)._Right); }
        static _Vref _Value(_Nodeptr _P)
                {return ((_Vref)(*_P)._Value); }
public:
        typedef _SEOTree<_K, _Ty, _Kfn, _Pr, _A> _Myt;
        typedef _K key_type;
        typedef _Ty value_type;
        typedef _A::size_type size_type;
        typedef _A::difference_type difference_type;
        typedef _POINTER_X(_Ty, _A) _Tptr;
        typedef _POINTER_X(const _Ty, _A) _Ctptr;
        typedef _REFERENCE_X(_Ty, _A) reference;
        typedef _REFERENCE_X(const _Ty, _A) const_reference;
                // CLASS iterator
        class iterator;
        friend class iterator;
        class iterator : public _Bidit<_Ty, difference_type> {
        public:
                iterator()
                        {}
                iterator(_Nodeptr _P)
                        : _Ptr(_P) {}
                reference operator*() const
                        {return (_Value(_Ptr)); }
                _Tptr operator->() const
                        {return (&**this); }
                iterator& operator++()
                        {_Inc();
                        return (*this); }
                iterator operator++(int)
                        {iterator _Tmp = *this;
                        ++*this;
                        return (_Tmp); }
                iterator& operator--()
                        {_Dec();
                        return (*this); }
                iterator operator--(int)
                        {iterator _Tmp = *this;
                        --*this;
                        return (_Tmp); }
                bool operator==(const iterator& _X) const
                        {return (_Ptr == _X._Ptr); }
                bool operator!=(const iterator& _X) const
                        {return (!(*this == _X)); }
                void _Dec()
                        {/*_Lockit _Lk;*/
                        if (_Color(_Ptr) == _Red
                                && _Parent(_Parent(_Ptr)) == _Ptr)
                                _Ptr = _Right(_Ptr);
                        else if (_Left(_Ptr) != _Nil)
                                _Ptr = _Max(_Left(_Ptr));
                        else
                                {_Nodeptr _P;
                                while (_Ptr == _Left(_P = _Parent(_Ptr)))
                                        _Ptr = _P;
                                _Ptr = _P; }}
                void _Inc()
                        {/*_Lockit _Lk;*/
                        if (_Right(_Ptr) != _Nil)
                                _Ptr = _Min(_Right(_Ptr));
                        else
                                {_Nodeptr _P;
                                while (_Ptr == _Right(_P = _Parent(_Ptr)))
                                        _Ptr = _P;
                                if (_Right(_Ptr) != _P)
                                        _Ptr = _P; }}
                _Nodeptr _Mynode() const
                        {return (_Ptr); }
        protected:
                _Nodeptr _Ptr;
                };
                // CLASS const_iterator
        class const_iterator;
        friend class const_iterator;
        class const_iterator : public iterator {
        public:
                const_iterator()
                        {}
                const_iterator(_Nodeptr _P)
                        : iterator(_P) {}
                const_iterator(const iterator& _X)
                        : iterator(_X) {}
                const_reference operator*() const
                        {return (_Value(_Ptr)); }
                _Ctptr operator->() const
                        {return (&**this); }
                const_iterator& operator++()
                        {_Inc();
                        return (*this); }
                const_iterator operator++(int)
                        {iterator _Tmp = *this;
                        ++*this;
                        return (_Tmp); }
                const_iterator& operator--()
                        {_Dec();
                        return (*this); }
                const_iterator operator--(int)
                        {iterator _Tmp = *this;
                        --*this;
                        return (_Tmp); }
                bool operator==(const const_iterator& _X) const
                        {return (_Ptr == _X._Ptr); }
                bool operator!=(const const_iterator& _X) const
                        {return (!(*this == _X)); }
                };
        typedef reverse_bidirectional_iterator<iterator,
                value_type, reference, _Tptr, difference_type>
                        reverse_iterator;
        typedef reverse_bidirectional_iterator<const_iterator,
                value_type, const_reference, _Ctptr, difference_type>
                        const_reverse_iterator;
        typedef pair<iterator, bool> _Pairib;
        typedef pair<iterator, iterator> _Pairii;
        typedef pair<const_iterator, const_iterator> _Paircc;
        explicit _SEOTree(const _Pr& _Parg, bool _Marg = true,
                const _A& _Al = _A())
                : allocator(_Al),
                key_compare(_Parg), _Multi(_Marg)
                {_Init(); }
        _SEOTree(const _Ty *_F, const _Ty *_L,
                const _Pr& _Parg, bool _Marg = true,
                const _A& _Al = _A())
                : allocator(_Al),
                key_compare(_Parg), _Multi(_Marg)
                {_Init();
                insert(_F, _L); }
        _SEOTree(const _Myt& _X)
                : allocator(_X.allocator),
                key_compare(_X.key_compare), _Multi(_X._Multi)
                {_Init();
                _Copy(_X); }
        ~_SEOTree()
                {erase(begin(), end());
                _Freenode(_Head);
                _Head = 0, _Size = 0;
                        {/*_Lockit _Lk;*/
                        if (--_Nilrefs == 0)
                                {_Freenode(_Nil);
                                _Nil = 0; }}}
        _Myt& operator=(const _Myt& _X)
                {if (this != &_X)
                        {erase(begin(), end());
                        key_compare = _X.key_compare;
                        _Copy(_X); }
                return (*this); }
        iterator begin()
                {return (iterator(_Lmost())); }
        const_iterator begin() const
                {return (const_iterator(_Lmost())); }
        iterator end()
                {return (iterator(_Head)); }
        const_iterator end() const
                {return (const_iterator(_Head)); }
        reverse_iterator rbegin()
                {return (reverse_iterator(end())); }
        const_reverse_iterator rbegin() const
                {return (const_reverse_iterator(end())); }
        reverse_iterator rend()
                {return (reverse_iterator(begin())); }
        const_reverse_iterator rend() const
                {return (const_reverse_iterator(begin())); }
        size_type size() const
                {return (_Size); }
        size_type max_size() const
                {return (allocator.max_size()); }
        bool empty() const
                {return (size() == 0); }
        _A get_allocator() const
                {return (allocator); }
        _Pr key_comp() const
                {return (key_compare); }
        _Pairib insert(const value_type& _V)
                {_Nodeptr _X = _Root();
                _Nodeptr _Y = _Head;
                bool _Ans = true;
                { /*_Lockit Lk;*/
                        while (_X != _Nil)
                                {_Y = _X;
                                _Ans = key_compare(_Kfn()(_V), _Key(_X));
                                _X = _Ans ? _Left(_X) : _Right(_X); }
                }
                if (_Multi)
                        return (_Pairib(_Insert(_X, _Y, _V), true));
                iterator _P = iterator(_Y);
                if (!_Ans)
                        ;
                else if (_P == begin())
                        return (_Pairib(_Insert(_X, _Y, _V), true));
                else
                        --_P;
                if (key_compare(_Key(_P._Mynode()), _Kfn()(_V)))
                        return (_Pairib(_Insert(_X, _Y, _V), true));
                return (_Pairib(_P, false)); }
        iterator insert(iterator _P, const value_type& _V)
                {if (size() == 0)
                        ;
                else if (_P == begin())
                        {if (key_compare(_Kfn()(_V), _Key(_P._Mynode())))
                                return (_Insert(_Head, _P._Mynode(), _V)); }
                else if (_P == end())
                        {/*_Lockit Lk;*/
                        if (key_compare(_Key(_Rmost()), _Kfn()(_V)))
                                return (_Insert(_Nil, _Rmost(), _V)); }
                else
                        {iterator _Pb = _P;
                        if (key_compare(_Key((--_Pb)._Mynode()), _Kfn()(_V))
                                && key_compare(_Kfn()(_V), _Key(_P._Mynode())))
                                {/*_Lockit _Lk;*/
                                if (_Right(_Pb._Mynode()) == _Nil)
                                        return (_Insert(_Nil, _Pb._Mynode(), _V));
                                else
                                        return (_Insert(_Head, _P._Mynode(), _V)); }}
                return (insert(_V).first); }
        void insert(iterator _F, iterator _L)
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        void insert(const value_type *_F, const value_type *_L)
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        iterator erase(iterator _P)
                {_Nodeptr _X;
                _Nodeptr _Y = (_P++)._Mynode();
                _Nodeptr _Z = _Y;
                /*_Lockit _Lk;*/
                if (_Left(_Y) == _Nil)
                        _X = _Right(_Y);
                else if (_Right(_Y) == _Nil)
                        _X = _Left(_Y);
                else
                        _Y = _Min(_Right(_Y)), _X = _Right(_Y);
                if (_Y != _Z)
                        {_Parent(_Left(_Z)) = _Y;
                        _Left(_Y) = _Left(_Z);
                        if (_Y == _Right(_Z))
                                _Parent(_X) = _Y;
                        else
                                {_Parent(_X) = _Parent(_Y);
                                _Left(_Parent(_Y)) = _X;
                                _Right(_Y) = _Right(_Z);
                                _Parent(_Right(_Z)) = _Y; }
                        if (_Root() == _Z)
                                _Root() = _Y;
                        else if (_Left(_Parent(_Z)) == _Z)
                                _Left(_Parent(_Z)) = _Y;
                        else
                                _Right(_Parent(_Z)) = _Y;
                        _Parent(_Y) = _Parent(_Z);
                        std::swap(_Color(_Y), _Color(_Z));
                        _Y = _Z; }
                else
                        {_Parent(_X) = _Parent(_Y);
                        if (_Root() == _Z)
                                _Root() = _X;
                        else if (_Left(_Parent(_Z)) == _Z)
                                _Left(_Parent(_Z)) = _X;
                        else
                                _Right(_Parent(_Z)) = _X;
                        if (_Lmost() != _Z)
                                ;
                        else if (_Right(_Z) == _Nil)
                                _Lmost() = _Parent(_Z);
                        else
                                _Lmost() = _Min(_X);
                        if (_Rmost() != _Z)
                                ;
                        else if (_Left(_Z) == _Nil)
                                _Rmost() = _Parent(_Z);
                        else
                                _Rmost() = _Max(_X); }
                if (_Color(_Y) == _Black)
                        {while (_X != _Root() && _Color(_X) == _Black)
                                if (_X == _Left(_Parent(_X)))
                                        {_Nodeptr _W = _Right(_Parent(_X));
                                        if (_Color(_W) == _Red)
                                                {_Color(_W) = _Black;
                                                _Color(_Parent(_X)) = _Red;
                                                _Lrotate(_Parent(_X));
                                                _W = _Right(_Parent(_X)); }
                                        if (_Color(_Left(_W)) == _Black
                                                && _Color(_Right(_W)) == _Black)
                                                {_Color(_W) = _Red;
                                                _X = _Parent(_X); }
                                        else
                                                {if (_Color(_Right(_W)) == _Black)
                                                        {_Color(_Left(_W)) = _Black;
                                                        _Color(_W) = _Red;
                                                        _Rrotate(_W);
                                                        _W = _Right(_Parent(_X)); }
                                                _Color(_W) = _Color(_Parent(_X));
                                                _Color(_Parent(_X)) = _Black;
                                                _Color(_Right(_W)) = _Black;
                                                _Lrotate(_Parent(_X));
                                                break; }}
                                else
                                        {_Nodeptr _W = _Left(_Parent(_X));
                                        if (_Color(_W) == _Red)
                                                {_Color(_W) = _Black;
                                                _Color(_Parent(_X)) = _Red;
                                                _Rrotate(_Parent(_X));
                                                _W = _Left(_Parent(_X)); }
                                        if (_Color(_Right(_W)) == _Black
                                                && _Color(_Left(_W)) == _Black)
                                                {_Color(_W) = _Red;
                                                _X = _Parent(_X); }
                                        else
                                                {if (_Color(_Left(_W)) == _Black)
                                                        {_Color(_Right(_W)) = _Black;
                                                        _Color(_W) = _Red;
                                                        _Lrotate(_W);
                                                        _W = _Left(_Parent(_X)); }
                                                _Color(_W) = _Color(_Parent(_X));
                                                _Color(_Parent(_X)) = _Black;
                                                _Color(_Left(_W)) = _Black;
                                                _Rrotate(_Parent(_X));
                                                break; }}
                        _Color(_X) = _Black; }
                _Destval(&_Value(_Y));
                _Freenode(_Y);
                --_Size;
                return (_P); }
        iterator erase(iterator _F, iterator _L)
                {if (size() == 0 || _F != begin() || _L != end())
                        {while (_F != _L)
                                erase(_F++);
                        return (_F); }
                else
                        {/*_Lockit Lk;*/
                        _Erase(_Root());
                        _Root() = _Nil, _Size = 0;
                        _Lmost() = _Head, _Rmost() = _Head;
                        return (begin()); }}
        size_type erase(const _K& _X)
                {_Pairii _P = equal_range(_X);
                size_type _N = 0;
                _Distance(_P.first, _P.second, _N);
                erase(_P.first, _P.second);
                return (_N); }
        void erase(const _K *_F, const _K *_L)
                {for (; _F != _L; ++_F)
                        erase(*_F); }
        void clear()
                {erase(begin(), end()); }
        iterator find(const _K& _Kv)
                {iterator _P = lower_bound(_Kv);
                return (_P == end()
                        || key_compare(_Kv, _Key(_P._Mynode()))
                                ? end() : _P); }
        const_iterator find(const _K& _Kv) const
                {const_iterator _P = lower_bound(_Kv);
                return (_P == end()
                        || key_compare(_Kv, _Key(_P._Mynode()))
                                ? end() : _P); }
        size_type count(const _K& _Kv) const
                {_Paircc _Ans = equal_range(_Kv);
                size_type _N = 0;
                _Distance(_Ans.first, _Ans.second, _N);
                return (_N); }
        iterator lower_bound(const _K& _Kv)
                {return (iterator(_Lbound(_Kv))); }
        const_iterator lower_bound(const _K& _Kv) const
                {return (const_iterator(_Lbound(_Kv))); }
        iterator upper_bound(const _K& _Kv)
                {return (iterator(_Ubound(_Kv))); }
        const_iterator upper_bound(const _K& _Kv) const
                {return (iterator(_Ubound(_Kv))); }
        _Pairii equal_range(const _K& _Kv)
                {return (_Pairii(lower_bound(_Kv), upper_bound(_Kv))); }
        _Paircc equal_range(const _K& _Kv) const
                {return (_Paircc(lower_bound(_Kv), upper_bound(_Kv))); }
        void swap(_Myt& _X)
                {std::swap(key_compare, _X.key_compare);
                if (allocator == _X.allocator)
                        {std::swap(_Head, _X._Head);
                        std::swap(_Multi, _X._Multi);
                        std::swap(_Size, _X._Size); }
                else
                        {_Myt _Ts = *this; *this = _X, _X = _Ts; }}
        friend void swap(_Myt& _X, _Myt& _Y)
                {_X.swap(_Y); }
protected:
        static _Nodeptr _Nil;
        static size_t _Nilrefs;
        void _Copy(const _Myt& _X)
                {/*_Lockit _Lk;*/
                _Root() = _Copy(_X._Root(), _Head);
                _Size = _X.size();
                if (_Root() != _Nil)
                        {_Lmost() = _Min(_Root());
                        _Rmost() = _Max(_Root()); }
                else
                        _Lmost() = _Head, _Rmost() = _Head; }
        _Nodeptr _Copy(_Nodeptr _X, _Nodeptr _P)
                {/*_Lockit _Lk;*/
                _Nodeptr _R = _X;
                for (; _X != _Nil; _X = _Left(_X))
                        {_Nodeptr _Y = _Buynode(_P, _Color(_X));
                        if (_R == _X)
                                _R = _Y;
                        _Right(_Y) = _Copy(_Right(_X), _Y);
                        _Consval(&_Value(_Y), _Value(_X));
                        _Left(_P) = _Y;
                        _P = _Y; }
                _Left(_P) = _Nil;
                return (_R); }
        void _Erase(_Nodeptr _X)
                {/*_Lockit _Lk;*/
                for (_Nodeptr _Y = _X; _Y != _Nil; _X = _Y)
                        {_Erase(_Right(_Y));
                        _Y = _Left(_Y);
                        _Destval(&_Value(_X));
                        _Freenode(_X); }}
        void _Init()
                {/*_Lockit _Lk;*/
                if (_Nil == 0)
                        {_Nil = _Buynode(0, _Black);
                        _Left(_Nil) = 0, _Right(_Nil) = 0; }
                ++_Nilrefs;
                _Head = _Buynode(_Nil, _Red), _Size = 0;
                _Lmost() = _Head, _Rmost() = _Head; }
        iterator _Insert(_Nodeptr _X, _Nodeptr _Y, const _Ty& _V)
                {/*_Lockit _Lk;*/
                _Nodeptr _Z = _Buynode(_Y, _Red);
                _Left(_Z) = _Nil, _Right(_Z) = _Nil;
                _Consval(&_Value(_Z), _V);
                ++_Size;
                if (_Y == _Head || _X != _Nil
                        || key_compare(_Kfn()(_V), _Key(_Y)))
                        {_Left(_Y) = _Z;
                        if (_Y == _Head)
                                {_Root() = _Z;
                                _Rmost() = _Z; }
                        else if (_Y == _Lmost())
                                _Lmost() = _Z; }
                else
                        {_Right(_Y) = _Z;
                        if (_Y == _Rmost())
                                _Rmost() = _Z; }
                for (_X = _Z; _X != _Root()
                        && _Color(_Parent(_X)) == _Red; )
                        if (_Parent(_X) == _Left(_Parent(_Parent(_X))))
                                {_Y = _Right(_Parent(_Parent(_X)));
                                if (_Color(_Y) == _Red)
                                        {_Color(_Parent(_X)) = _Black;
                                        _Color(_Y) = _Black;
                                        _Color(_Parent(_Parent(_X))) = _Red;
                                        _X = _Parent(_Parent(_X)); }
                                else
                                        {if (_X == _Right(_Parent(_X)))
                                                {_X = _Parent(_X);
                                                _Lrotate(_X); }
                                        _Color(_Parent(_X)) = _Black;
                                        _Color(_Parent(_Parent(_X))) = _Red;
                                        _Rrotate(_Parent(_Parent(_X))); }}
                        else
                                {_Y = _Left(_Parent(_Parent(_X)));
                                if (_Color(_Y) == _Red)
                                        {_Color(_Parent(_X)) = _Black;
                                        _Color(_Y) = _Black;
                                        _Color(_Parent(_Parent(_X))) = _Red;
                                        _X = _Parent(_Parent(_X)); }
                                else
                                        {if (_X == _Left(_Parent(_X)))
                                                {_X = _Parent(_X);
                                                _Rrotate(_X); }
                                        _Color(_Parent(_X)) = _Black;
                                        _Color(_Parent(_Parent(_X))) = _Red;
                                        _Lrotate(_Parent(_Parent(_X))); }}
                _Color(_Root()) = _Black;
                return (iterator(_Z)); }
        _Nodeptr _Lbound(const _K& _Kv) const
                {/*_Lockit _Lk;*/
                _Nodeptr _X = _Root();
                _Nodeptr _Y = _Head;
                while (_X != _Nil)
                        if (key_compare(_Key(_X), _Kv))
                                _X = _Right(_X);
                        else
                                _Y = _X, _X = _Left(_X);
                return (_Y); }
        _Nodeptr& _Lmost()
                {return (_Left(_Head)); }
        _Nodeptr& _Lmost() const
                {return (_Left(_Head)); }
        void _Lrotate(_Nodeptr _X)
                {/*_Lockit _Lk;*/
                _Nodeptr _Y = _Right(_X);
                _Right(_X) = _Left(_Y);
                if (_Left(_Y) != _Nil)
                        _Parent(_Left(_Y)) = _X;
                _Parent(_Y) = _Parent(_X);
                if (_X == _Root())
                        _Root() = _Y;
                else if (_X == _Left(_Parent(_X)))
                        _Left(_Parent(_X)) = _Y;
                else
                        _Right(_Parent(_X)) = _Y;
                _Left(_Y) = _X;
                _Parent(_X) = _Y; }
        static _Nodeptr _Max(_Nodeptr _P)
                {/*_Lockit _Lk;*/
                while (_Right(_P) != _Nil)
                        _P = _Right(_P);
                return (_P); }
        static _Nodeptr _Min(_Nodeptr _P)
                {/*_Lockit _Lk;*/
                while (_Left(_P) != _Nil)
                        _P = _Left(_P);
                return (_P); }
        _Nodeptr& _Rmost()
                {return (_Right(_Head)); }
        _Nodeptr& _Rmost() const
                {return (_Right(_Head)); }
        _Nodeptr& _Root()
                {return (_Parent(_Head)); }
        _Nodeptr& _Root() const
                {return (_Parent(_Head)); }
        void _Rrotate(_Nodeptr _X)
                {/*_Lockit _Lk;*/
                _Nodeptr _Y = _Left(_X);
                _Left(_X) = _Right(_Y);
                if (_Right(_Y) != _Nil)
                        _Parent(_Right(_Y)) = _X;
                _Parent(_Y) = _Parent(_X);
                if (_X == _Root())
                        _Root() = _Y;
                else if (_X == _Right(_Parent(_X)))
                        _Right(_Parent(_X)) = _Y;
                else
                        _Left(_Parent(_X)) = _Y;
                _Right(_Y) = _X;
                _Parent(_X) = _Y; }
        _Nodeptr _Ubound(const _K& _Kv) const
                {/*_Lockit _Lk;*/
                _Nodeptr _X = _Root();
                _Nodeptr _Y = _Head;
                while (_X != _Nil)
                        if (key_compare(_Kv, _Key(_X)))
                                _Y = _X, _X = _Left(_X);
                        else
                                _X = _Right(_X);
                return (_Y); }
        _Nodeptr _Buynode(_Nodeptr _Parg, _Redbl _Carg)
                {_Nodeptr _S = (_Nodeptr)allocator._Charalloc(
                        1 * sizeof (_Node));
                _Parent(_S) = _Parg;
                _Color(_S) = _Carg;
                return (_S); }
        void _Consval(_Tptr _P, const _Ty& _V)
                {_Construct(&*_P, _V); }
        void _Destval(_Tptr _P)
                {_Destroy(&*_P); }
        void _Freenode(_Nodeptr _S)
                {allocator.deallocate(_S, 1); }
        _A allocator;
        _Pr key_compare;
        _Nodeptr _Head;
        bool _Multi;
        size_type _Size;
        };
template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
        _SEOTree<_K, _Ty, _Kfn, _Pr, _A>::_Nodeptr
                _SEOTree<_K, _Ty, _Kfn, _Pr, _A>::_Nil = 0;
template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
        size_t _SEOTree<_K, _Ty, _Kfn, _Pr, _A>::_Nilrefs = 0;
                // tree TEMPLATE OPERATORS
template<class _K, class _Ty, class _Kfn,
        class _Pr, class _A> inline
        bool operator==(const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
        {return (_X.size() == _Y.size()
                && equal(_X.begin(), _X.end(), _Y.begin())); }
template<class _K, class _Ty, class _Kfn,
        class _Pr, class _A> inline
        bool operator!=(const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
        {return (!(_X == _Y)); }
template<class _K, class _Ty, class _Kfn,
        class _Pr, class _A> inline
        bool operator<(const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
        {return (lexicographical_compare(_X.begin(), _X.end(),
                _Y.begin(), _Y.end())); }
template<class _K, class _Ty, class _Kfn,
        class _Pr, class _A> inline
        bool operator>(const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
        {return (_Y < _X); }
template<class _K, class _Ty, class _Kfn,
        class _Pr, class _A> inline
        bool operator<=(const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
        {return (!(_Y < _X)); }
template<class _K, class _Ty, class _Kfn,
        class _Pr, class _A> inline
        bool operator>=(const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _SEOTree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
        {return (!(_X < _Y)); }
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _SEOTREE_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include "windows.h"
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CSEOComModule : public CComModule {
	public:
		const GUID *GetAPPID();
		HRESULT WriteAPPID();
		HRESULT EraseAPPID();
};
extern CSEOComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CSEOComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\subdict.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	subdict.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Sub-Dictionary class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/09/97	created

--*/


// subdict.cpp : Implementation of CSEOSubDictionary
#include "stdafx.h"
#include "seodefs.h"
#include "subdict.h"


#define SSA(x)	((x)?(x):"")
#define SSW(x)	((x)?(x):L"")


#define _ALLOC_NAME_A(prefix,suffix)	(LPSTR) _alloca((strlen((prefix))+strlen((suffix))+1)*sizeof(CHAR))
inline LPSTR CopyNameA(LPSTR pszDest, LPCSTR pszPrefix, LPCSTR pszSuffix) {

	strcpy(pszDest,pszPrefix);
	strcat(pszDest,pszSuffix);
	return (pszDest);
}
#define ALLOC_NAME_A(prefix,suffix)	CopyNameA(_ALLOC_NAME_A(SSA(prefix),SSA(suffix)),SSA(prefix),SSA(suffix))

#define _ALLOC_NAME_W(prefix,suffix)	(LPWSTR) _alloca((wcslen((prefix))+wcslen((suffix))+1)*sizeof(WCHAR))
inline LPWSTR CopyNameW(LPWSTR pszDest, LPCWSTR pszPrefix, LPCWSTR pszSuffix) {

	wcscpy(pszDest,pszPrefix);
	wcscat(pszDest,pszSuffix);
	return (pszDest);
}
#define ALLOC_NAME_W(prefix,suffix)	CopyNameW(_ALLOC_NAME_W(SSW(prefix),SSW(suffix)),SSW(prefix),SSW(suffix))

#ifdef UNICODE
	#define ALLOC_NAME_T	ALLOC_NAME_W
#else
	#define ALLOC_NAME_T	ALLOC_NAME_A
#endif
#define ALLOC_NAME_OLE	ALLOC_NAME_W


HRESULT MakeNameAsVariant(VARIANT *pvarResult, VARIANT *pvarName, LPWSTR pszPrefix) {
	HRESULT hrRes;
	BSTR bstrTmp;

	VariantInit(pvarResult);
	if (pvarName && (pvarName->vt != VT_ERROR)) {
		hrRes = VariantChangeType(pvarResult,pvarName,0,VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	} else {
		pvarResult->bstrVal = SysAllocString(L"");
		if (!pvarResult->bstrVal) {
			return (E_OUTOFMEMORY);
		}
	}
	bstrTmp = SysAllocStringLen(pvarResult->bstrVal,
								wcslen(pvarResult->bstrVal)+wcslen(pszPrefix?pszPrefix:L"")+1);
	if (!bstrTmp) {
		VariantClear(pvarResult);
		return (E_OUTOFMEMORY);
	}
	wcscat(bstrTmp,pszPrefix);
	SysFreeString(pvarResult->bstrVal);
	pvarResult->bstrVal = bstrTmp;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CSEOSubDictionary


HRESULT CSEOSubDictionary::FinalConstruct() {
	HRESULT hrRes;
	TraceFunctEnter("CSEOSubDictionary::FinalConstruct");

	m_pszPrefixA = NULL;
	m_pszPrefixW = NULL;
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOSubDictionary::FinalRelease() {
	TraceFunctEnter("CSEOSubDictionary::FinalRelease");

	m_pdictBase.Release();
	if (m_pszPrefixA) {
		CoTaskMemFree(m_pszPrefixA);
		m_pszPrefixA = NULL;
	}
	if (m_pszPrefixW) {
		CoTaskMemFree(m_pszPrefixW);
		m_pszPrefixW = NULL;
	}
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CSEOSubDictionary::SetBaseA(ISEODictionary *pdictBase, LPCSTR pszPrefix) {

	if (m_pszPrefixA) {
		CoTaskMemFree(m_pszPrefixA);
		m_pszPrefixA = NULL;
	}
	if (m_pszPrefixW) {
		CoTaskMemFree(m_pszPrefixW);
		m_pszPrefixW = NULL;
	}
	m_pdictBase.Release();
	if (pszPrefix) {
		DWORD dwLen = strlen(pszPrefix);

		m_pszPrefixA = (LPSTR) CoTaskMemAlloc((dwLen+1)*sizeof(CHAR));
		if (!m_pszPrefixA) {
			return (E_OUTOFMEMORY);
		}
		m_pszPrefixW = (LPWSTR) CoTaskMemAlloc((dwLen+2)*sizeof(WCHAR));
		if (!m_pszPrefixW) {
			CoTaskMemFree(m_pszPrefixA);
			m_pszPrefixA = NULL;
			return (E_OUTOFMEMORY);
		}
		strcpy(m_pszPrefixA,pszPrefix);
		MultiByteToWideChar(CP_ACP,0,pszPrefix,-1,m_pszPrefixW,dwLen+1);
		m_pdictBase = pdictBase;
	}
	return (S_OK);
}


HRESULT CSEOSubDictionary::SetBaseW(ISEODictionary *pdictBase, LPCWSTR pszPrefix) {

	if (m_pszPrefixA) {
		CoTaskMemFree(m_pszPrefixA);
		m_pszPrefixA = NULL;
	}
	if (m_pszPrefixW) {
		CoTaskMemFree(m_pszPrefixW);
		m_pszPrefixW = NULL;
	}
	m_pdictBase.Release();
	if (pszPrefix) {
		DWORD dwLen = wcslen(pszPrefix);

		m_pszPrefixA = (LPSTR) CoTaskMemAlloc((dwLen+2)*sizeof(CHAR));
		if (!m_pszPrefixA) {
			return (E_OUTOFMEMORY);
		}
		m_pszPrefixW = (LPWSTR) CoTaskMemAlloc((dwLen+1)*sizeof(WCHAR));
		if (!m_pszPrefixW) {
			CoTaskMemFree(m_pszPrefixA);
			m_pszPrefixA = NULL;
			return (E_OUTOFMEMORY);
		}
		WideCharToMultiByte(CP_ACP,0,pszPrefix,-1,m_pszPrefixA,dwLen+1,NULL,NULL);
		wcscpy(m_pszPrefixW,pszPrefix);
		m_pdictBase = pdictBase;
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::get_Item(VARIANT *pvarName, VARIANT *pvarResult) {
	VARIANT varTmp;
	HRESULT hrRes;

	if (!pvarResult) {
		return (E_POINTER);
	}
	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	hrRes = MakeNameAsVariant(&varTmp,pvarName,m_pszPrefixW);
	if (!SUCCEEDED(hrRes)) {
		VariantInit(pvarResult);
		return (hrRes);
	}
	hrRes = m_pdictBase->get_Item(&varTmp,pvarResult);
	VariantClear(&varTmp);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::put_Item(VARIANT *pvarName, VARIANT *pvarValue) {
	VARIANT varTmp;
	HRESULT hrRes;

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	hrRes = MakeNameAsVariant(&varTmp,pvarName,m_pszPrefixW);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = m_pdictBase->put_Item(&varTmp,pvarValue);
	VariantClear(&varTmp);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::get__NewEnum(IUnknown **ppunkResult) {

	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetVariantA(LPCSTR pszName, VARIANT *pvarResult) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetVariantA(pszTmp,pvarResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetVariantW(LPCWSTR pszName, VARIANT *pvarResult) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetVariantW(pszTmp,pvarResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetVariantA(LPCSTR pszName, VARIANT *pvarValue) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetVariantA(pszTmp,pvarValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetVariantW(LPCWSTR pszName, VARIANT *pvarValue) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetVariantW(pszTmp,pvarValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetStringA(LPCSTR pszName, DWORD *pchCount, LPSTR pszResult) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetStringA(pszTmp,pchCount,pszResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetStringW(LPCWSTR pszName, DWORD *pchCount, LPWSTR pszResult) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetStringW(pszTmp,pchCount,pszResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetStringA(LPCSTR pszName, DWORD chCount, LPCSTR pszValue) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetStringA(pszTmp,chCount,pszValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetStringW(LPCWSTR pszName, DWORD chCount, LPCWSTR pszValue) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetStringW(pszTmp,chCount,pszValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetDWordA(LPCSTR pszName, DWORD *pdwResult) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetDWordA(pszTmp,pdwResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetDWordW(LPCWSTR pszName, DWORD *pdwResult) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetDWordW(pszTmp,pdwResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetDWordA(LPCSTR pszName, DWORD dwValue) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetDWordA(pszTmp,dwValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetDWordW(LPCWSTR pszName, DWORD dwValue) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetDWordW(pszTmp,dwValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetInterfaceA(LPCSTR pszName, REFIID iidDesired, IUnknown **ppunkResult) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetInterfaceA(pszTmp,iidDesired,ppunkResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetInterfaceW(LPCWSTR pszName, REFIID iidDesired, IUnknown **ppunkResult) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetInterfaceW(pszTmp,iidDesired,ppunkResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetInterfaceA(LPCSTR pszName, IUnknown *punkValue) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetInterfaceA(pszTmp,punkValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetInterfaceW(LPCWSTR pszName, IUnknown *punkValue) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetInterfaceW(pszTmp,punkValue));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\idl\makefile.inc ===
$(O)\seo.h : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(MIDL_TLBDIR)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\dll\makefile.inc ===
$(O)\seo.h : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(MIDL_TLBDIR)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\lib\makefile.inc ===
$(O)\seo.h : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(MIDL_TLBDIR)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\subdict.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	subdict.h

Abstract:

	This module contains the definition for the Server
	Extension Object Sub-Dictionary class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/09/97	created

--*/


// item.h : Declaration of the CSEOSubDictionary

/////////////////////////////////////////////////////////////////////////////
// CSEOSubDictionary
class ATL_NO_VTABLE CSEOSubDictionary : 
	public CComObjectRoot,
//	public CComCoClass<CSEOSubDictionary, &CLSID_CSEOSubDictionary>,
	public IDispatchImpl<ISEODictionary, &IID_ISEODictionary, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"SEOSubDictionary Class",
//								   L"SEO.SEOSubDictionary.1",
//								   L"SEO.SEOSubDictionary");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOSubDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
		COM_INTERFACE_ENTRY(IDispatch)
//		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEODictionary
	public:
		HRESULT STDMETHODCALLTYPE get_Item(VARIANT *pvarName, VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE put_Item(VARIANT *pvarName, VARIANT *pvarValue);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppunkResult);
		HRESULT STDMETHODCALLTYPE GetVariantA(LPCSTR pszName, VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE GetVariantW(LPCWSTR pszName, VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE SetVariantA(LPCSTR pszName, VARIANT *pvarValue);
		HRESULT STDMETHODCALLTYPE SetVariantW(LPCWSTR pszName, VARIANT *pvarValue);
		HRESULT STDMETHODCALLTYPE GetStringA(LPCSTR pszName, DWORD *pchCount, LPSTR pszResult);
		HRESULT STDMETHODCALLTYPE GetStringW(LPCWSTR pszName, DWORD *pchCount, LPWSTR pszResult);
		HRESULT STDMETHODCALLTYPE SetStringA(LPCSTR pszName, DWORD chCount, LPCSTR pszValue);
		HRESULT STDMETHODCALLTYPE SetStringW(LPCWSTR pszName, DWORD chCount, LPCWSTR pszValue);
		HRESULT STDMETHODCALLTYPE GetDWordA(LPCSTR pszName, DWORD *pdwResult);
		HRESULT STDMETHODCALLTYPE GetDWordW(LPCWSTR pszName, DWORD *pdwResult);
		HRESULT STDMETHODCALLTYPE SetDWordA(LPCSTR pszName, DWORD dwValue);
		HRESULT STDMETHODCALLTYPE SetDWordW(LPCWSTR pszName, DWORD dwValue);
		HRESULT STDMETHODCALLTYPE GetInterfaceA(LPCSTR pszName, REFIID iidDesired, IUnknown **ppunkResult);
		HRESULT STDMETHODCALLTYPE GetInterfaceW(LPCWSTR pszName, REFIID iidDesired, IUnknown **ppunkResult);
		HRESULT STDMETHODCALLTYPE SetInterfaceA(LPCSTR pszName, IUnknown *punkValue);
		HRESULT STDMETHODCALLTYPE SetInterfaceW(LPCWSTR pszName, IUnknown *punkValue);

	// CSEOSubDictionary
	public:
		HRESULT SetBaseA(ISEODictionary *pdictBase, LPCSTR pszPrefix);
		HRESULT SetBaseW(ISEODictionary *pdictBase, LPCWSTR pszPrefix);

	private:
		CComPtr<ISEODictionary> m_pdictBase;
		LPSTR m_pszPrefixA;
		LPWSTR m_pszPrefixW;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\sampprnt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SampPrnt.rc
//
#define IDS_PROJNAME	100
#define IDR_SEOSamplePrintExt			101



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\sampprnt\printer.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	printer.cpp

Abstract:

	This module contains the implementation for a sample Server
	Extension Object which simply prints the properties of each Event.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   01/09/97        created

--*/

#include "stdafx.h"

#include <stdio.h>

#include "SampPrnt.h"
#include "PRINTER.h"
#include "SEO.H"
#include "..\SEOUtils.h"

#define TAB_SIZE  (4)


/////////////////////////////////////////////////////////////////////////////
// CSEOSamplePrintExt

void PrintBag(ISEODictionary *pBag, int indent) {
	if(!pBag) return; // Nothing to print

	char str[200]; // Buffer for printing debug strings
	LPSTR indentSpaces = (LPSTR) _alloca(1 + (indent * TAB_SIZE));

	indentSpaces[0] = 0; // Terminate string
	for(int j = indent * TAB_SIZE; j > 0; --j) lstrcat(indentSpaces, " ");

	CComPtr<IUnknown> piUnk;
	HRESULT hr = pBag->get__NewEnum(&piUnk);
	if(FAILED(hr) || !piUnk) return;
	CComQIPtr<IEnumVARIANT, &IID_IEnumVARIANT> pieEnum = piUnk;
	piUnk.Release(); // Done with piUnk - use pieEnum now
	if(!pieEnum) return;

	DWORD dwResult = 0; // Number actually retrieved (should be 1 or 0 for us)
	CComVariant varDest; // Hold the current result

	// Read in and print all of the properties
	while(SUCCEEDED(pieEnum->Next(1, &varDest, &dwResult)) && dwResult) {
		if(varDest.vt == VT_UNKNOWN) {  // It's a sub-bag
			wsprintf(str, "%hs(Subkey)\n", indentSpaces); // Print it
			OutputDebugString(str);
			PrintBag(GetDictionary(varDest.punkVal), indent + 1);
		} else {
			hr = varDest.ChangeType(VT_BSTR); // Try to get a printable format

			if(SUCCEEDED(hr) && (varDest.vt == VT_BSTR)) { // If coercion worked
				wsprintf(str, "%hsValue: %lS\n", indentSpaces, varDest.bstrVal); // Print it
				OutputDebugString(str);
			}
		}

		varDest.Clear();
	}
}

HRESULT STDMETHODCALLTYPE CSEOSamplePrintExt::OnMessage(ISEODictionary __RPC_FAR *piMessage) {
	PrintBag(piMessage, 0);
	OutputDebugString("\nDone.\n");
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\sampprnt\printer.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	regprop.h

Abstract:

	This module contains the definition for the Server
	Extension Object Registry Property Bag.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	11/26/96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CSEOSamplePrintExt
// {DB2A6930-68AF-11d0-8B88-00C04FD42E37}

class CSEOSamplePrintExt : 
	public CComObjectRoot,
	public CComCoClass<CSEOSamplePrintExt, &CLSID_CSEOSamplePrintExt>,
	public IDispatchImpl<ISEOMessageFilter, &IID_ISEOMessageFilter, &LIBID_SampPrntLib>
{
	public:

	DECLARE_STATIC_REGISTRY_RESOURCEID(IDR_SEOSamplePrintExt)

	BEGIN_COM_MAP(CSEOSamplePrintExt)
		COM_INTERFACE_ENTRY(ISEOMessageFilter)
	END_COM_MAP()

	// CSEOSamplePrintExt
	public:
		HRESULT STDMETHODCALLTYPE OnMessage(ISEODictionary __RPC_FAR *piMessage);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\sampprnt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\lib\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include "windows.h"
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\sampprnt\sampprnt.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	SampPrnt.cpp

Abstract:

	This module contains a sample implementation of a Server
	Extension Object.  This sample merely prints the properties
	of the event it is given.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   1/06/97        created

--*/


// SampPrnt.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 or higher in order to build 
// this project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL, 
//              <<TBD>>.

#include "stdafx.h"

#include "resource.h"
#include "SampPrnt.h"
#include "printer.h"

#include "SampPrnt_i.c" // OLE Definitions
#include "..\seo_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_CSEOSamplePrintExt, CSEOSamplePrintExt)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		_Module.Init(ObjectMap,hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
		_Module.Term();
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {

	return ((_Module.GetLockCount()==0)?S_OK:S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {

	return (_Module.GetClassObject(rclsid,riid,ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {

	// registers object, typelib and all interfaces in typelib
	return (_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {

	_Module.UnregisterServer();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\sampprnt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently



#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\lib\seolib.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolib.cpp

Abstract:

	This module contains the implementations for various
	utility classes and functions of the Server	Extension
	Object system.

Author:

	Don Dumitru (dondu@microsoft.com)

Revision History:

	dondu	05/20/97	Created.

--*/


#include "stdafx.h"
#include "seo.h"
#include "seolib.h"


CEventBaseDispatcher::CEventBaseDispatcher() {

	// nothing
}


CEventBaseDispatcher::~CEventBaseDispatcher() {

	// nothing
}


CEventBaseDispatcher::CBinding::CBinding() {

	m_bIsValid = FALSE;
}


CEventBaseDispatcher::CBinding::~CBinding() {

	// nothing
}


HRESULT CEventBaseDispatcher::CBinding::Init(IEventBinding *piBinding) {
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pProps;
	CComVariant varValue;

	if (!piBinding) {
		return (E_POINTER);
	}
	varValue.vt = VT_BOOL;
	hrRes = piBinding->get_Enabled(&varValue.boolVal);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_bIsValid = varValue.boolVal ? TRUE: FALSE;
	varValue.Clear();
	m_dwPriority = (DWORD) PRIO_DEFAULT;
	m_bExclusive = FALSE;
	m_piBinding = piBinding;
	hrRes = piBinding->get_SourceProperties(&pProps);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pProps->Item(&CComVariant(L"Priority"),&varValue);
	if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
		hrRes = varValue.ChangeType(VT_I4);
		if (SUCCEEDED(hrRes)) {
			if (varValue.lVal < PRIO_MIN) {
				varValue.lVal = PRIO_MIN;
			} else if (varValue.lVal > PRIO_MAX) {
				varValue.lVal = PRIO_MAX;
			}
			m_dwPriority = (DWORD) varValue.lVal;
		} else {
			hrRes = varValue.ChangeType(VT_BSTR);
			if (SUCCEEDED(hrRes)) {
				static struct {
					LPCWSTR pszString;
					DWORD dwValue;
				} sConvert[] = {{PRIO_HIGHEST_STR,PRIO_HIGHEST},
								{PRIO_HIGH_STR,PRIO_HIGH},
								{PRIO_MEDIUM_STR,PRIO_MEDIUM},
								{PRIO_LOW_STR,PRIO_LOW},
								{PRIO_LOWEST_STR,PRIO_LOWEST},
								{PRIO_DEFAULT_STR,PRIO_DEFAULT},
								{NULL,0}};
				for (DWORD dwIdx=0;sConvert[dwIdx].pszString;dwIdx++) {
					if (_wcsicmp(varValue.bstrVal,sConvert[dwIdx].pszString) == 0) {
						m_dwPriority = sConvert[dwIdx].dwValue;
						break;
					}
				}
			}
		}
	}
	varValue.Clear();
	hrRes = pProps->Item(&CComVariant(L"Exclusive"),&varValue);
	if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
		hrRes = varValue.ChangeType(VT_BOOL);
		if (SUCCEEDED(hrRes)) {
			m_bExclusive = (varValue.boolVal ? TRUE : FALSE);
		}
	}
	hrRes = InitRuleEngine();
	// ignore result
	return (S_OK);
}


int CEventBaseDispatcher::CBinding::Compare(const CBinding& b) const {
    return (m_dwPriority - b.m_dwPriority);
}


HRESULT CEventBaseDispatcher::CBinding::InitRuleEngine(IEventBinding *piBinding, REFIID iidDesired, IUnknown **ppUnkRuleEngine) {
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pProperties;
	CComVariant varValue;
	CStringGUID objGuid;

	if (ppUnkRuleEngine) {
		*ppUnkRuleEngine = NULL;
	}
	if (!piBinding || !ppUnkRuleEngine) {
		return (E_POINTER);
	}
	hrRes = piBinding->get_SourceProperties(&pProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pProperties->Item(&CComVariant(L"RuleEngine"),&varValue);
	if (!SUCCEEDED(hrRes) || (hrRes == S_FALSE)) {
		return (hrRes);
	}
	hrRes = SEOCreateObject(&varValue,piBinding,pProperties,iidDesired,ppUnkRuleEngine);
	return (SUCCEEDED(hrRes)?S_OK:S_FALSE);
}


HRESULT CEventBaseDispatcher::CBinding::InitRuleEngine() {

	// default is to not to try to load a rule engine
	return (S_OK);
}


int CEventBaseDispatcher::CBindingList::Compare(CBinding* p1, CBinding* p2) {

	return (p1->Compare(*p2));
};


HRESULT CEventBaseDispatcher::CParams::CheckRule(CBinding& b) {

	// default behavior is to not pay attention to any "rules"
	return (S_OK);
}


HRESULT CEventBaseDispatcher::CParams::CallObject(IEventManager *piManager, CBinding& bBinding) {
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkSink;

	if (!piManager) {
		return (E_POINTER);
	}
	hrRes = piManager->CreateSink(bBinding.m_piBinding,NULL,&pUnkSink);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CallObject(bBinding,pUnkSink));
}


HRESULT CEventBaseDispatcher::CParams::CallObject(CBinding& bBinding, IUnknown *pUnkSink) {
	HRESULT hrRes;
	CComQIPtr<IEventSinkNotify,&IID_IEventSinkNotify> pSink;
	CComQIPtr<IDispatch,&IID_IEventSinkNotifyDisp> pSinkDisp;
	DISPPARAMS dpNoArgs = {NULL,NULL,0,0};

	// Default behavior is to call IEventSinkNotify::OnEvent, or to call
	// IEventSinkNotifyDisp::Invoke passing DISPID_VALUE (which maps to On